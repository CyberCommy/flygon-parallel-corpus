- en: Elements of Functional Programming Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an advanced chapter that focuses on the functional programming paradigm
    and design patterns that come from the functional programming world. It is high
    time to dive deep into why we have the option of creating stateless and stateful
    components. This comes down to understanding what pure functions are and how immutable
    objects help us to predict application behavior. Once we have clarified that,
    we will move on to higher-order functions and higher-order components. You have
    used them already many times, but this time we will look at them from a slightly
    different perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, I have challenged you with many concepts that will get
    much much clearer after reading this chapter. I hope you will embrace them in
    your applications and use them wisely, keeping in mind the maturity of your team.
    These patterns are good to know but are not essential to either React or React
    Native development. However, at some point when reading pull requests to the React
    or React Native repositories, you will find yourself referring back to this chapter
    quite often.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable and immutable structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific functions, such as pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Maybe` monad and the monad pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching and memorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutable and immutable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concept surprised me in one of my coding interviews. At the beginning of
    my career, I had little knowledge of mutable and immutable objects and it backfired
    without me even realizing the root cause.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml), *Store Patterns,*
    I explained the basics of mutability and immutability. We even used the `Immutable.js`
    library. That part of the book was heavily focused on the store. Now let's look
    at the bigger picture. Why do we even need mutable or immutable objects?
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the main reason is the ability to quickly reason about our application's
    behavior. For instance, React wants to quickly check whether it should re-render
    components. If you create object *A* and you are guaranteed that it won't ever
    change, then to reassure yourself that nothing changed, the only thing you need
    to do is compare the reference to the object. If it is the same as before, then
    object *A* remained unchanged. If object *A* could change, we would need to compare
    every single nested key within object *A* to be sure it remained unchanged. If
    object *A* had nested objects and we wanted to know whether those did not change,
    we would need to repeat the process for the nested objects. This is a lot of work,
    especially as object *A* grows. But why would we need to do it this way?
  prefs: []
  type: TYPE_NORMAL
- en: Immutable primitives in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JavaScript, primitive data types (number, string, Boolean, undefined, null,
    and symbol) are immutable. Objects are mutable. In addition, JavaScript is loosely
    typed; that means the variable does not need to be of a certain type. For instance,
    you may declare variable A and assign the number 5 to it, and then later decide
    to assign an object to it. JavaScript allows that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify things, the community has created two very important movements:'
  prefs: []
  type: TYPE_NORMAL
- en: Libraries that guarantee immutability of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static type-checkers for JavaScript, such as Flow or TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one provides functions to create objects that guarantee their immutability.
    This means that, whenever you want to change something within an object, it will
    clone itself, apply the change, and return a brand new immutable object.
  prefs: []
  type: TYPE_NORMAL
- en: The second, static type-checkers, primarily solves the problem of human error
    when developers accidentally try to assign a value of a different type than initially
    expected. Hence, if you declare `variableA` to be a number, you can never assign
    a string to it. To us, it means type immutability. If you want a different type,
    you need to create a new variable and map `variableA` to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important side note on the `const` keyword: `const` operates on the reference
    level. It forbids a reference change. The value of a constant variable cannot
    be reassigned and cannot be redeclared. With primitive immutable types, it simply
    means freezing them for life. You can never reassign a new value to the variable.
    Trying to assign a different value will also fail, because primitives are immutable
    and it simply means creating a brand new reference. With objects that are mutable
    types, it simply means freezing the object reference. We cannot reassign a new
    object to the variable, but we can change the contents of the object. This means
    we can mutate what is inside. This is not very useful.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability cost explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was first introduced to this concept, I started to scratch my head. How
    is it any faster? If you want to modify an object, you need to clone it and this
    is a serious cost with any simple change. I thought it was unacceptable. I assumed
    it was the same cost as if we were performing equality check on every level. I
    was both right and wrong.
  prefs: []
  type: TYPE_NORMAL
- en: It depends on the tools you use. Special data structures, such as Immutable.js,
    make numerous optimizations to work easily. However, if you clone your objects
    with the `spread` operator or `Object.assign()`, then you recreate the whole object
    again or unknowingly just clone one level deep.
  prefs: []
  type: TYPE_NORMAL
- en: '"For deep cloning, we need to use other alternatives because Object.assign()
    copies property values. If the source value is a reference to an object, it only
    copies that reference value."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Mozilla JavaScript Documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign).  "Spread
    syntax effectively goes one level deep while copying an array. Therefore, it may
    be unsuitable for copying multidimensional arrays [...] (it''s the same with Object.assign()
    and spread syntax)."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Mozilla JavaScript Documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Operators/Spread_syntax](https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Operators/Spread_syntax).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very convenient and we abuse this fact many times in React apps. Let''s
    look at this with an example. The following is the object we will perform operations
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will clone just one level deep, and then mutate something two levels
    deep in the cloned object. Observe what happens to the original object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is one of the gotchas of mutations. If you are not proficient enough to
    understand what is going on, you may generate bugs that are incredibly hard to
    fix. The question is, how do we clone two levels deep? See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you need to, you may use this technique to copy the whole object this way.
  prefs: []
  type: TYPE_NORMAL
- en: Copying just one level deep is often called a **shallow copy**.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmark on read/write operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To better understand the tradeoffs and which library to decide on for your specific
    use case, please have a look at the read and write operations benchmarks. This
    should serve as a general idea. Please run your own tests before making the final
    call.
  prefs: []
  type: TYPE_NORMAL
- en: I have used the benchmarks created by [ImmutableAssign authors](https://github.com/engineforce/ImmutableAssign/).
    The code automatically compares numerous libraries and approaches to solve immutability
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at pure JavaScript with just simple mutable structures.
    We do not care about any benefits, just use them as is for a benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Nearly-new MacBook Pro 15'''' (2018) with no background tasks | MacBook Pro
    15'''' (2016) with a few background tasks running |'
  prefs: []
  type: TYPE_TB
- en: '| **Mutable objects and arrays**  Object: read (x500000): 9 ms  Object: write
    (x100000): 3 ms  Object: very deep read (x500000): 31 ms  Object: very deep write
    (x100000): 9 ms  Object: merge (x100000): 17 ms  Array: read (x500000): 4 ms 
    Array: write (x100000): 3 ms  Array: deep read (x500000): 5 ms  Array: deep write
    (x100000): 2 ms  Total elapsed  49 ms (read) + **17 ms (write)** + 17 ms   (merge)
    = 83 ms. | **Mutable objects and arrays**  Object: read (x500000): 11 ms  Object:
    write (x100000): 4 ms  Object: very deep read (x500000): 42 ms  Object: very deep
    write (x100000): 12 ms  Object: merge (x100000): 17 ms  Array: read (x500000):
    7 ms  Array: write (x100000): 3 ms  Array: deep read (x500000): 7 ms  Array: deep
    write (x100000): 3 ms  Total elapsed  67 ms (read) + **22 ms (write)** + 17 ms
    (merge)  = 106 ms. |'
  prefs: []
  type: TYPE_TB
- en: In the parentheses, you can see a number of performed operations. It is incredibly
    fast. No immutable solution can outperform this benchmark, as it uses just mutable
    JS objects and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some things to spot are differences based on how deep we read. For instance,
    the object read (x500000) takes 11 ms, while the very deep object read (x500000)
    takes 42 ms, which is nearly 4x longer:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Nearly-new MacBook Pro 15'''' (2018) with no background tasks | MacBook Pro
    15'''' (2016) with a few background tasks running |'
  prefs: []
  type: TYPE_TB
- en: '| **Immutable objects and arrays (Object.assign)**  Object: read (x500000):
    13 ms  Object: write (x100000): 85 ms  Object: very deep read (x500000): 30 ms 
    Object: very deep write (x100000): 220 ms  Object: merge (x100000): 91 ms  Array:
    read (x500000): 7 ms  Array: write (x100000): 402 ms  Array: deep read (x500000):
    9 ms  Array: deep write (x100000): 400 ms  Total elapsed  59 ms(read)+**1107 ms(write)**+91
    ms(merge)  = 1257 ms. | **Immutable objects and arrays (Object.assign)**  Object:
    read (x500000): 19 ms  Object: write (x100000): 107 ms  Object: very deep read
    (x500000): 33 ms  Object: very deep write (x100000): 255 ms  Object: merge (x100000):
    136 ms  Array: read (x500000): 11 ms  Array: write (x100000): 547 ms  Array: deep
    read (x500000): 14 ms  Array: deep write (x100000): 504 ms  Total elapsed  77
    ms(read)+**1413 ms(write)**+136 ms(merge)  = 1626 ms. |'
  prefs: []
  type: TYPE_TB
- en: '`Object.assign` creates a spike on write operations. Now we see the cost of
    copying things that are not needed. The object write operation on a very deep
    level is close to 25 times more costly. An array deep write is 100 to 200 times
    slower than the mutable way:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Nearly-new MacBook Pro 15'''' (2018) with no background tasks | MacBook Pro
    15'''' (2016) with a few background tasks running |'
  prefs: []
  type: TYPE_TB
- en: '| **Immutable.js objects and arrays**  Object: read (x500000): 12 ms  Object:
    write (x100000): 19 ms  Object: very deep read (x500000): 111 ms  Object: very
    deep write (x100000): 80 ms  Object: merge (x100000): 716 ms  Array: read (x500000):
    18 ms  Array: write (x100000): 135 ms  Array: deep read (x500000): 51 ms  Array:
    deep write (x100000): 97 ms  Total elapsed  192 ms(read)+**331 ms(write)**+716  
    ms(merge)  = 1239 ms. | **Immutable.js objects and arrays**  Object: read (x500000):
    24 ms  Object: write (x100000): 52 ms  Object: very deep read (x500000): 178 ms 
    Object: very deep write (x100000): 125 ms  Object: merge (x100000): 1207 ms  Array:
    read (x500000): 24 ms  Array: write (x100000): 255 ms  Array: deep read (x500000):
    128 ms  Array: deep write (x100000): 137 ms  Total elapsed  354 ms(read)+**569
    ms(write)**+1207  ms(merge)  = 2130 ms. |'
  prefs: []
  type: TYPE_TB
- en: The object write is 6 times slower than the mutable way. A very deep object
    write is nearly 9 times slower than the mutable way, and 2.75 times faster than
    with `Object.assign()`. The merge operation, which constructs the object that
    is a result of merging the two objects passed as arguments, is much slower (42
    times slower than a mutable one or even 70 times slower if the user is using other
    programs).
  prefs: []
  type: TYPE_NORMAL
- en: Please pay attention to the hardware used. It is either a 2016 MacBook Pro or
    2018 MacBook Pro, which are both blazing-fast machines. Taking this to the mobile
    world will spike those benchmarks even more. The purpose of this section is to
    give you a general idea of how the numbers compare. Before you jump to a conclusion,
    please run your own tests on a specific hardware relevant to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we come back to the pure functions that we have already learned,
    but now from a different perspective. Do you remember that Redux tries to be as
    explicit as possible? There is a reason for that. Everything that is implicit
    is usually the root cause of troubles. Do you remember functions from math classes?
    Those are 100% explicit. There is nothing else happening other than transforming
    the input into some output.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, however, function can have implicit output. It may change a value,
    change an external system, and many many other things may happen outside of the
    function scope. You have already learned that in [Chapter 5,](ede13e51-3070-4b51-998b-80a2628af2d4.xhtml) *Store
    Patterns*. All such implicit output is usually referred to as side effects.
  prefs: []
  type: TYPE_NORMAL
- en: We need to address all of the different flavours of side effects. One of our
    weapons is immutability, which shields us from implicit external object changes.
    This is what immutability is for—it guarantees no such thing ever happens.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, we cannot eliminate all side effects by introducing weapons such
    as immutability. Some require the tools on the language level, which are not available.
    In functional programming languages such as Haskell, even input/output is controlled
    by a separate structure called `IO()`. In JavaScript, however, we need to deal
    with it on our own. This means we cannot avoid some functions being impure—as
    those need to take care of API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is randomness. Any function using `Math.random` cannot be considered
    pure, as some part of such functions rely on the random number generator, which
    defeats the purpose of pure functions. Once the function is invoked with certain
    arguments, you are not guaranteed to receive the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, everything that relies on time is impure. If your function execution
    relies on the month, day, second, or even year, it cannot be considered a pure
    function. At some point, the same argument will not give the same output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, it all comes down to the execution chain. If you want to say a
    subset of operations were pure, then you need to know that each one of them was
    pure. An minimalist example is a function that consumes another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we do not know what `someFunc` will be. If `someFunc` is impure,
    the `example` function will also be impure.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions in Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The good news is we can push side-effects to one place of our application and
    call them in a loop when we really need them. This is what Flux does. Redux embraces
    it even further, allowing only pure functions as reducers. This is understandable.
    Reducers are called when the impure part is already done. From there on, we can
    maintain immutability, at least in terms of the Redux stores.
  prefs: []
  type: TYPE_NORMAL
- en: Some may question whether this is a good choice in terms of performance. Trust
    me, it is. We have a really low number of events happening (that need to be reduced,
    and hence affect the store) in comparison with state accesses and selectors operating
    on the computed state.
  prefs: []
  type: TYPE_NORMAL
- en: In return for keeping the state immutable, we get a huge benefit. We can tell
    the order of the function application that led to this particular state. We can
    track it if we really need to. This is huge. We can apply those functions again
    in a test environment and we will be guaranteed that the output is exactly the
    same. This is thanks to the functions being pure—hence, no side-effects are generated.
  prefs: []
  type: TYPE_NORMAL
- en: Caching pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is a technique of remembering computations. If you are guaranteed that
    for certain arguments your function will always return the same value, you can
    safely compute it once and always return that computed value for these specific
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the trivial implementation that is usually brought up for teaching
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a powerful technique and is used in the reselect library.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions are **referentially transparent**, meaning that their function
    invocation can be replaced with its corresponding outcome for a given argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the examples of referentially-transparent and referentially-opaque
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s imagine a mathematical expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that you need to avoid such simplifications if your function is not
    referentially transparent. Expressions such as the preceding or `x() + x() * 0`
    are tempting gotchas.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you make any use of it or not is up to you. Also, see the *Further reading*
    section at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Everything but monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term monad has been infamous for many years. Not because it's an amazingly
    useful construct, but because of the complexity it introduces. There is also a
    common belief that once you understand monads, you lose the capability to explain
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '"In order to understand monads, you need to first learn Haskell and Category
    Theory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I think this is like saying: In order to understand burritos, you must first
    learn Spanish."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Douglas Crockford: Monads and Gonads (YUIConf Evening Keynote)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=dkZFtimgAcM](https://www.youtube.com/watch?v=dkZFtimgAcM).'
  prefs: []
  type: TYPE_NORMAL
- en: A monad is a way of composing functions despite special circumstances, such
    as nullable values, side-effects, computations, or just conditional execution.
    Such a definition of a monad makes it a context holder. That's why the monad of
    X is not equivalent to X. This X Before being treated as `monad<X>`, this X something needs
    to be lifted first, which simply means creation of the required context. If we
    do not need monad<X> anymore, we can flatten the structure to just X, which is
    the equivalent of losing a context.
  prefs: []
  type: TYPE_NORMAL
- en: It's like unwrapping a present for Christmas. You are pretty sure there is a
    present in there, but it depends on whether you were nice throughout the year.
    In some rare cases of misbehavior, you may end up with the stick or lump of coal
    in there. This is how the `Maybe<X>`  monad works. It may be X or nothing. It
    works great with nullable API values.
  prefs: []
  type: TYPE_NORMAL
- en: Call me Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one place in our code that begs for simplification. Take a look at
    the `taskSelector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We constantly fear whether we received something or null. This is a perfect
    case to delegate such work to the `Maybe` monad. Once we implement `Maybe`, the
    following code will be fully functional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, so far you know a little about the `Maybe` monad we need to implement:
    it needs to be nothing when `null`/`undefined` or `Something` when `null` nor
    `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, very easy. The problem is, we did not implement neither `Nothing` nor
    `Something`. Don't worry, it is dead simple, just like in my comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need both of them to react to three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isNothing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first two functions are trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isNothing`: `Nothing` returns `true`, `Something` returns `false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val`: `Nothing` returns `null`, `Something` returns its value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last one is `map`, which for `Nothing` should do nothing (return itself)
    and for `Something` it should apply the function to the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f293a752-b6fb-44b1-ad84-e1f05ca9d370.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying toUpperCase on an ordinary string type and on the Maybe<string> monad
    using the map function
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we go, it took us less than 20 lines. Our selectors are now using the
    `Maybe` monad. The last thing we need to do is fix the end usages; it should ask
    for the value after the selector call, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our `Maybe` implementation is a cool pattern to avoid the null-checking burden,
    but is it really a monad?
  prefs: []
  type: TYPE_NORMAL
- en: Monad interface requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More formally, the monad interface should define two basic operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Return (`a -> M a`), an operation that takes the `a` type and wraps it into
    a monad (`M a`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bind (`M a -> (a -> M b) -> M b`), an operation that takes two arguments: a
    monad of the a type, and a function that operates on `a` and returns the `M b`
    (`a -> M b`) monad'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these terms, our constructor function is the `return` function. However,
    our map function is not compliant with the `bind` requirements. It takes a function
    that turns `a` into `b` (`a -> b`), then our `map` function automatically wraps
    `b` into `M b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beside this, our monad needs to obey three monad laws:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Left identity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Right identity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Associativity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Mathematical proof is outside the scope of this book. However, we can play
    with the laws and see whether they hold for some random examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned about higher-order components, and in this section, we will
    have a look at the more general concept, called higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the example. It''s pretty straightforward. You wouldn''t even
    notice you created anything special:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So what is a higher-order function?
  prefs: []
  type: TYPE_NORMAL
- en: 'A higher-order function is a function that does one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Takes one or more functions as an argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's it; it's so simple.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of functions that are higher-order functions and you use
    them on a daily basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.prototype.map`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.filter`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.prototype.reduce`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And, of course, functions such as `compose`, `call`, or `curry`, which we have
    learned about already.
  prefs: []
  type: TYPE_NORMAL
- en: In general, any function that takes a callback is a higher-order function. You
    use such functions everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember how nicely those compose? See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: But some of them don't, such as callbacks. Have you heard of callback hell?
  prefs: []
  type: TYPE_NORMAL
- en: A callback in a callback in a callback, this is a callback hell. That's why
    Promises were invented.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, all of a sudden, `Promise` hell started, so wise people created a
    syntactic sugar for promises: `async` and `await`.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional languages aside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, please read this interesting opinion from David.
  prefs: []
  type: TYPE_NORMAL
- en: '"Wait, wait, wait. What does the performance of persistent data structures
    have to do with the future of JavaScript MVCs?'
  prefs: []
  type: TYPE_NORMAL
- en: A whole lot.
  prefs: []
  type: TYPE_NORMAL
- en: We'll see how, perhaps unintuitively, immutable data allows a new library, Om,
    to outperform a reasonably performant JavaScript MVC like Backbone.js without
    hand optimization from the user. Om itself is built upon the absolutely wonderful React library
    from Facebook."
  prefs: []
  type: TYPE_NORMAL
- en: - The Future of JavaScript MVC Frameworks
  prefs: []
  type: TYPE_NORMAL
- en: David Nolen (swannodette), 17 December 2013
  prefs: []
  type: TYPE_NORMAL
- en: '[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs).'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing (September 2018), Backbone is already out of business.
    Even the popularity of Angular struggles to compete with React. React took the
    market insanely fast and once it finally changed it's license to MIT, it even
    accelerated.
  prefs: []
  type: TYPE_NORMAL
- en: The fun fact is that **requestAnimationFrame** (**rAF**) is not such a big deal
    as once believed.
  prefs: []
  type: TYPE_NORMAL
- en: '"We do batching between different setState()s within one event handler (everything
    is flushed when you exit it). For many cases this works well enough and doesn’t
    have pitfalls of using rAF for every update.  We are also looking at asynchronous
    rendering by default. But rAF doesn’t really help much if the rendered tree is
    large. Instead we want to split non-critical updates in chunks using rIC until
    they’re ready to be flushed.'
  prefs: []
  type: TYPE_NORMAL
- en: (...) We use a concept of "expiration". Updates coming from interactive events
    get very short expiration time (must flush soon), network events get more time
    (can wait). Based on that we decide what to flush and what to time-slice."
  prefs: []
  type: TYPE_NORMAL
- en: '- Dan Abramov tweets'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://twitter.com/jaffathecake/status/952861127528124417](https://twitter.com/jaffathecake/status/952861127528124417).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lesson I want you to learn from these two quotations is: don''t take things
    for granted, do not glorify one approach over another, and learn in which circumstances
    one is better than the other. Functional programming is similar; it would be foolish
    to just abandon this chapter as I once thought. I had this feeling: is it relevant
    to React Native programmers? Yes, it is. If it is popular enough to flood many
    public PRs in the community, you are certainly going to be exposed to these concepts
    and I want you to be prepared.'
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don't be scared by Functors, EndoFunctors, CoMonads, and CoRoutines—take what
    is useful from the theoretical abstractions. Let theoretical experts take care
    of them. Math geeks have always been ahead and usually this is a good thing, but
    don't get too crazy. Business is business. Deadlines cannot wait for you to prove
    the greatest law in category theory.
  prefs: []
  type: TYPE_NORMAL
- en: Focus on understanding the immediate benefits, such as the ones outlined in
    this book. If you ever find yourself in a team that is opposed to functional programming
    patterns, do not enforce them. After all, it is not as important in JavaScript
    as it is in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: '"Using fancy words instead of simple, common ones makes things harder to understand.
    Your writing will be clearer if you stick with a small vocabulary."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Sophie Alpert tweet (Engineering manager of React at Facebook)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://twitter.com/sophiebits/status/1033450495069761536](https://twitter.com/sophiebits/status/1033450495069761536).'
  prefs: []
  type: TYPE_NORMAL
- en: Building abstractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we benchmarked immutable libraries and compared
    their performance. As with everything, I highly encourage you to spend some time
    before you commit to any library, pattern, or way of doing things.
  prefs: []
  type: TYPE_NORMAL
- en: Most libraries that adopt functional programming patterns do so for a real benefit.
    If you are unsure, leave it to someone else, and stick to your well-known imperative
    patterns. It turns out that simple code often gets better optimizations on the
    engine level.
  prefs: []
  type: TYPE_NORMAL
- en: React is not obsessed with pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you dive into the React ecosystem for the first time, you may get a bit
    of a surprise. There are a lot of examples that use pure functions and talk about
    time travelling, using Redux, and about one store to rule them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The truth is, neither React nor Redux use only pure functions. In fact, there
    are a lot of functions in both libraries that perform mutations in the outer scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These variables are being modified by other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at the React way of remembering what the library warned about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This little mutation depends on the environment.
  prefs: []
  type: TYPE_NORMAL
- en: If you maintain a library with such checks, current build tools, such as webpack,
    can remove this dead code when building a production-minified file. By dead code,
    I mean code paths (like the preceding `if` statement) that will never be accessed
    because of the environment (production).
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to Facebook in general, they are not ashamed to show that their
    code base is tricky in some places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0b931c82-9955-4d74-b5ac-cf24732225a9.png)Facebook codebase screenshot,
    posted by Dan Abramov on Twitter'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into one of the most esoteric branches
    of JavaScript programming. We learned about monads, how to use them for the greater
    good, and how not to care about the laws of math if we really don't need to. Then,
    we got comfortable using vocabulary such as pure functions, mutable/immutable
    objects, and referential transparency.
  prefs: []
  type: TYPE_NORMAL
- en: We know that there is a caching pattern for pure functions if we need it. This
    great approach can be useful in many Flux apps. You now can work effectively with
    selectors and make them dead simple using the Maybe monad, which takes away the
    null-checking burden.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this expertise, it is now time to learn the challenges of maintaining
    dependencies and large code bases. In the next chapter, you will face a major
    challenge of every big code base, and believe me, every major company struggles
    with this at some point—no matter how many programming patterns they use or how
    many libraries they depend on.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A mostly adequate guide to functional programming—a free book on functional
    programming in JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/MostlyAdequate/mostly-adequate-guide](https://github.com/MostlyAdequate/mostly-adequate-guide).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of cache functions that you may want to use with the Reselect library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/reduxjs/reselect#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one](https://github.com/reduxjs/reselect#q-the-default-memoization-function-is-no-good-can-i-use-a-different-one).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Information on referential transparency:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://softwareengineering.stackexchange.com/questions/254304/what-is-referential-transparency](https://softwareengineering.stackexchange.com/questions/254304/what-is-referential-transparency).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Eric''s Elliott mastering JavaScript interview series episode, Pure Functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A historical post that predicted the future, *The future of JavaScript MVCs*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs](http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is old but still worth a read, *A General Theory of Reactivity*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/kriskowal/gtor](https://github.com/kriskowal/gtor).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following book on FP in JavaScript, *JavaScript Allonge* (free to read
    online):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-javascript-allong](https://leanpub.com/javascriptallongesix/read#leanpub-auto-about-javascript-allong).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Monad laws (Haskell Wiki):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://wiki.haskell.org/Monad_laws](https://wiki.haskell.org/Monad_laws).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Douglas Crockford, Monads and Gonads:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=dkZFtimgAcM](https://www.youtube.com/watch?v=dkZFtimgAcM).'
  prefs: []
  type: TYPE_NORMAL
- en: 'How Immutable.js is using the Trie graph to optimize writing operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2](https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Trie](https://en.wikipedia.org/wiki/Trie).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Should React use `requestAnimationFrame` by default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/facebook/react/issues/11171](https://github.com/facebook/react/issues/11171).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An awesome functional programming collection on GitHub:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/xgrommx/awesome-functional-programming/blob/master/README.md](https://github.com/xgrommx/awesome-functional-programming/blob/master/README.md).'
  prefs: []
  type: TYPE_NORMAL
- en: If you fell in love with functional programming, here is a very good resource,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learn You a Haskell for Great Good (requires Haskell understanding):'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://learnyouahaskell.com/chapters](http://learnyouahaskell.com/chapters).'
  prefs: []
  type: TYPE_NORMAL
