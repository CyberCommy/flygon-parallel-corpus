- en: Chapter 5. Authenticating Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will add user authentication to our site. Being able to
    distinguish one user from another allows us to develop an entirely new class of
    features. For instance, we will see how to restrict access to the create, edit,
    and delete views, preventing anonymous users from tampering with site content.
    We can also display a user's draft posts to them, but hide them from everyone
    else. This chapter will cover the practical aspects of adding an authentication
    layer to the site, and wrap up with a discussion of how to use sessions to track
    anonymous users as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a database model to represent users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Flask-Login and add the LoginManager helper to our site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to securely store and validate passwords using cryptographic hash functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build forms and views for logging users in and out of the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to reference the logged-in user in views and templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit access to views to logged-in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an author foreign key to the Entry model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Flask session object to track any visitor to the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in building our authentication system will be to create a database
    model representing an individual user account. We will store the user''s login
    credentials, along with some additional information such as the user''s display
    name, and their account creation timestamp. Our model will have the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`email` (unique): store the user''s email address and use that for authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password_hash`: instead of stringing each user''s password as plaintext, we
    will hash the password using a one-way cryptographic hash function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: the user''s name, so we can display it alongside their blog entries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slug`: A URL-friendly representation of the user''s name, also unique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active`: Boolean flag indicating whether this account is active. Only active
    users will be able to log into the site'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_timestamp`: The time this user account was created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there are other fields you think might be useful, feel free to make your
    own additions to this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our list of fields, let''s create the `model` class. Open
    `models.py` and, below the `Tag` model, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you''ll recall from [Chapter 2](ch02.html "Chapter 2. Relational Databases
    with SQLAlchemy"), *Relational Databases with SQLAlchemy*, we need to create a
    migration in order to add this table to our database. From the command line, we
    will use the `manage.py` helper to introspect our models and generate the migration
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Having generated the migration, we can now run `db upgrade` to make the schema
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have users, the next step will be to allow them to log into the
    site.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Flask-Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask-Login is a lightweight extension that handles logging users in and out
    of the site. From the project''s documentation, Flask-Login will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Log users in and out of the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict views to the logged-in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage cookies and the "remember me" functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help protect user session cookies from being stolen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, Flask-Login will not do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make any decisions about the storage of user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage usernames, passwords, OpenIDs, or any other form of credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle tiered permissions or anything beyond logged in or logged out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Account registration, activation, or password reminders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The takeaway from these lists is that Flask-Login can best be thought of as
    a session manager. It simply manages user sessions and lets us know which user
    is making a request, and whether that user is logged in or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started. Use `pip` to install Flask-Login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to start using the extension in our app, we will create an instance
    of the `LoginManager` class, which is provided by Flask-Login. In addition to
    creating the `LoginManager` object, we will add a signal handler that will run
    before every request. This signal handler will retrieve the currently logged-in
    user and store it on a special object named `g`. In Flask, the `g` object can
    be used to store arbitrary values per-request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `app.py`. The imports go at the top of the
    module, and the rest goes at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have created our `login_manager` and added a signal handler to load
    the current user, we need to tell Flask-Login how to determine which user is logged
    in. The way Flask-Login determines this is by storing the current user's ID in
    the session. Our user loader will accept the ID that was stored in the session
    and return a `User` object from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `models.py` and add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now Flask-Login knows how to convert a user ID into a User object, and that
    user will be available to us as `g.user`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Flask-Login interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order for Flask-Login to work with our `User` model, we need to implement
    a handful of special methods that comprise the Flask-Login interface. By implementing
    these methods, Flask-Login will be able to take a `User` object and determine
    whether they can log into the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `models.py` and add the following methods to the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first method, `get_id()`, instructs Flask-Login how to determine the ID
    of a user, which will then be stored in the session. It is the inverse of our
    User Loader function, which gives us an ID and asks us to return a `User` object.
    The rest of the methods tell Flask-Login that `User` objects from the database
    are not anonymous, and should be allowed to login only if the active attribute
    is set to `True`. Recall that Flask-Login knows nothing about our `User` model
    or our database, so we have to be very explicit in what we tell it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured Flask-Login, let's add the code that will allow
    us to create some users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a new user is just like creating an entry or tag with one exception:
    we need to securely hash the user''s password. You should never store passwords
    as plaintext and, due to the ever-increasing sophistication of hackers, it is
    best to use a strong cryptographic hash function. We will be using the **Flask-Bcrypt**
    extension to hash and check our passwords, so let''s install the extension using
    `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `app.py` and add the following code to register the extension with our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add some methods to the `User` object that will make creating and
    checking passwords straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `make_password` method accepts a plaintext password and returns the hashed
    version, while the `check_password` method accepts a plaintext password and determines
    whether it matches the hashed version stored in the database. We will not use
    these methods directly, however. Instead, we will create two higher-level methods,
    `create` and `authenticate`. The `create` method will create a new user, automatically
    hashing the password before saving, and the `authenticate` method will retrieve
    a user given a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s experiment with these methods by creating a new user. Open up a shell
    and, using the following code as an example, create a user for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a way to securely store and verify a user's credentials, we
    can commence with building the login and logout views.
  prefs: []
  type: TYPE_NORMAL
- en: Login and logout views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users will log into our blogging site using their email and password; so, before
    we begin building our actual login view, let''s start with the `LoginForm`. This
    form will accept the `username`, `password`, and will also present a checkbox
    to indicate whether the site should `remember me`. Create a `forms.py` module
    in the `app` directory and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that WTForms also provides an e-mail validator. However, as the documentation
    for this validator tells us, it is very primitive and may not capture all edge
    cases as full e-mail validation is actually extremely difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to validate the user''s credentials as part of the normal WTForms
    validation process, we will override the form''s `validate()` method. In the event
    the email is not found or the password does not match, we will display an error
    below the email field. Add the following method to the `LoginForm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that our form is ready, let's create the login view. We will instantiate
    the `LoginForm` and validate it on `POST`. In addition, when the user successfully
    authenticates, we will redirect them to a new page.
  prefs: []
  type: TYPE_NORMAL
- en: When a user logs in, it is a good practice to redirect them back to the page
    the user was previously browsing. To accomplish this, we will store the URL for
    the page the user was previously at in a query string value called `next`. If
    a URL is found in this value, we can redirect the user there. If no URL is found,
    the user will get redirected to the homepage by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `views.py` in the `app` directory and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The magic happens on `POST` after we've successfully validated the form (and
    therefore authenticated the user). We are calling `login_user`, a helper function
    provided by Flask-Login, which handles setting the correct session values. Then
    we set a flash message and send the user on their way.
  prefs: []
  type: TYPE_NORMAL
- en: The login template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `login.html` template is straightforward with the exception of one trick,
    one exception. In the form''s action attribute, we are specifying `url_for(''login'')`
    but we are also passing an extra value `next`. This allows us to preserve the
    desired next URL while the user is logging in. Add the following code to `templates/login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When you visit the login page, your form will look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The login template](img/1709_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Logging out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally let''s add a view for logging users out of the site. Interestingly,
    no template is needed for this view because users will simply pass through the
    view, being redirected after their session is logged out. Add the following `import`
    statement and logout view code to `views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we are accepting a `next` URL as part of the query string, defaulting
    to the homepage if no URL is specified.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the current user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create links to the login and logout views in the navigation bar. To do
    this, we will need to check whether the current user is authenticated. If so,
    we will display a link to the logout view; otherwise, we will display a link to
    log in.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from earlier in the chapter, we added a signal handler that
    stores the current user as an attribute of the Flask `g` object. We can access
    this object in the template, so we simply need to check, in the template, whether
    `g.user` is authenticated or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `base.html` and make the following additions to the navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note how we are calling the `is_authenticated()` method, which we implemented
    on our `User` model. Flask-Login provides us with a special `AnonymousUserMixin`
    that will be used if no user is currently logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, in addition to the view name, we are specifying `next=request.path`.
    This works in tandem with our login and logout views, to redirect the user to
    their current page after clicking login or logout.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access to views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, all of our blog views are currently unprotected and available
    to anyone who wants to visit them. In order to prevent a malicious user from trashing
    our entries, let's add some protection to the views that actually modify data.
    Flask-Login provides a special decorator `login_required` that we will use to
    protect views that should require an authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the entries blueprint and protect all views that modify data.
    Start by adding the following import at the top of the `blueprint.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`login_required` is a decorator, just like `app.route`, so we will simply wrap
    the views that we wish to protect. For example, this is how you would protect
    the `image_upload` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Go through the module and add the `login_required` decorator to the following
    views, taking care to add it below the route decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image_upload`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an anonymous user attempts to access these views, they will be redirected
    to the `login` view. As an added bonus, Flask-Login will automatically handle
    specifying the next parameter when redirecting to the `login` view, so users will
    be returned to the page they were attempting to access.
  prefs: []
  type: TYPE_NORMAL
- en: Storing an entry's author
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you might recall from the spec we created in [Chapter 1](ch01.html "Chapter 1. Creating
    Your First Flask Application"), *Creating your First Flask Application*, our blogging
    site will support multiple authors. When an entry is created, we will store the
    current user in the entry''s author column. In order to store the `User` who authored
    a given `Entry`, we will be creating a *one-to-many* relationship between users
    and entries, such that one user may have many entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing an entry''s author](img/1709_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a *one-to-many* relationship, we will add a column to the `Entry`
    model that points to a user in the `User` table. This column will be named `author_id`
    and, because it references a `User`, we will make this a foreign key. Open `models.py`
    and make the following modification to the `Entry` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ve added a new column, we once again need to create a migration.
    From the command line, run `db migrate` and `db upgrade` once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Like we did with tags, the final step will be to create a back-reference on
    the User model that will allow us to access a given user's associated `Entry`
    rows. Because a user may have many entries we would like to perform additional
    filtering operations on, we will expose the back-reference as a query, just like
    we did for tag.entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `User` class, add the following line of code below the `created_timestamp`
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We now have the ability to store a `User` as the author of a blog entry, and
    the next step will be to populate this column at the time the entry is created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If there are any blog entries in the database, we also need to be sure that
    they are assigned to an author. From the interactive shell, let''s manually update
    the author field on all existing entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The query will return the number of rows updated, which in this case is the
    number of entries in the database. To save these changes, once again call `commit()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Setting the author on blog entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a column suitable for storing the author of the `Entry`, and
    are able to access the currently logged-in user, we can put that information to
    use by setting the author of an entry at the time it is created. Before each request,
    our signal handler will patch the current user onto the Flask `g` object, and
    since the `create` view is protected by the `login_required` decorator, we know
    that `g.user` will be a `User` from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are using the `g object` to access the user, we will need to import
    it, so add the following import statement to the top of the entries blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the entries blueprint, we now need to modify the instantiation of the `Entry`
    object to manually set the author attribute. Make the following change to the
    `create` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When you go to create an entry, you will now be saved in the database as the
    author of that entry. Go ahead and try it out.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the edit and delete views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If multiple users are able to log into our site, there's nothing to stop a malicious
    user from editing or even deleting another user's entries. These views are protected
    by the `login_required` decorator, but we need to add some additional code to
    ensure that only the author can edit or delete their own entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this protection cleanly, we will once again refactor
    the helper functions in the entries blueprint. Make the following modifications
    to the entries blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have introduced a new helper function, `filter_status_by_user`. This function
    will ensure that anonymous users cannot see draft entries. Add the following function
    to the entries blueprint below `get_entry_or_404`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to restrict access to the `edit` and `delete` views, we now only need
    to pass in the current user as the author parameter. Make the following modification
    to the edit and delete views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you were to attempt to access the `edit` or `delete` view for an entry you
    did not create, you would receive a `404` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s modify the entry detail template to hide the *Edit* and *Delete*
    links from all users except the entry''s author. In your `entries` app edit the
    template `entries/detail.html`, your code might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Displaying a user's drafts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is still one slight problem with our entry list: draft entries are displayed
    alongside normal entries. We don''t want to display unfinished entries to just
    anyone, but at the same time it would be helpful for a user to see their own drafts.
    For that reason, we will modify the entry lists and detail to display only public
    entries to everyone but the author of the entry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again we will be modifying the helper functions in the entries blueprint.
    We will first modify the `filter_status_by_user` function to allow logged-in users
    to view their own drafts (but not anyone else''s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The new query could be parsed as—"Give me all the public entries, or the undeleted
    entries for which I am the author."
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `get_entry_or_404` is using the `filter_status_by_user` helper already,
    the `detail`, `edit,` and `delete` views are ready to go. We only need to address
    the various list views, which use the `entry_list` helper. Let''s update the `entry_list`
    helper to use the new `filter_status_by_user` helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That's all that it takes! I hope this shows how a few helper functions, in the
    right places, can really simplify your life as a developer. Before continuing
    on to the final section, I'd suggest creating one or two users and experimenting
    with the new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan on supporting multiple authors on your blog, you could also add
    an authors' index page (like the tag index), and author detail pages that list
    the entries associated with a given author (`user.entries`).
  prefs: []
  type: TYPE_NORMAL
- en: Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've worked through this chapter, you may have wondered how Flask-Login
    (and also Flask) are able to determine which user is logged in between requests,
    request after request. Flask-Login does this by storing a user's ID in a special
    object called the session. Sessions utilize cookies to securely store morsels
    of information. When the user makes a request to your Flask application, their
    cookies are sent along with the request, and Flask is able to inspect the cookie
    data and load it into the session object. Similarly, your views can add or modify
    information stored in the session, updating the user's cookies in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of Flask''s session object is that it can be used for any visitor
    to the site, whether they are logged in or not. The session can be treated just
    like an ordinary Python dictionary. The following code shows how you might track
    the last page a user visited using the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By default, Flask sessions last only as long as the browser is open. If you
    would like the session to persist, even between restarts, simply set `session.permanent
    = True`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like the `g` object, the `session` object can be accessed directly from the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, try implementing a simple theme chooser for your website. Create
    a view that allows users to pick a color theme, which will be stored in the session.
    Then, in the templates, apply extra CSS rules depending on the user's chosen theme.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added user authentication to the blogging app. We created
    a `User` model, which securely stores a user's login credentials in the database,
    then built views for logging users in and out of the site. We added a signal handler
    that runs before every request and retrieves the current user, then learned how
    to use this information in the views and templates. In the second half of the
    chapter, we integrated the `User` model with the Entry model, making our blog
    more secure in the process. The chapter wrapped up with a brief discussion of
    Flask sessions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build an administrative dashboard that will allow
    super-users to perform actions such as creating new users and modifying site content.
    We will also collect and display various site metrics, such as page-views, to
    help visualize what content is driving the most traffic.
  prefs: []
  type: TYPE_NORMAL
