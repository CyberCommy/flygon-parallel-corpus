- en: Chapter 9. From Monolithic to Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at some possible strategies to follow when we
    have to transform a monolithic application into microservices, along with some
    examples. This process can be a little difficult if we already have a big and
    complex application, but fortunately, there are some well-known strategies that
    we can follow in order to avoid problems throughout this process.
  prefs: []
  type: TYPE_NORMAL
- en: Refactor strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of transforming a monolithic application into microservices is a
    refactor code in order to modernize your application. This should be done incrementally.
    Trying to transform the entire application into microservices in one step could
    cause problems. Little by little, it will create a new application based on microservices
    and finally, your current application will disappear because it will be transformed
    into little microservices leaving the original application empty or maybe it will
    also be a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Stop diving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your application is already a hole, you have to stop diving in that hole.
    In other words, stop making your monolithic application bigger. This is when you
    have to implement a new functionality, it is necessary to create a new microservice
    and connect it to the monolithic application instead of continuing developing
    the new functionalities in the monolith.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, when a new functionality is implemented, we will have the current
    monolith, the new functionality, and also two more things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Router:** This is responsible for the HTTP requests; in other words, this
    is like a gateway that knows where it needs to send every request, either to the
    old monolith or to the new functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Glue code:** This is responsible for connecting the monolithic application
    to the new functionality. It is very common for the new functionality to need
    to access the monolithic application in order to get data or any necessary functions
    from it:![Stop diving](graphics/B06142_09_01.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop diving strategy
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding glue code, there are 3 different possibilities to access the application
    from the new functionality to the monolith:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an API on the monolith side to be consumed by the new function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect directly with the monolith database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a synchronized monolith copy of the database on the functionality side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this strategy is a pretty way to start developing microservices
    in your current monolithic application. In addition, the new functionality can
    scale, deploy, and develop in an isolated way from the monolith, improving your
    application. However, this does not solve the problem, it just avoids making the
    current problem any bigger, so let’s take a look at two more strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Divide frontend and backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another strategy is to divide the logic presentation part from the data access
    layer. An application usually has at least 3 different parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Presentation layer:** This is the user interface, in other words, the HTML
    language of a website'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business logic layer:** This consists of the components used to implement
    the business rules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access data layer:** This has components that have access to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is usually a separation between the presentation layer and the business
    logic and access data layers. The business layer has an API that has one or more
    facades that encapsulate the business logic components. From this API, it is possible
    to divide the monolith into 2 smaller applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the division, the presentation layer makes calls to the business logic.
    Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Divide frontend and backend](graphics/B06142_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Divide frontend and backend strategy
  prefs: []
  type: TYPE_NORMAL
- en: 'This division has 2 different advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to scale and develop two different and isolated applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides you with an API that can be consumed for future microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem with this strategy is that it is only a temporary solution, it can
    be transformed into one or two monolithic applications, so let's look at the next
    strategy in order to remove the rest of the monolith.
  prefs: []
  type: TYPE_NORMAL
- en: Extraction services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last strategy is about isolating modules from the resultant or resultants
    monoliths. Little by little, we can extract modules from it and make a microservice
    from every module. Once we have all the important modules extracted, the resultant
    monolith will also be a microservice or it will even disappear. The general idea
    is to create logical groups of features that will be your future microservices.
  prefs: []
  type: TYPE_NORMAL
- en: A monolithic application usually has many potential modules to be extracted.
    The priority must be set by selecting the easier ones first and then the most
    beneficial ones. The easier ones will give you necessary experience in extracting
    modules into microservices to do it with the important ones later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips to help you choose the most beneficial ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules that change frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules that require different resources to the monolith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules that require expensive hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is useful to look for the existing coarse-grained boundaries, they are easier
    and cheaper to convert to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: How to extract a module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's look at how to extract a module, we will use an example to make the
    explanation a little easier to understand. Imagine that your monolithic application
    is a blog system. As you can imagine, the core functionality is the posts that are
    created by users and each post supports comments. As you can see from our small
    description, you can define the different modules of your application and decide
    which is the most important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the description and features of your application clear, you can
    continue with the general steps used to extract a module from your monolithic
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an interface between the module and the monolith code. The best solution
    is a bidirectional API, because the monolith will need data from the module and
    the module will need data from the monolith. This process is not easy, you will
    probably have to change code from the monolithic application in order to make
    the API work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the coarse-grained interface is implemented, convert the module into an
    isolated microservice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, imagine that the `POST` module is the candidate to be extracted,
    their components are used by the `Users` and `Comments` modules. As the first
    step says, it is necessary to implement a coarse-grained API. The first interface
    is an entry API used by `Users` to invoke the `POST` module and the second one
    is used by `POST` in order to invoke `Comments`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step of the extraction, convert the module to an isolated microservice.
    Once this is done, the resulting microservice will be scalable and independent,
    so it will be possible to make it grow or even to write it from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Little by little, the monolith will be smaller and your application will have
    more microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tutorial: From monolithic to microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter's examples, we will not use a framework and the code will be
    written without using a MVC architecture in order to focus on the subject of this
    chapter and learn how to transform a monolithic application into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: There is no better way to learn something than by practicing, so let's look
    at an entire example of a blog platform that we defined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The blog platform example can be downloaded from our PHP microservices repository,
    so if you want to follow our steps, it is possible to do so by downloading it
    and following this guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example is a basic blog platform with the minimum functionalities to go
    through this tutorial. It is a blog system that allows the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering new users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admins can post new articles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registered users can post new comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admins can create new categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admins can create new articles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admins can manage the comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the users can see the articles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, the first step in transforming a monolithic application into microservices
    is to familiarize yourself with the current application. In our imaginary schema,
    the current application can be divided into the following microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Articles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is pretty clear in this example, but in a real example it should be studied
    deeply in order to divide the project into little microservices that will do specific
    functions by following the priorities we explained earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Stop diving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to follow the strategy that we explained before, imagine
    that we want to add a new functionality to send private messages between users
    in our blog platform.
  prefs: []
  type: TYPE_NORMAL
- en: To figure this out, we need to know which functionalities will have the new
    sending private messages feature in order to find where the glue code and the
    request to get information (routes) from the new microservice should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the functionalities of the new microservices can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading your messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, these functionalities are very basic, but remember that this
    is only to familiarize yourself with the process of creating a new microservice
    in a monolithic application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create the private messages microservices and, of course, we will use
    Lumen again. To quickly create the skeleton, run the following command on your
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create a folder with Lumen installed.
  prefs: []
  type: TYPE_NORMAL
- en: In the [Chapter 2](ch02.html "Chapter 2. Development Environment"), *Development
    Environment*, we explained how to create Docker containers. Now, you have the
    chance to use everything you have learned and implement the monolithic and the
    different new microservices in the Docker environment. Based on the previous chapters,
    you should be able to do this on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Our new feature needs a place to store the private messages, so we will now
    create the table to be used by the private messages microservices. This can be
    created in a separate database or even in the same application's database. Remember
    that microservices can share the same database if the situation allows it, but
    imagine that this microservice will have a lot of traffic, so it is a better solution
    for us to have it in a separate database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new database or connect with the application database and execute
    the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the table, it is necessary to connect the new microservice
    to it, so open the `.env.example` file and modify the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If your database is different, change it in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rename the `.env.example` file to `.env` and change the `$app->run();` code
    to the following one on the `public/index.php` file; this will allow you to make
    calls to this microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can check that your microservice is working properly on Postman by
    making a GET call to `http://localhost/private_messages/public/`. Remember to
    make all the required changes to match your development infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: You will receive a 200 status code with the Lumen version installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our microservice, we will need to include at least the following calls:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GET `/messages/user/id`: This is required to get the messages that a user has'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'POST `/message/sender/id/recipient/id`: This is required to send a message
    to a user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, now we will create the routes on `/private_messages/app/Http/routes.php`
    by adding the following lines at the end of the `routes.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a controller, called `MessageController`, on `/app/Http/Controllers/MessageController.php`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to tell Lumen that it is necessary to use the database, so uncomment
    the following lines on `/bootstrap/app.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create both the functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once our methods are complete, the microservice is finished. So, now we have
    to connect the monolithic application to the private messages microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new button for the registered users on the `header.php`
    file of the monolithic application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to create a new file, called `messages.php`, in the `root` folder
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are making a `curl` call to the microservice in order to
    get the user message list. Also, we need to get the user list to fill the user
    selector for sending messages. This piece of code can be considered as glue code because
    it is necessary to match the microservice data with the monolith data. We will
    use the following glue code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can build the html code to display the user messages and the necessary
    form for sending messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is a form for sending messages, so we have to add some code
    to make a call to the microservice in order to send the message. Add the following
    code after the `$messages = json_decode($result, true);` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We have our first microservice included in the monolithic application.
    This is how to proceed when we have to add a new functionality in a current monolithic
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Divide frontend and backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second strategy, as we said before, consists of isolating the presentation
    layer from the business logic. This can be done by creating an entire microservice
    that includes all the business logic and data access or simply by isolating the
    presentation layer from the business layer, like a **Model-View-Controller** (**MVC**)
    structure does.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a complete solution for the problem of using monolithic applications
    because it results in us having two monolithic applications instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we should start by creating a new `Controller.php` file in the
    `root` folder. We can call this class `Controller` and it will contain all the
    methods that the views need. For example, the `Article` view needs `getArticle`,
    `postComment`, and `getArticleComments`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The article view should include the methods included in the `Controller.php`
    file. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These are the steps that we should follow in order to isolate the business logic
    layer from the views.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want, you can put all the view files (`header.php`, `footer.php`, `index.php`,
    `article.php`, and so on) into a folder called `views` in order to have them organized
    in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all the views isolated from the business logic, we will have all
    the methods included in the controller instead of having them in the presentation
    layer. As we said before, this is only a temporary solution, so we will look at
    the real solution in order to extract the modules into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Extraction services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this strategy, we have to select the first module that we want to isolate
    in order to make a microservice from it. In this case, we will start doing it
    on the `Categories` module.
  prefs: []
  type: TYPE_NORMAL
- en: The categories are most used on the admin panel. It is possible to create, modify,
    and delete categories from it and then, it is possible to select them when creating
    a new article and they are displayed in the articles to indicate the article category.
  prefs: []
  type: TYPE_NORMAL
- en: The extraction process is not easy; we have to ensure that we are aware of all
    the places the module is being used at. To do this, we will create a bidirectional
    API or create all the category methods in the controller and then, we can isolate
    them in a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `admin/categories.php` file, we have to do the same as we did with
    the divide frontend and backend strategy--find all the places where the categories
    are referenced and create a new method on the controller. Take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `controller.php` file has to contain the category methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more references to categories in the `admin/articles.php` file, so
    open it and add the following lines after the `require_once` lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines will allow you to use the category methods included in the `controller.php`
    file in the `articles.php` file. Modify the code used to get the categories to
    this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is necessary to make some changes on the article view. This is the
    view to display an article, and it contains the category selected when creating
    the article.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an article, the executed query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the query requires the categories table. If you want to use
    a different database for the categories microservice, you will have to remove
    the highlighted line from the query, select `articles.category_id` in the query
    and then, get the category name with the method created to provide it. So, the
    query will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code to get the category name from the provided category
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have made all of these changes, we are ready to isolate the category
    table in a different database, so we can create a categories microservice from
    the created methods in the `controller.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public function createCategory($name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function updateCategory($id,$name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function deleteCategory($id)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function getCategories()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function getCategory($id)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you would imagine, these functions are used to create the `routes.php` file
    of the categories microservice. So, let's create a new microservice like we did
    with the stop diving strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the new categories microservice by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will install Lumen in a folder called categories, so we
    can start creating the code for our new categories microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have two options--the first one is to use the same table located on the
    current database--we can point the new microservice to the current database. The
    second option is to create a new table in a new database, so the new microservice
    will use its own database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create a new table in a new database, we can proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Export the current categories table in a SQL file. It will keep the current
    data stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the SQL file to the new database. It will create the exported table and
    data in the new database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The export/import process can be performed using a SQL client or by executing
    `mysqldump` in console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the new table is imported to a new database or you decide to use the current
    database, it is necessary to set up the `.env.example` file in order to connect
    the new microservice to the correct database, so open it and put the correct parameters
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to rename the `.env.example` file to `.env` and change the `$app->run()`
    line on `public/index.php`, like we did earlier to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, uncomment the following lines on `/bootstrap/app.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to add the necessary methods to the `routes.php` file. We
    have to add the category methods that we have on the `Controller.php` of the monolithic
    application and translate them to routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public function createCategory($name)`: This is a POST method for creating
    a new category. So, it can be something like `$app->post(''category'', ''CategoryController@createCategory'');`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function updateCategory($id,$name)`: This is a PUT method to edit an
    existing category. So, it can be something like `app->put(''category/{id}'', ''CategoryController@updateCategory'');`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function deleteCategory($id)`: This is a DELETE method for deleting
    an existing category. So, it can be something like `app->delete(''category/{id}'',
    ''CategoryController@deleteCategory'');`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function getCategories()`: This is a GET method for getting all the
    existing categories. So, it can be something like `app->get(''categories'', ''CategoryController@getCategories'');`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function getCategory($id)`: This is a GET method too, but this only
    gets a single category. So, it can be something like `app->get(''category/{id}'',
    ''CategoryController@getCategory'');`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, once we have all our routes added to the `routes.php` file, it is time
    to create the category model. To do this, create a new folder on `/app/Model`
    and a file on `/app/Model/Category.php`, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the model, create a `/app/Http/Controllers/CategoryController.php`
    file with the necessary methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have finished our categories microservice. You can give it a try on
    Postman in order to check that all the methods work. For example, the `getCategories`
    method can be called by Postman with the `http://localhost/categories/public/categories`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the new categories microservice created and working properly, it
    is time to disconnect the categories module and connect the monolithic application
    to the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the monolithic application and find all the references to the category
    methods. We have to replace them by making calls to the new microservice. We will
    make these calls using native curl calls, but you should consider using Guzzle
    or a similar package instead, as we did in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, firstly we should create a function to make the calls in the `Controller.php`
    file. It can be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will be used in order to reuse code in every single call
    to the categories microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `/admin/categories.php` file and replace the `controller->createCategory($name);` line
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can check that we are making a POST call to the create
    category method with the value parameter set to the `$name` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `/admin/categories.php` file, find and replace the `controller->updateCategory($id,
    $name);` line with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, find and replace `$controller->deleteCategory($_GET[''del'']);`
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file again and also in the `/admin/articles.php` file, find and
    replace `$arrCategories = $controller->getCategories();` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last one is located in the `/admin/categories.php` file again. Find and
    replace the `row = $controller->getCategory($_GET[''id'']);` line with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once we have finished replacing all the category methods on the monolithic application
    with calls to the new categories microservice, we can delete all the references
    to the monolithic category module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `Controller.php` file and delete the following functions, you do
    not need them any more because they reference to the monolithic category module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public function deleteCategory($id)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function createCategory($name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function updateCategory($id,$name)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function getCategories()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public function getCategory($id)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, if you created a new database for the categories microservice,
    you can drop the categories table located in the monolithic application database
    by executing the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have finished extracting the categories service from the monolithic application.
    The next step would be to select another module, follow the same steps again,
    and repeat this process until the monolithic application disappears or becomes
    a microservice too.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Security"), *Security* we talked about
    security in microservices. To practice what you have learned, review all the code
    in this chapter and find the weakness in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the strategies to follow in order to transform
    a monolithic application into microservices using sample codes for every single
    step. From now on, you are ready to say goodbye to monolithic applications and
    transform them in order to start working with microservices.
  prefs: []
  type: TYPE_NORMAL
