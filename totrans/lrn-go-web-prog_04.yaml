- en: Chapter 4. Using Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Serving and Routing"), *Serving and Routing*,
    we explored how to take URLs and translate them to different pages in our web
    application. In doing so, we built URLs that were dynamic and resulted in dynamic
    responses from our (very simple) `net/http` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: We've presented our data as real HTML, but we specifically hard-coded our HTML
    directly into our Go source. This is not ideal for production-level environments
    for a number of reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Go comes equipped with a robust but sometimes tricky template engine
    for both text templates, as well as HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a lot of other template languages that eschew logic as a part of the
    presentation side, Go's template packages enable you to utilize some logic constructs,
    such as loops, variables, and function declarations in a template. This allows
    you to offset some of your logic to the template, which means that it's possible
    to write your application, but you need to allow the template side to provide
    some extensibility to your product without rewriting the source.
  prefs: []
  type: TYPE_NORMAL
- en: We say some logic constructs because Go templates are sold as logic-less. We
    will discuss more on this topic later.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll explore ways to not only present your data but also explore
    some of the more advanced possibilities in this chapter. By the end, we will be
    able to parlay our templates into advancing the separation of presentation and
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing templates, context, and visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML templates and text templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying variables and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using logic and control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing templates, context, and visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s worth noting very early that while we''re talking about taking our HTML
    part out of the source code, it''s possible to use templates inside our Go application.
    Indeed, there''s nothing wrong with declaring a template as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we do this, however, we'll need to restart our application every time the
    template needs to change. This doesn't have to be the case if we use file-based
    templates; instead we can make changes to the presentation (and some logic) without
    restarting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do to move from in-application HTML strings to file-based
    templates is create a template file. Let''s briefly look at an example template
    that somewhat approximates to what we''ll end up with later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Very straightforward, right? Variables are clearly expressed by a name within
    double curly brackets. So what's with all of the periods/dots? Not unlike a few
    other similarly-styled templating systems (Mustache, Angular, and so on), the
    dot signifies scope or context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to demonstrate this is in areas where the variables might otherwise
    overlap. Imagine that we have a page with a title of **Blog Entries** and we then
    list all of our published blog articles. We have a page title but we also have
    individual entry titles. Our template might look something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The dot here specifies the specific scope of, in this case, a loop through the
    range template operator syntax. This allows the template parser to correctly utilize
    `{{.Title}}` as a blog's title versus the page's title.
  prefs: []
  type: TYPE_NORMAL
- en: This is all noteworthy because the very first templates we'll be creating will
    utilize general scope variables, which are prefixed with the dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates and text templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first example of displaying the values from our blog from our database
    to the Web, we produced a hardcoded string of HTML and injected our values directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the two lines that we used in [Chapter 3](ch03.html "Chapter 3. Connecting
    to Data"), *Connecting to Data*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It shouldn't be hard to realize why this isn't a sustainable system for outputting
    our content to the Web. The best way to do this is to translate this into a template,
    so we can separate our presentation from our application.
  prefs: []
  type: TYPE_NORMAL
- en: To do this as succinctly as possible, let's modify the method that called the
    preceding code, `ServePage`, to utilize a template instead of hardcoded HTML.
  prefs: []
  type: TYPE_NORMAL
- en: So we'll remove the HTML we placed earlier and instead reference a file that
    will encapsulate what we want to display. From your root directory, create a `templates`
    subdirectory and `blog.html` within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the very basic HTML we included, feel free to add some flair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in our application, inside the `ServePage` handler, we''ll change our
    output code slightly to leave an explicit string and instead parse and execute
    the HTML template we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If, somehow, you failed to create the file or it is otherwise not accessible,
    the application will panic when it attempts to execute. You can also get panicked
    if you're referencing `struct` values that don't exist—we'll need to handle errors
    a bit better.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: Don''t forget to include `html/template` in your imports.'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of moving away from a static string should be evident, but we now
    have the foundation for a much more extensible presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we visit `http://localhost:9500/page/hello-world` we''ll see something similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML templates and text templates](img/B04294_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Displaying variables and security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate this, let''s create a new blog entry by adding this SQL command
    to your MySQL command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'VALUES:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another thrilling piece of content, for sure. Note, however that we have some
    embedded HTML in this when we attempt to italicize the word better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debates about how formatting should be stored notwithstanding, this allows
    us to take a look at how Go''s templates handle this by default. If we visit `http://localhost:9500/page/a-new-blog`
    we''ll see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying variables and security](img/B04294_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, Go automatically sanitizes our data for output. There are a
    lot of very, very wise reasons to do this, which is why it's the default behavior.
    The biggest one, of course, is to avoid XSS and code-injection attack vectors
    from untrusted sources of input, such as the general users of the site and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'But ostensibly we are creating this content and should be considered trusted.
    So in order to validate this as trusted HTML, we need to change the type of `template.HTML`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to simply scan the resulting SQL string value into a `template.HTML`
    you''ll find the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to work around this is to retain the string value in `RawContent`
    and assign it back to `Content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we `go run` this again, we''ll see our HTML as trusted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying variables and security](img/B04294_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using logic and control structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier in this chapter we looked at how we can use a range in our templates
    just as we would directly in our code. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You may recall that we said that Go's templates are without any logic, but this
    depends on how you define logic and whether shared logic lies exclusively in the
    application, the template, or a little of both. It's a minor point, but because
    Go's templates offer a lot of flexibility; it's the one worth thinking about.
  prefs: []
  type: TYPE_NORMAL
- en: Having a range feature in the preceding template, by itself, opens up a lot
    of possibilities for a new presentation of our blog. We can now show a list of
    blogs or break our blog up into paragraphs and allow each to exist as a separate
    entity. This can be used to allow relationships between comments and paragraphs,
    which have started to pop up as a feature in some publication systems in recent
    years.
  prefs: []
  type: TYPE_NORMAL
- en: 'But for now, let''s use this opportunity to create a list of blogs in a new
    index page. To do this, we''ll need to add a route. Since we have `/page` we could
    go with `/pages`, but since this will be an index, let''s go with `/` and `/home`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We'll use `RedirIndex` to automatically redirect to our `/home` endpoint as
    a canonical home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Serving a simple `301` or `Permanently Moved` redirect requires very little
    code in our method, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is enough to take any requests from `/` and bring the user to `/home`
    automatically. Now, let''s look at looping through our blogs on our index page
    in the `ServeIndex` HTTP handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s `templates/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![Using logic and control structures](img/B04294_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ve highlighted an issue with our `Page struct` here—we have no way to get
    the reference to the page''s `GUID`. So, we need to modify our `struct` to include
    that as the exportable `Page.GUID` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can link our listings on our index page to their respective blog entries
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can update our HTML part with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But this is just the start of the power of the templates. What if we had a much
    longer piece of content and wanted to truncate its description?
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new field within our `Page struct` and truncate that. But that's
    a little clunky; it requires the field to always exist within a `struct`, whether
    populated with data or not. It's much more efficient to expose methods to the
    template itself.
  prefs: []
  type: TYPE_NORMAL
- en: So let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create yet another blog entry, this time with a larger content value.
    Choose whatever you like or select the `INSERT` command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'VALUES:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: For the sake of brevity, we''ve truncated the full length of our preceding
    Lorem Ipsum text.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to represent our truncation as a method for the type `Page`. Let's
    create that method to return a string that represents the shortened text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cool thing here is that we can essentially share a method between the application
    and the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code will loop through the length of content and if the number of characters
    exceeds `150`, it will return the slice up to that number in the index. If it
    doesn't ever exceed that number, `TruncatedText` will return the content as a
    whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling this in the template is simple, except that you might be expected to
    need a traditional function syntax call, such as `TruncatedText()`. Instead, it''s
    referenced just as any variable within the scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling .`TruncatedText`, we essentially process the value inline through
    that method. The resulting page reflects our existing blogs and not the truncated
    ones and our new blog entry with truncated text and ellipsis appended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using logic and control structures](img/B04294_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I'm sure you can imagine how being able to reference embedded methods directly
    in your templates can open up a world of presentation possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just scratched the surface of what Go's templates can do and we'll explore
    further topics as we continue, but this chapter has hopefully introduced the core
    concepts necessary to start utilizing templates directly.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at simple variables, as well as implementing methods within the
    application, within the templates themselves. We've also explored how to bypass
    injection protection for trusted content.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll integrate a backend API for accessing information
    in a RESTful way to read and manipulate our underlying data. This will allow us
    to do some more interesting and dynamic things on our templates with Ajax.
  prefs: []
  type: TYPE_NORMAL
