- en: Chapter 9. Extract Domain Logic to Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we extracted all our SQL statements to a layer of *Gateway*
    objects. This encapsulates the interactions between the application and the database.
  prefs: []
  type: TYPE_NORMAL
- en: However, we usually need to apply some amount of business or domain logic to
    the data coming from and going back to the database. The logic can include things
    like data validation, adding or modifying values for presentation or calculation
    purposes, collecting simpler records into more complex ones, using the data to
    perform related actions, and so on. This domain logic is often embedded into a
    page script, making that logic difficult to reuse and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter describes one way to extract domain behaviors into a separate
    layer. In many ways, this chapter forms the very core of the book: everything
    before now has led us to this central concern of the legacy application, and everything
    that comes after will lead us into layers above and around this core functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Domain or Model?**'
  prefs: []
  type: TYPE_NORMAL
- en: The domain logic in the legacy application is the model portion of model-view-controller.
    However, the legacy codebase is unlikely to have separate entity objects that
    provide a full model of the business domain. Thus, we will be speaking in terms
    of domain logic and not model logic throughout this chapter. If we are lucky enough
    to have separate model objects already, so much the better.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded Domain Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have extracted SQL statements, the page scripts and classes are
    probably manipulating the results and performing other actions related to the
    retrieved data. These manipulations and actions are the core of the domain logic,
    and it is currently embedded along with other non-domain concerns.
  prefs: []
  type: TYPE_NORMAL
- en: We can see an example of the progression from embedded SQL to using *Gateway*
    classes by examining the differences between the code in [Appendix B](apb.xhtml
    "Appendix B. Code before Gateways"), *Code before Gateway* and [Appendix C](apc.xhtml
    "Appendix C. Code after Gateways"), *Code after Gateway*. The code is too lengthy
    to present here. What we want to notice is that even after extracting the embedded
    SQL statements, the code is still doing a lot of work with the incoming and outgoing
    data before the results are presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Having the domain logic embedded in the page script makes it very difficult
    to test that logic in isolation. We also cannot reuse it easily. If we wanted
    to search for repetition and duplication in how we work with the domain entities
    (in this case a series of articles) we would need to review every page script
    in the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: The solution here is to extract the domain logic to one or more classes so that
    we can test them independently of any particular page script. We can then instantiate
    the domain logic classes and use them in any page script we like.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can apply that solution, we need to determine how to structure the
    target classes for our domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: Domain logic patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Martin Fowler''s **Patterns of Enterprise Application Architecture** (**PoEAA**)
    catalogs four domain logic patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction Script**: It organizes [domain] logic primarily as a single procedure,
    making calls directly to the database or through a thin database wrapper. Each
    transaction will have its own Transaction Script, although common subtasks can
    be broken into subprocedures."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain Model**: It creates a web of interconnected objects, where each object
    represents some meaningful individual, whether as large as a corporation or as
    small as a single line on an order form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table Module**: It organizes domain logic with one class per table in the
    database, and a single instance of a class contains the various procedures that
    will act on the data, if you have many orders, a Domain Model will have one order
    object per order while a Table Module will have one object to handle all orders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Layer**: It defines an application''s boundary and its set of available
    operations from the perspective of interfacing client layers. It encapsulates
    the application''s business logic, controlling transactions and coordinating responses
    in the implementation of its operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I strongly recommend purchasing PoEAA in hard copy and reading the pattern descriptions
    and examples in full. The book is an absolute must-have reference for the professional
    programmer. I find myself consulting it on a weekly basis (sometimes more often)
    and it always provides clarity and insight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice before us now is this: given the existing structure of our legacy
    application, which of these patterns best fits the architecture currently in place?'
  prefs: []
  type: TYPE_NORMAL
- en: We will dismiss Service Layer at this point, since it implies a level of sophistication
    that is probably not present in our legacy application. We will likewise dismiss
    Domain Model, since it implies a well-designed set of business entity objects
    that encapsulate behavior. If the legacy application already has one of these
    patterns implemented, then so much the better. Otherwise, that leaves us with
    the Table Module and Transaction Script patterns.
  prefs: []
  type: TYPE_NORMAL
- en: When we extracted our SQL statements to `Gateway` classes in the previous chapter,
    those `Gateway` classes were likely to follow the Table Data Gateway pattern,
    in particular if they were simple enough to interact with only a single table
    per `Gateway` class. This makes it seem like the Table Module pattern would be
    a good fit for our domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is unlikely that each remaining page script or class with embedded
    domain logic is interacting with a single table at a time. More frequently, legacy
    applications have many interactions across many tables in a single class or script.
    As such, we will begin by using the Transaction Script pattern when we extract
    our domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction Script is admittedly a simple pattern to follow. With it, we extract
    the domain logic from the page script and dump it into a class method mostly intact.
    We make modifications to the logic only for getting data into and out of the class
    method so that the original code can still operate properly.
  prefs: []
  type: TYPE_NORMAL
- en: Although we may wish for something more sophisticated than Transaction Script,
    we have to remember that one of our goals here is to avoid changing the existing
    logic too dramatically. We are refactoring, not rewriting. What we want right
    now is to move the code around so that it can be tested and reused appropriately.
    Thus, a Transaction Script is probably the best way to wrap our legacy domain
    logic as-it-exists, not as-we-want-it-to-be.
  prefs: []
  type: TYPE_NORMAL
- en: Once we extract the domain logic to its own layer, we will then be able to see
    that logic more clearly and with less distraction. At that point, if it is truly
    needed, we can begin to plan a refactoring of the domain layer to something more
    sophisticated. For example, we may build a Service Layer that uses Table Modules
    or a Domain Model to coordinate the various domain interactions. The interface
    presented to the page scripts by the Service Layer might remain completely unchanged
    from the Transaction Script interface, although the underlying architecture may
    have changed completely. But that is a task for another day.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What about Active Record?**'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby on Rails is famous for using the Active Record pattern, and many PHP developers
    love that kind of database interaction. It definitely has its strengths. However,
    Fowler classifies Active Record as a data source architecture pattern, not a domain
    logic pattern, so we will not be addressing it here.
  prefs: []
  type: TYPE_NORMAL
- en: The Extraction Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of the refactoring processes described in this book, extracting domain logic
    is going to be the most difficult, time consuming, and detail-oriented. This is
    a very tough thing to do, and it requires a lot of care and attention. The domain
    logic is the very core of our legacy application, and we need to make sure to
    pull out just the right parts. This means success is completely dependent on our
    familiarity and competence with the the legacy application as it exists now.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, our prior exercises in modernizing our legacy codebase have given us
    a broad overview of the application as a whole, as well as deep knowledge of the
    specific parts we have had to extract and refactor. This should endow us with
    the confidence to complete this task successfully. It is a demanding, but ultimately
    satisfying, activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, we proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the entire codebase for uses of `Gateway` classes that exist outside
    `Transactions` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where we find `Gateway` usage, examine the logic surrounding the `Gateway` operations
    to discover which portions of that logic are related to the domain behaviors of
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the relevant domain logic to one or more `Transactions` classes related
    to the domain elements, and modify the original code to use the `Transactions`
    class instead of the embedded domain logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check to make sure the original code still works properly, and modify the
    extracted logic as necessary to ensure correct operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write tests for the extracted `Transactions` logic, refining them along with
    the tested code until they pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When all original tests and new tests pass, commit the code and tests, push
    to the common repository, and notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search again for uses of `Gateway` classes, and continue extracting domain logic
    until `Gateway` usage exists only in `Transactions`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for uses of Gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in earlier chapters, we use our project-wide search facility to find where
    we create new instances of `Gateway` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The new `Gateway` instance may be used directly in a page script, in which case
    we have found some candidate code for extracting domain logic. If the `Gateway`
    instance is injected into a class, we now need to dive into that class to find
    where the `Gateway` is used. The code surrounding that usage will be our candidate
    for extracting domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: Discover and Extract Relevant Domain Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When extracting logic to a class method, we should be careful to follow all
    the lessons we learned about dependency injection in prior chapters. Among other
    things, this means: no use of globals, replacing superglobals with a `Request`
    object, no use of the `new` keyword outside `Factory` classes, and (of course)
    injecting objects via the constructor as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we have found some candidate code using a `Gateway`, we need to examine
    the code surrounding `Gateway` usage for these and other operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing, filtering, sanitizing, and validating of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculation, modification, creation, and manipulation of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequential or concurrent operations and actions using the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retention of success/failure/warning/notice messages from those operations and
    actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retention of values and variables for later inputs and outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These and other pieces of logic are likely to be domain-related.
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully extract the domain logic to one or more `Transactions` classes
    and methods, we will have to perform these and other activities:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking up or reorganizing the extracted domain logic into support methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking up or reorganizing the original code to wrap around the new `Transactions`
    calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retaining, returning, or reporting data needed by the original code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding, changing, or removing variables in the original code related to the
    extracted domain logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and injecting dependencies for the `Transactions` classes and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Discovery-and-extraction is best thought of as a learning exercise. Picking
    apart the legacy application like this is a way of learning how the application
    is constructed. As such, we should not be afraid to make multiple attempts at
    extraction. If our first attempt fails, ends up ugly, or gives poor results, we
    should feel no guilt about scrapping the work and starting over, having learned
    a little more about what works and what doesn't. For my own part, I often make
    two or three passes at extracting domain logic before the work is completed to
    my satisfaction. This is where a revision control system makes our life so much
    easier; we can work piecemeal, committing only as we are happy with the result,
    and reverting back to earlier stages if we need to begin again from a clean slate.
  prefs: []
  type: TYPE_NORMAL
- en: Example Extraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By way of example, recall the code we started with in [Appendix B](apb.xhtml
    "Appendix B. Code before Gateways"), *Code before Gateways*. Earlier in this chapter
    we mentioned that we had extracted embedded SQL statements to *ArticlesGateway*
    classes, ending up with the code in [Appendix C](apc.xhtml "Appendix C. Code after
    Gateways"), *Code after Gateways*. We now go from that to [Appendix D](apd.xhtml
    "Appendix D. Code after Transaction Scripts"), *Code after Transaction Scripts*
    where we have extracted the domain logic to an `ArticleTransactions` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The extracted domain logic does not appear particularly complicated in its
    completed form, but actually doing the work turns out to be quite detailed. Review
    the [Appendix C](apc.xhtml "Appendix C. Code after Gateways"), *Code after Gateways*
    and compare to the [Appendix D](apd.xhtml "Appendix D. Code after Transaction
    Scripts"), *Code after Transaction Scripts*. Among other things, we should find
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We discovered two separate transactions being performed in the page script:
    one to submit a new article, and one to update an existing article. In turn, these
    each needed to operate on the user''s credit counts in the database, along with
    various data normalizing and support operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We extracted the relevant domain logic to an `ArticleTransactions` class and
    two separate methods, one for creating and one for updating. We named the `ArticleTransactions`
    methods for the domain logic being performed, not for the implemenation of the
    underlying technical operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input filtering has been encapsulated as a support method in the `ArticleTransactions`
    class for reuse across both of the transaction methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `ArticleTransactions` class receives `ArticlesGateway` and `UsersGateway`
    dependencies to manage the database interactions instead of making direct SQL
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several variables that were related only to the domain logic have been removed
    from the page script and placed into the `Transactions` class as properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in the original page script has been greatly reduced. It is now essentially
    an object creation and injection mechanism, passing user inputs to the domain
    layer and getting back data to output later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the domain logic is now encapsulated, the original code can no longer
    see the `$failure` variable as it gets modified throughout the transaction. That
    code must now get failure information from the `ArticleTransactions` class for
    later presentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the extraction, we have a `classes/` directory structure that looks something
    like the following. This is a result of using a domain-oriented class structure
    when we extracted SQL to `Gateway` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This need not be our final refactoring. Further modifications of the `ArticleTransactions`
    are still possible. For example, instead of injecting a `UsersGateway`, it might
    make sense to extract various domain logic related to users into a `UserTransactions`
    class and inject that instead. There is still a lot of repetition between the
    `Transactions` methods. We also need better error checking and condition reporting
    in the `Transactions` methods. These and other refactorings are secondary, and
    will be both more noticeable and easier to deal with only after the primary extraction
    of domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: Spot check the remaining original code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have extracted one or more *Transactions* from the original code, we
    need to make sure the original code works when using the *Transactions* instead
    of the embedded domain logic. As before, we do this by running our pre-existing
    characterization tests. If we do not have characterization tests, we must browse
    to or otherwise invoke the changed code. If these tests fail, we rejoice! We have
    discovered that the extraction was flawed, and we have a chance to fix it before
    we deploy to production. If the "tests" pass, we likewise rejoice, and move on.
  prefs: []
  type: TYPE_NORMAL
- en: Write tests for the extracted transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now know the original code works with the newly extracted *Transactions*
    logic. However, the new classes and methods need their own set of tests. As with
    everything else related to extracting domain logic, writing these tests is likely
    to be detailed and demanding. The logic is probably convoluted, with lots of branches
    and loops. We should not let this deter us from testing. At the very least, we
    need to write tests that cover the main cases of the domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, we may refactor the extracted logic to separate methods that are
    themselves more easily testable. Breaking up the extracted logic will make it
    easier for us to see the flow and find repeated elements of logic. We must remember,
    though, that our goal is to maintain the existing behavior, not change the behavior
    presented by the legacy application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For insights and techniques on how to make the extracted logic more testable,
    please see *Refactoring* ([http://refactoring.com/](http://refactoring.com/))by
    Martin Fowler et al., as well as *Working Effectively With Legacy Code* ([https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/01311))by
    Michael Feathers.
  prefs: []
  type: TYPE_NORMAL
- en: Spot check again, Commit, Push, Notify QA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, because our testing and related refactoring of the extracted *Transactions*
    logic may have introduced some unexpected changes, we spot check the original
    code one more time using our characterization tests or by otherwise invoking the
    relevant code. If these fail, we rejoice! We have found out that our changes were
    not as good as we thought, and we have a chance to correct the code and tests
    before they get too far away from us.
  prefs: []
  type: TYPE_NORMAL
- en: When both the original code tests and the extracted *Transactions* tests pass,
    we rejoice again! We can now commit all of our new work, push it to the central
    repository, and notify QA that our modernized code is ready for them to review.
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We begin the extraction process over again by looking for another *Gateway*
    usage outside a *Transactions* class. We continue extracting and testing until
    all *Gateway* calls occur inside *Transactions* classes.
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are we talking about SQL transactions?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term Transaction Script refers to an architectural pattern, and does not
    mean the the domain logic must be wrapped in an SQL transaction. It is easy to
    confuse the two ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, keeping SQL transactions in mind may help us when extracting
    domain logic. One useful rule-of-thumb is that pieces of domain logic should be
    split up according to how well they would fit inside a single SQL transaction.
    That hypothetical transaction would be committed, or rolled back, as an atomic
    whole.
  prefs: []
  type: TYPE_NORMAL
- en: This singularity-of-purpose will help us determine where the boundaries of our
    domain logic lie. We do not actually add SQL transactions, it is just that thinking
    in those terms can give us some insight as to the boundaries of the domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: What about repeated Domain Logic?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we extracted SQL statements to `Gateway` classes, we sometimes found queries
    that were similar but not exactly identical. We had to determine if there was
    a way to combine them into a single method or not.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, we may discover that some parts of our legacy domain logic
    have been copied and pasted in two or more locations. When we find these, we have
    the same problem as with our `Gateway` classes. Are the pieces of logic similar
    enough to be combined into a single method, or must they be different methods
    (or even in completely different `Transactions`)?
  prefs: []
  type: TYPE_NORMAL
- en: The answer here is it depends. In some cases the repeated code will be an obvious
    copy of logic elsewhere, meaning we can reuse existing `Transactions` methods.
    If not, we need to extract to a new `Transactions` class or method.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a middle path, where the domain logic as a whole is different,
    but there are support elements of logic that are identical across different `Transactions`.
    In these cases, we can refactor the supporting logic as methods on an abstract
    base `Transactions` class, and then extend new `Transactions` from it. Alternatively,
    we can extract the logic to a supporting class and inject it into our `Transactions`.
  prefs: []
  type: TYPE_NORMAL
- en: Are printing and echoing part of Domain Logic?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our `Transactions` classes should not be using `print` or `echo`. The domain
    logic should only return or retain data.
  prefs: []
  type: TYPE_NORMAL
- en: When we discover output generation in the middle of our domain logic, we should
    extract that portion so that it lies outside of the domain logic. In general,
    this means collecting output in the `Transactions` class and then either returning
    it or making it available by a separate method. Leave output generation for the
    presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Can a transaction be a class instead of a Method?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the examples, we showed *Transactions* as a collection of methods related
    to a particular domain entity, such as *ArticleTransactions*. Each part of the
    domain logic related to that entity was wrapped in a class method.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is also reasonable to break up domain logic into a one-class-per-transaction
    structure. Indeed, some transactions may be complex enough that they truly require
    their own separate classes. There is nothing wrong with using a single class to
    represent a single domain logic transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the earlier *ArticleTransactions* class might be split into an
    abstract base class with support methods, and two concrete classes for each of
    the extracted pieces of domain logic. Each of the concrete classes extends the
    *AbstractArticleTransaction*, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we use a one-class-per-transaction approach, what do we name the main method
    on the single-transaction class, the one that actually performs the transaction?
    If there is a common convention for main methods that already exist in our legacy
    codebase, we should adhere to that convention. Otherwise, we need to pick a single
    consistent method name. Personally, I enjoy co-opting the `__invoke()` magic method
    for this purpose, but you may wish to use `exec()` or some other appropriate term
    to indicate we are executing or otherwise performing the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: What about Domain Logic in Gateway classes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we extracted our SQL statements to `Gateway` classes, it is possible that
    we moved some domain logic into them instead of leaving that logic in its original
    location. At that earlier point in our refactoring work, it was very easy to confuse
    domain-level input filtering (which makes sure the data conforms to a domain-specific
    state) with database-level filtering (which makes sure the data is safe to use
    with the database).
  prefs: []
  type: TYPE_NORMAL
- en: Now we can more easily tell the difference between the two. If we discover that
    there is domain-level logic in our `Gateway` classes, we should probably extract
    it to our `Transactions` classes instead. We need to be sure to update the relevant
    tests as well.
  prefs: []
  type: TYPE_NORMAL
- en: What about Domain logic embedded in Non-Domain classes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples in this chapter show domain logic embedded in page scripts. It
    is just as likely that we have domain logic embedded in classes as well. If the
    class can reasonably be considered part of the domain, and contains only domain-related
    logic, but is not named for the domain, it may be wise to move the class into
    the domain namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the class has any responsibilities other than domain logic, we
    may proceed to extract the domain logic from it in the same way that we extracted
    logic from a page script. After the extraction, the original class will then need
    to have the relevant `Transactions` class injected as a dependency. The original
    class should then make calls to the `Transactions` as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point we have extracted the core of our legacy codebase, the domain
    logic that sits at the center our application, to its own separate and testable
    layer. This has been the most demanding of the steps in our modernization process,
    but it has been very much worth our time. We have not made many modifications
    or improvements to the domain logic itself. Any changes we have made have been
    just enough to get data into our new `Transactions` classes and then out again
    for later use.
  prefs: []
  type: TYPE_NORMAL
- en: In a lot of ways, all we have done is shuffle the logic around so that it is
    independently addressable. Although the domain logic itself may still have many
    problems, those problems are now *testable* problems. We can continue adding tests
    as needed to explore edge cases in our domain logic. If we need to add new domain
    logic, we can create or modify our `Transactions` classes and methods to encapsulate
    and test that logic.
  prefs: []
  type: TYPE_NORMAL
- en: The process of extracting domain logic to its own layer leaves us with a great
    foundation for further iterative refactoring of the domain model. If we choose
    to pursue it, that refactoring will lead us to a more appropriate architecture
    for the application domain logic. However, what that architecture will be depends
    on the application. For more information on developing a good domain model for
    our application, please read *Domain Driven Design* ([https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215))
    by Eric Evans.
  prefs: []
  type: TYPE_NORMAL
- en: With the extraction of our domain logic to its own layer, we can continue on
    to the next phase of our modernization process. At this point there are only a
    few concerns remaining in our original code. Of those concerns, we will next address
    the presentation layer.
  prefs: []
  type: TYPE_NORMAL
