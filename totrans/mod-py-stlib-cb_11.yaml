- en: Web Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Treating JSON—how to parse and write JSON objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing URLs—how to parse the path, query, and other parts of a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming HTTP—how to read data from an HTTP endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting forms to HTTP—how to POST HTML forms to an HTTP endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building HTML—how to generate HTML with proper escaping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving HTTP—serving dynamic content over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files—how to serve static files over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors in web applications—how to report errors in web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling forms and files—parsing data received from HTML forms and uploaded
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST API—serving a basic REST/JSON API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling cookies—how to handle cookies to identify a returning user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP protocol and, more generally, the web set of technologies, are being
    recognized as an effective and robust way to create distributed systems that can
    leverage a widespread and reliable way to implement inter-process communication
    with ready available technologies and paradigms for caching, error propagation,
    reiterable requests, and best practices for contexts where services might fail
    without impacting the overall system status.
  prefs: []
  type: TYPE_NORMAL
- en: Python has many very good and reliable web frameworks, from full stack solutions,
    such as Django and TurboGears, to more finely tweakable frameworks, such as Pyramid
    and Flask. However, for many cases, the standard library might already provide
    the tools you need to implement an HTTP-based software without the need to rely
    on external libraries and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some some common recipes and tools provided
    by the standard library that can be convenient in the context of HTTP and web-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Treating JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most frequent needs when working with web-based solutions is parsing
    and speaking JSON. Python has built-in support for XML and HTML, but also for
    JSON encoding and decoding.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON encoder can also be specialized to handle non-standard types, such
    as dates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JSONEncoder` and `JSONDecoder` classes can be specialized to implement
    custom encoding and decoding behaviors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our custom encoder can then be passed to `json.dumps` to encode the JSON output
    according to our rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also encode any custom class as far as it provides a `__json__` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be a JSON object that contains the provided data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading back-encoded values will, by the way, lead to plain strings being decoded,
    because they are not JSON types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to also parse back dates, we can try to specialize a `JSONDecoder`
    to guess whether a string contains a date in ISO 8601 format and try to parse
    it back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Loading back at previous data should lead to the expected types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To generate JSON representation of Python objects, the `json.dumps` method
    is used. This method accepts an additional argument, `cls`, where a custom encoder
    class can be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `default` method of the provided class will be called whenever it is required
    to encode an object that the encoder doesn't know how to encode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `CustomJSONEncoder` class provides a `default` method that handles encoding
    dates, times, generators, decimals, and any custom class that provides a `__json__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is done by checking one after the other the properties of the encoded object.
    Remember that objects that the encoder knows how to encode won't be provided to
    the `default` method; only objects that the encoder doesn't know how to treat
    will be passed to the `default` method.
  prefs: []
  type: TYPE_NORMAL
- en: So we only have to check for the objects we want to support additionally to
    the standard ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first check is to verify if the provided object has a `__json__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For any object that has a `__json__` attribute that is a callable, we will rely
    on calling it to retrieve a JSON representation of the object. All the `__json__`
    method has to do is return any object that the JSON encoder knows how to encode,
    usually a `dict` where the properties of the object will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the case of dates, we will encode them using a simplified form of the ISO
    8601 format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This usually allows easy parsing from clients, such as JavaScript interpreters
    that might have to build `date` objects back from the provided data.
  prefs: []
  type: TYPE_NORMAL
- en: '`Decimal` is just converted to a floating point number for convenience. This
    will suffice in most cases and is fully compatible with any JSON decoder without
    any additional machinery required. Of course, nothing prevents us from returning
    a more complex object, such as a dictionary, to retain fixed precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, generators are consumed and a list of the contained values is returned
    from them. This is usually what you would expect, and representing the generator
    logic itself would require an unreasonable effort to guarantee cross-languages
    compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For any object we don''t know how to handle, we just let the parent implement
    the `default` method and proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will just complain that the object is not JSON-serializable and will inform
    the developer that we don't know how to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: The custom decoder support instead works slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: While the encoder will receive objects that it knows and objects that it doesn't
    know (as the Python objects are richer than the JSON objects), it's easy to see
    how it can only request additional guidance for the objects that it doesn't know
    and behave in a standard way for those that it knows how to handle.
  prefs: []
  type: TYPE_NORMAL
- en: The decoder instead receives only valid JSON objects; otherwise, the provided
    string wouldn't be valid JSON at all.
  prefs: []
  type: TYPE_NORMAL
- en: How can it know that the provided string must be decoded as a normal string
    or if it should ask for additional guidance?
  prefs: []
  type: TYPE_NORMAL
- en: It can't, and for this reason it asks for guidance on any single decoded object.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why the decoder is based on an `object_hook` callable that
    will receive every single decoded JSON object and can check it to perform additional
    transformations or it can let it go if the normal decoding was the right one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our implementation, we subclassed the decoder and provided a default `object_hook`
    argument that is based on a local class method, `parse_object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parse_object` method will then receive any JSON object that was found
    decoding the JSON (top or nested ones); thus, it will receive a bunch of dictionaries
    that it can check in any way that is needed and edit their content to perform
    additional conversions on top of those performed by the JSON decoder itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The received argument is actually a full JSON object, so it will never be a
    single field alone; it will always be an object (so, a full Python dictionary
    with multiple key values).
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You won't receive a `g` key but you will receive the whole Python dictionary.
    This means that if your JSON document has no nested JSON objects, your `object_hook`
    will be called exactly once with the whole document and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our custom `object_hook` provided by the `parse_object` method iterates
    over all the properties of the decoded JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And as dates and times in JSON are usually represented in strings in ISO 8601
    format, it just ignores everything that is not a string.
  prefs: []
  type: TYPE_NORMAL
- en: We are perfectly fine with the way numbers, lists, and dictionaries were converted
    (you might have to jump into lists if you expect dates to be placed inside lists)
    so if the value is not a string, we just skip it.
  prefs: []
  type: TYPE_NORMAL
- en: When the value is a string instead, we check its properties and if we guess
    it might be a date, we try to parse it as a date.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can consider a proper definition of a date: three values separated by two
    dashes, followed by three values separated by two colons with a `"T"` in the middle
    splitting the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If that definition is matched, we actually try to decode it as a Python `datetime`
    object and replace the value in the decoded JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably noticed that while encoding Python to JSON is fairly reasonable
    and robust, the trip back is full of issues.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is not a very expressive language; it doesn't provide any machinery for
    custom types, so you have a standard way to give back hints to the decoder about
    the type that you would expect something to be decoded to.
  prefs: []
  type: TYPE_NORMAL
- en: While we can *guess* that something like `2017-01-01T13:21:17` is a date, we
    have no guarantee at all. Maybe, originally, it was actually some text that by
    chance contained something that can be decoded as a date, but was never meant
    to become a `datetime` object in Python.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it's usually safe to implement custom decoding only in constrained
    environments. If you know and control the source you will be receiving data from,
    it's usually safe to provide custom decoding. And you might want to go for extending
    JSON with custom properties that might guide the decoder (like having a `__type__`
    key that tells you whether it's a date or a string), but in the open web world,
    it is usually not a very good idea to try to guess what people are sending you,
    as the web is very diverse.
  prefs: []
  type: TYPE_NORMAL
- en: There are extended standard versions of JSON that try to solve exactly this
    ambiguity in decoding data, such as JSON-LD and JSON Schema, that allow you to
    express more complex entities in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel the need, you should rely on those standards to avoid the risk of
    reinventing the wheel and facing limits of your solution that were already solved
    by existing standards.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with web-based software, it's frequently necessary to understand
    links, protocols, and paths.
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to rely on regular expressions or strings splitting to
    parse URLs, but if you account for all the oddities a URL might include (things
    such as credentials or particular protocols), it might not be as easy as you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides utilities in the `urllib` and `cgi` modules that make life easier
    when you want to account for all the possible different formats a URL can have.
  prefs: []
  type: TYPE_NORMAL
- en: Relying on them can make life easier and your software more robust.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `urllib.parse` module has multiple tools to parse URLs. The most commonly
    used solution is to rely on `urllib.parse.urlparse`, which can handle the most
    widespread kinds of URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be called on the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The returned `OrderedDict` contains all the parts that compose our URL and also,
    for the query arguments, it provides them already parsed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nowadays, the URIs also support parameters to be provided at each path segment.
    Those are very rarely used in practice, but if your code is expected to receive
    those kind of URIs, then you should not rely on `urllib.parse.urlparse` because
    it tries to parse the parameters from the URL, which is not properly supported
    for those URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that parameters for the last part of the path were properly
    parsed in `params`, but the parameters for the first part were left in `path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such case, you might want to rely on `urllib.parse.urlsplit`, which won''t
    parse the parameters and will leave them as they are for you to parse. So you
    can split the URL segments from the parameters on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See that, in this case, all parameters were left in place in `path` and you
    can then split them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be interacting with a third-party service based on HTTP REST APIs,
    or you might be fetching content from a third party or just downloading a file
    that your software needs as the input. It doesn't really matter. Nowadays, it's
    virtually impossible to write an application and ignore HTTP; you will have to
    face it sooner or later. People expect HTTP support from all kind of applications.
    If you are writing an image viewer, they probably expect to be able to throw a
    URL that leads to an image to it and see it appear.
  prefs: []
  type: TYPE_NORMAL
- en: While they have never been really user friendly and obvious, the Python standard
    library has always had ways to interact with HTTP, and they are available out
    of the box.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `urllib.request` module provides the machinery required to submit an HTTP
    request. A light wrapper around it can solve most needs in terms of using HTTP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use our `http_request` function to perform requests to fetch files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use it to interact with JSON-based APIs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it can be used to submit or upload data to endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `http_request` method takes care of creating a `urllib.request.Request`
    instance, sending it through the network and fetching back the response.
  prefs: []
  type: TYPE_NORMAL
- en: A request is sent to the specified URL to which query arguments are appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing the function does is parse the URL, so that it can replace
    parts of it. This is done to be able to replace/append the query arguments with
    the one provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`urllib.parse.urlencode` will accept a dictionary of arguments, such as`{''a'':
    5, ''b'': 7}`, and will give you back the string with the `urlencode` arguments:
    `''b=7&a=5''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting query string is then placed into the parsed parts of the `url`
    to replace the currently existing query arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the `url` is built back from all the parts that now include the right
    query arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `url` with the encoded query is ready, it builds a request out of
    it, proxying the specified method, headers, and body of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When doing a plain `GET` request, those will be the default ones, but being
    able to specify them allows us to perform also more advanced kinds of requests,
    such as `POST`, or provide special headers into our requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request is then opened and the response is read back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The response comes back as a `urllib.response.addinfourl` object, with two
    relevant parts: the body of the response and an `http.client.HTTPMessage`, from
    which we can get all the response info, such as headers, URL, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The body is retrieved by reading the response like a file, while the `HTTPMessage` is
    retrieve through the `info()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the retrieved info, we can check whether the response is a JSON response,
    and in this case, we decode it back to a dictionary so we can navigate the response
    instead of just receiving plain bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For all responses, we return the message and the body. The caller can just
    ignore the message if it''s not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making HTTP requests can be very simple for simple cases and very complicated
    for more complex cases. Perfectly handling the HTTP protocol can be a long and
    complex job, especially since the protocol specifications themselves are not always
    clear in enforcing how things should work and a lot comes from experience of how
    real existing web servers and clients work.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, if you have needs that go further than just fetching simple
    endpoints, you might want to rely on a third-party library for performing HTTP
    requests, such as the requests library that is available for nearly all Python
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting forms to HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you have to interact with HTML forms or upload files. This usually
    requires handling the `multipart/form-data` encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Forms can mix files and text data, and there can be multiple different fields
    within a form. Thus, it requires a way to express multiple fields in the same
    request and some of those fields can be binary files.
  prefs: []
  type: TYPE_NORMAL
- en: That's why encoding data in multipart can get tricky, but it's possible to roll
    out a basic recipe using only standard library tools that will work in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '`multipart` itself requires tracking all the fields and files we want to encode
    and then performing the encoding itself.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will rely on `io.BytesIO` to store all the resulting bytes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then provide and encode our `form` data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this with our `http_request` method from previous recipe, we can submit
    any `form` through HTTP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `httpbin` properly received our `file1` and and our `name` field
    and processed both.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`multipart` is practically based on encoding multiple requests within a single
    body. Each part is separated by a **boundary** and within the boundary lies the
    data of that part.'
  prefs: []
  type: TYPE_NORMAL
- en: Each part can provide both data and metadata, such as the content type of the
    provided data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way the receiver can know whether the contained data is binary, text,
    or whatever. For example, the part specifying the value for the `surname` field
    of a `form` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And the part providing data for an uploaded file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `MultiPartForm` allows us to store aside both plain `form` fields by setting
    them with dictionary syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call it on a command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And to provide files by adding them with the `add_file` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call this method on a command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Those just record the wanted fields and files in a dictionary and a list that
    are only used later on when `_generate_bytes` is called to actually generate the
    full multipart content.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the hard work is done by `_generate_bytes` that goes through all those
    fields and files and creates a part for each one of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As the boundary must separate every part, it's very important to verify that
    the boundary is not contained within the data itself, or the receiver might wrongly
    consider a part ended when it encounters it.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why our `MultiPartForm` class generates a `boundary`, checks whether
    it''s contained within the multipart response, and if it is, it generates a new
    one, until it can find a `boundary` that is not contained within the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have found a valid `boundary`, we can use it to generate the multipart
    content and return it to the caller with the content type that must be used (as
    the content type provides a hint to the receiver about which `boundary` to check):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multipart encoding is not an easy subject; for example, encoding of names within
    the multipart body is not an easy topic.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, it was changed and discussed multiple times about what's the
    proper encoding for the name of fields and name of files within the multipart
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, it's safe to only rely on plain ASCII names in those fields, so
    if you want to make sure the server you are submitting data to is able to properly
    receive your data, you might want to stick to simple filenames and fields that
    don't involve Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, multiple other ways to encode those fields and filenames were
    suggested. UTF-8 is one of the officially supported fallback for HTML5\. The suggested
    recipe relies on UTF-8 to encode filenames and fields, so that it's backward compatible
    with cases where plain ASCII names are used but it's still possible to rely on
    Unicode characters when the server supports them.
  prefs: []
  type: TYPE_NORMAL
- en: Building HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you are building a web page, an email, or a report, you are probably
    going to rely on replacing placeholders in an HTML template with actual values
    that you need to show to your users.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw in [Chapter 2](eef0828f-f070-4a09-b37e-db0d62134ac5.xhtml), *T**ext
    Management*, how a minimal, simple template engine can be implemented, but it
    wasn't specific to HTML in any way.
  prefs: []
  type: TYPE_NORMAL
- en: When working with HTML, it's particularly important to pay attention to escaping
    the values provided by users, as that might lead to broken pages or even XSS attacks.
  prefs: []
  type: TYPE_NORMAL
- en: You clearly don't want your users to get mad at you just because you registered
    yourself on your website with the surname `"<script>alert('You are hacked!')</script>"`.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, the Python standard library provides escaping tools that can
    be used to properly prepare content for insertion into HTML.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Combining the `string.Formatter` and `cgi` modules, it is possible to create
    a formatter that takes care of escaping for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use the `HTMLFormatter` and the `Markup` classes while also retaining
    the ability to inject raw `html` when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We can also easily combine this recipe with the one regarding text template
    engines to implement a minimalistic HTML template engine with escaping.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever the `HTMLFormatter` has to replace a value in the format string, it
    will check whether the retrieved value has a `__html__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If that method exists, it's expected to return the HTML representation of the
    value. And that's expected to be a perfectly valid and escaped HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, the value is expected to be a string that needs escaping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it so that any value we provide to the `HTMLFormatter` gets escaped
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to avoid escaping, we can rely on the `Markup` object, which can
    wrap out a string to make it pass as is without any escaping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This works because our `Markup` object implements an `__html__` method that
    returns the string as is. As our `HTMLFormatter` ignores any value that has an
    `__html__` method, our string will get through without any form of escaping.
  prefs: []
  type: TYPE_NORMAL
- en: While `Markup` permits us to disable escaping on demand, when we know that we
    actually want HTML in there, we can apply the HTML method to any other object.
    Any object that needs to be represented in a web page can provide an `__html__` method
    and will automatically get converted to HTML according to it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can add `__html__` to your `User` class and any time you want
    to put your user in a web page, you just need to provide the `User` instance itself.
  prefs: []
  type: TYPE_NORMAL
- en: Serving HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interacting through HTTP is one of the most frequent means of communication
    between distributed applications or even totally separated software and it's also
    the foundation of all existing web applications and web-based tools.
  prefs: []
  type: TYPE_NORMAL
- en: While Python has tens of great web frameworks that can satisfy most different
    needs, the standard library itself has all the foundations that you might need
    to implement a basic web application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has a convenient protocol named WSGI to implement HTTP-based applications.
    While for more advanced needs, a web framework might be required; for very simple
    needs, the `wsgiref` implementation built into Python itself can meet our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can create a `WSGIApplication` and register any number of routes with
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are ready, we just need to serve the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked properly, by pointing your browser to `http://localhost:8000`,
    you should see an Hello World text and a link leading you to further pages providing
    query arguments, URL arguments, and being served on various URLs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `WSGIApplication` creates a WSGI server that is in charge of serving the
    web application itself (`self`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: On every request, `WSGIApplication.__call__` is called by the server to retrieve
    a response for that request.
  prefs: []
  type: TYPE_NORMAL
- en: '`WSGIApplication.__call__` scans through all the registered routes (each route
    can be registered with `app.route(path)`, where `path` is a regular expression).
    When a regular expression matches the current URL path, the registered function
    is called to produce a response of that route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a function matching the path is found, that function is called to get
    a response body and then the resulting body is returned to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Right before returning the body, `Response.send` is called to send the response
    HTTP headers and status through the `start_response` callable.
  prefs: []
  type: TYPE_NORMAL
- en: The `Response` and `Request` objects are instead used to keep around the environment
    of the current request (and any additional argument parsed from the URL), the
    headers, and status of the response. This is so that the actions called to handle
    the request can receive them and inspect the request or add/remove headers from
    the response before it's sent.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While basic HTTP-based applications can be served using the provided implementation
    of `WSGIApplication`, there is a lot that is missing or incomplete for a full
    featured application.
  prefs: []
  type: TYPE_NORMAL
- en: Parts such as caching, sessions, authentication, authorization, managing database
    connections, transactions, and administration are usually required when more complex
    web applications are involved, and they are easily provided for you by most Python
    web frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a complete web framework is out of the scope of this book and you
    should probably try to avoid reinventing the wheel when there are many great web
    frameworks available in the Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: Python has a wide range of web frameworks covering everything from full-stack
    frameworks for rapid development, such as Django; API-oriented micro frameworks,
    such as Flask; to flexible solutions, such as Pyramid and TurboGears, where the
    required pieces can be enabled, disabled, or replaced on demand, ranging from
    full-stack solutions to microframeworks.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when working on JavaScript-based applications or static websites,
    it's necessary to be able to serve the content of a directory directly from disk.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library has a ready-made HTTP server that handles requests,
    mapping them to files in a directory, so we can quickly roll our own HTTP server
    to write websites without the need to install any other tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `http.server` module provides most of what is needed to implement an HTTP
    server in charge of serving content of a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `serve_directory` can be started against any path, to serve the content
    of that path on `http://localhost:8000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Pointing your browser to `http://localhost:8000` should list the content of
    the `/tmp` directory and allow you to navigate it and see content of any file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ThreadingHTTPServer` joins `HTTPServer` with `ThreadingMixin`, which allows
    you to serve more than a single request at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: This is especially important when serving static websites because browsers frequently
    keep connections open longer than needed, and when serving a single request at
    a time, you might be unable to fetch your CSS or JavaScript files until the browser
    closes the previous connection.
  prefs: []
  type: TYPE_NORMAL
- en: For each request, the `HTTPServer` forwards it for processing to a specified
    handler. The `SimpleHTTPRequestHandler` is able to serve the requests, mapping
    them to local files on disk, but on most Python versions, it is only able to serve
    them from the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to serve requests from any directory, we provided a custom `translate_path` method,
    which replaces the path resulting from the standard implementation that is relative
    to the `SERVED_DIRECTORY` class variable.
  prefs: []
  type: TYPE_NORMAL
- en: '`serve_directory` then puts everything together and joins `HTTPServer` with
    the customized request handler to create a server able to handle requests for
    the provided path.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot has changed in more recent Python versions regarding the `http.server`
    module. The newest version, Python 3.7, already provides the `ThreadingHTTPServer`
    class out of the box and it's now possible to configure a specific directory to
    be served by `SimpleHTTPRequestHandler`, thus removing the need to customize the
    `translate_path` method to serve a specific directory.
  prefs: []
  type: TYPE_NORMAL
- en: Errors in web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, when a Python WSGI web application crashes, you get a traceback in
    the Terminal and an empty path in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: That doesn't make it very easy to debug what's going on and unless you explicitly
    check your Terminal, it might be easy to miss that your page is not showing up
    because it actually crashed.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Python standard library provides some basic debugging tools for
    web applications that make it possible to report crashes into the browser so you
    can see them and fix them without having to jump away from your browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `cgitb` module provides tools to format an exception and its traceback
    as HTML, so we can leverage it to implement a WSGI middleware that can wrap any
    web application to provide better error reporting in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`ErrorMiddleware` can be used to wrap any WSGI application, so that in case
    of errors, it will display the error into the web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, for example, grab back our `WSGIApplication` from the previous recipe,
    add a route that will cause a crash, and serve the wrapped application to see
    how errors are reported into the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Once you point your browser to `http://localhost:8000/crash`, you should see
    a nicely formatted traceback of the triggered exception.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ErrorMiddleware` receives the original application and replaces it in the
    request handling.'
  prefs: []
  type: TYPE_NORMAL
- en: All HTTP requests will be received by `ErrorMiddleware`, which will then proxy
    them to the application, returning the resulting response provided by the application.
  prefs: []
  type: TYPE_NORMAL
- en: If an exception arises while the application response was being consumed, it
    will stop the standard flow, and instead of consuming the response of the application
    any further, it will format the exception and send it back as the response to
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done because `ErrorMiddleware.__call__` in fact calls the wrapped application
    and iterates over any provided result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This approach works with both applications that return a normal response and
    applications that return a generator as the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an error arises when calling the application or while consuming the response,
    the error is trapped and a new `start_response` is attempted to notify the server
    error to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If `start_response` fails, it means that the wrapped application already called
    `start_response` and thus it's not possible to change the response status code
    or headers anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, as we can''t provide the nicely formatted response anymore, we
    just fall back to providing an error on the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If `start_response` succeeded, instead, we stop returning the content of the
    application response and, instead, we return the error and traceback, nicely formatted
    by `cgitb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, then, if it provided a `close` method, we close the application
    response. This way, if it was a file or any source that needs to be closed, we
    avoid leaking it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More complete solutions for error reporting in web applications in Python are
    available out of the standard library. If you have further needs or want to get
    the errors notified by email or through cloud error reporting solutions, such
    as Sentry, you might want to provide an error reporting WSGI library.
  prefs: []
  type: TYPE_NORMAL
- en: The `Werkzeug` debugger from Flask, the `WebError` library from the Pylons project,
    and the `Backlash` library from the TurboGears project are probably the most common
    solutions for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: You might also want to check whether your web framework provides some advanced
    error reporting configuration, as many of them provide it out of the box, relying
    on those libraries or other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Handling forms and files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When submitting forms and uploading files, they are usually sent with the `multipart/form-data`
    encoding.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw how to create data encoded in `multipart/form-data`, and submit
    it to an endpoint, but how can we handle incoming data in such a format?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cgi.FieldStorage` class in the standard library already provides all the
    machinery required to parse multipart data and send it back to you in a way that
    is easy to handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a simple web application (based on `WSGIApplication`) to show
    how `cgi.FieldStorage` can be used to parse the uploaded file and show it back
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application exposes two web pages. One is on the root of the website (through
    the `index` function) that only shows a simple form with an upload field.
  prefs: []
  type: TYPE_NORMAL
- en: The other, the `upload` function, instead receives the uploaded file and shows
    it back if it's an image or a text file. In all other cases, it will just show
    the name of the uploaded file.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is required to handle the upload in multipart format is to create
    a `cgi.FieldStorage` out of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The whole body of the `POST` request is always available in the `environ` request
    with the `wsgi.input` key.
  prefs: []
  type: TYPE_NORMAL
- en: This provides a file-like object that can be read to consume the posted data.
    Make sure you save aside the `FieldStorage` after it has been created if you need
    to use it multiple times, because once the data is consumed from `wsgi.input`,
    it becomes inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: '`cgi.FieldStorage` provides a dictionary-like interface, so we can check whether
    a file was uploaded just by checking whether the `uploadedfile` entry exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s because in our form, we provided `uploadedfile` as the name of the
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That specific field will be accessible with `form['uploadedfile']`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it''s a file, it will return an object that provides the `type`, `filename`,
    and `file` attributes through which we can check the MIME type of uploaded file
    to see whether it''s an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'And if it''s an image, we can read its content to encode it in `base64` so
    that it can be displayed by the `img` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filename` attribute is instead only used if the uploaded file is of an
    unrecognized format, so that we can at least print back the name of the uploaded
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST with JSON has become the de facto standard in cross-application communication
    technologies for web-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: It's a very effective protocol, and the fact that the definition can be understood
    by everyone made it popular pretty quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Also, a rapid REST implementation can be rolled out pretty quickly compared
    to other more complex communication protocols.
  prefs: []
  type: TYPE_NORMAL
- en: As the Python standard library provides the foundations we needed to build WSGI-based
    applications, it's not hard to extend our existing recipe to support REST-based
    dispatch of requests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use `WSGIApplication` from our previous recipe, but instead
    of registering a function for a root, we are going to register a particular class
    able to dispatch based on the request method.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the REST classes we want to implement must inherit from a single `RestController`
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can subclass `RestController` to implement all the specific `GET`,
    `POST`, `DELETE`, and `PUT` methods and register the resources on a specific route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This already provides basic functionalities that allow us to add, remove and
    list resources from an in-memory catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this, we can start a server in a background thread and use the `http_request`
    function from our previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a new resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we list them all:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a second one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we see that now both resources are listed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can ask for a specific resource out of the catalog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also delete a specific resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then see that it was actually deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This should allow us to provide a REST interface for most simple cases relying
    on what is already available in the Python standard library itself.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the magic is done by `RestController.__call__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a subclass of `RestController` is called, it will look at the HTTP
    request method and look for an instance method named like the HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: If there is one, the method is called and the response provided by the method
    itself returned. If there is none, then `self._not_found` is called, which will
    just respond a 404 error.
  prefs: []
  type: TYPE_NORMAL
- en: This relies on the `WSGIApplication.__call__` support for classes instead of
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `WSGIApplication.__call__` finds an object associated to a route through
    `app.route` that is a class, it will always create an instance of it, and then
    it will call the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: If `routed_action` is a `RestController` subclass, what will happen is that
    `routed_action = routed_action()` will replace the class with an instance of it,
    and then `routed_action(request, resp)` will call the `RestController.__call__` method
    to actually serve the request.
  prefs: []
  type: TYPE_NORMAL
- en: The `RestController.__call__` method can then forward the request to the right
    instance method based on the HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that as REST resources are identified by providing the resource identifier
    in the URL, the route assigned to `RestController` must have an `id` argument
    and an optional `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise you won't be able to distinguish between a request for the whole `GET`
    resources catalog, `/resources`, and a request for a specific `GET` resource, `/resources/3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lack of an `id` argument is exactly the way our `GET` method decided when
    to return the content for the whole catalog or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: For methods that receive the data in the request body, such as `POST`, `PUT`,
    and `PATCH`, you will have to read the request body from `req.environ['wsgi.input']`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it's important to provide exactly how many bytes to read, as the
    connection might never be closed, and the read might otherwise block forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Content-Length` header can be used to know the length of the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Handling cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are frequently used in web applications to store data in browsers. The
    most frequent use case is user identification.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to implement a very simple and insecure identification system based
    on cookies to show how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `http.cookies.SimpleCookie` class provides all the facilities required to
    parse and generate cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rely on it to create a web application endpoint that will set a cookie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to create one that will parse the cookie and tell us who the
    current user is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you start the application you can point your browser to `http://localhost:8000`
    and you should see the web application complaining that you are lacking an identity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Once you click on the suggested link, you should get one and, going back to
    the index page, it should recognize you through the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SimpleCookie` class represents a cookie, as a set of one or more values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each value can be set into the cookie as if it was a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If the cookie `morsel` has to accept more options, those can be set with dictionary
    syntax too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Each cookie can contain multiple values and each one of them should be set with
    a `Set-Cookie` HTTP header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating over the cookie will retrieve all the key/value pairs that constitute
    the cookie, and then calling `OutputString()` on them will return the cookie value
    encoded as expected by the `Set-Cookie` header, with all the additional attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Practically, once the cookie is set, calling `OutputString()` will send you
    back the string you need to send to the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading back a cookie is as simple as building it from the `environ[''HTTP_COOKIE'']`
    value if it''s available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the cookie has parsed, the values stored within it can be accessed with
    dictionary syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with cookies, one particular condition you should pay attention
    to is their life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies can have an `Expires` attribute, which will state on which date they
    should die (the browser will discard them), and actually, that's the way you delete
    a cookie. Setting a cookie again with an `Expires` date in the past will delete
    it.
  prefs: []
  type: TYPE_NORMAL
- en: But cookies can also have a `Max-Age` attribute, which states how long they
    should stick around or can be created as session cookies that will disappear when
    the browser window is closed.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you face problems with your cookies randomly disappearing or not being
    loaded back correctly, always check those properties as the cookie might just
    have been deleted by the browser.
  prefs: []
  type: TYPE_NORMAL
