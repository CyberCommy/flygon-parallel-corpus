- en: Chapter 6. Inheritance, Abstraction, Extension, and Specialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about one of the most important pillars of object-oriented
    programming in Java 9: inheritance. We will work with examples on how to create
    class hierarchies, override and overload methods, and work with the constructors
    defined in superclasses. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create class hierarchies to abstract and specialize behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an abstract base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare classes that inherit from another class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overload constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overload instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating class hierarchies to abstract and specialize behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have been creating classes in Java 9 to generate
    blueprints for real-life objects. We declared classes and then we created instances
    of these classes in JShell. Now it is time to take advantage of many of the most
    advanced features of object-oriented programming included in Java 9 and start
    designing a hierarchy of classes instead of working with isolated classes. First,
    we will design all the classes that we need based on the requirements, and then
    we will use the features available in Java 9 to code the designed classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We worked with classes to represent virtual creatures. Now, let''s imagine
    that we have to develop a complex Web Service that requires us to work with dozens
    of types of virtual animal. Many of these virtual animals will be similar to pets
    and domestic animals in the first stage of the project. The requirements specify
    that our Web Service will start working with the following four virtual animals
    that are going to be similar to the domestic animal species:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Horse** (**Equus ferus caballus**). Do not confuse this with a wild horse
    (Equus ferus). We will have male and female horses, and female horses might be
    pregnant. In addition, we will have to work with the following three specific
    horse breeds: American Quarter Horse, Shire Horse, and Thoroughbred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cockatiel** (**Nymphicus hollandicus**). This bird is also known as quarrion
    or weiro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maine Coon**. This is one of the largest domesticated breeds of cat (Felis
    silvestris catus).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domestic rabbit** (**Oryctolagus cuniculus**). This rabbit is also known
    as European rabbit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous list includes the scientific name for each domestic animal species.
    We will definitely work with the most common name for each species and just have
    the scientific name as a class constant of type `String`. Hence, we won't have
    a complex class name, such as `VirtualEquusFerusCaballus`, but we will use `VirtualHorse`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Our first requirements specify that we have to work with a limited number of
    breeds for the previously enumerated four domestic animal species. Additionally,
    in the future it will be necessary to work with other members of the listed domestic
    animal species, other domestic mammals, additional domestic birds, specific horse
    breeds, and even reptiles and birds that don't belong to the domestic animal species.
    Our object-oriented design must be ready to be expanded for the future requirements,
    as always happens in real-life projects. In fact, we will use this example to
    understand how object-oriented programming makes it easy to expand an existing
    design to consider future requirements.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to model a complete representation of the animal kingdom and its
    classification. We will just create the necessary classes to have a flexible model
    that can be easily expanded based on future requirements. The animal kingdom is
    extremely complex. We will keep our focus on just a few members of this huge family.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main goals for the following examples is to learn that object-oriented
    programming doesn't sacrifice flexibility. We will start with a simple class hierarchy
    that we will expand as the required features complexity increases and we have
    more information about these new requirements. Let's remember that requirements
    aren't fixed and that we always must add new features, and make changes to the
    existing classes based on these new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a hierarchy of classes to represent a complex classification
    of virtual animals and their breeds. When we extend a class, we create a subclass
    of this class. The following list enumerates the classes that we will create and
    their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VirtualAnimal`: This class generalizes all the members of the animal kingdom.
    Horses, cats, birds, rabbits, and reptiles have one thing in common: they are
    animals. Hence, it makes sense to create a class that will be the baseline for
    the different classes of virtual animals that we may have to represent in our
    object-oriented design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualMammal`: This class generalizes all the mammalian virtual animals.
    Mammals are different from insects, birds, amphibians, and reptiles. We already
    know that we can have female horses and that they can be pregnant. We also know
    that we will have to model reptiles and birds, and therefore, we create a `VirtualMammal`
    class that extends `VirtualAnimal` and becomes a subclass of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualBird`: This class generalizes all the birds. Birds are different from
    mammals, insects, amphibians, and reptiles. We already know that we will also
    have to model reptiles. A Cockatiel is a bird, and therefore, we will create a
    `VirtualBird` class at the same level as `VirtualMammal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualDomesticMammal`: This class extends the `VirtualMammal` class. Let''s
    do some research and we will realize that the tiger (Panthera tigris) is the largest
    and heaviest living species of the cat family. A tiger is a cat, but it is completely
    different from a Maine Coon, which is a small domestic cat. The initial requirements
    specified that we work with both virtual domestic and virtual wild animals, so
    we will create a class that generalizes all the virtual domestic mammal animals.
    In the future, we will have a `VirtualWildMammal` subclass that will generalize
    all the virtual wild mammalian animals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualDomesticBird`: This class extends the `VirtualBird` class. Let''s do
    some research and we will realize that the ostrich (Struthio camelus) is the largest
    living bird. An ostrich is a bird, but it is completely different from a Cockatiel,
    which is a small domestic bird. We will work with both virtual domestic and virtual
    wild birds, so we will create a class that generalizes all virtual domestic birds.
    In the future, we will have a `VirtualWildBird` class that will generalize all
    virtual wild birds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualHorse`: This class extends the `VirtualDomesticMammal` class. We could
    go on specializing the `VirtualDomesticMammal` class with additional subclasses
    until we reach a `VirtualHorse` class. For example, we might create a `VirtualHerbivoreDomesticMammal`
    subclass and then make the `VirtualHorse` class inherit from it. However, the
    kind of Web Service we have to develop doesn''t require any intermediary class
    between `VirtualDomesticMammal` and `VirtualHorse`. The `VirtualHorse` class generalizes
    the fields and methods required for a virtual horse in our application. The different
    subclasses of the `VirtualHorse` class will represent the diverse families of
    the virtual horse breed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualDomesticRabbit`: This class extends the `VirtualDomesticMammal` class.
    The `VirtualDomesticRabbit` class generalizes all the fields and methods required
    for a virtual domestic rabbit in our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VirtualDomesticCat`: This class extends the `VirtualDomesticMammal` class.
    The `VirtualDomesticCat` class generalizes all the fields and methods required
    for a virtual domestic cat in our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AmericanQuarterHorse`: This class extends the `VirtualHorse` class. The `AmericanQuarterHorse`
    class generalizes all the fields and methods required for a virtual horse that
    belongs to the American Quarter Horse breed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ShireHorse`: This class extends the `VirtualHorse` class. The `ShireHorse`
    class generalizes all the fields and methods required for a virtual horse that
    belongs to the Shire Horse breed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thoroughbred`: This class extends the `VirtualHorse` class. The `Thoroughbred`
    class generalizes all the fields and methods required for a virtual horse that
    belongs to the Thoroughbred breed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cockatiel`: This class extends the `VirtualDomesticBird` class. The `Cockatiel`
    class generalizes all the fields and methods required for a virtual domestic bird
    that belongs to the Cockatiel family.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaineCoon`: This class extends the `VirtualDomesticCat` class. The `MaineCoon`
    class generalizes all the fields and methods required for a virtual domestic cat
    that belongs to the Maine Coon breed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following table shows each of the classes from the previous list with its
    superclass, parent class, or supertype.
  prefs: []
  type: TYPE_NORMAL
- en: '| Subclass, child class, or subtype | Superclass, parent class, or supertype
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualMammal` | `VirtualAnimal` |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualBird` | `VirtualAnimal` |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualDomesticMammal` | `VirtualMammal` |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualDomesticBird` | `VirtualBird` |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualHorse` | `VirtualDomesticMammal` |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualDomesticRabbit` | `VirtualDomesticMammal` |'
  prefs: []
  type: TYPE_TB
- en: '| `VirtualDomesticCat` | `VirtualDomesticMammal` |'
  prefs: []
  type: TYPE_TB
- en: '| `AmericanQuarterHorse` | `VirtualHorse` |'
  prefs: []
  type: TYPE_TB
- en: '| `ShireHorse` | `VirtualHorse` |'
  prefs: []
  type: TYPE_TB
- en: '| `Thoroughbred` | `VirtualHorse` |'
  prefs: []
  type: TYPE_TB
- en: '| `Cockatiel` | `VirtualDomesticBird` |'
  prefs: []
  type: TYPE_TB
- en: '| `MaineCoon` | `VirtualDomesticCat` |'
  prefs: []
  type: TYPE_TB
- en: The following UML diagram shows the previous classes organized in a class hierarchy.
    The class names that use italic text format indicate that they are abstract classes.
    Notice that the diagram doesn't include any members, just the class names. We
    will add the members later.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating class hierarchies to abstract and specialize behavior](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a class inherits from another class, it inherits all the members that compose
    the parent class, which is also known as the **superclass**. The class that inherits
    the elements is known as a **subclass** of the superclass. For example, the `VirtualBird`
    subclass inherits all the instance fields, class fields, instance methods, and
    class methods defined in the `VirtualAnimal` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java 9, a subclass doesn't inherit any constructor from its superclass. However,
    it is possible to call the constructors defined in the superclass and we will
    do this in the next examples. Only the usage of the `private` access modifier
    in any constructor defined in a superclass can make it impossible for a subclass
    to call this constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualAnimal` abstract class is the baseline for our class hierarchy.
    We say that it is an **abstract class** because we cannot create instances of
    the `VirtualAnimal` class. Instead, we must create instances of the specific subclasses
    of `VirtualAnimal`, any subclass that isn't an abstract class. The classes that
    we can use to create instances of them are known as **concrete classes** or just
    classes in most cases. Java 9 allows us to declare classes as abstract classes
    when they aren't intended to generate instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot create instances of an abstract class by using the `new` keyword followed
    by the class name.
  prefs: []
  type: TYPE_NORMAL
- en: We require each `VirtualAnimal` to specify its age but we don't need to specify
    any name for them. We put names to domestic animals only. Hence, we will have
    to specify an age value when we create any `VirtualAnimal`, that is, any instance
    of any `VirtualAnimal` subclass. The class will define an `age` field and print
    a message whenever a virtual animal is being created.
  prefs: []
  type: TYPE_NORMAL
- en: But wait; we just explained that we are talking about an abstract class and
    that Java won't allow us to create an instance of an abstract class. We cannot
    create an instance of the `VirtualAnimal` abstract class but we will be able to
    create an instance of any concrete class that has `VirtualAnimal` as a superclass
    and this subclass can end up calling the constructor defined in the `VirtualAnimal`
    abstract class. It sounds a bit complicated but we will easily understand the
    situation after we code the classes and run the examples in JShell. We will print
    messages in each constructor we define to make it easy to understand what happens
    when we create an instance of a concrete class that has one or more superclasses,
    including one or more abstract superclasses. All the instances of the subclasses
    of `VirtualAnimal` will be instances of `VirtualAnimal` too.
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualAnimal` abstract class will define abstract class methods and abstract
    instance methods. An **abstract class method** is a class method that is declared
    without an implementation. An **abstract instance method**, also known as an abstract
    method, is an instance method that is declared without an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we declare any of the two types of abstract methods, we only declare the
    arguments (if any) and then put a semicolon (`;`). We don't use curly braces at
    all. We can only declare abstract methods in an abstract class. A concrete subclass
    of any abstract class must provide an implementation for all the inherited abstract
    methods to become a class that we can use to create instances with the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualAnimal` class will declare the following seven abstract methods
    that fulfill requirements that are going to be common to all the members of a
    specific family or type. The class will just declare their required arguments
    without an implementation for the method. The subclasses will be responsible for
    fulfilling the explained requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '`isAbleToFly`: This returns a `boolean` value indicating whether the virtual
    animal is able to fly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRideable`: This returns a `boolean` value indicating whether the virtual
    animal is rideable. A rideable animal is capable of being ridden over.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isHerbivore`: This returns a `boolean` value indicating whether the virtual
    animal is herbivore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isCarnivore`: This returns a `boolean` value indicating whether the virtual
    animal is carnivore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAverageNumberOfBabies`: This returns the average number of babies at a
    time that are usually born for the virtual animal type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getBaby`: This returns a `String` representation of a baby for the virtual
    animal type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAsciiArt`: This returns a `String` with the ASCII art (text-based visual
    art) that represents the virtual animal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VirtualAnimal` class will define the following five methods that fulfill
    the requirements for each instance. These will be concrete methods that will be
    coded in the `VirtualAnimal` class and inherited by all its subclasses. Some of
    these methods call the previously explained abstract methods. We will understand
    how this works in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: '`printAsciiArt`: This prints the `String` returned by the `getAsciiArt` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isYoungerThan`: This returns a `boolean` value indicating whether the `age`
    value for the `VirtualAnimal` is lower than the age for the `VirtualAnimal` instance
    received as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isOlderThan`: This returns a `boolean` value indicating whether the `age`
    value for the `VirtualAnimal` class is greater than the age for the `VirtualAnimal`
    instance received as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printAge`: This prints the `age` value for the virtual animal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printAverageNumberOfBabies`: This prints a representation of the average number
    of babies at a time that are usually born for the virtual animal. This method
    will take into account the value returned by the `getAverageNumberOfBabies` method
    that is going to be implemented in the different concrete subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `VirtualMammal` class inherits from `VirtualAnimal`. We will have to specify
    its age and whether it is pregnant or not when we create a new `VirtualMammal`
    instance. The class inherits the `age` property from the `VirtualAnimal` superclass,
    so it is only necessary to add a field to specify whether the virtual mammal is
    pregnant or not. Note that we will not specify the gender at any time in order
    to keep things simple. If we added gender, we would need a validation to avoid
    a male being pregnant. Right now, our focus is on inheritance. The class will
    display a message whenever a virtual mammalian animal is created; that is, whenever
    its constructor is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each class inherits from one class, and therefore, each new class we will define
    has just one superclass. In this case, we will always work with **single inheritance**.
    In Java, a class cannot inherit from multiple classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualDomesticMammal` class inherits from `VirtualMammal`. We will have
    to specify its name and its favorite toy when we create a new `VirtualDomesticMammal`
    instance. We put names to any domestic mammal and they always pick a favorite
    toy. It is true that sometimes they just choose an object that satisfies their
    appetite for destruction. In many cases, the favorite toy is not exactly the toy
    we would like them to pick (our shoes, sneakers, flip flops, or electronic devices),
    but let's keep the focus on our classes. We won't be able to change the name but
    we can change the favorite toy. We never change the name for any domestic mammal,
    but we can definitely force it to change its favorite toy. The class displays
    a message whenever a virtual domestic mammalian animal is created.
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualDomesticMammal` class will declare a `talk` instance method that
    will display a message indicating the virtual domestic mammal's name concatenated
    with the message `"says something"`. Each subclass must make the specific domestic
    mammal talk in a different way. A parrot can really talk, but we will consider
    a horse's nicker and a rabbit's tooth purring as if they were talking. Notice
    that, in this case, the `talk` instance method has a concrete implementation in
    the `VirtualDomesticMammal` class and it is not an abstract instance method. The
    subclasses will be able to provide a different implementation for this method.
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualHorse` class inherits from `VirtualDomesticMammal` and implements
    all the abstract methods inherited from the `VirtualAnimal` superclass except
    `getBaby` and `getAsciiArt`. These two methods will be implemented in each subclass
    of `VirtualHorse` that determines a horse breed.
  prefs: []
  type: TYPE_NORMAL
- en: We want horses to be able to neigh and nicker. Thus, we need both a `neigh`
    and a `nicker` method. Horses usually neigh when they are angry and they nicker
    when they are happy. It is a bit more complex than this, but we will keep things
    simple for our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `neigh` method has to allow a virtual horse to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Neigh just once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neigh a specific number of times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neigh to another virtual domestic mammal that has a name just once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neigh to another virtual domestic mammal that has a name a specific number of
    times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `nicker` method has to allow a virtual horse to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Nicker just once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nicker a specific number of times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nicker to another virtual domestic mammal that has a name just once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nicker to another virtual domestic mammal that has a name a specific number
    of times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, a horse can neigh or nicker either happily or angrily. We can have
    just one `neigh` method with default values for many of the arguments or many
    `neigh` methods. Java 9 provides many mechanisms to solve the challenges of the
    different ways in which a virtual horse must be able to neigh. We will apply the
    same solution for both the `neigh` and `nicker` methods.
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `talk` method for any virtual horse, we want it to nicker happily
    once. We don't want to display the message defined in the `talk` method introduced
    in the `VirtualDomesticMammal` class. Thus, the `VirtualHorse` class must overwrite
    the inherited `talk` method with its own definition.
  prefs: []
  type: TYPE_NORMAL
- en: We want to know the breed to which a virtual horse belongs. Thus, we will define
    a `getBreed` abstract method. Each subclass of `VirtualHorse` must return the
    appropriate `String` with a name when this method is called. The `VirtualHorse`
    class will define a method named `printBreed` that uses the `getBreed` method
    to retrieve the name and print the breed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, all the classes we have mentioned are abstract classes. We cannot
    create instances of them. The `AmericanQuarterHorse`, `ShireHorse`, and `Thoroughbred`
    classes inherit from the `VirtualHorse` class and implement the inherited `getBaby`,
    `getAsciiArt`, and `getBreed` methods. In addition, their constructors will print
    a message indicating that we are creating an instance of the respective class.
    The three classes are concrete classes and we can create instances of them.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with the `VirtualBird`, `VirtualDomesticBird`, `Cockatiel`, `VirtualDomesticCat`,
    and `MaineCoon` classes later. First, we will create the base `VirtualAnimal`
    abstract class in Java 9, and then we will use simple inheritance to create the
    subclasses up to the `VirtualHorse` class. We will override methods and overload
    methods to fulfill all the requirements. We will take advantage of polymorphism,
    which is a very important feature in object-oriented programming that we will
    understand while working with the created classes in JShell. Of course, we will
    dive deeply into many of the topics introduced while analyzing the different classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following UML diagram shows the members for all the abstract classes we
    will code in this chapter: `VirtualAnimal`, `VirtualMammal`, `VirtualDomesticMammal`,
    and `VirtualHorse`. We will code the other classes in the next chapter and we
    will add their members to the diagram later. We use the italic text format to
    indicate abstract methods. Remember that public members have a plus sign (**+**)
    as a prefix. One class has a protected member that uses a hash as a prefix (**#**).
    We will use the bold text format to indicate a method that overrides an existing
    method in a superclass. In this case, the `VirtualHorse` class overrides the `tal`
    `k()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding inheritance](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous UML diagram we will notice the following conventions. We will
    use these conventions in all the UML diagrams that include class members.
  prefs: []
  type: TYPE_NORMAL
- en: The constructors have the same name as the classes and do not specify any return
    type. They are always the first methods listed in the methods section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type for a field is indicated after the field name separated by a colon
    (**:**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each parameter in the parameter list for each method is separated by a semicolon
    (**;**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return type of a method is indicated after the parameter list for the method,
    separated by a colon (**:**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We always use Java type names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an abstract base class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will create the abstract class that will become our base class for
    the other classes. The following lines show the code for the `VirtualAnimal` abstract
    base class in Java 9\. The `abstract` keyword before `class` indicates to Java
    that we are creating an abstract class. The code file for the sample is included
    in the `java_9_oop_chapter_06_01` folder, in the `example06_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class declares an immutable field of type `int` named `age`. The
    constructor requires an `age` value to create an instance of the class and prints
    a message indicating that a virtual animal is created. The class declares the
    following abstract methods that include the `abstract` keyword before the returned
    type to let Java know we just want to declare the required arguments and that
    we won't provide an implementation for the methods. We have already explained
    the goals for these methods that will be implemented in subclasses of `VirtualAnimal`.
  prefs: []
  type: TYPE_NORMAL
- en: '`isAbleToFly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isRideable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isHerbivore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isCarnivore`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAverageNumberOfBabies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getBaby`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAsciiArt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the class declares the following five methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`printAsciiArt`: This method calls `System.out.println` to print the `String`
    returned by the `getAsciiArt` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printAverageNumberOfBabies`: This method creates a new `char` array with a
    number of elements equal to the value returned by the `getAverageNumberOfBabies`
    method. Then, the code creates a new `String` initialized with the `char` array
    and calls the `replace` method to substitute each `"\0"`, with the `String` returned
    by the `getBaby` method. This way, we generate a `String` that concatenates `getAverageNumberOfBabies`
    times the `String` returned by `getBaby`. The code calls `System.out.println`
    to print the generated `String`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`printAge`: This method calls `System.out.println` to print the `String` generated
    with `String.format` that includes the value of the `age` immutable field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isYoungerThan`: This method receives a `VirtualAnimal` instance in the `otherAnimal`
    argument and returns the result of applying the less than operator between the
    value of the `age` field for this instance and `otherAnimal.age`. This way, the
    method will return `true` only if the age for this instance is lower than the
    age for `otherAnimal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isOlderThan`: This method receives a `VirtualAnimal` instance in the `otherAnimal`
    argument and returns the result of applying the greater than operator between
    the value of the `age` field for this instance and `otherAnimal.age`. This way,
    the method will return `true` only if the age for this instance is greater than
    the age for `otherAnimal`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we execute the following line in JShell after declaring the `VirtualAnimal`
    class, Java will generate a fatal error and indicate that the `VirtualAnimal`
    class is abstract and that it cannot be instantiated. The code file for the sample
    is included in the `java_9_oop_chapter_06_01` folder, in the `example06_02.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an abstract base class](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Declaring classes that inherit from another class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will create another abstract class. Specifically, we will create a subclass
    of the recently created `VirtualAnimal` abstract class. The following lines show
    the code for the `VirtualMammal` abstract class that extends the `VirtualAnimal`
    class. Note the `abstract class` keywords followed by the class name, `VirtualMammal`,
    the `extends` keyword, and `VirtualAnimal`, that is, the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The class name that follows the `extends` keyword indicates the superclass from
    which the new class inherits in the class definition. The code file for the sample
    is included in the `java_9_oop_chapter_06_01` folder, in the `example06_03.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `VirtualMammal` abstract class inherits the members from the previously
    declared `VirtualAnimal` abstract class and adds a new `boolean` mutable field
    named `isPregnant`. The new abstract class declares two constructors. One of the
    constructors requires an `age` value to create an instance of the class, as it
    happened with the `VirtualAnimal` constructor. The other constructor requires
    the `age` and `isPregnant` values.
  prefs: []
  type: TYPE_NORMAL
- en: If we create an instance of this class with just one `age` argument, Java will
    use the first constructor. If we create an instance of this class with two arguments,
    an `int` value for `age` and a `boolean` value for `isPregnant`, Java will use
    the second constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have overloaded the constructor and provided two different constructors.
    We won't use these constructors with the `new` keyword because we are declaring
    an abstract class. However, we will be able to call these constructors from subclasses
    by using the `super` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The first constructor that requires the `isPregnant` argument uses the `super`
    keyword to call the constructor from the base class or superclass, that is, the
    constructor defined in the `VirtualAnimal` class that requires the `age` argument.
    After the constructor defined in the superclass finishes its execution, the code
    sets the value for the `isPregnant` mutable field and prints a message indicating
    that a virtual mammal has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `super` keyword to reference the superclass, and we can use this
    keyword to call any constructor defined in the superclass. In Java 9, subclasses
    do not inherit the constructors from its superclasses. In other programming languages,
    subclasses inherit constructors or initializers, and therefore, it is very important
    to understand that this doesn't happen in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: The second constructor uses the `this` keyword to call the previously explained
    constructor with the received `age` and with `false` as the value for the `isPregnant`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: We will create another abstract class. Specifically, we will create a subclass
    of the recently created `VirtualMammal` abstract class. The following lines show
    the code for the `VirtualDomesticMammal` abstract class that extends the `VirtualMammal`
    class. Note the `abstract class` keywords followed by the class name, `VirtualDomesticMammal`,
    the `extends` keyword, and `VirtualMammal`, that is, the superclass. The class
    name that follows the `extends` keyword indicates the superclass from which the
    new class inherits in the class definition. The code file for the sample is included
    in the `java_9_oop_chapter_06_01` folder, in the `example06_04.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `VirtualDomesticMammal` abstract class inherits the members from the previously
    declared `VirtualMammal` abstract class. It is important to understand that the
    new class also inherits the members that the superclass inherited from its superclass,
    that is, from the `VirtualAnimal` abstract class. For example, our new class inherits
    the `age` immutable field declared in the `VirtualAnimal` abstract class and all
    the other members declared in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VirtualDomesticMammal` class adds a new `String` immutable field called
    `name` and a new `String` mutable field named `favoriteToy`. The new abstract
    class declares two constructors. One of the constructors requires four arguments
    to create an instance of the class: `age`, `isPregnant`, `name`, and `favoriteToy`.
    The other constructor requires all the arguments except `isPregnant`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first constructor that requires the four arguments uses the `super` keyword
    to call the constructor from the base class or superclass, that is, the constructor
    defined in the `VirtualMammal` class that requires two arguments: `age` and `isPregnant`.
    After the constructor defined in the superclass finishes its execution, the code
    sets the value for the `name` and `favoriteToy` fields and prints a message indicating
    that a virtual domestic mammal has been created.'
  prefs: []
  type: TYPE_NORMAL
- en: The second constructor uses the `this` keyword to call the previously explained
    constructor with the received arguments and with `false` as the value for the
    `isPregnant` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the class declares a `talk` method that displays a message with the
    `name` value followed by a colon (`:`) and `says something`. Note that we will
    be able to override this method in any subclass of `VirtualDomesticMammal` because
    each virtual domestic mammal has a different way of talking.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding and overloading methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java allows us to define a method with the same name many times with different
    arguments. This feature is known as **method overloading**. When we created the
    previous abstract classes, we overloaded the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can take advantage of method overloading to define multiple
    versions of the `neigh` and `nicker` method that we have to define in the `VirtualHorse`
    abstract class. However, it is very important to avoid code duplication when we
    overload methods.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we define a method in a class, and we know that a subclass might
    need to provide a different version of the method. A clear example is the `talk`
    method we defined in the `VirtualDomesticMammal` class. When a subclass provides
    a different implementation of a method defined in a superclass with the same name,
    arguments, and return type, we say that we are **overriding** a method. When we
    override a method, the implementation in the subclass overwrites the code provided
    in the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `VirtualHorse` class overrides the `talk` method inherited from `VirtualDomesticMammal`.
    The code just invokes the `nicker` method without parameters because horses don't
    talk, they nicker. The method doesn't invoke the method with the same name for
    its superclass; that is, we don't use the `super` keyword to invoke the `talk`
    method defined in `VirtualDomesticMammal`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `@Override` annotation before the method declaration to inform the
    Java 9 compiler that the method is meant to override the method with the same
    name declared in a superclass. It isn't mandatory to add this annotation when
    we override methods, but it is a good practice to include it and we will always
    use it when we override methods because it helps to prevent errors. For example,
    in case we have a typo and we write `tak()` instead of `talk()` as the method
    name and arguments, the usage of the `@Override` annotation makes the Java 9 compiler
    generate an error because the `talk` method marked with `@Override` fails to override
    a method with this name and arguments in one of the superclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nicker` method is overloaded with four declarations with different arguments.
    The following lines show the four different declarations included within the class
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can call any of the defined `nicker` methods based on the provided
    arguments. The four methods end up invoking the `printNicker` public method with
    different default values for the arguments with the same names not provided in
    the call to `nicker`. The method calls the `printSoundInWords` public method with
    `"Nicker "` as the value for the `soundInWords` arguments and the other arguments
    set to the received arguments that have the same names. This way, the `printNicker`
    method builds and prints a nicker message according to the specified number of
    times (`times`), the optional destination virtual domestic mammal (`otherDomesticMammal`),
    and whether the horse is angry or not (`isAngry`).
  prefs: []
  type: TYPE_NORMAL
- en: The `VirtualHorse` class uses a similar approach for the `neigh` method. This
    method is also overloaded with four declarations with different arguments. The
    following lines show the four different declarations included within the class
    body. They have the same arguments we just analyzed for the `nicker` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can call any of the defined `neigh` methods based on the provided
    arguments. The four methods end up invoking the `printNeigh` public method with
    different default values for the arguments with the same names not provided in
    the call to `nicker`. The method calls the `printSoundInWords` public method with
    `"Neigh "` as the value for the `soundInWords` arguments and the other arguments
    set to the received arguments that have the same names.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Java 9, a subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherits all the constructors from its superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Doesn't inherit any constructor from its superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherits the constructor with the largest number of arguments from its superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can declare abstract methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In any class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only in an abstract class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only in a concrete subclass of an abstract class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A concrete subclass of any abstract class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must provide an implementation for all the inherited abstract methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must provide an implementation for all the inherited constructors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must provide an implementation for all the inherited abstract fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines declare an abstract class named `Dog` as a subclass
    of `VirtualAnimal`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public abstract class Dog subclasses VirtualAnimal`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public abstract Dog subclasses VirtualAnimal`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public abstract class Dog extends VirtualAnimal`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following annotations indicated before a method''s declaration
    informs the Java 9 compiler that the method is meant to override the method with
    the same name declared in a superclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Overridden`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@OverrideMethod`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@Override`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the difference between abstract and concrete classes.
    We learned how to take advantage of simple inheritance to specialize a base abstract
    class. We designed many classes from top to bottom using chained constructors,
    immutable fields, mutable fields, and instance methods.
  prefs: []
  type: TYPE_NORMAL
- en: Then we coded many of these classes in JShell, taking advantage of different
    features provided by Java 9\. We overloaded constructors, overrode, and overloaded
    instance methods, and we took advantage of a special annotation to make overridden
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about inheritance, abstraction, extension, and specialization,
    we are ready to finish coding the additional classes and understand how to work
    with typecasting and polymorphism, which are the topics we are going to discuss
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
