- en: Using High-Order Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We frequently encounter questions such as, "Just curious, what are the benefits
    of applying pure functional programming concepts to imperative languages (other
    than making the code hard to read for others)?"
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will address this common misconception using high-order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the characteristics of **functional programming** (**FP**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the purpose of generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how FP improves performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement `Map`, `Filter`, and `Reduce` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement lazy evaluation using Goroutines and a Go channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characteristics of FP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the requirements for a pure FP language. A pure
    FP language must include support for things like:'
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tail-call optimization** (**TCO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to accomplish pure FP, a language must treat functions as it does any
    other variable type. How can an immutable language have variables that vary? The
    way we accomplish this in an FP way is by creating new variables, rather than
    modifying existing ones. We will see how to accomplish this later in the chapter,
    when we look at the `Map` function.
  prefs: []
  type: TYPE_NORMAL
- en: Go is a multidimensional language that supports imperative, object-oriented,
    and FP styles. We could write a purely imperative or functional program in Go.
    It is our choice of programming style that dictates this. This is one of the great
    things about Go and FP. It's not an all or nothing issue. We can migrate our code
    toward FP when and where it makes sense to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Go requires **tail-call optimization** (**TCO**) to handle production performance
    requirements. Each time a recursive function calls itself, a new block is added
    to the stack frame; we soon feel the sluggish effects of this Go compiler omission.
    We will see how to mitigate this issue when we implement the `Reduce` function.
  prefs: []
  type: TYPE_NORMAL
- en: The last requirement is support for **high-order functions** (**HOF**). High-order
    functions take functions as arguments and/or return functions as their result.
    HOFs allow us to chain our functions together in a readable manner with less code.
  prefs: []
  type: TYPE_NORMAL
- en: 'HOFs are arguably the focal point of any FP language, and after a quick look
    at FP characteristics, we''ll study how we can exploit them in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Characteristic** | **Supported in Go?** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Anonymous Function** | Yes | A function without a name. For example, this
    function call an anonymous function that prints a message.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Closures** | Yes | A closure is an inner function that closes over, that
    is, has access to, variables in its outer scope. In other words, a closure is
    a function''s scope that is kept alive by a reference to that function.  |'
  prefs: []
  type: TYPE_TB
- en: '| **Composition** | Yes | Composition is what allows us to combine simple functions
    to build more complicated ones. Currying and pipelining are example implementations
    of the concept of composition. |'
  prefs: []
  type: TYPE_TB
- en: '| **Continuations** | Yes | Continuations are like a GOTO statements with arguments. A
    continuation is a function parameter (`next`) we pass to a function (`factorial`)
    that specifies where the function should return.The factorial function does not
    define a return value. It''s a function that accepts an int and another function
    that passes along its current state.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Calls continue until a base condition is met (`x == 0`) and then all the partially
    executed next functions on the stack are popped off and evaluated .We can call
    `factorial` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print: **result: 24**Programming with Monads is a form of **continuation
    passing style** (**CPS**) that gives us more control; Using the Lexical Workflow
    Solution, upon encountering an error we can direct execution to the error path
    (bypassing subsequent chained function calls) to our workflow''s single idiomatic
    Go error handler.CPS can also be programmed using Goroutines and channels. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Currying** | Yes | Currying is where we get a function that accepts x parameters
    and return a composition of x functions each of which take 1 parameter. In FP,
    every function is a function of one argument. |'
  prefs: []
  type: TYPE_TB
- en: '| **Declarative** | Yes | Declarative style, as opposed to an imperative style,
    means that we write expressions as opposed to step by step instructions.The imperative
    function is not used as data; Instead, it''s used for its side effect, i.e., printing
    "Hello".'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Either Data Type** | Yes | Either is a type constructor that takes two
    arguments. It allows us to say a value is either one of two types. For example,
    `Either Car Truck`. We can use Either to create an error handling system if we
    make our result of type   `Either Success Failure`. Slightly more complicated
    that the Maybe data type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **First Class Functions** | Yes! | First-class functions can be passed around
    as parameters and returned as values. |'
  prefs: []
  type: TYPE_TB
- en: '| **Functional Composition** | Yes | Functional composition means that we decompose
    monolithic applications into our smallest units of computation. We can then re-combine
    our functions in new ways to create new functionality by chaining our function
    calls. |'
  prefs: []
  type: TYPE_TB
- en: '| **Hindley-Milner type system** | No | HM infers types without requiring any
    type definitions. HM type systems support polymorphic types, where lists can contain
    items of different types. If Go used HM, then the type of b would be inferred
    as `float64` below (rather than throwing the runtime error, *constant 1.8 truncated
    to integer*)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Idempotence** | Yes | Idempotence  means that we can call our function
    repeatedly and it will produce the same result each time. |'
  prefs: []
  type: TYPE_TB
- en: '| **Immutable data** | Yes | Immutable immutable data structures, once created,
    do not change. Data cannot be added, removed, or reordered. In order to make an
    *update* we need to create a copy with our changes. Immutability is a core tenant
    of FP because without it, the data flow in our applications become lossy and inconsistent.
    The true constant in FP (as in life) is change. Mutation hides change. For more
    reasons see the *Immutable Data* section below. |'
  prefs: []
  type: TYPE_TB
- en: '| **Immutable variables** | Yes | Go has the const keyword, but that only works
    for ints and strings. In order to have a immutable object, we could to write it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Or only allow access to fields via method calls that could be coded to prevent
    mutation. |
  prefs: []
  type: TYPE_NORMAL
- en: '| **Lambda expressions** | Yes | A Lambda expression is an anonymous function,
    often used as data, passed as a parameter, and returned as data and used to invoke
    another function. Note that a lambda expression executes in the context of their
    appearance, that is, they only have access to the variables in their lexical scope
    and they take only one parameter.For an example of what is and what is not a lambda
    expression check: `2-design-patterns/ch04-solid/01_lambda/main.go`**Tip 1**: If
    we can call a function without using its return value then it’s impure.**Tip 2**:
    If we need to pass more than one parameter, use a partially applied function.**Tip
    3**: When we see some code like that like the following, we''re likely looking
    at a Lambda Expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **List Monad** | Yes | List monads are used to model nondeterministic computations
    that can return an arbitrary number of results. A list monad can return zero or
    more results.The return function inserts a value into a list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The bind function pulls values from the list, applies a function to them and
    produces a new list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the following function definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The list monad allows us to compose **f** and **g** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'f looks like this:`f "X" --> ["W", "X", "Y"]`g looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map g (f "X") --> [["w", "W"], ["x", "X"], ["y", "Y"]]`When we compose f and
    g we get`["w", "W","x", "X","y", "Y"]`Using the composition operator "." we can
    write the List monad composition as follows:`f >=> g = concat . map g . f` |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Maybe data type** | Yes | Maybe represents a computation that might not
    return a result, i.e., an optional value. Maybe a is a value that either contains
    a value of type a (represented as Just a), or it is empty (represented as Nothing) The
    following definition of Maybe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Says, `Maybe` a is either not there or it is there. If it's not there, its `Nothing`;
    If it is there is is Just a, where a is a value.Maybe is a polymorphic type that
    can be used to define a function that can produce a value of another type or nothing
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Maybe Monad** | Yes | The Maybe Monad is a type of error monad, where all
    errors are represented by `Nothing`. (The Either type provides more functionality.)Given
    the polymorphic nature of `Maybe` and associativity, we can say.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**h** is the Monadic composition of **f** and **g**.The definition of the `Maybe`
    monad is a follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Monadic error handling** | Yes | `Maybe` helps us handle errors. It represents
    something expected rather than an unexpected error. Either is like a `Maybe` that
    also lets us return an arbitrary value instead of `Nothing.` Instead of worrying
    about receiving a null from a function call, which could cause a null pointer
    exception, our type system will force to handle error conditions a type-safe way.Using
    Either as our return type, e can run a task, get a result, check for the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And even if the task failed, we'll get a non-nil result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For details, see `2-design-patterns/ch04-solid/02_maybe` |
  prefs: []
  type: TYPE_NORMAL
- en: '| **No side-effects** | Yes | *No side effects* means that the only thing that
    occurs when we call a pure function is:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass in parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get a result; `Nothing` else happens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tip 1:** If our function prints output it is impure. **Tip 2:** If any state/data
    changes anywhere else in our system as a result of calling our function then our
    function is impure. **Tip 3:** If our function has no return value then it is
    either impure or completely useless. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator overloading** | No | Operator overloading, also known as *ad hoc
    polymorphism*, is a specific case of polymorphism, where different operators like
    +, = or == are treated as polymorphic functions and as such have different behaviors
    depending on the types of its arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| **Option type** | Yes | We can create an Option typeclass in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parametric polymorphism** | No | Parametric Polymorphism means **Generics**.
    This is a style of datatype generic programming where we code our functions using
    non-specific data types. For example, we can implement generic algorithms that
    work on collections of non-specific types. Generics provides code reuse, type
    safety and easy-to-read code. See the following Generics section for a simple
    example. |'
  prefs: []
  type: TYPE_TB
- en: '| **Partial function application** | Yes | Giving a function fewer arguments
    than it expects is called Partial function application. Here, our function accepts
    a function with multiple parameters and returns a function with fewer parameters.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Pure functions** | Yes | Pure functions map inputs to outputs. When given
    the same input a pure function will always return the same output  (also known
    as *determinism*) and will not have any observable side effects.The  determinism
    of pure functions means that our FP programs'' correctness can be proven formally,
    which is a great benefit for mission critical applications.Just like a mathematical
    function, the output of our function depends entirely on its input and nothing
    else. For example, the output of the function below will always return two more
    than the value (x) passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pattern matching** | No | Pattern matching enables the compiler to match
    a value  against some patterns to select a branch of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The value of our `ErrorMessage` in the preceding code will be one of five different
    error choices (`YourNameInvalid`, `YourPhoneInvalid`, and so on)In Go, we can
    accomplish this at runtime using a union type. |
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pipelining** | Yes | Pipelining allows us to pass the output of one function
    as input to another. Function calls can be chained in a sequence to implement
    a workflow. Pipelining encourages code reuse and parallel execution. |'
  prefs: []
  type: TYPE_TB
- en: '| **Recursion** | Yes | Recursion is used by FP languages in place of loops
    where a function calls itself until an end condition is reached. In Go, every
    recursive call creates a call stack. TCO avoids creating a new stack by making
    last call in a recursion the function itself. Even though we can code recursively
    in Go without TCO, it''s just not practical because of poor performance. Note
    that recursion in pure FP languages are abstracted from sight by HOFs. |'
  prefs: []
  type: TYPE_TB
- en: '| **Referential rransparency** | Yes | Referential transparency is a property
    of pure functions where our function that always return the same output for the
    same inputs. Our function expression f(x) and the results of evaluating our function
    are interchangeable. For example, 1 + 1 is always equals 2\. As we saw in [Chapter
    2](../Text/Ch02.xhtml), *Manipulating Collections*, this means that we can cache
    the results of the first function invocation and improve performance.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip:** If we can cache results from previous function calls then we have
    referential integrity. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Sum or Union types** | Yes | We can implement a union type using an interface
    with `Success()` and `Failure()` methods that will return either Success or Failure.For
    details see `2-design-patterns/ch04-solid/02_maybe`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tail Call Optimization** | No | Tail Call Optimization makes recursive
    function calls performant. A tail call happens when a function calls another as
    its last action. TCO acts like a GOTO statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The program does not need to return to the calling function when the called
    function g(x) ends b/c there is no executable code after that last line. After
    the tail call, the program does not need any call stack information about g. Without
    TCO the program will create a needless call stack for g; A lot of recursive calls
    will cause a stack overflow. With TCO, the recursive  program will be faster and
    consume far fewer resources. |
  prefs: []
  type: TYPE_NORMAL
- en: '| **Typeclasses** | Yes | Type classes allow us to define functions that can
    be used on different types with a potentially different implementation for each
    type. Each class represents a set of types and is associated with a particular
    set of member functions. For example, the type class Eq represents the set of
    all equality types, which is precisely the set of types on which the (==) operator
    can be used. |'
  prefs: []
  type: TYPE_TB
- en: '| **Unit type** | Yes | A Unit type has exactly a one value. It is also known
    as the identity. The unit for multiplication is 1, for addition is 0, for string
    concatenation is the empty string. How many values can a type defined as a tuple
    of of type int contain? Infinite. (-∞, …, 0, 1, 2... ∞)  How many values can a
    type defined as the empty tuple contain?The value of a Unit type is that you can
    use it in places where we might otherwise return nil (or null). We return a Unit
    when we don’t care what the value is. We don’t return nil, we return a value;
    the Unit value. All functions return values; No more null pointer exceptions!The
    Unit type is also useful in places that need an empty value. For example, in F#
    an Async action which may create  side effects but does not return a value is
    an instance of type Async<unit> |'
  prefs: []
  type: TYPE_TB
- en: These are not all characteristics of a pure FP, just some of the more significant
    ones. Probably the most important one is support for first class functions.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table introduces a lot of concepts that we'll cover in greater
    detail later in our book. Feel free to skip ahead if your curiosity is too great;
    Otherwise, just go with the flow and we'll eventually get to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Supported in Go?* column in the preceding table:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Yes!**: Indicates that the FP characteristic exists in Go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yes**: Indicates that the characteristic or requirement can be achieved with
    some effort in Go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No**: Indicates that this FP characteristic or requirement is missing and
    is difficult or not possible to achieve without a major upgrade to the Go compiler,
    or without using another technology in tandem with Go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Function composition is what happens when we combine functions. The output of
    one function is the the input of the next function. We can use objects and morphisms
    of category theory to help us get the order right. Take the following diagram
    for example...
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df1c8e59-30fe-4a52-89bc-fe93e0cf3599.png)>'
  prefs: []
  type: TYPE_NORMAL
- en: We see that we can combine our functions f and g to get from A to B to C. Note
    that the order matters. We must first go from A to B via f and then from B to
    C via g.
  prefs: []
  type: TYPE_NORMAL
- en: We express this with the following notation (f.g)(x). That reads, *f-compose-g
    with input x*. This expression equals g(f(x)), which reads *f of x of g*. So *(f.g)(x)
    == g(f(x))*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the compose function looks like in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Where `StrFunc` is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `main.go`, we define our `f` and `g` functions, recognize and emphasize,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We compose `f` and `g` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that order matters. What happens if we flip the order of `f` and `g` and
    then compose?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Monads allow us to chain continuations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Chaining continuations means that we can execute a series of functions, where
    the output of one function is the input of the next. Check out the following example
    of chaining high-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How much more code would be required if we were to implement the for loops,
    error checking, and other scaffolding that is typically required when coding Go
    in the typical imperative style of programming?
  prefs: []
  type: TYPE_NORMAL
- en: Instead of telling Go how to filter, map, and reduce our collection, we declare
    what we want to accomplish. Later in this chapter, we do implement the `Filter`,
    `Map`, and `Reduce` functions, but what if the Go standard library already provides
    these for us?
  prefs: []
  type: TYPE_NORMAL
- en: How can we expect Go to provide HOF implementations for cars? That would not
    be reasonable, right? What's missing? The answer is *generics*.
  prefs: []
  type: TYPE_NORMAL
- en: The ChainLink implementation in this chapter is sort of a poor man's monad.
    We'll explore a real monad in the last chapter of this book and discover that
    there are more operations involved (Bind, Return, monadic error handling). Real
    monads also do not rely on global variables. What is similar is that they both
    allow us to execute operations in order, where the output of one function is the
    input to the next. That is a key concept to remember.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parametric polymorphism means generics. A generic function or a data type can
    be written to handle any data value using the same logic, without having to cast
    the value to a specific data type. This greatly improves code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a C# code example of a generic `IsEqual` implementation. The
    generic `IsEqual` function will accept any type (that implements `Equals`). We
    pass `IsEqual` integers and strings by simply indicating the type `T` during runtime,
    at the moment `IsEqual` is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Currently, to do this in Go, we will have to use an empty interface and perform
    a type conversion. It's type conversion that will cause the performance hit that
    usually makes this sort of generics handling in Go impractical.
  prefs: []
  type: TYPE_NORMAL
- en: First-class functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First-class functions allow us to make new functions by providing our base
    functions with function parameters. In the following code, our base function is
    `Filter`. By passing `ByMake("Toyota")` to `Filter`, we remove most of the car
    items from our collection, leaving only Toyota:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the ability to transform any function that works on single elements
    into a function that works on lists, by wrapping it with the `Map` function. Without
    our new functional style of programming, we might be tempted to implement a `for`
    loop and apply the `fmt.Sprintf` transformation on each individual car, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we can simply pass the `Upgrade` function to `Map` as we compose our
    data transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We no longer need to write `for` loops that manipulate arrays because we can
    call `Map` inline.
  prefs: []
  type: TYPE_NORMAL
- en: HOFs can greatly reduce the time that it takes to develop complex logic. We
    can quickly compose smaller, task-specific functions into solutions for complex
    business logic much faster, with less scaffolding code, which means we'll have
    fewer bugs to fix. Our functions are in essence reusable building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: HOFs are independent, making them easy to reuse, refactor, and reorganize in
    our code base. This makes our programs more flexible and resilient to future code
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: More readable code, faster implementation, fewer bugs. The benefits of FP are
    adding up!
  prefs: []
  type: TYPE_NORMAL
- en: Closure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A closure is a function that closes over variables in its outer scope. We really
    need an example to understand that statement! Here''s a good one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding closure is formed by the `addTwo` function. Inside `addTwo`, both
    `sum` and the anonymous function are declared in the same lexical scope. Since
    `addTwo` closes over both `sum` and the anonymous function, and because sum was
    declared before the anonymous function, the anonymous function always has access
    to, and can modify, the `sum` variable. As soon as `addTwo` is assigned to `twoMore`,
    the `addTwo` functions's anonymous function gets access to the `sum` variable
    and holds on to it as long as the application continues to run.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically scoped
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if we accidentally initialized `sum` in an outer scope from where we defined
    our  function? Notice that there is no sum variable initialization in the same
    scope as our anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this in our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Our Go runtime looks in the environment in which the anonymous function was
    called, rather than where it was defined (as is the case in lexical scoping).
    If `addTwoDynamic` had been nested several stack frames deep, our Go runtime would
    look where `addTwoDynamic` was defined for sum. If it was not found there, it
    would continue up the stack until sum is found. So, we see that dynamic scoping
    adds complexity and might cause the value of sum to change in unpredictable ways,
    or at least in ways that  are more difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: What happened? Since sum was not defined in the scope in which our anonymous
    function was defined, Go found it in the global scope. It's value was 5. `addTwoDynamic`
    added 2 to 5 and got 7. `addTwoDynamic` did it again and got 9\. Probably not
    what we wanted.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to pass around lexical context is powerful and guarantees that we
    won't have side effects that might occur with dynamic scoping. We'll look at a
    practical example where we create an application context, for example, database
    connection, logger, and so on, at application startup and pass that context around
    where needed throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: Pure function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pure function is a function that when given the same input will always return
    the same output and will not have any observable side effects. How is that a benefit?
    Let's see. We can run any pure function in parallel since our functions do not
    need access to shared memory. Race condition due to side effects are not possible
    with pure functions. The performance gains of running our code concurrently on
    multiple cores is another awesome benefit of FP.
  prefs: []
  type: TYPE_NORMAL
- en: Immuable Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Immutable data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Have one state and never change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are simpler to construct, debug, test, and reason about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are side-effect free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve performance and are more scalable because they are easier to cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are safer in that they prevent null pointer references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are thread safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are always in a stable state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since immutable data structures are never changed, that means that failures
    never occur during a data modification operation. When an immutable data structure
    is initialized it will either fail or succeed, returning a valid data structure
    that never changes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make changes to an immutable data structure, we must create a new
    tree. Suppose we want to update the value of g in the existing tree data structure
    (*previous root)*. First, we would create the g' node and build the new tree by
    traversing the nodes connected to g and copying only those values necessary to
    rebuild the tree. References to other nodes can be created without creating new
    nodes (these are the nodes in white). With the new root in place, new leaf nodes
    are added to the new tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: Once the new root has been created the previous/old root can be preserved or
    it can be marked for deletion.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1d89ea7-d7eb-4169-8cde-e3bad95d668c.png)'
  prefs: []
  type: TYPE_IMG
- en: This may seem like a lot of work, but one of the greatest benefits is that we
    no longer need to worry about our data unexpectedly changing. For example, what
    if one Goroutine is looping through our data structure while another one is removing
    elements from it? We no longer need to concern ourselves with dealing with race
    conditions and verifying that our preconditions are still valid. When we use immutable
    data structures, our code becomes more robust and easier to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of any solutions today that make use of immutable data structures?
  prefs: []
  type: TYPE_NORMAL
- en: Ever wondered how git works?
  prefs: []
  type: TYPE_NORMAL
- en: Interested in full stack development? How does ReactJS update its models?
  prefs: []
  type: TYPE_NORMAL
- en: In the game of soccer, we may loose to a team because they have a player with
    specific skills. When we face the team again we may forget the past, but that
    does not change history; It is not possible to change the past. When the past
    is not preserved, we cannot learn from it and history will repeat itself. Mutability
    hides changes.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent data structures for Go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Check out [https://godoc.org/github.com/mndrix/ps](https://github.com/mndrix/ps)
  prefs: []
  type: TYPE_NORMAL
- en: 'From it''s documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: Fully persistent data structures. A persistent data structure is a data structure
    that always preserves the previous version of itself when it is modified. Such
    data structures are effectively immutable, as their operations do not update the
    structure in-place, but instead always yield a new structure.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent data structures typically share structure among themselves. This
    allows operations to avoid copying the entire data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'ps has small but effective API for manipulating lists and maps of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For more details see [https://godoc.org/github.com/mndrix/ps](https://godoc.org/github.com/mndrix/ps)
  prefs: []
  type: TYPE_NORMAL
- en: Use of expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use of expressions (rather than statements) means that in FP, we pass a value
    to a function that typically transforms it in some way and then returns a new
    value. Since FP functions have no side effects, an FP function that does not return
    a value is useless and a sign of code smell. In [Chapter 1](../Text/Ch01.xhtml),
    *Pure Functional Programming in Go*, we saw that imperative programming focuses
    on the step-by-step mechanics of how a program operates, whereas in declarative
    programming, we declare what we want the results to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of imperative programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of declarative programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We have less, declarative FP code that is easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Sample HOF application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s build a sample app that will demonstrate the benefits of applying functional
    programming concepts to Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app will read from the following `cars.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We will apply high-order functions and various functional programming constructs
    to the list of cars to filter, map, reduce, and transform it to our heart's content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our project is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: At the root of the `chapter4` directory is our `main.go` file. Since we plan
    to build a Go executable from `main.go` and run it, we use the package name of
    `main` and include a `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The other files will be in a subdirectory named `01_hof`, where `hof` stands
    for high-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter4 application code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s examine our `chapter4` implementation, starting with `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot (`.`) in the ` . "github.com/l3x/learn-fp-in-go/chapter4/01_hof"` import
    keeps us from having to preface the functions in that directory with `hof`, which
    is the package name used by all the Go files in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We'll use the `log` package to log output to stdout. Passing a 0 value to `log.SetFlags`
    tells the logger to print without prepending timestamps. We also tell the logger
    to print to `stdout`, rather than the default `stderr` because we want all of
    the output to be consistently displayed for ease of reading. We'd likely not output
    any information to `stdout` for a production application because there isn't anything
    useful for the program to send on `stdout` other than command help and usage information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log` function can easily be configured to prepend timestamps and line
    numbers. The `log.SetFlags(log.Lshortfile | log.Ldate)` setting will print the
    output to `stdout`: ` 2017/04/07 utils.go:17: car: Honda Accord`.'
  prefs: []
  type: TYPE_NORMAL
- en: Build and runtime instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After verifying that our Go environment is properly configured, we can change
    the directory to a project directory and start a RESTful web server with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See the *My Go build and runtime process* section in the Appendix, *Miscellaneous
    Information and How-Tos*, for details regarding how I manage my Go environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to open another Terminal window to run our `chapter4` executable.
    Let''s build and run our `chapter4` app to exercise our HOFs with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The top few lines of output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: More application code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first thing we do in the `main()` function is check the `RUN_HTTP_SERVER`
    environment variable. If it''s set to `true`, then the program will set up two
    routes. The first route `/cars` returns the index page that displays all the cars
    that have been loaded from the `.csv` files. The second route `/cars/:id` retrieves
    an individual car object and returns its JSON representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IndexedCars` variable is defined in `types.go` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we look at the else logic, let''s take a peek at the following `cars.go` file.
    We declare an exported package level variable `CarsDB` that is assigned a slice
    of `IndexedCars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that every Go source file in our `01_hof` directory uses the package name
    `hof`.
  prefs: []
  type: TYPE_NORMAL
- en: We preface the `strings` package with `s` so that we can easily reference string
    utility functions with `s` like this: `s.Contains(car, make)` rather than `strings.Contains(car,
    make)`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `var CarsDB = initCarsDB()` is defined at the package level, it will be
    evaluated when we start our `chapter4` executable. The `initCarsDB()`  function
    only needs to be referenced in this `cars.go` file, so we do not need to capitalize
    its first character.
  prefs: []
  type: TYPE_NORMAL
- en: The  `LoadCars()` function, on the other hand, is referenced by the main package,
    so we need to capitalize its first character in order to make it accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's turn our attention to the FP goodies in the else block.
  prefs: []
  type: TYPE_NORMAL
- en: The Filter function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first HOF that we exploit is the `Filter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Filter` function is in the `cars.go` file. Observe the `fn` argument.
    It is passed into the `Filter` function and later called with a `car` parameter.
    If `fn(car)`--that is, `ByMake("Honda")`--returns `true`, then the car is added
    to the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When we define the `Filter` function on the `cars collection` type, it's called
    a method. A Go method is a function with a special receiver argument. In our `Filter`
    function, the `cars` collection is the receiver. Notice that `cars` is in the
    first set of arguments, between the `func` keyword and the `Filter` name. Note
    that `cars` is a data structure that has a `Filter` behavior. The `Filter` method
    accepts `FilterFun` as its argument and returns a filtered collection.
  prefs: []
  type: TYPE_NORMAL
- en: Reality check
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What? A `for` loop? A mutating `car` variable? What gives? We must face the
    facts. The Go compiler does not provide TCO, so a recursive implementation is
    simply not practical. Perhaps Go 2.0 will provide a pure functional library with
    all our favorite HOFs as well as generics. Until then, we will make do with using
    the functional programming style as much as possible with a bit of imperative
    programming where necessary. Another option that we'll explore later is an execution
    system named **Gleam**, which provides pure Go mappers and reducers that provide
    high performance and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Data transformations are so common that it's nice to have a shorthand for it.
    HOF's ability to simplify both writing and reading code that performs data transformations
    is one of FP's greatest benefits.
  prefs: []
  type: TYPE_NORMAL
- en: FilterFunc
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the `types.go` file, we see its definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking back at the line in `main.go`, we see that we use the `ByMake` filter
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ByMake` function is defined in the `cars.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `ByMake` function is a HOF because it returns a function. Recall that `Filter` is
    a HOF because it accepts a function. In this case, `ByMake` is that function,
    `fn`, as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Filter function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `Filter` function is a HOF that takes another HOF, namely `ByMake`, and performs a
    data transformation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: RESTful resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s open `http://localhost:8000/cars` to see the full list of cars from
    both `cars.csv` and `more_cars.csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa24237d-e100-487d-9d2c-0edce3dea662.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the next `Filter` function in action in `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FilterFunc` method used in this case is `ByHasNumber()`. It operates like
    `ByMake FilterFunc` and uses Go''s regexp `MatchString` function to return `true`
    if the car has a number in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Chaining functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the hang of it, let''s chain a few filters together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: More cars
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It''s time to add more cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Wait, what? `AddCars`? How is that an HOF? `AddCars` neither takes a function
    nor returns a function. Even worse, it mutates the `cars` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Reality check
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: It's not important that the cars collection remain *pure*; frankly, that's not
    feasible, given that the Go compiler currently does not provide TCO. What's important
    is that our code improves with the use of functional programming techniques. Granted,
    this one, `AddCars`, is the furthest function we have from pure, but it is useful
    and it does improve our programs' readability. We do need to be careful when we
    use non-pure functions, especially ones that mutate their state, but this usage
    is perfectly fine for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We find `AddCars` in `cars.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The Map function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Back to `main.go`. This time, you''ll be introduced to the `Map` HOF. Whereas
    `Filter` acts to reduce the number of items in the resulting collection, `Map`
    will return the same number of items that it receives. The `Map` function transforms
    the collection into a new collection, where each item is changed in some way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass a `MapFunc` function named `Upgrade` to `Map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`Upgrade` calls the `UpgradeLabel` function in order to append the appropriate
    upgrade label to the end of the cars'' model name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Improved performance from the Map function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One of the greatest benefits of FP is performance.
  prefs: []
  type: TYPE_NORMAL
- en: Programs today achieve better performance largely by performing more than one
    operation at a time using multiple CPU cores.
  prefs: []
  type: TYPE_NORMAL
- en: This means running code in parallel, and to do that, our code must be thread-safe.
    Programs that have a shared mutable state are not thread-safe. These programs
    will be bottlenecked in one core.
  prefs: []
  type: TYPE_NORMAL
- en: FP solves this bottleneck/thread safety issue by returning new instances of
    variables rather than changing the original instance.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24149bd7-d77b-4308-a2f5-d78e76d0d712.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the `Map` function to see how we can pull this off using FP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Instead of appending to the cars collection, that `Map` receives a new variable
    `mappedCars`. The `mappedCars` collection is mutated, not the original cars collection.
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing, tactically, when we call `Map(Upgrade())` is pushing the
    moment that our data changes out to the last moment--in this example, after `mappedCars`
    has been populated.
  prefs: []
  type: TYPE_NORMAL
- en: We have been programming our way around FP concepts our entire career. Part
    of what we do in this chapter is to identify these FP patterns and see how and
    why we should exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: The Reduce function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, let's look at the `Reduce` function. `Reduce` is the Swiss army knife
    of HOFs. With a `Reduce` function, we can do anything that can be done with `Filter`
    or `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: A `Reduce` function, also known as a `fold`, `accumulate`, `aggregate`, `compress`,
    or `inject` takes a seed value and applies the logic of the reducer function to
    the seed, and potentially multiple calls to itself to arrive at a result. Often,
    the reduce function will combine the data elements to return a single aggregated
    value, hence the term `fold`. So, we fold all of the data into a single result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `main.go`, we apply the `ByMake` filter to filter out all the cars
    that are not a Honda product. Then, we call the `Reduce` function to transform
    the collection of Honda vehicles into a collection of JSON strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Reduce` function is a method of the cars collection that accepts a `Reducer`
    function. Again, we see a `for` loop and recall, *No TCO, No recursion*. That''s
    okay. So, the guts of our `Reduce` function is not *pure*. That''s OK. It''s still
    readable, performant, and safe; in the spirit of Go programming, it gets the job
    done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter `Collection{}` is the accumulator, which is the initial
    value assigned to the result. The `Reducer` function starts with the accumulator
    value, performs transformations on each item in the collection, and returns the
    result. This `Reduce` function provides the framework in which to perform a reduction,
    but it's the reducer function (`fn`) that does the heavy lifting. Note that we
    can pass any valid reducer function (`fn`) into the `Reduce` framework to get
    vastly different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `JsonReducer` function does the real work of transforming each item in
    the cars collection into a JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Reduce is an HOF function that takes a function. `JsonReducer` is an HOF function
    that returns a function.
  prefs: []
  type: TYPE_NORMAL
- en: More high-order functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now, let's return to `main.go` to look at a few more HOFs in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We apply our `ByMake` filter and a new type of reducer. This reducer, `Reducer2`,
    will return a slice of `CarTypes` rather than JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is another example that shows how easy chaining, also known as
    function composition, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We saw how the `Upgrade` map function adds the appropriate label to the end
    of the car model. By applying `Downgrade` after `Upgrade`, we effectively undo
    `Upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Time to check out generators. Generators are useful because they allow us to
    delay an expression evaluation. We only compute the expression(s) we need when
    we need them. Generators also conserve memory because with generators, we only
    create and use what we need, no more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We will find the implementation of `GenerateCars` in the `generate.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We define our imports. The `sync` import is a clue that we have a need to synchronize
    our Goroutines. The `iterator` function will be passed to the `carGenerator` function
    and will track how many cars we've generated. We'll be creating cars as per need
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we have our RESTful server running on port `8000`, we can open our web browser
    to `http://localhost:8000/cars/1` and see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This is a representation of an `IndexedCar` struct. It has an index and a car
    make and model string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the actual `IndexedCar` struct in `types.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The GenerateCars function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''s the actual generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GenerateCars` is another method in the `cars` collection that makes it
    easy to compose data transformations with other HOFs. `GenerateCars` takes a start
    index and limit, which is the number of cars that we want to be returned. We create
    `carChannel` of pointers to `IndexedCars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `sync.WaitGroup` as a counting semaphore to wait for our collection
    of Goroutines to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the number of cars we want to generate and pass that number to
    the `waitGroup.Add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `carGenerator` function returns a function that we assign to a variable
    named `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The `next` variable returns two variables: `carIndex` and `done`. As long as
    there are more cars to generate, `done` will be `false`. So, we can use `done`
    to control a `for` loop that launches a Goroutine, one for each car to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `next` variable returns two variables `GetThisCar(carIndex)` in the code
    block; immediately after this, the preceding code calls the RESTful car service
    that returns the requested car.
  prefs: []
  type: TYPE_NORMAL
- en: If an error is encountered, we use the built-in function `panic` to stop the execution
    of the current Goroutine. Since we used a deferred function, namely `csvfile.Close()`,
    in the call stack, it will be executed if a panic occurs. Note that we could have
    had more control over the termination sequence using the built-in recover function.
  prefs: []
  type: TYPE_NORMAL
- en: The `thisCar` variable is sent to `carChannel`, and the `Car` field is appended
    to the `generatedCars` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Currying Goroutine
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Notice anything special about the `generatedCars` collection? (Hint: Our Goroutine
    is an anonymous function).'
  prefs: []
  type: TYPE_NORMAL
- en: That's right. We are currying the `generatedCars` collection. Our Goroutine
    covers over the `generatedCars` collection. That's what enables us to reference
    and append to it from the Goroutine, regardless of which core it happens to be
    running in.
  prefs: []
  type: TYPE_NORMAL
- en: We are standing on the shoulders of giants. We're using a Go channel and Goroutines
    to emulate an FP generator and other HOFs. Our code is readable, and it doesn't
    take much code to make it all work.
  prefs: []
  type: TYPE_NORMAL
- en: A closer look at currying
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Before we move on, let''s look at the following curried versus non-curried
    code example to improve our understanding of currying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: You would immediately see that the curried example takes only one parameter,
    whereas the non-curried example requires two. The idea behind currying is to create
    new, more specific functions from smaller, more general, functions by partially
    applying them. We'll see more of this in [Chapter 8](../Text/Ch07.xhtml), *Functional
    Parameters*.
  prefs: []
  type: TYPE_NORMAL
- en: Another take away is the use of a function type. The `numberIs` is a data type
    that is a function that takes an int and returns a bool. That's right. In FP,
    we are not scared of functions. We treat them as a regular old data type. In FP
    everything is data, and data never changes. It only gets passed around, created
    and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of angle *x* is equal to the length of the (*A*)djacent side divided
    by the length of the (*H*)ypotenuse ([http://www.mathopenref.com/cosine.html](http://www.mathopenref.com/cosine.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '*cos x = A / H*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/842223a2-7e83-48c9-82da-cbe9f193f131.png)'
  prefs: []
  type: TYPE_IMG
- en: In imperative programming, we are led to believe that functions and data are
    different things. In FP, we see that functions have no side effects. A good FP
    example is the geometric cosine function. For a right-angle triangle, if we pass
    15 for the (*A*)djacent side and 30 for the (*H*)ypotenuse, then we get 0.5 as
    the cosine of angle A. Since we can rely on that fact--pass 15 and 30 and get
    0.5 every time--even with our imperative programming hats on, we know we can put
    those values in a lookup table. Imagine a spreadsheet where row numbers represent
    the A's and the columns represent the H's. The cell at row 15, column 30, would
    have the value 0.5\.
  prefs: []
  type: TYPE_NORMAL
- en: See, functions are data! However, we don't always want to store every computed
    value for every possible parameter combination in every use case, just where it
    makes sense to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the performance of a system where every function call is a table lookup.
    Now imagine our reuse potential, where the evaluation parts of the applications
    are generic. If your mind is still intact, wait until [Chapter 9](../Text/Ch11.xhtml),
    *Category Theory That Applies*, where we will discuss the application of category
    theory and type classes.
  prefs: []
  type: TYPE_NORMAL
- en: Extending our currying example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'But wait, there''s more! Let''s add the following, just above `func main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The `apply` function is a method bound to a function type, namely `numberIs`.
    Our apply function applies the `numberIs` function to each argument. Each calculated
    value is appended to the newly created array of bools that is then returned to
    the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we update `main()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In pure FP, every function is a function of one argument. We can use currying
    in Go to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Now, back to cars.
  prefs: []
  type: TYPE_NORMAL
- en: Using a WaitGroup variable to manage concurrency
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After appending `thisCar` to the `generatedCars` collection, we execute `waitGroup.Done()`.
    This decrements the count of the `WaitGroup` variable. This count corresponds
    to the iterator value we assign to the lower variable, and applies to the `lower
    > upper` expression that is assigned to the done `return` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the iterator to know how many Goroutines to launch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Finishing up the GenerateCars function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At the end of our `GenerateCars` function, we execute another anonymous Goroutine.
    The purpose of this Goroutine is to wait for all the previously launched Goroutine
    generators to complete. We use `waitGroup.Wait` to know when the last generator
    was completed. Then, it''s safe to close `carChannel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The `carChannel` will block until it receives a new car; this is a result of
    calling `GetThisCar(carIndex)`. Recall that `WaitGroup.Add(numCarsToGenerate)`
    told `WaitGroup` how many cars we'd process. The `waitGroup.Done()` function counts
    that number down to 0, at which time `waitGroup.Wait()` is executed and `carChannel`
    is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We wait until all our Goroutines have fetched data from the RESTful HTTP server
    before returning the `generatedCars` collection. This is a common pattern in FP:
    we eliminate as much state change in our data transformation operation as possible.
    We wait until all of our data collection processing has completed and then we
    finally return the final result.'
  prefs: []
  type: TYPE_NORMAL
- en: Our FP work is much like that of an electrician. Electricians turn off the power, hook
    up all the wires in the building, and when everything is in place, they flip the
    power switch and all the lights come on. Data is power. Don't let your data fly
    until the last possible moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.go` file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Handling concurrency
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We are managing our `GetThisCar` Goroutines by counting how many we''ve launched,
    and we leverage a `WaitGroup` variable to decrement that count when they complete.
    While it is true that many of our `GetThisCar` Goroutines execute in parallel,
    what''s important is the way we handle their concurrency. Using the next iterator
    and the `waitGroup` variable, we are able to simply and effectively deal with
    their life cycle: starting with each Goroutine, receiving their results and closing
    `carChannel` when our counter indicates all the Goroutines are completed. Ever
    tried managing multiple threads of operation using Java or C++? Notice how we
    don''t have to deal with managing mutexes and hard-to-debug race conditions? The
    ease of concurrency implementation is one of Go''s many strengths.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrency**: A property of systems in which several processes are executing
    at the same time and potentially interacting with each other. Concurrency is about
    dealing with lots of things at once.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallelism**: This is a type of computation in which many calculations are
    carried out simultaneously, operating on the principle that large problems can
    often be divided into smaller ones, which are then solved in parallel. Parallelism
    is about doing lots of things at once.'
  prefs: []
  type: TYPE_NORMAL
- en: See Rob Pike's epic video, *Concurrency Is Not Parallelism*, at [https://www.youtube.com/watch?v=cN_DpYBzKso](https://www.youtube.com/watch?v=cN_DpYBzKso).
  prefs: []
  type: TYPE_NORMAL
- en: The final HOF example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our final HOF example is a doozy. We generate 14 cars, filter `ByDomestic`,
    map them with an `Upgrade` function, filter them by `ByHasNumber`, and reduce
    them to a collection of JSON strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: That's six lines of code. How many lines of code do you think it would take
    to do this using an imperative coding style?
  prefs: []
  type: TYPE_NORMAL
- en: '"This program is already so bloated a little more bloat won''t hurt." No. Eventually,
    it will. And then it will be too late to fix."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Rob Pike'
  prefs: []
  type: TYPE_NORMAL
- en: '"The problem is that adding more bloat is often much easier than integrating
    properly, which requires thought, time, and hard decisions."'
  prefs: []
  type: TYPE_NORMAL
- en: - Roger Peppe
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FP is a programming style that is declarative. It is more readable and usually requires
    much less code than our imperative or object-oriented implementation options.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we implemented the `Map`, `Filter`, and `Reduce` high-order
    functions. We studied closures and looked at how currying enables function composition.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Reduce` implementation demonstrated how to use Goroutines and a Go channel
    to perform lazy evaluation. We managed its concurrency using a `WaitGroup` variable
    and some common sense.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll consider the API software design. We'll look at how
    to build composable systems using interfaces and closures to enforce the single
    responsibility principle and the open/close principle.
  prefs: []
  type: TYPE_NORMAL
