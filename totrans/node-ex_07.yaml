- en: Chapter 7. Posting Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 6](part0046.xhtml#aid-1BRPS2 "Chapter 6. Adding Friendship Capabilities"),
    *Adding Friendship Capabilities*, was about adding friendship capabilities. The
    ability to connect with other users in a social network is important. However,
    it is even more important to provide an interface to generate content. In this
    chapter, we will implement the logic behind content creation. We will cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Posting and storing text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing the user's feed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Posting and storing text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous chapters, we have a feature that requires changes in both
    the frontend and backend parts of our application. We will need an HTML form that
    accepts the user's text, a new model that handles the communication with the backend,
    and of course, changes in the API. Let's start by updating our home page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a form to post text messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a home page that displays a simple title. Let''s use it and add a `<textarea>`
    tag to send content to the API. Later in this chapter, we will use the same page
    to display the user''s feed. Let''s replace the lonely `<h1>` tag with the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We still have the heading there, but it is displayed only if the `posting` variable
    is equal to `false`. In the next section, where we will update the controller
    of the home page, we will use `posting` to protect the content's form. In some
    cases, we do not want to make `<textarea>` visible.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have two blocks to show messages. The first one will be visible
    if there is an error during the posting and the second one when everything goes
    well. The rest of the form is the needed user interface—the text area, input file
    field, and a button. The button dispatches a post event that we will catch in
    the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the content's model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will definitely need a model to manage communication with the API. Let''s
    create a new `models/Content.js` file and place the following code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The module extends the same `models/Base.js` class, which is similar to the
    other models in our system. The `lib/Ajax.js` module is needed because we are
    going to make HTTP requests. We should be familiar with the rest of the code.
    A `POST` request to `/api/content` is made by sending text that is passed as an
    argument to the `create` function.
  prefs: []
  type: TYPE_NORMAL
- en: The module will be updated when we reach the file posting. To create records
    that are based only on text, this is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the controller of the home page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a proper model and form, we are ready to tweak the controller
    of the home page. As mentioned earlier, the `posting` variable controls the visibility
    of the form. Its value will be set to `true` by default, and if the user is not
    logged in, we will change it to `false`. Every Ractive.js component may have a
    `data` property. It represents the initial state of all the internal variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add some logic to the `onrender` handler. This is the entry point
    to our component. We will start by checking whether the current user is logged
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From [Chapter 5](part0040.xhtml#aid-164MG1 "Chapter 5. Managing Users"), *Managing
    Users*, we know that `userModel` is a global object that we can use to check the
    state of the current user. As mentioned earlier, if we have an unauthorized visitor,
    we have to set `posting` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next logical step is to process the content from the form and submit a
    request to the API. We will use the newly created `ContentModel` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the user presses the button in the form, our component dispatches a `post`
    event. We will then catch the event and call the `create` method of the model.
    It is important to give a proper response to the user, so we clear the text field
    with `self.set('text', '')` and use the local `error` and `success` variables
    to indicate the status of the request.
  prefs: []
  type: TYPE_NORMAL
- en: Storing content in the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have an HTML form that submits an HTTP request to the API. In this
    section, we will update our API so that we can store text content in the database.
    The endpoint of our model is `/api/content`. We will add a new route and protect
    it by allowing access to only authorized users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will create a `user` local variable that contains the visitor's session data.
    Every post that goes to the database should have an owner. So, it is good to have
    a shortcut to the user's profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same `/api/content` directory will be used to fetch the posts too. Again,
    we will use the `req.method` property to find out what kind of request is coming.
    If it is `GET`, we need to fetch the posts from the database and send them to
    the browser. If it is `POST`, we have to create a new entry. Here is the code
    that sends the user''s text to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The data sent by the browser is coming as `POST` variables. Again, we need
    the help of `processPOSTRequest` to access it. If there is no `.text` or it is
    empty, the API returns an error. If everything is okay and the text message is
    available, we proceed with the establishing of the database connection. We also
    fetch the entire profile of the current user. The posts in our social network
    will be saved along with the following additional properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`userId`: This represents the creator of the record. We will use this property
    during the feed generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`userName`: We do not want to call `getCurrentUser` for every single post that
    we display. So, the name of the owner is directly stored along with the text.
    It is worth mentioning that in some cases, such calls are needed. For example,
    the calls will be needed while changing the name of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`: We should know the date of the creation of data. It is useful for the
    sorting or filtering of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, we call `collection.insert`, which effectively stores the entry
    in the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to retrieve created content and display
    it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the user's feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, every user is able to store messages in our database. Let's continue by
    showing the records in the browser. We will start by adding logic to the API that
    fetches the posts. It will be interesting because you should get the messages
    sent by not only a specific user, but also to his/her friends. We used the `POST`
    method to create content. The following lines will process the `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will get the IDs of the user''s friends in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapter, we implemented friendship capabilities and kept the
    IDs of the user's friends directly in the profile of the user. The `friends` array
    is exactly what we need because the posts in our social network are linked to
    the users' profiles by their IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to establish a connection to the database and query only those
    records that match the specific IDs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to read the records from the `content` collection. The `find`
    method accepts an object that has the `$query` and `$orderby` properties. In the
    first one, we will put our criteria. In this particular case, we want to get all
    the records'' IDs that are a part of the `friends` array. In order to create such
    a query, we need the `$in` operator. It accepts an array. Along with the posts
    of the user''s friends, we need to show the posts of the user. So, we will create
    an array with an item—the ID of the current user—and concatenate it with `friends`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After a successful query, the `userId` property is deleted because it is not
    needed. In the `content` collection, we keep the text of the message and the name
    of the owner. In the end, the records are sent attached to the `posts` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the additions made in the preceding code, our backend returns the posts
    made by the current user and their friends. All we have to do is update the controller
    of our home page and use the API''s method. Right after the code listening for
    the `post` event, we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The calling of the `fetch` method triggers the `GET` request to the API at
    the model''s endpoint—`/api/content`. The process is wrapped in a function because
    the same action will happen when a new post is created. As we already know, if
    `model.create` succeeds, a callback is fired. We will add `getPosts()` there so
    that the user sees his/her newest post in the feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What the `getPosts` function produces as a result are lists of objects stored
    in a local variable called `posts`. The same variable is accessible in the Ractive.js
    template. We need to loop through the items in the array and display the information
    on the screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Just after the form, we use the `each` operator to show the author and the text
    of the post.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the users in our network will be able to create and browse messages
    in the form of text blocks. In the next section, we will extend the functionalities
    that we have written so far and make the uploading of images along with the text
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Posting files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are building a single-page application. One of the characteristics of such
    applications is that all the operations happen without a page reload. Uploading
    files without changing the page was always tricky. In the past, we used solutions
    that involved hidden iframes or small Flash applications. Thankfully, when HTML5
    arrived, it introduced the **FormData** interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The popular Ajax is possible because of the `XMLHttpRequest` object. Back in
    2005, Jesse James Garrett coined the term "Ajax", and we started using it to make
    HTTP requests within JavaScript. It became easy to perform the `GET` or `POST`
    requests in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code generates a proper `POST` requests and even sets the right
    headers. The problem is that the parameters are represented as a string. The forming
    of such strings requires additional effort. It is also difficult to send files.
    It can be quite challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FormData interface solves this problem. We create an object that is a set
    of key/value pairs representing form fields and their values. Then, we pass this
    object to the `send` method of the `XMLHTTPRequest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All we have to do is use the `append` method and specify the `input` DOM element
    with the `file` type. The rest is done by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide the ability to upload files, we need to add the UI element for file
    selection. Here is how the form in `home.html` template looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code but with a new `input` element with type equal to `file`. So
    far, the implementation in our controller that sends the `POST` requests doesn''t
    use the FormData interface. Let''s change this and update the `controllers/Home.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code is changed. So, the code creates a new `FormData` object and uses the
    `append` method for collecting the information needed for the new post. We make
    sure that the files selected by the user are appended. By default, the HTML input
    provides a selection of only one file. However, we can add the `multiple` attribute
    and the browser will allow us to choose more than one file. It is worth mentioning
    that we filter the selected files and only use the images.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the latest changes, the `create` method of our model accepts the `FormData`
    object and not a plain JavaScript object. So, we have to update the model, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `data` property is replaced with the `formData` one. Now we know that the
    frontend sends the selected files to the API. However, we do not have the code
    that handles the `multipart/form-data` type of the `POST` data. The processing
    of files sent through the `POST` request is not that simple, and `processPOSTRequest`
    will not do the job in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js has a big community, and there are thousands of modules available. The
    `formidable` module is what we are going to use. It has a fairly simple API and
    it handles requests containing files. What happens during the file upload is that
    `formidable` saves the file in a specific location on the server's hard disk.
    Then, we receive the path to the resource. Finally, we have to decide what to
    do with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `backend/API.js` file, the application flow is split into the `GET`
    and `POST` requests. We are going to update a major part of the `POST` case. The
    following lines contain the `formidable` initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, the module saves the uploaded files in a temporary folder
    on the hard drive. The `uploadDir` variable contains a more appropriate place
    for the users' images. The callback passed to the `parse` function of `formidable`
    receives the normal text fields in the `data` argument and uploads the images
    in `files`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid the long chain of nested JavaScript callbacks, we will extract
    some logic into the function definitions. For example, the moving of files from
    the `temporary` to the `static` folder can be performed in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We don't want to mix the files of different users. So, we will use the ID of
    the user and create his/her own folder. There are a few other issues that we may
    have to take care of. For example, we can create subfolders for every file so
    that we can prevent the overwriting of the resources that are already uploaded.
    However, to keep the code as simple as possible, we will stop here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code that saves the post to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We still need a connection to the database and the fetching of the current user's
    profile. The difference here is that we attach a new `file` property to the object
    stored in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we have to update the template of the home page so that it shows
    the uploaded file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `each` loop checks whether there is a file that comes with the text
    of the post. If yes, it displays an `img` tag that shows the image. With this
    last addition, the users of our social network will be able to create content
    that consists of text and pictures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we did something that is very important for our application.
    We implemented content creation and delivery by extending our backend API. A couple
    of changes were made to the frontend too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue adding new features. We will make the
    creating of branded pages and events possible.
  prefs: []
  type: TYPE_NORMAL
