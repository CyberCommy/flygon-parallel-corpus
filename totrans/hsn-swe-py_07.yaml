- en: Setting Up Projects and Processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first iteration is all about getting things ready for all of the following
    iterations, and for any development efforts after the project is initially complete—bug
    fixes, maintenance, new feature requests, and so on. This sort of preparation
    will need to be undertaken for any new development effort over a certain expected
    degree of complexity, but it may not be broken out into its own iteration. Creating
    many of the foundational structures could be managed as part of other iterations;creating
    the project's structure when the first development that needs it starts, for example.
    The trade-off that's tied into taking that approach is that there is a higher
    probability that early definition work will have to be significantly altered as
    later development unfolds because that original structure couldn't accommodate
    multiple Python virtual environments, or the addition of a new project to the
    system's code base.
  prefs: []
  type: TYPE_NORMAL
- en: Having some standard structural definitions, like the ones from [Chapter 6](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=30&action=edit), *Development
    Tools and Best Practices,* will minimize a fair number of these concerns going
    forward, but may not prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the setup and preparation items that are common to
    most projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source Code Management** (**SCM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and deploy processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The deliverables of this iteration are mostly focused, then, on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A master repository, stored in a Git server or service (local server, GitHub,
    or Bitbucket, for example) that contains the complete, empty project structure
    for the system and its component projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A component project for each deployable class library or application in the
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit test suite that can be executed and whose execution passes for each component
    project in the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A build process for each component project – also executable – that results
    in a deployable package, even if that package starts as something that's essentially
    useless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembly of stories and tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The needs of developers can also be expressed as stories, with tasks to execute. These
    foundational stories may be reused over multiple projects, and if they are, will
    likely evolve over time to better capture common needs and goals across development
    efforts—even for radically different systems. These should suffice as a starting
    point for now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, I need to know how source code for the system is going to be
    managed and version controlled so that I will be able to appropriately keep/store
    the code I write:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a blank SCM repository for the system—`hms_sys`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the repository with baseline information and documentation needed for
    ongoing use
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish and distribute whatever credentials are needed for dev team members
    to access the repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a developer, I need to know what the full structure of the system looks
    like, at least at a high level, so that I will be able to write code that fits
    into that structure. This will involve:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the use cases, and the logical and physical architecture, to define
    the component project's needs and its structure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building out standard project starting points for each component project identified
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing a minimal `setup.py` for each component project that completes
    a source package build
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determining whether or not to use Python virtual environments for component
    projects, implement them, and document how they can be reproduced
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a developer, I need to know how and where to write unit tests for the code
    base so that I can create unit tests after the code is written. I also need to
    ensure that the code is thoroughly tested:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define unit testing standards/requirements (coverage, standard values by type,
    and so on)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a mechanism for enforcing those standards
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define where unit test code is going to reside in a component project's structure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a basic, top-level test for each component project that executes without
    any failures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a developer, I need to know how to integrate unit tests for a component
    project into the build process for that component project so that builds can automatically
    execute unit tests, which involves:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining how to integrate unit tests into the build process; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining how to deal with build/test integration for different environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Up SCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the balance of the activities that need to happen in this iteration will
    ultimately need to be stored in SCM, the first story from the list that will be
    undertaken, with its tasks, is the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, I need to know how source code for the system is going to be
    managed and version controlled, so that I will be able to appropriately keep/store
    the code I write:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a blank SCM repository for the system—``hms_sys``
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Populate the repository with the baseline information and documentation needed
    for ongoing use
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish and distribute whatever credentials are needed for dev team members
    to access the repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for `hms_sys` is going to live in Bitbucket ([https://bitbucket.org](https://bitbucket.org)),
    in a Git repository, so the first step is to set Up a new repository there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3633e5d7-d6fd-47de-97a4-ea8ac5c36ee2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The settings for the new repository are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Owner: The user who owns the repository. If multiple users have access to the
    repository through the Bitbucket account, or if there are groups associated with
    it, those users and groups will be available as options for this setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository name: The (required) name of the repository. Ideally, a repository
    name should be easily associated with the system or project that it contains,
    and since `hms_sys` is both the name of the overall project and it wasn''t already
    taken, that was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access level: Determines whether the repository is public or private. Since
    `hms_sys` is not intended for public perusal or distribution, the repository has
    been made private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Include a README?: Whether the system will create a `README` file as part of
    the creation process. The options are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No: Will require the manual creation of the file later, if one is even needed/desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, with a template: Creates a basic file with minimal information. This option
    was selected so that a basic `README` file would be created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, with a tutorial (for beginners).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version control system: Allows the repository to use either Git or Mercurial
    as its SCM engine. Git was selected because that''s what we decided to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Advanced settings have to be expanded to be available, and are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Description: Any description provided here will be added to the `README` file
    if the Yes, with a template option was selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forking: Controls whether/how forking is allowed from the repository. The options
    are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow forks: Anyone who has access can fork the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow only private forks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No forks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project management: Allows the integration of issue tracking and wiki systems
    with the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Language: Specifies a primary programming language for the code in the repository.
    This setting doesn''t do anything other than categorize the repository by its
    primary language, at least initially. Some SCM providers will use the language
    settings to pre-populate Git''s `.gitignore` file with commonly ignored file patterns,
    though, so it''s advantageous to specify it if possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the Create repository button is clicked, the repository will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd3bedd7-14cd-4d16-9248-6e73670d0d99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the overview page for any repository, the HTTPS and SSH options for connecting
    to and cloning/pulling the repository are available, and anyone who has the requisite
    permissions can clone it (by whatever means are preferred) to a local copy to
    work with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9c540d9-904a-4c59-98e7-a05af6cc69c8.png)There are several ways
    to initialize a new Git repository. This process, starting at the repository''s
    provider, assures that the repository is well-formed and accessible, as well as
    allowing for some initial configuration and documentation setup that won''t have
    to be done by hand later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, two of the tasks from the story are resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a blank SCM repo for the system—`hms_sys`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish and distribute whatever credentials are needed for dev team members
    to access the repository. Since the repository was created through the external
    service provider's interface, the credentials needed for access are managed there,
    and anyone whose user account is associated with the repository's accounts or
    groups either has the access they'll need, or can be given it through the user
    management in the provider's system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The remaining task, populated with baseline information and the documentation
    needed for ongoing use, has ties to the project structure that haven't been addressed,
    but there are still items that can be addressed that are independent of that.
  prefs: []
  type: TYPE_NORMAL
- en: First is the creation and documentation of the base component projects in the
    top-level repository directory. Initially, it's probably a good idea to create
    a top-level project, encompassing the entire system code base—this will provide
    a single project that can be used to organize items that span two or more of the
    component projects, as well as anything that encompasses the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Geany, that''s accomplished by using Project → New, supplying a project
    name, project file path, and a base path for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2e94a29-c46c-450b-a006-5ed04eae1f5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since Geany project files store filesystem paths that may vary from one machine
    to another, those need to be added to Git''s `.gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `.gitignore` file is, ultimately, a list of files and/or folders that Git
    will ignore when committing or pushing code to the central repository. Any file
    or folder that matches one of the paths in `.gitignore` will not be tracked by
    the SCM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, instructions for creating a local `hms_sys.geany` file should
    probably be documented so that any other developer who needs one can create one
    as needed. That sort of information can be dropped into the `README.md` file,
    and similar efforts will be undertaken as the component projects for the system
    are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these changes are staged, committed locally, and pushed to the master
    repository, what should appear there is a revised `README.md` file and a new `.gitignore`,
    but not the `hms_sys.geany` project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a1d0b88d-71d2-413b-bcf5-a0fe8a54df03.png)'
  prefs: []
  type: TYPE_IMG
- en: As the component projects get added into the code base, the same sort of documentation
    and setup should be followed, yielding similar results. At this point, the final
    task of the first story is as complete as it can be, so it would be reviewed and
    closed if it was judged complete and approved.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing out component projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On, then, to the next story:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, I need to know what the full structure of the system looks
    like, at least at a high level, so that I will be able to write code that fits
    into that structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze the use cases, and the logical and physical architecture to define the
    component project's needs and its structure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build out standard project starting points for each component project identified
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a minimal `setup.py` for each component project that completes a source
    package build
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Component project analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logical architecture, along with the use cases diagram from [Chapter 6](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=30&action=edit), *Development
    Tools and Best Practices,* indicates three obvious component projects that will
    need to be accounted for, one each for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Artisan Application**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Artisan Gateway**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Review/Manage Application**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these component projects, in turn, needs access to some common object
    types—they all need to be able to handle **Product** instances, and most of them
    also need to be able to work with **Artisan** and **Order** instances as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4d63b4a0-ca46-4c5d-80a0-24978af874b5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There may well be other business objects that aren''t immediately apparent
    from this breakout, but the fact that there are any is a good sign that there
    is probably a need for a fourth component project to collect the code that provides
    those business objects and their functionality. With that in mind, the initial
    component project structure boils down to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HMS Core** (`hms-core`): A class library collecting all of the baseline business
    object definitions to provide representations of objects such as **artisans**,
    **products**, and **orders**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Central Office Application** (`hms-co-app`): Provides an executable application
    that allows Central Office staff to perform various tasks that require communication
    with an **Artisan** about **products**, **orders**, and perhaps other items as
    well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Artisan Application** (`hms-artisan`): Provides an executable local application
    that allows an **Artisan** to manage **products** and **orders**, communicating
    with the Central Office as needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The HMS Artisan Gateway** (`hms-gateway`): Provides an executable service
    that the **Artisan** Application and Central Office Application use to send information
    back and forth between the artisans and the Central Office'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some decisions will have to be made later on about how the `hms-core` code will
    be included in distributions of the other projects that require it, but those
    don't need to be tackled until they're reached, so they'll be set aside for now.
    In the meantime, setting Up starting point project structures for each of the
    component projects is the next step. The basic structure, for now, is identical
    across all four of the component projects;the only differences will be in the
    names of the various files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `hms-core` as an example, since that''s the first logical code set to
    start working on, the project structures will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3246869b-f7de-4208-9ee1-e93b0521f081.png)'
  prefs: []
  type: TYPE_IMG
- en: Packaging and build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up the minimal standard Python packaging for a project and providing
    the bare-bones build process makes very few changes to the baseline `setup.py`
    and `Makefile` files that were discussed earlier. There are only a few specifics
    that are available before code starts being written: the package name and the
    top-level directory of the main package that `setup.py` will use, and the `setup.py`
    file itself that can be added to the `Makefile`.  The `Makefile` changes are the
    simplest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setup.py` file, though it''s been populated with some starting data and
    information, is still pretty much the same bare-bones starting point file that
    we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure will not acquire any of the various directories and files outside
    the core package just yet either—at this point, there''s no indication that any
    of them will be needed, so their inclusion will be left until there''s an actual
    need for them. Even without those, though, the `setup.py` file can successfully
    build and install the source distribution package, though it throws a few warnings
    during the build process, and the installed package doesn''t provide any functionality
    yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41827bb6-0523-4d13-bd79-6c1031958583.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In larger (or at least more formally structured) development shops, the build/packaging
    processes for component projects may well need to accommodate different builds
    for different environments:'
  prefs: []
  type: TYPE_NORMAL
- en: A local environment, such as the developers' local machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared development environment, where all developers' local code changes first
    mix together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared test server for QA and broader integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A User Acceptance Testing server, using realistic, production-like data that
    can be used to demonstrate functionality to whoever needs to give final approval
    for changes to be promoted to a live environment or build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A staging environment that has full access to a complete copy of production
    data, with an eye toward being able to perform load and other tests that require
    access to that dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The live environment/build code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is at least *some* potential for needing significant differentiation between
    these different builds (`local`, `dev`, `test`, `stage`, and `live`, with the
    user acceptance build assumed to be identical to a stage build for the time being).
    At this point in the development effort, though, there really isn't anything to
    differentiate, so the best that can be done is to plan around what will happen
    if it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Until there is a need for a completely different package structure for any given
    environment, the current `setup.py` file will remain untouched. It's highly unlikely
    that there will be an environment-specific need that isn't common across all environments.
    If such a need does arise, then the approach will be to create a distinct `setup.py`
    for each environment that has any distinct needs, and execute that specific `setup.py`,
    either manually or though the `Makefile`. With some care and thought, this should
    allow any environment-specific variances to be contained in a single location,
    and in a reasonably standard fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'That, in turn, means that there will have to be changes made to the `Makefile`.
    Specifically, there will need to be a target for each environment-specific build
    process (`dev` through `live` again), and some way of managing files that are
    specific to one of those environments. Since the `make` process can manipulate
    files, create directories, and so on, the strategy that will be used will be to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify environment-specific files by prefixing them with the build target/environment
    name that they relate to. For example, there would be a `dev-setup.py` file in
    the code base, as well as a `test-setup.py` file, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering the `Makefile` to make a copy of all relevant files in the project's
    code tree that can be altered (and destroyed) without impacting the core project
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a process that will find and rename all of the environment-specific files
    in the temporary copy as needed for a specific environment's build, and removing
    any environment-specific files from the temporary tree that aren't relevant to
    the build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing the `setup.py` file as normal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The changes that would be made to the `Makefile` would look something like this,
    at least as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define a common temporary build directory—the local build will be the
    default, and will simply execute the standard `setup.py` file, just as the original
    process did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A new target, `build_dir`, is created to create the temporary build directory,
    and to copy all of the project files that can be part of any build into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A prep target for each environment, as well as the final target for each, will
    be written to rename and remove files as needed, and to execute the `setup.py` file in
    the temporary build directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, when `make dev` is executed against this `Makefile`, the `dev` target runs
    the `unit_test` target, and then the `build_dir` target is used to create the
    temporary copy of the project. Afterwards, `dev_prep` is used to deal with the
    filename changes and the removal of files from other environments. Then, and only
    then, will it execute the remaining `setup.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Python virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final task to address is determining whether or not to use Python virtual
    environments for the various component projects, creating them if needed, and
    documenting how to create them so that other developers will be able to reproduce
    them if/as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Given the structure across the component projects, what is known about them,
    and how their installed code is expected to interact with other system members,
    there isn't an obvious need for different environments, or even an obvious advantage
    to establishing them. Provided that sufficient care and discipline were exercised
    during development, making sure that dependencies got added to each component
    project's `setup.py` or other build process artifacts or configuration, the worst-case
    scenario that would likely arise is that a missing dependency would be discovered
    during the process of performing a test installation. In an otherwise bug-free
    live installation, there might be some trivial inefficiencies that would creep
    in—the `hms-gateway` project, for example, might install database or GUI libraries
    that it won't need or doesn't use, or the two component projects might both have
    message-system libraries that the other users installed, but which aren't needed.
  prefs: []
  type: TYPE_NORMAL
- en: None of these represent any sort of imminent threat to the operation of the
    individual component project installations, but they do throw unnecessary code
    into the installations. The potential for significant creep of needless library
    installations is very real if it isn't carefully watched and managed, and could
    be a vector for security issues in the future. Worse, any potential security issues
    might not be visible as a result; if no-one is really aware that something not
    needed got installed with a given program, then it may not get fixed until it's
    too late.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first best steps that can be taken to keep systems secure is to assure
    that they only have exactly what they need to function installed. That won't cover
    every possibility, but it will reduce the bandwidth needed to keep current with
    patches and security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping track of dependencies on a project-by-project basis is something that
    virtual environments can make a difference in. That's a point in favor of setting
    them Up for each project individually. Another point in favor of this practice
    is that some platforms, such as the various public clouds, will require the ability
    to include dependent packages as part of their deployment process, and a virtual
    environment will keep those nicely separated from the core system installation
    package set. In that respect, virtual environments are also, then, a type of future-proofing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of developing `hms_sys`, then, we''ll set up a separate virtual
    environment for each component project. If they prove unnecessary later on, they
    can always be deleted. The processes for creating, activating, and deactivating
    them are pretty straightforward, and can be created wherever is convenient—there
    isn''t really any standard location — the commands vary per Operating System,
    though, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Virtual Environment Activity | Operating system |'
  prefs: []
  type: TYPE_TB
- en: '| Linux/MacOS/Unix | Windows |'
  prefs: []
  type: TYPE_TB
- en: '| Creating | `python3 -m venv ~/path/to-myenv` | `c:\>c:\Python3\python -m
    venv c:\path\to\myenv` |'
  prefs: []
  type: TYPE_TB
- en: '| Activating | `source ~/path/to-myenv/bin/activate` | `C:\> c:\path\to\myenv\Scripts\activate.bat`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Deactivating | `deactivate` | `C:\> c:\path\to\myenv\Scripts\deactivate.bat`
    |'
  prefs: []
  type: TYPE_TB
- en: Once a virtual environment is created and activated, packages can be installed
    in it with `pip` (or `pip3`), just like outside the virtual environment's context.
    Installed packages are stored in the virtual environment's libraries, instead
    of in the global system libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting which virtual environments are associated with which component projects
    is just a matter of copying the commands needed to create it into project-level
    documentation somewhere. For `hms_sys`, these will be stored in the `README.md`
    files for each component project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the tasks for this story:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the use cases, and the logical and physical architecture to define component-project
    needs and structure—**Done**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build out standard project starting points for each component project identified—**Done**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a minimal `setup.py` file for each component project that completes
    a source package build—**Done**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine whether or not to use Python virtual environments for component projects,
    implement them, and document how they can be reproduced—**Done**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a unit testing structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of the previous chapter, it was noted that although an expectation
    had been set that all code would be unit-tested, with all public members of modules
    and classes subject to that requirement, it was also noted that no test policy
    details had been defined yet, which is a good part of what the unit testing story
    in this iteration is all about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, I need to know how and where to write unit tests for the code
    base so that I can create unit tests after the code is written. I also need to
    assure that the code is thoroughly tested:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define unit testing standards/requirements (coverage, standard values by type,
    and so on)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a mechanism for enforcing those standards
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define where unit test code is going to reside in a component project's structure
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a basic, top-level test for each component project that executes without
    any failures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bulk of this unit testing material was adapted and converted into Python
    3 from Python 2.7.x code and a discussion of this is on the author's blog (starting
    at [bit.ly/HOSEP-IDIC-UT](http://bit.ly/HOSEP-IDIC-UT)). Though that code was
    written for an older version of Python, there may be additional insights to be
    gained from the unit testing articles there.
  prefs: []
  type: TYPE_NORMAL
- en: 'It could be argued that all members, not just the public ones, should be tested—after
    all, if the code in question gets used anywhere, it should also be held to the
    same standards as far as predictable behavior is concerned, yes? Technically,
    there''s no reason that can''t be done, particularly in Python where protected
    and private class members aren''t really protected or private they are merely
    treated as such by convention—in earlier versions of Python, protected members
    were accessible, and private members (prefixed with two underscores: `__private_member`)
    were not directly accessible in derived classes, except by calling them by their
    mangled name. In Python 3, there is no language-level enforcement of nominally
    protected or private scope, even though the name mangling is still in play. This
    is quickly demonstrated. Consider the following class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to create an instance of `ExampleParent`, and call its `show` method,
    we''d expect to see all three groups of output and that''s exactly what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b1d4a55-d5ba-4906-a7da-27ee5dd81a70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the `ExampleParent` class structure is examined with `dir(ExampleParent)`,
    all three of the methods can be seen: [''`_ExampleParent__private_method`'', …,
    ''`_protected_method`'', ''`public_method`'', …]. In earlier versions of Python,
    a class derived from `ExampleParent` would still have access to `public_method`
    and `_protected_method`, but would raise an error if `__private_method` was called
    by that name. In Python 3 (and some later versions of Python 2.7.x), that is no
    longer the case.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating an instance of this class, and calling its `show` method yields the
    same results:![](assets/24ed77f9-a8fd-49ac-a999-51d090e8aaa1.png)
  prefs: []
  type: TYPE_NORMAL
- en: Technically then, all members of a Python class are public.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what does that mean from the perspective of defining a unit testing policy,
    if all class members are public? If the public/protected/private convention is
    adhered to, then the following apply:'
  prefs: []
  type: TYPE_NORMAL
- en: Public members should be tested in the test suite that corresponds to the class
    they are defined in (their class of origin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most protected members are likely intended to be inherited by derived classes,
    and should be tested in depth in the test suite that corresponds with the class
    they are defined in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private members should be treated as if they really were private—not accessible
    at all outside their class of origin—or as if they were implementation details
    that are subject to breaking changes without warning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherited members shouldn't require any testing again, then, since they will
    have been tested against their class of origin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Members that are overridden from their parent classes will be tested in the
    suite that relates to the class they are overridden in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Up a unit testing process that applies all of these rules is possible,
    though it's moderately complex and substantial enough that it'd be really advantageous
    to be able to wrap it Up in some sort of reusable function or class so that it
    doesn't have to be recreated in every test process, or maintained across dozens
    or hundreds of copies of it if test policies change. The end goal would be to
    have a repeatable test structure that's quickly and easily implemented which implies
    that it could also be templated out in much the same way that modules and package
    headers were earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, though, we need something to test. Specifically, we need classes that
    have methods that fall into the categories that were noted previously:'
  prefs: []
  type: TYPE_NORMAL
- en: Defined locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherited from a parent class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overridden from a parent class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This covers all of the public/protected/private options. Though it wasn''t
    specifically mentioned previously, we should also include a class that has at
    least one abstract method.Those are still classes, and will also need to be tested;
    they just haven''t been addressed yet. They don''t need to be very complex to
    illustrate the test process, though they should return testable values. With all
    of that in mind, here is a simple set of classes that we''ll use to test against
    and to generate the core test process:'
  prefs: []
  type: TYPE_NORMAL
- en: These files are in the `hms_sys` code base, in the top-level `scratch-space`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a quick instance of each concrete class, and calling the `show` method
    of each instance, shows the anticipated results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76292447-5806-4101-acb0-c649c747d0ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing in Python is supported by the built-in `unittest` module. There
    may be other modules that also provide unit testing functionality, but `unittest`
    is readily available, is installed in Python virtual environments by default,
    and provides all the testing functionality necessary for our purposes, at least
    as a starting point. The initial test module for the preceding classes is quite
    simple, even if it doesn''t do anything more than define the test case classes
    that apply to the code being tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the classes that begin with `test` (and that are derived from `unittest.TestCase`)
    will be instantiated by the `unittest.main()` call at the end of the module, and
    each method within those classes whose name also starts with `test` will be executed.
    If we add test methods to one of them, `testParent `for example, and run the test
    module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of the test methods can be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8564487b-106a-4bdd-9069-98606419bd70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If the `print()` calls are replaced with a pass, as shown in the following
    code, the output is even simpler, printing a period for each test case''s test
    method that executes without raising an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this yields the following:![](assets/f2124f2f-1f61-400a-9028-6170a1628ac4.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good then;we have tests that can be executed, so the next question
    is how to apply the test policy rules that we want applied. The first policy,
    having a test module for each source module, is an aspect of project structure
    rather than one tied to test execution processes. All that we really need to do
    in order to address that is define where test code will live in any given project.
    Since we know that we''re going to want to address running tests during the build
    process later on, we need to have a common test directory, a file just inside
    it (call it `run_tests.py`) that can run all the project''s tests on demand, and
    a test directory and file structure that''s accessible to that file should be
    included, which ends Up looking like this for the `hms_core` component project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e13fc4d7-5a42-4fd5-bde1-e66d4c44920d.png)'
  prefs: []
  type: TYPE_IMG
- en: Identifying missing test case classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The balance of the testing goals noted earlier all require the ability to examine
    the code being tested in order to identify module members, and members of those
    members, that need to be tested. This might sound daunting, but Python provides
    a module dedicated to that purpose: `inspect`. It provides a very robust collection
    of functions that can be used to examine Python code at runtime, which can be
    leveraged to generate collections of member names that can, in turn, be used to
    determine whether the high-level test coverage meets the standard we''re establishing.'
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of illustration, the preceding classes that we need to test
    will be saved in a module called `me.py`, which makes them importable, and each
    step demonstrating the process for finding the needed information about the `me`
    module will be collected in `inspect_me.py`, as this shown here. The corresponding
    test cases will live in `test_me.py`, which will start as a near-empty file—no
    test case classes will be defined there at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is identifying the target members of `me` that we''re going
    to require test case classes for. As things stand right now, all we need is a
    list of classes in the target module, which can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Step by step, what''s happening is this:'
  prefs: []
  type: TYPE_NORMAL
- en: The `inspect` module is being imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `me` module is being imported, using `target_module` as an override to its
    default module-name—we'll want to be able to keep imported module names predictable
    and relatively constant to make things easier to reuse down the line, and that
    starts here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `getmembers` function of `inspect` is called against the `target_module`,
    using `isclass` as a filtering predicate. This returns a list of tuples that look
    like `('ClassName', <class object>)`. Those results are run through a list comprehension
    to extract only the class names, and that list is handed off to a Python `set`
    to yield a formal set of class names that were discovered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python's `set` type is a very useful basic data type it provides an iterable
    collection of values that are distinct (never repeated in the set), and that can
    be merged with other sets (with `union`), have its members removed from other
    sets (with `difference`), and a host of other operations that would be expected
    from standard set theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'With those names available, creating a set of expected test case class names
    is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just another list comprehension that builds a set of class names that
    start with `test` from the target class name set. A similar approach to the one
    that gathered the class names in the target module can be used to find the test
    case classes that exist in the `test_me.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the `issubclass` check of each member found, which will limit the
    members of the set to names of classes that are derived from `unittest.TestCase`,
    this is identical to the process that built the initial `target_classes` set.
    Now that we have sets that collect what''s expected and what''s actually defined,
    determining what test case classes need to be created is a simple matter of removing
    the defined test case names from the set of expected ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If `missing_tests` is not empty, then its collection of names represents the
    test case class names that need to be created in order to meet the first part
    of the "all members will be tested" policy. A simple print of the results at this
    point will suffice for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/0a3a9422-8343-452d-860f-528ac0c04b40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having identified the missing test case class items that need to be created,
    they can be added to `test_me.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once they have been added (and once subclasses are derived from `unittest.TestCase`,
    because of the check performed earlier in identifying actual test case classes),
    there are no missing test cases that need to be addressed.
  prefs: []
  type: TYPE_NORMAL
- en: A similar approach could be taken for identifying module-level functions that
    should arguably also be tested—they are also public members of a module, after
    all, and that's what the policy is concerned with, public members of modules.
    The actual implementation of tests against functions, or any other callable element,
    would follow the structures and processes that will be established later for class
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Really, the only public members that may not be easily identified with this
    sort of process are unmanaged attributes—module constants or variables that are
    created at the module level. While those could still be tested, and arguably should
    be, the fact that they are unmanaged, and can be changed at runtime without any
    checks to assure that they aren't going to break things somewhere down the line,
    might well make any formal testing policy around them little more than a waste
    of time. That said, there's no harm in testing them, if only to assure that changes
    to them, intentional or accidental, don't pass unnoticed and raise issues and
    bugs later on.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying missing test methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `inspect.getmembers` function that was used to identify classes in modules
    earlier can also be used to identify other member types of other target elements,
    such as properties and methods of classes. The process for identifying either
    is similar to what''s already been shown for identifying classes in modules, and
    looks like this (for properties):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The only significant differences here from the process for finding classes in
    a module are the target that's being inspected (in this case, the `target_class`,
    which we've set to the `Parent` class) and the predicate (`inspect.isdatadescriptor`),
    which filters the results to data descriptors—managed attributes or formal properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 6](62f5861c-5fbb-44f3-82c3-585d2b238773.xhtml), *Development Tools
    and Best Practices*, when the various internal code standards were being discussed
    and defined, one aspect of using managed attributes/properties was noted as being
    significant for unit testing purposes:the ability to know what kinds of values
    to test with for any given property. This is another advantage of taking that
    approach: class properties defined using the built-in `property()` function can
    be detected as class members that need to be tested. Unmanaged attributes, though
    they may well be detectable, may not be readily identifiable as members of a class
    that need to be tested, and that identification is almost certainly not something
    that can be automated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar `inspect.getmembers` call can be used to identify class methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Both of these member name collections include items that the test policy doesn't
    require tests for, though the `__weakref__` property is a built-in property of
    all classes and the `_Parent__private` method entry ties back to our original
    `__private` method, and neither of those need to be included in our lists of required
    test methods. Some basic filtering can be accomplished by simply adding a check
    for a leading `__` in the property list names (since we'd never be testing a private
    property according to our test policy). That'd take care of removing `__weakref__`
    from the test list, and allow public and protected properties to appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding a property declaration (`prop`) to Parent, and adding that filtering
    criteria, we would get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That same approach would not work well for finding class methods that need to
    be tested, though;some common methods, such as `__init__`, have names that would
    be removed based on name-based filtering, but are members that we'd want to assure
    have tests required. This simple name-based filtering also doesn't deal with not
    including member names that exist in a class but aren't defined in that class—like
    all of the properties and members of the `Child` class. While the name-based filtering
    is a step in the right direction, it feels like it's time to take a step back
    and look at a broader solution,one that does account for where a member is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'That involves building the list of test names in a more complex fashion, and
    paying attention to the **Method Resolution Order** (**MRO**) of each class, which
    can be found in a class built-in `__mro__` property. We''ll start by defining
    an empty set and acquiring the MRO of the class, then the same list of property
    names that were available from the target class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to keep track of where a property''s definition can be found,that
    is, what class it originates in, as well as the actual implementation of the properties.
    We''ll want to start with a complete data structure for each, which associates
    the names with the source classes and implementations eventually, but that''s
    initialized with `None` values to start with. That will allow the final structure,
    once it''s populated, to be used to identify members of the class that aren''t
    defined there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With that data in hand, the generation of the list of required property test
    methods is similar to the required test case class list shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for acquiring and filtering down the method members of a class
    looks almost the same, though we''re going to include all members, even those
    whose names begin with `__`, and acquire members that are either functions or
    methods, just to ensure that we''ll include class and static methods of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for constructing the `dict` items used to keep track of method
    sources and implementations can actively skip local, private members and anything
    that''s been defined as abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The balance of the test name list generation is the same, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what are the takeaways from all of this exploration? To put it briefly,
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to automate the process of detecting what members of a module
    should require test cases to be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to automate the process of verifying that those required test
    cases exist in the test module that corresponds to a given source module, though
    it still requires some discipline to assure that the test modules are created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to automate the process of detecting what test methods need to
    be required for any given test case/source class combination, and to do so without
    requiring the testing of private and abstract members, neither of which make much
    sense in the context of the test policies we're looking to establish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a fair chunk of code, though. 80-odd lines, without some of the actual
    testing of class members and the announcement of issues, and after stripping out
    all the comments. That's a lot more code than should ever be copied and pasted
    around, especially for a process that has the kind of high damage potential or
    impact that a unit testing process has. It'd be a lot better to be able to keep
    it all in one place. Fortunately, the `unittest` module's classes provide some
    options that will make creating module-by-module code coverage tests amazingly
    easy—though it will require some design and implementation first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating reusable module code coverage tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good unit testing framework will allow not just the creation of tests for
    members of code elements, but will also provide mechanisms for executing code
    before any of the tests are run, as well as after all tests have executed, successfully
    or not. Python's `unittest` module handles that in the individual `TestCase` classes,
    which allow the class to implement the `setUpClass` and `tearDownClass` methods
    to handle the pre- and post-test setup and teardown, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'That, then, means that it''d be possible to create a test class that could
    be imported, extended with module-specific properties, and added to a test module
    that could leverage all of the capabilities just shown to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Find all of the classes and functions in the target module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine what test case classes need to exist in the test module, and test
    them to make sure they exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine, for each source module member's test case class, what tests need
    to exist in order to meet our unit testing policies and criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test for the existence of those test methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code coverage test case class will need to know what module to examine
    in order to find all of that information, but it should be able to manage everything
    else on its own. Ultimately, it will define just one test of its own that it will
    execute the one to assure that every class or function in the source module has
    a corresponding test case class in the test module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It will also need to be able to provide a mechanism to allow the checks for
    property and method test methods. Doing so on a fully automated basis is tempting,
    if it could even be achieved, but there may be cases where that could prove more
    troublesome bring up than worthwhile. At least for the time being, the addition
    of those tests will be made available by creating some decorators that will make
    attaching those tests to any given test case class easy.
  prefs: []
  type: TYPE_NORMAL
- en: Python's decorators are a fairly detailed topic in their own right. For now,
    don't worry about how they work  just be aware of what using them looks like and
    trust that they do work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our starting point is just a class derived from `unittest.TestCase` that defines
    the `setUpClass` class method noted earlier, and does some initial checking for
    a defined class-level `_testModule` attribute—if there is no test module, then
    all tests should simply skip or pass, since there''s nothing being tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `@classmethod` line is a built-in class method decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start by finding all the classes and functions available in the
    target module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll keep track of the name of the module being tested as an additional check
    criteria for class and function members, just in case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The mechanism for keeping track of the class and function tests is similar
    to the sources-and-implementations dictionaries in the initial exploration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of required test case class names is the aggregated list of all class
    and function test case class names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The collection of actual test case classes will be used later to test against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll generate the list of missing test case names that the class `testCodeCoverage`
    test method uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, that lone test method would be able to execute, and either pass
    or fail with an output that indicates what test cases are missing. If we write
    out the `test_me.py` module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then after it''s been executed, we would get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9c2a3323-b640-4cec-b3ee-6065dc67fc9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All that needs to be done to make that top-level code coverage test pass is
    to add the missing test case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach, taking a proactive stance on ensuring code coverage in this
    fashion, lends itself well to making unit testing a lot less troublesome. If the
    process for writing tests starts with a common test that will tell the test developer
    what''s missing at every step along the way, then the entire process of writing
    tests really becomes repeating the following steps until there are no tests failing:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute the test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If there are failing tests, make whatever code changes are needed to make the
    last one pass:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's a missing test failure, add the necessary test class or method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it's a failure because of the code in the source, alter that accordingly
    after verifying that the test values involved in the failure should have passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onward!
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to test for missing property and method tests across all
    the test case classes in the test module, we''ll need to find all of them and
    keep track of them on a class-by-class basis. This is mostly the same process
    that we discovered earlier, but the stored values have to be retrievable by class
    name since we want the single coverage test instance to check all of the source
    and test case classes, so we''ll store them in a couple of dictionaries, `propSources`
    for the sources of each, and `propImplementations` for the actual functionality
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The acquisition of the method tests works in the same way, and uses the same
    approach from the previous exploration as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these last two blocks have executed, the code coverage test class will
    have a complete breakout of all the test methods needed for each test case class
    in the test module. The property test collection (`cls._propertyTestsByClass`)
    is sparse, since there''s only one property associated with any class, `Parent.prop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The method test structure (`cls._methodTestsByClass`) has a bit more meat to
    it, though, and is accurately representing that the `public` and `_protected`
    methods in the `ChildOverride` class need their own test methods, and that the
    abstract `show` method in `Showable` does not need to be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That data is all that's needed to handle the tests for the required property
    and method tests. All that remains is working out a way to attach them to each
    test case class.
  prefs: []
  type: TYPE_NORMAL
- en: The property and method testing decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A decorator can be thought of as a function that takes another function as an
    argument, and extends or wraps other functionality around the decorated function
    without actually modifying it. Any callable—a function, an instance method of
    a class, or (in this case) a class method belonging to a class—can be used as
    the decorating function. In this case, the code coverage test case class is going
    to define two class methods (`AddPropertyTesting` and `AddMethodTesting`) using
    a decorator function structure in order to add new methods (`testPropertyCoverage`
    and `testMethodCoverage`) to any classes that are decorated with them. Those two
    methods, since they are nested members of the main code coverage class, have access
    to the data in the class—specifically the lists of required property and method
    test names that were generated. Also, because they are nested members of the decorator
    functions themselves, they will have access to the variables and data in those
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two decorator methods are almost identical, except for their names, their
    messaging, and where they look for their data, so only the first, `AddMethodTesting`,
    will be detailed. The method starts by checking to make sure that it''s a member
    of a class that extends the `ModuleCoverageTest` class—this assures that the data
    it''s going to be looking at is limited to only that which is relevant to the
    combined source and test modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `target` argument that's passed in at the start of the function is a `unittest.TestCase` class
    (though it's not explicitly type checked).
  prefs: []
  type: TYPE_NORMAL
- en: 'It also needs to make sure that the data it''s going to use is available. If
    it''s not, for whatever reason, that can be remedied by explicitly calling the
    class `setUpClass` method ,which was just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is defining a function instance to actually execute the test.
    This function is defined as if it were a member of a class because it will be
    by the time the decoration process has completed, but because it''s nested inside
    the decorator method, it has access to, and will preserve the values of, all of
    the variables and arguments defined in the decorator method so far. Of these,
    the most important is the `target`, since that''s the class that''s going to be
    decorated. That `target` value is, essentially, attached to the function that''s
    being defined/created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method itself is pretty straightforward: it creates a set of active
    test method names that are defined in the test case class it''s attached to, removes
    those from the required test methods for the test case class that it retrieves
    from the coverage test class, and if there are any left over, the test will fail
    and announce what''s missing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains to do is attach the function to the target and return the
    target so that access to it isn''t disrupted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once those decorators are defined, they can be applied to the unit testing
    code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And, with them in place, the test run starts reporting what''s missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f0e03da-20e0-492e-bf6c-1734514a639c.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating unit test template files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bare-bones starting point for the collection of tests just shown would work
    as a starting point for any other collection of tests that are concerned with
    a single module. The expected code structure for `hms_sys`, however, includes
    whole packages of code, and may include packages inside those packages. We don't
    know yet, because we haven't gotten that far. That's going to have an impact on
    the final unit testing approach, as well as on the creation of template files
    to make the creation of those test modules faster and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: The main impact is centered around the idea that we want to be able to execute
    all of the tests for an entire project with a single call, while at the same time
    not being required to execute every test in the component project's test suite
    in cases where the interest is in one or more tests running against something
    deeper in the package structure. It would make sense, then, to break the tests
    out in the same sort of organizational structure as the package that they are
    testing, and allow test modules at any level to import child tests when they are
    called or imported themselves by a parent higher Up the module tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'To that end, the template module for unit tests needs to accommodate the same
    sort of import capabilities that the main code base does, while keeping track
    of all the tests that result from whatever import process originated with the
    test run. Fortunately, the `unittest` module also provides classes that can be
    used to manage that need, such as the `TestSuite` class, which is a collection
    of tests that can be executed and that can have new tests added to it as needed.
    The final test module template looks much like the module template we created
    earlier, though it starts with some search-and-replace boilerplate comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the packages and modules that provide application functionality, the
    unit test module template doesn''t expect or need to provide much in the way of `**all**` entries—only
    the test case classes that reside in the module itself, and any child test modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few standard imports that will occur in all test modules, and there
    is the potential for third-party imports as well, though that''s probably not
    going to be common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'All the test modules will define a `unittest.TestSuite` instance named `LocalSuite`,
    which contains all of the local test cases and can be imported by name in parent
    modules when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also define boilerplate code that defines the code coverage test case
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point on, everything that isn''t part of the `__main__` execution
    of the module should be definitions of the test case classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If child test modules need to be imported later on, the code structure for
    doing so is here, commented out and ready to copy, paste, uncomment, and rename
    as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There more standard module sections, following the organization structure of
    the standard module and package templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there''s some provision for executing the module directly, running
    the tests, and displaying and writing out the reports when no failures occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The template provides a handful of items that can be found and replaced when
    it''s first copied to a final test module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PackagePath`: The full namespace to the module being tested, minus the module
    itself. For example, if a test module was being created for a module whose full
    namespace was `hms_core.business.processes.artisan`, the `PackagePath` would be
    `hms_core.business.processes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ModuleName`: The name of the module being tested (`artisan`, using the preceding
    example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That search-and-replace operation will also provide a unique name for the `ModuleCoverageTest` subclass definition
    that's embedded in the template. As soon as those replacements are completed,
    the test module can be run, as shown in the preceding example, and will start
    reporting on missing test cases and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each test module that follows this structure keeps track of its local tests
    in a `unittest.TestSuite` object that can be imported by parent test modules,
    and this can add tests from child `TestSuite` instances as needed a commented-out
    example of what that would look like is in place of the template file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the template file makes use of some display and reporting functions
    defined in the custom `unit_testing` module to write summary test result data
    to the console and (when tests run without failure) to a local file that can be
    tracked in source control if/as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating tests with the build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s only one story/task set remaining how to integrate unit tests with
    whatever build process will be put into play for the component projects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, I need to know how to integrate unit tests for a component
    project into the build process for that component project so that builds can automatically
    execute unit tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine how to integrate unit tests into the build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine how to deal with build/test integration for different environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the unit testing structures just defined in place in a component project,
    integrating them into a build process is relatively easily accomplished. In a
    `setup.py` file-based build, the test modules can be specified in the `test_suite`
    argument for the `setup` function itself, and tests can be run by executing `python
    setup.py test`. It will be necessary in the `hms_sys` component projects to add
    the path for the unit testing standards code to `setup.py` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If a Makefile-based build process becomes necessary, the specific call to `setup.py
    test` can simply be included in whatever Make targets are relevant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A test suite executed from within `setup.py` will return the appropriate values
    to stop the Make process if an error is raised or a failure occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's probable, barring the setup of a new team or new business, that most of
    these processes and policies will have been established well before the start
    of a project—usually before or during the first project that the team undertook.
    Most development shops and teams will have discovered the needs that underlie
    the sorts of solutions presented in this chapter, and will have acted upon them.
  prefs: []
  type: TYPE_NORMAL
- en: With all of these items set and committed to the SCM, the foundations are laid
    for all of the subsequent iterations' development work. The first “real” iteration
    will tackle the basic business object's definition and implementation.
  prefs: []
  type: TYPE_NORMAL
