- en: Fun with Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing access to a resource with Mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a map for concurrent access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a code block only once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pooling resources across multiple goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing goroutines with WaitGroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the fastest result from multiple sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propagating errors with errgroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The programming of concurrent behavior is always hard. Go has pretty good mechanisms for
    managing the concurrency in the form of channels. Besides the channels as a synchronization
    mechanism, the Go standard library provides the package to handle the concurrent
    parts of the more traditional core way. This chapter describes how to leverage
    the sync package for implementing common synchronization tasks. The final recipe
    will show the simplification of error propagation for a group of goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Check if Go is properly installed. The *Getting ready* section in the *Retrieving
    Golang version* recipe of *[Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml),*
    *Interacting with the Environment,* will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the ports `8080` and `7070` are not used by another application.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing access to a resource with Mutex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case the code uses the concurrent access to any resource which is considered
    to be unsafe for concurrent use, it is necessary to implement a synchronization
    mechanism to secure the access. Besides the channel usage, Mutex could be leveraged
    for this purpose. This recipe will show you how.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter10/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `mutex.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run mutex.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/74cd4a32-0ae7-4ae9-a01d-818c46a48289.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The synchronization primitive `Mutex` is provided by the package `sync`. The
    `Mutex` works as a lock above the secured section or resource. Once the `goroutine`
    calls `Lock` on the `Mutex` and the `Mutex` is in the unlocked state, the `Mutex`
    becomes locked and the `goroutine` gets exclusive access to the critical section.
    In case the `Mutex` is in the locked state, the `goroutine` calls the `Lock` method.
    This `goroutine` is blocked and needs to wait until the `Mutex` gets unlocked
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the example, we use the `Mutex` to synchronize access on a slice
    primitive, which is considered to be unsafe for the concurrent use.
  prefs: []
  type: TYPE_NORMAL
- en: The important fact is that the `Mutex` cannot be copied after its first use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating map for concurrent access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The map primitive in Golang should be considered as unsafe for concurrent access.
    In the previous recipe, we described how to synchronize access to the resource
    with Mutex, which could also be leveraged with access to the map primitive. But
    the Go standard library also provides the map structure designed for concurrent
    access. This recipe will illustrate how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter10/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `map.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run map.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45f734cb-36b0-4b7a-85c7-e88fbef33ba4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package `sync`, contains the structure `Map` that is designed to be used
    concurrently from multiple Go routines. The `Map` struct, with its methods, mimics
    the behavior of the map primitive. The `Store` method is the equivalent of the
    `m[key] = val` statement. The `Load` method is equal to `val, ok := m[key]` and
    the  `Range` method provides the ability to iterate through the map. Note that
    the `Range` function works with the current state of `Map`, so if the values are
    changed during the running `Range` method, the changes are reflected, but only
    if the key wasn't already visited. The `Range` function visits its keys only once.
  prefs: []
  type: TYPE_NORMAL
- en: Running a code block only once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In situations when multiple goroutines run the same code and there is a code
    block that initializes, for example, shared resource, the Go standard library
    offers the solution, which will be described further.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter10/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `once.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run once.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4e9a0641-c657-405e-9403-e46cea0a4fcd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sample code illustrates the lazy loading of the data while accessing the
    container structure. As the data should be loaded only once, the `Once` struct
    from the sync package is used in the method `Pop`. The `Once` implements only
    one method called `Do` which consumes the `func` with no arguments and the function
    is executed only once per `Once` instance, during the execution.
  prefs: []
  type: TYPE_NORMAL
- en: The `Do` method calls blocks until the first run is done. This fact corresponds
    with the fact that `Once` is intended to be used for initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Pooling resources across multiple goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resource pooling is the traditional way to improve performance and save resources.
    Usually, it is worth pooling the resources with expensive initialization. The
    Go standard library provides the skeleton structure for a resource pool, which
    is considered to be safe for multiple goroutines access. This recipe describes
    how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter10/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `pool.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run pool.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b1f1b1a-910b-46ea-8e86-82980e37e096.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sync` package contains the struct for pooling the resources. The `Pool`
    struct has the `Get` and `Put` method to retrieve and put the resource back to
    the pool. The `Pool` struct is considered to be safe for concurrent access.
  prefs: []
  type: TYPE_NORMAL
- en: While creating the `Pool` struct, the `New` field needs to be set. The `New`
    field is a no-argument function that should return the pointer to the pooled item.
    This function is then called in case the new object in the pool needs to be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Note from the logs of the preceding example, that the `Worker` is reused while
    returned to the pool. The important fact is that there shouldn't be any assumption
    related to the retrieved items by `Get` and returned items to `Put` method (like
    I've put three objects to pool just now, so there will be at least three available).
    This is mainly caused by the fact that that the idle items in a `Pool` could be
    automatically removed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: The pooling of resources is usually worth it if the resource initialization
    is expensive. Still, the management of resources brings some additional cost.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing goroutines with WaitGroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working with concurrently running code branches, it is no exception that
    at some point the program needs to wait for concurrently running parts of the
    code. This recipe gives insight into how to use the `WaitGroup` to wait for running
    goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter10/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `syncgroup.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run syncgroup.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ecce87d6-6a87-44ff-a4d1-d0fcc182549d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With help of the  `WaitGroup` struct from the `sync` package, the program run
    is able to wait until some finite number of goroutines finish. The `WaitGroup`
    struct implements the method `Add` to add the number of goroutines to wait for.
    Then after the goroutine finishes,  the `Done` method should be called to decrement
    the number of goroutines to wait for. The method `Wait` is called as a block until
    the given number of `Done` calls has been done (usually at the end of a `goroutine`).
    The `WaitGroup` should be used the same way as all synchronization primitives
    within the sync package. After the creation of the object, the struct should not
    be copied.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the fastest result from multiple sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, for example, while integrating information retrieval from multiple
    sources, you only need the first result, the fastest one, and the other results
    are irrelevant after that. An example from the real world could be extracting
    the currency rate to count the price. You have multiple third-party services and
    because you need to show the prices as fast as possible, you need only the first
    rate received from any service. This recipe will show the pattern for how to achieve
    such behavior.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter10/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `first.go` with following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run first.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2011444d-0d1e-4b2b-afb4-2806dc133819.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding code proposes the solution on executing multiple tasks that output
    some results, and we need only the first fastest one. The solution uses the `Context`
    with the cancel function to call cancel once the first result is obtained. The
    `SearchSrc` structure provides the `Search` method that results in a  channel
    where the result is written. Note that the `Search` method simulates the delay
    with the `time.Sleep` function. The merge function, for each channel from the `Search`
    method, triggers the `goroutine` that writes to the final output channel that
    is read in the `main` method. While the first result is received from the output
    channel produced from the `merge` function, the `CancelFunc` stored in the variable
    `cancel` is called to cancel the rest of the processing.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that the `Search` method still needs to end, even if its result would
    not be processed; so this needs to be handled to avoid the `goroutine` and channel
    leak.
  prefs: []
  type: TYPE_NORMAL
- en: Propagating errors with errgroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show how to easily use the errgroup extension package to detect
    the error within the group of goroutines that run subtasks, within a common task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter10/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `lines.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by `go run lines.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/424e9afe-d9e4-4440-ab5a-1eba1b4e7aeb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `golang.org/x/sync/errgroup` package helps to simplify the error propagation
    and cancellation by context for goroutine groups. The `Group` contains the Go
    method which consumes the no-arg function returning the `error`. This function
    should contain the task which should be done by the executed `goroutine`. The
    `Wait` method of the `Group` from `errgroup` waits until all executed tasks from
    the Go method are complete, and if any of them are returned `err`, then the first
    non-nil error is returned. This way, it is possible to simply propagate the error
    from the group of running goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Group` is also created with the use of context. The `Context`
    serves as the mechanism to cancel other tasks, if the error occurs. After the
    `goroutine` function returns the `error` , the inner implementation cancels the
    context and so could be the running task.
  prefs: []
  type: TYPE_NORMAL
