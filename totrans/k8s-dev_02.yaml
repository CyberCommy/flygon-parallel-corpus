- en: Packaging Your Code to Run in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'n this chapter, we will dig into the first thing you need to enable to use
    Kubernetes: getting your software into a container. We will review what containers
    are, how you store and share images, and how to build a container. The chapter
    then continues with two examples, one in Python, and another in Node.js, which
    step you through how to take simple example code from those languages to build
    containers, and run them within Kubernetes. The sections of this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your own container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python example—making a container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js example—making a container image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging your container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step for using Kubernetes is getting your software into a container.
    Docker is the easiest way to create these containers, and it is a fairly simple
    process. Let''s take a moment to look at an existing container image to understand
    what choices you will need to make when creating your own containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you''ll see it pulling down a list of files with arcane IDs. You''ll
    see them updating in parallel, as it tries to grab these as they''re available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And when the downloads are complete, the output will update to say `extracting`,
    and finally `pull complete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What you saw in the Terminal was Docker downloading the layers that go into
    a container image, pulling them all together, and then verifying the output. Kubernetes
    does exactly this same process when you ask it to run the software, downloading
    the images and then running them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see (perhaps among others) the image listed akin to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The image is `211MB` in size, and you'll notice that when we specified `jocatalin/kubernetes-bootcamp:v1`,
    we were specifying both a name, `jocatalin/kubernetes-bootcamp`, and a tag, `v1`.
    In addition, the image has an `IMAGE ID` (`8fafd8af70e9`), which is a unique ID
    for the whole image. If you were to specify a name for an image without a tag,
    the default is to assume you want a default tag of `latest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a deeper look at the image we just downloaded, using the `docker
    history` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is making explicit what we saw earlier when it downloaded the container:
    that a container image is made up of layers, which build upon the ones below it.
    The layers of a Docker image are quite simple—each layer is the result of a command
    being executed and any changes that the command ended up making on the local filesystem.
    In the previous `docker history` command, you will see a size reported by any
    commands that changed the size of the underlying filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: The image format was created by Docker and is now formally specified by the
    **OCI** (**Open Container Initiative**) Image Format project. If you want to dig
    into that further, you can find the format and all relevant details at [https://github.com/opencontainers/image-spec](https://github.com/opencontainers/image-spec).
  prefs: []
  type: TYPE_NORMAL
- en: Container images, and each of the layers in the images, are typically available
    on the internet. All the examples I use in this book are publicly available. It
    is possible to configure your Kubernetes cluster to use a private image repository,
    and there's documentation at the Kubernetes project for exactly how to do that
    task, available at [https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/).
    This setup is more private, but at the cost of being more involved and complex
    to set up, so in this book, we will be sticking with publicly available images.
  prefs: []
  type: TYPE_NORMAL
- en: 'A container image also includes information on how to run the image, what to
    run, what environment variables to set, and so forth. We can see all those details
    using the `docker inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces quite a bit of content, describing the container
    image in quite a bit of detail and the metadata that goes along with running the
    code within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the base configuration, a Docker container image can also contain
    a runtime configuration, so there is often a duplicate section defining much of
    what you say under the `ContainerConfig` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last section included is an explicit list of the overlays for filesystems
    and how they fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot of information in that JSON dump, more than you probably need
    or care about right now. Most importantly, I want you to know that it specifies
    a `cmd` under the `config` section in three parts. This is what will be invoked
    by default if you `run` the container, and it is often called the `Entrypoint`.
    If you put those pieces together and imagine running them yourself in the container,
    you would be running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Entrypoint` defines what binary will get executed, and any arguments to
    it, and is the key to specify what you want to run and how you want to run it.
    Kubernetes works with this same `Entrypoint` and can override it, with commands
    and arguments to run your software, or run diagnostic tools that you have stored
    in the same container image.
  prefs: []
  type: TYPE_NORMAL
- en: Container registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, when we invoked the command to pull the container,
    we referenced [https://www.docker.com/](https://www.docker.com/), which is Docker''s
    container registry. There are two other common registries that you will see frequently
    when working with Kubernetes or reading documentation about Kubernetes: [gcr.io](https://cloud.google.com/container-registry/),
    Google''s container registry, and [quay.io](https://quay.io/), CoreOS''s container
    registry. Other companies offer hosted container registries on the internet, and
    you can run your own. Currently, Docker and Quay both offer free hosting for public
    images, so you will see those frequently in documentation and examples. All three
    registries also offer options for private image repositories, typically for a
    relatively small subscription.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of publicly available images (and layering on top of those
    images) is that it makes it very easy to compose your images, sharing underlying
    layers. This also implies that those layers can be inspected, and common layers
    searched for security vulnerabilities. There are several open source projects
    aimed at helping provide this information, and several companies have formed that
    help in coordinating the information and scanning. If you subscribe to an image
    repository for your images, they will often include this scanning for vulnerabilities
    in their product offering.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, when you use a library in your code, you are responsible for
    how it will operate. You are already responsible for being familiar with how those
    libraries work (or not), and handling any issues when they don't work as expected.
    With the flexibility and control of specifying the whole container, you are equally
    responsible for everything that gets included in the container in the same fashion.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to forget about the layers that your software is built upon, and
    you may not always have the time to track all the potential security vulnerabilities
    and issues that have arisen with the software that you are building upon. The
    security scans from projects such as Clair ([https://github.com/coreos/clair](https://github.com/coreos/clair))
    can provide you with excellent information about potential vulnerabilities. I
    recommend you consider taking advantage of a service that can provide those details
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Making your first container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a container is something easily done with the Docker software and the `docker
    build` command. This command uses a manifest that details how to create the container,
    called a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest possible container. Create a file called a Dockerfile
    and add this to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, invoke `build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then you are either missing the `.` in the command, or ran the command in a
    directory different from where you created the Dockerfile. The `.` is telling
    `docker` where to find Dockerfile (`.` meaning] in this current directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'What you should see is some output akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This image only has an ID, `f5d273aa2dcb`, not a name, but this is sufficient
    for us to see how this works. If you run this sample example locally, you will
    get a different ID that uniquely identifies the container image. You can run the
    code in the container image using the `docker run f5d273aa2dcb` command. This
    should result in you seeing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Take a moment to run `docker history f5d273aa2dcb` and `docker inspect f5d273aa2dcb`
    on the image you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done, we can delete the Docker image we just made with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get an error removing an image, which can happen if you have a stopped
    container that references the image locally, you can force the removal with the
    addition of `-f`. For example, the command that will force the removal of a local
    image would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Dockerfile commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker has documentation on how to write a Dockerfile at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/),
    and a set of best practices that they recommend at [https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/).
    We will cover some of the commands that are common and important to know for building
    your own container images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the important Dockerfile build commands that you
    should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM` ([https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from)): `FROM`
    describes the image that you are using as a base to build your container, and
    is generally the first command in a Dockerfile. Docker best practices encourage
    the use of Debian as a base Linux distribution. As you saw from my example earlier,
    I prefer to use Alpine Linux because it is very compact in size. You can also
    use Ubuntu, Fedora, and CentOS, all of which are larger images and include significantly
    more software in their base image. If you are already familiar with a distribution
    of Linux and the tools that are used with it, then I recommend you take advantage
    of that knowledge for making your first containers. You can also frequently find
    containers built specifically to support the language you''re using, such as Node
    or Python. At the time of writing (fall 2017), I downloaded a variety of these
    images to show the relative sizes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the images vary considerably in size.
  prefs: []
  type: TYPE_NORMAL
- en: You can explore these (and a wide variety of other base images) at [https://hub.docker.com/explore/](https://hub.docker.com/explore/).
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN` ([https://docs.docker.com/engine/reference/builder/#run](https://docs.docker.com/engine/reference/builder/#run)): `RUN`
    describes commands that you run within the container image that you''re building,
    most frequently used for adding in dependencies or other libraries. If you look
    at Dockerfiles created by others, you''ll often see the `RUN` command used to
    install libraries using commands such as `apt-get install ...` or `rpm -ivh ...`.
    The commands that are used are specific to the choice of base image; `apt-get`,
    for example, is available on Debian and Ubuntu base images, but not on Alpine
    or Fedora. If you put in a `RUN` command that''s not available (or just has a
    typo), then when you''re running the `docker build` command you''ll see an error.
    As an example, when building the Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/bin/sh -c apt-get install nodejs` command returned a non-zero code: `127`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV` ([https://docs.docker.com/engine/reference/builder/#env](https://docs.docker.com/engine/reference/builder/#env)): `ENV`
    defines environment variables that will persist and be set prior to invoking your
    software in the container image. These are also set while creating the container
    image, which may cause surprising effects. If you need an environment variable
    set for a specific `RUN` command, for example, it is probably better to define
    it with a single `RUN` command rather than using the `ENV` command. For example,
    using `ENV DEBIAN_FRONTEND` non-interactive may confuse using a later `RUN apt-get
    install …` command on a Debian-based image. In the case where you want to enable
    that for a specific `RUN` command, you can do so by temporarily adding the environment
    variable in front of the single `RUN` command. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`COPY` ([https://docs.docker.com/engine/reference/builder/#copy](https://docs.docker.com/engine/reference/builder/#copy)): `COPY`
    (or the `ADD` command) is how you add your own local files into the container.
    This is often the most effective way to copy your code into the container image
    to run. You can copy an entire directory, or a single file. Along with the `RUN`
    command, this is likely going to be how you do most of the work of creating a
    container image with your code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WORKDIR` ([https://docs.docker.com/engine/reference/builder/#workdir](https://docs.docker.com/engine/reference/builder/#workdir)): `WORKDIR`
    makes a local directory and then makes that directory the base for all further
    commands (`RUN`, `COPY`, and so on). It can be extraordinarily convenient for
    `RUN` commands that expect to be run from a local or relative directory, such
    as installation tools such as Node.js `npm`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LABEL` ([https://docs.docker.com/engine/reference/builder/#label](https://docs.docker.com/engine/reference/builder/#label)): `LABEL`
    adds values that are visible to `docker inspect` and are generally used as references
    for who is responsible or what is within a container. The `MAINTAINER` command
    was very common earlier, but it has been replaced with the `LABEL` command. Labels
    are built on base images and are additive, so any labels you add will be included
    with labels from a base image you''re using.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CMD` ([https://docs.docker.com/engine/reference/builder/#cmd](https://docs.docker.com/engine/reference/builder/#cmd))
    and `ENTRYPOINT `([https://docs.docker.com/engine/reference/builder/#entrypoint](https://docs.docker.com/engine/reference/builder/#entrypoint)): `CMD`
    (and the `ENTRYPOINT` command) is how you specify what to run when someone runs
    your container. The most common format is a JSON array, where the first element
    is the command to be invoked, and the second and later elements are arguments
    to that command. `CMD` and `ENTRYPOINT` were made to be used either individually,
    in which case you use either `CMD` or `ENTRYPOINT` to specify the executable to
    run and all arguments, or together, in which case `ENTRYPOINT` should be just
    the executable and `CMD` should be the arguments for that executable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Example – Python/Flask container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To walk through the details of how to use Kubernetes, I have created two sample
    applications that you can download, or replicate to follow along and try out these
    commands. The first of these is a very simple Python application using the Flask
    library. The sample application is directly from the Flask documentation ([http://flask.pocoo.org/docs/0.12/](http://flask.pocoo.org/docs/0.12/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download a copy of this code from GitHub at [https://github.com/kubernetes-for-developers/kfd-flask/tree/first_container](https://github.com/kubernetes-for-developers/kfd-flask/tree/first_container).
    Since we will evolve these files, the code referenced here is available at the `first_container`
    tag. If you want to use Git to get these files, you can run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go into the repository and check out the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with looking at the contents of a Dockerfile, which define what
    gets built into a container and how that happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goals we have for creating this Dockerfile are:'
  prefs: []
  type: TYPE_NORMAL
- en: Get and install any security patches for the underlying operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the language or runtime that we need to use to run our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install any dependencies for our code that are not included directly in our
    source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy our code into the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define how and what to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This container is based on Alpine Linux. I appreciate the small size of the
    containers, and there is less extraneous software residing in the container. You
    will see several commands that may not be familiar, specifically the `apk` command.
    This is the command-line tool that helps install, update, and remove Alpine Linux
    packages. These commands update the package repository, upgrade all installed
    and pre-existing packages in the image, and then install Python 3 from packages.
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with Debian commands (such as `apt-get`) or Fedora/CentOS
    commands (such as `rpm`), then I recommend you use those base Linux containers
    for your own work.
  prefs: []
  type: TYPE_NORMAL
- en: The next two commands make a directory on the container at `/opt/exampleapp`
    to house our source code and copy it all into place. The `COPY` command adds everything
    from the local directory into the container, which is probably more than we need.
    You can create a file called `.dockerignore` in the future that will `ignore`
    a set of files based on patterns so that some common files that we don't want
    to be included will be ignored in the `COPY` command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll see a `RUN` command that installs the application dependencies,
    in this case from the file `requirements.txt`, which is included in the source
    repository. It is good practice to maintain your dependencies in a file like this,
    and the `pip` command was made to support doing exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: The last two commands leverage `ENTRYPOINT` and `CMD` separately. For this simple
    example, I could have used just one or the other. Both are included to show how
    they can be used together, the `CMD` being essentially arguments passed to the
    executable defined in `ENTRYPOINT`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `docker build` command to create the container. In a Terminal
    window, change into the directory with the Dockerfile and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Each step in the Dockerfile will be reflected by output of what''s happening
    when Docker is building the image at that step, and with more complex Dockerfiles,
    the output can be quite extensive. As it finishes its build process, it will report
    an overall success or failure, and will also report the container IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When we build the container without any other information, it makes an image
    locally that we can play with (it has an ID), but it doesn't have a name or a
    tag. When you are choosing a name, you will generally want to consider where you
    are hosting your container images. In this case, I am using CoreOS's Quay.io service,
    which offers free hosting for open source container images.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tag the image that we just created, we can use the `docker tag` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This tag contains three relevant parts. The first [quay.io](http://quay.io)
    is the container registry. The second (`kubernetes-for-developers`) is the namespace
    for your container, and the third (`flask`) is the name of the container. We did
    not specify any specific tag for the container, so the `docker` command will use
    the latest.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use tags for releases or other points in time in your development
    that you want to be able to jump back to easily and leverage latest to represent
    your most recent development work, so let''s also tag this as a specific version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When you share an image with someone else, it is a very good idea to be explicit
    about which image you are working with. As a general rule, consider only using
    the code yourself, and whenever you share the image with any other people, use
    an explicit tag. The tag does not have to be a version, and although there are
    limits on its format, it can be nearly any string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the `docker push` command to transfer the image to the container repository
    once it''s been tagged. You will need to log in to your container repository first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you can push the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The push refers to a repository, `[quay.io/kubernetes-for-developers/flask]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You will generally want to build your container with a tag from the start,
    rather than having to do the additional commands. To do that, you can add the
    tag information with the `-t <your_name>` option to the `build` command. For the
    examples in this book, I am using the name `kubernetes-for-developers`, so the
    command I have been using to build the example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are following along with this example, use your own value where the
    preceding command has `quay.io/kubernetes-for-developers/flask .`. You should
    see output that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Take a moment to read through that output, and notice that in several places
    it reports `Using cache`. You may have also noticed that the command was faster
    than the first time you built the image.
  prefs: []
  type: TYPE_NORMAL
- en: That is because Docker attempts to reuse any layers that haven't changed so
    that it doesn't have to recreate that work. Since we just did all of those commands,
    it can use the layers from the cache it made while creating the previous image.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `docker images` command, you should now see it listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you continue with using container images to house and deploy your code,
    you will likely want to automate the process of creating the images. As a general
    pattern, a good build process would be:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the code from source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker build`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker tag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker push`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the process we are using in these examples, and you can automate these
    commands with whatever tooling is most comfortable for you. I recommend you set
    up something that can be run on a command line quickly and consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Running your container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s run the container we just made. We will use the `kubectl run` command
    to specify the simplest deployment—just the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what this is doing, we need to ask the cluster for the current state
    of the resources we just created. When we use the `kubectl run` command, it will
    implicitly create a Deployment resource for us, and as you learned in the last
    chapter, a Deployment has a ReplicaSet within it, and a Pod within the ReplicaSet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get details on this deployment by asking for the raw data associated
    with the Kubernetes deployment resource `flask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We could just as easily request the information in `YAML` format, or query
    a subset of these details leveraging JsonPath or the other capabilities of the
    `kubectl` command. The JSON output will be extensive. It will start with a key
    indicating apiVersion from Kubernetes, the kind of resource, and metadata about
    the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Beneath this is usually the specification of the deployment itself, which has
    a lot of the core of what is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And the last part is usually the status, which indicates the current state
    of the deployment, as of the time you made the request for the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that when a Pod runs in Kubernetes, it is running in a sandbox, isolated
    from the rest of the world. Kubernetes does this intentionally, so you can specify
    how Pods are supposed to be connected and what can be accessed from outside the
    cluster. We will cover how to set up external access in a later chapter. In the
    meantime, you can leverage one of two commands with `kubectl` to get direct access
    from your development machine: `kubectl port-forward` or `kubectl proxy`.'
  prefs: []
  type: TYPE_NORMAL
- en: These commands both work by making proxies from your local development machine
    into the Kubernetes cluster, providing you private and personal access to your
    running code. The `port-forward` command will open a specific TCP (or UDP) port
    and arrange all traffic to forward to your Pod in the cluster. The proxy command
    uses an HTTP proxy that already exists to forward HTTP traffic in and out of your
    Pod. Both of these commands rely on knowing the Pod name to make the connections.
  prefs: []
  type: TYPE_NORMAL
- en: Pod name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are working with a web server, using a proxy would make the most sense,
    as it will forward HTTP traffic through a URL based on the name of the Pod. Before
    we do that, we will use the `port-forward` command, which will be more relevant
    if what you're writing doesn't use the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key thing you will need is the name of the Pod that was created. When we
    ran `kubectl get pods` earlier, you probably noticed that the name wasn''t just
    `flask`, but included some additional characters in the name: `flask-1599974757-b68pw`.
    When we invoked `kubectl run`, it created a deployment, which consists of a Kubernetes
    ReplicaSet wrapped around a Pod. The first part of the name (`flask`) is from
    the deployment, the second part (`1599974757`) is the unique name assigned to
    the ReplicaSet that was created, and the third part (`b68pw`) is the unique name
    assigned to the Pod that was created. If you run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will show you the replicasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the ReplicaSet name is the first two parts of the Pod's name.
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can use that name to ask `kubectl` to set up a proxy that will forward
    all traffic from a local port we specify to a port associated with the Pod we
    determine. Get the full name of the Pod that was created with your deployment
    by looking at the Pods using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In my example, the result was `flask-1599974757-b68pw`, which can then be used
    with the `port-forward` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This is forwarding any and all traffic that gets created on your local machine
    at TCP port `5000` to TCP port `5000` on the Pod `flask-1599974757-b68pw`.
  prefs: []
  type: TYPE_NORMAL
- en: You will note that you don't have a Command Prompt back yet, which is because
    the command is actively running to keep this particular tunnel we've requested
    alive. If we cancel or quit the `kubectl` command, typically by pressing *Ctrl*
    + C, then port forwarding will immediately end. `kubectl proxy` works in the same
    fashion, so when you use commands such as `kubectl port-forward` or `kubectl proxy`,
    you will probably want to open another Terminal window to run that command in
    by itself.
  prefs: []
  type: TYPE_NORMAL
- en: While the command is still running, open a browser and put in this URL: `http://localhost:5000`.
    The response should come back that says `Index Page`. When we invoked the `kubectl
    run` command, I specifically choose port `5000` to match the default from Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other command you can use to access your Pod is the `kubectl proxy` command.
    The proxy provides access not only to your Pod, but to all of the Kubernetes APIs
    as well. To invoke the proxy, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output will show something akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Like the `port-forward` command, you won't get a prompt back in the Terminal
    window until the proxy terminates. While it is active, you can access Kubernetes
    REST API endpoints through this proxy. Open a browser and enter the URL `http://localhost:8001/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a long list of URLs in JSON format, something akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'These are accessing the Kubernetes infrastructure directly. One of those URL''s
    is `/api/v1` - and although it wasn''t listed specifically, it uses the Kubernetes
    API server to provide a proxy to Pods based on the name. When we invoked our `run`
    command, we didn''t specify a namespace, so it used the default, which is called
    `default`. The URL pattern to see a Pod is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8001/api/v1/proxy/namespaces/<NAME_OF_NAMESPACE>/pods/<POD_NAME>/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the case of our Pod, this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8001/api/v1/proxy/namespaces/default/pods/flask-1599974757-b68pw/`'
  prefs: []
  type: TYPE_NORMAL
- en: If you open a URL in your browser created with the Pod name that your Kubernetes
    cluster assigned, it should show you the same output that you saw using the `port-forward`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: How did the proxy know to connect to port 5000 on the container?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you ran a container, Kubernetes did not magically know what TCP ports
    your code is listening on. When we created this deployment using the `kubectl
    run` command, we added the `--port=5000` option at the end of that command. That
    was used by Kubernetes to know that the program should be listening on port `5000`
    for HTTP traffic. If you look back at the output from the `kubectl get deployment
    -o json` command, you will see a section in there under the key containers that
    includes the image we provided, the name of the deployment, and a data structure
    indicating a default port for accessing the container: `5000`. If we had not provided
    the additional details, the proxy would have assumed we wanted to access the container
    at port `80`. Since nothing is running on port `80` with our development container,
    you would have seen an error akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Getting logs from your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are more ways to interact with your code running in the container, which
    we'll cover in a future chapter. If the code you run does not listen on a TCP
    socket to provide HTTP traffic, or something equivalent, then you generally want
    to see the output that your code created to know that it's running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Containers are specifically set up to capture any output to STDOUT and STDERR
    from the executable you''ve specified and capture that into logs, which can be
    retrieved with another `kubectl` command: `kubectl logs`. Like the `proxy` and
    `port-forward` commands, this command needs to know the name of the Pod you want
    to interact with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And you should see some output akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Example – Node.js/Express container image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example follows the same pattern as the Python example, a simple Node.js
    application built with the Express library to walk through the details of how
    to use Kubernetes. If you are more familiar with JavaScript development, this
    example may be more meaningful. The sample application is directly from the Express
    documentation ([https://expressjs.com/en/starter/generator.html](http://flask.pocoo.org/docs/0.12/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get a download a copy of this code from GitHub at [https://github.com/kubernetes-for-developers/kfd-nodejs/tree/first_container](https://github.com/kubernetes-for-developers/kfd-nodejs/tree/first_container).
    Since we will evolve these files, the code referenced here is available at the `first_container` tag.
    If you want to use Git to retrieve these files, you can do so using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the Python example, we will start with the Dockerfile. As a reminder,
    this is what defines what gets built into a container, and how it happens. The
    goals of this Dockerfile are:'
  prefs: []
  type: TYPE_NORMAL
- en: Get and install any critical security patches for the underlying operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the language or runtime that we'll need to use to run our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install any dependencies for our code that aren't included directly in our source
    control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy our code into the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define how and what to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Like the Python example, this container is based on Alpine Linux. You will see
    several commands that may not be familiar, specifically the `apk` command. As
    a reminder, this command is used to install, update, and remove Alpine Linux packages.
    These commands update the Alpine package repository, upgrade all installed and
    pre-existing packages in the image, and then install `nodejs` and `npm` from packages.
    Those steps basically bring us to a minimal container that can run a Node.js application.
  prefs: []
  type: TYPE_NORMAL
- en: The next commands make a directory in the container at `/src` to house our source
    code, copy in the `package.json` file, and then use `npm` to install the dependencies
    for running the code. The `--production` option used with the `npm install` command
    installs only those items listed in `package.json` that are needed for running
    the code - development dependencies are excluded. Node.js makes it easy and consistent
    to maintain your dependencies with its `package.json` format, and it is good practice
    to separate out dependencies needed in production from those needed in development.
  prefs: []
  type: TYPE_NORMAL
- en: The last two commands leverage `ENV` and `CMD`. This differs from the Python
    example where I used `CMD` and `ENTRYPOINT` to highlight how they work together.
    In this example, I use the `ENV` command to set the `DEBUG` environment variable
    to match the example instructions in the Express documentation. `CMD` then contains
    a command to start our code, which simply leverages `npm` to run the command defined
    in `package.json`, and uses the earlier `WORKDIR` command to set the local directory
    for that invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Building the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the same `docker build` command to create the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw with the Python-based example, every step in the Dockerfile is reflected
    with output showing you what happened as Docker was building the container image
    based on your instructions (the Dockerfile):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the Python example, this builds a container with only an ID. This example
    also leverages Quay for hosting the images publicly, so we will take the image
    appropriately so we can upload it to Quay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the Python example, the tag contains three relevant parts - [quay.io](http://quay.io)
    is the container registry. The second (`kubernetes-for-developers`) is the namespace
    for your containers, and the third (`nodejs`) is the name of the container. The
    same commands as the Python example are used to upload the container, referencing
    `nodejs` instead of `flask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And when it is complete, you should see something akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the Python example, you may want to build and tag in the same command.
    For the Node.js example, that command would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This, if run immediately after you built the image, should display output that
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Again, it will be significantly faster as it was using Docker's cache of the
    image layers that were previously built.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the `docker images` command, you should now see it listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you are pushing your own images to `quay.io` as a container repository, you
    may need to log in to the website and make the images public in addition to these
    commands. By default, `quay.io` will keep images private, even the public ones,
    until you approve their exposure on their website.
  prefs: []
  type: TYPE_NORMAL
- en: Running your container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s run the container we just made. We will use the `kubectl run` command
    as with the Python example, but replacing flask with `nodejs` to specify the container
    we just made and uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what it''s doing, we need to ask the cluster for the current state of
    the resources we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kubectl run` command works regardless of the language, and in the same
    fashion as the Python example. The simple deployment created in this case is named
    `nodejs`, and we can request the same kinds of information about it that we did
    with the Python example earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON output should will be fairly extensive, and will have multiple sections.
    At the top of the output will be `apiVersion`, `kind`, and `metadata` about the
    deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, underneath that will be `spec`, which has a lot of the core of what
    you''re just asked to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And the final section is `status`, which indicates the current state (as of
    the request for this information) of the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When a Pod runs in Kubernetes, it is running in a sandbox, isolated from the
    rest of the world. Kubernetes does this intentionally, so you can specify what
    systems can communicate with each other, and what can be accessed from outside.
    For most clusters, the defaults for Kubernetes allow any Pod to communicate with
    any other Pod.  Just like the Python example, you can leverage one of two commands
    with `kubectl` to get direct access from your development machine: `kubectl` port-forward
    or `kubectl` proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can use that name to ask `kubectl` to set up a proxy that will forward
    all traffic from a local port we specify to a port associated with the Pod we
    determine. The Node.js example runs on a different port than the Python example
    (port `3000` instead of port `5000`), so the command needs to be updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This is forwarding any and all traffic that gets created on your local machine
    at TCP port `3000` to TCP port `3000` on the `nodejs-568183341-2bw5v` Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the Python example, you don't get a Command Prompt back yet because
    the command is actively running to keep this particular tunnel alive. As a reminder,
    you can cancel or quit the `kubectl` command by pressing *Ctrl* + *C* and port
    forwarding will immediately end.
  prefs: []
  type: TYPE_NORMAL
- en: While the command is still running, open a browser and put in this URL: `http://localhost:3000`.
    The response should come back that says, `Index Page`. When we invoked the `kubectl
    run` command, I specifically choose port `3000` to match the default from Express.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this is an HTTP-based application, we can also use the `kubectl proxy`
    command to get access to the responses from our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output will show something akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reminder, you won''t get a prompt back in the Terminal window until the
    proxy terminates. Just as with the Python example, we can determine the URL to
    use that the proxy will use to forward to our container based on the Pod name
    and the namespace that we used when invoking the `kubectl run` command. Since
    we did not specify a namespace, it used the default, which is called `default`.
    The URL pattern for accessing the Pod is the same as the Python example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8001/api/v1/proxy/namespaces/<NAME_OF_NAMESPACE>/pods/<POD_NAME>/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And in the case of our Pod, this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8001/api/v1/proxy/namespaces/default/pods/nodejs-568183341-2bw5v/`'
  prefs: []
  type: TYPE_NORMAL
- en: If you open a URL in your browser created with the Pod name that your Kubernetes
    cluster assigned, it should show you the same output that you saw using the `port-forward`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting logs from your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like the Python example, the Node.js example sends some output to `STDOUT`.
    As the containers are specifically set up to capture any output to `STDOUT` and
    `STDERR` from the executable you''ve specified and capture that into logs, the
    same commands will work to show you the log output from the Node.js application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show you output akin to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Tagging your container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the `:latest` tag on Docker images is incredibly convenient, but it can
    easily lead to confusion as to what exactly is running. If you do use `:latest`,
    then it is a very good idea to also tell Kubernetes to always attempt to pull
    a new image when loading the container. We will see how to set this in [Chapter
    4](a210420d-4d80-43c1-9acb-531bc6b19b75.xhtml), *Declarative Infrastructure*,when
    we talk about declaratively defining our applications.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to make explicit tags, building with a tag, and also using
    `docker tag` to tag the image as `latest` for the convenience factor, but maintaining
    specific tags within the declarations that you check in to source control. For
    this example, the tag chosen is `0.2.0`, using semantic versioning to represent
    a value to use with the container, and matched to a `git tag` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps that were used while making this example were:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed what makes up a container, how to store and share
    containers on the internet, and some of the commands you can use to create your
    own containers. We then used that knowledge to walk through an example in Python
    and another in Node.js, creating simple web-based services in both, building those
    into container images, and running them within Kubernetes. In our next chapter,
    we will dive deeper into how to interact with your code once it's been packaged
    into a container and will explore tips for taking full advantage of containers
    and Kubernetes during your development.
  prefs: []
  type: TYPE_NORMAL
