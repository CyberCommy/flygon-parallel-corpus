- en: Templates and Commonly-Used Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 7](9c9ba953-362d-4409-b6d5-3a3361238bce.xhtml), *Dynamic Memory
    Allocation*, we spoke about how you would use dynamic memory allocation if you
    want to create a new array whose size isn't known at compile time. Dynamic memory
    allocations are of the form `int * array = new int[ number_of_elements ]`.
  prefs: []
  type: TYPE_NORMAL
- en: You also saw that dynamic allocations using the `new[]` keyword require you
    to call `delete[]` on the array later, otherwise you'd have a memory leak. Having
    to manage memory this way is hard work.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a way to create an array of a dynamic size and have the memory automatically
    managed for you by C++? The answer is yes. There are C++ object types (commonly
    called containers) that handle dynamic memory allocations and deallocations automatically.
    UE4 provides a couple of container types to store your data in dynamically resizable
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: There are two different groups of template containers. There is the UE4 family
    of containers (beginning with `T*`) and the C++ **Standard Template Library**
    (**STL**) family of containers. There are some differences between the UE4 containers
    and the C++ STL containers, but the differences are not major. UE4 container sets
    are written with game performance in mind. C++ STL containers also perform well,
    and their interfaces are a little more consistent (consistency in an API is something
    that you'd prefer). Which container set you use is up to you. However, it is recommended
    that you use the UE4 container set since it guarantees that you won't have cross-platform
    issues when you try to compile your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the output in UE4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates and containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UE4's TArray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TSet and TMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ STL versions of commonly-used containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging the output in UE4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the code in this chapter (as well as in the later chapters) will require
    you to work in a UE4 project. For the purpose of testing `TArray`, I created a
    basic code project called `TArrays`. In the `ATArraysGameMode::ATArraysGameMode`
    constructor, I am using the debug output feature to print text to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the code in `TArraysGameMode.cpp` will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure you also add the function to the `.h` file. If you compile and run
    this project, you will see the debug text in the top-left corner of your game
    window when you start the game. You can use debug output to see the internals
    of your program at any time. Just make sure that the `GEngine` object exists at
    the time of debugging the output. The output of the preceding code is shown in
    the following screenshot (note that you may need to run it as a standalone game
    to see it):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8c01c25-6466-44de-bba4-a0db06c1f05d.png)'
  prefs: []
  type: TYPE_IMG
- en: Templates and containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are a special type of object. A template object lets you specify what
    type of data it should expect. For example, as you'll see soon, you could run
    a `TArray<T>` variable. This is an example of a template.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what a `TArray<T>` variable is, you first have to know what the
    `<T>` option between the angle brackets stands for. The `<T>` option means that
    the type of data stored in the array is a variable. Do you want an array of `int`?
    Then create a `TArray<int>` variable. A `TArray` variable of `double`? Create
    a `TArray<double>` variable.
  prefs: []
  type: TYPE_NORMAL
- en: So in general, wherever `<T>` appears, you can plug in a C++ data type of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Containers are different structures that are meant for storing objects. Templates
    are particularly useful for these because they can be used to store many different
    types of objects. You may want to store numbers with int or float, strings, or
    different types of game objects. Imagine if you had to write a new class for every
    type of object you want to store. Fortunately, you don't have to. Templates let
    one class be flexible enough to handle any objects you want to store in it.
  prefs: []
  type: TYPE_NORMAL
- en: Your first template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating templates is an advanced topic, and you could go years without having
    to create your own (although you'll use the standard ones all the time). But it
    can be helpful to see what one looks like just to help you understand what's going
    on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you want to create a number template that will let you use an int,
    float, or another type. You can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first section is the class itself. As you can see, you want to use the type
    anywhere in the template, you make the class and you will use `T` instead of specifying
    a particular type. You can also use templates to specify the values sent to functions.
    In this case, the final section lets you add another number and return the sum.
  prefs: []
  type: TYPE_NORMAL
- en: You can even make things simpler by overloading the + operator so you can add
    these numbers like you would any standard type. That's through something called
    operator overloading.
  prefs: []
  type: TYPE_NORMAL
- en: UE4's TArray<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TArrays are UE4's Version of a dynamic array, built using templates. Like other
    dynamic arrays we discussed, you don't have to worry about managing the array
    size yourself. Let's move on and look at this with an example.
  prefs: []
  type: TYPE_NORMAL
- en: An example that uses TArray<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `TArray<int>` variable is just an array of `int`. A `TArray<Player*>` variable
    will be an array of `Player*` pointers. An array is dynamically resizable, and
    elements can be added at the end of the array after its creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `TArray<int>` variable, all you have to do is use the normal variable
    allocation syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Changes to the `TArray` variable are done using member functions. There are
    a couple of member functions that you can use on a `TArray` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first member function that you need to know about is how you add a value
    to the array, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These four lines of code will produce the array value in memory, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f29a440-73b4-4596-9a09-342c3fad4a2e.png)'
  prefs: []
  type: TYPE_IMG
- en: When you call `array.Add( number )`, the new number goes to the end of the array.
    Since we added the numbers **1**, **10**, **5**, and **20** to the array, in this
    order, that is the order in which they will go into the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to insert a number in the front or middle of the array, this is
    also possible. All you have to do is use the `array.Insert(value, index)` function,
    as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will push the number `9` into position `0` of the array (at the
    front). This means that the rest of the array elements will be offset to the right,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53088c53-3664-4a96-9f42-6fa30b9713f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can insert another element into position `2` of the array using the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will rearrange the array, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b989010-02d1-4356-8a5e-e5bca807c402.png)'
  prefs: []
  type: TYPE_IMG
- en: If you insert a number into a position in the array that is out of bounds (it
    doesn't exist), UE4 will crash. So, be careful not to do that. You can use `Add`
    to add a new item instead.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating a TArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can iterate (walk over) the elements of a `TArray` variable in two ways:
    using integer-based indexing or using an iterator. I will show you both ways here.'
  prefs: []
  type: TYPE_NORMAL
- en: The vanilla-for-loop-and-square-brackets notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using integers to index the elements of an array is sometimes called a vanilla `for`
    loop. The elements of the array can be accessed using `array[ index ]`, where
    `index` is the numerical position of the element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also use an iterator to walk over the elements of the array one by
    one, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterators are pointers into the array. Iterators can be used to inspect or
    change values inside the array. An example of an iterator is shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47aabe5d-01fc-4220-9f22-726d1d5595db.png)'
  prefs: []
  type: TYPE_IMG
- en: An iterator is an external object that can look into and inspect the values
    of an array. Doing `++it` moves the iterator to examine the next element.
  prefs: []
  type: TYPE_NORMAL
- en: An iterator must be suitable for the collection it is walking through. To walk
    through a `TArray<int>` variable, you need a `TArray<int>::TIterator` type iterator.
  prefs: []
  type: TYPE_NORMAL
- en: We use `*` to look at the value behind an iterator. In the preceding code, we
    used `(*it)` to get the integer value from the iterator. This is called dereferencing.
    To dereference an iterator means to look at its value.
  prefs: []
  type: TYPE_NORMAL
- en: The `++it` operation that happens at the end of each iteration of the `for`
    loop increments the iterator, moving it on to point to the next element in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the code into the program and try it out now. Here''s the example program
    we have created so far using `TArray` (all in the `ATArraysGameMode::ATArraysGameMode()`
    constructor):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/657541c8-f2fd-4aa0-ba33-285189680049.png)'
  prefs: []
  type: TYPE_IMG
- en: Determining whether an element is in the TArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Searching our UE4 containers is easy. It is commonly done using the `Find`
    member function. Using the array we created previously, we can find the index
    of the value of `10` by typing the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: TSet<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `TSet<int>` variable stores a set of integers. A `TSet<FString>` variable
    stores a set of strings. The main difference between `TSet` and `TArray` is that
    `TSet` does not allow duplicates; all the elements inside a `TSet` are guaranteed
    to be unique. A `TArray` variable doesn't mind duplicates of the same elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add numbers to `TSet`, simply call `Add`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `TSet` will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/740b0648-f23d-4b33-887c-c11c86a96683.png)'
  prefs: []
  type: TYPE_IMG
- en: Duplicate entries of the same value in  `TSet` will not be allowed. Notice how
    the entries in a `TSet` aren't numbered, as they were in a `TArray`; you can't
    use square brackets to access an entry in `TSet` arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating a TSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to look into a `TSet` array, you must use an iterator. You can''t
    use the square brackets notation to access the elements of a `TSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Intersecting TSet arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `TSet` array has two special functions that the `TArray` variable does
    not. The intersection of two `TSet` arrays is basically the elements they have
    in common. If we have two `TSet` arrays, such as `X` and `Y`, and we intersect
    them, the result will be a third, new `TSet` array that contains only the elements
    common between them. Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The common elements between `X` and `Y` will then just be the element `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Unioning TSet arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematically, the union of two sets is when you basically insert all the elements
    into the same set. Since we are talking about sets here, there won't be any duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take the `X` and `Y` sets from the previous example and create a union,
    we will get a new set, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finding in TSet arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can determine whether an element is inside a `TSet` or not by using the
    `Find()` member function on the set. `TSet` will return a pointer to the entry
    in the `TSet` that matches your query if the element exists in the `TSet`, or
    it will return `NULL` if the element you're asking for does not exist in the `TSet`.
  prefs: []
  type: TYPE_NORMAL
- en: TMap<T,S>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TMap<T,S>` creates a table of sorts in the RAM. `TMap` represents a mapping
    of the keys at the left to the values on the right-hand side. You can visualize
    `TMap` as a two-column table, with keys in the left column and values in the right
    column.'
  prefs: []
  type: TYPE_NORMAL
- en: A list of items for the player's inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For example, say we wanted to create a C++ data structure in order to store
    a list of items for the player''s inventory. On the left-hand side of the table
    (the keys), we''d have `FString` for the item''s name. On the right-hand side
    (the values), we''d have an `int` for the quantity of that item, as shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Item (key) | Quantity (value) |'
  prefs: []
  type: TYPE_TB
- en: '| `apples` | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `donuts` | `12` |'
  prefs: []
  type: TYPE_TB
- en: '| `swords` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `shields` | `2` |'
  prefs: []
  type: TYPE_TB
- en: 'To do this in code, we''d simply use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you have created your `TMap`, you can access values inside the `TMap` using
    square brackets and by passing a key between the brackets. For example, in the
    `items` map in the preceding code, `items[ "apples" ]` is `4`.
  prefs: []
  type: TYPE_NORMAL
- en: UE4 will crash if you use square brackets to access a key that doesn't exist
    in the map yet, so be careful! The C++ STL does not crash if you do this.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating a TMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to iterate a `TMap`, you use an iterator as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`TMap` iterators are slightly different from `TArray` or `TSet` iterators.
    A `TMap` iterator contains both a `Key` and a `Value`. We can access the key with
    `it->Key` and the value inside the `TMap` with `it->Value`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f66537a-711e-4291-aae6-4fa91483e851.png)'
  prefs: []
  type: TYPE_IMG
- en: TLinkedList/TDoubleLinkedList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work with a TArray, each item has an index in numerical order, and
    array data is generally stored the same way, so each entry is right next to the
    one before it in memory too. But what if you need to put a new item somewhere
    in the middle (for example, if the array is filled with strings in alphabetical
    order)?
  prefs: []
  type: TYPE_NORMAL
- en: Since the items are next to each other, the one next to it will have to be moved
    over to make room. But to do that, the one next to that will also have to be moved
    over. This will continue until the end of the array, when it finally gets to memory
    it can use without moving something else. As you might imagine, this could get
    very slow, especially if you're doing it a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where linked lists come in. A linked list doesn''t have any indices.
    A linked list has nodes that contain the items and give you access to the first
    node on the list. That node has a pointer to the next node on the list, which
    you can get by calling `Next()`. Then, you can call `Next()` on that one to get
    the one after it. It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1ab445b-147b-4ff9-8f86-bbf2bdcc9859.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you might guess, this could get slow if you''re looking for an item at the
    end of the list. But at the same time, you might not be searching the list that
    often, and might instead be adding new items somewhere in the middle. Adding an
    item in the middle is a lot faster. Say you''re trying to insert a new node between
    **Node 1** and **Node 2**, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edb6efd2-6025-4a81-b93c-aaf3f7fecc5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s no need to move things around in memory to make room this time. Instead,
    to insert an item after another one, get the node that `Next()` points to from
    **Node 1** (**Node 2**). Set the new node to point to that one (**Node 2**). Then,
    set Node 1 to point to the new node. It should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7286df8d-4f4e-498c-be18-19b9bb7fac08.png)'
  prefs: []
  type: TYPE_IMG
- en: And you're done!
  prefs: []
  type: TYPE_NORMAL
- en: So what if you are going to be spending more time looking for items toward the
    end of the list? That is where `TDoubleLinkedList` comes in handy. Doubly-linked
    lists can give you either the first node in the list or the last node in the list.
    Each node also has pointers to both the next node and the previous node. You can
    access these using `GetNextLink()` and `GetPrevLink()`. So, you have the choice
    to go forward or backward through the list, or even to do both and meet in the
    middle.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you may ask yourself, *"Why does it matter when I can just use TArray and
    not worry about what it's doing behind the scenes?"* For one thing, professional
    game programmers always have to worry about speed. Every advance in computers
    and game consoles is matched by more and better graphics, and other advances that
    slow things right back down again. So, optimizing speed is always important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plus, there''s the other practical reason: I can tell you from experience that
    there are people in this industry who will turn you down in job interviews if
    you don''t use linked lists. Programmers all have their own preferred ways of
    doing things, so you should always be familiar with anything that might come up.'
  prefs: []
  type: TYPE_NORMAL
- en: C++ STL versions of commonly-used containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll cover the C++ STL versions of a few containers. STL is the standard
    template library, which is shipped with most C++ compilers. The reason why I want
    to cover these STL versions is that they behave somewhat differently than the
    UE4 versions of the same containers. In some ways, their behavior is very good,
    but game programmers often complain of STL having performance issues. In particular,
    I want to cover STL's `set` and `map` containers, but I will also cover the commonly-used
    `vector`.
  prefs: []
  type: TYPE_NORMAL
- en: If you like STL's interface but want better performance, there is a well-known
    reimplementation of the STL library by Electronic Arts called EASTL, which you
    can use. It provides the same functionality as STL but is implemented with better
    performance (basically by doing things such as eliminating bounds checking). It
    is available on GitHub at [https://github.com/paulhodge/EASTL](https://github.com/paulhodge/EASTL).
  prefs: []
  type: TYPE_NORMAL
- en: The C++ STL set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A C++ set is a bunch of items that are unique and sorted. The good feature about
    the STL `set` is that it keeps the set elements sorted. A quick and dirty way
    to sort a bunch of values is actually to just shove them into the same `set`.
    The `set` will take care of the sorting for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can return to a simple C++ console application for the use of sets. To use
    the C++ STL set, you need to include `<set>`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The duplicate `7` is filtered out, and the elements are kept in increasing order
    inside the `set`. The way we iterate over the elements of an STL container is
    similar to UE4's `TSet` array. The `intSet.begin()` function returns an iterator
    that points to the head of `intSet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The condition to stop iterating is when it becomes `intSet.end()`. `intSet.end()`
    is actually one position past the end of the `set`, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2143e060-1cc8-4ded-a163-8a2aca5fb9be.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding an element in a <set>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find an element inside an STL `set`, we can use the `find()` member function. If
    the item we''re looking for turns up in the `set`, we get an iterator that points
    to the element we were searching for. If the item that we were looking for is
    not in the `set`, we get back `set.end()` instead, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ask the user for a set of three unique names. Take each name in, one by one,
    and then print them in a sorted order. If the user repeats a name, ask them for
    another one until you get to three.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution for the preceding exercise can be found using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The C++ STL map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ STL `map` object is a lot like UE4's `TMap` object. The one thing it
    does that `TMap` does not is maintain a sorted order inside the map as well. Sorting
    introduces an additional cost, but if you want your map to be sorted, opting for
    the STL Version might be a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the C++ STL `map` object, we include `<map>`. In the following example
    program, we populate a map of items with some key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the iterator's syntax for an STL map is slightly different than that
    of `TMap`; we access the key using `it->first` and the value using `it->second`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how C++ STL also offers a bit of syntactic sugar over `TMap`; you can
    use square brackets to insert into the C++ STL `map`. You cannot use square brackets
    to insert into a `TMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Finding an element in a <map>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can search a map for a <`key`, `value`> pair using the STL map's `find`
    member function. You generally search by `key` and it'll give you the value for
    that `key`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ask the user to enter five items and their quantities into an empty `map`. Print
    the results in sorted order (that is, alphabetically or lowest to highest in the
    case of numbers).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution for the preceding exercise uses the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this solution code, we start by creating `map<string, int> items` to store
    all the items we're going to take in. Ask the user for an item and a quantity;
    then, we save the `item` in the `items` map using the square brackets notation.
  prefs: []
  type: TYPE_NORMAL
- en: C++ STL Vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Vector` is the STL equivalent of `TArray`. It''s basically an array that manages
    everything behind the scenes, the same way `TArray` does. You may not need to
    use it when working in UE4, but it''s good to know in case someone else uses it
    in a project.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UE4's containers and the C++ STL family of containers are both excellent for
    storing game data. Often, a programming problem can be simplified a lot by selecting
    the right type of data container.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will actually start to program the beginning of our
    game by keeping track of what the player is carrying and storing that information
    in a `TMap` object.
  prefs: []
  type: TYPE_NORMAL
