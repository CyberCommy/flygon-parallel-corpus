- en: '*Chapter 15*: Adding GraphQL Schema Part I'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll continue building out our application by integrating
    GraphQL. We'll do this on both the client and the server. We'll also finish building
    out our backend Express server and integrating that backend with our React client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating GraphQL server-side typedefs and resolvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating authentication with GraphQL resolvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating React client-side Hooks for querying Apollo GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a basic understanding of GraphQL and a good understanding of
    React, Node.js, Postgres, and Redis. We will once again be using Node and **Visual
    Studio Code** (**VSCode**) to write our code.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in folder `Chap15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the [*Chapter 15*](B15508_15_Final_JC_ePub.xhtml#_idTextAnchor222)
    code folder, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to your `HandsOnTypescript` folder and create a new folder called `Chap15`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to the `Chap14` folder and copy the `super-forum-server` folder into
    the `Chap15` folder. Make certain all files have been copied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the `super-forum-server` folder delete the `node_modules` folder and
    the `package-lock.json` file. Make sure you''re in the `super-forum-server` folder
    and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now make sure your Postgres server and Redis server are running, as shown in
    [*Chapter 13*](B15508_13_Final_JC_ePub.xhtml#_idTextAnchor208), *Setting Up a
    Session State Using Express and Redis*, and [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*. Then, test your server
    by running this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now let's copy our client app. Go to the `Chap13` folder and copy `super-forum-client`
    to the root of `Chap15`. Make sure all files are copied over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Delete the `node_modules` folder and the `package-lock.json` file. Now make
    sure you''re in the `super-forum-client` folder and run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Test that it works by running this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating GraphQL server-side typedefs and resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll add our GraphQL service to our Express server. We'll
    also start transforming our routes into GraphQL queries, which we created in [*Chapter
    14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216), *Setting Up* *Postgres and
    Repository Layer with TypeORM*. We'll also flesh out the rest of the calls that
    we need, as GraphQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by first integrating GraphQL into our Express application (we
    covered GraphQL in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, and [*Chapter 10*](B15508_10_Final_JC_ePub.xhtml#_idTextAnchor147),
    *Setting Up an Express Project with TypeScript and GraphQL Dependencies*):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There will be a very large amount of code in this chapter and not all of it
    can be shown in text. Please refer to the chapter source code, which is the GitHub
    repository code, frequently. Note also the chapter source code is the final running
    project and will contain only the final working code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by installing GraphQL. Run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create our initial type definitions, `typeDefs`. Create a folder
    called `gql` inside of the `src` folder. Then create the file `typeDefs.ts` inside
    of it. Now add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a new custom `scalar` type, `Date`, not available by default in GraphQL
    for dates and times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This `EntityResult` type will be used when errors or messages are returned
    instead of entities from our resolvers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We created our `User` type here. Notice the relations to `Thread` and `ThreadItem`.
    We''ve also used our `Date` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We created our `Thread` type and its relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are implementing our real application, it's time to use some more
    sophisticated features of GraphQL. The `union` type is the same concept as in
    TypeScript. It will allow us to return any type from a list of possible GraphQL
    types. For example, in this example, this type may represent *either* a Thread
    or an EntityResult, but not both at the same time. I'll show the usage of this
    type soon and it will become clearer how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We created our `ThreadItem` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `ThreadCategory` type also refers to the `Threads` that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have our `Query` with the `getThreadById` function. Notice it returns
    our `union` `ThreadResult`. We'll flesh this out more later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a simple resolvers file to get started with our GraphQL installation.
    Create a file called `resolvers.ts` in the `gql` folder and add this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be using `EntityResult` as our return type for errors and status messages.
    Also, add our type mapping to the same type in the `typeDefs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s another new feature of GraphQL we are using. `ThreadResult` is the
    `union` that represents the two types, `Thread` and `EntityResult`, in GraphQL.
    This resolver notices when a `ThreadResult` is about to be returned and figures
    out which type it is internally. The method you use is entirely up to you to determine
    the type sent back, but here we have used a simple check for the `EntityResult`
    type''s `message` field by checking `obj.message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We learned about GraphQL queries in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, so I won't go over it too deeply here. Just note that in this
    call, I accept the result type from the call to `getThreadById`, `QueryOneResult`,
    and after some processing, I return the actual entity itself or `EntityResult`.
    Again, since our `typeDefs` file has our query as returning a `ThreadResult`,
    it will go to the `ThreadResult` query and figure out which type to return. This
    is a pattern that we'll repeat for most of our repository calls. Repositories
    were covered in [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For this sample application, we are just rethrowing the errors that may occur.
    But in your production app, you should handle the error as appropriate to your
    app, which, in general, means to at least log the issue so it can be looked at
    later.
  prefs: []
  type: TYPE_NORMAL
- en: We will populate this code with more queries and mutations later, but for now,
    let's focus on completing our base setup.
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste the `GqlContext.ts` file from the `Chap10/gql-server/src` folder
    into the `gql` folder. As shown in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, this is where our Request and Response objects live inside
    of a GraphQL call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s open our `index.ts` file and add GraphQL into it. Update it by adding
    this code just before the call to `listen` and make sure to add the necessary
    imports, which you should be able to do yourself now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is basically similar code to [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*, where we instantiate our `ApolloServer` and bring it our `typeDefs`,
    `resolvers`, and Express `app` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test this to make sure it's working. Open the URL `http://localhost:5000/graphql`.
    This is the GraphQL playground we reviewed in [*Chapter 9*](B15508_09_Final_JC_ePub.xhtml#_idTextAnchor139),
    *What is GraphQL?*. Run it as shown:![Figure 15.1 – First query into GraphQL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_15.01_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.1 – First query into GraphQL
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, our call now works. The only difference from some of our
    prior calls into GraphQL is that since our call could return two different types,
    we use the `… on <some type>` syntax to decide which entity and fields we want
    upon return (this feature is called inline fragments). Also, again, please remember
    your local ID numbers will not necessarily be the same as mine, so you need to
    send IDs that definitely exist in your database.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s do another. This time, we''ll pick one that does not return an entity
    – the `createThread` function. First, add this mutation to the end of your `typeDefs`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Notice we are not returning a `ThreadResult`. Our `createThread` function only
    returns a string message. So that's all we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s update the `resolvers` file. Add this function as a mutation. Again,
    you''ll need to import anything that is needed yourself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the same parameters list as always, but this time we return only the
    `EntityResult` as there is no need to return the entire entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we made our call to the repository's `createThread` and got back our result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And now we're returning the list of possible messages to indicate the status
    of the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Again, in production, you should not simply rethrow but log or otherwise deal
    with an error. We rethrow here in order to simplify and focus on the concepts
    at hand, without getting sidetracked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, now if we run our code, we should see this:![Figure 15.2 – createThread
    function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_15.02_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.2 – createThread function
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so let''s do one more call for Threads. In the `ThreadRepo` is the call
    `getThreadsByCategoryId`, which returns an array of Threads. This is a problem
    because the GraphQL `union` operator does not support arrays. So we''ll need to
    create another new entity in the `typeDefs` file to represent an array of Threads
    and then we can create our union. Update the `typeDefs` file by adding this under
    the ThreadResult union:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So we created an entity that returns an array of Threads first. Then we created
    our `union` that either returns that entity type or the `EntityResult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add this after the `getThreadById` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can build our resolver. Update the `resolvers` Query section by adding
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we return our array of threads.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And here we return our messages if there are no threads.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re missing just one more item. When we first started using `union`, we
    had to create a query for the `EntityResult` type. So, we need to do the same
    thing for our new `ThreadArrayResult` type. Enter this code just after the `EntityResult`
    definition inside the `resolvers` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It's the same situation as before. If `obj` has a `messages` property, we return
    the type `EntityResult`; if not, then we return the `ThreadArray` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this Query, we should see something like this (note my results are
    filled with duplicate testing data):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.3 – The getThreadsByCategoryId function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.03_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.3 – The getThreadsByCategoryId function
  prefs: []
  type: TYPE_NORMAL
- en: Notice we added an additional field called `__typename`. This field will tell
    us which type is coming back, which as shown is `ThreadArray`.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so now we have a working GraphQL server with queries for Threads. Try and
    integrate the non-authentication related calls from [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*, yourself. If you get
    stuck, you can refer to the source code. But it's important you try and do this
    *without* looking as that's how you know for sure you understand the material.
  prefs: []
  type: TYPE_NORMAL
- en: ThreadPoint System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve integrated our existing resolver calls, let''s create some
    of the calls that we still need. We created a points system for our Threads and
    ThreadItems. Let''s now implement a way to increment and decrement points. If
    it''s been a while, take a look at the ThreadPoint and ThreadItemPoint entities
    before continuing. You''ll notice a new field called `points`, which I''ll explain
    once we start writing our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file called `ThreadPointRepo.ts` inside of the repo folder
    and add this code into it (again, I assume you know how to add the necessary imports):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice the parameters have an `increment` boolean. This determines whether we
    are trying to add or remove a point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once we create our authentication calls, we'll revisit this comment and fill
    it in with code. Note that adding a `todo` comment is a good way of keeping track
    of the items remaining to be completed. It also notifies team members of this
    fact.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So, we start by getting the `Thread` for the given `threadId`. Notice we also
    check that the given `User` is not the same `User` who owns the thread. If you
    have only one `User` in your database, you'll need to add another `User`, so that
    the owner of the `Thread` is not the same one trying to increment its point. You
    can add a user by using a SQL insert query or reusing our register route from
    [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216), *Setting Up Postgres
    and Repository Layer with TypeORM*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've gotten the matching `User` a bit before we actually need to use
    them. We'll see in a bit why we're doing something that may seem inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are seeing if an existing point entity already exists. We will use
    this object to make decisions on how to add or remove points later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a bit of new TypeORM code. The `getManager().transaction`
    call is creating a SQL transaction. A transaction is a way of doing multiple SQL
    operations as a single atomic operation. In other words, either every single one
    will complete successfully or all will fail. So then everything running inside
    of this scope is part of the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we noticed previously that we had created a `User` entity in advance
    of using it. This is because it is a best practice to avoid making selection queries
    inside of a transaction. This is not a hard rule. But in general, having selection
    queries inside of transactions makes things slower.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we checked if a `ThreadPoint` already exists by checking for
    `existingPoint` (remember a `ThreadPoint` can represent a positive or negative
    point, as indicated by the `isDecrement` field). Once that is determined, we decide
    if we are doing an increment or a decrement. If doing an `increment` and there
    is an existing decrement `ThreadPoint`, we delete that entity and do nothing else.
    If we are doing a decrement and there is an existing `increment` `ThreadPoint`,
    we delete that entity and do nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the other thing to notice is that our Thread Entity now has a field called
    points, which we increment or decrement as appropriate. This field will act as
    a sort of shortcut in our UI that will allow us to get the current `Thread''s`
    points total without having to sum all the `ThreadPoints` for that `Thread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Else if we have no existing points at all, we just create a new one that is
    either an increment or a decrement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add `Mutation` to `typeDefs` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Then, update the `resolver` by adding the `updateThreadPoint` call to the `Mutation`
    section. Since this is just a wrapper around the repository call that does the
    actual work, I won't show the code here. Try and see if you can create the `Mutation`
    yourself without looking at the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Most of the resolvers we will use are just wrappers around our Repository calls.
    This keeps our resolver code separate from our database and Repository calls.
    So, most of the time, I will not show the resolver code since it is slight and
    available in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `Mutation` as shown and then check your database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Run updateThreadPoint'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.04_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.4 – Run updateThreadPoint
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the result of our mutation in the Postgres database, using pgAdmin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Run the updateThreadPoint database result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.05_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.5 – Run the updateThreadPoint database result
  prefs: []
  type: TYPE_NORMAL
- en: So, our record is created successfully, as shown.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's discuss a bit more about this points system that we have and how it
    works. A *like* points system can allow for both a positive and a negative point,
    as does our system. However, it must also prevent users from voting more than
    once. In order to do that, we need to associate each point with both the user
    that gave it and the Thread or ThreadItem they put it on. This is why we have
    the ThreadPoint and ThreadPointItem entities.
  prefs: []
  type: TYPE_NORMAL
- en: On a well-trafficked site having many users, adding or removing points at any
    given time can be a significant load on the server. But worse than this is if
    we were to have to sum up all of these ThreadPoints or ThreadItemPoints upon each
    call to get Thread or ThreadItem data. This would be untenable. So for the first
    issue, we must accept it as part of having a "one vote per user" points system.
    However, for the summing of points issue, we could attempt several different things
    in order to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: The most performant would be to add a caching system, using a secondary service
    like Redis. However, building a caching system is no trivial matter and well beyond
    the scope of this book. And we could argue that while our site is just getting
    started, before it achieves glorious success and billions of dollars, we won't
    have that kind of traffic. So, as a start, we could try something a little simpler.
  prefs: []
  type: TYPE_NORMAL
- en: So what we are doing instead is adding the points field to our Thread and ThreadItem
    entities and incrementing the values as calls to add or remove points are made.
    Not the best solution, but it will do for now. Over time, a caching system or
    some other mechanism can be built out that is more sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: The code for ThreadItemPoint is virtually identical. Go ahead and see if you
    can build the `ThreadItemPointRepo.ts` file yourself. As always, take a look at
    the code in the source if you get stuck.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we began integrating our Repository calls with our GraphQL
    layer. We also fleshed out our Thread and ThreadItem points system. In the next
    section, we'll continue building out our GraphQL API by integrating our authentication
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating authentication with GraphQL resolvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating authentication into GraphQL isn't much different from adding any
    other functionality. In this section, we'll learn how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now integrate our authentication-related calls. Let''s start with the
    `register` call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll recall we already created our `register` call in [*Chapter 14*](B15508_14_Final_JC_ePub.xhtml#_idTextAnchor216),
    *Setting Up Postgres and Repository Layer with TypeORM*. So now, let''s add our
    `typeDefs` and `resolvers`. First, add the `register` call from the source code,
    to the `typeDefs` file in the `Mutation` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in our resolvers file, in the `Mutation` section, add the code from our
    GitHub source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is again just a wrapper of our repository call so there's not much to explain,
    but notice we do not return a `User` object; we only return a status message.
    This is because we want to reduce the chance of any unnecessary information being
    spilled out. Before we try running it, let's enable our GraphQL playground to
    accept cookies so we can test it. We need to enable cookies so that our Session
    State can be saved, which is what allows our calls to check if the User has already
    logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upper-right corner of the playground, click on the gear icon. Set the
    `request.credentials` field to `include` as shown, then save it and refresh the
    screen. We should see this if we run it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Register'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.06_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.6 – Register
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the `login` function. Add the login source code to the `Mutation`
    section of your `typeDefs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add the resolver code for `login` from the source code. Our Repository `login`
    call is checking that the user exists and making sure the password matches. The
    GraphQL call then takes the `user.id` and sets it to the Session object, `ctx.req.session.userId`,
    if a successful login happens. Notice also that our resolver does not return the
    `user` object upon success. We'll create a new function to provide `User` info
    later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's do the `logout` function. First, add the `typeDefs` entry inside of
    the `Mutation` section as shown by the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now update the resolvers `Mutation` with the `logout` resolver code from the
    source. Notice no matter what response comes back from the Repository `logout`
    call, we `destroy` the `session` using `ctx.req.session?.destroy` and this sets
    `ctx.req.session?.userId` to `undefined`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add one more new call and a new type to our `typeDefs`. Add
    the function `me` to the `Query` section of the `typeDefs` file, as shown by the
    source code. Next, underneath the `User` type, add this `union`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Why do we need these? In our calls to `register` and `login`, we eliminated
    the returned `User` object because `User` details may or may not be used after
    these calls and we don't want to unnecessarily expose `User` data. However, there
    are times when once a `User` is logged in, we may want to see their relevant data.
    For example, when they access their UserProfile screen. So, we will use this `me`
    function to handle that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add our `UserRepo` call for the `me` function. Add this function
    to `UserRepo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'First, notice that the `user` object we find includes any `Threads` and `ThreadItems`
    that belong to the user. We will use these in our UserProfile screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the function is a lot like the login function.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create our `resolvers` for the `UserResult` and the `me` function.
    At the top of the resolvers `const`, add the UserResult resolver as shown in the
    code. This is the same as the other Result `union` resolvers – there's nothing
    new to explain here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Query` section, add the code for the `me` function from the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice this resolver takes no parameters, as it gets the `userId` from the session.
    On line 193, it checks the `userId` is in the session. If it is not, it exits
    early. If the `userId` is in the Session, it uses our `UserRepo` `me` function
    to get the currently logged-in `user`. And the rest is basically the same as other
    functions returning an entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try running our `me` resolver. Make sure you''ve logged in once and
    have followed the instructions in *Step 3* for the GraphQL playground. If you
    run `me` as shown, you should get back relevant data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Call to the me resolver'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.07_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.7 – Call to the me resolver
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we use inline fragments again and are able to get back both
    related Threads and ThreadItems.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we tied our Repository layer authentication calls to GraphQL
    and tested their functionality. In the next section, we will finish our application
    by tying our nearly complete backend to our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Creating React client-side Hooks for querying Apollo GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will finish off our application by connecting our React
    client to our GraphQL backend. We've come a long way and we're almost there.
  prefs: []
  type: TYPE_NORMAL
- en: In order to tie the two parts of our app together, we need to add CORS to our
    Express server. **CORS** stands for **Cross-Origin Resource Sharing**. It means
    that our server will be set up to allow a client domain that is not the same as
    its own domain.
  prefs: []
  type: TYPE_NORMAL
- en: In most server configurations of even modest complexity, the server that hosts
    the client-side application and the server that provides the API do not exist
    on the same domain. In general, you will have a proxy of some kind, for example,
    NGINX, that will accept calls coming from the browser. And that proxy will "redirect"
    calls as required. We will explain how reverse proxies work in more detail in
    [*Chapter 17*](B15508_17_Final_JC_ePub.xhtml#_idTextAnchor259), *Deploying an
    Application to AWS*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A proxy is a stand-in for a service or some services. When a proxy is used,
    if a client makes a call to a service, they end up accessing the proxy first and
    not the service directly. The proxy then determines where the client's request
    should be routed to. A proxy, therefore, provides companies with better control
    of their service access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling CORS is also necessary because the React application runs on its own
    test web server. In our case, it runs on port `3000`, while the server runs on
    port `5000`. Although they both use localhost, having different ports effectively
    means different domains. To update CORS, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to update our `.env` file to have the path to the client development
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `index.ts` and add this code immediately after `const app = express();`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `credentials` setting enables the header Access-Control-Allow-Credentials.
    This allows client JavaScript to receive responses from servers after successfully
    providing credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also update the Apollo Server so that its own `cors` is disabled. Update this
    line just before `listen`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ve installed CORS onto our server. Let''s now open our React project
    in its own VSCode window and install GraphQL to get started integrating with our
    GraphQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: After opening the `super-forum-client` folder in its own VSCode window, try
    running it first to make sure it's working. If you have not done so already, delete
    the `node_modules` folder and the `package-lock.json` file and run `npm install`
    once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s install Apollo GraphQL Client. Open your terminal to the root of
    `super-forum-client` and run this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to configure our client. Open `index.ts` and add this code above
    `ReactDOM.render`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As always, add your imports – pretty self-explanatory. We set the URL of the
    server, include any credentials needed, and set the `cache` object. Note this
    means that Apollo caches all our query results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next update `ReactDOM.render` and have it include the `ApolloProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s test that its working by getting ThreadCategories. Open the `src/components/areas/LeftMenu.tsx`
    file and update it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve imported some items from the Apollo client. `gql` allows us to get syntax
    highlighting and formatting for GraphQL queries. `UseQuery` is our first GraphQL
    related client-side Hook. It allows us to do a GraphQL Query, as opposed to doing
    a Mutation, but it runs immediately. Later, I''ll show a Hook that allows lazy
    loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here is our query. Not much to explain here, but note we get both `id` and `name`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `useQuery` call returns the properties `loading`, `error`, and `data`.
    Each Apollo GraphQL Hook returns a different set of relevant properties. We''ll
    see how these particular properties are used in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the code just shown, we first check if data is still being loaded by using
    the `loading` property and providing placeholder text in that case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this error section, we indicate an error occurred during the query run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if all went well and we got our data, then we display an unordered
    list of elements representing each ThreadCategory. Notice each `li` element has
    a unique key identifier. It is always important to have keys when providing an
    array of similar elements, as it reduces unnecessary renders. Also, each element
    is a link that shows the user all Threads related to a specific `ThreadCategory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the app should show this screen in desktop mode. Notice I''ve clicked
    on one of the ThreadCategory links that have associated Thread data. But of course,
    we are currently still using `dataService` to return hardcoded data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.8 – LeftMenu ThreadCategory list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.08_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.8 – LeftMenu ThreadCategory list
  prefs: []
  type: TYPE_NORMAL
- en: Awesome – we are now connected to our GraphQL server!
  prefs: []
  type: TYPE_NORMAL
- en: The Main screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Congratulations – you''ve come a long way. Now we need to update our Main component
    so that we return real data from our GraphQL service. Let''s create that now:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to our `super-forum-server` project and open the `typeDefs` file and add
    the schema entry for the function `getThreadsLatest` just below the `getThreadsByCategoryId`
    query from the source. Here, we are creating a new resolver, `getThreadsLatest`,
    that gives us the latest Threads when no specific ThreadCategory is given. When
    a ThreadCategory is given, we already have the `getThreadsByCategoryId` resolver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `ThreadRepo` and add this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a query that includes ThreadCategories and ThreadItems – `leftJoinAndSelect`,
    is ordered by the `createdOn` field, `orderBy`, and takes only up to 10 items
    (`take`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The rest is self-explanatory as it's similar to `getThreadsByCategoryId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also update our `getThreadsByCategoryId` function to include the ThreadItems
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: It's the same as before only with the additional `leftJoinAndSelect` function.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `resolvers` file and add the `getThreadsLatest` function from the source
    code at the end of the Query section. This is a wrapper almost identical to the
    `getThreadsByCategoryId` resolver, except it calls `getThreadsLatest` instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we need to update our `Main` React component so that it uses our GraphQL
    resolvers instead of the fake data from our `dataService`. Open `Main` and update
    the file like this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `const` `GetThreadsByCategoryId` is our first query. As you can see, it
    uses inline fragments and gets back our Thread data fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`GetThreadsLatest` is basically identical to `GetThreadsByCategoryId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we begin our `Main` component definition with our use of `useLazyQuery`
    Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The two Hooks that were shown are now using our queries. Notice these are lazy
    GraphQL queries. This means they do not run immediately, unlike `useQuery`, and
    only run when the `execGetThreadsByCat` or `execGetThreadsLatest` calls are made.
    The `data` property is what contains our query's returned data. Additionally,
    I have commented out two of the returned properties because we are not using them.
    However, they are available for use should your call run into errors. `Error`
    contains information on failures and `called` indicates whether the Hook was called
    already.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The previous state objects remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This `useEffect` was updated to now only execute `execGetThreadsByCat` or `execGetThreadsLatest`
    as needed. If the `categoryId` parameter is given, `execGetThreadsByCat` should
    run; if not, the other should run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In `useEffect`, `threadsByCatData` changes cause us to update `category` and
    `threadCards` with data from the `getThreadsByCategoryId` query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In `useEffect`, `threadsLatestData` changes cause us to update `category` and
    `threadCards` with data from the `getThreadsLatest` query. Notice when no `categoryId`
    is given, we just use a generic "Latest" name for our ThreadCategory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code remains the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we run this for a `categoryId`, we should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.9 – With categoryId'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.09_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.9 – With categoryId
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this without a `categoryId`, we should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Without categoryId'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.10_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.10 – Without categoryId
  prefs: []
  type: TYPE_NORMAL
- en: 'Good – now we have some actual real data populating on our site screen. Before
    continuing, let''s clean up our styling a bit and get rid of some of these placeholder
    background colors. I''ve made minor changes to the `Nav.css` and `Home.css` files.
    This is what it looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Home screen style update'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.11_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.11 – Home screen style update
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, that''s better. Here''s one thing to notice on the mobile version of our
    screen – we have no way for the user to switch to another category, as shown in
    this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – Home screen mobile view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.12_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.12 – Home screen mobile view
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add a dropdown that will allow the user to switch categories. This
    dropdown should only appear while in mobile mode. Try and build this control yourself
    before following along. Hint: use React-DropDown to build the dropdown and replace
    the category label with the drop-down control. For example, in *Figure 15.12*
    we see the selected category is `MainHeader` control. So then replace that label
    with the dropdown, but only in mobile mode. Note that we are already using a dropdown
    in our ThreadCategory route so we should create a component out of it so it can
    be reused.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve given it a try, let''s now start building it together so you can
    compare. Here''s the thing I lied a little bit. This is a fairly complex change
    as it requires two main things. First, we would want to add a new Reducer for
    ThreadCategories since we know that the list of ThreadCategories is being used
    in at least two separate components. We also need to componentize the dropdown
    in the ThreadCategory component so that it can be used in several places. This
    second piece is fairly involved as the new drop-down component has to be complex
    enough to receive props from the outside and also send out the selected category
    whenever it changes:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create our new Reducer. Create a new folder in the `store` folder
    called `categories`. In that folder, create a file called `Reducer.ts` and add
    the source code to it. This file is a lot like our `User` Reducer, except it returns
    as payload an array of `Category` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add our new Reducer to our `AppState''s` `rootReducer` like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Our new `rootReducer` member will be called `Categories`.
  prefs: []
  type: TYPE_NORMAL
- en: Now update the `App.tsx` component so that upon application load, we immediately
    get our ThreadCategories and add them to the Redux store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we are adding the `GetAllCategories` GraphQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this code we''ve seen before, but this is where we''ve sent our payload
    of ThreadCategories to the Redux store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Everything else remains the same. Note you will need to update your imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LeftMenu` and `ThreadCategory` components will need to have their code
    for getting ThreadCategories and creating the dropdown removed. But first, let''s
    create our shared control that will do all this. Create a file inside of `src/components`
    called `CategoryDropDown.tsx` and add this code. Make sure you add any necessary
    imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: With `defaultOption`, we've created an initial value for our dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`CategoryDropDownProps` will be our parameter type for our `CategoryDropDown`
    component. `sendOutSelectedCategory` is a function passed by the parent caller
    that will be used to receive the selected drop-down option by the parent. `Navigate`
    is a boolean that determines whether the screen will move to a new URL upon selection
    of a new drop-down option. And `preselectedCategory` allows the parent to force
    the dropdown to have selected the specified ThreadCategory on load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Based on our previous learning, the usage of these listed Hooks is pretty obvious.
    But do notice that we are getting the list of ThreadCategories from our Redux
    store using `useSelector`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here, we build our array of options to feed to our dropdown later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `setCategoryOptions`, we are receiving our list of ThreadCategory option
    elements and setting them so they can be consumed by our dropdown later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have set our default drop-down selection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In this drop-down change handler here, we are notifying the parent of a selection
    change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We navigate to the next ThreadCategory route if requested by the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: And finally, here's our actual JSX, which is pretty self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to update the `MainHeader.tsx` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The only significant change is this `getLabelElement` function, which decides
    whether the screen is mobile and renders `CategoryDropDown` if it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code is the removal of code mostly, so try and do that yourself.
    You can, of course, look at the source code if needed. The affected files are
    `ThreadCategory.tsx`, `LeftMenu.tsx`, and `Thread.css`.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication-related features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s continue by updating our authentication-related features. Please
    remember that all your `User` accounts must have their `confirmed` field set to
    true *before* they can log in:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we want to do is have the user be able to log in. In order to
    do this and then be able to update our `User` object in the global Redux store,
    we're going to refactor our Redux User Reducer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, in the `models` folder, create a new file called `User.ts` and add the
    source code to it. Notice that our `User` class has a field called threads. This
    will contain not only the Threads belonging to the user but the ThreadItems of
    those Threads.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's update our Reducer. Open `store/user/Reducer.ts` and update it by
    removing the `UserProfilePayload` interface and replacing its references with
    the new `User` class we just created. Look at the source code if you need to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can update our `Login` component like this. Update the imports as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice we have imported the Hook `useRefreshReduxMe`. We''ll define this Hook
    in a moment, but first I want to introduce some features of the `useMutation`
    GraphQL Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our login `Mutation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Let me explain this `useMutation` call. The call takes as parameters the Mutation
    query `LoginMutation` and something called `refetchQueries`. `refetchQueries`
    forces whatever queries are listed therein to rerun and then caches their values.
    If we did not use `refetchQueries` and ran the `Me` query again, we would end
    up getting the last cached version instead of the freshest data. Please note it
    does not auto-refresh any calls that depend on its queries; we still have to make
    those calls to get the new data.
  prefs: []
  type: TYPE_NORMAL
- en: The output, `execLogin`, is a function that can be executed later as desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The prior calls are the same as they were previously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The `onClickLogin` handler is now calling our `execLogin` function with appropriate
    parameters. After `execLogin` finishes, it will automatically call our `refetchQueries`
    list of queries. After that, we make a call to the functions from our Hook, `useRefreshReduxMe`,
    `execMe`, and `updateMe`. The `execMe` function will get the latest `User` object
    and `updateMe` will add it into the Redux store. The rest of the code is identical
    so I will not show it here.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's define our Hook `useRefreshReduxMe`. We want to create this Hook so
    that our code to set or unset our Redux `User` object can be in this single file.
    We will be using this Hook from several components. Create a file called `useRefreshReduxMe.ts`
    in the hooks folder and add the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top, we can see the `Me` `const` is our query to get user information.
    The `EntityResult` inline fragment is used to get the string of messages if that's
    what is coming back. If we get actual user data, then the fields desired are defined
    by the `User` inline fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `UseRefreshReduxMeResult` interface is a return type for our Hook.
  prefs: []
  type: TYPE_NORMAL
- en: On line 37, we have defined `useLazyQuery` to allow our Hook users to be able
    to execute the call to the `Me` query at a time of their own choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have defined a function, `deleteMe`, to allow users of our Hook to
    destroy the Redux `User` object at any time. For example, when the user logs off.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we have the `updateMe` function to allow the setting of the Redux
    `User` object. And then we return all of these functions so they can be used by
    our Hook callers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon app load, we should immediately check if our `User` is logged in and who
    that is. So, open `App.tsx` and update it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've initialized our `useRefreshReduxMe` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call our `execMe` to get the `User` data from GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: And here, we call `updateMe` to update our Redux User Reducer with the `User`
    data if any.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: I changed our original data field name to `categoriesData` so it would be clearer
    what it's for. The rest of the code remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you log in now, you''ll see that our `SideBar` `userName` updates to the
    logged-in user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.13 – Logged-in user'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.13_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.13 – Logged-in user
  prefs: []
  type: TYPE_NORMAL
- en: So, now we can log in, and then show the `userName` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Awesome, but now let''s fix our `SideBar` so that only the appropriate links
    show at the right time. For example, if the user is logged in, we should not see
    the **login** or **register** links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that the right menus show when the user logs in or out, let''s
    first update our `Logout` component. Make sure imports are up to date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Here's our `logout` mutation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, again, we've forced a refresh of our GraphQL cache for the `Me` query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Again, we've taken our `useRefreshReduxMe` Hook, but here we only call the `deleteMe`
    function since we're just logging out. The rest of the code remains the same,
    so I won't show it here.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're going to update the `SideBarMenus` component so that only the appropriate
    menus show at the right time. Open that file and update it as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, I''ll only show the returned JSX as that''s the only thing that
    changed (other than imports):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are testing whether the `user` object has a value and then
    showing our same `userName` UI, else we show nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don't want to show our registration UI if the user does exist
    so that's what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Again, we don't show the login if the `user` object exists already, because
    that indicates the user had already logged in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Here, we show the logout UI if the `user` object has a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code now, when not yet logged in, you''ll see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.14 – Not logged in SideBarMenus'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.14_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.14 – Not logged in SideBarMenus
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when logged in, we should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Logged in SideBarMenus'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.15_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.15 – Logged in SideBarMenus
  prefs: []
  type: TYPE_NORMAL
- en: So our sidebar now displays proper links and text. Let's now work on our UserProfile
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: The UserProfile screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, since we are in the authentication sections, let''s finish our UserProfile
    screen. We will need to make multiple changes to configure this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s update our GraphQL by adding a field to our `User` type. Update
    the `typeDefs` file''s `User` type by adding this just below the threads field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update our User Entity by adding one new field. Update the
    `User.ts` file by adding this field in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows our `User` entity to have associated entities on the ThreadItems
    entity. Also, make sure you already have the matching field in the `ThreadItem.ts`
    file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s open our UserRepo Repository file and update our `me` function so
    that it includes the user''s ThreadItems. Update the UserRepo `User.findOne` function
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice that the UserProfile screen has a change password feature. So
    let''s build that out now. First, we''ll need to add a new Mutation to our `typeDefs`
    file. Add this Mutation to the Mutation section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: A pretty self-explanatory Mutation definition.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's implement this function in our UserRepo. Add the `changePassword`
    function to the end of the UserRepo from the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting at line 125, since the user will be logged in if this call is made,
    we are expecting the user `id` from the resolver code to be passed in. If it does
    not exist, then of course we'll error out.
  prefs: []
  type: TYPE_NORMAL
- en: Then we try and get the `User` object and then run a few checks to make sure
    the user is valid. And finally, we use `bcrypt` to generate our hashed password.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create our resolver. Open the `resolvers` file and add the source
    code for the `changePassword` function into the Mutation section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, on line 389, we check if a valid Session and `userId` in that Session
    exist, because this is what indicates the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, we call our `changePassword` Repository function with the Session
    `userId` and the given new password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now update our `UserProfile` component. Update the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the imports as we have imported a couple of new items, `gql` and `useMutation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have our new Mutation, `ChangePassword`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: useEffect(() => {
  prefs: []
  type: TYPE_NORMAL
- en: if (user) {
  prefs: []
  type: TYPE_NORMAL
- en: dispatch({
  prefs: []
  type: TYPE_NORMAL
- en: 'type: "userName",'
  prefs: []
  type: TYPE_NORMAL
- en: 'payload: user.userName,'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: getUserThreads(user.id).then((items) => {
  prefs: []
  type: TYPE_NORMAL
- en: 'const threadItemsInThreadList: Array<ThreadItem>        = [];'
  prefs: []
  type: TYPE_NORMAL
- en: 'const threadList = items.map((th: Thread) => {'
  prefs: []
  type: TYPE_NORMAL
- en: for (let i = 0; i < th.threadItems.length; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: threadItemsInThreadList.push(th.            threadItems[i]);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <li key={`user-th-${th.id}`}>
  prefs: []
  type: TYPE_NORMAL
- en: <Link to={`/thread/${th.id}`}               className="userprofile-link">
  prefs: []
  type: TYPE_NORMAL
- en: '{th.title}'
  prefs: []
  type: TYPE_NORMAL
- en: </Link>
  prefs: []
  type: TYPE_NORMAL
- en: </li>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: setThreads(<ul>{threadList}</ul>);
  prefs: []
  type: TYPE_NORMAL
- en: 'const threadItemList = threadItemsInThreadList.         map((ti: ThreadItem)
    => ('
  prefs: []
  type: TYPE_NORMAL
- en: <li key={`user-th-${ti.threadId}`}>
  prefs: []
  type: TYPE_NORMAL
- en: <Link to={`/thread/${ti.threadId}`}             className="userprofile-link">
  prefs: []
  type: TYPE_NORMAL
- en: '{ti.body}'
  prefs: []
  type: TYPE_NORMAL
- en: </Link>
  prefs: []
  type: TYPE_NORMAL
- en: </li>
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: setThreadItems(<ul>{threadItemList}</ul>);
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}, [user]);'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: const onClickChangePassword = async (
  prefs: []
  type: TYPE_NORMAL
- en: 'e: React.MouseEvent<HTMLButtonElement, MouseEvent>'
  prefs: []
  type: TYPE_NORMAL
- en: ) => {
  prefs: []
  type: TYPE_NORMAL
- en: e.preventDefault();
  prefs: []
  type: TYPE_NORMAL
- en: 'const { data: changePasswordData } = await     execChangePassword({'
  prefs: []
  type: TYPE_NORMAL
- en: 'variables: {'
  prefs: []
  type: TYPE_NORMAL
- en: 'newPassword: password,'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: dispatch({
  prefs: []
  type: TYPE_NORMAL
- en: 'type: "resultMsg",'
  prefs: []
  type: TYPE_NORMAL
- en: 'payload: changePasswordData ? changePasswordData.      changePassword : "",'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: return (
  prefs: []
  type: TYPE_NORMAL
- en: <div className="screen-root-container">
  prefs: []
  type: TYPE_NORMAL
- en: <div className="thread-nav-container">
  prefs: []
  type: TYPE_NORMAL
- en: <Nav />
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <form className="userprofile-content-container">
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <strong>User Profile</strong>
  prefs: []
  type: TYPE_NORMAL
- en: '<label style={{ marginLeft: ".75em"           }}>{userName}</label>'
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="userprofile-password">
  prefs: []
  type: TYPE_NORMAL
- en: <div>
  prefs: []
  type: TYPE_NORMAL
- en: <PasswordComparison
  prefs: []
  type: TYPE_NORMAL
- en: dispatch={dispatch}
  prefs: []
  type: TYPE_NORMAL
- en: password={password}
  prefs: []
  type: TYPE_NORMAL
- en: passwordConfirm={passwordConfirm}
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <button
  prefs: []
  type: TYPE_NORMAL
- en: className="action-btn"
  prefs: []
  type: TYPE_NORMAL
- en: disabled={isSubmitDisabled}
  prefs: []
  type: TYPE_NORMAL
- en: onClick={onClickChangePassword}
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Change Password
  prefs: []
  type: TYPE_NORMAL
- en: </button>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: '<div style={{ marginTop: ".5em" }}>'
  prefs: []
  type: TYPE_NORMAL
- en: <label>{resultMsg}</label>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="userprofile-postings">
  prefs: []
  type: TYPE_NORMAL
- en: <hr className="thread-section-divider" />
  prefs: []
  type: TYPE_NORMAL
- en: <div className="userprofile-threads">
  prefs: []
  type: TYPE_NORMAL
- en: <strong>Threads Posted</strong>
  prefs: []
  type: TYPE_NORMAL
- en: '{threads}'
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: <div className="userprofile-threadIems">
  prefs: []
  type: TYPE_NORMAL
- en: <strong>ThreadItems Posted</strong>
  prefs: []
  type: TYPE_NORMAL
- en: '{threadItems}'
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: </form>
  prefs: []
  type: TYPE_NORMAL
- en: </div>
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: export default UserProfile;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s show the user''s Threads and ThreadItems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to update our User model. Add this field to the `User.ts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Now update the `Me` query inside of the `useRefreshReduxMe` Hook like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in your `UserProfile` component, update `useEffect` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now getting our threads from the `user.threads` array, instead of our
    fake `dataService` call, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'We do the same thing for `threadItems` as well. Notice our `Link to` gets updated
    so that it uses `ti.thread?.id` instead of `ti.threadId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Here, we had added a tiny bit of extra logic to format long text that might
    go horizontally off the screen and wrap. Basically, it just means that if the
    text is longer than 40 characters, we add `"…"` to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining code is identical. If you run this, you should see something
    like the following (again, your data will be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – User''s Threads and ThreadItems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.16_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15.16 – User's Threads and ThreadItems
  prefs: []
  type: TYPE_NORMAL
- en: OK, that's it for our UserProfile. Because this was an enormous amount of material
    to cover, let's continue our work in the next chapter, [*Chapter 16*](B15508_16_Final_JC_ePub.xhtml#_idTextAnchor254),
    *Adding a GraphQL Schema – Part II*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have almost completed our application by integrating the
    frontend and the backend with GraphQL. This was a large and complex chapter so
    you should feel good about how far you have come.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 16*](B15508_16_Final_JC_ePub.xhtml#_idTextAnchor254),
    *Adding a GraphQL Schema – Part II*, we will finish coding our application by
    working on the Thread screen, so that we can view and post Threads, and work on
    the Points system so that users can see the popularity of individual Threads.
  prefs: []
  type: TYPE_NORMAL
