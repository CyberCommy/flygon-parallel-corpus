- en: Chapter 3. Using Modules and Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to use modules and packages within your Python programs, you need
    to understand how they work. In this chapter, we will examine the nuts and bolts
    of how modules and packages are defined and used in Python. In particular, we
    will:'
  prefs: []
  type: TYPE_NORMAL
- en: Review how Python modules and packages are defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how packages can be created inside other packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover how modules and packages can be initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about the import process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the notion of relative imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to control what gets imported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how to deal with circular dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how a module can be run directly from the command line, and why this can
    be useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should be fairly comfortable with organizing your Python code into
    modules and then importing and using these modules in other modules and programs.
    This is only a taste of what can be done, however. Let's briefly review what Python
    modules and packages are before looking closer at how they work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen, a **module** is simply a Python source file. You can import
    the module using the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, you can refer to any functions, classes, variables, and
    other definitions within the module by prepending the module name to the item,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 1](ch01.html "Chapter 1. Introducing Modular Programming"), *Introducing
    Modular Programming*, we learned that a Python **package** is a directory containing
    a special file named `__init__.py`. This is called the **package initialization
    file** and identifies the directory as a Python package. The package also typically
    contains one or more Python modules, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modules and packages](graphics/B05012_3_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To import the modules within this package, you add the package name to the
    start of the module name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use an alternative version of the `import` statement to make your
    code easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will look at the various ways in which you can use the `import` statement
    in the section *How to Import Anything* later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Packages within packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like you can have directories within directories, you can have packages
    within other packages. For example, imagine that our `my_package` directory contained
    another directory called `my_sub_package`, which itself had an `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packages within packages](graphics/B05012_3_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you might expect, you import the modules within a sub-package by prepending
    the names of the packages that contain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no limit to how deeply you can nest packages, though in practice it
    becomes a bit unwieldy if you have too many levels of packages-within-packages.
    More interestingly, the various packages and sub-packages form a **tree-like structure**
    which allows you to organize even the most complex program. For example, a sophisticated
    business system might be arranged like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packages within packages](graphics/B05012_3_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this is called a tree-like structure because the packages-within-packages
    look like the spreading branches of a tree. A tree-like structure like this allows
    you to group logically-related parts of your program together, while ensuring
    that everything can be found when you need it. For example, using the structure
    described by the preceding illustration, you would access your customer data using
    the `program.logic.data.customers` package, and the various menus in your program
    would be defined by the `program.gui.widgets.menus` package.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is an extreme example. Most programs—even very complex ones—won't
    be this complicated. But you can see how Python packages allow you to keep your
    program well organized, no matter how big and elaborate it becomes.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a module is imported, any top-level code within that module is executed.
    This has the effect of making the various functions, variables, and classes you
    defined in your module available for the caller to use. To see how this works,
    create a new Python source file named `test_module.py`, and enter the following
    code into this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open up a terminal window, `cd` into the directory where your `test_module.py`
    file is stored, and type `python` to start up the Python interpreter. Then try
    typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you do this, the Python interpreter prints the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It does this because all the top-level Python statements in the module—including
    the `def` statements and our `print` statement—are executed when the module is
    imported. You can then call the `foo` and `bar` functions, and access the `my_var`
    global, by prefixing the names with `my_module`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because all the top-level Python statements are executed when a module is imported,
    you can initialize a module by directly including the initialization statements
    in the module itself, just like the statement in our test module which sets `my_var`
    to zero. This means that the module will be automatically initialized when the
    module is imported.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that a module is only imported once. If two modules import the same module,
    the second `import` statement will simply return a reference to the already-imported
    module, so you won't get the same module imported (and initialized) twice.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This implicit initialization works, but it isn't necessarily a good practice.
    One of the guidelines promoted by the designers of the Python language is that
    *explicit is better than implicit*. In other words, having a module automatically
    initialize itself isn't always good coding practice, as it isn't always clear
    from reading the code exactly what gets initialized and what doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this confusion, and in order to follow the Python guidelines, it is
    often a good idea to explicitly initialize your modules. By convention, this is
    done by defining a top-level function called `init()` which performs all of the
    initialization for your module. For example, in our `test_module`, we could replace
    the `my_var = 0` statement with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit more verbose, but it makes the initialization explicit. Of course,
    you also have to remember to call `test_module.init()` before you use the module,
    usually from within your main program.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of explicit module initialization is that you can
    control the order in which your various modules get initialized. For example,
    if the initialization for module A includes calling a function in module B, and
    this function requires module B to have been initialized, the program will crash
    if the two modules are imported in the wrong order. This can get particularly
    difficult when modules import other modules, as the order in which modules are
    imported can be quite confusing. To avoid this, it's better to use explicit module
    initialization and have your main program call `B.init()` before it calls `A.init()`.
    This is a perfect example of why it's generally better to use explicit initialization
    functions for your modules.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To initialize a package, you place the Python code inside the package''s `__init__.py`
    file. This code is then executed when the package is imported. For example, imagine
    that you have a package named `test_package`, which contains an `__init__.py`
    file and one module named `test_module.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing a package](graphics/B05012_3_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can place whatever code you like inside the `__init__.py` file, and when
    the package (or a module within the package) is imported for the first time, that
    code will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why you might want to do this. Initializing a module
    makes sense as a module contains various functions that might need to be initialized
    before they are used (for example, by setting global variables to an initial value).
    But why initialize a package, rather than just a module within that package?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer lies in what happens when you import a package. When you do this,
    anything you define in the package''s `__init__.py` file becomes available at
    the package level. For example, imagine that your `__init__.py` file contained
    the following Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you could access this function from your main program in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to define the `say_hello()` function inside a module within the
    package for it to be easily accessed.
  prefs: []
  type: TYPE_NORMAL
- en: As a general principle, however, adding code to the `__init__.py` file isn't
    a great idea. It works, but people looking through your package's source code
    will expect the package's code to be defined inside modules rather than in the
    package initialization file. Also, there is only one `__init__.py` file for the
    whole package, which makes organizing your code within the package more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way of using package initialization files is to write your code in
    modules within the package, and then use the `__init__.py` file to import this
    code so that it is available at the package level. For example, you might implement
    the `say_hello()` function within the `test_module` module, and then include the
    following in the package''s `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Programs using your package would still call the `say_hello()` function in exactly
    the same way. The only difference is that this function is now implemented as
    part of the `test_module` module, rather than being lumped inside the `__init__.py`
    file for the entire package.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very useful technique, especially as your packages get more complicated
    and you have lots of functions, classes, and other definitions which you want
    to make available. By adding `import` statements to your package initialization
    file, you can write the parts of your package in whatever modules make the most
    sense to you, and then choose which functions, classes, and so on to make available
    at the package level.
  prefs: []
  type: TYPE_NORMAL
- en: One of the nice things about using `__init__.py` files in this way is that the
    various `import` statements tell the users of your package which functions and
    classes they should be using; if you haven't included a module or function in
    your package initialization file, then it's probably excluded for a reason.
  prefs: []
  type: TYPE_NORMAL
- en: Using `import` statements in a package initialization file also tells the users
    of your package where the various parts of a complex package are located—the `__init__.py`
    file acts as a kind of index into the package's source code.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, while you can include any Python code you like within a package's
    `__init__.py` file, it's probably best if you limit yourself to `import` statements,
    and keep your real package code elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: How to import anything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have used two different versions of the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing a module and then using the module name to access something defined
    within that module. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Importing something from a module and then using that thing directly. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `import` statement is very powerful, however, and we can do all sorts of
    interesting things with it. In this section, we will look at the different ways
    in which you can use the `import` statement to import modules and packages, and
    their contents, into your program.
  prefs: []
  type: TYPE_NORMAL
- en: What does the import statement actually do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever you create a global variable or function, the Python interpreter adds
    the name of that variable or function to what is called the **global namespace**.
    The global namespace holds all the names that you have defined at the global level.
    To see how this works, enter the following command into the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `globals()` built-in function returns a dictionary with the current contents
    of the global namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't worry about the various oddly named globals such as `__package__`; these
    are used internally by the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a new top-level function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now print out the dictionary of global names, our `test()` function will
    be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several other entries in the `globals()` dictionary, but from now
    on we'll only show the items that interest us so that these examples aren't too
    confusing.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the name `test` has been added to our global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once again, don't worry about the value associated with the `test` name; this
    is Python's internal way of storing the functions that you define.
  prefs: []
  type: TYPE_NORMAL
- en: 'When something is in the global namespace, you can access it by name from anywhere
    in your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there's a second namespace, called the **local namespace**, that holds
    variables and other things defined within the current function. While the local
    namespace is important when it comes to variable scope, we're going to ignore
    it as it isn't generally involved in importing modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you use the `import` statement, you are adding entries to the global
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the module that you imported has been added to the global namespace,
    allowing you to access that module by name, for example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, if you used the `from...import` version of the `import` statement,
    the item you''ve imported will be added directly to the global namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So now you know what the `import` statement does: it adds what you''re importing
    to the global namespace so that you can access it.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the import statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've seen what the `import` statement does, let's take a look at the
    different versions of the `import` statement that Python provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen the two most common forms of the `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import <something>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from <somewhere> import <something>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the first form, you aren''t limited to importing modules one at a time.
    If you want, you can import multiple modules at once, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can import multiple things at once from a module or package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more items to import than will fit on one line, you can either
    use line continuation characters (`\`) to spread the import across multiple lines,
    or surround the list of items that you want to import with parentheses. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When you import something, you can also change the name of the imported item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you are importing the `math` module under the name `math_ops`.
    The `math` module will be added to your global namespace using the name `math_ops`,
    and you can access the `math` module''s contents using the `math_ops` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two reasons why you might want to use the `import...as` statement
    to change the name of something when you import it:'
  prefs: []
  type: TYPE_NORMAL
- en: To make a long or unwieldy name easier to type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To avoid naming conflicts. For example, if you are using two packages that
    both define a module named `utils`, you might want to use the `import...as` statement
    so that the names are different. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that you should probably use the `import...as` statement sparingly. Every
    time you change the name of something, you (and anyone reading your code) will
    have to remember that `X` is another name for `Y`, which adds complexity and means
    that you have more things to remember as you write your program. There are certainly
    legitimate uses for the `import...as` statement, but don't overuse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, of course, combine the `from...import` statement with `import...as`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use a **wildcard import** to import everything from a module
    or package in one fell swoop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This adds all the items defined in the `math` module into the current global
    namespace. If you are importing from a package, then all the items defined in
    the package's `__init__.py` file will be imported.
  prefs: []
  type: TYPE_NORMAL
- en: By default, everything in the module (or package) that doesn't start with an
    underscore character will be imported by a wildcard import. This ensures that
    private variables and functions won't be imported. If you want, however, you can
    change what gets included in a wildcard import by using the `__all__` variable;
    this will be discussed in the *Controlling what gets imported* section later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Relative imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, whenever we've imported something, we've used the full name of the module
    or package that we want to import from. For simple imports such as `from math
    import pi`, this is sufficient. There are times, however, when this type of importing
    can be quite cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the complex tree of packages that we looked at in the
    *Packages within packages* section earlier in this chapter. Imagine that we want
    to import a module named `slider.py` from within the `program.gui.widgets.editor`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relative imports](graphics/B05012_3_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You could import this module using the following Python statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `program.gui.widgets.editor` part of the `import` statement identifies the
    package where the `slider` module can be found.
  prefs: []
  type: TYPE_NORMAL
- en: While this works, it can be quite unwieldy, especially if you have a lot of
    modules to import or if one part of a package needs to import several other modules
    from within the same package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this type of situation, Python supports the concept of **relative
    imports**. Using relative imports, you identify what you want to import relative
    to the current module''s position within the tree of packages. For example, imagine
    that the `slider` module wanted to import another module within the `program.gui.widgets.editor`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relative imports](graphics/B05012_3_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To do this, you replace the package name with a `.` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `.` character is a shorthand for *the current package*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, imagine that you have a module within the `program.gui.widgets`
    package that wants to import the `slider` module from the `editor` sub-package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relative imports](graphics/B05012_3_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, your `import` statement would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `.` character still refers to the current location, and `editor` is the
    name of the package relative to this current location. In other words, you are
    telling Python to look for a package named `editor` in the current location, and
    then import the module named `slider` within this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the opposite situation. Imagine that the `slider` module wants
    to import a module from the `widgets` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relative imports](graphics/B05012_3_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, you can use two `.` characters to mean *go up one level*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might imagine, you can use three `.` characters to mean *go up two levels*
    and so on. You can also combine these techniques to move through the package hierarchy
    in any way you like. For example, imagine that the `slider` module wants to import
    a module named `errDialog` from the `gui.dialogs.errors` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relative imports](graphics/B05012_3_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using relative imports, the `slider` module could import the `errDialog` module
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can use these techniques to select any module or package
    anywhere in the tree of packages, relative to your current position in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main reasons for using relative imports:'
  prefs: []
  type: TYPE_NORMAL
- en: They're a great way of making your `import` statements shorter and easier to
    read. Instead of having to type `from` `program.gui.widgets.editor import utils`
    in the `slider` module, you can simply type `from . import utils`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you write a package for others to use, you can have different modules within
    your package refer to each other without having to worry about where the user
    installed the package. For example, I might take a package you've written and
    place it inside another package; using relative imports, your package will continue
    to work without having to change all the `import` statements to reflect the new
    package structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Like anything, relative imports can be overused. Because the meaning of the
    `import` statement depends on the position of the current module, relative imports
    tend to violate the *explicit is better than implicit* principle. You can also
    get into trouble if you attempt to run a module from the command line, as described
    in the *Running modules from the command line* section later in this chapter.
    For these reasons, you should use relative imports sparingly, and stick to fully
    listing out the entire package hierarchy in your `import` statements unless you
    have a good reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling what gets imported
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you import a module or package, or when you use a wildcard import such
    as `from my_module import *`, the Python interpreter loads the contents of the
    given module or package into your global namespace. If you are importing from
    a module, all of the top-level functions, constants, classes, and other definitions
    will be imported. When importing from a package, all of the top-level functions,
    constants, and so on defined in the package's `__init__.py` file will be imported.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these imports load *everything* from the given module or package.
    The only exception is that a wildcard import will automatically skip any function,
    constant, class, or other definition starting with an underscore—this has the
    effect of excluding private definitions from the wildcard import.
  prefs: []
  type: TYPE_NORMAL
- en: While this default behavior generally works well, there are times when you may
    want more control over what gets imported. To do this, you can use a special variable
    named `__all__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how the `__all__` variable works, take a look at the following module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you imported this module, only `A` and `B` would be imported. While the module
    defines the variable `C`, this definition would be skipped because it isn't included
    in the `__all__` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a package, the `__all__` variable behaves in the same way, with one
    important difference: you can also include the name of modules and sub-packages
    that you want to include when the package is imported. For example, a package''s
    `__init__.py` file might contain only the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `__all__` variable controls which modules and packages to
    include; when you import this package, the two modules and the sub-package will
    be imported automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the preceding `__init.py__` file is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Both versions of the `__init__.py` file would have the effect of including the
    two modules and the sub-package within the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you don''t need to use it, the `__all__` variable gives you complete
    control over your imports. The `__all__` variable can also be a useful way of
    indicating to users of your modules and packages which parts of your code they
    should be using: if something isn''t included in the `__all__` list, then it''s
    not intended to be used by external code.'
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the annoying problems that you are likely to face while working with
    modules is what is known as circular dependencies. To understand what these are,
    consider the following two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is a contrived example, you can see that `module_1` imports something
    from `module_2`, and `module_2` imports something from `module_1`. If you tried
    to run a program containing these two modules, you would see the following error
    when `module_1` is imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you tried to import `module_2` instead, you would get a similar error. With
    the code organized in this way, you''re stuck: you can''t import either module
    as both depend on the other.'
  prefs: []
  type: TYPE_NORMAL
- en: To get around this, you would have to restructure your modules so that they
    don't depend on each other. In this example, you could create a third module,
    named `module_3`, and move the `calc_markup()` function to that module. This would
    make `module_1` dependent on `module_3`, rather than `module_2`, which breaks
    the circular dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other tricks you can perform to avoid circular dependency errors,
    for example by moving the `import` statement inside a function. In general, however,
    a circular dependency means that your code is badly designed, and you should refactor
    your code to remove the circular dependency entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Running modules from the command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Writing Your First Modular Program"),
    *Writing Your First Modular Program*, we saw your system''s main program is often
    named `main.py` and typically has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `__name__` global variable will be set to the value `"__main__"` by the
    Python interpreter when the user runs your program. This has the effect of calling
    your `main()` function when the program is run.
  prefs: []
  type: TYPE_NORMAL
- en: There is nothing special about the `main.py` program, however; it's just another
    Python source file. You can take advantage of this to make your Python modules
    executable from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider, for example, the following module, which we will call `double.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This module defines some functionality, in this case a function named `double()`,
    and then uses the `if __name__ == "__main__"` trick to demonstrate and test the
    module''s functionality when it is run from the command line. Let''s try running
    this module to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common use for a runnable module is to allow the end user to directly
    access the module''s functionality from the command line. To see how this works,
    create a new module named `funkycase.py`, and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `funky_case()` function takes a string and capitalizes every second letter.
    If you wanted to, you could import this module and then access this function from
    within your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is useful, we also want to let the user run the `funkycase.py` module
    as a standalone program, directly converting the supplied string to funky-case
    and printing it out to the user can see it. To do this, we can use the `if __name__
    == "__main__"` trick along with `sys.argv` to extract the string supplied by the
    user. We can then call the `funky_case()` function to convert this string to funky-case
    and print it out. To do this, add the following code to the end of your `funkycase.py`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following to the top of your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run this module directly as if it was a standalone program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this way, `funkycase.py` acts as a kind of *chameleon module*. To other Python
    source files, it appears as just another module that can be imported and used,
    while to the end user it looks like a standalone program that can be run from
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you want to make a module executable from the command line, you
    aren't limited to just using `sys.argv` to accept and process the arguments supplied
    by the user. The excellent `argparse` module in the Python Standard Library allows
    you to write Python programs (and modules) that accept a wide range of inputs
    and options from the user. If you haven't used this module before, do check it
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one issue to be aware of when you create a module that can be run
    from the command line: if your module uses relative imports, your imports will
    fail with an *attempted relative import of non-package* error when you run it
    directly using the Python interpreter. This error occurs because a module forgets
    about its position within the package hierarchy when it is run from the command
    line. As long as your module doesn''t use any command-line arguments, you can
    get around this problem by using Python''s `-m` command-line option, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However, if your module does accept command-line arguments, then you will need
    to replace your relative imports so that this problem doesn't occur. There are
    workarounds, but they are kludgy and not recommended for general use.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the details of how Python modules and packages
    work. We saw that modules are simply Python source files that get imported using
    an `import` statement, and that packages are directories of Python source files
    identified by a package initialization file named `__init__.py`. We learned that
    packages can be defined inside other packages to form a tree-like structure of
    nested packages. We looked at how modules and packages can be initialized, and
    how the `import` statement can be used in various ways to import modules and packages,
    and their contents, into your programs.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw how relative imports can be used to import modules relative to your
    current position in the package hierarchy and how the `__all__` variable can be
    used to control what gets included in an import.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned about circular dependencies and how to avoid them, and we finished
    by learning about chameleon modules, which can act as both importable modules
    and as standalone programs that can be run from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will apply what we have learned to the design and implementation
    of a more complicated program, and we will see how a good understanding of these
    techniques will let us build a system that is robust and can be updated to meet
    changing requirements.
  prefs: []
  type: TYPE_NORMAL
