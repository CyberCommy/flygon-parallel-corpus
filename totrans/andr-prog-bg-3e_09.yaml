- en: '*Chapter 9*: Learning Java Methods'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are starting to get comfortable with Java programming, in this chapter
    we will take a closer look at methods because although we know that you can **call**
    them to make them execute their code, there is more to them than we have discussed
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Method structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method overloading versus overriding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method demo mini-app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How methods affect our variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's go through a quick method recap.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009).
  prefs: []
  type: TYPE_NORMAL
- en: Methods revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This figure sums up where our understanding of methods is at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Understanding methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Understanding methods
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the figure, there are still a couple of question marks around
    methods. We will totally take the lid off methods and see how they work and what
    exactly the other parts of the method are doing later in the chapter. In [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming,*
    and [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More Object-Oriented
    Programming*, we will clear up the last few parts of the mystery of methods while
    discussing object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: What exactly are Java methods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method is a collection of variables, expressions, and control flow statements
    bundled together inside an opening and closing curly brace preceded by a **signature**.
    We have already been using lots of methods, but we just haven't looked very closely
    at them yet.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the method structure.
  prefs: []
  type: TYPE_NORMAL
- en: Method structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part of a method that we write is called the signature. Here is a
    hypothetical method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add an opening and closing pair of curly braces, `{}`, with some code
    that the method performs, then we have a complete method – a **definition**. Here
    is another made up yet syntactically correct method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen, we could then use our new method from another part of our
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At the point where we call the `setCoordinates` method, our program's execution
    would branch to the code contained within that method. The method would execute
    all the statements inside it, step by step, until it reaches the end, and then
    return control to the code that called it, or sooner if it hits a `return` statement.
    Then, the code would continue running from the first line after the method call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a method complete with the code to make the method
    return to the code that called it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to use the preceding method could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, we don't need to write methods to add two `int` variables together,
    but the example helps us see a little more into the workings of methods. First,
    we pass in the values `2` and `4`. In the method signature, the value `2` is assigned
    to `int a` and the value `4` is assigned to `int b`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the method body, the variables `a` and `b` are added together and used
    to initialize the new variable, `int answer`. The line `return answer` returns
    the value stored in `answer` to the calling code, causing `myAnswer` to be initialized
    with the value `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each of the method signatures in the preceding examples varies a
    little. The reason for this is the Java method signature is quite flexible, allowing
    us to build exactly the methods we need.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how the method signature defines how the method must be called and how
    the method must return a value deserves further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Let's give each part of the signature a name so we can break it up into pieces
    and learn about the parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following bolded text is a method signature with its parts labeled up ready
    for discussion. Also, have a look at the table that follows the bolded text to
    further clarify which part of the signature is which. This will make the rest
    of our discussion on methods straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**modifier** | **return-type** | **name of method (parameters)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16773_09_Table_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our earlier examples, we only used a modifier in a couple of examples, partly
    because the method doesn't have to use a modifier. The modifier is a way of specifying
    what code can use (call) your method, by using modifiers such as `public` and
    `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can have modifiers too, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Modifiers (for methods and variables) are an essential Java topic, but they
    are best dealt with when we are discussing the other vital Java topic we have
    skirted around a few times already – classes. We will do so in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next in the table is the return type. Like a modifier, a return type is optional.
    So, let''s look at it a bit closer. We have seen that our methods do anything
    we can code in Java. But what if we need the results from what a method has done?
    The simplest example of a return type we have seen so far is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the return type in the signature is highlighted. The return type is an
    `int`. The `addAToB` method sends back (returns) to the code that called it a
    value that will fit in an `int` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The return type can be any Java type we have seen so far. However, the method
    does not have to return a value at all. When the method does not return a value,
    the signature must use the `void` keyword as the return type. When the `void`
    keyword is used, the method body must not try to return a value as this will cause
    a compiler error. It can, however, use the `return` keyword without a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some combinations of the return type and use of the `return` keyword
    that are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another combination is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is yet another combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We could call each of the preceding methods in turn like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would execute all the code in each method in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Name of the method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next in the table is the name of the method. When we design our own methods,
    the method name is arbitrary. But it is the convention to use verbs that clearly
    explain what the method will do. Also, use the convention of the first letter
    of the first word of the name being lowercase and the first letter of any later
    words being uppercase. This is called camel case, as we learned while learning
    about variable names. Consider this next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method is perfectly legitimate and will work; however, let''s
    look at three much clearer examples that use these conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is much clearer as the names make it obvious what the methods will do.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the parameters in methods.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final topic in the table is **parameters**. We know that a method can return
    a result to the calling code. But what if we need to share some data values *from*
    the calling code *with* the method?
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters allow us to send values into the called method. We have already
    seen an example with parameters when we looked at return types. We will look at
    the same example but a little more closely at the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the parameters are highlighted. Parameters are contained in parentheses,
    `(parameters go here)`, immediately after the method name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the first line of the method body, we use `a + b` as if they
    are already declared and initialized variables. That is because they are. The
    parameters of the method signature are their declaration and the code that calls
    the method initializes them, as highlighted in the next line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Also, as we have partly seen in earlier examples, we don't have to just use
    `int` in our parameters. We can use any Java type, including types we design ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is more, we can mix and match types as well. We can also use as many parameters
    as is necessary to solve our problem. An example might help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example would have four declared and initialized variables that
    are ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at the method body – what goes inside the method.
  prefs: []
  type: TYPE_NORMAL
- en: The body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous examples, we have been pseudo-coding our method bodies with
    comments such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following has also been used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addToAddressBook` method has also been used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: But we know exactly what to do in the body already. Any Java syntax we have
    learned about so far will work in the body of a method. In fact, if we think back,
    all the code we have written in this book so far *has* been in a method.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing we can do next is to write a few methods that do something in
    the body.
  prefs: []
  type: TYPE_NORMAL
- en: Using method demo apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will quickly build two apps to explore methods a bit further. First,
    we will explore the fundamentals with the `Real World Methods` app, and then we
    will glimpse a new topic, `Exploring Method Overloading` app.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can open the ready-typed code files in the usual way. The next
    two examples of methods can be found in the download bundle in the [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)
    folder and the `Real World Methods` and `Exploring Method Overloading` sub-folders.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's make ourselves some simple working methods complete with return
    type parameters and fully functioning bodies.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create a new Android project called `Real World Methods`, use
    the `MainActivity.java` file by left-clicking the **MainActivity.java** tab above
    the editor and we can start coding.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add these three methods to the `MainActivity` class. Add them just after
    the closing curly brace, `}`, of the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first method we added is called `joinThese`. It will return a `String` value
    and needs three `String` variables passed into it. In the method body, there is
    only one line of code. The `return a + b + c` code will concatenate the three
    strings that are passed into it and return the joined strings as the result.
  prefs: []
  type: TYPE_NORMAL
- en: The next method, named `getAreaCircle`, takes a `float` variable as an argument
    and then returns a `float` variable too. The body of the method simply uses the
    formula for the area of a circle, incorporating the passed-in radius, and then
    returns the answer to the calling code. The odd-looking `f` on the end of `3.141`
    is to let the compiler know that the number is of the `float` type. Any floating-point
    number is assumed to be of the `double` type unless it has the trailing `f`.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final method is the simplest of all the methods. Notice that it
    doesn't return anything; it has a `void` return type. We have included this method
    to make clear an important point that we want to remember about methods. But let's
    see it in action before we talk about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `onCreate` method, after the call to the `setContentView` method,
    add this code, which calls our three new methods and then outputs some text to
    the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app and see the output in the logcat window, which is provided here
    for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the logcat output, the first thing we can see is the value of the `joinedString`
    string. As expected, it is the concatenation of the three words we passed into
    the `joinThese` method.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can see that `getAreaCircle` has indeed calculated and returned the
    area of a circle based on the length of the radius passed in.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the `a` variable still holds the value `0` even after it has been
    passed into the `changeA` method deserves a separate discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering variable scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final line of output is most interesting: `a=: 0`. In the `onCreate` method,
    we declared and initialized `int a` to `0`, and then we called the `changeA` method.
    In the body of `changeA`, we incremented `a` with the code `a++`. Yet, back in
    the `onCreate` method, we see that when we use the `Log.i` method to print the
    value of `a` to the logcat window, it is still **0**.'
  prefs: []
  type: TYPE_NORMAL
- en: So, when we passed in `a` to the `changeA` method, we were actually passing
    the *value* *stored in* *a* not the *actual variable* *a*. This is referred to
    as passing by value in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a variable in a method, it can only be *seen* in that method.
    When we declare a variable in another method, even if it has the exact same name,
    it is *not* the same variable. A variable only has **scope** within the method
    it was declared.
  prefs: []
  type: TYPE_NORMAL
- en: With all primitive variables, this is how passing them to methods works. With
    reference variables, it works slightly differently and we will see how in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: I have talked about this scope concept with a number of people new to Java.
    To some, it seems blindingly obvious, even natural. To others, however, it is
    a cause of constant confusion. Should you fall into the latter category, don't
    worry, because we will talk a bit more about this later in this chapter, and in
    future chapters, we will go into greater depth with exploring scope and make sure
    it is no longer an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another practical example of methods and learn something new at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring method overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are beginning to realize, methods are quite deep as a topic. But hopefully,
    by taking them a step at a time, we will see that they are not daunting in any
    way. We will also be returning to methods in the next chapter. For now, let's
    create a new project to explore the topic of **method overloading**.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Exploring Method` `Overloading`, then we will get on with writing
    three methods, but with a slight twist.
  prefs: []
  type: TYPE_NORMAL
- en: As we will soon see, we can create more than one method with the same name provided
    that the parameters are different. The code in this project is simple. It is how
    it works that might appear slightly curious until we analyze it after.
  prefs: []
  type: TYPE_NORMAL
- en: In the first method, we will simply call it `printStuff` and pass in an `int`
    variable via a parameter to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert this method after the closing `}` of the `onCreate` method but before
    the closing `}` of the `MainActivity` class. Remember to import the `Log` class
    in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this second method, we will also call it `printStuff` but pass in a `String`
    variable to be printed. Insert this method after the closing `}` of the `onCreate`
    method but before the closing `}` of the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this third method, we will call it `printStuff` yet again but pass in a
    `String` variable and an `int` value to be printed. Insert this method after the
    closing `}` of `onCreate` but before the closing `}` of the `MainActivity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, insert this code just before the closing `}` of the `onCreate` method
    to call the methods and print some values to the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the app on the emulator or a real device. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Java has treated three methods with the same name as different
    methods. This, as we have just shown, can be useful. It is called **method overloading**.
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading and overriding confusion
  prefs: []
  type: TYPE_NORMAL
- en: '**Overloading** is when we have more than one method with the same name but
    different parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overriding** is when we replace a method with the same name and the same
    parameter list.'
  prefs: []
  type: TYPE_NORMAL
- en: We know enough about overloading and overriding to complete this book; but if
    you are brave and your mind is wandering, yes, you can override an overloaded
    method, but that is something for another time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it all works. In each of the steps where we wrote code, we created
    a method called `printStuff`. But each `printStuff` method has different parameters,
    so each is actually a different method that can be called individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The body of each of the methods is trivial and just prints out the passed-in
    parameters and confirms which version of the method is being called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important part of our code is when we make it plain which version
    of the method we mean to call by using the specific arguments that match the parameters
    in the signature. In the final step, we call each method in turn, using the matching
    parameters so that Java knows the exact method required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We now know all we need to know about methods, so let's take a quick second
    look at the relationship between methods and variables. Then, we'll get our heads
    around this scope phenomenon a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and variables revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might remember in the `Real World Methods` project the slightly disturbing
    anomaly was that variables in one method were not apparently the same as those
    from another even if they do have the same name. If you declare a variable in
    a method, whether that is one of the life cycle methods or one of our own methods,
    it can only be used within that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is no use if we do this in `onCreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, following that, we try to do this in `onPause` or some other method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We will get an error because `a` is only visible within the method it was declared.
    At first, this might seem like a problem, but surprisingly, it is actually an
    especially useful feature of Java.
  prefs: []
  type: TYPE_NORMAL
- en: I have already mentioned that the term used to describe this is **scope**. A
    variable is said to be in scope when it is usable and out of scope when it is
    not. The topic of scope is best discussed along with classes, and we will do so
    in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented
    Programming,* and [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More
    Object-Oriented Programming*, but as a sneak look at what lies ahead, you might
    like to know that a class can have its very own variables and when it does, they
    have scope for the whole class; that is, all its methods can "see" and use them.
    We call them **member** variables or **fields**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a member variable, you simply use the usual syntax after the start
    of the class, outside of any method declared in the class. Say our app started
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We could use `mSomeVariable` anywhere, inside any method in this class. Our
    new variable, `mSomeVariable`, has `m` to the variable name simply to remind us
    when we see it that it is a **member** variable. This is not required by the compiler,
    but it is a useful convention.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more method topic before we move on to classes.
  prefs: []
  type: TYPE_NORMAL
- en: Method recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method recursion is when a method calls itself. This might at first seem like
    something that happens by mistake but is an efficient technique for solving some
    programming problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some code that shows a recursive method in its most basic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the `recursiveMethod` method, its only line of code will then call
    itself, which will then call itself, which will then call itself, and so on. This
    process will go on forever until the app crashes, giving the following error in
    Logcat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When the method is called, its instructions are moved to an area of the processor
    called the stack, and when it returns, its instructions are removed. If the method
    never returns and yet more and more copies of the instructions are added, eventually
    the stack will run out of memory (or overflow) and we get `StackOverflowError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attempt to visualize the first four method calls using the next screenshot.
    Also, in the next screenshot, I have crossed out the call to the method to show
    that if we were able to, at some point, prevent the method call, eventually all
    the methods would return and be cleared from the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Method calls'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Method calls
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our recursive methods worthwhile, we need to enhance two aspects. We
    will look at the second aspect shortly. First and most obviously, we need to give
    it a purpose. How about we ask our recursive method to sum (add up) the values
    of numbers in a range from 0 to a given target value, say 10, 100, or more? Let''s
    modify the preceding method by giving it this new purpose and renaming it accordingly.
    We will also add a variable with class scope (outside the method) called `answer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a method called `computeSum` that takes an `int` as a parameter.
    If we wanted to compute the sum of all the digits between 0 and 10, we could call
    the method like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the values of the `answer` variable at each function call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First call of `computeSum`: `answer` = 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second call of `computeSum`: `answer` = 19'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: 'Tenth call of `computeSum`: `answer` = 55'
  prefs: []
  type: TYPE_NORMAL
- en: Apparent success – until you realize that the method continues to call itself
    beyond the `target` variable reaching 0\. In fact, we still have the same problem
    as our first recursive method and after tens of thousands of method calls, the
    app will crash with `StackOverflowError` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is a way to stop the method calling itself once `target` is equal
    to 0\. The way we solve this problem is to check whether the value of `target`
    is 0 and if it is, we quit calling the method. Have a look at the additional highlighted
    code shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We have used an `if` statement to check whether the target variable is greater
    than 0\. We also have an additional `Log.d` code to output the value of `answer`
    when the method has been called for the last time. See whether you can work out
    what is happening before reading the explanation following the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of calling `computeSum(10)` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`if(target > 0)` tells the code to first check whether the `target` variable
    is above 0\. If it is, only then does it call the method again and pass in the
    value of `target – 1`. If it isn''t, then it stops the whole process.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We won't be using method recursion in this book, but it is an interesting concept
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: We know more than enough about methods to complete all the projects in the book.
    Let's have a quick recap with some questions and answers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is wrong with this method definition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'No return type is declared. You do not have to return a value from a method,
    but its return type must be `void` in this case. This is how the method should
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with this method definition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The method returns a string (`userName`) but the signature states that it must
    return a `float` type. With a method name like `getBalance`, this code is what
    was likely intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When do we call the `onCreate` method? (Trick question alert!)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't. Android decides when to call the `onCreate` method, as well as all
    the other methods that make up the lifecycle of an Activity. We just override
    the ones that are useful to us. We do, however, call `super.onCreate` so that
    our overridden version and the original version both get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of complete disclosure, it is technically possible to call the
    lifecycle methods from our code, but we will never need to in the context of this
    book. It is best to leave these things to Android.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first five chapters, we got quite proficient with a whole array of widgets
    and other UI elements. We also built a broad selection of UI layouts. In this
    chapter and the previous three, we have explored Java and the Android activity
    lifecycle in quite significant depth, especially considering how quickly we have
    done it.
  prefs: []
  type: TYPE_NORMAL
- en: We have, to a small extent, created interaction between our Java code and our
    UI. We have called our methods by setting the `onClick` attribute and we have
    loaded our UI layouts using the `setContentView` method. We haven't, however,
    really made a proper connection between our UI and our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: What we really need to do now is to bring these things together, so we can begin
    to display and manipulate our data using the Android UI. To achieve this, we need
    to understand a bit more about classes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes have been lurking in our code since [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,
    Beginning Android and Java*, and we have even used them a bit. Up until now, however,
    we haven't tackled them properly other than constantly referring to [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming*.
    In the next chapter, [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, we will quickly get to grips with classes, and then
    we can finally start to build apps where the UI designs and our Java code work
    in perfect harmony.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned enough Java to proceed with the book. It is always beneficial,
    however, to see more examples of Java in action and to go beyond the minimum necessary
    knowledge to proceed. If you want a good source to learn Java in greater depth,
    then the official Oracle website is good. Note that you do not need to study this
    website to continue with this book. Also, note that the tutorials on the Oracle
    website are not set in an Android context. The site is a useful resource to bookmark
    and browse all the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official Java tutorials: [https://docs.oracle.com/javase/tutorial/](https://docs.oracle.com/javase/tutorial/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official Android developer site: [https://developer.android.com/training/basics/firstapp](https://developer.android.com/training/basics/firstapp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
