- en: '*Chapter 9*: Learning Java Methods'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are starting to get comfortable with Java programming, in this chapter
    we will take a closer look at methods because although we know that you can **call**
    them to make them execute their code, there is more to them than we have discussed
    so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Method structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method overloading versus overriding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method demo mini-app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How methods affect our variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method recursion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's go through a quick method recap.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Methods revisited
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This figure sums up where our understanding of methods is at the moment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Understanding methods'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16773.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Understanding methods
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the figure, there are still a couple of question marks around
    methods. We will totally take the lid off methods and see how they work and what
    exactly the other parts of the method are doing later in the chapter. In [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming,*
    and [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More Object-Oriented
    Programming*, we will clear up the last few parts of the mystery of methods while
    discussing object-oriented programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: What exactly are Java methods?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method is a collection of variables, expressions, and control flow statements
    bundled together inside an opening and closing curly brace preceded by a **signature**.
    We have already been using lots of methods, but we just haven't looked very closely
    at them yet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the method structure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Method structure
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part of a method that we write is called the signature. Here is a
    hypothetical method signature:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we add an opening and closing pair of curly braces, `{}`, with some code
    that the method performs, then we have a complete method – a **definition**. Here
    is another made up yet syntactically correct method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we have seen, we could then use our new method from another part of our
    code like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the point where we call the `setCoordinates` method, our program's execution
    would branch to the code contained within that method. The method would execute
    all the statements inside it, step by step, until it reaches the end, and then
    return control to the code that called it, or sooner if it hits a `return` statement.
    Then, the code would continue running from the first line after the method call.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a method complete with the code to make the method
    return to the code that called it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The call to use the preceding method could look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clearly, we don't need to write methods to add two `int` variables together,
    but the example helps us see a little more into the workings of methods. First,
    we pass in the values `2` and `4`. In the method signature, the value `2` is assigned
    to `int a` and the value `4` is assigned to `int b`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Within the method body, the variables `a` and `b` are added together and used
    to initialize the new variable, `int answer`. The line `return answer` returns
    the value stored in `answer` to the calling code, causing `myAnswer` to be initialized
    with the value `6`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Notice that each of the method signatures in the preceding examples varies a
    little. The reason for this is the Java method signature is quite flexible, allowing
    us to build exactly the methods we need.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Exactly how the method signature defines how the method must be called and how
    the method must return a value deserves further discussion.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Let's give each part of the signature a name so we can break it up into pieces
    and learn about the parts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The following bolded text is a method signature with its parts labeled up ready
    for discussion. Also, have a look at the table that follows the bolded text to
    further clarify which part of the signature is which. This will make the rest
    of our discussion on methods straightforward:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**modifier** | **return-type** | **name of method (parameters)**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16773_09_Table_1.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: Modifier
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our earlier examples, we only used a modifier in a couple of examples, partly
    because the method doesn't have to use a modifier. The modifier is a way of specifying
    what code can use (call) your method, by using modifiers such as `public` and
    `private`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can have modifiers too, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Modifiers (for methods and variables) are an essential Java topic, but they
    are best dealt with when we are discussing the other vital Java topic we have
    skirted around a few times already – classes. We will do so in the next chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next in the table is the return type. Like a modifier, a return type is optional.
    So, let''s look at it a bit closer. We have seen that our methods do anything
    we can code in Java. But what if we need the results from what a method has done?
    The simplest example of a return type we have seen so far is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the return type in the signature is highlighted. The return type is an
    `int`. The `addAToB` method sends back (returns) to the code that called it a
    value that will fit in an `int` variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The return type can be any Java type we have seen so far. However, the method
    does not have to return a value at all. When the method does not return a value,
    the signature must use the `void` keyword as the return type. When the `void`
    keyword is used, the method body must not try to return a value as this will cause
    a compiler error. It can, however, use the `return` keyword without a value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some combinations of the return type and use of the `return` keyword
    that are valid:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another combination is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code is yet another combination:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We could call each of the preceding methods in turn like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code would execute all the code in each method in turn.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Name of the method
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next in the table is the name of the method. When we design our own methods,
    the method name is arbitrary. But it is the convention to use verbs that clearly
    explain what the method will do. Also, use the convention of the first letter
    of the first word of the name being lowercase and the first letter of any later
    words being uppercase. This is called camel case, as we learned while learning
    about variable names. Consider this next example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding method is perfectly legitimate and will work; however, let''s
    look at three much clearer examples that use these conventions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is much clearer as the names make it obvious what the methods will do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the parameters in methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final topic in the table is **parameters**. We know that a method can return
    a result to the calling code. But what if we need to share some data values *from*
    the calling code *with* the method?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters allow us to send values into the called method. We have already
    seen an example with parameters when we looked at return types. We will look at
    the same example but a little more closely at the parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the parameters are highlighted. Parameters are contained in parentheses,
    `(parameters go here)`, immediately after the method name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that in the first line of the method body, we use `a + b` as if they
    are already declared and initialized variables. That is because they are. The
    parameters of the method signature are their declaration and the code that calls
    the method initializes them, as highlighted in the next line of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Also, as we have partly seen in earlier examples, we don't have to just use
    `int` in our parameters. We can use any Java type, including types we design ourselves.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'What is more, we can mix and match types as well. We can also use as many parameters
    as is necessary to solve our problem. An example might help:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding example would have four declared and initialized variables that
    are ready to use.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Now we will look at the method body – what goes inside the method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The body
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous examples, we have been pseudo-coding our method bodies with
    comments such as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following has also been used:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `addToAddressBook` method has also been used:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But we know exactly what to do in the body already. Any Java syntax we have
    learned about so far will work in the body of a method. In fact, if we think back,
    all the code we have written in this book so far *has* been in a method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The best thing we can do next is to write a few methods that do something in
    the body.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Using method demo apps
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will quickly build two apps to explore methods a bit further. First,
    we will explore the fundamentals with the `Real World Methods` app, and then we
    will glimpse a new topic, `Exploring Method Overloading` app.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can open the ready-typed code files in the usual way. The next
    two examples of methods can be found in the download bundle in the [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)
    folder and the `Real World Methods` and `Exploring Method Overloading` sub-folders.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Real-world methods
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's make ourselves some simple working methods complete with return
    type parameters and fully functioning bodies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create a new Android project called `Real World Methods`, use
    the `MainActivity.java` file by left-clicking the **MainActivity.java** tab above
    the editor and we can start coding.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add these three methods to the `MainActivity` class. Add them just after
    the closing curly brace, `}`, of the `onCreate` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first method we added is called `joinThese`. It will return a `String` value
    and needs three `String` variables passed into it. In the method body, there is
    only one line of code. The `return a + b + c` code will concatenate the three
    strings that are passed into it and return the joined strings as the result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The next method, named `getAreaCircle`, takes a `float` variable as an argument
    and then returns a `float` variable too. The body of the method simply uses the
    formula for the area of a circle, incorporating the passed-in radius, and then
    returns the answer to the calling code. The odd-looking `f` on the end of `3.141`
    is to let the compiler know that the number is of the `float` type. Any floating-point
    number is assumed to be of the `double` type unless it has the trailing `f`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The third and final method is the simplest of all the methods. Notice that it
    doesn't return anything; it has a `void` return type. We have included this method
    to make clear an important point that we want to remember about methods. But let's
    see it in action before we talk about it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `onCreate` method, after the call to the `setContentView` method,
    add this code, which calls our three new methods and then outputs some text to
    the logcat window:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the app and see the output in the logcat window, which is provided here
    for your convenience:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the logcat output, the first thing we can see is the value of the `joinedString`
    string. As expected, it is the concatenation of the three words we passed into
    the `joinThese` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can see that `getAreaCircle` has indeed calculated and returned the
    area of a circle based on the length of the radius passed in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the `a` variable still holds the value `0` even after it has been
    passed into the `changeA` method deserves a separate discussion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Discovering variable scope
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final line of output is most interesting: `a=: 0`. In the `onCreate` method,
    we declared and initialized `int a` to `0`, and then we called the `changeA` method.
    In the body of `changeA`, we incremented `a` with the code `a++`. Yet, back in
    the `onCreate` method, we see that when we use the `Log.i` method to print the
    value of `a` to the logcat window, it is still **0**.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: So, when we passed in `a` to the `changeA` method, we were actually passing
    the *value* *stored in* *a* not the *actual variable* *a*. This is referred to
    as passing by value in Java.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: When we declare a variable in a method, it can only be *seen* in that method.
    When we declare a variable in another method, even if it has the exact same name,
    it is *not* the same variable. A variable only has **scope** within the method
    it was declared.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: With all primitive variables, this is how passing them to methods works. With
    reference variables, it works slightly differently and we will see how in the
    next chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: I have talked about this scope concept with a number of people new to Java.
    To some, it seems blindingly obvious, even natural. To others, however, it is
    a cause of constant confusion. Should you fall into the latter category, don't
    worry, because we will talk a bit more about this later in this chapter, and in
    future chapters, we will go into greater depth with exploring scope and make sure
    it is no longer an issue.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another practical example of methods and learn something new at
    the same time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Exploring method overloading
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are beginning to realize, methods are quite deep as a topic. But hopefully,
    by taking them a step at a time, we will see that they are not daunting in any
    way. We will also be returning to methods in the next chapter. For now, let's
    create a new project to explore the topic of **method overloading**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Exploring Method` `Overloading`, then we will get on with writing
    three methods, but with a slight twist.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: As we will soon see, we can create more than one method with the same name provided
    that the parameters are different. The code in this project is simple. It is how
    it works that might appear slightly curious until we analyze it after.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In the first method, we will simply call it `printStuff` and pass in an `int`
    variable via a parameter to be printed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert this method after the closing `}` of the `onCreate` method but before
    the closing `}` of the `MainActivity` class. Remember to import the `Log` class
    in the usual way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this second method, we will also call it `printStuff` but pass in a `String`
    variable to be printed. Insert this method after the closing `}` of the `onCreate`
    method but before the closing `}` of the `MainActivity` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this third method, we will call it `printStuff` yet again but pass in a
    `String` variable and an `int` value to be printed. Insert this method after the
    closing `}` of `onCreate` but before the closing `}` of the `MainActivity` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, insert this code just before the closing `}` of the `onCreate` method
    to call the methods and print some values to the logcat window:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can run the app on the emulator or a real device. Here is the output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, Java has treated three methods with the same name as different
    methods. This, as we have just shown, can be useful. It is called **method overloading**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Method overloading and overriding confusion
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**Overloading** is when we have more than one method with the same name but
    different parameters.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**Overriding** is when we replace a method with the same name and the same
    parameter list.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: We know enough about overloading and overriding to complete this book; but if
    you are brave and your mind is wandering, yes, you can override an overloaded
    method, but that is something for another time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it all works. In each of the steps where we wrote code, we created
    a method called `printStuff`. But each `printStuff` method has different parameters,
    so each is actually a different method that can be called individually:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The body of each of the methods is trivial and just prints out the passed-in
    parameters and confirms which version of the method is being called.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important part of our code is when we make it plain which version
    of the method we mean to call by using the specific arguments that match the parameters
    in the signature. In the final step, we call each method in turn, using the matching
    parameters so that Java knows the exact method required:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We now know all we need to know about methods, so let's take a quick second
    look at the relationship between methods and variables. Then, we'll get our heads
    around this scope phenomenon a bit more.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Scope and variables revisited
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might remember in the `Real World Methods` project the slightly disturbing
    anomaly was that variables in one method were not apparently the same as those
    from another even if they do have the same name. If you declare a variable in
    a method, whether that is one of the life cycle methods or one of our own methods,
    it can only be used within that method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'It is no use if we do this in `onCreate`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then, following that, we try to do this in `onPause` or some other method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will get an error because `a` is only visible within the method it was declared.
    At first, this might seem like a problem, but surprisingly, it is actually an
    especially useful feature of Java.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: I have already mentioned that the term used to describe this is **scope**. A
    variable is said to be in scope when it is usable and out of scope when it is
    not. The topic of scope is best discussed along with classes, and we will do so
    in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented
    Programming,* and [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More
    Object-Oriented Programming*, but as a sneak look at what lies ahead, you might
    like to know that a class can have its very own variables and when it does, they
    have scope for the whole class; that is, all its methods can "see" and use them.
    We call them **member** variables or **fields**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a member variable, you simply use the usual syntax after the start
    of the class, outside of any method declared in the class. Say our app started
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We could use `mSomeVariable` anywhere, inside any method in this class. Our
    new variable, `mSomeVariable`, has `m` to the variable name simply to remind us
    when we see it that it is a **member** variable. This is not required by the compiler,
    but it is a useful convention.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at one more method topic before we move on to classes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Method recursion
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method recursion is when a method calls itself. This might at first seem like
    something that happens by mistake but is an efficient technique for solving some
    programming problems.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some code that shows a recursive method in its most basic form:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we call the `recursiveMethod` method, its only line of code will then call
    itself, which will then call itself, which will then call itself, and so on. This
    process will go on forever until the app crashes, giving the following error in
    Logcat:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the method is called, its instructions are moved to an area of the processor
    called the stack, and when it returns, its instructions are removed. If the method
    never returns and yet more and more copies of the instructions are added, eventually
    the stack will run out of memory (or overflow) and we get `StackOverflowError`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attempt to visualize the first four method calls using the next screenshot.
    Also, in the next screenshot, I have crossed out the call to the method to show
    that if we were able to, at some point, prevent the method call, eventually all
    the methods would return and be cleared from the stack:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Method calls'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16773.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Method calls
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our recursive methods worthwhile, we need to enhance two aspects. We
    will look at the second aspect shortly. First and most obviously, we need to give
    it a purpose. How about we ask our recursive method to sum (add up) the values
    of numbers in a range from 0 to a given target value, say 10, 100, or more? Let''s
    modify the preceding method by giving it this new purpose and renaming it accordingly.
    We will also add a variable with class scope (outside the method) called `answer`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we have a method called `computeSum` that takes an `int` as a parameter.
    If we wanted to compute the sum of all the digits between 0 and 10, we could call
    the method like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here are the values of the `answer` variable at each function call:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'First call of `computeSum`: `answer` = 10'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Second call of `computeSum`: `answer` = 19'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Tenth call of `computeSum`: `answer` = 55'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Apparent success – until you realize that the method continues to call itself
    beyond the `target` variable reaching 0\. In fact, we still have the same problem
    as our first recursive method and after tens of thousands of method calls, the
    app will crash with `StackOverflowError` again.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need is a way to stop the method calling itself once `target` is equal
    to 0\. The way we solve this problem is to check whether the value of `target`
    is 0 and if it is, we quit calling the method. Have a look at the additional highlighted
    code shown next:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have used an `if` statement to check whether the target variable is greater
    than 0\. We also have an additional `Log.d` code to output the value of `answer`
    when the method has been called for the last time. See whether you can work out
    what is happening before reading the explanation following the output.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of calling `computeSum(10)` would be as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`if(target > 0)` tells the code to first check whether the `target` variable
    is above 0\. If it is, only then does it call the method again and pass in the
    value of `target – 1`. If it isn''t, then it stops the whole process.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: We won't be using method recursion in this book, but it is an interesting concept
    to understand.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: We know more than enough about methods to complete all the projects in the book.
    Let's have a quick recap with some questions and answers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is wrong with this method definition?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'No return type is declared. You do not have to return a value from a method,
    but its return type must be `void` in this case. This is how the method should
    look:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What is wrong with this method definition?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The method returns a string (`userName`) but the signature states that it must
    return a `float` type. With a method name like `getBalance`, this code is what
    was likely intended:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When do we call the `onCreate` method? (Trick question alert!)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't. Android decides when to call the `onCreate` method, as well as all
    the other methods that make up the lifecycle of an Activity. We just override
    the ones that are useful to us. We do, however, call `super.onCreate` so that
    our overridden version and the original version both get executed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of complete disclosure, it is technically possible to call the
    lifecycle methods from our code, but we will never need to in the context of this
    book. It is best to leave these things to Android.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first five chapters, we got quite proficient with a whole array of widgets
    and other UI elements. We also built a broad selection of UI layouts. In this
    chapter and the previous three, we have explored Java and the Android activity
    lifecycle in quite significant depth, especially considering how quickly we have
    done it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: We have, to a small extent, created interaction between our Java code and our
    UI. We have called our methods by setting the `onClick` attribute and we have
    loaded our UI layouts using the `setContentView` method. We haven't, however,
    really made a proper connection between our UI and our Java code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: What we really need to do now is to bring these things together, so we can begin
    to display and manipulate our data using the Android UI. To achieve this, we need
    to understand a bit more about classes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在真正需要做的是将这些东西结合起来，这样我们就可以开始使用Android UI来显示和操作我们的数据。为了实现这一点，我们需要更多地了解类的知识。
- en: Classes have been lurking in our code since [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,
    Beginning Android and Java*, and we have even used them a bit. Up until now, however,
    we haven't tackled them properly other than constantly referring to [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming*.
    In the next chapter, [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, we will quickly get to grips with classes, and then
    we can finally start to build apps where the UI designs and our Java code work
    in perfect harmony.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 自从《第1章》《开始Android和Java》以来，类一直潜伏在我们的代码中，我们甚至有点使用它们。然而，直到现在，除了不断地参考《第10章》《面向对象编程》之外，我们还没有适当地解决它们。在下一章《第10章》《面向对象编程》中，我们将快速掌握类的知识，然后我们终于可以开始构建应用程序，使UI设计和我们的Java代码完美地协同工作。
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We have learned enough Java to proceed with the book. It is always beneficial,
    however, to see more examples of Java in action and to go beyond the minimum necessary
    knowledge to proceed. If you want a good source to learn Java in greater depth,
    then the official Oracle website is good. Note that you do not need to study this
    website to continue with this book. Also, note that the tutorials on the Oracle
    website are not set in an Android context. The site is a useful resource to bookmark
    and browse all the same:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到了足够的Java知识来继续阅读本书。然而，看到更多Java实例并超越最低必要的知识总是有益的。如果你想要一个学习Java更深入的好资源，那么官方的Oracle网站是一个不错的选择。请注意，您不需要学习这个网站来继续阅读本书。另外，请注意，Oracle网站上的教程并不是在Android环境中设置的。该网站是一个有用的资源，可以收藏并浏览：
- en: 'The official Java tutorials: [https://docs.oracle.com/javase/tutorial/](https://docs.oracle.com/javase/tutorial/)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Java教程：[https://docs.oracle.com/javase/tutorial/](https://docs.oracle.com/javase/tutorial/)
- en: 'The official Android developer site: [https://developer.android.com/training/basics/firstapp](https://developer.android.com/training/basics/firstapp)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Android开发者网站：[https://developer.android.com/training/basics/firstapp](https://developer.android.com/training/basics/firstapp)
