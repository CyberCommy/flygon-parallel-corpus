- en: High Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nothing is more disappointing than having to deal with issues in production
    when an application is behaving in an unexpected way. In this chapter, we are
    going to discuss some simple techniques that can be applied in order to get rid
    of these annoying problems, applying simple recommendations to your daily routine
    to take care of the performance of your applications. Throughout this chapter,
    we are going to review the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why performance matters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key recommendations to keep your software away from performance issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL query optimizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by introducing the importance of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Why performance matters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last two decades as a consultant, I visited several government institutions,
    banks, and financial institutions, establishing a common factor for a lack of
    performance in applications that are working in production, and I found common
    issues that can be avoided if you use a set of good practices as part of your
    SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to pay close attention to performance, because it brings huge
    trouble to companies, project sponsors, and customers since an application that
    faces this problem brings dissatisfaction on several levels.
  prefs: []
  type: TYPE_NORMAL
- en: Before giving recommendations, we are going to review and understand the non-functional
    requirements of scalability, availability, and performance.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This describes the capacity of a system to deal with to a high workload and
    to increase its capacity in order to resolve more requests based on the demand
    for work.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is resolved by adding additional nodes with all the functionality of your
    system, redistributing the requests, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07407738-e2aa-4e2b-8a7c-2824e2c98a6f.png)'
  prefs: []
  type: TYPE_IMG
- en: Horizontal scalability
  prefs: []
  type: TYPE_NORMAL
- en: Vertical scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use vertical scaling by adding resources (such as the RAM, CPU, or hard
    disk) to the node or server, and so on, to process more requests for our system.
    One common practice that I saw is that it adds more hardware to the database server
    to better perform the multiple connections that are using it; we can only scale
    a service by adding more resources, as the following diagram shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c711bfde-11e4-4757-9e8d-66adcf3157ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Vertical scalability
  prefs: []
  type: TYPE_NORMAL
- en: High availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This refers to the capacity to guarantee that a system provides a service or
    resource continuously. This capacity is directly associated to the **Service Level
    Agreement** (**SLA**).
  prefs: []
  type: TYPE_NORMAL
- en: An SLA is calculated based on the maintenance window of the system, and SLAs
    define whether a system should scale up or out.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the capacity of the responsiveness of a system to execute any action
    within a given time interval. As part of software systems, we need to start defining
    measurable performance goals such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum or average response time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The average amount of concurrent users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of requests per second during high load or concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The principal challenge that we have today as developers is the number of customers
    and devices that our application must handle, and, even more, whether our application
    is going to run on the internet or within an intranet only. The following diagram
    shows the topology of how an application is usually deployed and consumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd66e4d6-2cec-4366-a347-5bfaa97bf0ff.png)'
  prefs: []
  type: TYPE_IMG
- en: High-load requests to a system
  prefs: []
  type: TYPE_NORMAL
- en: After understanding the principal concepts behind performance, scalability,
    and availability, let's review some key recommendations to increase the performance
    of applications.
  prefs: []
  type: TYPE_NORMAL
- en: The key recommendation to avoid performance issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common to use load testing tools, **Application Performance Monitors**
    (**APMs**), and profiling tools to find and fix performance issues in software
    systems. To simulate the number of users in production, we need to run load test-creating
    scenarios for the most commonly used functionalities of our system, and, at the
    same time, track and monitor the application health-measuring resources such as
    CPU, RAM, IO, heap usage, threads, and database access. At the output of these
    process, we can give some key recommendations to keep your software away from
    performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we are going to explain the most common bottlenecks
    that we can find, and how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying bottlenecks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise applications become more complex every day. When the business succeeds,
    the application supporting that business will have more users, which means a bigger
    load received every day, so we need to take care of the performance bottlenecks
    that could appear.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the term **bottleneck**, we are going to give a simple definition.
    In software systems, a bottleneck happens when the function of an application
    or a system is starting to be limited for a single component, and it is like comparing
    the neck of a bottle slowing down overall water flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we can see a bottleneck if our application starts to perform
    slowly or starts to exceed the anticipated response time . This can happen for
    different kinds of bottlenecks, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU**: This happens when this resource is busy and cannot respond to the
    system properly. It is common to start having this bottleneck when we start to
    see CPU at utilization exceed 80% for extended periods of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory**: This happens when the system doesn''t have enough RAM or fast RAM.
    Sometimes the application logs show out-of-memory exceptions or leak-of-memory
    problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network**: Associated with a lack of necessary bandwidth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application itself, code problems, too many exceptions not being controlled,
    poor use of resources, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using APMs to identify bottlenecks  is a good approach because an APM can collect
    runtime information without slowing down application performance.
  prefs: []
  type: TYPE_NORMAL
- en: To identify bottlenecks, we can use a couple of practices; load testing and
    monitor tools, or profiling tools. The following section explains profiling tools.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can look at our code and start to profile the parts of the system we suspect
    have performance issues, or we can use a profiler and obtain information about
    the entire system as a whole. These tools gather runtime data and monitor resource
    consumption in terms of CPU, memory, threads, classes, and I/O.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several tools available for profiling Java applications, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tools that come with the JVM, such as VisualVM, JStat, JMap, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized tools, such as JProfiler, Java Mision Control, and Yourkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight profilers that come with APMs, like those we saw in [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml),
    *Monitoring*, using New Relic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a visual tool integrated as part of the JDK, which has the capability
    to profile applications. Let's run our banking app from the previous chapters,
    and review which information we can gather using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run our previous banking application, go to the project folder and run the
    following via the command line: `java -jar build/libs/banking-app-1.0.jar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to use the VisualVM to gather some metrics about the JVM.
    We can run this tool from the console using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see a screen similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12186fb2-07fe-45c2-b73c-7ffc34c653db.png)'
  prefs: []
  type: TYPE_IMG
- en: Java VisualVM
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Locals menu option, you have to attach the Java process that is going
    to be monitored. In this case, we are going to select banking-app-1.0.jar. Then,
    we should see a resume of the resources used for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ec75a25-90ec-4440-a3a1-3602ac6a55c5.png)'
  prefs: []
  type: TYPE_IMG
- en: VisualVM CPU, RAM, classes, and threads
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a tab that provides information about Threads, which is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1893b4e3-a122-471f-ab36-236c5f8e778c.png)'
  prefs: []
  type: TYPE_IMG
- en: VisualVM threads
  prefs: []
  type: TYPE_NORMAL
- en: We can use any tool that we feel comfortable with; a great place to start, and
    a tool that is easy to use is Jprofiler, but all the tools give us similar information.
    We need to understand and follow the possible problems generated by any bottleneck
    that we find in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging performance issues in production can be a difficult task, and, in
    some cases hard to find and fix. We need a tool that we can feel confident about
    to understand the bottlenecks, so we need to try different tools and experiment
    load tests to find the right one for us.
  prefs: []
  type: TYPE_NORMAL
- en: Don't optimize before you know it's necessary; first, run the application and
    run a load test to see whether we can approach the non-functional requirements
    defined for performance.
  prefs: []
  type: TYPE_NORMAL
- en: SQL query optimizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Optimizing queries and the data access layer of your enterprise application
    is key to avoiding bottlenecks and performance issues. We can use New Relic as
    an APM, and this will help us to detect bottlenecks and performance problems using
    database access graphics. With these graphics, we can find the SQL sentences used
    by your application, finding delay transactions or blocked tables if we continue
    to drilldown the information until we can also find the most SQL sentences used
    and the number of connections managed, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/414aa751-dcba-464d-8f68-40dc3a952b0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Database metrics from New Relic
  prefs: []
  type: TYPE_NORMAL
- en: 'From the app, we can identify the queries most used and check for opportunities
    to optimize them. We would need indexes or to refactor our code to get better
    performance. On the other hand, without using an APM or a profiling tool, we can
    use a number of techniques to improve our SQL and data access layers, such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Review SQL sentences**: This reviews the SQL sentences executed and optimized
    one by one via the profiler or the APM, applying indexes, choosing the right column
    types, and optimizing relationships using native queries when necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JDBC batch**: This uses `prepared` statements for batching, and some databases
    such as Oracle support batching for `prepared` statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection managing**: This reviews the use of the connection pool, and measure
    and set the correct pool size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale up and scale out**: This is explained in the *Scalability* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: This uses in-memory buffer structures to avoid disk access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid ORM**: **Object Relational Mapping** (**ORM**) tools are used to treat database
    tables as Java Objects to persist information. However, in some cases, it is better
    to use plain SQL statements to avoid unnecessary joins, which lead us to improve
    the performance of applications and databases at the same time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at how to simulate virtual users in order
    to create a load test for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: A load test example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load tests are used to check how an application will behave once it is used
    for a determined number of concurrent users; the number of concurrent users is
    given for the number of users that the application will have in production. You
    should always define a performance test suite that tests the whole application
    with tools such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Neoload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache JMeter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load Runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rational Performance Tester
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to define a load test and profile as part of a pipeline of our applications,
    and run it before and after we work on performance improvement. We are going to
    create an example using Neoload to review these key recommendations in our application
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define a scenario to run a load test; in our case, we are
    going to take the banking application from [Chapter 12](f58465fa-861d-4800-a2a3-fe19c06e8789.xhtml),
    *Monitoring*, that is ready to use, and define a functional common scenario such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user is going to log in using the credentials: `rene`/`rene`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the user will click on the menu notifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And finally, the user is going to click on the logout link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we are going to download Neoload from the following URL: [https://www.neotys.com/download.](https://www.neotys.com/download)'
  prefs: []
  type: TYPE_NORMAL
- en: Neoload gives us a trial version where we can simulate up to 50 virtual concurrent
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Neoload, we are going to open the application and create a
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e59455fe-eb5c-40d5-b289-2182c806683e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we are going to click on Start Recording, and choose the browser that
    we are going to use to record our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa10d02d-71cf-42dd-ba4a-32b9237dd5c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the browser, we are going to enter the URL of our application: `http://localhost:8080/login`,
    and navigate as a user to list the notification set of our customer. So the process
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the menu notifications
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on logout
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the host that we are recording, which in our case is localhost, and
    follow the next instructions until the end. Finally, we are going click on the
    Stop recording button and we should see in the left-hand menu that our actions
    are recorded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91ed11b1-338d-45f3-82d7-8e731a976a2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are then going to run the recorded scenario by clicking on the check icon
    that can be seen hovering over the user icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/718b6a6a-f4f9-410b-ab1e-0f80fed17c72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We should see that our scenario runs without errors, simulating one concurrent
    user, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb15e5b7-4176-49e9-8745-62e657e0cd3f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s generate load testing, creating a population (casual user simulated
    scenario):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c427bd33-70c5-4ab1-8234-d85a170faedd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click on the Runtime icon to run the load test with 10 concurrent users
    for 2 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffe1f2a6-dbb2-4414-8004-2f9ec8ffbc55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And then, click on the play icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05c9f54d-0d3c-4142-895f-2e78e442a949.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, after the test finishes, we can check the results; denoting that we
    visited 670 pages and made 890 requests during the load test time, using 20 concurrent
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/953bb0e2-b9a5-4bac-b8f6-cb429f645b20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, during the load test using VisualVM, we can check the performance
    of our application and see how it performs at checking the threads, as demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16bfcc40-b147-4764-858a-1cf091d3e859.png)'
  prefs: []
  type: TYPE_IMG
- en: We are going to find that the JVM, memory, and threads, with a simulation of
    virtual users, look different than just navigating on the application.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth monitoring all the resources of an application when you run load
    tests to identify where an issue can rise.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have learned that using a profiler tool or an APM, in addition to
    a load test tool, can guarantee that our applications and system work on performance
    improvements before we launch our code to production environments.
  prefs: []
  type: TYPE_NORMAL
- en: After adding code to improve the performance of an application, it is always
    a good idea to run performance tests in order to check how well the changes have
    been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we explained the meaning of scalability, availability,
    and performance. We also learned how to apply some techniques and tools to avoid
    dealing with performance issues in production and, consequently, how we can improve
    the performance of our applications to achieve a better response times.
  prefs: []
  type: TYPE_NORMAL
