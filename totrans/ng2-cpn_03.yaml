- en: Chapter 3. The TypeScript Primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular 2 is written with TypeScript, but that doesn't mean we have to write
    our application with TypeScript. Angular 2 applications can be written with ES6
    (JavaScript 2015) or even ES5 (JavaScript 1.5). In this book, we will use TypeScript,
    mainly (but not only) because of the implementations of decorators, which can
    clean our Angular 2 code compared to ES6 and ES5.
  prefs: []
  type: TYPE_NORMAL
- en: I will assume that you already know how to write JavaScript 2015 (ES6) code.
    Through this chapter, we will cover just what we need to know about TypeScript;
    most of the code is compatible with JavaScript 2015 as is. If you are not familiar
    with ES6 at all, it's highly recommended to catch up with the new syntax and features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the TypeScript language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage dependencies with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class declarations and usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System, built-in, and custom types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important thing that you should know about TypeScript is that it's
    not a completely new language. It's a superset of ES6\. This means an ES6 code
    can be *converted* to TypeScript just by changing the file extension from `.js`
    to `.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code is a valid ES6 or TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, the TypeScript compiler can target various versions of JavaScript,
    including ES6\. The compiler will peel all the *extra* code and output clean and
    readable JavaScript code that is almost identical to the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple TypeScript class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Targeting ES6 will output this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the completion result when targeting ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the compilation results in a clean and readable code, which
    is almost identical to the source code (in case of ES6).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the language features. Note that most of the features
    that we will go through are part of ES6 and not TypeScript. I will mention which
    feature belongs to TypeScript and which does not.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important changes introduced in JavaScript is modules. A module
    is a JavaScript file that gets loaded in a special way. All variables and declarations
    are scoped to the module. If we like to expose some code to the outside world,
    we need to export it explicitly. If you try to log the value of `this` in the
    top level of the module, you will get undefined.
  prefs: []
  type: TYPE_NORMAL
- en: The export and import statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `export` and `import` keywords are used to define which part of the code
    should be exposed to other modules, and which code we will like to import from
    another module. The following module exposes a function, a class, and a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this exported code, we need to import it in another module. We can import
    this code in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The default exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can import only what we need from the module, import multiple code and import
    everything that the module exported. There is another option to export code from
    a module, which is called a `default` export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When importing code that is exported using the default keyword, we don''t have
    to use the exact name of the function or class or variable that we exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A `default` export can be declared only once per module. We can mix the default
    and named exports in the same module. Note that we don't have to use curly braces
    when importing code that has been exported as default.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The JavaScript language''s object-oriented capabilities are built around the
    concept of prototypes. The prototype model defines links between objects, instead
    of inheritance trees. The prototype model, as powerful as it is, is not very friendly
    to the average JavaScript programmer. TypeScript enables us to create classes
    with a familiar syntax, and it''s completely identical to JavaScript 1.5 classes
    (if we choose not to use TypeScript exclusive features). To define a class in
    TypeScript, we use the `class` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes in TypeScript might have a constructor and methods just like JavaScript
    2015\. TypeScript also adds the ability to define class properties. The following
    example shows our `Product` class with a constructor, property, and a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, just like JavaScript 2015, inheritance is achieved through the
    `extends` keyword, and the `super` keyword is used to call the parent class when
    necessary. The following example illustrates how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It's important to realize that classes are just a *sugar* on top of prototypes.
    This means the way JavaScript deals with objects' instantiation and inheritance
    behind the scenes hasn't changed. It just has a friendly syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular 2, the component that contains all the component behavior is defined
    as a class. The rest is just a metadata decorator, which we will learn about in
    the future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The type system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most famous feature that made TypeScript what it is, is the type system
    that enables us to leverage a static type checking at compile time. We have already
    seen the use of types in the previous code examples. It's important to understand
    that in TypeScript the use of types is optional but highly recommended. As we
    saw at the beginning of this chapter, the TypeScript compiler breakdown all the
    types declaration, so the compilation result will be plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The basic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript supports all the basic JavaScript types you expected: Booleans,
    Numbers, Strings, and Arrays. The following example shows how to use it in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript also includes extra three types to the mix, namely, `enum`, `any`,
    and `void`. The type `any`, as the name suggests, is used when we are dealing
    with dynamic data and we can''t tell which type of data we are expecting. If we
    don''t specify a type at all, TypeScript defaults to the `any` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `void` type is like the opposite of `any`. It means *no type*. Most of
    the time, it is used as a return type for a function that doesn''t return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'An `enum` is just a way of giving more friendly names to sets of numeric values.
    Nothing more. The default numbering starts with `0`, and can be set manually to
    any other numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The custom types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the built-in basic types, you can (and you probably will) use your own
    types for code that you have written. There are three ways in TypeScript to define
    types, namely, creating a class, defining an interface, and using special files
    that declare types for an existing library.
  prefs: []
  type: TYPE_NORMAL
- en: An interface in TypeScript can be described as the *shape* of the object, and
    usually includes class members and methods without implementation. Interfaces
    are only at design time; for example, you can't use it as type when defining providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how to use your own classes as types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example illustrates how to create an interface for defining a
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The third option is to create a file with a `.d.ts` extension, which maps an
    existing code (third party) to types. The process of creating this file is behind
    the scope of this book, and you can visit [http://www.typescriptlang.org/Handbook#writing-dts-files](http://www.typescriptlang.org/Handbook#writing-dts-files)
    to learn more about it.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you can find the Definition map for almost any library
    out there (including Angular). Visit [https://github.com/typings/typings](https://github.com/typings/typings)
    where you can browse for repositories of Definition maps, and learn more about
    typings, which is a command-line tool for managing those maps.
  prefs: []
  type: TYPE_NORMAL
- en: About generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another feature that is related to types and that should be mentioned,
    called *generics*. This feature enables us to create a component that can work
    over a variety of types rather than a single one.
  prefs: []
  type: TYPE_NORMAL
- en: The generics API is out of the scope of this book, and we won't use this feature
    through our code example. You can learn more about generics by visiting [http://www.typescriptlang.org/Handbook#generics](http://www.typescriptlang.org/Handbook#generics).
  prefs: []
  type: TYPE_NORMAL
- en: Using decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Decorators are functions that modify a class, property, method, or method parameter.
    The following example illustrates how to define and use a simple decorator that
    adds a static parameter to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The three dots syntax (`...`) is the *spread operator,* which is a feature of
    JavaScript 2015 that deconstructs the items of a given array.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators versus annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have heard the term annotations; they are simply metadata related
    to Angular 2\. Before the Angular team decided to use TypeScript, they introduced
    us to a new language that they called AtScript. This language included a feature
    called annotations, which look exactly like decorators. So what's the difference?
    The decorator is an interface for creating those Angular annotations. Decorators
    are executed and in Angular 2, they have the responsibility to set metadata leveraging
    the Reflect Metadata library. Furthermore, decorators are a proposal for ES7—the
    next version of JavaScript. For that reason, we can focus on decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is a superset of JavaScript. This means you can write plain JavaScript
    in `.ts` files. The TypeScript compiler will peel all the extra TypeScript code
    and produce code that is plain, readable, and almost identical to the source code.
    The Angular 2 team uses TypeScript for developing the Angular platform (the source
    code is written with TypeScript, but a compiled JavaScript version is also available).
    As developers, we can choose whatever we want to use; TypeScript, JavaScript 2015
    (ES6), or JavaScript 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to use TypeScript, it's highly recommended to visit [http://www.typescriptlang.org/](http://www.typescriptlang.org/)
    and learn more about the language's capabilities that go beyond the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
