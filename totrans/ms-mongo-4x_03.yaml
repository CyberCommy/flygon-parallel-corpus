- en: Schema Design and Data Modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on schema design for schema less databases such as MongoDB.
    Although this may sound counter-intuitive, there are considerations that we should
    take into account when we develop for MongoDB. We will learn about the schema
    considerations and the data types supported by MongoDB. We will also learn about
    preparing data for text searches in MongoDB by connecting Ruby, Python, and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational schema design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling data for atomic operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational schema design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In relational databases, we design with the goal of avoiding anomalies and redundancy.
    Anomalies can happen when we have the same information stored in multiple columns;
    we update one of them but not the rest and so end up with conflicting information
    for the same column of information. An anomaly can also happen when we cannot
    delete a row without losing information that we need, possibly in other rows referenced
    by it. Data redundancy can happen when our data is not in a normal form, but has
    duplicate data across different tables. This can lead to data inconsistency and
    is difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In relational databases, we use normal forms to normalize our data. Starting
    from the basic **First Normal Form** (**1NF**), onto the 2NF, 3NF, and BCNF, we
    model our data, taking functional dependencies into account and, if we follow
    the rules, we can end up with many more tables than domain model objects.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, relational database modeling is often driven by the structure of
    the data that we have. In web applications following some sort of **Model-View-Controller**
    (**MVC**) model pattern, we will model our database according to our models, which
    are modeled after the **Unified Modeling Language** (**UML**) diagram conventions.
    Abstractions such as the ORM for **Django** or the **Active Record** for Rails
    help application developers abstract database structure to object models. Ultimately,
    many times, we end up designing our database based on the structure of the available
    data. Thus, we are designing around the answers that we can have.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB schema design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to relational databases, in MongoDB we have to base our modeling
    on our application-specific data access patterns. Finding out the questions that
    our users will have is paramount to designing our entities. In contrast to an
    RDBMS, data duplication and denormalization are used far more frequently and with
    solid reason.
  prefs: []
  type: TYPE_NORMAL
- en: The document model that MongoDB uses means that every document can hold substantially
    more or less information than the next one, even within the same collection. Coupled
    with rich and detailed queries being possible in MongoDB in the embedded document
    level, this means that we are free to design our documents in any way that we
    want. When we know our data access patterns, we can estimate which fields need
    to be embedded and which can be split out to different collections.
  prefs: []
  type: TYPE_NORMAL
- en: Read-write ratio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The read to write ratio is often an important design consideration for MongoDB
    modeling. When reading data, we want to avoid scatter/gather situations, where
    we have to hit several shards with random I/O requests to get the data our application
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: When writing data, on the other hand, we want to spread out writes to as many
    servers as possible, to avoid overloading any single one of them. These goals
    appear to be conflicting on the surface, but they can be combined once we know
    our access patterns, coupled with application design considerations, such as using
    a replica set to read from secondary nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Data modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the different data types MongoDB uses, how
    they map to the data types that programming languages use, and how we can model
    data relationships in MongoDB using Ruby, Python, and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB uses BSON, a binary-encoded serialization for JSON documents. BSON extends the
    JSON data types, offering, for example, native data and binary data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'BSON, compared to protocol buffers, allows for more flexible schemas that come
    at the cost of space efficiency. In general, BSON is space-efficient, easy to
    traverse, and time-efficient in encoding/decoding operations, as can be seen in
    the following table. (See the MongoDB documentation at [https://docs.mongodb.com/manual/reference/bson-types/](https://docs.mongodb.com/manual/reference/bson-types/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Number** | **Alias** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| Double | 1 | `double` |  |'
  prefs: []
  type: TYPE_TB
- en: '| String | 2 | `string` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Object | 3 | `object` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Array | 4 | `array` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Binary data | 5 | `binData` |  |'
  prefs: []
  type: TYPE_TB
- en: '| ObjectID | 7 | `objectId` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | 8 | `bool` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Date | 9 | `date` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Null | 10 | `null` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Regular expression | 11 | `regex` |  |'
  prefs: []
  type: TYPE_TB
- en: '| JavaScript | 13 | `javascript` |  |'
  prefs: []
  type: TYPE_TB
- en: '| JavaScript (with scope) | 15 | `javascriptWithScope` |  |'
  prefs: []
  type: TYPE_TB
- en: '| 32-bit integer | 16 | `int` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Timestamp | 17 | `timestamp` |  |'
  prefs: []
  type: TYPE_TB
- en: '| 64-bit integer | 18 | `long` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Decimal128 | 19 | `decimal` | New in version 3.4 |'
  prefs: []
  type: TYPE_TB
- en: '| Min key | -1 | `minKey` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Max key | 127 | `maxKey` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Undefined | 6 | `undefined` | Deprecated |'
  prefs: []
  type: TYPE_TB
- en: '| DBPointer | 12 | `dbPointer` | Deprecated |'
  prefs: []
  type: TYPE_TB
- en: '| Symbol | 14 | `symbol` | Deprecated |'
  prefs: []
  type: TYPE_TB
- en: In MongoDB, we can have documents with different value types for a given field
    and we  distinguish among them when querying using the `$type` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a `balance` field in GBP with 32-bit integers and `double`
    data types, if `balance` has pennies in it or not, we can easily query for all
    accounts that have a rounded `balance` with any of the following queries shown
    in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will compare the different data types in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing different data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the nature of MongoDB, it's perfectly acceptable to have different data
    type objects in the same field. This may happen by accident or on purpose (that
    is, null and actual values in a field).
  prefs: []
  type: TYPE_NORMAL
- en: 'The sorting order of different types of data, from highest to lowest, is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Max key (internal type)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regular expression
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Timestamp
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Date
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ObjectID
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Binary data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Symbol, string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Numbers (`int`, `long`, `double`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Min key (internal type)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Non-existent fields get sorted as if they have `null` in the respective field.
    Comparing arrays is a bit more complex than fields. An ascending order of comparison
    (or `<`) will compare the smallest element of each array. A descending order of
    comparison (or `>`) will compare the largest element of each array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, see the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In ascending order, this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in descending order, it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies when comparing an array with a single number value, as illustrated
    in the following example. Inserting a new document with an integer value of `4`
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows the code snippet for a descending `sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following example is the code snippet for an ascending `sort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In each case, we highlighted the values being compared in bold.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about the data type in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Date type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dates are stored as milliseconds with effect from January 01, 1970 (epoch time).
    They are 64-bit signed integers, allowing for a range of 135 million years before
    and after 1970\. A negative date value denotes a date before January 01, 1970\.
    The BSON specification refers to the `date` type as UTC `DateTime`.
  prefs: []
  type: TYPE_NORMAL
- en: Dates in MongoDB are stored in UTC. There isn't `timestamp` with a `timezone`
    data type like in some relational databases. Applications that need to access
    and modify timestamps, based on local time, should store the `timezone` offset
    together with the date and offset dates on an application level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the MongoDB shell, this could be done using the following format with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to apply the saved offset to reconstruct the original local time,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will cover `ObjectId`.
  prefs: []
  type: TYPE_NORMAL
- en: ObjectId
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ObjectId` is a special data type for MongoDB. Every document has an `_id`
    field from cradle to grave. It is the primary key for each document in a collection
    and has to be unique. If we omit this field in a `create` statement, it will be
    assigned automatically with an `ObjectId`.'
  prefs: []
  type: TYPE_NORMAL
- en: Messing with `ObjectId` is not advisable but we can use it (with caution!) for
    our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '`ObjectId` has the following distinctions:'
  prefs: []
  type: TYPE_NORMAL
- en: It has 12 bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is ordered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting by `_id` will sort by creation time for each document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the creation time can be accessed by `.getTimeStamp()` in the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The structure of an `ObjectId` has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A 4-byte value representing the seconds since the Unix epoch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 3-byte machine identifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 2-byte process ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 3-byte counter, starting with a random value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The  following diagram shows the structure of an ObjectID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28e23c3f-309a-4e34-b437-cfbce6e41960.png)'
  prefs: []
  type: TYPE_IMG
- en: By its structure, `ObjectId` will be unique for all purposes; however, since
    this is generated on the client side, you should check the underlying library's
    source code to verify that implementation is according to specification.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about modeling data for atomic operations.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling data for atomic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is relaxing many of the typical **Atomicity, Consistency, Isolation
    and Durability** (**ACID**) constraints found in RDBMS. In the absence of transactions,
    it can sometimes be difficult to keep the state consistent across operations,
    especially in the event of failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, some operations are atomic at the document level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`update()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findandmodify()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all atomic (all or nothing) for a single document.
  prefs: []
  type: TYPE_NORMAL
- en: This means that, if we embed information in the same document, we can make sure
    they are always in sync.
  prefs: []
  type: TYPE_NORMAL
- en: An example would be an inventory application, with a document per item in our
    inventory, where we would need to total the available items left in stock how
    many have been placed in a shopping cart in sync, and use this data to sum up
    the total available items.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `total_available = 5`, `available_now = 3`, `shopping_cart_count = 2`,
    this use case could look like the following: `{available_now : 3, Shopping_cart_by:
    ["userA", "userB"] }`'
  prefs: []
  type: TYPE_NORMAL
- en: When someone places the item in their shopping cart, we can issue an atomic
    update, adding their user ID in the `shopping_cart_by` field and, at the same
    time, decreasing the `available_now` field by one.
  prefs: []
  type: TYPE_NORMAL
- en: This operation will be guaranteed to be atomic at the document level. If we
    need to update multiple documents within the same collection, the update operation
    may complete successfully without modifying all of the documents that we intended
    it to. This could happen because the operation is not guaranteed to be atomic
    across multiple document updates.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern can help in some, but not all, cases. In many cases, we need multiple
    updates to be applied on all or nothing across documents, or even collections.
  prefs: []
  type: TYPE_NORMAL
- en: A typical example would be a bank transfer between two accounts. We want to
    subtract *x* GBP from user *A*, then add *x* to user *B*. If we fail to do either
    of the two steps, we would return to the original state for both balances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The details of this pattern are outside the scope of this book, but roughly,
    the idea is to implement a hand-coded two phase **commit** protocol. This protocol
    should create a new transaction entry for each transfer with every possible state
    in this transaction: such as initial, pending, applied, done, cancelling, cancelled,
    and, based on the state that each transaction is left at, applying the appropriate
    rollback function to it.'
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself having to implement transactions in a database that was
    built to avoid them, take a step back and rethink why you need to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Write isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sparingly, we could use `$isolated` to isolate writes to multiple documents
    from other writers or readers to these documents. In the previous example, we
    could use `$isolated` to update multiple documents and make sure that we update
    both balances before anyone else gets the chance to double-spend, draining the
    source account of its funds.
  prefs: []
  type: TYPE_NORMAL
- en: What this won't give us though, is atomicity, the all-or-nothing approach. So,
    if the update only partially modifies both accounts, we still need to detect and
    unroll any modifications made in the pending state.
  prefs: []
  type: TYPE_NORMAL
- en: '`$isolated` uses an exclusive lock on the entire collection, no matter which
    storage engine is used. This means a severe speed penalty when using it, especially
    for WiredTiger document-level locking semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$isolated` does not work with sharded clusters, which may be an issue when
    we decide to go from replica sets to sharded deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Read isolation and consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB read operations would be characterized as *read uncommitted* in a traditional
    RDBMS definition. What this means is that, by default, reads may get values that
    may not finally persist to the disk in the event of, for example, data loss or
    a replica set rollback operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, when updating multiple documents with the default write behavior,
    lack of isolation may result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads may miss documents that were updated during the update operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-serializable operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read operations are not point-in-time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can be resolved by using the `$isolated` operator with a heavy performance
    penalty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Queries with cursors that don''t use `.snapshot()` may also, in some cases,
    get inconsistent results. This can happen if the query''s resultant cursor fetches
    a document, which receives an update while the query is still fetching results,
    and, because of insufficient padding, ends up in a different physical location
    on the disk, ahead of the query''s result cursor position. `.snapshot()` is a
    solution for this edge case, with the following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn't work with sharding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't work with `sort()` or `hint()` to force an index to be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It still won't provide point-in-time read behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If our collection has mostly static data, we can use a unique index in the query
    field to simulate `snapshot()` and still be able to apply `sort()` to it.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, we need to apply safeguards at the application level to make sure
    that we won't end up with unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from version 3.4, MongoDB offers linearizable read concern. With linearizable
    read concern from the primary member of a replica set and a majority write concern,
    we can ensure that multiple threads can read and write a single document as if
    a single thread was performing these operations one after the other. This is considered
    a linearizable schedule in RDBMS, and MongoDB calls it the real-time order.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will explain how we can translate relationships
    in RDBMS theory into MongoDB's document-collection hierarchy. We will also examine
    how we can model our data for text search in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coming from the relational DB world, we identify objects by their relationships.
    A one-to-one relationship could be a person with an address. Modeling it in a
    relational database would most probably require two tables: a **Person** and an
    **Address** table with a foreign key `person_id` in the **Address** table, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b045cf93-073f-43f2-aeb7-d0831e4e7b68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The perfect analogy in MongoDB would be two collections, `Person` and `Address`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the same pattern as we do in a relational database to find
    `Person` from `address`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is well known and works in the relational world.
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB, we don't have to follow this pattern, as there are more suitable
    ways to model these kinds of relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way in which we would typically model one-to-one or one-to-many relationships
    in MongoDB would be through embedding. If the person has two addresses, then the
    same example would then be shown in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using an embedded array, we can have access to every `address` this user has.
    Embedding querying is rich and flexible so that we can store more information
    in each document, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantages of this approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No need for two queries across different collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can exploit atomic updates to make sure that updates in the document will
    be all-or-nothing from the perspective of other readers of this document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can embed attributes in multiple nest levels creating complex structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most notable disadvantage is that the maximum size of the document is 16
    MB so this approach cannot be used for an arbitrary, ever-growing number of attributes.
    Storing hundreds of elements in embedded arrays will also degrade performance.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many and many-to-many
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the number of elements in the *many* side of the relationship can grow
    unbounded, it''s better to use references. References can come in two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the *one* side of the relationship, store an array of many-sided elements,
    as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This way we can get the array of `addresses` from the one-side and then query
    with `in` to get all the documents from the many-side, as shown in the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Turning this one-to-many to many-to-many is as easy as storing this array in
    both ends of the relationship (that is, in the `Person` and `Address` collections).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the many-side of the relationship, store a reference to the one-side,
    as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, with both designs we need to make two queries to the database
    to fetch the information. The second approach has the advantage that it won't
    let any document grow unbounded, so it can be used in cases where one-to-many
    is one-to-millions.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling data for keyword searches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Searching for keywords in a document is a common operation for many applications.
    If this is a core operation, it makes sense to use a specialized store for search,
    such as **Elasticsearch**; however, MongoDB can be used efficiently until scale
    dictates moving to a different solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic need for a keyword search is to be able to search the entire document
    for keywords. For example, with a document in the `products` collection, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a multi-key index in the `keywords` field, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now we can search in the `keywords` field for any name, manufacturer, price,
    and also any of the custom keywords that we set up. This is not an efficient or
    flexible approach, as we need to keep keywords lists in sync, we can't use stemming,
    and we can't rank results (it's more like filtering than searching). The only
    advantage of this method is that it is slightly quicker to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Since version 2.4, MongoDB has had a special text index type. This can be declared
    in one or multiple fields and supports stemming, tokenization, exact phrase (`"
    "`), negation (`-`), and weighting results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Index declaration on three fields with custom `weights` is shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `name` is `10` times more important than `price` but only two
    times from `manufacturer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `text` index can also be declared with a wildcard, matching all the fields
    that match the pattern, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful when we have unstructured data and we may not know all the
    fields that they will come with. We can drop the index by name, just like with
    any other index.
  prefs: []
  type: TYPE_NORMAL
- en: The greatest advantage though, other than all the features, is that all record
    keeping is done by the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to connect to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to connect to MongoDB. The first is by using the driver
    for your programming language. The second is by using an ODM layer to map your
    model objects to MongoDB in a transparent way. In this section, we will cover
    both ways, using three of the most popular languages for web application development:
    Ruby, Python, and PHP.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting using Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ruby was one of the first languages to have support from MongoDB with an official
    driver. The official MongoDB Ruby driver on GitHub is the recommended way to connect
    to a MongoDB instance. Perform the following steps to connect MongoDB using Ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation is as simple as adding it to the Gemfile, as shown in the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You need to install Ruby, then install RVM from [https://rvm.io/rvm/install](https://rvm.io/rvm/install), and
    finally run `gem install bundler` for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in our class, we can connect to a database, as shown in the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest example possible: connecting to a single database instance
    called `test` in our `localhost`. In most use cases, we would at least have a
    replica set to connect to, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `client_host` servers are seeding the client driver with servers to attempts
    to connect. Once connected, the driver will determine the server that it has to
    connect to according to the primary/secondary read or write configuration. The
    `replica_set` attribute needs to match `REPLICA_SET_NAME` to be able to connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`user` and `password` are optional, but highly recommended in any MongoDB instance.
    It''s good practice to enable authentication by default in the `mongod.conf` file
    and we will learn more about this in [Chapter 8](687220c0-264a-4edb-9e04-c10b0c180766.xhtml), *Monitoring,
    Backup, and Security*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connecting to a sharded cluster is similar to a replica set, with the only difference
    being that, instead of supplying the server host/port, we need to connect to the
    MongoDB process that serves as the MongoDB router.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mongoid ODM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a low-level driver to connect to the MongoDB database is often not the
    most efficient route. All the flexibility that a low-level driver provides is
    offset against longer development times and code to glue our models with the database.
  prefs: []
  type: TYPE_NORMAL
- en: An ODM can be the answer to these problems. Just like ORMs, ODMs bridge the
    gap between our models and the database. In Rails, the most widely-used MVC framework
    for Ruby—Mongoid—can be used to model our data in a similar way to Active Record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing `gem` is similar to the Mongo Ruby driver, by adding a single file
    in the Gemfile, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the version of Rails, we may need to add the following to `application.rb`
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to the database is done through a config file, `mongoid.yml`. Configuration
    options are passed as key-value pairs with semantic indentation. Its structure
    is similar to `database.yml` used for relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the options that we can pass through the `mongoid.yml` file are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Database` | The database name. |'
  prefs: []
  type: TYPE_TB
- en: '| `Hosts` | Our database hosts. |'
  prefs: []
  type: TYPE_TB
- en: '| `Write`/`w` | The write concern (default is 1). |'
  prefs: []
  type: TYPE_TB
- en: '| `Auth_mech` | Authentication mechanism. Valid options are: `:scram`, `:mongodb_cr`, `:mongodb_x509`,
    and `:plain`. The default option on 3.0 is `:scram`, whereas the default on 2.4
    and 2.6 is `:plain`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Auth_source` | The authentication source for our authentication mechanism.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Min_pool_size`/`max_pool_size` | Minimum and maximum pool size for connections.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SSL`, `ssl_cert`, `ssl_key`,  `ssl_key_pass_phrase`, `ssl_verify` | A set
    of options regarding SSL connections to the database. |'
  prefs: []
  type: TYPE_TB
- en: '| `Include_root_in_json` | Includes the root model name in JSON serialization.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Include_type_for_serialization` | Includes the `_type` field when serializing
    MongoDB objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `Use_activesupport_time_zone` | Uses active support''s time zone when converting
    timestamps between server and client. |'
  prefs: []
  type: TYPE_TB
- en: 'The next step is to modify our models to be stored in MongoDB. This is as simple
    as including one line of code in the model declaration, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We use it to generate `created_at` and `updated_at` fields in a similar way
    to Active Record. Data fields do not need to be declared by type in our models,
    but it''s good practice to do so. The supported data types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigDecimal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hash`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Integer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BSON::ObjectId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BSON::Binary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Regexp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimeWithZone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the types of fields are not defined, fields will be cast to the object and
    stored in the database. This is slightly faster, but doesn't support all types.
    If we try to use `BigDecimal`, `Date`, `DateTime`, or `Range`, we will get back
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance with Mongoid models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code is an example of inheritance using the Mongoid models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a `Canvas` class with many `Shape` objects embedded in it. Mongoid
    will automatically create a field, which is `_type`, to distinguish between parent
    and child node fields. In scenarios where documents are inherited from their fields,
    relationships, validations, and scopes get copied down into their child documents,
    but not vice-versa.
  prefs: []
  type: TYPE_NORMAL
- en: '`embeds_many` and `embedded_in` pairs will create embedded sub-documents to
    store the relationships. If we want to store these via referencing to `ObjectId`,
    we can do so by substituting these with `has_many` and `belongs_to`.'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A strong contender to Ruby and Rails is Python with Django. Similar to Mongoid,
    there is MongoEngine and an official MongoDB low-level driver, PyMongo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing PyMongo can be done using `pip` or `easy_install`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our class, we can connect to a database, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Connecting to a replica set requires a set of seed servers for the client to
    find out what the primary, secondary, or arbiter nodes in the set are, as indicated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using the connection string URL, we can pass a username and password and the `replicaSet`
    name all in a single string. Some of the most interesting options for the connection
    string URL are present in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a shard requires the server host and IP for the MongoDB router,
    which is the MongoDB process.
  prefs: []
  type: TYPE_NORMAL
- en: PyMODM ODM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to Ruby''s Mongoid, PyMODM is an ODM for Python that follows closely
    on Django''s built-in ORM. Installing `pymodm` can be done via `pip`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to edit `settings.py` and replace the database `ENGINE` with a
    `dummy` database, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add our connection string anywhere in `settings.py`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have to use a connection string that has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Options have to be pairs of `name=value` with an `&` between each pair. Some
    interesting pairs are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `minPoolSize`/`maxPoolSize` | Minimum and maximum pool size for connections.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `w` | Write concern option. |'
  prefs: []
  type: TYPE_TB
- en: '| `wtimeoutMS` | Timeout for write concern operations. |'
  prefs: []
  type: TYPE_TB
- en: '| `Journal` | Journal options. |'
  prefs: []
  type: TYPE_TB
- en: '| `readPreference` | Read preference to be used for replica sets. Available
    options are: `primary`, `primaryPreferred`, `secondary`, `secondaryPreferred`,
    `nearest`. |'
  prefs: []
  type: TYPE_TB
- en: '| `maxStalenessSeconds` | Specifies, in seconds, how stale (data lagging behind
    master) a secondary can be before the client stops using it for read operations.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SSL` | Using SSL to connect to the database. |'
  prefs: []
  type: TYPE_TB
- en: '| `authSource` | Used in conjunction with username, this specifies the database
    associated with the user''s credentials. When we use external authentication mechanisms,
    this should be `$external` for LDAP or Kerberos. |'
  prefs: []
  type: TYPE_TB
- en: '| `authMechanism` | Authentication mechanism can be used for connections. Available
    options for MongoDB are: **SCRAM-SHA-1**, **MONGODB-CR**, **MONGODB-X.509**.MongoDB
    enterprise (paid version) offers two more options: **GSSAPI** (Kerberos), **PLAIN**
    (**LDAP SASL**) |'
  prefs: []
  type: TYPE_TB
- en: 'Model classes need to inherit from `MongoModel`. The following code shows what
    a sample class will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This has a `User` class with `first_name`, `last_name`, and `email` fields,
    where `email` is the primary field.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance with PyMODM models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling one-to-one and one-to-many relationships in MongoDB can be done using
    references or embedding. The following example shows both ways, which are references
    for the model user and embedding for the comment model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Similar to Mongoid for Ruby, we can define relationships as being embedded or
    referenced, depending on our design decision.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting using PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MongoDB PHP driver was rewritten from scratch two years ago to support
    the PHP 5, PHP 7, and HHVM architectures. The current architecture is shown in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e79b102-ba4d-4275-9559-dcb782394764.png)'
  prefs: []
  type: TYPE_IMG
- en: Currently, we have official drivers for all three architectures with full support
    for the underlying functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation is a two-step process. First, we need to install the MongoDB extension.
    This extension is dependent on the version of PHP (or HHVM) that we have installed
    and can be done using `brew` in macOS.  The following example is with PHP 7.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use `composer` (a widely-used dependency manager for PHP) as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to the database can be done by using the connection string URL or
    by passing an array of options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the connection string URL, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to connect to a replica set using SSL authentication, we use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use the `$uriOptions` parameter to pass in parameters without using
    the connection string URL, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The set of `$uriOptions` and the connection string URL options available are
    analogous to the ones used for Ruby and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Doctrine ODM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Laravel** is one of the most widely-used MVC frameworks for PHP, similar
    in architecture to Django and Rails from the Python and Ruby worlds respectively.
    We will follow through configuring our models using Laravel, Doctrine, and MongoDB.
    This section assumes that Doctrine is installed and working with Laravel 5.x.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Doctrine entities are **Plain Old PHP Objects** (**POPO**) that, unlike **Eloquent**,
    Laravel''s default ORM doesn''t need to inherit from the `Model` class. Doctrine
    uses the **Data Mapper Pattern**, whereas Eloquent uses Active Record. Skipping
    the `get()` and `set()` methods, a simple class would be shown in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This POPO-based model uses annotations to define field types that need to be
    persisted in MongoDB. For example, `@ORM\Column(type="string")` defines a field
    in MongoDB with the `string` types `firstname` and `lastname` as the attribute
    names, in the respective lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a whole set of annotations available here: [https://doctrine2.readthedocs.io/en/latest/reference/annotations-reference.html](https://doctrine2.readthedocs.io/en/latest/reference/annotations-reference.html).'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to separate the POPO structure from annotations, we can also define
    them using YAML or XML instead of inlining them with annotations in our POPO model
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance with Doctrine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modeling one-to-one and one-to-many relationships can be done via annotations,
    YAML, or XML. Using annotations, we can define multiple embedded sub-documents
    within our document, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, a `User` document embeds many `phonenumbers`. `@EmbedOne()` will embed
    one sub-document to be used for modeling one-to-one relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Referencing is similar to embedding, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`@ReferenceMany()` and `@ReferenceOne()` are used to model one-to-many and
    one-to-one relationships via referencing into a separate collection.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about schema design for relational databases and
    MongoDB and how we can achieve the same goal starting from a different starting
    point.
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB, we have to think about read and write ratios, the questions that
    our users will have in the most common cases, and cardinality among relationships.
  prefs: []
  type: TYPE_NORMAL
- en: We learnt about atomic operations and how we can construct our queries so that
    we can have ACID properties without the overhead of transactions.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about MongoDB data types, how they can be compared, and some
    special data types, such as the `ObjectId`, which can be used both by the database
    and to our own advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from modeling simple one-to-one relationships, we went through one-to-many
    and also many-to-many relationship modeling, without the need for an intermediate
    table, as we would do in a relational database, either using references or embedded
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to model data for keyword searches, one of the features that
    most applications need to support in a web context.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored different use cases for using MongoDB with three of the
    most popular web programming languages. We saw examples using Ruby with the official
    driver and Mongoid ODM. Then we explored how to connect using Python with the
    official driver and PyMODM ODM, and, lastly, we worked through an example using
    PHP with the official driver and Doctrine ODM.
  prefs: []
  type: TYPE_NORMAL
- en: With all these languages (and many others), there are both official drivers
    offering support and full access functionality to the underlying database operations
    and also **object data modeling** frameworks for ease of modeling our data and
    rapid development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into the MongoDB shell and the operations
    we can achieve using it. We will also master using the drivers for CRUD operations
    on our documents.
  prefs: []
  type: TYPE_NORMAL
