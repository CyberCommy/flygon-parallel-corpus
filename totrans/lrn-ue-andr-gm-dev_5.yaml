- en: Chapter 5. Scripting with Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now come to one of the most important aspects of the game: interactivity.
    Without it, our game will just be an environment that the player can move around
    in. Those who have used UDK before may already be familiar with the concept of
    visual scripting. UDK had what is called Kismet, a powerful visual scripting tool.
    A really attractive feature of this tool is that anyone can use it without any
    prior programming knowledge. All you need to know is the logic behind the event
    you wish to implement. You can create a full game without even writing a single
    line of code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal 4, we have Blueprints, which is sort of an upgrade to Kismet. The
    basic setup is the same: you have various nodes and expressions, which you can
    use to script in-game events, actions, and so on. The interface is simple to understand,
    easy to use, and yet extremely powerful. Once you get the hang of it, you can
    create complex sequences and events.'
  prefs: []
  type: TYPE_NORMAL
- en: However, even though Blueprint is an easy-to-learn and a great tool, it is still
    limited in terms of what it can do. In that respect, C++ is much more versatile
    and flexible than Blueprint. C++ is great for implementing complex interactions
    and mechanics, which Blueprint may or may not offer. Another difference between
    Blueprint and C++ is that Blueprint is much slower to execute than C++ code, but
    this is only noticeable if you have a lot of Blueprint script in your game. There
    are several other differences between Blueprint and C++; but it all boils down
    to personal preference about the features, mechanics, and functionalities you
    want in your game. You can choose to use either one or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What Blueprints are and how they work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Level Blueprints are and how to script using Level Blueprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level Blueprint user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a Blueprint class is and how to use it in the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to Script basic AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Blueprint works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Scripting in Blueprint is similar to creating a flowchart. At your disposal
    are various nodes, which you can connect to create an action sequence. In order
    to properly script in Blueprint, you should first know the logic behind the desired
    sequence. For example, say you want to implement a lamp that is switched on when
    you go near it and switched off when you move away from it. In such a case, you
    would first place a trigger around the lamp. Then, the logic behind this would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: If the player is overlapping the trigger, the light will be switched on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player is not overlapping the trigger, the light will be switched off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have figured out how to carry out this action, we can proceed to
    set up our nodes. Say your setup looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Blueprint works](img/image00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the character walks into the box trigger, the ceiling light (the spotlight)
    is switched on. The Blueprint to toggle the light on/off will look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How Blueprint works](img/image00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are various types of nodes that you should know about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Nodes**: The nodes with the red bar are event notes. These are activated
    when the corresponding event takes place. They usually have a rightward facing
    arrow at the top left corner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also have Input Event Nodes, which fire off when the player gives the corresponding
    input (for example, firing a weapon when the player presses the left mouse button).
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Nodes**: The nodes with the blue top are function nodes. They usually
    have a function symbol **f** at the top left corner, as you can see in the preceding
    screenshot. These nodes perform a specific action on an actor or player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two types of function nodes: those that act upon an actor, and those
    that return a specific value. These types of nodes have green tops (not displayed
    in the screenshot). This includes things such as returning an actor''s location
    in the world, returning the actor''s velocity, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference or Variable Nodes**: The node in the center of the screenshot is
    a variable node (or reference). When you want a function node to act upon a specific
    actor in the scene, or if you want to "get" some of its property or properties,
    you need to create its reference in the Level Blueprint. The same goes with variable
    nodes. It should come as no surprise that variables play a very important role
    when scripting or coding. So naturally, you will have to create variables when
    you are using Blueprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When scripting using Blueprint, keep in mind that the fewer nodes you have,
    the better the performance. It also makes your workspace more organized and easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: When a particular event occurs, the corresponding event node fires off a pulse
    to whichever node it is attached. In our case, when the player overlaps the trigger,
    it will activate the Spotlight's **Toggle Visibility** function (since the light
    is off by default, it will toggle it on). And when the player stops overlapping
    the trigger (walks out of the trigger), it will fire the **Toggle Visibility**
    function once again (the light will be switched off).
  prefs: []
  type: TYPE_NORMAL
- en: '![How Blueprint works](img/image00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot demonstrates how blueprints function when an event
    has taken place. When the player has overlapped the trigger (top left), the corresponding
    event fires off a pulse to the **Toggle Visibility** function, which toggles the
    light on. When the player moves out of the trigger, or stops overlapping, the
    corresponding event again fires a pulse to the **Toggle Visibility** function
    node, which toggles the light on.
  prefs: []
  type: TYPE_NORMAL
- en: You can actually see the pulse being fired whenever a node is activated. This
    makes debugging very easy, as you can see which node is causing the problem and
    fix it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from knowing the logic, you should also know which nodes are available
    and what they can be used to do. This comes with time and practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of Blueprints in Unreal 4: Level Blueprint and Blueprint
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Level Blueprints is to UE4 what Kismet was to UE3\. Each level or map that you
    create in your project file will have its own unique Level Blueprint. You can
    control everything level related using Level Blueprints, such as playing cutscenes,
    editing the properties of actors (visibility, location, and so on) in your level,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint classes, on the other hand, are special actors that contain various
    components as well as scripts. These components include things such as static
    or skeletal meshes, camera, collision component, triggers, and audio components.
    By using scripts, you can set their properties and determine how they interact
    with the world. Blueprint classes are not unique to a particular level; therefore,
    you can use them in any map or level you have made in your project. You can export
    them to other projects as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let us move on to the Level Blueprint's user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The Level Blueprint user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following screenshot features the Level Blueprint's user interface. Continuing
    with our style of dividing the UI into various parts, the interface is divided
    into sections, which we will go through individually.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Level Blueprint user interface](img/image00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The tab and menu bars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tab bar is the same as that seen in all the other windows. Just like in
    the case of web browsers, you can see which windows are open, swap between them,
    and close any window you want from there.
  prefs: []
  type: TYPE_NORMAL
- en: '![The tab and menu bars](img/image00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The menu bar is where you can access all the general commands and actions that
    you would need.
  prefs: []
  type: TYPE_NORMAL
- en: '**File**: In this menu, you can save your level, open any asset in your Content
    Browser, compile your blueprint, enable source control, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edit**: From this menu, you can perform actions such as undoing the last
    action, redoing it, searching for a specific node or expression, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View**: Here, you can hide/unhide unused pins and unconnected pins (through
    which you connect nodes), zoom in, and zoom out in the event graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debug**: If there is a problem in your Blueprint sequence that you cannot
    figure out, you can use the options available in the Debug menu to find and resolve
    them. These include adding breaking points, watching the value of a particular
    variable at a particular point, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Window**: Here, you can set what windows you want to be visible and what
    windows you do not want to be visible. You can customize the layout and save it
    from the Window menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Help**: From here, you can access Epic''s official documentation regarding
    Blueprints. You can also go to the Wiki page, the forums, and the Answer Hub from
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Toolbar** has the most commonly used actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The toolbar](img/image00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The most commonly used actions are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compile**: Whenever you add, remove, or edit any node in the event graph,
    be sure to click on the **Compile** button. It compiles all the nodes and sequences,
    and if there is any error or warning, it will notify you in the **Compiler Results**
    panel, which you can then fix. Also, if you have a variable node, in order to
    set its default value, you first need to compile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search**: When you have large and complex sequences with several connected
    nodes, trying to find a specific node or variable can be a tedious and time-consuming
    task. In order to avoid that, you can click on the **Search** button, and type
    in the name of whatever it is you wish to find. The results will, by default,
    be displayed at the bottom of the screen, where the **Compiler Results** panel
    is (it will open a new tab called **Find Results**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Settings**: Clicking on this will open up the Blueprint settings in
    the **Details panel**, where you can set certain options such as adding a description,
    category, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class Defaults**: Here, you can set the default or initial values of your
    Blueprint class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Play**: Similar to the **Play** button in the **Viewport** toolbar, this
    opens a new window where you can test your game. While the game is running, clicking
    the *Esc* button will close the game and return to the Editor. You may notice
    a small downward-facing arrow next to the button. This opens a menu where you
    can set options such as how you want to preview your game, where the player should
    start, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Details panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the **Details** panel, you can set the properties of various nodes and variables.
    It offers settings such as the type of variable you want (Boolean, float, integer,
    and so on), the name of the variable, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Details panel](img/image00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Compiler Results panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anyone who has any programming knowledge will know what compilation is. It occurs
    when the code that you have written is converted from the language you wrote the
    code in into machine language that the computer understands, so that it can be
    executed. This is usually handled by a compiler. (If you do not see the **Compiler
    Results** panel, in Level Blueprint, go to Window, and click on **Compiler Results**.)
  prefs: []
  type: TYPE_NORMAL
- en: '![The Compiler Results panel](img/image00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the **Compiler Results** panel, you can see the output log of the compiler.
    How long it took to compile, any errors found during compilations, any warnings,
    and so on, all are displayed here.
  prefs: []
  type: TYPE_NORMAL
- en: My Blueprint panel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this panel, you can see a list of all of the events, variables, and event
    dispatchers that you have created. Whenever you create an event node, it is displayed
    here, under **EventGraph**. Apart from that, you can also create various functions,
    macros, variables, and so on. To do so, you can click on the **Add New** button
    and select whatever it is you want to create, or by clicking on the **+** button
    in front of the names.
  prefs: []
  type: TYPE_NORMAL
- en: '![My Blueprint panel](img/image00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Event Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Located at the center of the screen, the **Event Graph** (also referred to as
    **Graph Editor**) is where you set up your nodes and sequences. By default, there
    are two event nodes already set up, namely **Event Begin Play**, which is activated
    when the game begins, and **Event Tick**, which is activated at every frame. These
    two events do not require any trigger to be activated.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Event Graph](img/image00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At the top, you can see the tab. Below the tab, at the top-left corner, are
    two arrows. You can use them to switch between graphs. At the center, you can
    see the hierarchy and the blueprint structure. At the extreme right, you can see
    the zoom ratio—in other words, how much you have zoomed in our zoomed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the controls of **Event Graph** that you should know
    and memorize:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Control | Action |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Left-click on mouse | Selects nodes |'
  prefs: []
  type: TYPE_TB
- en: '| Left-click + drag | Creates selection box |'
  prefs: []
  type: TYPE_TB
- en: '| Right-click | Opens the Action Menu |'
  prefs: []
  type: TYPE_TB
- en: '| Right-click + drag | Pans the Graph Editor |'
  prefs: []
  type: TYPE_TB
- en: '| Scroll wheel up | Zooms in |'
  prefs: []
  type: TYPE_TB
- en: '| Scroll wheel down | Zooms out |'
  prefs: []
  type: TYPE_TB
- en: '| C | Creates a comment box around selected node(s) |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though it is visual scripting, it can still get pretty messy when you script
    using Blueprints. So, to avoid confusion and keep everything organized, it is
    advisable to create comment boxes around your nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Using Level Blueprint in the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With all the basics out of the way, we can begin scripting our game. One thing
    you should know is that we might add more triggers and actors as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: Key cube pickup and placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we are going to script is the player picking up the key
    cube. Now, when the player is close enough to the key cube and taps on it on their
    screen, they will be able to pick up the cube. In our case, to give the illusion
    that the player has picked up the key, we are going to destroy the actor when
    the player taps on it on the screen. Also, we will place a replica of the key
    cube on top of the pedestal at the very beginning and keep it hidden at the start
    of the game. When the player has picked up the cube and is close enough to the
    pedestal, tapping on the screen will unhide the cube from the game, giving the
    impression that the character has placed the key on the pedestal. So, let's set
    that up. Firstly, with the key cube selected, hold down the *Alt* button, and
    with the help of the Transform tool, drag out a duplicate. Place this duplicate
    on top of the pedestal.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In its **Details** panel, under the **Rendering** section, tick the **Actor
    Hidden in Game** option. Doing so will hide the game from view during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's open the Level Blueprint. To do this, click on **Blueprints** in
    the **Viewport** toolbar and select **Open Level Blueprint**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the event in this case would be the player tapping on the screen, or in
    technical terms, providing a touch input. So in the **Event Graph** window, right-click
    to open the **Actions** menu and type in `Touch`. This should find and display
    the **Touch** event node. Click on it to add it to the **Event Graph**. You may
    find various types of **Touch** nodes—the one you need is the node that simply
    says **Touch**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: the **InputTouch** event node, we are only concerned with the **Pressed** output
    pin. The **Pressed** pin will be activated when the player presses anywhere on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: To remove the box from the scene, we are going to use the **Destroy Actor**
    function node. So, right-click anywhere in the **Graph Editor**, type in `Destroy
    Actor`, and click on the result (you can also find it manually find under the
    **Utility** section). With both nodes present, connect the **Pressed** output
    pin to the **Destroy Actor** input pin. Now, the function does not know itself
    which actor it has to destroy. We have to specify to it which actor we want to
    get rid of. In Blueprint terms, we have to create a reference to the actor we
    wish to apply the function to. So, in the **Viewport**, select the key cube. Then,
    in the **Graph Editor**, right-click and select **Create a Reference to TemplateCube_Rounded**.
  prefs: []
  type: TYPE_NORMAL
- en: If your object has a different name, instead of **TemplateCube_Rounded**, you
    will see the name of the actor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Doing so will create a reference node with the name of the actor written on
    it. Connect this to the **Destroy Actor** target pin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of doing this is to drag the reference node''s output pin and release
    it anywhere in the **Event Graph**. Doing so will open a menu, from where you
    can select the **Destroy Actor** node. Once created, the reference node will automatically
    be connected to it. The setup so far should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00331.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: However, there is a problem here. If you were to test your game, you would notice
    that the cube is destroyed when you tap on the screen, no matter where you are.
    We only want the cube to be destroyed when the player is close enough to it.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this issue, the first thing we are going to do is render the input
    disabled at the start of the game. As you may remember, the event node that is
    activated when the game begins, **Event Begin Play**, is already present in the
    **Graph Editor**. To this, we are going to attach a **Disable Input** node. Right-click
    and find the node, and connect it to the **Event Begin Play**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00332.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although not required right now, if your game has several players or controllers,
    you will have to specify which player's controller you wish to disable. This can
    be done by first creating a **Get Player Controller** node and attaching it to
    **Player Controller** in the **Disable Input** node. By default, **Player Index**
    of the character you play as is 0.
  prefs: []
  type: TYPE_NORMAL
- en: If you test your game now, when you tap on the screen, the key cube is not destroyed
    (although the character will start shooting projectiles again). Now, going back
    to our sequence, since we want the player to be only able to pick up the cube
    when they are at a certain distance, we are going to enable their input when they
    are overlapping with the trigger we had placed around the key cube.
  prefs: []
  type: TYPE_NORMAL
- en: With the trigger selected, create an **EventBeginOverlap** node. After creating
    it, create an **Enable Input** node and attach it to the **EventBeginOverlap**
    node's output pin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00333.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are now almost done with our setup. If you were to test it now, you would
    find that it functions the way we intended it to. However, this is still not complete.
    For one, if you have more than one key cube in your room, both of them will disappear
    when you click on one. We do not want that; we want only the key cube the player
    picks up to disappear. To do this, we are going to use a **Gate** node. A **Gate**
    node is used to control pulses going through the node based on certain conditions
    that you can set. For example, you can set it to **Open** when a certain event
    has taken place, and so on. For instance, when the player has overlapped with
    the trigger, it will open the gate, allowing pulses to go through it.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click anywhere in the **Event Graph** and type `Gate`. Then, click on
    it to place it. You can also find it under **Utilities** | **Flow Control** |
    **Gate**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00334.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The event you wish to control is connected to the **Gate** node's **Enter**
    input. The rest of the events are used to control the flow. Connecting the **Close**
    input to an event will stop anything from passing through the **Gate** when the
    event has occurred. Similarly, connecting the **Open** input to an event or function
    will allow pulses to pass through the node. The **Toggle** node will either open
    the **Gate** node if it was initially closed or vice versa. Finally, you have
    a **Start Closed** pin, which sets the initial state of the **Gate** node. If
    checked, it will be closed initially, and when unchecked, it will be open initially.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, disconnect the **Pressed** pin from the **InputTouch** node and connect
    it, instead, to the Gate node''s **Enter** pin. Then, connect the **Exit** pin
    to the **Destroy Actor** function''s Input pin. Once that is done, we need an
    event that will open the Gate node. This event would be when the player overlaps
    with the trigger. So, take the output pin of the **Enable Input** node and connect
    it to the **Open** input pin of the Gate node (make sure that **Start Closed**
    is checked). Your setup should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00335.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, when the player steps out of the trigger, that is, stops overlapping with
    the trigger, we again want to disable the input. So, with the trigger box selected,
    create an **OnActorEndOverlap** node. You can type it in the search bar or find
    it under **Add Event** for <name of the actor> | **Collision** | **Add On Actor
    End Overlap**. Also, create a **Disable Input** node. Again, you can type it in
    or find under **Input** | **Disable Input**. With everything set up, here is what
    we should end up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00336.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a simple pickup action. But we have more to do before we are finished.
    We have only just scripted the picking up of the cube. We still have to script
    in for when the player places the key cube. This is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is add an overlap event that would enable the
    player's input. Hook them up the same way as you did with the previous trigger.
    Next, we are going to add another Touch event node. To this, we are going to connect
    a **Set Actor Hidden in Game** node. First, select the other key cube (the one
    that is hidden in the game), then right-click anywhere in the **Graph Editor**,
    and find it by typing in its name in the search bar. You can also find it in **Call
    Function** on <name of the selected actor> | **Rendering** | **Set Actor Hidden
    in Game**. You will notice that when you create this node, a reference node for
    the key cube will automatically be created with it, and connect to the **Target**
    input. Next, connect the **Pressed** output pin to the **Set Actor Hidden in Game**
    node's input pin. After having done that, add a **Gate** node with its **Toggle**
    input connected to the output of the **Enable Output** node.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create an **OnActorEndOverlap** node and connect a **Disable Input**
    node to it, just like with the previous trigger.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00337.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you were to test it out, you would find it working perfectly. However, there
    is a problem here: we have not set a condition as to when the player can place
    or unhide the key cube on the pedestal. In other words, if the player simply walks
    up to the pedestal, without picking up the first key cube, they would still be
    able to unhide the other key cube, since that would mean that the player can progress
    through the room without picking up the key cube.'
  prefs: []
  type: TYPE_NORMAL
- en: To fix that, we are first going to change a few properties of the trigger on
    the pedestal. We need to first turn off the trigger's collision. We will have
    to set it up so that initially, the trigger on the pedestal ignores all types
    of overlap events—in other words, toggle it off. To do so, select the trigger
    on the pedestal, and in the Details panel, go to the **Collision** section. Under
    this section, you will see an option called **Collision Presets**. By default,
    it will be set to **Trigger**. Click on the bar to open the preset menu. From
    here, select **Custom**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00338.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, click on the small triangle next to **Collision Presets** in order to
    open a list of the trigger''s collision responses against different types of actors.
    There are three general responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore**: The trigger will not register any response to the collision. The
    actor(s) the trigger is set to ignore will neither be blocked, nor be registered
    by it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overlap**: The actor(s) the trigger is set to overlap will not be blocked
    by it, but the collision will be registered by it. This collision registration
    is how we are able to script things such as switching on the light when the player
    overlaps the trigger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Block**: The actor(s) the trigger is set to block will not be able to pass
    through it. It will act like a wall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can either set what response you want from each actor individually, or choose
    the general response you want from all actors. We will be doing the later. At
    the very top, there is an option called **Collision Response**. In front of that,
    you have three boxes, one for each type of response. Simply check the **Ignore**
    box, and everything below it will be set to ignore. This is what we want. We want
    the trigger to ignore collision for all actors initially. We will change its collision
    response when the player has picked up the key cube.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to the pickup setup we had made, we will need to add a few more
    nodes to it. Right-click anywhere in the **Event Graph**, and in the **Flow Control**
    section, you will find something called **Sequence**. Select and create it. A
    **Sequence** node takes one input and has multiple outputs. If you want a particular
    node to activate or set off various different events or functions, you should
    use a **Sequence** node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00339.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By default, a **Sequence** node has one input pin and two output pins. The first
    node is fired first, then the next, and so on. If you want more output pins, simply
    click on **Add Pins**, and it will create another output pin. Now, connect the
    **Gate** node's output pin to the **Sequence** node's input pin. Then, connect
    **Then 0** to the **Destroy Actor** node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00340.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will now change the **Collision Response** of the trigger to **Overlap**
    when the player has picked up the cube. With the trigger selected, right-click
    on it and first uncheck the **Context Sensitive** box, which is located at the
    top-right corner of the menu. When you have an actor selected in the **Viewport**
    and when you right-click in the **Graph Editor**, the event nodes and the function
    nodes you can see are usually correlated to the selected actor. They only display
    the functions and expressions that can applied directly to the actor. Otherwise,
    Blueprint offers quite a few nodes, but some of them cannot be used either directly
    or at all on the selected actor.
  prefs: []
  type: TYPE_NORMAL
- en: The node that we need here is one that can be applied to the trigger, but not
    directly. What we need is a **Set Collision Response to All Channels** node. This
    node can be used to change the collision response of actors during runtime. Right-click
    in the **Event Graph** and type in the name of the node and create it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00341.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can set a target actor whose **Collision Response** you wish to change.
    If you click on the dropdown menu, you will see three settings: **Ignore**, **Overlap**,
    and **Block**. If you recall, these were the three types of responses in the trigger''s
    **Collision** section. We had set it to **Ignore**, but we want to change it to
    **Overlap** once the player has picked up the key cube. So, select **Overlap**
    in the dropdown menu. Next, connect the **Then 1** pin to this node''s input.
    Finally, with the trigger selected in the **Viewport**, right-click in the **Graph
    Editor**, check the **Context Sensitive** box, and select **Create Reference**
    for <actor name>. Connect this to the **Target** inputof the **Set Collision Response
    to All Channels** node. When you do this, you will find that it does not directly
    connect to the **Target** input. Instead, a new node is created, which takes the
    trigger''s reference as its input and has **Collision Component** as its output.
    What this does is take the trigger box and convert it into something called a
    **Primitive Component Reference**. It is the only way you can connect it to this
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00342.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we were to test the game now, we would find things working the way we want.
    We would not be able to place the key cube without first picking it up.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost done with our setup here. Remember we had placed a **PostProcessVolume**
    around out key cube, which would act as a visual indicator that the player has
    picked up the key cube? We need to script that in as well. We had initially set
    it to be disabled. We will enable it via **Blueprint**, and then destroy it after
    a very brief moment. First, add a new pin to the **Sequence** node. Next, with
    the **PostProcessVolume** selected, right-click in the **Graph Editor** and create
    a reference for it. Then, click on its output pin, drag it out, and release the
    left mouse button to open the menu. Here, you can type in **Set Enabled**, which
    would create a **Bool** node (Bool nodes are red in color). Once created, you
    will see a tick box, which says **Enabled**. Tick that box, and connect it to
    the **Then 2** output pin of the **Sequence** node.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to destroy the actor after a brief moment. For that, we will need
    to create a **Delay** node. A **Delay** node takes in an input and fires off a
    pulse after a certain time (which you can set). Right-click in the **Graph Editor**
    and type in **Delay** and create it. You can also find it under **Utilities**
    | **Flow Control** | **Delay**. You can see an option called **Duration** in the
    node. Here, you can set how long before you want the pulse to be fired. For now,
    leave it at the default value (which is `0.2` seconds), and connect it to the
    **Set Enabled** node. Finally, create a **Destroy Actor** node, connect it to
    the **Delay** node, and set the **PostProcessVolume** as its target. You can simply
    select the post process reference you had created for the **Set Enabled** node
    by clicking *Ctrl* + *C*, and then *Ctrl* + *V*) to create a copy and connect
    this duplicate to the **Target** inputof the **Destroy Actor** node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key cube pickup and placement](img/image00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And there you have it! We have a pickup and placement system for our key cube.
    We also have a visual indicator that we have picked up the cube (we will cover
    how to script the door opening and closing in the next chapter). Now, though this
    was a fairly simple and small setup, doing this for every key cube would be a
    tedious job. Imagine if your game had 10…20…50…100 rooms! You would have to script
    for each key cube in the game and waste loads of time. Thankfully, UE4 offers
    something to get around such a scenario: a **Blueprint** class.'
  prefs: []
  type: TYPE_NORMAL
- en: The Blueprint class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already mentioned, scripting for each key cube would just be a tedious and
    time-consuming task. With a Blueprint class, you would need to do all the scripting
    and everything else only once. A Blueprint class is an entity that contains actors
    (static meshes, volumes, camera classes, trigger box, and so on) and functionalities
    scripted in it. Looking at our example once again of the lamp turning on/off,
    say you want to place 10 such lamps. With a Blueprint class, you would just have
    to create and script once, save it, and duplicate it. This is really an amazing
    feature offered by UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Blueprint class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a Blueprint class, click on the **Blueprints** button in the **Viewport**
    toolbar, and in the dropdown menu, select **New Empty Blueprint Class.** A window
    will then open, asking you to pick your parent class, indicating the kind of Blueprint
    class you wish to create.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Blueprint class](img/image00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the top, you will see the most common classes. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actor**: An **Actor**, as already discussed, is an object that can be placed
    in the world (static meshes, triggers, cameras, volumes, and so on, all count
    as actors)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pawn**: A **Pawn** is an actor that can be controlled by the player or the
    computer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Character**: This is similar to a **Pawn**, but has the ability to walk around'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Player Controller**: This is responsible for giving the **Pawn** or **Character**
    inputs in the game, or controlling it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Game Mode**: This is responsible for all of the rules of gameplay'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actor Component**: You can create a component using this and add it to any
    actor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scene Component**: You can create components that you can attach to other
    scene components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these, there are other classes that you can choose from. To see them,
    click on **All Classes**, which will open a menu listing all the classes you can
    create a Blueprint with. For our key cube, we will need to create an **Actor Blueprint
    Class**. Select **Actor**, which will then open another window, asking you where
    you wish to save it and what to name it. Name it **Key_Cube**, and save it in
    the `Blueprint` folder. After you are satisfied, click on **OK** and the **Actor
    Blueprint Class** window will open.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Blueprint class](img/image00345.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Blueprint class user interface is similar to that of Level Blueprint, but
    with a few differences. It has some extra windows and panels, which have been
    described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Components panel**: The **Components panel** is where you can view, and add
    components to the Blueprint class. The default component in an empty Blueprint
    class is **DefaultSceneRoot**. It cannot be renamed, copied, or removed. However,
    as soon as you add a component, it will replace it. Similarly, if you were to
    delete all of the components, it will come back. To add a component, click on
    the **Add Component** button, which will open a menu, from where you can choose
    which component to add. Alternatively, you can drag an asset from the Content
    Browser and drop it in either the **Graph Editor** or the **Components panel**,
    and it will be added to the Blueprint class as a component. Components include
    actors such as static or skeletal meshes, light actors, camera, audio actors,
    trigger boxes, volumes, particle systems, to name a few. When you place a component,
    it can be seen in the **Graph Editor**, where you can set its properties, such
    as size, position, mobility, material (if it is a static mesh or a skeletal mesh),
    and so on, in the **Details** panel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph Editor**: The **Graph Editor** is also slightly different from that
    of Level Blueprint, in that there are additional windows and editors in a Blueprint
    class. The first window is the **Viewport**, which is the same as that in the
    Editor. It is mainly used to place actors and set their positions, properties,
    and so on. Most of the tools you will find in the main **Viewport** (the editor''s
    **Viewport**) toolbar are present here as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Graph**: The next window is the **Event Graph** window, which is the
    same as a Level Blueprint window. Here, you can script the components that you
    added in the **Viewport** and their functionalities (for example, scripting the
    toggling of the lamp on/off when the player is in proximity and moves away respectively).
    Keep in mind that you can script the functionalities of the components only present
    within the Blueprint class. You cannot use it directly to script the functionalities
    of any actor that is not a component of the Class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Construction Script**: Lastly, there is the **Construction Script** window.
    This is also similar to the **Event Graph**, as in you can set up and connect
    nodes, just like in the **Event Graph**. The difference here is that these nodes
    are activated when you are constructing the Blueprint class. They do not work
    during runtime, since that is when the **Event Graph** scripts work. You can use
    the **Construction Script** to set properties, create and add your own property
    of any of the components you wish to alter during the construction, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin creating the Blueprint class for our key cubes.
  prefs: []
  type: TYPE_NORMAL
- en: Viewport
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we need are the components. We require three components: a
    cube, a trigger box, and a **PostProcessVolume**. In the **Viewport**, click on
    the **Add Components** button, and under **Rendering**, select **Static Mesh**.
    It will add a **Static Mesh** component to the class. You now need to specify
    which **Static Mesh** you want to add to the class. With the **Static Mesh** actor
    selected in the **Components panel**, in the actor''s **Details** panel, under
    the **Static Mesh** section, click on the **None** button and select **TemplateCube_Rounded**.
    As soon as you set the mesh, it will appear in the **Viewport**. With the cube
    selected, decrease its scale (located in the **Details** panel) from `1` to `0.2`
    along all three axes.'
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need is a trigger box. Click on the **Add Component** button
    and select **Box Collision** in the **Collision** section. Once added, increase
    its scale from `1` to `9` along all three axes, and place it in such a way that
    its bottom is in line with the bottom of the cube.
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewport](img/image00346.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Construction Script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could set its material in the **Details** panel itself by clicking on the
    **Override Materials** button in the **Rendering** section, and selecting the
    key cube material. However, we are going to assign its material using **Construction
    Script**. Switch to the **Construction Script** tab. You will see a node called
    **Construction Script**, which is present by default. You cannot delete this node;
    this is where the script starts. However, before we can script it in, we will
    need to create a variable of the type `Material`. In the **My Blueprint** section,
    click on **Add New** and select **Variable** in the dropdown menu. Name this variable
    `Key Cube Material`, and change its type from **Bool** (which is the default variable
    type) to **Material** in the **Details** panel. Also, be sure to check the **Editable**
    box so that we can edit it from outside the Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Construction Script](img/image00347.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, drag the **Key** **Cube Material** variable from the **My Blueprint**
    panel, drop it in the **Graph Editor**, and select **Set** when the window opens
    up. Connect this to the output pin of the **Construction Script** node. Repeat
    this process, only this time, select **Get** and connect it to the input pin of
    **Key Cube Material**.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the **Graph Editor** window and type in **Set Material** in the
    search bar. You should see **Set Material (Static Mesh)**. Click on it and add
    it to the scene. This node already has a reference of the Static Mesh actor (**TemplateCube_Rounded**),
    so we will not have to create a reference node. Connect this to the **Set** node.
    Finally, drag **Key Cube Material** from **My Blueprint**, drop it in the **Graph
    Editor**, select **Get**, and connect it to the **Material** input pin. After
    you are done, hit **Compile**. We will now be able to set the cube's material
    outside of the Blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Construction Script](img/image00348.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's test it out. Add the Blueprint class to the level. You will see a **TemplateCube_Rounded**
    actor added to the scene. In its **Details** panel, you will see a **Key Cube
    Material** option under the **Default** section. This is the variable we created
    inside our **Construction Script**. Any material we add here will be added to
    the cube. So, click on **None** and select **KeyCube_Material**. As soon as you
    select it, you will see the material on the cube. This is one of the many things
    you can do using **Construction Script**. For now, only this will do.
  prefs: []
  type: TYPE_NORMAL
- en: The Event Graph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now need to script the key cube's functionalities. This is more or less the
    same as what we did in the Level Blueprint with our first key cube, with some
    small differences. In the **Event Graph** panel, the first thing we are going
    to script is enabling and disabling input when the player overlaps and stops overlapping
    the trigger box respectively. In the **Components** section, right-click on **Box**.
    This will open a menu. Mouse over **Add Event** and select **Add OnComponentBeginOverlap**.
    This will add a **Begin Overlap** node to the **Graph Editor**. Next, we are going
    to need a **Cast** node. A **Cast** node is used to specify which actor you want
    to use. Right-click in the **Graph Editor** and add a **Cast to Character** node.
    Connect this to the **OnComponentBeginOverlap** node and connect the other actor
    pin to the **Object** pin of the **Cast to Character** node. Finally, add an **Enable
    Input** node and a **Get Player Controller** node and connect them as we did in
    the Level Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add an event for when the player stops overlapping the
    box. Again, right-click on **Box** and add an **OnComponentEndOverlap** node.
    Do the exact same thing you did with the **OnComponentBeginOverlap** node; only
    here, instead of adding an **Enable Input** node, add a **Disable Input** node.
    The setup should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Event Graph](img/image00349.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can move the key cube we had placed earlier on top of the pedestal, set
    it to hidden, and put the key cube Blueprint class in its place. Also, make sure
    that you set the collision response of the trigger actor to **Ignore**.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Event Graph](img/image00350.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is scripting the destruction of the key cube when the player touches
    the screen. This, too, is similar to what we had done in Level Blueprint, with
    a few differences. Firstly, add a **Touch** node and a **Sequence** node, and
    connect them to each other. Next, we need a **Destroy Component** node, which
    you can find under **Components** | **Destroy Component** (Static Mesh). This
    node already has a reference to the key cube (Static Mesh) inside it, so you do
    not have to create an external reference and connect it to the node. Connect this
    to the **Then 0** node.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to activate the trigger after the player has picked up the key
    cube. Now, since we cannot call functions on actors outside the Blueprint class
    directly (like we could in Level Blueprint), we need to create a variable. This
    variable will be of the type Trigger Box. The way this works is, when you have
    created a **Trigger Box** variable, you can assign it to any trigger in the level,
    and it will call that function to that particular trigger. With that in mind,
    in the **My Blueprint** panel, click on **Add New** and create a variable. Name
    this variable **Activated Trigger Box**, and set its type to **Trigger Box**.
    Finally, make sure you tick on the **Editable** box; otherwise, you will not be
    able to assign any trigger to it. After doing that, create a **Set Collision Response
    to All Channels** node (uncheck the Context Sensitive box), and set the **New
    Response** option to **Overlap**. For the target, drag the **Activated Trigger
    Box** variable, drop it in the **Graph Editor**, select **Get**, and connect it
    to the **Target** input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for the Post Process Volume, we will need to create another variable
    of the type **PostProcessVolume**. You can name this variable **Visual Indicator**,
    again, while ensuring that the **Editable** box is checked. Add this variable
    to the **Graph Editor** as well. Next, click on its pin, drag it out, and release
    it, which will open the actions menu. Here, type in **Enabled**, select **Set
    Enabled**, and check **Enabled**. Finally, add a **Delay** node and a **Destroy
    Actor** and connect them to the **Set Enabled** node, in that order. Your setup
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Event Graph](img/image00351.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Back in the **Viewport**, you will find that under the **Default** section
    of the Blueprint class actor, two more options have appeared: **Activated Trigger
    Box** and **Visual Indicator** (the variables we had created). Using this, you
    can assign which particular trigger box''s collision response you want to change,
    and which exact post process volume you want to activate and destroy. In front
    of both variables, you will see a small icon in the shape of an eye dropper. You
    can use this to choose which external actor you wish to assign the corresponding
    variable. Anything you scripted using those variables will take effect on the
    actor you assigned in the scene. This is one of the many amazing features offered
    by the Blueprint class. All we need to do now for the remaining key cubes is:'
  prefs: []
  type: TYPE_NORMAL
- en: Place them in the level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the eye dropper icon that is located next to the name of the variables,
    pick the trigger to activate once the player has picked up the key cube, and which
    post process volume to activate and destroy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second room, we have two key cubes: one to activate the large door and
    the other to activate the door leading to the third room. The first key cube will
    be placed on the pedestal near the big door. So, with the first key cube selected,
    using the eye dropper, select the trigger box on the pedestal near the big door
    for the **Activated Trigger Box** variable. Then, pick the post process volume
    inside which the key cube is placed for the **Visual Indicator** variable.'
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need to do is to open **Level Blueprint** and script in what
    happens when the player places the key cube on the pedestal near the big door.
    Doing what we did in the previous room, we set up nodes that will unhide the hidden
    key cube on the pedestal, and change the collision response of the trigger box
    around the big door to **Overlap**, ensuring that it was set to **Ignore** initially.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Event Graph](img/image00352.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test it out! You will find that everything is working as expected. Now, do the
    same with the remaining key cubes. Pick which trigger box and which post process
    volume to activate when you touch on the screen. Then, in the Level Blueprint,
    script in which key cube to unhide, and so on (place the key cubes we had placed
    earlier on the pedestals and set it to **Hidden**), and place the Blueprint class
    key cube in its place.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the many ways you can use Blueprint class. You can see it takes
    a lot of work and hassle. Let us now move on to Artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting basic AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming back to the third room, we are now going to implement AI in our game.
    We have an AI character in the third room which, when activated, moves. The main
    objective is to make a path for it with the help of switches and prevent it from
    falling. When the AI character reaches its destination, it will unlock the key
    cube, which the player can then pick up and place on the pedestal. We first need
    to create another Blueprint class of the type **Character**, and name it `AI_Character`.
    When created, double-click on it to open it. You will see a few components already
    set up in the **Viewport**. These are the **CapsuleComponent** (which is mainly
    used for collision), **ArrowComponent** (to specify which side is the front of
    the character, and which side is the back), **Mesh** (used for character animation),
    and **CharacterMovement**. All four are there by default, and cannot be removed.
    The only thing we need to do here is add a **StaticMesh** for our character, which
    will be **TemplateCube_Rounded**.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add Components**, add a **StaticMesh**, and assign it **TemplateCube_Rounded**
    (in its **Details** panel). Next, scale this cube to `0.2` along all three axes
    and move it towards the bottom of the **CapsuleComponent**, so that it does not
    float in midair.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00353.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is all we require for our AI character. The rest we will handle in Level
    Blueprints. Next, place **AI_Character** into the scene on the Player side of
    the pit, with all of the switches. Place it directly over the Target Point actor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00354.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, open up Level Blueprint, and let's begin scripting it. The left-most switch
    will be used to activate the AI character, and the remaining three will be used
    to draw the parts of a path on which it will walk to reach the other side.
  prefs: []
  type: TYPE_NORMAL
- en: To move the AI character, we will need an **AI Move To** node. The first thing
    we need is an overlapping event for the trigger over the first switch, which will
    enable the input, otherwise the AI character will start moving whenever the player
    touches the screen, which we do not want. Set up an **Overlap** event, an **Enable
    Input** node, and a **Gate** event. Connect the **Overlap** event to the **Enable
    Input** event, and then to the **Gate** node's **Open** input.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing is to create a **Touch** node. To this, we will attach an **AI
    Move To** node. You can either type it in or find it under the AI section. Once
    created, attach it to the **Gate** node's **Exit** pin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00355.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now need to specify to the node which character we want to move, and where
    it should move to. To specify which character we want to move, select the AI character
    in the **Viewport**, and in the Level Blueprint's **Graph Editor**, right-click
    and create a reference for it. Connect it to the **Pawn** input pin. Next, for
    the location, we want the AI character to move towards the second **Target Point**
    actor, located on the other side of the pit. But first, we need to get its location
    in the world. With it selected, right-click in the **Graph Editor**, and type
    in `Get Actor Location`. This node returns an actor's location (coordinates) in
    the world (the one connected to it). This will create a **Get Actor Location**,
    with the **Target Point** actor connect to its input pin.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, connect its **Return Value** to the **Destination** input of the **AI
    Move To** node.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00356.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you were to test it out, you would find that it works fine, except for one
    thing: the AI character stops when it reaches the edge of the pit. We want it
    to fall off the pit if there is no path. For that, we will need a **Nav Proxy
    Link** actor. As discussed in the previous chapter, a **Nav Proxy Link** actor
    is used when an AI character has to step outside the Nav Mesh temporarily (for
    example, jump between ledges). We will need this if we want our AI character to
    fall off the ledge. You can find it in the **All Classes** section in the **Modes**
    panel. Place it in the level.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00357.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The actor is depicted by two cylinders with a curved arrow connecting them.
    We want the first cylinder to be on one side of the pit and the other cylinder
    on the other side. Using the **Scale** tool, increase the size of the **Nav Proxy
    Link** actor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00358.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When placing the **Nav Proxy Link** actor, keep two things in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that both cylinders intersect in the green area; otherwise, the actor
    will not work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that both cylinders are in line with the AI character; otherwise, it
    will not move in a straight line but instead to where the cylinder is located
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once placed, you will see that the AI character falls off when it reaches the
    edge of the pit. We are not done yet. We need to bring the AI character back to
    its starting position so that the player can start over (or else the player will
    not be able to progress). For that, we need to first place a trigger at the bottom
    of the pit, making sure that if the AI character does fall into it, it overlaps
    the trigger. This trigger will perform two actions: first, it will teleport the
    AI character to its initial location (with the help of the first Target Point);
    second, it will stop the **AI Move To** node, or it will keep moving even after
    it has been teleported.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00359.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After placing the trigger, open Level Blueprint and create an Overlap event
    for the trigger box. To this, we will add a **Sequence** node, since we are calling
    two separate functions for when the player overlaps the trigger. The first node
    we are going to create is a **Teleport** node. Here, we can specify which actor
    to teleport, and where. The actor we want to teleport is the AI character, so
    create a reference for it and connect it to the **Target** input pin. As for the
    destination, first use the **Get Actor Location** function to get the location
    of the first Target Point actor (upon which the AI character is initially placed),
    and connect it to the **Dest Location** input.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00360.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To stop the AI character's movement, right-click anywhere in the **Graph Editor**,
    and first uncheck the **Context Sensitive** box, since we cannot use this function
    directly on our AI character. What we need is a **Stop Active Movement** node.
    Type it into the search bar and create it. Connect this to the **Then 1** output
    node, and attach a reference of the AI character to it. It will automatically
    convert from a **Character Reference** into **Character Movement** component reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is all that we need to script for our AI in the third room. There is one
    more thing left: how to unlock the key cube. But we will cover this in the next
    chapter since it involves Matinee.'
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth room, we are going to use the same principle. Here, we are going
    to make a chain of **AI Move To** nodes, each connected to the previous one's
    **On Success** output pin. This means that when the AI character has successfully
    reached the destination (Target Point actor), it should move to the next, and
    so on. Using this, and what we have just discussed about AI, script the path that
    the AI will follow (recall the previous chapter, where we lined out the path the
    AI character would take in the fourth room).
  prefs: []
  type: TYPE_NORMAL
- en: '![Scripting basic AI](img/image00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered with Blueprints and discussed how they work. We
    also discussed Level Blueprints and the Blueprint class, and covered how to script
    AI. We still have a few more things to script, but first we will have to cover
    the topic of Unreal Matinee. In the next chapter, we will be doing just that.
  prefs: []
  type: TYPE_NORMAL
