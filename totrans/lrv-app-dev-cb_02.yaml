- en: Chapter 2. Using Forms and Gathering Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple form
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering form input to display on another page
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user input
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a file uploader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating a file upload
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom error message
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a "honey pot" to a form
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading an image using Redactor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cropping an image with Jcrop
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an autocomplete text input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a CAPTCHA style spam catcher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about using forms in Laravel, and how to accomplish
    some typical tasks. We'll begin with some simple form validation and file uploads,
    and move on to incorporating some frontend tools, such as Redactor and jCrop,
    into Laravel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple form
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most basic aspects of any web application is the form. Laravel provides
    easy ways to build HTML for our forms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we need a fresh installation of Laravel.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In the `app/views` folder, create a new `userform.php` file.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `routes.php`, create a route to load the view:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `userform.php` view, create a form using the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: View your form in the web page, by going to `http://{your-server}/userform`
    (where `{your-server}` is the name of your server).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this task, we created a simple form using Laravel's built-in `Form` class.
    This allows us to easily create form elements with minimal code, and it's W3C
    (World Wide Web Consortium) compliant.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: First, we open the form. Laravel automatically creates the `<form>` html, including
    the action, the method, and the accept-charset parameters. When there are no options
    passed in, the default action is the current URL, the default method is `POST,`
    and the charset is taken from the application config file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Next we create normal text and password input fields, along with their labels.
    The first parameter in the label is the name of the text field and the second
    is the actual text to print. In the form builder, the label should appear before
    the actual form input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The form select requires a second parameter, an array of the value in the drop-down
    box. In this example, we're creating an array using the `'key' => 'value'` syntax.
    If we want to create option groups, we just need to create nested arrays.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create our Submit button and close the form.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of Laravel's form methods can also include parameters for a default value
    and custom attributes (classes, IDs, and so on). We could also use `Form::input()`
    for many fields, if we didn't want to use the specific methods. For example, we
    could have `Form::input('submit', NULL, 'Send it!')` to create a submit button.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Gathering form input to display on another page* recipe
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering form input to display on another page
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a user submits a form, we need to be able to take that information and
    pass it to another page. This recipe shows how we can use Laravel's built-in methods
    to handle our POST data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need the simple form set up from the *Creating a simple form* section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route to handle the POST data from the form:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a route to redirect to, and to display the data:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our simple form, we're POSTing the data back to the same URL, so we need
    to create a route that accepts `POST` using the same path. This is where we would
    do any processing of the data, including saving to a database or validating the
    input.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we simply want to pass the data to the next page. There are a
    number of ways to accomplish this. For example, we could use the `Input` class''s
    `flashOnly()` method:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, we're using a shortcut that Laravel provides, and only passing along
    two of the three form fields we asked for.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: On the next page, we use `Input::old()` to display the flashed input.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a simple form* recipe
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user input
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most web applications, there will be certain form fields that are required
    to process the form. We also want to be sure that all the e-mail addresses are
    formatted correctly, or the input must have a certain number of characters. Using
    Laravel's `Validator` class, we can check for these rules and let the user know
    if something is not correct.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we just need a standard installation of Laravel.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route to hold the form:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a view named `userform.php` and add a form:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a route that handles our `POST` data and validates it:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a route to handle a successful form submission:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our form page, we begin by checking if there are any errors and displaying
    them if found. Inside the error, we can set the default style for each error message.
    We also have the option of checking for and displaying errors for individual fields
    using `$errors->get('email')`. The `$errors` variable is automatically created
    by Laravel if it detects a flashed error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create our form. In the last parameter of the form elements, we're
    getting `Input::old()`, which we use to store the previous input if the validation
    happens to fail. That way, the user won't need to keep filling out the entire
    form.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We then create a route where the form is POSTed, and set up our validation rules.
    In this case, we use the required rule for `email`, `username`, and `password`,
    to make sure something is typed into those fields.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The `email` field also gets the `email` rule, which uses PHP's built-in `FILTER_VALIDATE_EMAIL`
    filter of the `filter_var` function. The `email` field must also not be the same
    as the `username` field. The `username` field uses the size validation to check
    for at least six characters. Then the `password` field checks the value of the
    `password_confirm` field and makes sure they're the same.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the validator and pass in all of the form data. If any of those
    rules aren't met, we navigate the user back to the form, and also send back any
    validation error messages as well as the original form input.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: If the validation passes, we go to the next page using Laravel's `dd()` helper
    function, which uses `var_dump()` to show the form values on the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The Creating a simple form recipe*'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a file uploader
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may be times when we'd like the user to upload a file to our server. This
    recipe shows how Laravel can handle file uploads through a web form.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a file uploader, we need a standard version of Laravel installed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route in our `routes.php` file to hold the form:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the `fileform.php` View in our `app/views` directory:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a route to upload and save the file:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our View, we use `Form::open ()` and pass in an array with `'files' => TRUE`
    that automatically sets the enctype in the `Form` tag; then we add a form field
    to take the file. Without using any other parameters in `Form::open()`, the form
    will use the default method of `POST` and action of the current URL. `Form::file()`
    is our input field to accept the files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Since our form is posting to the same URL, we need to create a route to accept
    the `POST` input. The `$file` variable will hold all the file information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to save the file with a different name but first we need to get
    the extension of the uploaded file. So we use the `guessExtension()` method, and
    store that in a variable. Most of the methods for using files are found in Symfony's
    File libraries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we move the file to its permanent location using the file's `move()`
    method, with the first parameter being the directory where we will save the file;
    the second is the new name of the file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If everything uploads correctly, we show `'Success'`, and if not we show `'Error'`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Validating a file upload* recipe
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating a file upload
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to allow users to upload a file through our web form, we may want
    to restrict which kind of file they upload. Using Laravel's `Validator` class,
    we can check for a specific file type, and even limit the upload to a certain
    file size.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need a standard Laravel installation, and an example file
    to test our upload.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route for the form in our `routes.php` file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the form view:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a route to validate and process our file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with a route to hold our form, and then a view for the form's html.
    At the top of the view, if we get any errors in validation, they will be echoed
    out here. The form begins with `Form::open (array('files' => TRUE))`, which will
    set the default action, method, and `enctype` for us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a route to capture the post data and validate it. We set a `$rules`
    variable as an array, first checking for a specific mime type. There can be as
    few or as many as we want. Then we make sure the file is less than 1000 kilobytes,
    or 1 megabyte.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: If the file isn't valid, we navigate the user back to the form with the error
    messages. The `$error` variable is automatically created in our view if Laravel
    detects a flashed error message. If it is valid, we attempt to save the file to
    the server. If it saves correctly, we'll see `"Success"`, and if not, we'll see
    `"Error"`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One other common validation for files is to check for an image. For that, we
    can use this in our `$rules` array:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will check to make sure the file is either a `.jpg`, `.png`, `.gif`, or
    `.bmp` file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a file uploader* recipe
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom error message
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel has built-in error messages if a validation fails, but we may want to
    customize those messages to make our application unique. This recipe shows a few
    different ways to create custom error messages.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we just need a standard installation of Laravel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route in `routes.php` to hold the form:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a view named `myform.php` and add a form:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a route that handles our POST data and validates it:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open the file `app/lang/en/validation.php`, where `en` is the default language
    of the app. In our case, we''re using English. At the bottom of the file, update
    the `attributes` array as the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a route to handle a successful form submission:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first create a fairly simple form, and since we aren't passing any parameters
    to `Form::open()`, it will POST the data to the same URL. We then create a route
    to accept the `POST` data and validate it. As a best practice, we're also adding
    in the `csrf` filter before our `post` route. This will provide some extra security
    against cross-site request frogeries.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The first variable we set in our `post` route will hold our rules. The next
    variable will hold any custom messages we want to use if there's an error. There
    are a few different ways to set the message.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The first message to customize is for `min` size. In this case, it will display
    the same message for any validation errors where there's a `min` rule. We can
    use `:attribute` and `:min` to hold the form field name and minimum size when
    the error is displayed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Our second message is used only for a specific form field and for a specific
    validation rule. We put the form field name first, followed by a period, and then
    the rule. Here, we are checking whether the username is required and setting the
    error message.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Our third message is set in the language file for validations. In the `attributes`
    array, we can set any of our form field names to display any custom text we'd
    like. Also, if we decide to customize a particular error message across the entire
    application, we can alter the default message at the top of this file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we look in the `app/lang` directory, we see quite a few translations that
    are already part of Laravel. If our application is localized, we can set custom
    validation error messages in any language we choose.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a simple form* recipe
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a honey pot to a form
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sad reality of the Web is that there are "spam bots" that search the web and
    look for forms to submit spam to. One way to help combat this is to use a technique
    called a **honey pot**. In this recipe, we'll create a custom validation to check
    for spam submissions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we just need a standard Laravel installation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route in `routes.php` to hold our form:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a view in our `app/view` directory named as `myform.php` and add the
    form:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a route in our `routes.php` file to handle the `post` data, and validate
    it:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our `routes.php` file, create a custom validation:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a simple route to use for a success page:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first create a fairly simple form; since we aren't passing any parameters
    to `Form::open()`, it will POST the data to the same URL. In the form, we create
    a field that's designed to be empty, but hide it from the user using CSS. By naming
    it as something with the word `email` in it, many spam bots will mistake it for
    an `email` field and try to populate it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We then create a route to accept the `post` data and validate it, along with
    having a `csrf` filter added before the route. We add a custom validation rule
    to our `no_email` field, which will make sure that field stays empty. We also
    create an error message for that rule in the `$messages` array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Next, we actually create our custom validation rule in the `routes` file. This
    rule will get the value from the form field and return `TRUE` if the value is
    empty.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Now, if a bot tries to fill in the entire form, it will not validate since that
    extra field is designed to stay empty.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One alternative to creating a custom validation is to use the rule `size: 0`,
    which will make sure the `honey_pot` field is exactly `0` characters in length.
    However, this method keeps the validation check much simpler.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We might also want to redirect any honey pot errors to another page that doesn't
    have a form. That way, any automatic form submission scripts won't continue to
    try and submit the form.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Uploading an image using Redactor
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different JavaScript libraries that can turn a form's text area
    into a WYSIWYG editor. Redactor is a newer library but is very well coded and
    has gained quite a bit of popularity in a short amount of time. For this recipe,
    we'll apply Redactor to our Laravel form, and create routes to allow for image
    uploads through Redactor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download a copy of Redactor from [https://github.com/dybskiy/redactor-js/tree/master/redactor](https://github.com/dybskiy/redactor-js/tree/master/redactor).
    Download `redactor.min.js` and save it to the `public/js` directory. Download
    `redactor.css` and save it to the `public/css` directory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route in our `routes.php` file to hold our form with the `redactor`
    field:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a view in our `app/views` directory and name it as `redactor.php`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Make a route that will handle the image upload:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create another route to show our form input after it''s submitted:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After creating our form route, we create the view to hold our form HTML. In
    the head of the page, we load in the redactor CSS, the jquery library (using Google's
    CDN), and the redactor JavaScript file.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Our form will only have one field, a text area named `mytext`. In our script
    area, we initialize Redactor on the text area field and set the `imageUpload`
    parameter to a route or controller that will accept the image upload. Ours is
    set to `redactorupload`, so we create a route for it that accepts `post` data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In our `redactorupload` route, we do some validation and, if everything is okay,
    the image will upload to our images directory. To get the image to display in
    our text area, it needs a JSON array with a file link as the key and the image
    path as the value. For this, we'll use Laravel's built-in `Response::json` method,
    and pass in an array with the image's location.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: On our form page, if the image validated and uploaded correctly, Redactor will
    display the image inside the text area. If we submit, we'll see the text included
    the `<img>` tag and the image path.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this recipe is specifically for image uploads, non-image file uploads
    work in a very similar manner. The only real difference is that file upload route
    should also return filename in the JSON output.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Cropping an image with Jcrop
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Image editing and manipulation can sometimes be a difficult thing to implement
    in our application. Using Laravel and the Jcrop JavaScript library, we can make
    the task much simpler.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to download the Jcrop library from [http://deepliquid.com/content/Jcrop_Download.html](http://deepliquid.com/content/Jcrop_Download.html)
    and unzip it. Put the file `jquery.Jcrop.min.js` into our `public/js` directory,
    and the `jquery.Jcrop.min.css` and `Jcrop.gif` files into our `public/css` directory.
    We'll use the Google CDN version of jQuery. We also need to make sure we have
    the GD library installed on our server, so we can do image manipulation. In our
    `public` directory, we'll need an images folder to store the images, and should
    have the permission set for it to be writable.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to finish this recipe:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a route in our `routes.php` file to hold our form:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create the form for uploading an image, in `app/views` with the filename `imageform.php`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Make a route to handle the image upload and validation:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a route for our Jcrop form:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Make a form, where we can crop the image, in our `app/views` directory with
    the filename `jcrop.php`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create a route that will process the image and display it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with a basic file upload; to make it easier, we'll only be using `.jpg`
    files. We use the validation to check for the image type as well as making sure
    the file size is under 10,000 kilobytes. After the file is uploaded, we send the
    path to our Jcrop route.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In the HTML for the Jcrop route, we create a form with hidden fields that will
    hold the dimensions of the cropping. The JavaScript function `updateCoords` takes
    the cropping dimensions and updates the values of those hidden fields.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: When we're done cropping, we submit the form and our route gets the POST data.
    The image is run through the GD library and cropped, based on the dimensions that
    were posted. We then overwrite the image and display the updated and cropped file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this recipe only covers cropping a jpg image, adding in `gif` and `png`
    images wouldn't be very difficult. We'd just need to get the file extension by
    passing the file name to Laravel using `File::extension()`. Then, we could either
    do a `switch` or `if` statement to use the appropriate PHP function. For example,
    if the extension is `.png`, we'd use `imagecreatefrompng()` and `imagepng()`.
    More information can be found at [http://www.php.net/manual/en/ref.image.php](http://www.php.net/manual/en/ref.image.php).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Creating an autocomplete text input
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On our web forms, there may be times when we want to have an autocomplete text
    field. This can be handy for populating common search terms or product names.
    Using the jQueryUI Autocomplete library along with Laravel, that becomes an easy
    task.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll be using the CDN versions of jQuery and jQueryUI; however,
    we could also download them and place them in our `public/js` directory, if we
    wanted to have them locally.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a route to hold our autocomplete form:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Make a view in the `app/views` directory named `autocomplete.php` with our
    form''s HTML and JavaScript:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a route that will populate the data for the `autocomplete` field:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our form, we're creating a text field to accept user input that will be used
    for the `autocomplete`. There's also a disabled text field that we can use to
    see the ID of the value that was selected. This can be useful if you have an ID
    for a particular value that's numeric, or otherwise not named in a standard way.
    In our example, we're using the first letter of the color as the ID.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: As the user starts typing, `autocomplete` sends a `GET` request to the source
    that we added, using the word `term` in the query string. To process this, we
    create a route that gets the input, and convert it to lower-case. For our data,
    we're using a simple array of values but it would be fairly easy to add in a database
    query at this point. Our route checks the values in the array to see if there
    are any matches with the user input and, if so, adds the ID and value to the array
    we will return. Then, we output the array as JSON, for the `autocomplete` script.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Back on our form page, when the user selects a value, we add the ID to the disabled
    response field. Many times, this will be a hidden field, which we can then pass
    on when we submit the form.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we'd like to have our `getdata` route only accessible from our autocomplete
    form, or some other AJAX request, we could simply wrap the code in `if (Request::ajax())
    {}` or create a filter that rejects any non-AJAX requests.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Making a CAPTCHA-style spam catcher
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to combat "bots" that automatically fill in web forms is by using the
    CAPTCHA technique. This shows the user an image with some random letters; the
    user must fill in a text field with those letters. In this recipe, we will create
    a CAPTCHA image and verify that the user has entered it correctly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a standard Laravel installation and make sure we have the GD2 library
    installed on our server, so we can create an image.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, follow these steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `app` directory, create a directory named `libraries`, and in our `composer.json`
    file, update it as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In our `app/libraries` directory, create a file named `Captcha.php` to hold
    our simple `Captcha` class:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the root of our app, open the command-line interface to update the `composer`
    autoloader:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a route in `routes.php` to hold the form with `captcha`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create our `captcha` view in the `app/views` directory with the name `captcha.php`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a route to compare the `captcha` value and the user input:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We begin by updating our `composer.json` file to add our `libraries` directory
    to the autoloader. Now, we can add any classes or libraries we'd like into that
    directory, even if they're custom classes or possibly some legacy code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, we create a simple `Captcha` class with a single `make()`
    method. In this method, we first create a random string using Laravel's `Str:random()`,
    which we tell to output a 6-character string of only letters. We then save that
    string to a session, so we can use it for validation later.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Using the string, we create a 100x25 pixel jpg image, with a gray background
    and darker gray text. Instead of saving the file to the server, we use the output
    buffer and save the image data to a variable. That way, we can create a data URI
    to send back to our route.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串，我们创建了一个100x25像素的jpg图像，背景为灰色，文本为深灰色。我们不是将文件保存到服务器，而是使用输出缓冲区并将图像数据保存到一个变量中。这样，我们可以创建一个数据URI并发送回我们的路由。
- en: Next, we need to run composer's `dump-autoload` command, so our new class can
    be used by the application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行composer的`dump-autoload`命令，这样我们的新类才能被应用程序使用。
- en: In our `captcha` route, we use the `Captcha` class to create the `captcha` data
    URI and send it to our form. For our purposes, the form will simply display the
    image and ask for the characters in a text field.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`captcha`路由中，我们使用`Captcha`类来创建`captcha`数据URI并将其发送到我们的表单。对于我们的目的，表单将简单地显示图像并要求在文本字段中输入字符。
- en: When the user submits the form, we compare the Session that the `Captcha` class
    created with the user input. In this recipe, we're just checking if the two values
    match but we could also create a custom validation method and add it our rules.
    We then set a session saying if it matched or not, and return the user back to
    the CAPTCHA page.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户提交表单时，我们将比较`Captcha`类创建的Session与用户输入。在这个示例中，我们只是检查这两个值是否匹配，但我们也可以创建一个自定义验证方法并将其添加到我们的规则中。然后我们设置一个会话来表示是否匹配，并将用户返回到CAPTCHA页面。
