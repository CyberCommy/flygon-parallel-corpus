- en: Testing and Tracing in Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have got to see how microservices can help us change the way
    that we build and deliver our application to production. Be it faster rollouts
    for new features, or keeping the teams small, microservices enable that for us.
    But with this architecture, where every single component is a small service in
    its own, we have got some challenges to solve. These challenges involve how we
    can aim to ship a stable and bug free application into production while following
    the microservices approach.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the Monolithic architecture, we had only a small number of moving components
    that required testing. We could write unit tests to test the individual methods
    of the Monolithic application, and then move on to integration testing to verify
    if these components operate correctly with each other. But now, with the advent
    of microservices, we have got more and more moving components in the picture.
    Inside the microservices, we have different features where each feature is described
    as its own microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this chapter, we will take a look at how the testing of microservices
    differ from that of the Monolithic applications, where we now need to account
    not only for the correct functioning of an individual microservice, but also have
    to make sure that these services communicate with each other in a well-defined
    manner to produce the correct results for the business needs.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since the information in a microservices-based application flows from
    one service to another, it becomes important for us to understand the flow of
    this information when a client makes a request to when the response is generated.
    By doing this, we can accurately find and fix any of the issues that may generate
    an incorrect response or cause a bottleneck in the application performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reader, by the end of this chapter, you can expect to learn about the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the testing of Monolithic applications and microservices-based
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approaching the testing of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing distributed tracing inside microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code listings in this book can be found under `chapter12` directory at [https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python](https://github.com/PacktPublishing/Hands-On-Enterprise-Application-Development-with-Python).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code samples can be cloned by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The requirements for the Python-based application can be installed by executing
    the following command on your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Beyond the usual Python-based requirements, the code samples in this chapter
    need to have the following additional dependencies to work correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker**: The docker client is required to run some of the tools that we
    will be using inside the ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in the microservices world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move away from the Monolithic architecture, we need to understand that
    the processes that used to work for us in the Monolithic application development
    also need to move along. During the development of the Monolithic application,
    we used to work with the testing strategies such as unit testing, which aimed
    to cover the functionality of the individual methods inside an application, followed
    by integration testing, which is used to cover the fact that these methods operate
    correctly with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the microservices architecture, things get a little bit complicated.
    We now have small services where each service is supposed to perform a specific
    functionality. These services indeed need to interact with each other over the
    network to produce any meaningful output for the business use case that might
    be there. But things do not end here. Each of these microservices are composed
    of several individual methods and interfaces that it needs to work correctly.
    This makes the case of testing the microservices an interesting one, because now,
    we not only need to perform the unit testing of the individual components of the
    microservices and the interaction between them, but we also need to test if the
    microservices are able to operate correctly with each other.
  prefs: []
  type: TYPE_NORMAL
- en: This asks for a more elaborate testing of the application, with several different
    techniques. Let's take a look at these techniques to understand them better.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing inside microservices follows the same principles as in the testing
    of the Monolithic applications. We work on writing the unit tests for the individual
    methods inside a microservice and run those tests either manually or through automation
    so as to validate if those components are producing the expected result or not.
  prefs: []
  type: TYPE_NORMAL
- en: Functionality testing in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are sure that the individual methods inside a microservice work properly,
    we need to make sure that a microservice, in its complete independence, is able
    to function without any kind of issues. This happens because most of the microservices
    are a complete package in themselves. They come with their own set of dependencies,
    as well as the data sources through which they can manage their data.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, it is important for us to make sure that the microservice is
    able to interact properly with its dependencies. For this, we work on implementing
    the functionality testing for the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Also, during the functionality testing, we need to take care of certain things.
    Since each API endpoint inside a microservice may need to interact with some other
    microservice to produce the correct result, we might need to mock the presence
    of some microservices for the functionality testing to complete successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are sure that our microservices work correctly with their dependencies,
    it's time for us to make sure that they have the same checkboxes ticked when they
    are interacting with each other. This is important due to the fact that these
    services, no matter what, need to interact with each other to produce any meaningful
    business outcome.
  prefs: []
  type: TYPE_NORMAL
- en: During the integration tests, we usually aim to test the request response cycle
    by introducing both the correct and incorrect parameters to an API endpoint so
    as to verify that the microservices are able to handle both the use cases and
    do not fail. This ensures that the communication interfaces between two external
    services are robust enough for the varied inputs that ...
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end testing in microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have assured that the different microservices are able to operate seamlessly
    with each other to generate a meaningful result, it's time to validate if the
    whole system, consisting of the different microservices and their dependencies,
    work without any problems. This kind of testing aims to cover the request-response
    cycle through the whole system, validating the outputs produced in the intermediate
    stages, as well as the final stages. This is known as **end-to-end** testing.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of testing ensures that the system as a whole behaves in a well-defined
    manner and does not produce any surprises when an input that is beyond the domain
    of the system is provided to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every microservice inside the infrastructure is made to handle a certain set
    of requests. As the number of requests to the application increases, some of the
    microservices may see an increased load on them in comparison to the other services.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine there is an e-commerce website that is based upon the microservices
    architecture. There is a flash sale going on, and a lot of customers are trying
    to checkout and pay for their purchase at the same time. If the services that
    handle the checkout and payment for the customers does not scale up during the
    increased load, the customers may face increased response times or timeouts, creating
    chaos for the e-commerce company, whose customer care might now be busy in dealing
    with ...
  prefs: []
  type: TYPE_NORMAL
- en: Challenges in microservices testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The microservice architecture raises quite some challenges when it comes to
    testing. These challenges sometimes happen as a side effect of the architecture,
    the poor testing strategy, or the inexperience with the microservices architecture.
    The following are some of the challenges that make microservices testing a complex
    procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incomplete knowledge of the microservices**: For integration testing and
    debugging of issues inside an application built over microservices architecture,
    the tester responsible for writing the tests for the application needs to have
    complete knowledge about the infrastructure and the individual microservices.
    Without this knowledge, the tester is unable to write tests that can cover all
    the possible request flows inside an application that may result in some of the
    bugs escaping during the testing phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poor coordination**: In the development of microservices, there are multiple
    teams that own their set of microservices, and are usually working on their pace.
    This may cause an issue in the coordination and can delay the testing of the application
    in case a microservice, on which there are certain dependencies, has still not
    come out of the development phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased complexity**: For an application that has only a small number of
    microservices, the testing is usually easy. But this testing becomes more and
    more cumbersome as the number of microservices powering an application increases.
    This is because now, the testers are supposed to write tests for the increased
    number of request flows, and also to make sure that the different API endpoints
    function as intended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High flexibility**: Microservices allow for increased flexibility. As a developer,
    we are free to choose a technology stack that is going to power a particular microservice.
    The same thing adds to the increased issues for the testing of the application
    because now, the tests need to take into account the different types of components
    that are being used to power a particular microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding points are a few challenges that make the work of testing the
    microservices a challenging task. However, every problem comes with a solution,
    and so do these challenges. Let''s take a look at the possible workarounds we
    have to overcome these challenges, outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement release schedules**: The teams responsible for building an application
    can commit to a schedule for the release of application in terms of Milestone.
    At every stage in the Milestone, some of the services are made available for testing
    based on the priority of the service to be deployed. This helps in improving the
    team''s coordination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standardize the API endpoints:** Every service needs to expose a set of APIs
    that it uses for taking in a request and generating a response. Standardizing
    the APIs and defining what parameters a particular API endpoint may require helps
    a lot during the testing phase, where the testers can now mock a service easily,
    even if the service is not yet available for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standardize development practices**: Although every team that is responsible
    for the development of a particular microservice is free to use any set of tools
    for the development of microservice, it is usually a good practice to standardize
    the set of tools and technologies that may be used by a team so as to avoid unnecessary
    complexity inside the infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration of DevOps practices**: As the shift to microservices architecture
    happens, the DevOps practices should also be adopted, which aims to make the teams
    responsible for the complete life cycle of the microservice they are developing.
    This not only helps in speeding up the development process, but also allows for
    thorough testing of the microservices before they are deployed in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we are aware of what kind of changes the process requires for the testing
    of the microservices architecture. This allows us to plan our strategy ahead,
    and make sure that the services are well-tested before they are deployed into
    the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of testing in place, it's now time to understand a very important
    concept in the area of microservices that allows us to understand how the individual
    services are behaving in production.  This also allows us to figure out where
    exactly a particular request inside a microservices-based application is failing.
    So, let's take a deep dive into this concept.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing requests inside microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside any application, a request may flow through several components before
    a final response for the request is generated. All of these components may do
    some processing that might be required on the process before they hand the request
    off to another component.
  prefs: []
  type: TYPE_NORMAL
- en: The tracing of a request allows us to visualize a rich amount of detail about
    the flow of a particular request. With the complete picture of the flow of the
    request, we can now work on finding out the places that may be causing a bottleneck
    in the performance of the request-response cycle, or figure out the components
    that may be causing the generation of an incorrect result.
  prefs: []
  type: TYPE_NORMAL
- en: Today, in the application development world, any serious application ...
  prefs: []
  type: TYPE_NORMAL
- en: The OpenTracing standard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, there are a number of solutions out there in the wild that provide
    the functionality of implementing tracing for applications. Some of these solutions
    are proprietary, while the others are open source in nature.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you are free to choose any of them based on the requirements
    of the application, and what facilities are provided by the solution you have
    chosen. But the problem is, what happens if you want to move to a different tracing
    solution because the solution provides better features and more control over the
    environment? Now you are stuck because you might need to change a lot of things
    in your infrastructure and the application code to get the new tracing solution
    to work. That's a lot of trouble.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenTracing standard provides a common set of vendor neutral APIs and instrumentation
    for implementing distributed tracing inside the applications. Any tracing solution
    that implements this set of standard APIs is compatible with the OpenTracing standard,
    and can interoperate with the other tools that follow the same standard.
  prefs: []
  type: TYPE_NORMAL
- en: Our choice of Jaeger as a tracing tool for our demo applications is also an
    OpenTracing compliant tool. Now, without spending any more time, let's get our
    hands dirty by implementing tracing inside the application we built in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing tracing inside ToDo manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we worked on building a simple application that allows
    us to manage `ToDo` lists. It's time for us to implement request tracing inside
    this application. For the first example, we will work on implementing tracing
    of the requests inside our user service.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the tracing to work, we will need to have a few requirements in place.
    If you followed the *Technical requirements* section of this book, you are in
    a good place to start working with the tutorial. But, before we dive into implementing
    the tracing, let''s take a look at the following components that we will require:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jaeger all-in-one image:** The Jaeger all-in-one image provides us with the
    Jaeger server, the agent, and a UI that ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside the microservices world, the requests may travel from one service to
    another before a final response is generated. Even our simple example of a `todo`
    list management application shows this behavior, where the `todo` manager service
    frequently makes a request to the user service to implement user authentication,
    and to gather the details about the user, thus creating a new `todo` list.
  prefs: []
  type: TYPE_NORMAL
- en: The distributed tracing system aims to enable the tracing of the requests while
    they travel from one microservice to another.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the tracing systems utilize a number of mechanisms, the easiest
    of which is to embed a unique tracing key into the HTTP headers of every request
    that is being made. The tracing system is then able to differentiate and aggregate
    a particular request as it flows from one service to another by reading the request
    identifier that is present in the HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time for us to see the distributed tracing in action. For this, we
    will make a few changes to enable tracing inside our `todo` manager service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet of code showcases the changes required to enable distributed
    tracing inside the `todo` manager service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code in place inside the `todo_service.py` file, we have
    the distributed tracing enabled. But before we see this in action, there are a
    few things that we need to take a look at. In the preceding code snippet, we imported
    one extra method named `install_all_patches()` from the `opentracing_instrumentation`
    library which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method is responsible for enabling the tracing of the actions that takes
    place inside the SQL library or through the `python_requests` library.
  prefs: []
  type: TYPE_NORMAL
- en: Once this library was imported along with the `jaeger_client` and `flask_opentracing`,
    we moved on to configure and enable the tracing for the application inside the
    `init_tracer` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the tracing configured, let's restart our application and then make
    a request to `http://localhost:5001/list/new` by passing the appropriate parameters
    to the API endpoint for creating a new `todo` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this action succeeds, we can navigate back to our Jaeger UI running at
    `http://localhost:16686` to see that the Jaeger UI shows the trace for the API
    call we just made. The following screenshot shows a sample of how the screen may
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/120840da-d633-454c-9c8e-560edce20740.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the preceding screenshot, the Jaeger UI does not only show
    the request trace for the todo manager API service endpoint, but also goes further
    into displaying the endpoint that was called inside the user service, while providing
    the details of how much time was spent in each of the API endpoints before the
    response was generated back to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we now have an idea of how the distributed tracing inside microservices
    looks. But what are the possible use cases that can see a benefit from having
    this kind of tracing in place? Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With distributed tracing in place inside our application based on microservices
    architecture, we have enabled a lot of power to tackle quite some use cases, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understanding the flow of the application**: With distributed tracing, we
    can now visualize how an incoming request from the client flows inside our application
    from one service to another. This kind of information is really useful in figuring
    out how the application works and to enable better testing of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Narrowing down the bugs**: With the idea of how the request goes from one
    service to another, we can quickly isolate the services that may be causing the
    request to produce an incorrect response by analysing what steps ...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we got to learn about how the move to microservices
    architecture affects the processes inside our application development life cycle.
    We got to learn about how the testing inside microservices-based applications
    differ from that of the Monolithic applications, and what kind of testing phases
    are usually required when dealing with the microservices architecture. We then
    learned about the challenges that arise in the testing phases, due to the move
    toward a microservices-based approach, and how we can overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this chapter took us through the journey of distributed tracing
    inside the application, where we did a hands-on to enable us to trace the flow
    of requests in the ToDo manager application we developed in the previous chapter.
    During this, we got to learn about how the tracing works, and how distributed
    tracing differs from the normal methods of tracing. We also learned about how
    the OpenTracing standard is helping provide a vendor neutral API for enabling
    distributed tracing inside microservices-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with all of this knowledge, let's move on to take a look at another approach
    of developing our enterprise applications where instead of building services or
    components, we will build functions that execute on the occurrence of a certain
    event. The next chapter takes us through this serverless approach of application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we write integration tests for microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does tracing a Monolithic application differ from that of microservices-based
    applications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other tools are available except Jaeger for enabling distributed tracing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we instrument a specific part of code using Jaeger?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
