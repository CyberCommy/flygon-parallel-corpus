- en: Introduction to Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have seen how parallel programming works. Parallelism
    is about creating small tasks called units of work that can be executed simultaneously
    by one or more application threads. Since threads run inside the application process,
    they notify the called thread once they finish using delegates.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by introducing the difference between synchronous
    code and asynchronous code. Then, we'll discuss when to use asynchronous code
    and when to avoid it. We will also discuss how asynchronous patterns have evolved
    over time. Finally, we will see how new features in parallel programming help
    us get around the complexities of asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous versus asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to use asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to avoid asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems you can solve using asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous patterns in early versions of C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you should have a good understanding of TPL and C#.
    The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Types of program execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At any point in time, program flow can either be synchronous or asynchronous.
    Synchronous code is easier to write and maintain but comes with performance overheads
    and UI responsiveness issues. Asynchronous code improves the performance and responsiveness
    of an application as a whole but, in turn, is difficult to write, debug, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We'll understand the synchronous and asynchronous way of program execution in
    detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding synchronous program execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case of synchronous execution, control never moves out of the calling
    thread. Code is executed one line at a time, and, when a function is called, the
    calling thread waits for the function to finish executing before executing the
    next line of code. Synchronous programming is the most commonly used method of
    programming and it works well due to the increase in CPU performance we have seen
    over the past few years. With faster processors, the code completes sooner.
  prefs: []
  type: TYPE_NORMAL
- en: 'With parallel programming, we have seen that we can create multiple threads
    that can run concurrently. We can start many threads but also make the main program
    flow synchronous by calling structures such as `Thread.Join` and `Task.Wait`.
    Let''s take a look at an example of synchronous code:'
  prefs: []
  type: TYPE_NORMAL
- en: We start the application thread by calling the `M1()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At line 3, `M1()` calls `M3()` synchronously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The moment the `M2()` method is called, the control execution transfers to the `M1()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the called method (`M2`) is finished, the control returns to the main thread,
    which executes the rest of the code in `M1()`, that is, lines 4 and 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same thing happens on line 5 with a call to `M2`. Line 6 executes when `M2`
    has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is a diagrammatic representation of synchronous code execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5a8b41e-6fed-47f0-a470-48987bd9688d.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will try to understand more about writing asynchronous
    code, which will help us compare both program flows.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding asynchronous program execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The asynchronous model allows us to execute multiple tasks concurrently. If
    we call a method asynchronously, the method is executed in the background while
    the thread that is called returns immediately and executes the next line of code.
    The asynchronous method may or may not create a thread, depending on the type
    of task we're dealing with. When the asynchronous method finishes, it returns
    the result to the program via callbacks. An asynchronous method can be void, in
    which case we don't need to specify callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a diagram showing a caller thread executing the `M1()` method,
    which calls an async method called `M2()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79ed2091-8666-497a-b56e-5f3c30bb189a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Contrary to the previous approach, here, caller thread doesn''t wait for `M2()`
    to finish. If there is any output that needs to be utilized from `M2()`, it needs
    to be put into some other method, say, `M3()`, here. This is what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: While executing `M1()`, the caller thread makes asynchronous calls to `M2()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The caller thread provides a callback function, say, `M3()`, while calling `M2()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The caller thread doesn't wait for `M2()` to finish; instead, it finishes the
    rest of the code in `M1()` (if there is any to finish).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`M2()` will be executed by the CPU either instantly in a separate thread or
    at a later date.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once `M2()` finishes, `M3()` is called, which receives output from `M2()` and
    processes it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, it's easy to understand the synchronous program's execution,
    whereas asynchronous code comes with code branching. We will learn how to mitigate
    this complexity using the `async` and `await` keywords in [Chapter 9](1b0d3653-dd80-486b-96fc-b17000f9439d.xhtml),
    *Async, Await, and Task-Based Asynchronous Programming Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: When to use asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many situations in which **Direct Memory Access** (**DMA**) is used
    to access the host system or I/O operations (such as files, databases, or network
    access) are used, which is where processing is done by the CPU rather than the
    application thread. In the preceding scenario, the calling thread makes a call
    to the I/O API and waits for the task to complete by moving to a blocked state.
    When the task is completed by the CPU, the thread is unblocked and finishes the
    rest of the method.
  prefs: []
  type: TYPE_NORMAL
- en: Using asynchronous methods, we can improve the application's performance and
    responsiveness. We can also execute a method via a different thread.
  prefs: []
  type: TYPE_NORMAL
- en: Writing asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is not new to C#. We used to write asynchronous code
    in earlier versions of C# using the `BeginInvoke` method of the `Delegate` class,
    as well as by using the `IAsyncResult` interface implementations. With the introduction
    of TPL, we started writing asynchronous code using the `Task` class. From C# 5.0
    onward, the `async` and `await` keywords have been the preferred choice for developers
    writing asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write asynchronous code in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Delegate.BeginInvoke()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Task` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `IAsyncResult` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `async` and `await` keywords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent sections, we'll look at each of these in detail with code
    examples, except for the `async` and `await` keywords – [Chapter 9](1b0d3653-dd80-486b-96fc-b17000f9439d.xhtml), *Async,
    Await, and Task-Based Asynchronous Programming Basics*, is dedicated to them!
  prefs: []
  type: TYPE_NORMAL
- en: Using the BeginInvoke method of the Delegate class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `Delegate.BeginInvoke` is no longer supported in .NET Core, but we will
    look at it here in terms of backward compatibility with earlier versions of .NET.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `Delegate.BeginInvoke` method to call any method asynchronously.
    This can be done to improve the UI's performance if some tasks need to be moved
    from the UI thread into the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a `Log` method as an example. The following code works synchronously
    and writes logs. For the sake of demonstration, the logging code has been removed
    and replaced with a dummy 5-second delay, after which the `Log` method prints
    a line to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a dummy `Log` method that takes 5 seconds to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the call to the `Log` method from the `Main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, a 5-second delay for writing logs is too long. Since we don't expect
    any output from the `Log` method (writing to the console is just for demonstration
    purposes), it makes sense to call it asynchronously and return the response to
    the caller immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the program as it is currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39f2ec02-f68d-4499-82f1-483b85baf2ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can add a `Log` method call to the preceding method. Then, we can wrap the
    `Log` method call inside a delegate and call the `BeginInvoke` method on the delegate,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, when we execute the code, we will see asynchronous behavior in older
    versions of .NET. In .NET Core, however, the code breaks at runtime with the following
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.PlatformNotSupportedException: ''Operation is not supported on this
    platform.''`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET Core, wrapping the synchronous methods into async delegates is no longer
    supported for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Async delegates use an `IAsyncResult`-based async pattern, which is not supported
    by .NET Core base class libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Async delegates are not possible without `System.Runtime.Remoting`, which is
    also not supported in .NET Core.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Task class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to implement asynchronous programming in .NET Core is to use the `System.Threading.Tasks.Task`
    class, as we mentioned earlier. The preceding code can be changed to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the required output without changing too much of the current
    code flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/414f388a-a105-4677-b001-ec47d471dbe8.png)'
  prefs: []
  type: TYPE_IMG
- en: We discussed `Task` in [Chapter 2](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml),
    *Task Parallelism*. The `Task` class provides us with a very powerful way to implement
    task-based asynchronous patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Using the IAsyncResult interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `IAsyncResult` interface has been used to implement asynchronous programming
    in older versions of C#. The following is some example code that works well in
    earlier versions of .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create `AsyncCallback` that will be executed when the async method
    finishes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a delegate that will execute an `Add` method with the parameters
    that are passed. Once finished, it will execute the callback method wrapped by
    `AsyncCallBack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `MyCallBack` method is called, it returns the `IAsyncResult` instance.
    To get the underlying result, state, and callback, we need to cast the `IAsyncResult`
    instance to `AsyncResult`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have `AsyncResult`, we can call `EndInvoke` to get the values that
    have been returned by the `Add` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, .NET Core has no support for `System.Runtime.Remoting` and so
    the preceding code will not work in .NET Core. We can only use task-based asynchronous
    patterns for all `IAsyncResult` scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code reads data from the file using the `FileStream` class. `FileStream`
    implements `IAsyncResult` and thus supports the `BeginRead` and `EndRead` methods. Then,
    we used the `Task.Factory.FromAsync` method to wrap `IAsyncResult` and return
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: When not to use asynchronous programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming can be very beneficial when it comes to creating a
    responsive UI and improving the application's performance. There are, however,
    scenarios in which asynchronous programming should be avoided as it may reduce
    performance and increase the complexity of the code. In the following subsections,
    we'll go through a few situations in which it is best not to use asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: In a single database without connection pooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In cases where we have a single database server that doesn't have connection
    pooling enabled, asynchronous programming will have no benefits. With long-running
    connections and multiple requests, there will be performance bottlenecks, irrespective
    of whether calls are made synchronously or asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: When it is important that the code is easy to read and maintain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using the `IAsyncResult` interface, we have to break down the source method
    into two methods: `BeginMethodName` and `EndMethodName`. Changing the logic in
    this way can take a lot of time and effort and make the code hard to read, debug,
    and maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: For simple and short-running operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to consider how much time the code is taking while it's running synchronously.
    If it isn't taking too long, it makes sense to keep the code synchronous as making
    code asynchronous comes with a small performance hit that would not be beneficial
    for small gains.
  prefs: []
  type: TYPE_NORMAL
- en: For applications with lots of shared resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application is using lots of shared resources, such as global variables
    or system files, it makes sense to keep the code synchronous; otherwise, we will
    end up reducing the performance benefits. Just like shared resources, we need
    to apply synchronization primitives that can reduce performance with multiple
    threads. Sometimes, single-threaded applications can be more performant than their
    multithreaded counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Problems you can solve using asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through a few situations where asynchronous programming can be handy
    to improve the responsiveness of the application and the performance of both the
    application and the server. Some situations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging and auditing: Logging and auditing are cross-cutting concerns for applications.
    If you happen to write your own code for logging and auditing, then calls to the
    server become slow as they need to write back the logs as well. We can make logging
    and auditing asynchronous and we should make the implementation stateless wherever
    possible. This will make sure that callbacks can be returned in a static context
    so that calls can continue to execute while the response returns to the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service calls: Web service calls and database calls can be made asynchronous
    because, once we make a call to the service/database, the control leaves the current
    application and goes to the CPU, which makes the network call. The caller thread
    goes into a blocked state. Once the response from the service call comes back,
    the CPU receives it and raises an event. The calling thread is unblocked and starts
    further execution. As a pattern, you are likely to have seen that all service
    proxies return asynchronous methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating responsive UIs: There may be scenarios in programs where a user clicks
    a button to save data. Saving data can involve multiple small tasks: reading data
    from the UI into models, making a connection to a database, and making calls to
    the database to update the data. This can take a long time and if these calls
    are made on a UI thread, then the thread is blocked until this completes. This
    means the user won''t be able to do anything on the UI until the call is returned.
    We can improve the user experience by making asynchronous calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPU-bound applications: With the advent of new technology and support in .NET,
    we can now write machine learning, ETL processing, and cryptocurrency mining code
    in .NET. These tasks are highly CPU-intensive and it makes sense to make these programs asynchronous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous patterns in early versions of C#** In early versions of .NET,
    two patterns were supported to perform I/O-bound and compute-bound operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous Programming Model** (**APM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-Based Asynchronous Pattern** (**EAP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed both of these approaches in detail in [Chapter 2](a001ad9c-7e57-4af7-961f-91c1e983b937.xhtml), *Task
    Parallelism*. We also learned how to convert these legacy implementations into
    task-based asynchronous patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's recall what we've covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what asynchronous programming is and why it makes
    sense to write asynchronous code. We also discussed scenarios where asynchronous
    programming can be implemented and where it should be avoided. Finally, we covered
    various asynchronous patterns that have been implemented in TPL.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming, if used correctly, can really enhance the performance
    of server-side applications by efficiently utilizing threads. It also improves
    the responsiveness of desktop/mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the asynchronous programming primitives
    that are provided by the .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ________ code is easier to write, debug, and maintain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Synchronous
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Asynchronous
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what scenario should you use asynchronous programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File I/O
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Database with connection pooling
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Network I/O
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Database without connection pooling
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which approach can be used to write async code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Delegate.BeginInvoke`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAsyncResult`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of these cannot be used to write async code in .NET Core?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`IAsyncResult`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Task`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
