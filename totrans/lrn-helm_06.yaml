- en: '*Chapter 4*: Understanding Helm Charts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to use Helm from an end user perspective,
    leveraging it as a package manager to install applications to Kubernetes. Using
    Helm in this fashion did not require any Kubernetes expertise or any deep understanding
    of the application since all of the resources and logic were included as part
    of a Helm chart. The only concept you needed to be familiar with were the values
    that the chart provided in order to customize your installation.
  prefs: []
  type: TYPE_NORMAL
- en: We will now shift gears from using Helm charts to understanding how they work
    and are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the YAML format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding chart templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding chart definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycle management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting a Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section requires the `helm` binary to be installed on your local machine.
    The installation and configuration of this tool are covered in [*Chapter 2*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098),
    Preparing a Kubernetes and Helm Environment.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the YAML format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**YAML Ain''t Markup Language** **(YAML)** is a file format used to create
    human-readable configuration. It is the file format most commonly used to configure
    Kubernetes resources and is also the format used for many of the files in Helm
    charts.'
  prefs: []
  type: TYPE_NORMAL
- en: YAML files follow a key-value format to declare configuration. Let's explore
    the YAML key-value construct.
  prefs: []
  type: TYPE_NORMAL
- en: Defining key-value pairs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most basic examples of a YAML key-value pair is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `name` key is given a `LearnHelm` value. In YAML,
    keys and values are separated by a colon (:). Characters written to the left of
    the colon represent the key, while characters written to the right of the colon
    represent the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spacing matters in YAML format. The following line does not constitute a key-value
    pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that a space is missing between the colon and the `LearnHelm` string.
    This would result in a parsing error. A space must exist between the colon and
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the preceding example represents a simple key-value pair, YAML allows
    users to configure more complex pairings with nested elements or blocks. An example
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example demonstrates a resources object containing a map of two
    key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Keys are determined by following the indentation under a YAML block. Each indentation
    adds a dot (`.`) separator to the name of the key. The value of the key has been
    reached when there are no longer any indentations remaining in the YAML block.
    By common practice, indentations in YAML should use two spaces, but users can
    provide as many spaces as they desire as long as the spacing is consistent throughout
    the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tabs** are not supported by YAML and their use will result in a parsing error.'
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of YAML key-value pairs, let's now explore some of the
    common types that values can be defined as.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values in a YAML file can be of different types. The most common type is a
    string, which is a text value. Strings can be declared by wrapping a value in
    quotations, but this is not always required. If a value contains at least one
    alphabetical letter or special character, the value is considered a string, with
    or without quotation marks. Multi-line strings can be set by using the pipe (`|`)
    symbol, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Values can also be integers. A value is an integer when it is a numeric character
    that is not wrapped in quotations. The following YAML declares an integer value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this to the following YAML, which assigns replicas to a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean values are often used as well, which can be declared with either true
    or false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This YAML sets `ingress.enable` to the `true` Boolean value. Other acceptable
    Boolean values are `yes`, `no`, `on`, `off`, `y`, `n`, `Y`, and `N`.
  prefs: []
  type: TYPE_NORMAL
- en: Values can also be set to more complex types, such as lists. Items in a list
    in YAML are identified by the dash (`-`) symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following demonstrates a YAML list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This YAML sets `servicePorts` to the list of integers (such as `8080` and `8443`).
    This syntax can also be used to describe a list of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `env` is set to a list of objects containing the `name` and `value`
    fields. Lists are often used in both Kubernetes and Helm configuration and understanding
    them is valuable to using Helm to its fullest potential.
  prefs: []
  type: TYPE_NORMAL
- en: While YAML is more commonly used in the worlds of Kubernetes and Helm for its
    ease of readability, the **JavaScript Object Notation** (**JSON**) format can
    be used as well. Let's briefly describe this format.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON format
  prefs: []
  type: TYPE_NORMAL
- en: YAML is a superset of another widely used formatâ€”JSON. JSON is a string of key-value
    pairs, similar to YAML. The key difference is that while YAML relies on spacing
    and indentation to properly configure key-value pairs, JSON relies on braces and
    brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example converts the previous YAML example into JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the keys in JSON are wrapped in quotation marks and positioned before
    a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: Curly braces (`{`) denote a block in a similar way to how indentations denote
    a block in YAML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Square brackets (`[`) denote a list in a similar way to how dashes denote a
    list in YAML.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more constructs to the YAML and JSON formats, but this introduction
    provides more than enough information to understand how they can be used in Helm
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the Helm chart file structure, which you
    may notice contains several YAML and JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: The Helm chart structure
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will recall from previous chapters, a Helm chart is a packaging of Kubernetes
    resources, allowing users to deploy applications of varying complexities to Kubernetes.
    In order to be considered a Helm chart, however, a certain file structure must
    be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is best practice to name the top-level directory as the name of the Helm
    chart. This is not a technical requirement, but it makes identifying the name
    of a Helm chart much simpler. For the preceding example file structure, the Helm
    chart's name is likely to be `my-chart`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the top-level directory are the files and directories that comprise the
    Helm chart. The following table shows each of these possible files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Throughout this chapter, we will explore each of these files to understand how
    a Helm chart is created. We'll first begin by understanding how chart templates
    work to allow Kubernetes resources to be dynamically generated.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding chart templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of a Helm chart is to create and manage the Kubernetes resources
    that make up an application. This is accomplished through chart templates, with
    values serving as parameters to customize those templates. In this section, we
    will discuss how Helm templates and values function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm charts must contain a `templates/` directory that defines the Kubernetes
    resources to be deployed (although this directory is not strictly required if
    the chart declares dependencies). The contents under the `templates/` directory
    are YAML files that are made up of Kubernetes resources. The contents of a `templates/`
    directory may appear similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `configmap.yaml` resource may then look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may question whether the prior example is a valid YAML syntax. It is because
    the `configmap.yaml` file is actually a Helm template that will modify the configuration
    of this resource based on a certain set of values to produce a valid YAML resource.
    The opening and closing curly braces represent input text for a **Golang** (**Go**)
    template that will be removed during an installation or upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn more about Go templates and how they can be used to generate Kubernetes
    resource files.
  prefs: []
  type: TYPE_NORMAL
- en: Go templating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Go** is a programming language that was developed by Google in 2009\. It
    is the programming language used by Kubernetes, Helm, and many other tools in
    the Kubernetes and container community. A core component of the Go programming
    language is templates, which can be leveraged to generate files of different formats.
    In the case of Helm, Go templates are used to generate Kubernetes YAML resources
    under a Helm chart''s `templates/` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Go template controls structures and processing begin with two opening curly
    braces ( `{{` ) and ends with two ending curly braces ( `}}` ). While these punctuation
    marks may appear in a local file under the `templates/` directory, they are removed
    during the processing that takes place during an installation or upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive deeper into Go templating in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*, where you will build your own Helm chart. In
    this chapter, we will discuss common capabilities of Go templating as an introduction
    to this feature before getting some hands-on practice. We'll start our discussion
    with a list of capabilities that Go templating provides, beginning with parameterization.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing fields with values and built-in objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Helm charts contain a `values.yaml` file in their chart directories. This file
    declares all of a chart's default values, which are referenced by Go templates
    and processed by Helm to dynamically generate Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'A chart''s `values.yaml` file may have values defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Lines that begin with the pound symbol (`#`) are comments (which are ignored
    during execution) and should provide details about the values they describe so
    that the user understands how they should be applied. Comments can also include
    the name of the value to allow comments to appear when a value is searched upon.
    Other lines in the file represent key-value pairs. An introduction to the YAML
    format is described at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Go templates beginning with `.Values` will reference values defined in a `values.yaml`
    file or passed in using the `--set` or `--values` flags during an installation
    or upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example represents a template before it is processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After the template is processed, a snippet of a YAML resource is rendered as
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.Values` construct used to refer to a chart''s values is a built-in object
    that can be used for parameterization. A full list of built-in objects can be
    found in the Helm docume[ntation (https://helm.sh/docs/chart_template_guide/builtin](https://helm.sh/docs/chart_template_guide/builtin_objects/)_objects/),
    but the most common objects are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/new04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dot (`.`) prefixed to each object represents the object scope. A dot followed
    by an object name limits the scope to that object. For example, the `.Values`
    scope only makes a chart's values visible; the `.Release` scope only makes fields
    under the `Release` object visible; and the `.` scope represents global scope,
    making all of these objects visible, plus the common objects defined in the preceding
    table.
  prefs: []
  type: TYPE_NORMAL
- en: The values.schema.json file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While on the topic of values and parameterization, let's take a moment to discuss
    the `values.schema.json` file, which is one of the files that may be included
    in a chart's directory. The `values.schema.json` file is used to enforce a particular
    schema in a `values` file. This schema can be used to validate the provided values
    during an installation or an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows what the `values.schema.json` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With this schema file in place, the `replicas` value should be set to `0` as
    a minimum. Additional values added to this file place additional restrictions
    on the values that can be provided. This file is a good way of ensuring users
    only provide the values that are supported as parameters in the chart's templates.
  prefs: []
  type: TYPE_NORMAL
- en: While Go templates allow chart developers to parameterize Helm charts, they
    also allow developers to provide conditional logic into a YAML file. We will explore
    this feature next.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-grained template processing with flow control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While parameterization allows chart developers to substitute fields with certain
    values, Go templating also provides developers with the ability to control the
    flow and structure of their templates. This can be accomplished using the following
    keywords (referred to as `actions` in Go):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are some occasions during chart templating where it may be necessary
    to include or exclude certain Kubernetes resources or certain parts of a resource.
    The `ifâ€¦else` actions can be used for this purpose. The following snippet from
    a deployment template includes a conditional block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `if` block is used to conditionally set the `readinessProbe` stanza. If
    the `probeType.httpGet` value evaluates to `true` or is non-null, the `httpGet`
    `readinessProbe` will be templated. Otherwise, the `readinessProbe` that is created
    will be a `tcpSocket` `readinessProbe` type. The dashes used in the curly braces
    are used to indicate that whitespace should be removed after processing. Dashes
    used after the opening braces remove whitespace before the braces and dashes used
    immediately before the closing braces remove whitespace after the braces.
  prefs: []
  type: TYPE_NORMAL
- en: Chart developers can also use the `with` action to modify the scope of the values.
    This action is useful when a block of values that are referenced are deeply nested.
    It can simplify the readability and maintainability of a template file by reducing
    the amount of characters required to reference a deeply nested value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code describes a `values` file, which includes deeply nested
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the `with` action, these values would be referenced in a `template`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with` action allows a developer to modify the scope of these values and
    reference them with a shortened syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, developers can perform repetitive actions using the `range` action.
    This action allows developers to loop over a list of values. Imagine that a chart
    has the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code provides a list of `servicePorts`, which can be looped over,
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with` and `range` actions limit the scope to the object that is provided.
    In the `range` example, the `range` acts on the `.Values.servicePorts` object,
    limiting the scope of the dot (.) symbol to values defined under this object.
    To enact a global scope under `range` where all the values and built-in objects
    are referenced, developers should prefix references with the dollar sign (`$`)
    symbol, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In addition to a chart's values, developers can also create variables to help
    render resources. We will explore this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Template variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although they are not as commonly used as other templating features, chart developers
    can create variables in their chart templates to provide additional processing
    options. A common use for this approach is flow control, but template variables
    can serve other use cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable in a chart template is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the `myvar` variable to the `Hello World!` string. Variables can
    be assigned to objects as well, such as a chart''s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A variable that is set is then referenced later in the template in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the best cases for using variables is in a range block, where variables
    are set to capture the index and value of list iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be rendered as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables can also simplify the processing of map iterations, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible result may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, variables can be used to refer to a value outside of the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `with` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'A template such as this one would fail to process since `.Release.Name` is
    not under the scope of `.Values.application.configuration`. One way this can be
    remedied is by setting a variable to `.Release.Name` above the `with` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: While this is a possible solution to this problem, the approach of using a dollar
    sign to refer to the global scope is preferred as it requires less lines to configure
    and is easier to read as chart complexity increases.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control and variables are powerful concepts that allow resources to be
    dynamically generated. In addition to flow control, chart developers can also
    leverage functions and pipelines to assist in resource rendering and formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Complex processing with functions and pipelines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go provides the concepts of functions and pipelines to enable complex processing
    of data within a template.
  prefs: []
  type: TYPE_NORMAL
- en: A Go template function is similar to other functions you may have encountered
    in other languages and constructs. Functions contain logic designed to consume
    certain inputs and provide an output based on the inputs that were provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Go templates, functions are called by using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: One Go function that is commonly used is the `indent` function. This function
    is used to indent a string of a specified number of characters to ensure strings
    are properly formatted since YAML is a whitespace-sensitive markup language. The
    `indent` function takes the number of spaces to indent as input, as well as the
    string that should be indented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following template illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This example indents the string contained in the `config` value by `4` spaces
    to ensure the string is properly indented under the `application-config` YAML
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other construct Helm provides is pipelines. A pipeline is a concept borrowed
    from **UNIX** where the output of one command is fed as input to a different command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example displays a UNIX pipeline. On the left side of the pipe
    (`|`) is the first command and on the right side is the second command. The first
    command, `cat file.txt`, prints the contents of a file named `file.txt` and passes
    it as input to the `grep helm` command, which filters the first command's output
    for the word `helm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go pipelines work in a similar way. This can again be demonstrated with the
    `indent` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will also indent the `config` value by 4 spaces. Pipelines are best used
    to chain multiple commands together. A third command can be added to the pipeline,
    called `quote`, which quotation quote marks around the final templated product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Because this is written as a pipeline, it is easy and natural to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different Go template functions that can be used in a Helm chart.
    These functions can be found in the Go documentation at https://golang.org/pkg/text/template/#hdr-Functions
    and in the Sprig template l[ibrary at http://masterminds.github](http://masterminds.github.io/sprig/).io/sprig/.
    Some common Go template functions that you may use during chart development are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`date`: To format a date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default`: Set a default value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail`: To fail template rendering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: To execute a Go template and return the results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nindent`: Similar to indent, except prepends a new line before indenting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indent`: To indent text by a set number of spaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`now`: To display the current date/time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quote`: To wrap a string in quotation marks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required`: To require user input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splitList`: To split a string into a list of strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toYaml`: To convert a string into YAML format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Go template language also consists of the following Boolean operators that
    can be used in `if` actions to further control the generation of YAML resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`and`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`or`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eq` (short for equal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ne` (short for not equal)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lt` (short for less than)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`le` (short for less than or equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gt` (short for greater than)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ge` (short for greater than or equal to)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to generating Kubernetes resources, Go templates can also be used
    to create functions that can be reused in YAML resources that have repetitive
    templating. This can be accomplished by creating named templates, described in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling code reuse with named templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating template files, there may be boilerplate or repetitive blocks
    of YAML in a Kubernetes resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of this is the labels of a resource, which can be specified as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For consistency, each of these labels can be added to each resource in a Helm
    chart. If the chart contains many different Kubernetes resources, it can be cumbersome
    to include the desired labels in each file, especially if a label needs to be
    modified or if a new label needs to be added to each resource in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides a construct called named templates that allows chart developers
    to create reusable templates that can be applied to reduce boilerplate. Named
    templates are defined under the `templates/` directory and are files that begin
    with underscores and end with the `.tpl` file extension. Many charts are created
    with a file called `_helpers.tpl` that contains the named templates, although
    the file does not need to be called `helpers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a named template in the `tpl` file, developers can leverage the `define`
    action. The following example creates a named template that can be used to encapsulate
    resource labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `define` action takes a template name as an argument. In the preceding example,
    the template name is called `mychart.labels`. The common convention for naming
    a template is `$CHART_NAME.$TEMPLATE_NAME`, where `$CHART_NAME` is the name of
    the Helm chart and `$TEMPLATE_NAME` is a short, descriptive name that describes
    the purpose of the template.
  prefs: []
  type: TYPE_NORMAL
- en: The `mychart.labels` name implies that the template is native to the `mychart`
    Helm chart and will generate labels to resources that it is applied to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a named template in a Kubernetes YAML template, you can use the `include`
    function, which has the following usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `TEMPLATE_NAME` parameter is the name of the named template that should
    be processed. The `SCOPE` parameter is the scope of values and built-in objects
    that should be processed. Most of the time, this parameter is a dot (`.`) to denote
    the current top-level scope, but the dollar sign ( `$` ) symbol should be used
    if the named template references values outside of the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how the `include` function is used to process
    a named template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This example begins by setting the name of the resource to the name of the
    release. It then uses the `include` function to process the labels and indents
    each line by two spaces, as declared by the pipeline. When processing is finished,
    a resource within a release called `template-demonstration` may appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Helm also provides a `template` action that can also expand named templates.
    This action has the same usage as `include`, but with one major limitationâ€”it
    cannot be used in a pipeline to provide additional formatting and processing.
    The `template` action is used to simply display data inline. Because of this limitation,
    chart developers should use the `include` function over the `template` action
    since `include` has feature parity with `template` but also provides the additional
    benefit of pipeline processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how named templates can be used to reduce
    boilerplate across multiple different charts.
  prefs: []
  type: TYPE_NORMAL
- en: Library charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Helm charts have a `type` field defined in the `Chart.yaml` file that is set
    to either `application` or `library`. Application charts are used to deploy full
    applications to Kubernetes. This is the most common type of chart and is the default
    setting. However, charts can also be defined as library charts. This type of chart
    is not used to deploy applications but instead to provide named templates that
    may be used across multiple different charts. An example of this use case is the
    `labels` example defined in the previous section. Developers can maintain multiple
    different charts whose resources have the same labels. Rather than defining the
    same named templates in each chart's `_helpers.tpl` file, developers can declare
    a library chart that provides the named template for generating resource labels
    as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: While Helm is most commonly used to create traditional Kubernetes resources,
    it can also create **Custom Resources** (**CRs**), which we will explain in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Templating CRs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**CRs** are used to create resources that are not native to the Kubernetes
    API. You may want to use this functionality to augment the abilities that Kubernetes
    provides. CRs can be created using Helm templates such as native Kubernetes resources,
    but there must first be a **Custom Resource Definition (CRD)** that defines the
    CR. If the CRD is not present before the CR is created, the installation will
    fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm charts can include a `crds/` folder, which consists of the CRDs that must
    be presented before templates are installed. An example `crds/` folder is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The file `my-custom-resource-crd.yaml` may have the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The templates/ directory can then contain an instance of the MyCustomResource
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: A file structure such as this will ensure that the `MyCustomResource` CRD is
    installed before the CR defined under the `templates/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: This capability requires the user to be a cluster administrator as creating
    CRDs requires escalated privileges. If you are not a cluster administrator, it
    may be better to ask an admin to create your CRDs beforehand. If you do so, the
    `crds/` folder would not need to be included in your chart because the CRDs would
    already be present in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have covered Helm templates in a large amount of detail. To summarize,
    Helm templates are the 'brains' of your Helm chart and are used to generate Kubernetes
    resources. We will get hands-on experience with writing Helm templates, along
    with other topics discussed in this chapter, in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's continue our discussion on Helm chart fundamentals with a topic
    of equal importance to chart templatesâ€”the `Chart.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding chart definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Chart.yaml` file, also known as the chart definition, is a resource that
    declares different metadata about a Helm chart. This file is required and if it
    is not included in a chart''s file structure, you''ll receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147), *Installing
    Your First Helm Chart*, we explored the chart definition of **Bitnami''s WordPress
    chart** by running the `helm show chart` command. Recall this chart definition
    by running this command again. We will assume that the Bitnami chart repository
    has already been added since this task was performed in [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147),
    *Installing Your First Helm Chart*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Below lists the chart definition of the wordpress chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 â€“ The output of the Bitnami chart repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 â€“ The chart definition of the wordpress chart.
  prefs: []
  type: TYPE_NORMAL
- en: The chart definition, or the `Chart.yaml` file, can contain many different fields.
    Some of the fields are required while most of the other fields are optional and
    can be provided only if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of the `Chart.yaml` file, we will explore
    the file's required fields in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Required fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A chart definition must contain the following fields that contain crucial chart
    metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s explore each of these required fields in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apiVersion` field can be set to one of two different values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`v2`'
  prefs: []
  type: TYPE_NORMAL
- en: If the `apiVersion` field is set to `v1`, this means that the chart follows
    a legacy chart structure. This is the `apiVersion` value that was used before
    the release of Helm 3, where an additional `requirement.yaml` file was supported
    in the chart structure and the `type` field in the chart definition was not supported.
    Helm 3 is backward-compatible with the `apiVersion` value `v1`, but new charts
    should be set to the `apiVersion` value `v2` to avoid deprecated features being
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `name` field is used to define the name of the Helm chart. This value should
    be equal to the name of the top-level directory containing the Helm chart's files.
    The name of the Helm chart appears in the search results from the `helm search`
    command, as well as the `helm list` command, to return the name of the chart used
    for a release. The value of this field should be concise yet descriptive, describing
    the application installed by the chart in a short name such as `wordpress` or
    `redis-cluster`. Kebab case, or separating words with dashes, is the common convention
    when distinguishing different words in a name. Sometimes, names will be written
    as one word, such as `rediscluster`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `version` field is used to determine the version of the Helm chart. Versions
    must follow the **Semantic Versioning** (**SemVer**) `2.0.0` format to be a valid
    chart version. SemVer describes a version based on a `Major.Minor.Patch` format,
    where the `Major` version should increase when a breaking change is introduced,
    the `Minor` version should increase when a backward-compatible feature is released,
    and the `Patch` version should increase when a bug is fixed. When the `Minor`
    version is increased, the `Patch` version is set back to `0`. When the `Major`
    version is increased, both the `Minor` and `Patch` versions are reset to `0`.
    Chart developers should take special care when incrementing chart versions as
    they are used to indicate when breaking changes, new features, and bug fixes are
    released.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these three fields are the only fields required in the `Chart.yaml` file,
    there are many more optional fields that can be included to add additional metadata
    to the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the other possible `Chart.yaml` fields.
  prefs: []
  type: TYPE_NORMAL
- en: Optional metadata
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the required fields, there are many optional fields that can
    be used to provide additional details about a chart, described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Some of these fields provide simple metadata to display information to a user
    about the Helm chart. Other fields, however, are used to modify the behavior of
    the Helm chart. The first of these fields is the `type` field, which can be set
    to either `application` or `library`. If set to `application`, the chart deploys
    Kubernetes resources. If set to `library`, the chart provides functions to other
    charts through the form of helper templates.
  prefs: []
  type: TYPE_NORMAL
- en: The second field that can modify the behavior of the Helm chart is the `dependencies`
    field, which is discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Managing chart dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chart dependencies are used to install other charts' resources that a Helm chart
    may depend on. An example of this is the `wordpress` chart, which declared the
    `mariaDB` chart as a dependency to save backend data. By using the `mariadb` dependency,
    the WordPress chart did not need to define its resources from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies are declared in the `Chart.yaml` file by populating the `dependencies`
    field. The following is the relevant snippet from the `wordpress` chart''s definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 â€“ A snippet of the wordpress chartâ€™s definition'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 â€“ The mariadb dependency declared in the wordpress Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: While this example displays a single dependency, `mariadb`, the dependencies
    block can define a list of multiple dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `dependencies` block contains many different fields that can be applied to
    modify the behavior of a chart''s dependency management. These fields are defined
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The minimum required fields under the `dependencies` blocks are the `name`,
    `repository`, and `version` fields. As shown in the preceding `wordpress` dependency
    snippet, the name of the dependency is mariadb and the repository can be found
    at [https://kubernetes-charts.storage.googleapis.com](https://kubernetes-charts.storage.googleapis.com/)/.
    This searches the provided repository for a Helm chart whose `name` field in the
    `Chart.yaml` file is `mariadb`. The `version` field of a `dependencies` block
    specifies the version of the chart that should be included. This can be pinned
    to a specific version, such as `7.0.0`, or it can specify a wildcard version.
    The dependency listed in the preceding example provides a wildcard version, `7.x.x`,
    which instructs Helm to download the latest version of the chart that matches
    the wildcard.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with an understanding of the required dependencies fields, let's learn
    how the declared dependencies can be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dependencies can be downloaded using the `helm dependency` subcommand listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To download dependencies for the first time, you can run the `helm dependency
    update` command, which downloads each dependency into the `charts/` directory
    of the given Helm chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `helm dependency update` command downloads dependencies from repositories
    in the form of `GZip` archives with the .`tgz` file extension. This command also
    generates a file called `Chart.lock`. The `Chart.lock` file is similar to the
    `Chart.yaml` file. However, while the `Chart.yaml` file contains the desired state
    of the chart dependencies, the `Chart.lock` file defines the actual state of the
    dependencies that were applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a `Chart.lock` file can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 â€“ A Chart.lock file'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 â€“ A `Chart.lock` file
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this to a simple corresponding `Chart.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 â€“ A corresponding Chart.yaml file'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 â€“ A corresponding `Chart.yaml` file
  prefs: []
  type: TYPE_NORMAL
- en: In the `Chart.yaml` file, you can see that the version of the specified `mariadb`
    dependency was version `7.x.x`, but the version in the `Chart.lock` file is version
    `7.3.1`. This is because the `Chart.yaml` file instructed Helm to download the
    latest version of the `7.x.x` release, and the actual version that was downloaded
    was version `7.3.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Chart.lock` file in place, Helm is able to redownload the exact dependencies
    that were originally downloaded in the event that the `charts/` directory is removed
    or needs to be rebuilt. This can be done by running the `helm dependency build`
    command against a chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because you can download dependencies using the `helm dependency build` command,
    it is possible to omit the `charts/` directory from source control to reduce the
    size of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, newer versions under the `7.x.x` release will be available. The `helm
    dependency update` command can be run again to reconcile this dependency, meaning
    the latest available version will be downloaded and the `Chart.lock` file will
    regenerate. If in the future you want to download from the `8.x.x` release or
    would like to pin the dependency to a specific release, such as `7.0.0`, you can
    set this in the `Chart.yaml` file and run `helm dependency update`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helm dependency list` command can be used to view the downloaded dependencies
    of a Helm chart saved to your local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 â€“ The output of a CHART_NAME command'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_4.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 â€“ "helm dependency list" output
  prefs: []
  type: TYPE_NORMAL
- en: The `STATUS` column determines whether the dependency has been successfully
    downloaded to the `charts/` directory. It has been downloaded if the status reads
    `ok`. If the status reads as `missing`, the dependency has not been downloaded
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: By default, every declared dependency in the `Chart.yaml` file will be downloaded,
    but this can be modified by providing the `condition` or `tags` fields of the
    `dependencies` block, which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `condition` and `flags` fields can be leveraged to conditionally include
    dependencies during an installation or upgrade. Consider an example `dependencies`
    block in the `Chart.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the inclusion of the `condition` and `tags` fields. The `condition`
    field lists a value that should be provided by the user or set in the chart''s
    `values.yaml` file. If it evaluates to `true`, the `condition` field causes the
    chart to be included as a dependency. If `false`, the dependency will not be included.
    Multiple conditions can be defined by separating each condition with a comma,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The best practice around setting a condition is to follow a `chartname.enabled`
    value format, where each dependency has a unique condition set depending on the
    dependency's chart name. This allows users to enable or disable individual charts
    by following an intuitive value schema. If the condition values are not included
    in the chart's `values.yaml` file or are not provided by the user, this field
    is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `condition` field is used to enable or disable individual dependencies,
    the `tags` field is used to enable or disable groups of dependencies. In the preceding
    `dependencies` block, both dependencies list a tag called `monitoring`. This means
    that if the `monitoring` tag is enabled, both dependencies are included. If the
    `monitoring` tag is set to `false`, the dependency is omitted. Tags are enabled
    or disabled by setting them under a `tags` YAML object in the parent chart''s
    `values.yaml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: A dependency can define multiple tags in the `Chart.yaml` file by following
    the YAML syntax for lists. Only one tag needs to be evaluated to `true` for the
    dependency to be included.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: If all of a dependency's tags are ignored, the dependency will be included by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed how dependencies can be declared conditionally.
    Next, we will discuss how values from a dependency can be overridden and referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding and referencing values from a child chart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the values belonging to a dependency chart (also referred to as
    a **child chart**) can be overridden or referenced by wrapping them in a map with
    a name set to the same as the child chart. Imagine a child chart called `my-dep`
    that supports the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When this chart is installed as a dependency, these values can be overridden
    by setting them in a `my-dep` YAML object of the parent chart, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example overrides the `replicas` and `servicePorts` values defined
    in `my-dep` to set `3` for `replicas` and add `8778` to `servicePorts`. These
    values can be referenced in the parent chart's templates by following dot notationâ€”for
    example, `my-dep.replicas`. In addition to overriding and referencing values,
    you can directly import dependency values by defining the `import-values` field,
    explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Importing values with import-values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dependencies` block of the `Chart.yaml` file supports an `import-values`
    field that can be used to import a child chart''s default values. This field works
    in a couple of ways. The first way is to provide a list of keys to import from
    the child chart. In order for this to work, the child chart must have values declared
    under an `exports` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent chart can then define the `import-values` field in the `Chart.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows default values under `exports.image` in the child chart to be referenced
    as follows in the parent chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this has removed the `image` map and left only the key-value pairs
    that were underneath it. If you don''t want this to happen, the `import-values`
    field can retain the `image` map by following what is referred to as the `child-parent`
    format. This allows chart developers to specify the values that should be imported
    from the child chart and provides the name that they should be referred to as
    in the parent chart. The `child-parent` format allows this to be done without
    the need for values in an `exports` block in the child chart. The following `dependencies`
    block demonstrates an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This example takes each value under the `image` block in the child chart and
    imports it under an `image` block in the parent chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note:'
  prefs: []
  type: TYPE_NORMAL
- en: The values imported using the `import-values` field cannot be overridden in
    the parent chart. If you need to override values in the child chart, you should
    not use the `import-values` field and should instead override the desired values
    by prefixing each one with the name of the child chart.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we covered how dependencies can be managed in the `Chart.yaml`
    file. Now, let's learn about how life cycle management hooks can be defined in
    a Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary benefits of Helm charts and their associated releases is
    the ability to manage complex applications on Kubernetes. A release undergoes
    multiple phases during its life span. To provide additional management capabilities
    around the life cycle of a release, Helm features a `hooks` mechanism so that
    actions can be undertaken at different points in time within a release cycle.
    In this section, we will explore the different phases of a release's life span
    and introduce how `hooks` can be used to provide capabilities for interacting
    not only with the release but also the entire Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147), *Installing
    Your First Helm Chart*, we encountered several phases that encompass the overall
    life span of a Helm release, including its installation, upgrade, removal, and
    rollback. Given that Helm charts can be complex, as they manage one or more applications
    that will be deployed to Kubernetes, there is often the need to perform additional
    actions besides just deploying resources. These can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Completing prerequisites that are needed by the application, such as managing
    certificates and secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database management as part of a chart upgrade to either perform a backup or
    restoration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleaning up assets before the removal of a chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of potential options can be long and it is important to first understand
    the basics of Helm hooks as well as when they can be executed, which we will describe
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of a Helm hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hook executes as a one-time action at a designated point in time during the
    life span of a release. A hook, as with the majority of the features within Helm,
    is implemented as yet another Kubernetes resource and, more specifically, within
    a container. While the majority of workloads within Kubernetes are designed to
    long-living processes, such as an application serving API requests, workloads
    can also be made up of a single task or set of tasks executed using a script that
    indicates either success or failure once completed.
  prefs: []
  type: TYPE_NORMAL
- en: Two options that are typically used in a Kubernetes environment to create short-lived
    tasks are to make use of either a bare **pod** or a **job**. A bare pod is a pod
    that runs until completion and then terminates, but will not be rescheduled if
    the underlying node fails. For this reason, it may be preferred to run life cycle
    hooks as jobs, which reschedules the hook if the node fails or becomes unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Since hooks are simply defined as Kubernetes resources, they are also placed
    in the `templates/` folder and annotated with the helm.sh/hook annotation. The
    designation of this annotation ensures they are not rendered with the rest of
    the resources that are applied to a Kubernetes environment during standard processing.
    Instead, they are rendered and applied based on the value specified within the
    helm.sh/hook annotation, which determines when it should be executed within Kubernetes
    as part of the Helm release life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how a hook can be defined as a job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This trivial example prints out the current date and time in the container before
    sleeping for 10 seconds. Helm executes this hook before and after installing the
    chart, as noted by the value of the 'helm.sh/hook' annotation. A use case for
    this type of hook is to tie into an auditing system that tracks the installation
    of applications to a Kubernetes environment. A similar hook can be added after
    the installation completes to track the total time it took to complete the chart
    installation process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explained the basics of Helm hooks, let's discuss how hooks
    can be defined in a Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: Hook execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you saw in the `job` hook in the previous section, the value of the `helm.sh/hook`
    annotation was `pre-install`. `pre-install` is one of the points during the life
    span of a Helm chart where a hook can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table denotes the available options for the `helm.sh/hook` annotation,
    indicating when the hook is executed. The descriptions for each hook references
    the official Helm documentation, which can be found at https://helm.sh/docs/topics/charts_hooks/#the-available-hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `helm.sh/hook` annotation can contain multiple values indicating that the
    same resource is executed at different points in time within a chart''s release
    cycle. For example, for a hook to be executed before and after a chart installation,
    the following annotation can be defined on either the pod or job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It is useful to understand how and when hooks are executed in order to determine
    the desired phase in a charts'' life cycle that needs to be selected. As described
    in the previous example, when a hook is denoted to run in the `pre-install` and
    `post-install` portions of an execution of the `helm install` command, the following
    actions take place:'
  prefs: []
  type: TYPE_NORMAL
- en: The user installs a Helm chart (by running, for example, `helm install bitnami/wordpress
    --version 8.1.0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Helm API is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CRDs in the `crds/` folder are loaded to the Kubernetes environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verification of the chart templates is performed and the resources are rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pre-install` hooks are ordered by weight, then are rendered and loaded
    to Kubernetes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Helm waits until the hooks are ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Template resources are rendered and applied to the Kubernetes environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `post-install` hooks are executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Helm waits until the `post-install` hooks are complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results of the `helm install` command are returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With an understanding of the basics of Helm hook execution, let's cover some
    of the more advanced topics around Helm hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced hook concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While minimal effort is needed to transform a standard Helm template resource
    into a hook, there are additional options that aid in chart execution and resource
    removal.
  prefs: []
  type: TYPE_NORMAL
- en: There is no limit to the number of hooks that can be executed during the life
    span of a Helm chart and there may be cases where multiple hooks are configured
    for the same life cycle phase. When this scenario arises, hooks, by default, are
    ordered alphabetically by name. However, you can define the order by specifying
    the weight of each hook using the `helm.sh/weight` annotation. Weights are sorted
    in ascending order, but if multiple hooks contain the same weight value, the default
    logic of sorting alphabetically by name is used.
  prefs: []
  type: TYPE_NORMAL
- en: While hooks present a useful mechanism for life cycle management, you should
    keep in mind that hooks, unlike regular template resources, are not removed with
    the rest of the chart during an invocation of the `helm uninstall` command as
    they are not tracked or managed by Helm. Instead, a couple of strategies can be
    employed to remove hooks during a release's life cycle, such as configuring a
    deletion policy and setting a TTL on a job.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `helm.sh/hook-delete-policy` annotation can be specified on the
    pod or job associated with the hook. This annotation determines when Helm should
    act on removing the resource from Kubernetes. The following options are available
    (the descriptions reference the Helm documentation, which can be found at https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, Kubernetes provides the option of defining a **Time-To-Live**
    (**TTL**) mechanism to limit the amount of time a resource is retained for after
    completion using the `ttlSecondsAfterFinished` property of the job, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the resources are removed in 60 seconds upon completion or
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final stage of a release''s life cycle is its deletion, and although standard
    chart templates are removed during the invocation of the `helm uninstall` command
    you may want certain resources to be retained so that Helm doesn''t take action
    on them. A common use case for this is when a new persistent volume via a `PersistentVolumeClaim`
    command is created at the beginning of a release''s life cycle but should not
    be removed alongside other resources at the end so that the volume''s data is
    retained. This option is enabled through the use of the `helm.sh/resource-policy`
    annotation, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Helm will no longer consider removing this resource during the execution of
    the `helm uninstall` command. It is important to note that when a resource is
    no longer managed, it becomes orphaned once the remainder of the resources is
    removed. This can cause challenges if the `helm install` command is used as it
    may cause resource-naming conflicts with the existing resource that was not previously
    removed. The orphaned resource can be deleted manually by using the `kubectl delete`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: This section discussed how you can write hooks and automation to manage a chart's
    life cycle. In the next section, we will discuss how you can properly document
    a Helm chart to ensure its users have a smooth experience.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a Helm chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any other software that users interact with, a Helm chart should be
    properly documented so that users know how to interact with it. The Helm chart
    structure supports a `README.md` file for documenting usage, a `LICENSE` file
    for covering usage and distribution rights, and a `templates/NOTES.txt` file for
    generating usage instructions during chart installation.
  prefs: []
  type: TYPE_NORMAL
- en: The README.md File
  prefs: []
  type: TYPE_NORMAL
- en: '**README** is a file commonly used in software development to describe the
    installation, usage, and other details of a product. A Helm chart''s README file
    often contains the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**: A common example of a prerequisite is creating a `secret`
    or a set of secrets to the Kubernetes cluster before a chart is installed. for
    the purpose of mounting to a Kubernetes deployment. Users can be made aware of
    this requirement by referencing the README file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Values**: Charts often consist of many different values, each of which should
    be described in a table in the `README` file. The table should specify the name
    of the value, its description or function, and its default value. You may also
    find it helpful to denote whether or not the value needs to be provided during
    an installation or upgrade.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application-specific information**: Once an application is installed using
    the Helm chart, you may need additional information on the application itself,
    such as how it can be accessed or how the application functions. These details
    can be provided in the `README` file as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm READMEs are written using the **Markdown** formatting language. Markdown
    is commonly used in GitHub projects and open source software and is a way of easily
    codifying text that can be displayed in an elegant format. Markdown can be explored
    further on the **Markdown Guide** website, loc[ated at https://www.markdowngu](https://www.markdownguide.org/)ide.org/.
  prefs: []
  type: TYPE_NORMAL
- en: The LICENSE file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from the technical instructions contained in a `README` file, chart maintainers
    may find it necessary to include a license that indicates the permissions users
    have around chart usage and distribution. These details can be composed in a file
    called `LICENSE` under the chart directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `LICENSE` file is a plaintext file containing a software license. The license
    may be custom-written or it can be a copy of a license commonly used in open source
    software, such as the Apache License 2.0 or the MIT License. Understanding the
    differences between licenses as well as the legality in using and distributing
    software is beyond the scope of this book, but you can begin exploring these details
    at the **Choose a License** [website (https://chooseali](https://choosealicense.com/)cense.com/),
    which will assist you in selecting an appropriate license for your Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: The templates/NOTES.txt file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the `README.md` file, the `templates/NOTES.txt` file is used to provide
    usage instructions for the application once installed using Helm. The difference
    is that while the `README.md` file is static, the `NOTES.txt` file can be dynamically
    generated using Go templating.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that a Helm chart has the following value configured in its `values.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the type of service that is set, the instructions to access the
    application will differ. If the service is a `NodePort` service, access will be
    gained by using a certain port number set on each Kubernetes node. If the service
    is set to `LoadBalancer`, the application will be accessed using the URL of a
    load balancer provisioned automatically on the creation of the service. Understanding
    how to access the application based on the type of service being used may be difficult
    for less experienced Kubernetes users, so the maintainer of this chart should
    provide a `NOTES.txt` file under the `templates/` directory that provides instructions
    on how the application can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how a `templates/NOTES.txt` file can be used
    for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This file will be generated and displayed during the application's install,
    upgrade, and rollback phases and can be recalled by running the `helm get notes`
    command. By providing this file, users will get a better understanding of how
    to use the application.
  prefs: []
  type: TYPE_NORMAL
- en: We have described the majority of the assets that comprise a Helm chart so far
    in this chapter, except for the actual packaging, which allows a chart to be easily
    distributable. This concept will be described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging a Helm chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Helm charts follow a common file structure, they should be packaged in
    order to be easily distributed. Charts are packaged in `tgz` archives. While this
    archives can be manually created by using the `tar` bash utility or an archive
    manager, Helm provides the `helm package` command to simplify this task. The syntax
    of the `helm package` command is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `helm package` command is run against a local chart directory. If this
    command is successful, it will generate a `tgz` archive with the following file
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The archive can then be distributed by pushing to a chart repository, which
    is a task that is explored further in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helm package` command includes every file under a chart directory. While
    this is often the preferred behavior, it may not always be desired if the directory
    contains files that are not essential to Helm. One example of a directory where
    this commonly occurs is the `.git/` directory, which is present in projects managed
    by **Git SCM**. If this file is packaged into the chart''s `tgz` archive, it will
    not serve any purpose and will only increase the size of the archive. Helm supports
    a file called `.helmignore` that can be used to omit certain files and folders
    from the Helm archive. The following describes an example `.helmignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file indicates that if the `.git/` directory or the `.gitignore`
    files appear in a chart's directory, they will be ignored by the `helm package`
    command, meaning they will not be present in the resulting `tgz` archive. Lines
    that begin with the pound symbol (`#`) in this file serve as comments. Be sure
    to include a `.helmignore` file in your Helm charts if your chart's directory
    contains files and folders that are not necessary to the overall function of the
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Helm chart is a set of files, written primarily in the YAML format, that follows
    a certain file structure. The `Chart.yaml` file is used to set chart metadata
    and declare dependencies. The `templates/` directory is used to contain Kubernetes
    YAML resources that are Go-templated, allowing them to be dynamically generated.
    Kubernetes resources defined under the `templates/` directory can also contain
    certain hooks to configure stages in an application's life cycle. To provide documentation
    to users, charts can contain the `README.md` and `templates/NOTES.txt` files and
    can also contain the `LICENSE` file to declare chart usage and distribution rights.
    Finally, charts can contain a `.helmignore` file, which is used to omit declared
    files from the final packaged product.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the structure of a Helm chart and how to
    configure key chart components. With the knowledge from this chapter under your
    belt, you now have an understanding of the basic concepts of how to write your
    first Helm chart from scratch, which we will do in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about the basics behind creating Helm charts, consult the Chart
    Template Guide page on the Helm d[ocumentation at https://helm.sh/docs/chart](https://helm.sh/docs/chart_template_guide/)_template_guide/.
    The Ch[arts section at https://helm.sh/doc](https://helm.sh/docs/topics/charts/a)s/topics/charts/
    also describes many of the topics discussed throughout this chapter, including
    chart file structure, dependencies, and the `Chart.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the file format that is most commonly used in Kubernetes and Helm?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three required fields in the `Chart.yaml` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can the values from a chart dependency be referenced or overridden?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine you want to take a data snapshot of a database deployed with Helm. What
    can you do to ensure that a data `snapshot` is taken before upgrading the database
    to a newer version?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What files can you, as a chart developer, create to provide documentation and
    simplify the chart installation process for the end user?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Helm templating construct can you take advantage of to generate repeating
    YAML portions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the `Chart.yaml` file differ from the `Chart.lock` file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the annotation that defines a resource as a hook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of functions and pipelines in chart templates? What are
    some common functions that can be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
