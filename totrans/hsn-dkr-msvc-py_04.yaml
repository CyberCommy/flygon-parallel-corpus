- en: Creating a REST Service with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following our example in the last chapter, we split the system designed as a
    monolith into smaller services. In this chapter, we will analyze in detail one
    of the microservices (Thoughts Backend) that we mentioned in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about how to develop this microservice as an application using
    Python. This microservice will be ready to interact with other microservices through
    a standard web RESTful interface, making it the foundation for our global microservice
    architecture system.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss different elements such as the API design, the database schema
    that supports it, and how to implement and how to implement the microservice.
    Finally, we'll see how to test the application to be sure that it works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Thoughts Backend microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the database schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you'll know how to successfully develop a microservice
    application, including the different stages from design to testing.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Thoughts Backend example can be found here ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend)).
    Installation and running instructions can be found on its `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Thoughts Backend microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s remember the diagram of microservices that we created in the last chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0b5a8c0-862d-494e-bfb4-4077bf0f8dd6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The diagram shows the different elements for our example system: the two backends,
    users and thoughts, and HTML frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Thoughts Backend** will be responsible for storing new thoughts, retrieving
    the existing ones, and searching the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the security layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the Thoughts Backend is going to be available externally, we need to implement
    a security layer. That means we need to identify the user producing the actions
    and verify their validity. For this service example, we will create a new thought from
    the logged in user, and we will retrieve my thoughts, thoughts created by the
    currently logged user.
  prefs: []
  type: TYPE_NORMAL
- en: Note the fact that the user is logged also validates the fact that the user
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: This security layer will come in the shape of a header. This header will contain
    information that is signed by the user backend, verifying its origin. It will
    take the form of a **JSON Web Token** (**JWT**), [https://jwt.io/introduction/](https://jwt.io/introduction/),
    which is a standard for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The JWT itself is encrypted, but the information contained here is mostly only
    relevant for checking the user that was logged.
  prefs: []
  type: TYPE_NORMAL
- en: A JWT is not the only possibility for the token, and there are other alternatives
    such as storing the equivalent data in a session cookie or in more secure environments
    using similar modules such as PASETO ([https://github.com/paragonie/paseto](https://github.com/paragonie/paseto)).
    Be sure that you review the security implications of your system, which are beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: This method should be handled by the **Users Backend** team, and get packaged
    so that the other microservices can use it. For this chapter, we will include
    the code in this microservice, but we'll see later how to create it so it's related
    to the Users Backend.
  prefs: []
  type: TYPE_NORMAL
- en: If the requests don't have a valid header, the API will return a 401 Unauthorized
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that not all API endpoints require authentication. In particular, `search`
    does not need to be logged.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how the authentication system is going to work, we
    can start designing the API interface.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will follow the principles of RESTful design for our API. This means we will
    use constructed URIs that represent resources and then use the HTTP methods to
    perform actions over these resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will only use the `GET` (to retrieve), `POST` (to create),
    and `DELETE` (to delete) methods as the thoughts are not editable. Remember that
    `PUT` (to overwrite completely) and `PATCH` (to perform a partial update) are
    also available.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main properties of RESTful APIs is that requests need to be stateless,
    which means that each request is totally self-contained and can be served by any
    server. All the required data should be either at the client (that will send it
    attached to the request) or in a database (so the server will retrieve it in full).
    This property is a hard requirement when dealing with Docker containers, as they
    can be destroyed and recreated without warning.
  prefs: []
  type: TYPE_NORMAL
- en: While it is common to have resources that map directly to rows in a database,
    this is not necessary. The resources can be a composition of different tables,
    part of them, or even represent something different altogether, such as an aggregation
    of data, whether certain conditions are met, or a forecast based on analysis on
    the current data.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the needs of the service and don't feel constrained by your existing
    database design. Migrating a microservice is a good opportunity to revisit the
    old design decisions and to try to improve the general system. Also, remember
    the Twelve-Factor App principles ([https://12factor.net/](https://12factor.net/))
    for improving the design.
  prefs: []
  type: TYPE_NORMAL
- en: It's always good to have a brief reminder about REST before starting an API
    design, so you can check [https://restfulapi.net/](https://restfulapi.net/) for
    a recap.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the API endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our API interface will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Endpoint** | **Requires authentication** | **Returns** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/me/thoughts/` | Yes | List of thoughts of the user |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/api/me/thoughts/` | Yes | The newly created thought |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/thoughts/` | No | List of all thoughts |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/thoughts/X/` | No | The thought with ID `X` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/thoughts/?search=X` | No | Searches all the thoughts that contain
    `X` |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/admin/thoughts/X/` | No | Deletes thought with ID `X` |'
  prefs: []
  type: TYPE_TB
- en: 'Note there are two elements of the API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A public API, starting with `/api`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An authenticated public API, starting with `/api/me`. The user needs to be authenticated
    to perform these actions. A non-authenticated request will return a 401 Unauthorized
    status code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-authenticated public API, starting with `/api`. Any user, even not authenticated,
    can perform these actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An admin API (starting with `/admin`). This won't be exposed publicly. It spares
    the authentication and allows you to do operations that are not designed to be
    done by customers. Clearly labeling with a prefix helps to audit the operations
    and clearly signifies that they should not be available outside of your data center.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The format of a thought is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To create one, only the text needs to be sent. The timestamp is set automatically,
    the ID is created automatically, and the username is detected by the authentication
    data.
  prefs: []
  type: TYPE_NORMAL
- en: As this is an example, this API is designed to be minimal. In particular, more
    administrator endpoints could be created to effectively impersonate a user and
    allow administrator actions. The `DELETE` action was the first action included
    as a way of cleaning tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final detail: there is some debate over whether it''s best to end URI resources
    with a final slash or not. When working with Flask, though, defining them with
    a slash will return a redirect status code, `308 PERMANENT_REDIRECT`, for a request
    without the proper ending. In any case, try to be consistent to avoid confusion.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the database schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The database schema is simple and inherited from the monolith. We care only
    about the thoughts, stored in the `thought_model` table, so the database structure
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Type** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | `INTEGER NOT NULL` | Primary key |'
  prefs: []
  type: TYPE_TB
- en: '| `username` | `VARCHAR(50)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `text` | `VARCHAR(250)` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `timestamp` | `DATETIME` | Creation time |'
  prefs: []
  type: TYPE_TB
- en: The thought_model table
  prefs: []
  type: TYPE_NORMAL
- en: 'This table is represented in code in the `thoughts_backend/models.py` file,
    described in SQLAlchemy format with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: SQLAlchemy is capable of creating the table for testing purposes or for development
    mode. For this chapter, we defined the database to be SQLite, which stores the
    data in the `db.sqlite3` file.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)) is a
    powerful Python module to work with SQL databases. There are two approaches to
    dealing with databases with a high-level language such as Python. One is keeping
    the low-level approach and doing raw SQL statements, retrieving the data as it
    is in the database. The other is to abstract the database using an **Object-Relational
    Mapper** (**ORM**) and use the interface without getting into the details of how
    it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is well represented by the Python database API specification
    (PEP 249—[https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/)),
    which is followed by all major databases, such as `psycopg2` ([http://initd.org/psycopg/](http://initd.org/psycopg/))
    for PostgreSQL. This mainly creates SQL string commands, executes them, and then
    parses the results. This allows us to tailor each query, but it's not very productive
    for common operations that get repeated over and over. PonyORM ([https://ponyorm.org/](https://ponyorm.org/))
    is another example that's not so low level but still aims at replicating the SQL
    syntax and structure.
  prefs: []
  type: TYPE_NORMAL
- en: For the second approach, the best-known example is probably the Django ORM ([https://docs.djangoproject.com/en/2.2/topics/db/](https://docs.djangoproject.com/en/2.2/topics/db/)).
    It abstracts the database access using defined model python objects. It works
    fantastically well for common operations, but its model assumes that the definition
    of the database is done in our Python code, and mapping legacy databases can be
    very painful. Some complex SQL operations created by the ORM can take a lot of
    time, while a custom-tailored query could save a lot of time. It's also easy to
    perform slow queries without even realizing, just because the tool abstracts us
    so much from the end result.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)) is
    quite flexible and can work on both ends of the spectrum. It''s not as straightforward
    or as easy to use as the Django ORM, but it allows us to map existing databases
    into an ORM. This is why we will use it in our example: it can take an existing,
    complicated legacy database and map it, allowing you to perform simple operations
    easily and complicated operations in exactly the way you want.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the operations we are going to be using in this book are quite
    simple and SQLAlchemy won't shine particularly in those tasks. But it's an invaluable
    tool if you're planning a complex migration from an old monolith that accesses
    the database through manually written SQL statements, to a newly created microservice.
    If you are already dealing with a complicated database, spending some time learning
    how to use SQLAlchemy will be invaluable. A well-tailored SQLAlchemy definition
    can perform some abstract tasks very efficiently, but it requires good knowledge
    of the tool.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for Flask-SQLAlchemy ([https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/))
    is a good place to start, as it summarizes the main operations, and the main SQLAlchemy
    documentation can be overwhelming at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we define a model, we can perform a query by using the `query` attribute
    in the model and filter accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Storing and deleting a row requires the use of the session and then committing
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To see how to configure the database access, check the `thoughts_backend/db.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement this microservice, we will use Flask-RESTPlus ([https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/)).
    This is a Flask ([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/))
    extension. Flask is a well-known Python microframework for web applications that's
    particularly good at implementing microservices, as it's small, easy to use, and
    compatible with the usual technology stack in terms of web applications, since
    it uses the **Web Server Gateway Interface** (**WSGI**) protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Flask-RESTPlus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask is capable of implementing a RESTful interface, but Flask-RESTPlus adds
    some very interesting capabilities that allow for good developing practices and
    speed of development:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines namespaces, which are ways of creating prefixes and structuring the
    code. This helps long-term maintenance and helps with the design when creating
    new endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have more than 10 endpoints in a single namespace, it may be a good time
    to consider dividing it. Use one namespace per file, and allow the size of the
    file to hint when it's a good idea to try to make a division.
  prefs: []
  type: TYPE_NORMAL
- en: It has a full solution for parsing input parameters. This means that we have
    an easy way of dealing with endpoints that requires several parameters and validates
    them. Using the *Request Parsing* ([https://flask-restplus.readthedocs.io/en/stable/parsing.html](https://flask-restplus.readthedocs.io/en/stable/parsing.html))
    module is similar to using the `argparse` command-line module ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)) that's
    included in the Python standard library. It allows defining arguments in the body
    of the request, headers, query strings, or even cookies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same way, it has a serialization framework for the resulting objects.
    Flask-RESTful calls it **response marshalling** ([https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)).
    This helps to define objects that can be reused, clarifying the interface and
    simplifying the development. If enabled, it also allows for field masks, which
    return partial objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has full Swagger API documentation support. Swagger ([https://swagger.io/](https://swagger.io/))
    is an open source project to help in the design, implementation, documentation,
    and testing of RESTful API web services, following standard OpenAPI specifications.
    Flask-RESTPlus automatically generates a Swagger specification and self-documenting
    page:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c4c54c31-5d8e-4b11-b13b-9e3d21a30b6c.png)'
  prefs: []
  type: TYPE_IMG
- en: The main Swagger documentation page for the Thoughts Backend API, generated
    automatically
  prefs: []
  type: TYPE_NORMAL
- en: 'Other nice elements of Flask are derived from the fact that it''s a popular
    project and has a lot of supported tools:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the connector for SQLAlchemy, Flask-SQLAlchemy ([https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)).
    Its documentation covers most of the common cases, while the SQLAlchemy documentation
    is more detailed and can be a bit overwhelming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run the tests, the `pytest-flask` module ([https://pytest-flask.readthedocs.io/en/latest/](https://pytest-flask.readthedocs.io/en/latest/))
    creates some fixtures ready to work with a Flask application. We will talk more
    about this in the *Testing the code* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A typical RESTful application has the following general structure:'
  prefs: []
  type: TYPE_NORMAL
- en: A URL-defined **resource**. This resource allows one or more actions through
    HTTP methods (`GET`, `POST`, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When each of the actions is called, the framework routes the request until the
    defined code executes the action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are any input parameters, they'll need to be validated first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the action and obtain a result value. This action will normally involve
    one or more calls to the database, which will be done in the shape of models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the resulting result value and encode it in a way that's understood
    by the client, typically in JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the encoded value to the client with the adequate status code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of these actions are done by the framework. Some configuration work needs
    to be done, but it's where our web framework, Flask-RESTPlus in this example,
    will help the most. In particular, everything but *step 4* will be greatly simplified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple code example (available in GitHub) to describe
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This implements the `GET /api/thoughts/X/` action, retrieving a single thought
    by ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze each of the elements. Note the lines are grouped thematically:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the resource by its URL. Note that `api_namespace` sets the
    `api` prefix to the URL, which validates that parameter `X` is an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The class allows you to perform multiple actions on the same resource. In this
    case, we only do one: the `GET` action.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the `thought_id` parameter, encoded in the URL, is passed as a parameter
    to the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute the action, which is a search in the database to retrieve
    a single object. Call `ThoughModel` to search for the specified thought. If found,
    it''s returned with a `http.client.OK (200)` status code. If it''s not found,
    an empty result and a `http.client.NOT_FOUND 404` status code is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `thought` object is being returned. The `marshal_with` decorator describes
    how the Python object should be serialized into a JSON structure. We''ll see later
    how to configure it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have some documentation, including the docstring that will be rendered
    by the autogenerated Swagger API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most of the actions are configured and performed through Flask-RESTPlus,
    and the bulk of the work as a developer is the meaty *step 4*. There's work to
    do, though, configuring what the expected input parameters are and validating
    them, as well as how to serialize the returning object into proper JSON. We'll
    see how Flask-RESTPlus can help us with that.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing input parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The input parameters can take different shapes. When we talk about input parameters,
    we talk mainly about two kinds:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String query parameters encoded into the URL. These are normally used for the `GET`
    requests, and look like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: They are part of the URL and will be stored in any log along the way. The parameters
    are encoded into their own format, called **URL encoding** ([https://www.urlencoder.io/learn/](https://www.urlencoder.io/learn/)).
    You've probably noticed that, for example, an empty space gets transformed to
    `%20`.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we won't have to decode query parameters manually, as frameworks such
    as Flask do it for us, but the Python standard library has utilities to do so
    ([https://docs.python.org/3/library/urllib.parse.html](https://docs.python.org/3/library/urllib.parse.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the body of the HTTP request. This is typically used in the `POST`
    and `PUT` requests. The specific format can be specified using the `Content-Type`
    header. By default, the `Content-Type` header is defined as `application/x-www-form-urlencoded`,
    which encodes it in URL encoding. In modern applications, this is replaced with
    `application/json` to encode them in JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the requests is not stored in a log. The expectation is that a `GET`
    request produce the same result when called multiple times, that means they are
    idempotent. Therefore, it can be cached by some proxies or other elements. That's
    the reason why your browser asks for confirmation before sending a `POST` request again,
    as this operation may generate different results.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are two other places to pass parameters that can also be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**As a part of the URL**: Things such as `thought id` are parameters. Try to
    follow RESTful principles and define your URLs as resources to avoid confusion.
    Query parameters are best left as optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Headers**: Normally, headers give information about metadata, such as the
    format of the request, the expected format, or authentication data. But they need
    to be treated as input parameters as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these elements are decoded automatically by Flask-RESTPlus, so we don't
    need to deal with encodings and low-level access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this works in our example. This code is extracted from the one
    in GitHub, and shortened to describe the parsing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a parser in the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`authentication_parser` is inherited by `thought_parser` to extend the functionality
    and combine both. Each of the parameters is defined in terms of type and whether
    they are required or not. If a required parameter is missing or another element
    is incorrect, Flask-RESTPlus will raise a `400 BAD_REQUEST` error, giving feedback
    about what went wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we want to handle the authentication in a slightly different way, we
    label it as not required and allow it to use the default (as created for the framework)
    value of `None`. Note that we specify that the `Authorization` parameter should
    be in the headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `post` method gets a decorator to show that it expects the `thought_parser` parameter,
    and we parse it with `parse_args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, `args` is now a dictionary with all the parameters properly parsed
    and used in the next lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the particular case of the authentication header, there''s a specific function
    to work with that, and it return a `401 UNAUTHORIZED` status code through the
    usage of `abort`. This call immediately stops a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will leave aside for a moment the action to be performed (storing a new thought
    in the database), and focus on the other framework configuration, to serialize
    the result into a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to return our results. The easiest way to do so is by defining the shape
    the JSON result should have through a serializer or marshalling model ([https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'A serializer model is defined as a dictionary with the expected fields and
    a field type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The model will take a Python object, and convert each of the attributes into
    the corresponding JSON element, as defined in the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `new_thought` is a `ThoughtModel` object, as retrieved by SQLAlchemy.
    We''ll see it in detail next, but for now, it suffices to say that it has all
    the attributes defined in the model: `id`, `username`, `text`, and `timestamp`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any attribute not present in the memory object will have a value of `None`
    by default. You can change this default to a value that will be returned. You
    can specify a function, so it will be called to retrieve a value when the response
    is generated. This is a way of adding dynamic information to your object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add the name of the attribute to be serialized, in case it''s
    different than the expected outcome, or add a `lambda` function that will be called
    to retrieve the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For more complex objects, you can nest values like this. Note this defines
    two models from the point of view of the documentation and that each `Nested`
    element creates a new scope. You can also use `List` to add multiple instances
    of the same kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Some of the available fields have more options, such as the date format for
    the `DateTime` fields. Check the full field's documentation ([https://flask-restplus.readthedocs.io/en/stable/api.html#models](https://flask-restplus.readthedocs.io/en/stable/api.html#models))
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you return a list of elements, add the `as_list=True` parameter in the `marshal_with`
    decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `marshal_with` decorator will transform the `result` object from a Python
    object into the corresponding JSON data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, it will return a `http.client.OK (200)` status code, but we can
    return a different status code returning two values: the first is the object to
    `marshal` and the second is the status code. The code parameter in the `marshal_with` decorator is
    used for documentation purposes. Note, in this case, we need to add the specific
    `marshal` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swagger documentation will display all your used-defined `marshal` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a40a02d-6154-4ae0-877e-48163872898f.png)'
  prefs: []
  type: TYPE_IMG
- en: The end of the Swagger page
  prefs: []
  type: TYPE_NORMAL
- en: One inconvenience of Flask-RESTPlus is that to input and output the same objects,
    they need to be defined twice, as the modules for input and output are different.
    This is not the case in some other RESTful frameworks, for example, in the Django
    REST framework ([https://www.django-rest-framework.org/](https://www.django-rest-framework.org/)).
    The maintainers of Flask-RESTPlus are aware of this, and, according to them, they'll
    be integrating an external module, probably `marshmallow` ([https://marshmallow.readthedocs.io/en/stable/](https://marshmallow.readthedocs.io/en/stable/)).
    You can integrate it manually if you like, as Flask is flexible enough to do so,
    take a look at this example ([https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy](https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy)).
  prefs: []
  type: TYPE_NORMAL
- en: For more details, you can check the full marshalling documentation at [https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html))
    of Flask-RESTPlus.
  prefs: []
  type: TYPE_NORMAL
- en: Performing the action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we get to the specific part where the input data is clean and ready
    to use, and we know how to return the result. This part likely involves performing
    some database query or queries and composing the results. Let''s look at the following
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see here, after parsing the parameters, we use SQLAlchemy to retrieve
    a query that, if the `search` parameter is present, will apply a filter. We obtain
    all the results with `all()`, returning all the `ThoughtModel` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Returning the objects marshals (encodes them into JSON) them automatically,
    as we specified in the `marshal_with` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logic for authentication is encapsulated in the `thoughts_backend/token_validation.py`
    file. This contains both the generation and the validation of the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions generate the `Bearer` token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This generates a JWT payload. It includes `username` to be used as a custom
    value, but it also adds two standard fields, an `exp` expiration date and the `iat` generation
    time of the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The token is then encoded using the RS256 algorithm, with a private key, and
    returned in the proper format: `Bearer <token>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The reverse action is to obtain the username from an encoded header. The code
    here is longer, as we should account for the different options in which we may
    receive the `Authentication` header. This header comes directly from our public
    API, so we should expect any value and program to be defensively ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The decoding of the token itself is straightforward, as the `jwt.decode` action
    will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'But before arriving at that step, we need to obtain the token and verify that
    the header is valid in multiple cases, so we check first whether the header is
    empty, and whether it has the proper format, extracting the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we decode the token. If the token cannot be decoded with the public key,
    it raises `DecodeError`. The token can also be expired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, check that it has the expected `exp` and `username` parameters. If any
    of these parameters is missing, that means that the token format, after decoding,
    is incorrect. This may happen when changing the code in different versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes fine, return the username at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the possible problems is logged with a different severity. Most common
    occurrences are logged with info- level security, as they are not grave. Things
    such as a format error after the token is decoded may indicate a problem with
    our encoding process.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using a private/public key schema, instead of a symmetric key
    schema, to encode and decode the tokens. This means that the decoding and encoding
    keys are different.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, this is a sign/verification as it is used to generate a signature,
    and not encode/decode, but it's the naming convention used in JWT.
  prefs: []
  type: TYPE_NORMAL
- en: In our microservice structure, only the signing authority requires the private
    key. This increases the security as any key leakage in other services won't be
    able to retrieve a key capable of signing bearer tokens. We'll need to generate
    proper private and public keys, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a private/public key, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to extract the public key, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate two files: `key.pem` and `key.pub` with a private/public
    key pair. Reading them in text format will be enough to use them as keys for encoding/decoding
    the JWT token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that, for the tests, we generated a **sample key pair** that's attached
    as strings. These keys have been created specifically for this usage and are not
    used anywhere else. Please do not use them anywhere as they are publicly available
    in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that you require a non-encrypted private key, not protected by a password,
    as the JWT module doesn't allow you to add a password. **Do not store production
    secret keys in unprotected files**. In [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml),
    *Build, Run, and Test Your Service Using Docker*, we'll see how to inject this
    secret using an environment variable, and in [Chapter 11](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml),
    *Handling Change, Dependencies, and Secrets in the System*, we'll see how to properly
    deal with secrets in production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test our application, we use the excellent `pytest` framework, which is the
    gold standard in test runners for Python applications.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, `pytest` has a lot of plugins and add-ons to deal with a lot of situations.
    We will be using `pytest-flask`, which helps with running tests for Flask applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run all the tests, just call `pytest` in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that `pytest` has a lot of features available to deal with a lot of situations
    while testing. Things running a subset of matched tests (the `-k` option), running
    the last failed tests (`--lf`), or stopping after the first failure (`-x`) are
    incredibly useful when working with tests. I highly recommend checking its full
    documentation ([https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/))
    and discovering all its possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a lot of plugins and extensions for using databases or frameworks,
    reporting code coverage, profiling, BDD, and many others. It is worth finding
    out about them.
  prefs: []
  type: TYPE_NORMAL
- en: We configure the basic usage, including always enabling flags in the `pytest.ini` file
    and the fixtures in `conftest.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the pytest fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixtures are used in `pytest` to prepare the context in which a test should
    be executed, preparing it and cleaning it at the end. The application fixture
    is expected by `pytest-flask`, as seen in the documentation. The plugin generates
    a `client` fixture that we can use to send requests in test mode. We see this
    fixture in action in the `thoughts_fixture` fixture, which generates three thoughts
    through the API and deletes everything after our test has run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure, simplified, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate three thoughts. Store its `thought_id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add `yield thought_ids` to the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieve all thoughts and delete them one by one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `faker` module to generate fake names and text. You can
    check its full documentation at [https://faker.readthedocs.io/en/stable/](https://faker.readthedocs.io/en/stable/).
    It is a great way of generating random values for your tests that avoid reusing `test_user` and
    `test_text` over and over. It also helps to shape your tests, by checking the
    input independently and not blindly copying a placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures can also exercise your API. You can choose a lower-level approach such
    as writing raw information in your database, but using your own defined API is
    a great way of ensuring that you have a complete and useful interface. In our
    example, we added an admin interface that's used to delete thoughts. This is exercised
    throughout the fixture as well as the creation of thoughts for a whole and complete
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we also use tests to validate that we can use our microservice as
    a complete service, without tricking ourselves into hacking our way to perform
    common operations.
  prefs: []
  type: TYPE_NORMAL
- en: Also note the usage of the `client` fixture, which is provided by `pytest-flask`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding test_token_validation.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This test file tests the behavior of the `token_validation` module. This module
    covers the generation and validation of the authentication header, so it's important
    to test it thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests check that the header can be encoded and decoded with the proper
    keys. It also checks all the different possibilities in terms of invalid inputs:
    different shapes of incorrect formats, invalid decoding keys, or expired tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for expired tokens, we use two modules: `freezegun`, to make the test
    to retrieve a specific test time ([https://github.com/spulec/freezegun](https://github.com/spulec/freezegun)),
    and `delorean`, to parse dates easily (though, the module is capable of way more;
    check the documentation at [https://delorean.readthedocs.io/en/latest/](https://delorean.readthedocs.io/en/latest/)).
    These two modules are very easy to use and great for testing purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this test checks an expired token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note how the freeze time is precisely 1 second after the expiry time of the
    token.
  prefs: []
  type: TYPE_NORMAL
- en: The public and private keys used for tests are defined in the `constants.py` file.
    There's an extra independent public key used to check what happens if you decode
    a token with an invalid public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth saying it again: please *do not* use any of these keys. These keys
    are for running tests only and are available to anyone who has access to this
    book.'
  prefs: []
  type: TYPE_NORMAL
- en: test_thoughts.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file checks the defined API interfaces. Each API is tested to perform the
    actions correctly (create a new thought, return thoughts of a user, retrieve all
    thoughts, search through thoughts, and retrieve a thought by ID) as well as some
    error tests (unauthorized requests to create and retrieve thoughts of a user,
    or retrieve a non-existing thought).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use `freezegun` again to determine when the thoughts are created, instead
    of creating them with a timestamp dependent on the time when tests are run.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to develop a web microservice. We started by designing
    its API following REST principles. Then, we described how to access the schema
    of the database, and how to do it using SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to implement it using Flask-RESTPlus. We learned how to
    define the resources being mapped to the API endpoints, how to parse the input
    values, how to process the actions, and then how to return the results using the
    serializer model. We described how the authentication layer works.
  prefs: []
  type: TYPE_NORMAL
- en: We included tests and described how to use the `pytest` fixture to create initial
    conditions for our tests. In the next chapter, we will look at how to containerize
    the service and run it through Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you name the characteristics of RESTful applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using Flask-RESTPlus?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which alternative frameworks to Flask-RESTPlus do you know?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the Python package used in the tests to fix the time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you describe the authentication flow?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we choose SQLAlchemy as a database interface for the example project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For an in-depth description of a RESTful design that is not limited to Python,
    you can find more information in *Hands-On RESTful API Design Patterns and Best
    Practices* ([https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices](https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices)).
    You can learn more about how to use the Flask framework in the book *Flask: Building
    Python Web Services* ([https://www.packtpub.com/gb/web-development/flask-building-python-web-services](https://www.packtpub.com/gb/web-development/flask-building-python-web-services)).'
  prefs: []
  type: TYPE_NORMAL
