- en: Creating a REST Service with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following our example in the last chapter, we split the system designed as a
    monolith into smaller services. In this chapter, we will analyze in detail one
    of the microservices (Thoughts Backend) that we mentioned in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about how to develop this microservice as an application using
    Python. This microservice will be ready to interact with other microservices through
    a standard web RESTful interface, making it the foundation for our global microservice
    architecture system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss different elements such as the API design, the database schema
    that supports it, and how to implement and how to implement the microservice.
    Finally, we'll see how to test the application to be sure that it works correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Thoughts Backend microservice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the RESTful API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the database schema
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you'll know how to successfully develop a microservice
    application, including the different stages from design to testing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Thoughts Backend example can be found here ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter02/ThoughtsBackend)).
    Installation and running instructions can be found on its `README.md` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Thoughts Backend microservice
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s remember the diagram of microservices that we created in the last chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0b5a8c0-862d-494e-bfb4-4077bf0f8dd6.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: 'The diagram shows the different elements for our example system: the two backends,
    users and thoughts, and HTML frontend.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '**Thoughts Backend** will be responsible for storing new thoughts, retrieving
    the existing ones, and searching the database.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the security layer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the Thoughts Backend is going to be available externally, we need to implement
    a security layer. That means we need to identify the user producing the actions
    and verify their validity. For this service example, we will create a new thought from
    the logged in user, and we will retrieve my thoughts, thoughts created by the
    currently logged user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Note the fact that the user is logged also validates the fact that the user
    exists.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: This security layer will come in the shape of a header. This header will contain
    information that is signed by the user backend, verifying its origin. It will
    take the form of a **JSON Web Token** (**JWT**), [https://jwt.io/introduction/](https://jwt.io/introduction/),
    which is a standard for this purpose.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The JWT itself is encrypted, but the information contained here is mostly only
    relevant for checking the user that was logged.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: A JWT is not the only possibility for the token, and there are other alternatives
    such as storing the equivalent data in a session cookie or in more secure environments
    using similar modules such as PASETO ([https://github.com/paragonie/paseto](https://github.com/paragonie/paseto)).
    Be sure that you review the security implications of your system, which are beyond
    the scope of this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: This method should be handled by the **Users Backend** team, and get packaged
    so that the other microservices can use it. For this chapter, we will include
    the code in this microservice, but we'll see later how to create it so it's related
    to the Users Backend.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: If the requests don't have a valid header, the API will return a 401 Unauthorized
    status code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Note that not all API endpoints require authentication. In particular, `search`
    does not need to be logged.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how the authentication system is going to work, we
    can start designing the API interface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Designing the RESTful API
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will follow the principles of RESTful design for our API. This means we will
    use constructed URIs that represent resources and then use the HTTP methods to
    perform actions over these resources.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will only use the `GET` (to retrieve), `POST` (to create),
    and `DELETE` (to delete) methods as the thoughts are not editable. Remember that
    `PUT` (to overwrite completely) and `PATCH` (to perform a partial update) are
    also available.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: One of the main properties of RESTful APIs is that requests need to be stateless,
    which means that each request is totally self-contained and can be served by any
    server. All the required data should be either at the client (that will send it
    attached to the request) or in a database (so the server will retrieve it in full).
    This property is a hard requirement when dealing with Docker containers, as they
    can be destroyed and recreated without warning.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: While it is common to have resources that map directly to rows in a database,
    this is not necessary. The resources can be a composition of different tables,
    part of them, or even represent something different altogether, such as an aggregation
    of data, whether certain conditions are met, or a forecast based on analysis on
    the current data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Analyze the needs of the service and don't feel constrained by your existing
    database design. Migrating a microservice is a good opportunity to revisit the
    old design decisions and to try to improve the general system. Also, remember
    the Twelve-Factor App principles ([https://12factor.net/](https://12factor.net/))
    for improving the design.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: It's always good to have a brief reminder about REST before starting an API
    design, so you can check [https://restfulapi.net/](https://restfulapi.net/) for
    a recap.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the API endpoints
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our API interface will be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Endpoint** | **Requires authentication** | **Returns** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/me/thoughts/` | Yes | List of thoughts of the user |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/api/me/thoughts/` | Yes | The newly created thought |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/thoughts/` | No | List of all thoughts |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/thoughts/X/` | No | The thought with ID `X` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/api/thoughts/?search=X` | No | Searches all the thoughts that contain
    `X` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/admin/thoughts/X/` | No | Deletes thought with ID `X` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: 'Note there are two elements of the API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'A public API, starting with `/api`:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An authenticated public API, starting with `/api/me`. The user needs to be authenticated
    to perform these actions. A non-authenticated request will return a 401 Unauthorized
    status code.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-authenticated public API, starting with `/api`. Any user, even not authenticated,
    can perform these actions.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An admin API (starting with `/admin`). This won't be exposed publicly. It spares
    the authentication and allows you to do operations that are not designed to be
    done by customers. Clearly labeling with a prefix helps to audit the operations
    and clearly signifies that they should not be available outside of your data center.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The format of a thought is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To create one, only the text needs to be sent. The timestamp is set automatically,
    the ID is created automatically, and the username is detected by the authentication
    data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: As this is an example, this API is designed to be minimal. In particular, more
    administrator endpoints could be created to effectively impersonate a user and
    allow administrator actions. The `DELETE` action was the first action included
    as a way of cleaning tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'One final detail: there is some debate over whether it''s best to end URI resources
    with a final slash or not. When working with Flask, though, defining them with
    a slash will return a redirect status code, `308 PERMANENT_REDIRECT`, for a request
    without the proper ending. In any case, try to be consistent to avoid confusion.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Defining the database schema
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The database schema is simple and inherited from the monolith. We care only
    about the thoughts, stored in the `thought_model` table, so the database structure
    is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Type** | **Comments** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| `id` | `INTEGER NOT NULL` | Primary key |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| `username` | `VARCHAR(50)` |  |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| `text` | `VARCHAR(250)` |  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| `timestamp` | `DATETIME` | Creation time |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: The thought_model table
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'This table is represented in code in the `thoughts_backend/models.py` file,
    described in SQLAlchemy format with the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: SQLAlchemy is capable of creating the table for testing purposes or for development
    mode. For this chapter, we defined the database to be SQLite, which stores the
    data in the `db.sqlite3` file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Working with SQLAlchemy
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)) is a
    powerful Python module to work with SQL databases. There are two approaches to
    dealing with databases with a high-level language such as Python. One is keeping
    the low-level approach and doing raw SQL statements, retrieving the data as it
    is in the database. The other is to abstract the database using an **Object-Relational
    Mapper** (**ORM**) and use the interface without getting into the details of how
    it is implemented.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is well represented by the Python database API specification
    (PEP 249—[https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/)),
    which is followed by all major databases, such as `psycopg2` ([http://initd.org/psycopg/](http://initd.org/psycopg/))
    for PostgreSQL. This mainly creates SQL string commands, executes them, and then
    parses the results. This allows us to tailor each query, but it's not very productive
    for common operations that get repeated over and over. PonyORM ([https://ponyorm.org/](https://ponyorm.org/))
    is another example that's not so low level but still aims at replicating the SQL
    syntax and structure.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: For the second approach, the best-known example is probably the Django ORM ([https://docs.djangoproject.com/en/2.2/topics/db/](https://docs.djangoproject.com/en/2.2/topics/db/)).
    It abstracts the database access using defined model python objects. It works
    fantastically well for common operations, but its model assumes that the definition
    of the database is done in our Python code, and mapping legacy databases can be
    very painful. Some complex SQL operations created by the ORM can take a lot of
    time, while a custom-tailored query could save a lot of time. It's also easy to
    perform slow queries without even realizing, just because the tool abstracts us
    so much from the end result.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy ([https://www.sqlalchemy.org/](https://www.sqlalchemy.org/)) is
    quite flexible and can work on both ends of the spectrum. It''s not as straightforward
    or as easy to use as the Django ORM, but it allows us to map existing databases
    into an ORM. This is why we will use it in our example: it can take an existing,
    complicated legacy database and map it, allowing you to perform simple operations
    easily and complicated operations in exactly the way you want.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the operations we are going to be using in this book are quite
    simple and SQLAlchemy won't shine particularly in those tasks. But it's an invaluable
    tool if you're planning a complex migration from an old monolith that accesses
    the database through manually written SQL statements, to a newly created microservice.
    If you are already dealing with a complicated database, spending some time learning
    how to use SQLAlchemy will be invaluable. A well-tailored SQLAlchemy definition
    can perform some abstract tasks very efficiently, but it requires good knowledge
    of the tool.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The documentation for Flask-SQLAlchemy ([https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/))
    is a good place to start, as it summarizes the main operations, and the main SQLAlchemy
    documentation can be overwhelming at first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'After we define a model, we can perform a query by using the `query` attribute
    in the model and filter accordingly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义模型之后，我们可以通过模型中的`query`属性执行查询，并相应地进行过滤：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Storing and deleting a row requires the use of the session and then committing
    it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 存储和删除一行需要使用会话，然后提交它：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To see how to configure the database access, check the `thoughts_backend/db.py` file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看如何配置数据库访问，请查看`thoughts_backend/db.py`文件。
- en: Implementing the service
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施服务
- en: To implement this microservice, we will use Flask-RESTPlus ([https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/)).
    This is a Flask ([https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/))
    extension. Flask is a well-known Python microframework for web applications that's
    particularly good at implementing microservices, as it's small, easy to use, and
    compatible with the usual technology stack in terms of web applications, since
    it uses the **Web Server Gateway Interface** (**WSGI**) protocol.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个微服务，我们将使用Flask-RESTPlus（[https://flask-restplus.readthedocs.io/en/stable/](https://flask-restplus.readthedocs.io/en/stable/)）。这是一个Flask（[https://palletsprojects.com/p/flask/](https://palletsprojects.com/p/flask/)）的扩展。Flask是一个著名的Python微框架，特别擅长实现微服务，因为它小巧、易于使用，并且与Web应用程序的常规技术栈兼容，因为它使用**Web服务器网关接口**（**WSGI**）协议。
- en: Introducing Flask-RESTPlus
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Flask-RESTPlus
- en: 'Flask is capable of implementing a RESTful interface, but Flask-RESTPlus adds
    some very interesting capabilities that allow for good developing practices and
    speed of development:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Flask能够实现RESTful接口，但Flask-RESTPlus添加了一些非常有趣的功能，可以支持良好的开发实践和快速开发：
- en: It defines namespaces, which are ways of creating prefixes and structuring the
    code. This helps long-term maintenance and helps with the design when creating
    new endpoints.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了命名空间，这是创建前缀和结构化代码的一种方式。这有助于长期维护，并在创建新的端点时有助于设计。
- en: If you have more than 10 endpoints in a single namespace, it may be a good time
    to consider dividing it. Use one namespace per file, and allow the size of the
    file to hint when it's a good idea to try to make a division.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在单个命名空间中有超过10个端点，那么现在可能是考虑分割它的好时机。使用一个文件一个命名空间，并允许文件大小提示何时是一个尝试进行分割的好时机。
- en: It has a full solution for parsing input parameters. This means that we have
    an easy way of dealing with endpoints that requires several parameters and validates
    them. Using the *Request Parsing* ([https://flask-restplus.readthedocs.io/en/stable/parsing.html](https://flask-restplus.readthedocs.io/en/stable/parsing.html))
    module is similar to using the `argparse` command-line module ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)) that's
    included in the Python standard library. It allows defining arguments in the body
    of the request, headers, query strings, or even cookies.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个完整的解决方案来解析输入参数。这意味着我们有一种简单的方法来处理需要多个参数并验证它们的端点。使用*请求解析*（[https://flask-restplus.readthedocs.io/en/stable/parsing.html](https://flask-restplus.readthedocs.io/en/stable/parsing.html)）模块类似于使用Python标准库中包含的`argparse`命令行模块（[https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)）。它允许在请求体、标头、查询字符串甚至cookie的参数中定义参数。
- en: In the same way, it has a serialization framework for the resulting objects.
    Flask-RESTful calls it **response marshalling** ([https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)).
    This helps to define objects that can be reused, clarifying the interface and
    simplifying the development. If enabled, it also allows for field masks, which
    return partial objects.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，它还有一个用于生成对象的序列化框架。Flask-RESTful称之为**响应编组**（[https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)）。这有助于定义可以重复使用的对象，澄清接口并简化开发。如果启用，它还允许字段掩码，返回部分对象。
- en: 'It has full Swagger API documentation support. Swagger ([https://swagger.io/](https://swagger.io/))
    is an open source project to help in the design, implementation, documentation,
    and testing of RESTful API web services, following standard OpenAPI specifications.
    Flask-RESTPlus automatically generates a Swagger specification and self-documenting
    page:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有完整的Swagger API文档支持。Swagger（[https://swagger.io/](https://swagger.io/)）是一个开源项目，用于帮助设计、实现、文档化和测试RESTful
    API Web服务，遵循标准的OpenAPI规范。Flask-RESTPlus自动生成了Swagger规范和自我记录页面：
- en: '![](img/c4c54c31-5d8e-4b11-b13b-9e3d21a30b6c.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c4c54c31-5d8e-4b11-b13b-9e3d21a30b6c.png)'
- en: The main Swagger documentation page for the Thoughts Backend API, generated
    automatically
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Thoughts Backend API的主要Swagger文档页面，自动生成
- en: 'Other nice elements of Flask are derived from the fact that it''s a popular
    project and has a lot of supported tools:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Flask的其他好元素源自它是一个受欢迎的项目，并且有很多支持的工具：
- en: We will use the connector for SQLAlchemy, Flask-SQLAlchemy ([https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)).
    Its documentation covers most of the common cases, while the SQLAlchemy documentation
    is more detailed and can be a bit overwhelming.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用SQLAlchemy的连接器Flask-SQLAlchemy（[https://flask-sqlalchemy.palletsprojects.com/en/2.x/](https://flask-sqlalchemy.palletsprojects.com/en/2.x/)）。它的文档涵盖了大多数常见情况，而SQLAlchemy的文档更详细，可能有点令人不知所措。
- en: To run the tests, the `pytest-flask` module ([https://pytest-flask.readthedocs.io/en/latest/](https://pytest-flask.readthedocs.io/en/latest/))
    creates some fixtures ready to work with a Flask application. We will talk more
    about this in the *Testing the code* section.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行测试，`pytest-flask`模块（[https://pytest-flask.readthedocs.io/en/latest/](https://pytest-flask.readthedocs.io/en/latest/)）创建了一些准备与Flask应用程序一起工作的固定装置。我们将在*测试代码*部分更多地谈论这个。
- en: Handling resources
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理资源
- en: 'A typical RESTful application has the following general structure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的RESTful应用程序具有以下一般结构：
- en: A URL-defined **resource**. This resource allows one or more actions through
    HTTP methods (`GET`, `POST`, and so on).
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个由URL定义的资源。这个资源允许通过HTTP方法（`GET`，`POST`等）执行一个或多个操作。
- en: When each of the actions is called, the framework routes the request until the
    defined code executes the action.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are any input parameters, they'll need to be validated first.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the action and obtain a result value. This action will normally involve
    one or more calls to the database, which will be done in the shape of models.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the resulting result value and encode it in a way that's understood
    by the client, typically in JSON.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the encoded value to the client with the adequate status code.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of these actions are done by the framework. Some configuration work needs
    to be done, but it's where our web framework, Flask-RESTPlus in this example,
    will help the most. In particular, everything but *step 4* will be greatly simplified.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple code example (available in GitHub) to describe
    it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This implements the `GET /api/thoughts/X/` action, retrieving a single thought
    by ID.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze each of the elements. Note the lines are grouped thematically:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the resource by its URL. Note that `api_namespace` sets the
    `api` prefix to the URL, which validates that parameter `X` is an integer:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The class allows you to perform multiple actions on the same resource. In this
    case, we only do one: the `GET` action.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the `thought_id` parameter, encoded in the URL, is passed as a parameter
    to the method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now execute the action, which is a search in the database to retrieve
    a single object. Call `ThoughModel` to search for the specified thought. If found,
    it''s returned with a `http.client.OK (200)` status code. If it''s not found,
    an empty result and a `http.client.NOT_FOUND 404` status code is returned:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `thought` object is being returned. The `marshal_with` decorator describes
    how the Python object should be serialized into a JSON structure. We''ll see later
    how to configure it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we have some documentation, including the docstring that will be rendered
    by the autogenerated Swagger API:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, most of the actions are configured and performed through Flask-RESTPlus,
    and the bulk of the work as a developer is the meaty *step 4*. There's work to
    do, though, configuring what the expected input parameters are and validating
    them, as well as how to serialize the returning object into proper JSON. We'll
    see how Flask-RESTPlus can help us with that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Parsing input parameters
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The input parameters can take different shapes. When we talk about input parameters,
    we talk mainly about two kinds:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'String query parameters encoded into the URL. These are normally used for the `GET`
    requests, and look like the following:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: They are part of the URL and will be stored in any log along the way. The parameters
    are encoded into their own format, called **URL encoding** ([https://www.urlencoder.io/learn/](https://www.urlencoder.io/learn/)).
    You've probably noticed that, for example, an empty space gets transformed to
    `%20`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we won't have to decode query parameters manually, as frameworks such
    as Flask do it for us, but the Python standard library has utilities to do so
    ([https://docs.python.org/3/library/urllib.parse.html](https://docs.python.org/3/library/urllib.parse.html)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the body of the HTTP request. This is typically used in the `POST`
    and `PUT` requests. The specific format can be specified using the `Content-Type`
    header. By default, the `Content-Type` header is defined as `application/x-www-form-urlencoded`,
    which encodes it in URL encoding. In modern applications, this is replaced with
    `application/json` to encode them in JSON.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The body of the requests is not stored in a log. The expectation is that a `GET`
    request produce the same result when called multiple times, that means they are
    idempotent. Therefore, it can be cached by some proxies or other elements. That's
    the reason why your browser asks for confirmation before sending a `POST` request again,
    as this operation may generate different results.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'But there are two other places to pass parameters that can also be used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另外两个地方可以传递参数：
- en: '**As a part of the URL**: Things such as `thought id` are parameters. Try to
    follow RESTful principles and define your URLs as resources to avoid confusion.
    Query parameters are best left as optional.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为URL的一部分**：像`thought id`这样的东西是参数。尽量遵循RESTful原则，并将URL定义为资源，以避免混淆。查询参数最好留作可选项。'
- en: '**Headers**: Normally, headers give information about metadata, such as the
    format of the request, the expected format, or authentication data. But they need
    to be treated as input parameters as well.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标头**：通常，标头提供有关元数据的信息，例如请求的格式、预期的格式或身份验证数据。但它们也需要被视为输入参数。'
- en: All of these elements are decoded automatically by Flask-RESTPlus, so we don't
    need to deal with encodings and low-level access.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些元素都会被Flask-RESTPlus自动解码，因此我们不需要处理编码和低级访问。
- en: 'Let''s see how this works in our example. This code is extracted from the one
    in GitHub, and shortened to describe the parsing parameters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在我们的例子中是如何工作的。这段代码是从GitHub中提取的，并缩短以描述解析参数：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We define a parser in the following lines:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面的行中定义了一个解析器：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`authentication_parser` is inherited by `thought_parser` to extend the functionality
    and combine both. Each of the parameters is defined in terms of type and whether
    they are required or not. If a required parameter is missing or another element
    is incorrect, Flask-RESTPlus will raise a `400 BAD_REQUEST` error, giving feedback
    about what went wrong.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`authentication_parser`被`thought_parser`继承，以扩展功能并结合两者。每个参数都根据类型和是否需要来定义。如果缺少必需的参数或其他元素不正确，Flask-RESTPlus将引发`400
    BAD_REQUEST`错误，并提供有关出了什么问题的反馈。'
- en: Because we want to handle the authentication in a slightly different way, we
    label it as not required and allow it to use the default (as created for the framework)
    value of `None`. Note that we specify that the `Authorization` parameter should
    be in the headers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想以稍微不同的方式处理身份验证，我们将其标记为不需要，并允许它使用默认值（由框架创建）`None`。请注意，我们指定`Authorization`参数应该在标头中。
- en: 'The `post` method gets a decorator to show that it expects the `thought_parser` parameter,
    and we parse it with `parse_args`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`post`方法得到一个装饰器，表明它期望`thought_parser`参数，并且我们用`parse_args`解析它：'
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Furthermore, `args` is now a dictionary with all the parameters properly parsed
    and used in the next lines.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`args`现在是一个带有所有参数正确解析并在下一行中使用的字典。
- en: 'In the particular case of the authentication header, there''s a specific function
    to work with that, and it return a `401 UNAUTHORIZED` status code through the
    usage of `abort`. This call immediately stops a request:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在身份验证标头的特定情况下，有一个特定的函数来处理它，并且通过使用`abort`返回`401 UNAUTHORIZED`状态码。这个调用立即停止了一个请求：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will leave aside for a moment the action to be performed (storing a new thought
    in the database), and focus on the other framework configuration, to serialize
    the result into a JSON object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时不考虑要执行的操作（将新的想法存储在数据库中），而是专注于其他框架配置，将结果序列化为JSON对象。
- en: Serializing results
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化结果
- en: We need to return our results. The easiest way to do so is by defining the shape
    the JSON result should have through a serializer or marshalling model ([https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要返回我们的结果。最简单的方法是通过定义JSON结果的形状来实现，通过一个序列化器或编组模型（[https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html)）。
- en: 'A serializer model is defined as a dictionary with the expected fields and
    a field type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器模型被定义为一个带有预期字段和字段类型的字典：
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The model will take a Python object, and convert each of the attributes into
    the corresponding JSON element, as defined in the field:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型将接受一个Python对象，并将每个属性转换为相应的JSON元素，如字段中所定义的那样：
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that `new_thought` is a `ThoughtModel` object, as retrieved by SQLAlchemy.
    We''ll see it in detail next, but for now, it suffices to say that it has all
    the attributes defined in the model: `id`, `username`, `text`, and `timestamp`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`new_thought`是一个`ThoughtModel`对象，由SQLAlchemy检索到。我们将在下面详细介绍它，但现在，可以说它具有模型中定义的所有属性：`id`、`username`、`text`和`timestamp`。
- en: 'Any attribute not present in the memory object will have a value of `None`
    by default. You can change this default to a value that will be returned. You
    can specify a function, so it will be called to retrieve a value when the response
    is generated. This is a way of adding dynamic information to your object:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内存对象中不存在的任何属性默认值为`None`。您可以将此默认值更改为将返回的值。您可以指定一个函数，因此在生成响应时将调用它来检索值。这是向对象添加动态信息的一种方式：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also add the name of the attribute to be serialized, in case it''s
    different than the expected outcome, or add a `lambda` function that will be called
    to retrieve the value:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以添加要序列化的属性的名称，以防它与预期的结果不同，或者添加一个将被调用以检索值的`lambda`函数：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For more complex objects, you can nest values like this. Note this defines
    two models from the point of view of the documentation and that each `Nested`
    element creates a new scope. You can also use `List` to add multiple instances
    of the same kind:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的对象，你可以像这样嵌套值。请注意，这从文档的角度定义了两个模型，并且每个`Nested`元素都创建了一个新的作用域。你也可以使用`List`来添加多个相同类型的实例：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Some of the available fields have more options, such as the date format for
    the `DateTime` fields. Check the full field's documentation ([https://flask-restplus.readthedocs.io/en/stable/api.html#models](https://flask-restplus.readthedocs.io/en/stable/api.html#models))
    for more details.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可用字段有更多的选项，比如`DateTime`字段的日期格式。查看完整的字段文档（[https://flask-restplus.readthedocs.io/en/stable/api.html#models](https://flask-restplus.readthedocs.io/en/stable/api.html#models)）以获取更多详细信息。
- en: 'If you return a list of elements, add the `as_list=True` parameter in the `marshal_with`
    decorator:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回一个元素列表，在`marshal_with`装饰器中添加`as_list=True`参数：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `marshal_with` decorator will transform the `result` object from a Python
    object into the corresponding JSON data object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, it will return a `http.client.OK (200)` status code, but we can
    return a different status code returning two values: the first is the object to
    `marshal` and the second is the status code. The code parameter in the `marshal_with` decorator is
    used for documentation purposes. Note, in this case, we need to add the specific
    `marshal` call:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Swagger documentation will display all your used-defined `marshal` objects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a40a02d-6154-4ae0-877e-48163872898f.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: The end of the Swagger page
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: One inconvenience of Flask-RESTPlus is that to input and output the same objects,
    they need to be defined twice, as the modules for input and output are different.
    This is not the case in some other RESTful frameworks, for example, in the Django
    REST framework ([https://www.django-rest-framework.org/](https://www.django-rest-framework.org/)).
    The maintainers of Flask-RESTPlus are aware of this, and, according to them, they'll
    be integrating an external module, probably `marshmallow` ([https://marshmallow.readthedocs.io/en/stable/](https://marshmallow.readthedocs.io/en/stable/)).
    You can integrate it manually if you like, as Flask is flexible enough to do so,
    take a look at this example ([https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy](https://marshmallow.readthedocs.io/en/stable/examples.html#quotes-api-flask-sqlalchemy)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: For more details, you can check the full marshalling documentation at [https://flask-restplus.readthedocs.io/en/stable/marshalling.html](https://flask-restplus.readthedocs.io/en/stable/marshalling.html))
    of Flask-RESTPlus.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Performing the action
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we get to the specific part where the input data is clean and ready
    to use, and we know how to return the result. This part likely involves performing
    some database query or queries and composing the results. Let''s look at the following
    as an example:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see here, after parsing the parameters, we use SQLAlchemy to retrieve
    a query that, if the `search` parameter is present, will apply a filter. We obtain
    all the results with `all()`, returning all the `ThoughtModel` objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Returning the objects marshals (encodes them into JSON) them automatically,
    as we specified in the `marshal_with` decorator.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the requests
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logic for authentication is encapsulated in the `thoughts_backend/token_validation.py`
    file. This contains both the generation and the validation of the header.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions generate the `Bearer` token:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This generates a JWT payload. It includes `username` to be used as a custom
    value, but it also adds two standard fields, an `exp` expiration date and the `iat` generation
    time of the token.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The token is then encoded using the RS256 algorithm, with a private key, and
    returned in the proper format: `Bearer <token>`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The reverse action is to obtain the username from an encoded header. The code
    here is longer, as we should account for the different options in which we may
    receive the `Authentication` header. This header comes directly from our public
    API, so we should expect any value and program to be defensively ready for it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'The decoding of the token itself is straightforward, as the `jwt.decode` action
    will do this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But before arriving at that step, we need to obtain the token and verify that
    the header is valid in multiple cases, so we check first whether the header is
    empty, and whether it has the proper format, extracting the token:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we decode the token. If the token cannot be decoded with the public key,
    it raises `DecodeError`. The token can also be expired:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, check that it has the expected `exp` and `username` parameters. If any
    of these parameters is missing, that means that the token format, after decoding,
    is incorrect. This may happen when changing the code in different versions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If everything goes fine, return the username at the end.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Each of the possible problems is logged with a different severity. Most common
    occurrences are logged with info- level security, as they are not grave. Things
    such as a format error after the token is decoded may indicate a problem with
    our encoding process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using a private/public key schema, instead of a symmetric key
    schema, to encode and decode the tokens. This means that the decoding and encoding
    keys are different.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Technically, this is a sign/verification as it is used to generate a signature,
    and not encode/decode, but it's the naming convention used in JWT.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In our microservice structure, only the signing authority requires the private
    key. This increases the security as any key leakage in other services won't be
    able to retrieve a key capable of signing bearer tokens. We'll need to generate
    proper private and public keys, though.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a private/public key, run the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, to extract the public key, use the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will generate two files: `key.pem` and `key.pub` with a private/public
    key pair. Reading them in text format will be enough to use them as keys for encoding/decoding
    the JWT token:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that, for the tests, we generated a **sample key pair** that's attached
    as strings. These keys have been created specifically for this usage and are not
    used anywhere else. Please do not use them anywhere as they are publicly available
    in GitHub.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that you require a non-encrypted private key, not protected by a password,
    as the JWT module doesn't allow you to add a password. **Do not store production
    secret keys in unprotected files**. In [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml),
    *Build, Run, and Test Your Service Using Docker*, we'll see how to inject this
    secret using an environment variable, and in [Chapter 11](06d0c451-77f1-4e4a-8d38-3abf112f79fa.xhtml),
    *Handling Change, Dependencies, and Secrets in the System*, we'll see how to properly
    deal with secrets in production environments.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test our application, we use the excellent `pytest` framework, which is the
    gold standard in test runners for Python applications.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Basically, `pytest` has a lot of plugins and add-ons to deal with a lot of situations.
    We will be using `pytest-flask`, which helps with running tests for Flask applications.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To run all the tests, just call `pytest` in the command line:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that `pytest` has a lot of features available to deal with a lot of situations
    while testing. Things running a subset of matched tests (the `-k` option), running
    the last failed tests (`--lf`), or stopping after the first failure (`-x`) are
    incredibly useful when working with tests. I highly recommend checking its full
    documentation ([https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/))
    and discovering all its possibilities.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: There are also a lot of plugins and extensions for using databases or frameworks,
    reporting code coverage, profiling, BDD, and many others. It is worth finding
    out about them.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: We configure the basic usage, including always enabling flags in the `pytest.ini` file
    and the fixtures in `conftest.py`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Defining the pytest fixtures
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixtures are used in `pytest` to prepare the context in which a test should
    be executed, preparing it and cleaning it at the end. The application fixture
    is expected by `pytest-flask`, as seen in the documentation. The plugin generates
    a `client` fixture that we can use to send requests in test mode. We see this
    fixture in action in the `thoughts_fixture` fixture, which generates three thoughts
    through the API and deletes everything after our test has run.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure, simplified, is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate three thoughts. Store its `thought_id`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, add `yield thought_ids` to the test:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Retrieve all thoughts and delete them one by one:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that we use the `faker` module to generate fake names and text. You can
    check its full documentation at [https://faker.readthedocs.io/en/stable/](https://faker.readthedocs.io/en/stable/).
    It is a great way of generating random values for your tests that avoid reusing `test_user` and
    `test_text` over and over. It also helps to shape your tests, by checking the
    input independently and not blindly copying a placeholder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures can also exercise your API. You can choose a lower-level approach such
    as writing raw information in your database, but using your own defined API is
    a great way of ensuring that you have a complete and useful interface. In our
    example, we added an admin interface that's used to delete thoughts. This is exercised
    throughout the fixture as well as the creation of thoughts for a whole and complete
    interface.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This way, we also use tests to validate that we can use our microservice as
    a complete service, without tricking ourselves into hacking our way to perform
    common operations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Also note the usage of the `client` fixture, which is provided by `pytest-flask`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Understanding test_token_validation.py
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This test file tests the behavior of the `token_validation` module. This module
    covers the generation and validation of the authentication header, so it's important
    to test it thoroughly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests check that the header can be encoded and decoded with the proper
    keys. It also checks all the different possibilities in terms of invalid inputs:
    different shapes of incorrect formats, invalid decoding keys, or expired tokens.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for expired tokens, we use two modules: `freezegun`, to make the test
    to retrieve a specific test time ([https://github.com/spulec/freezegun](https://github.com/spulec/freezegun)),
    and `delorean`, to parse dates easily (though, the module is capable of way more;
    check the documentation at [https://delorean.readthedocs.io/en/latest/](https://delorean.readthedocs.io/en/latest/)).
    These two modules are very easy to use and great for testing purposes.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this test checks an expired token:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how the freeze time is precisely 1 second after the expiry time of the
    token.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The public and private keys used for tests are defined in the `constants.py` file.
    There's an extra independent public key used to check what happens if you decode
    a token with an invalid public key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth saying it again: please *do not* use any of these keys. These keys
    are for running tests only and are available to anyone who has access to this
    book.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: test_thoughts.py
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This file checks the defined API interfaces. Each API is tested to perform the
    actions correctly (create a new thought, return thoughts of a user, retrieve all
    thoughts, search through thoughts, and retrieve a thought by ID) as well as some
    error tests (unauthorized requests to create and retrieve thoughts of a user,
    or retrieve a non-existing thought).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use `freezegun` again to determine when the thoughts are created, instead
    of creating them with a timestamp dependent on the time when tests are run.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to develop a web microservice. We started by designing
    its API following REST principles. Then, we described how to access the schema
    of the database, and how to do it using SQLAlchemy.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to implement it using Flask-RESTPlus. We learned how to
    define the resources being mapped to the API endpoints, how to parse the input
    values, how to process the actions, and then how to return the results using the
    serializer model. We described how the authentication layer works.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: We included tests and described how to use the `pytest` fixture to create initial
    conditions for our tests. In the next chapter, we will look at how to containerize
    the service and run it through Docker.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you name the characteristics of RESTful applications?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the advantages of using Flask-RESTPlus?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which alternative frameworks to Flask-RESTPlus do you know?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the Python package used in the tests to fix the time.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you describe the authentication flow?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we choose SQLAlchemy as a database interface for the example project?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For an in-depth description of a RESTful design that is not limited to Python,
    you can find more information in *Hands-On RESTful API Design Patterns and Best
    Practices* ([https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices](https://www.packtpub.com/gb/application-development/hands-restful-api-design-patterns-and-best-practices)).
    You can learn more about how to use the Flask framework in the book *Flask: Building
    Python Web Services* ([https://www.packtpub.com/gb/web-development/flask-building-python-web-services](https://www.packtpub.com/gb/web-development/flask-building-python-web-services)).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
