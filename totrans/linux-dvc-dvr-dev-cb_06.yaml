- en: Miscellaneous Kernel Internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing inside the kernel, we may need to do some miscellaneous activities
    to implement our device drivers, such as dynamically allocating memory and using
    specific data types in order to store register data, or simply actively waiting
    some time in order to be sure that a peripheral has completed its reset procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform all these tasks, Linux offers to kernel developers a rich set of
    useful functions, macros, and data types that we''ll try to present in this chapter
    through the means of very simple example codes, because we wish to point out to
    the reader how he/she can use them to simplify device driver development. That''s
    why, in this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using kernel data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing kernel linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using kernel hash tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting access to I/O memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spending time in the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on this chapter, you can visit the *Appendix*.
  prefs: []
  type: TYPE_NORMAL
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_06](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_06).
  prefs: []
  type: TYPE_NORMAL
- en: Using kernel data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, data items of a particular size are required by the kernel code to match
    predefined binary structures, to hold peripheral's register data, to communicate
    with userspace or to simply to align data within structures by inserting padding
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, kernel code requires data items of a specific size, perhaps to match
    predefined binary structures, to communicate with userspace, to hold peripheral's
    register data, or simply to align data within structures by inserting padding
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to see some special data types that can be used
    by kernel developers to simplify their everyday job. In the following, we're going
    to see an example with **fixed-size data types**, which are very useful to define
    some kind of data that is intended to match exactly the structure of data expected
    by a device or by a communication protocol; a careful reader will recognize that
    it wouldn't be possible indeed to define such fixed-size data entities by using
    standard C types, since the C standard does not explicitly guarantee a fixed-size
    representation across all the architectures, when we make use of similar standard
    C types such as `int`, `short`, or `long`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel offers the following data types to use whenever we need to know
    the size of our data (their actual definition depends on the currently used architecture,
    but they are named the same across different architectures):'
  prefs: []
  type: TYPE_NORMAL
- en: '`u8`: Unsigned byte (8 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u16`: Unsigned word (16 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u32`: Unsigned 32-bit (32 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u64`: Unsigned 64-bit (64 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s8`: Signed byte (8 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s16`: Signed word (16 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s32`: Signed 32-bit (32 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s64`: Signed 64-bit (64 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It may also happen that fixed-size data types must be used to exchange data
    with user space; however, in this last case, we cannot use the preceding types,
    but we''ll have to instead opt for the following alternative data types, which
    are equivalent to the preceding ones, but which can be used indifferently within
    both kernel and userspace (this concept will become clearer in the *Using the
    ioctl() method* recipe in [Chapter 7](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml)*,*
    A*dvanced Char Driver Operations*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`__u8`: Unsigned byte (8 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__u16`: Unsigned word (16 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__u32`: Unsigned 32-bit (32 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__u64`: Unsigned 64-bit (64 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__s8`: Signed byte (8 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__s16`: Signed word (16 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__s32`: Signed 32-bit (32 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__s64`: Signed 64-bit (64 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these fixed-size types are defined in the header file, `linux/include/linux/types.h`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to show how to use the preceding data types, we can again use a kernel
    module to execute some kernel code, which uses them to define a register mapping
    within a structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `data_type.c` file, where we put all code into the
    module''s `init()` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After performing *step 1*, the pointer `ptr` is then initialized according
    to the `base_addr` value in such a way that, by simply referencing a field of
    the `struct dtypes_s` (defined in the following code), we can point to the right
    memory address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: During a structure definition, we should be aware that the compiler may quietly
    insert padding into the structure itself to ensure that every field is properly
    aligned in order to attain good performances on the target processor; a workaround
    to avoid this behavior is to tell the compiler that the structure must be packed,
    with no fillers added. This, of course, can be done by using `__attribute__ ((packed))`, as
    before.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we wish to verify the step, we can do this by testing the code. We just
    need to compile the module as usual, then move it to the ESPRESSObin, and finally
    insert into the kernel as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also get an error message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insmod: ERROR: could not insert module data_types.ko: Invalid parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: However, this is due to the last `return -EINVAL` in the function `data_types_init()`;
    we used this as a trick, here and in the following, to force the kernel to remove
    the module after the module's `init()` function execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first lines we get into kernel messages are about the dimensions of type
    `u8`, `u16`, `u32`, and `u64` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the following lines (still among kernel messages) show to us the perfect
    padding we can achieve by using a struct definition with `u8`, `u16`, `u32`, and
    `u64`, and the `__attribute__ ((packed))` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good reference for kernel data types can be found at[ https://kernelnewbies.org/InternalKernelDataTypes](https://kernelnewbies.org/InternalKernelDataTypes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing helper functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During device driver development, we may need to concatenate a string or to
    compute its length or just copy or move a memory region (or a string). To do these
    common operations in the user space, we can use several functions, such as `strcat()`, `strlen()`, `memcpy()` (or `strcpy()`),
    and so on, and Linux offers us similarly named functions, which, of course, are
    safely usable in the kernel. (Note that kernel code cannot be linked against userspace
    glibc libraries.)
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use some kernel helpers in order to manage
    strings within the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we take a look inside kernel sources at the include file `linux/include/linux/string.h`,
    we can see a long list of usual userspace look-alike utility functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that each function is enclosed into `#ifndef`/`#endif` preprocessor condition
    clauses, because some of these functions can be implemented with some form of
    optimization for an architecture; therefore, their implementation may vary across
    different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In order to show how to use the preceding helper functions, we can again use
    a kernel module to execute a kernel code that uses some of them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to do it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `helper_funcs.c` file, we can see some really silly code that exemplifies
    how we can use these helper functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are encouraged to modify this code to play with different kernel helper
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the work is done inside the module''s `init()` function as it was in the
    preceding section. Here we can use the kernel functions `strlen()` and `strncpy()`
    as their userspace counterparts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These functions are special kernel implementations and they are not the userspace functions
    we usually use in normal programming. We cannot link a kernel module with the
    glibc!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `str` string is defined as a module parameter as follows, and it can be
    used to try different strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you wish to test the code in the recipe, you can do so by compiling it and
    then moving it into the ESPRESSObin.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we have to insert the module into the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can safely ignore the following error message, as discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insmod: ERROR: could not insert module helper_funcs.ko: Invalid parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel messages should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can see that string `str2` is just a copy of `str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we use the following `insmod` command, the output will change as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, string `str2` is a copy of `str`, but with its maximum size `STR2_LEN`
    defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a more complete list of string manipulation functions, a good starting point
    is at [https://www.kernel.org/doc/htmldocs/kernel-api/ch02s02.html](https://www.kernel.org/doc/htmldocs/kernel-api/ch02s02.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While regarding string conversion, you can take a look at [https://www.kernel.org/doc/htmldocs/kernel-api/libc.html#id-1.4.3](https://www.kernel.org/doc/htmldocs/kernel-api/libc.html#id-1.4.3).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good device driver should support neither more than one peripheral and (possibly)
    not a fixed number of them! However, even if we decide to restrict driver usage
    to just one peripheral, it may happen that we need to manage a variable number
    of data chunks so, in any case, we need to be able to manage **dynamic memory
    allocation**.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can dynamically (and safely) allocate chunks
    of memory in the kernel space.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to show how we can allocate from memory within the kernel by using `kmalloc()`, `vmalloc()`,
    and `kvmalloc()`, we can again use a kernel module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `mem_alloc.c` file, we can see some really simple code that shows
    how memory allocation works together with the related memory deallocation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the work gets done inside the module''s `init()` function as before. The
    first step is using `kmalloc()` with two different flags, that is `GFP_KERNEL` (which
    can sleep) and `GFP_ATOMIC` (which doesn''t sleep and then it can be safely used
    inside the interrupt context):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we try allocating memory by using `vmalloc()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we try two different allocations by using `kvmalloc()` with two different
    flags, that is `GFP_KERNEL` (which can sleep) and `GFP_ATOMIC` (which doesn''t
    sleep and then it can be safely used inside the interrupt context):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that, for each allocation function, we must use the related `free()` function!
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of the memory chunk to allocate is passed as a kernel parameter as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, as you did before, just compile the module and then move it to the ESPRESSObin.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try inserting the module with the default memory size (that is, 4 KB),
    we should get the following kernel messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can safely ignore the following error message as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insmod: ERROR: could not insert module mem_alloc.ko: Invalid parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: This shows us that all allocation functions successfully complete their job.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we try to increase the memory chunk as follows, something changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now the `kmalloc()` functions fail, while `vmalloc()` is still successful due
    to the fact it allocates on the virtual memory space over non-contiguous physical
    addresses. On the other hand, `kvmalloc()` succeeds when invoked with the flag `GFP_KERNEL`
    while it fails with the flag `GFP_ATOMIC`. (This is due to the fact that it cannot
    use `vmalloc()` as a fallback in this special situation.)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about memory allocation, a good starting point is [https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html](https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing kernel linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When programming inside the kernel, it could be useful to have the ability to
    manage lists of data, so, to reduce the amount of duplicated code, kernel developers
    have created a standard implementation of circular, doubly linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use lists in our code by using the Linux
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate how the list API works, we can again use a kernel module where
    we do some operations inside the module's `init()` function, as done previously.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `list.c` file, there is our example code where all games are played
    inside `list_init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step, let''s take a look at the declaration of the structure implementing
    a list element and the head of the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `list_init()`, we define our elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we add the first element to the list and we print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we continue adding elements and print the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we delete an element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the local function definition; to add an element in ordered
    mode, we can do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, the entry deletion can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the printing of all elements in the list can be achieved as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this last function, we use the macro `list_for_each_entry()` instead of the
    pair `list_for_each()` and `list_entry()`, to get more compact and readable code,
    which essentially performs the same steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The macro is defined in the `linux/include/linux/list.h` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can test the code after compilation and insertion into ESPRESSObin''s kernel.
    To insert the kernel, we do the usual `insmod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can safely ignore the following error message as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insmod: ERROR: could not insert module list.ko: Invalid parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after the first insertion, we have the following kernel message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In *step 1* and *step 2*, we have defined the elements of our list, while, in
    *step 3* we have done the first insert into the list, and the preceding message
    is what we get after the insertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the second insertion in *step 4*, we get the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after the deletion of *step 5*, the list becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in *step 6*, we presented a possible implementation of element insertion
    within the list in ordered mode but, of course, it's up to the developer use the
    best solution. The same considerations can be done for *step 7*, where we have
    implemented the element removal, while in *step 8*, we have the printing function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a more complete function list regarding Linux's list API, a good reference
    can be found at [https://www.kernel.org/doc/htmldocs/kernel-api/adt.html#id-1.3.2](https://www.kernel.org/doc/htmldocs/kernel-api/adt.html#id-1.3.2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using kernel hash tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As for kernel lists, Linux offers to kernel developers a common interface to
    manage hash tables. Their implementation is based on a special version of the
    kernel lists seen in the preceding section and named `hlist` (which is still a
    doubly linked list but with a single pointer list head). This API is defined in
    the header file, `linux/include/linux/hashtable.h`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will show how we can use hash tables in our kernel code by
    using the Linux API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even in this recipe, we can use a kernel module to see how a test code works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `hashtable.c` file, an example is implemented that is very similar to
    the one proposed in the preceding section with kernel lists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step, we declare the hash table, the data structure, and the hash
    function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our hash table has only two buckets just to be able to easily hit a collision,
    so the hash function implementation is very trivial; it must return only values
    `0` or `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the module''s `init()` function, we define our nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we do a first insertion followed by a data printing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we continue node insertion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we try a node deletion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final step, we can have a look at nodes'' insertion and removal functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These two functions need key generation in order to be sure to add or remove
    the node to or from the right bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hash table printing can be done by using the  `hash_for_each()` macro as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, to test the code, just compile and then insert the kernel module into
    the ESPRESSObin.
  prefs: []
  type: TYPE_NORMAL
- en: 'After module insertion, in kernel messages, we should see the first output
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can safely ignore the following error message as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insmod: ERROR: could not insert module hashtable.ko: Invalid parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1* and *step* *2*, we have defined the nodes of our hash table, while
    in *step 3* we have done the first insert into the table, and the preceding code
    is what we get after the insertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we perform the second insertion within *step 4* where we add two nodes
    with the data fields set to `7` and `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, in *step 5* we remove the node having the `data` field set to
    5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that in *step 6*, we presented a possible implementation of the node insertion
    within the hash table. In *step 7*, we have the printing function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about kernel hash tables, a good starting point (even
    if a bit outdated) is[ https://lwn.net/Articles/510202/](https://lwn.net/Articles/510202/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting access to I/O memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to get access to the internal peripherals of
    a CPU or to any other memory mapped device that is connected to the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This time, we'll present an example using an already existing piece of code
    in the kernel sources, so now there is nothing to compile, but we can go directly
    to the root directory of ESPRESSObin's kernel sources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good and really simple example about how to do a memory remap is reported
    in the `linux/drivers/reset/reset-sunxi.c` file in the `sunxi_reset_init()` function as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: By using the `of_address_to_resource()` function, we ask the device tree that
    is the memory mapping of our device and we get the result in the `res` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we request the memory mapping size by using the `resource_size()` function
    and then we call the `request_mem_region()` function in order to ask the kernel
    to get exclusive access to the memory addresses between `res.start` and `res.start+size-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If nobody has already issued this same request, the region is marked as used
    by us with the labeling name stored into `np->name`.
  prefs: []
  type: TYPE_NORMAL
- en: The name and memory region is now reserved for us and all this information can
    be retrieved from the`/proc/iomem` file, as will be shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all the preceding preliminary operations, we can finally call the `ioremap()` function
    that actually does the remap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In `data->membase`, is stored the virtual address we can use to get access to
    our device's registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The prototype of `ioremap()` and its counterpart `iounmap()`, which must be
    used when we have finished using this mapping, is defined in the header file, `linux/include/asm-generic/io.h`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that in `linux/include/asm-generic/io.h`, it is just reported that the
    implementation for systems that do not have an MMU due to the fact that each platform
    has its own implementation under the `linux/arch` directory.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To have an idea about how to use `ioremap()`, we can compare the preceding
    code and the **Universal Asynchronous Receiver/Transmitter** (**UART**) driver
    of our ESPRESSObin within the `linux/drivers/tty/serial/mvebu-uart.c` file, shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is part of the `mvebu_uart_probe()` function, which, at
    some time, calls the `devm_ioremap_resource()` function, which performs similar
    steps as the combined execution of functions presented in *step 1*, *step 2*,
    and *step 3*, that is, the functions `of_address_to_resource()`, `request_mem_region()`,
    and `ioremap()` at once: it takes information from the device tree and does a
    memory remap, reserving those registers for its exclusive usage only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This registration (done previously in *step 2*) can be checked in the procfs
    file `/proc/iomem` as follows, where we see that the memory area `d0012000-d00121ff`
    is assigned to `serial@12000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As already stated several times in this book, when we're in the kernel, nobody
    can really stop us from doing something; therefore, when I talk about *exclusive
    usage* of a memory area, the reader should imagine that this is true, if all programmers
    voluntarily refrain from issuing memory accesses on that area if a previous access
    request (like the ones issued previously) to an I/O memory area had failed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about memory mapping, a good starting point is [https://linux-kernel-labs.github.io/master/labs/memory_mapping.html](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html)[.](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spending time in the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at how we can delay the execution after
    some time in the future by using busy loops or more complex functions that may
    involve a suspension.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even in this recipe, we can use a kernel module to see how a test code works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `time.c` file, we can find a simple example exemplifying how the preceding
    functions work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first step, we declare a utility function to get the execution time
    in nanoseconds, of a line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is an easy trick to define a macro that executes a line of code while taking
    its execution time by using the `ktime_get_real_ns()` function, which returns
    the current system time in nanoseconds.
  prefs: []
  type: TYPE_NORMAL
- en: For further information regarding `ktime_get_real_ns()` and related functions,
    you can take a look at [https://www.kernel.org/doc/html/latest/core-api/timekeeping.html](https://www.kernel.org/doc/html/latest/core-api/timekeeping.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the module''s `init()` function, we can use our macro and then call
    all the preceding delaying functions as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can test our code by compiling it and then inserting it into the ESPRESSObin
    kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following kernel messages should be printed out by using the macro defined
    in *step 1*. This macro simply takes the execution time of the delay function
    passed into the `code` parameter by using the `ktime_get_real_ns()` function, which
    is useful for getting the current kernel time in nanoseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can safely ignore the following error message as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insmod: ERROR: could not insert module time.ko: Invalid parameters`'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the prompt will take 10 seconds before returning, due to the last
    call of the `ssleep(10)` function, which is not interruptible; so, even if we
    press *Ctrl* + *C*, we cannot stop the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the preceding output (from *step 2*), we notice that `ndelay()` is
    not as reliable as expected for a small amount of time, while `udelay()` and `mdelay()`
    work better. Regarding `*sleep()` functions, instead, we have to say that they are
    heavily affected by the machine load due to the fact they can sleep.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For further information about delaying functions, a good starting point is provided
    in the kernel documentation within the `linux/Documentation/timers/timers-howto.txt` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
