- en: Peripherals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication with peripheral devices is an essential part of any embedded application.
    Applications need to check the availability and status and send data to and receive
    data from a variety of devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each target platform is different and many ways of connecting peripheral devices
    to the computing unit exist. There are, however, several hardware and software
    interfaces that have become industry standard for communication with peripheral
    devices. In this chapter, we will learn how to work with peripheral devices connected
    directly to processor pins or over serial interfaces. This chapter covers the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling devices connected via GPIO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring pulse-width modulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ioctl to access a real-time clock in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using libgpiod to control GPIO pins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling I2C peripheral devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes in this chapter involve interaction with real hardware and are intended
    to be run on a real Raspberry Pi board.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling devices connected via GPIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**General Purpose Input-Output** (GPIO) is the simplest way of connecting peripheral
    devices to the CPU. Every processor usually has some number of pins reserved for
    general purposes. These pins can be electrically connected directly to the pins
    of a peripheral device. An embedded application can control the device by changing
    the signal level of the pins configured for output or by reading the signal level
    of the input pins.'
  prefs: []
  type: TYPE_NORMAL
- en: The interpretation of the signal levels does not follow any protocol and is
    determined by the peripheral device. Developers need to consult the device datasheet
    to be able to program the communication properly.
  prefs: []
  type: TYPE_NORMAL
- en: This type of communication is usually done on the kernel side using a dedicated
    device driver. This is, however, not always a requirement. In this recipe, we
    will learn how to use the GPIO interface on a Raspberry Pi board from a user-space
    application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a simple application that controls a **Light Emitting
    Diode** (LED) connected to a general-purpose pin on a Raspberry Pi board:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `gpio`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `gpio.cpp` file in the `gpio` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following code snippet into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Connect an LED to your Raspberry Pi board using the instructions from the *WiringPI
    example* section at [http://wiringpi.com/examples/blink/](http://wiringpi.com/examples/blink/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up an SSH connection to your Raspberry Pi board. Follow the instructions
    from the *Raspberry Pi documentation* section at [https://www.raspberrypi.org/documentation/remote-access/ssh/](https://www.raspberrypi.org/documentation/remote-access/ssh/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `gpio` folder to the Raspberry Pi board over SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to the board over SSH, then build and run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Your application should run and you should be able to observe the LED blinking.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raspberry Pi boards have 40 pins (26 in the first models) that can be programmed
    using a **Memory-Mapped Input-Output** (**MMIO**) mechanism. MMIO allows developers
    to query or set the state of pins by reading or writing specific addresses in
    the physical memory of the system.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Using specialized memory* recipe in [Chapter 6](ce2d6580-cf8f-42ca-bd14-de8d3265d07e.xhtml),
    *Memory Management*, we learned how to access MMIO registers. In this recipe,
    we are going to offload the MMIO address's manipulations to the specialized library,
    `wiringPi`. It hides all the complexities of memory mapping and finding proper
    offsets under the hood, exposing a clean API instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This library is pre-installed on Raspberry Pi boards, so to simplify the build
    process, we are going to build the code directly on the board instead of using
    cross-compilation. Unlike other recipes, our build rules do not mention a cross
    compiler—we are going to use the native ARM compiler on the board. We only add
    a dependency to the `wiringPi` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code of this example is a modification of the `wiringPi` example for blinking
    an LED. Firstly, we initialize the `wiringPi` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we enter the endless loop. On each iteration, we set the pin to the `HIGH`
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `500 ms` delay, we set the same pit to the `LOW` state and add another
    delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We configured our program to use pin `0`, which corresponds to `GPIO.0` or
    pin `17` of the `BCM2835` chip of Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If an LED is connected to this pin, it will blink, turning on for 0.5 seconds
    and then off for another 0.5 seconds. By tweaking the delays in the loop, you
    can change the blinking pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Since the program enters an endless loop, we can terminate it at any time by
    pressing *Ctrl* + *C* in the SSH console; otherwise, it will run forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the application, we only see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f3a257e-977a-4e63-97e3-c39452e84ce4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We log when we turn the LED `on` or `off`, but to check that the program actually
    works, we need to look at the LED connected to the pin. If we follow the wiring
    instructions, we can see how it works. While the program is running, the LED on
    the boards blinks synchronously with the program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72b7b80d-860c-48ec-ba6c-bb4aaee983d5.png)'
  prefs: []
  type: TYPE_IMG
- en: We are able to control simple devices connected directly to the CPU pins without
    writing complicated device drivers.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring pulse-width modulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Digital pins can only be in one of two states: either `HIGH` or `LOW`. An LED
    connected to a digital pin can also only be in one of two states: `on` or `off`,
    correspondingly. But is there a way to control the brightness of this LED? Yes,
    we can use a method called **Pulse-width Modulation **(**PWM**).'
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind PWM is simple. We limit the amount of power delivered by the
    electrical signal by turning it on or off periodically. This makes the signal
    pulse with some frequency and the amount of power is proportional to the width
    of the pulse—the time when the signal was `HIGH`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we turn a pin to `HIGH` for 10 microseconds and then `LOW` for
    another 90 microseconds in a loop, a device connected to that pin receives 10%
    of the power that would be delivered if the pin were always `HIGH`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use PWM to control the brightness of an
    LED connected to a digital GPIO pin on the Raspberry Pi board.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a simple application that gradually changes the brightness
    of an LED connected to a general-purpose pin on a Raspberry Pi board:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `pwm`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `pwm.cpp` file in the `pwm` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s put in the required `include` functions and define a function called `Blink`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Connect an LED to your Raspberry Pi board using the instructions from the *WiringPI
    example* section at [http://wiringpi.com/examples/blink/](http://wiringpi.com/examples/blink/.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up an SSH connection to your Raspberry Pi board. Follow instructions from
    the *Raspberry PI documentation* section at [https://www.raspberrypi.org/documentation/remote-access/ssh/](https://www.raspberrypi.org/documentation/remote-access/ssh/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `pwm` folder to the Raspberry Pi board over SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to the board over SSH, then build and run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Your application should now run and you can observe the LED blinking.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe reuses the code to blink an LED and the schematics from the preceding
    recipe. We moved this code from the `main` function to a new function, `Blink`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Blink` function accepts two parameters—`duration` and `percent_on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`duration` determines the total width of the pulse in microseconds. `percent_on`
    defines a ratio of the time when the signal is `HIGH` to the total duration of
    the pulse.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is straightforward. When `Blink` is invoked, it turns the
    pin to `HIGH` and waits for the amount of time proportional to `percent_on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, it turns the pin to `LOW` and waits for the remaining time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Blink` is the main building block for implementing PWM. We can control the
    brightness by changing `percent_on` from `0` to `100`, and if we pick `duration`
    short enough, we will not see any flickering.'
  prefs: []
  type: TYPE_NORMAL
- en: A duration that is equal to or shorter than the refresh rate of a TV or monitor
    is good enough. For 60 Hz, the duration is 16.6 milliseconds. We use 10 milliseconds
    for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we wrap everything up in another endless loop, but now it has another
    parameter, `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is updated with each iteration and bounces between `0` and `100`. The `delta` variable
    defines the direction of change—either a decrease or increase—as well as the amount
    of change, which is always `1` in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When the count reaches `101` or `0`, the direction changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On each iteration, we invoke `Blink`, passing `10ms` as a pulse and `count`
    as a ratio that defines the amount of time when LED is on, hence its brightness
    (as shown in the following image):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/98a8f41e-0940-43fa-82fe-09b2c45f7fb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Due to the high frequency of updates, we cannot tell when the LED turns from
    on to off.
  prefs: []
  type: TYPE_NORMAL
- en: When we wire everything up and run the program, we can see that the LED gets
    brighter or dimmer smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PWM is widely used in embedded systems for a variety of purposes. It is a common
    mechanism for servo control and voltage regulation. Use the *Pulse-width modulation*
    Wikipedia page, available at [https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation),
    as a starting point to learn more about this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Using ioctl to access a real-time clock in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our preceding recipes, we used MMIO to access peripheral devices from user-space
    Linux applications. This interface, however, is not the recommended way of communication
    between user-space applications and device drivers.
  prefs: []
  type: TYPE_NORMAL
- en: In Unix-like operating systems such as Linux, most of the peripheral devices
    can be accessed in the same way as regular files using so-called device files.
    When an application opens a device file, it can read from it, fetching data from
    the corresponding device, or write to it, sending data to the device.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, device drivers cannot work with unstructured data streams. They
    expect data exchange organized in the form of requests and responses, where each
    request and response has a specific and fixed format.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of communication is covered by the `ioctl` system call. It accepts
    a device-dependant request code as its parameter. It may also contain other parameters
    that encode the request data or provide storage for the output data. These parameters
    are specific to a particular device and request code.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use `ioctl` in user-space applications
    for data exchange with device drivers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an application that reads the current time from the **Real-Time
    Clock** (**RTC**) connected to the Raspberry Pi board:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `rtc`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `rtc.cpp` file in the `rtc` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s put the required `include` functions into the `rtc.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define a class called `Rtc` that encapsulates the communication to
    the real-clock device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the class is defined, we put a simple usage example into the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Build your application and copy the resulting `rtc` binary to our Raspberry
    Pi emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are implementing an application that talks directly to the hardware RTC connected
    to the system. There is a difference between the system clock and the RTC. The
    system clock is active and maintained only when the system is running. When the
    system is powered off or goes into sleep mode, the system clock becomes invalid.
    The RTC is active even when the system is off. It maintains the actual time that
    is used to configure the system clock when the system is up. Moreover, it can
    be programmed to wake up the system at a specific time when in sleep mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We encapsulate all communication with the RTC driver into a class called `Rtc`.
    All data exchange with the driver goes through the `/dev/rtc` special device file. In
    the `Rtc` class constructor, we open the device file and store the resulting file
    descriptor in the `fd` instance variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, a destructor is used to close the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the device is closed in the destructor as soon as the `Rtc` instance
    is destroyed, we can use the **Resource Acquisition is Initialization **(RAII)
    idiom to throw exceptions when something goes wrong without leaking the file descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our class defines only one member function—`GetTime`. It is a wrapper on top
    of the `RTC_RD_TIME` `ioctl` call. This call expects a `rtc_time` structure to
    return the current time. It is almost identical to the `tm` structure that we
    are going to use to convert the time returned by the RTC driver into a POSIX timestamp
    format, so we place both of them into the same memory location as a `union` data
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This way, we avoid copying identical fields from one structure to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the data structure is ready, we invoke the `ioctl` call, passing the `RTC_RD_TIME`
    constant as a request ID and a pointer to our structure as an address to store
    data to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once successful, `ioctl` returns `0`. In this case, we convert the resulting
    data structure into the `time_t` POSIX timestamp format using the `mktime` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, we create an instance of the `Rtc` class and then invoke
    the `GetTime` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the POSIX timestamp represents the number of seconds since January 1,
    1970, we convert it into a human-friendly representation using the `ctime` function
    and output the result to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our application, we can see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7640217-c2f3-4c53-b5b8-c7901c07760f.png)'
  prefs: []
  type: TYPE_IMG
- en: We were able to read the current time directly from the hardware clock using
    `ioctl`. The `ioctl` API is widely used in Linux embedded applications to communicate
    with devices.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our simple example, we learned how to use only one `ioctl` request. RTC devices
    support many other requests that can be used to set the alarm, update the time,
    and control RTC interrupts. More details can be found in the *RTC ioctl documentation* section
    available at [https://linux.die.net/man/4/rtc](https://linux.die.net/man/4/rtc).
  prefs: []
  type: TYPE_NORMAL
- en: Using libgpiod to control GPIO pins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we learned how to access the RTC using the `ioctl`
    API. Can we use it to control GPIO pins as well? The answer is yes. Recently,
    a generic GPIO driver was added to Linux, along with a user-space library, `libgpiod`,
    to simplify access to devices connected to GPIO by adding a convenience layer
    on top of the generic `ioctl` API. This interface allows embedded developers to
    manage their devices on any Linux-based platform without writing device drivers.
    Additionally, it provides bindings for C++ out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, the `wiringPi` library has been deprecated, despite still being
    widely used because of its easy-to-use interface.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `libgpiod` C++ bindings. We are
    going to use the same LED blinking example to see the differences and similarities
    in the `wiringPi` and `libgpiod` approaches.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an application that blinks an LED connected to the Raspberry
    Pi board using a new `libgpiod` API:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `gpiod`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `gpiod.cpp` file in the `gpiod` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the code for the application into the `rtc.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Connect an LED to your Raspberry Pi board using the instructions from the *WiringPI
    example* section at [http://wiringpi.com/examples/blink/](http://wiringpi.com/examples/blink/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up an SSH connection to your Raspberry Pi board. Follow the instructions
    from the *Raspberry PI documentation *section at [https://www.raspberrypi.org/documentation/remote-access/](https://www.raspberrypi.org/documentation/remote-access/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `gpio` folder to the Raspberry Pi board over SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the `libgpiod-dev` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to the board over SSH, then build and run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Your application should run and you can observe the LED blinking.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application uses a new, recommended way of accessing GPIO devices in Linux.
    Since it was added only recently, it requires the latest version of the Raspbian
    distributive, `buster`, to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: The `gpiod` library itself provides high-level wrappers to communicate with
    GPIO kernel modules using the `ioctl` API. This interface is designed for C languages
    and on top of it, there is an additional layer for C++ bindings. This layer lives
    in the `libgpiocxx` library, which is part of the `libgpiod2` package along with
    the `libgpiod` library for C.
  prefs: []
  type: TYPE_NORMAL
- en: The library uses exceptions to report errors, so the code is simple and not
    cluttered with checks of return codes. Also, we do not need to bother with releasing
    the capture's resources; it is done automatically via C++ RAII mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application starts, it creates an instance of the class chip, which
    works as an entry point for GPIO communication. Its constructor accepts the name
    of the device to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create an instance of the line, which represents a particular GPIO
    pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that unlike the `wiringPi` implementation, we pass a `17` pin number because
    `libgpiod` uses native Broadcom SOC Channel (**BCM**) pin numbering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After the line instance is created, we need to configure the desired access
    mode. We construct an instance of the `line_request` structure, passing the name
    of a consumer (`"test"`) and a constant indicating that the pin is configured
    for output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can change the pin state using the `set_value` method. As in
    the `wiringPi` example, we set the pin to `1` or `HIGH` for `500ms`, then back
    to `0` or `LOW` for another `500ms` in a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The output of this program is identical to the output of the program from the *Controlling
    devices connected via GPIO* recipe. The code may look more complex, but the new
    API is more generic and can work on any Linux board, not just Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about `libgpiod` and the GPIO interface, in general, can be
    found at [https://github.com/brgl/libgpiod](https://github.com/brgl/libgpiod).
  prefs: []
  type: TYPE_NORMAL
- en: Controlling I2C peripheral devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting devices over GPIO has one downside. A processor has a limited and
    relatively small number of pins available for GPIO. When you need to work with
    numerous devices or devices that provide complex functionality, you can run out
    of pins easily.
  prefs: []
  type: TYPE_NORMAL
- en: A solution is using one of the standard serial buses to connect peripheral devices.
    One of them is **Inter-Integrated Circuit** (**I2C**). This is widely used to
    connect various low-speed devices because of its simplicity and because a device
    can be connected with only two wires on the host controller.
  prefs: []
  type: TYPE_NORMAL
- en: The bus is well supported both on hardware and software levels. By using I2C
    peripherals, developers can control them from user-space applications without
    writing complex device drivers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to work with an I2C device on a Raspberry
    Pi board. We will use a popular and inexpensive LCD display. It has 16 pins, which
    makes it difficult to connect to the Raspberry board directly. However, with an
    I2C backpack, it only needs four wires to connect.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create an application that displays text on a 1602 LCD display attached
    to our Raspberry Pi board:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `~/test` working directory, create a subdirectory called `i2c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create an `i2c.cpp` file in the `i2c` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following `include` directives and constants'' definitions into the `i2c.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define a new class, `Lcd`, which encapsulates the display control logic.
    We start with the data fields and the `public` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'They are followed by the `private` methods. Low-level helper methods go first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the helper functions are defined, we add higher-level methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `main` function that uses the `Lcd` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CMakeLists.txt` file containing the build rules for our program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect the pins on the `i2c` backpack of your 1602LCD display to the pins
    on your Raspberry Pi board according to this table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Raspberry Pi pin name** | **Physical pin number** | **1602 I2C pin** |'
  prefs: []
  type: TYPE_TB
- en: '| GND  | 6 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| +5v | 2 | VSS |'
  prefs: []
  type: TYPE_TB
- en: '| SDA.1 | 3 | SDA |'
  prefs: []
  type: TYPE_TB
- en: '| SCL.1 | 5 | SCL |'
  prefs: []
  type: TYPE_TB
- en: Set up an SSH connection to your Raspberry Pi board. Follow the instructions
    from the *Raspberry PI documentation* section at [https://www.raspberrypi.org/documentation/remote-access/ssh/](https://www.raspberrypi.org/documentation/remote-access/ssh/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to the Raspberry board and run the `raspi-config` tool to enable `i2c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the menu, select Interfacing Options | I2C | Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reboot the board to activate the new settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `i2c` folder to the Raspberry Pi board over SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in to the board over SSH, then build and run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Your application should run and you can observe the LED blinking.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, our peripheral device—an LCD screen—is connected to the board
    over the I2C bus. It is a form of a serial interface, so the connection only requires
    four physical wires. An LCD screen, however, can do much more than a simple LED.
    This means that the communication protocol used to control it is also more complex.
  prefs: []
  type: TYPE_NORMAL
- en: We will use only a fraction of the functionality provided by the 1602 LCD screen.
    The communication logic is loosely based on the `LiquidCrystal_I2C` library for
    Arduino, adapted for Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define an `Lcd` class that hides all the complexities of I2C communication
    and the specifics of the 1602 control protocol in its private methods. Besides
    a constructor and a destructor, it exposes only two public methods: `Clear` and
    `Display`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, we communicate to I2C devices via device files. To start working
    with a device, we need to open a device file corresponding to an I2C controller
    using the regular open call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There may be multiple devices attached to the same bus. We need to select the
    device we what to communicate to. We do this with an `ioctl` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the I2C communication is configured and we can issue I2C commands
    by writing data to the open file descriptor. The commands, however, are specific
    for each peripheral device. So, after generic I2C initialization, we need to proceed
    with the LCD initialization.
  prefs: []
  type: TYPE_NORMAL
- en: We put all the LCD-specific initialization into the `Init` private function. It
    configures the operation modes, the number of rows, and the size of the displayed
    characters. To do this, we define the helper methods, data types, and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic helper function is `SendToI2C`. It is a simple method that writes
    a byte of data into the file descriptor configured for I2C communication and throws
    an exception in the case of an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'On top of `SendToI2C`, we define another helper method, `SendToLcd`. It sends
    a sequence of bytes to I2C, forming a command that the LCD controller can interpret.
    This involves setting different flags and taking care of delays required between
    chunks of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The LCD is working in 4-bit mode, which means that each byte sent to the display
    requires two commands. We define the `Write` method to do it for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define all possible commands supported by the device and put them
    into the `Function` enum class. A `Call` helper function can be used to invoke
    the functions in a type-safe way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use these helper functions to define public methods to clear the
    screen and display a string.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the complexity of the communication protocol is encapsulated in the
    `Lcd` class, our `main` function is relatively simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'It creates an instance of the class, passing in a device filename and a device
    address that we are going to use. By default, a 1620 LCD with an I2C backpack
    has a `0x27` address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the `Lcd` class performs all initialization and as soon
    as the instance is created, we can invoke the `Display` function. Instead of hardcoding
    the string to display, we use data passed by a user through the command-line parameters.
    The first parameter is displayed in the first row. If the second parameter is
    provided, it is also displayed in the second row of the display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Our program is ready and we can copy it over to the Raspberry Pi board and build
    it there. But before running it, we need to wire the display to the board and
    enable I2C support.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `raspi-config` tool to enable I2C. We need to do it only once, but
    a reboot is required unless I2C has not been previously enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ea36835-ced3-40ef-a8c8-70b0c08c2f71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can run our application. It will display the following output on
    the LCD display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91251e94-ad99-47c6-b5c3-e5866ca97b1e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we know how to control devices connected via an I2C bus from Linux user-space
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about working with I2C devices can be found at the *Interfacing
    with I2C devices *page, available at [https://elinux.org/Interfacing_with_I2C_Devices](https://elinux.org/Interfacing_with_I2C_Devices.).
  prefs: []
  type: TYPE_NORMAL
