- en: Handling Routing for Our REST Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss routing of the application. For creating an
    API, the first step is to define routes. So, to define routes, we need to figure
    out available constructs in Go. We begin with the basic internal routing mechanism
    in Go. Then, we see how to create a custom Multiplexer. Since ServeMux's capabilities
    are very limited, we will explore a few other frameworks built to serve this purpose.
    This chapter also includes creating routes using third-party libraries such as `httprouter`
    and `Gorilla Mux`. We are going to build a URL-shortening API throughout this
    book. In this chapter, we define routes for the API. Then, we discuss topics like
    SQL injection of an URL. A web framework allows the developer to create a route
    as the first step and then attach handlers to it. Those handlers hold the business
    logic of the application. The crux of this chapter is teaching you how to create
    HTTP routers in Go using `Gorilla Mux`. We also discuss how URL-shortening service
    functions and try to design a logical implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic web server in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the net/http package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ServeMux, a basic router in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding httprouter, a router package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Gorilla Mux, a powerful HTTP router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing URL shortening service design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download the code for this chapter from  [https://github.com/narenaryan/gorestful/tree/master/chapter2](https://github.com/narenaryan/gorestful/tree/master/chapter2).
    Feel free to add the comments and pull requests. Clone the code and use the code
    samples in the `chapter2` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Go's net/http package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go''s `net/http` package deals with HTTP client and server implementations.
    Here, we are mainly interested in the server implementation. Let us create a small
    Go program called `basicHandler.go` that defines the route and a function handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a route called  `/hello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a handler called `MyServer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever the request comes on the route (`/hello`), the handler function will
    be executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `hello, world` to the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the server on port `8000`. `ListenAndServe` returns **`error` **if something
    goes wrong. So log it using `log.Fatal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `http` package has a function called **`HandleFunc`,** using which we can
    map an URL to a function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, **`w`** is a response writer. A `ResponseWriter` interface is used by
    an HTTP handler to construct an HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`req` is a request object, which deals with all the properties and methods
    of an HTTP request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the log function to debug potential errors. The `ListenAndServe` function
    returns an error if there are any.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can run the preceding code as a standalone program. Name the preceding program `basicHandler.go`. Store
    it anywhere you wish to, then run it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now fire up a shell or browser to see the server in action. Here, I use the
    CURL request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Go has a different concept for handling request and response. We used the `io`
    library to write to the response. For web development, we can use a template to
    automatically fill in the details. Go's internal URL handlers use a ServeMuxmultiplexer.
  prefs: []
  type: TYPE_NORMAL
- en: ServeMux, a basic router in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ServeMux is an HTTP request multiplexer. The `HandleFunc` we used in the preceding
    section is actually a method of ServeMux. By creating a new ServeMux, we can handle
    multiple routes. Before that, we can also create our own multiplexer. A multiplexer
    just handles the logic of separating routes with a function called `ServeHTTP`.
    So if we create a new struct with the `ServeHTTP` method, it can do the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a route as a key in a dictionary (map), then the handler as its value.
    The router finds the handler from the route and tries to execute the `ServeHTTP`
    function. Let us create a program called `customMux.go` and see this implementation
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are creating a custom struct called **`CustomServeMux`, **which
    is going to take care of our routing. We implemented a function called **`ServeHTTP`**
    in order to capture the request and write a response back to it. The `fmt` package
    is usually used to create strings. **`Fprinf` **composes the string out of supplied
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the main function, we are creating an instance of our **`CustomServeMux` **and
    passing it to the `ListenAndServe` function on `http`.` "math/rand"` is the library
    that takes care of generating random numbers. This basic foundation is going to
    be helpful for us when we discuss adding authentication to our API server.
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us fire a CURL request and see what the response is for various routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, fire up a shell or browser to see the server in action. Here, I use the
    CURL request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Use *Ctrl* + *C* or *Cmd* + *C* to stop your Go server. If you are running it
    as a background process, use **`pgrep go`** to find the `processID` and kill it
    using `kill pid`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple handlers using ServeMux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding custom Mux that we created can be cumbersome when we have different
    endpoints with different functionalities. To add that logic, we need to add many
    `if/else` conditions to manually check the URL route. We can instantiate a new
    `ServeMux` and define many handlers like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet shows how to create a ServerMux and attach multiple handlers
    to it. `randomFloat` and `randomInt` are the two routes we created for returning
    a random `float` and random `int`, respectively. Now we can pass this to the `ListenAndServe`
    function. `Intn(100)` returns a random integer number from the range 0-100\. For
    more details on random functions, visit the Go random package page at [http://golang.org](http://golang.org).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The complete code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can run the program directly using the run command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us fire two CURL commands and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The responses will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Your response may change due to the random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how we can create a URL router with basic Go constructs. Now we are going
    to look at a few popular URL routing frameworks that are widely used by the Go
    community for their API servers.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing httprouter, a lightweight HTTP router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**httprouter,** as the name suggests, routes the HTTP requests to particular
    handlers. Compared to the basic router, it has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows variables in the route paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It matches the REST methods (`GET`, `POST`, `PUT`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No compromising on performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to discuss these qualities in more detail in the following section.
    Before that, there are a few noteworthy points that make httprouter an even better
    URL router:'
  prefs: []
  type: TYPE_NORMAL
- en: httprouter plays well with the inbuilt `http.Handler`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: httprouter explicitly says that a request can only match to one route or none
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router's design encourages building sensible, hierarchical RESTful APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can build efficient static file servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install httprouter, we just need to run the `get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now we have `httprouter`. We can refer to the library in our source code
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The basic usage of httprouter can be understood through an example. In this
    example, let us create a small API to get information about files and programs
    installed from the server. Before jumping straight into the program, you should
    know how to execute system commands on Go. There is a package called `os/exec`. It
    allows us to execute system commands and get the output back to the program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it can be accessed in the code as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**`exec.Command`** is the function that takes a command and an additional arguments
    array. Additional arguments are the options or input for the command. It can then
    be executed in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the command instantly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start and wait for it to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can collect the output of the command by attaching `Stdout` to a custom
    string. Get that string and send it back to the client. The code makes more sense
    here. Let us write a Go program to create a REST service that does two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the Go version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gets the file contents of a given file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This program uses `Hhttprouter` to create the service. Let us name it as `execService.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Program explanation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The preceding program is trying to implement a REST service using `httprouter`**.**
    We are defining two routes here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/api/v1/go-version`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/v1/show-file/:name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:name` here is the path parameter. It indicates the API that shows the
    file named xyz. The basic Go router cannot handle these parameters, by using `httprouter`,
    we can also match the REST methods. In the program, we matched `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a step-by-step process, the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: Imported the `httprouter` and other necessary Go packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created a new router using the `New()` method of `httprouter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router has methods like `GET`, `POST`, `DELETE`, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GET` method takes two arguments, `URL path expression` and `Handler function`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This router can be passed to the `ListenAndServe` function of http
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, coming to the handlers, they look similar to the ones belonging to ServeMux,
    but a third argument called **`httprouter.Params`** holds information about all
    parameters that are supplied with a `GET` request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined the path parameter (a variable in the URL path) called `name` and
    used it in our program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getCommandOutput` function takes commands and arguments and returns output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first API calls the Go version and returns the output to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second API performs a `cat` command of the file and returns it to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you observe the code, I used `/usr/local/bin/go` as the Go executable location
    because it is the Go compiler location on my MacBook. While executing `exec.Command`,
    you should give the absolute path of the executable. So if you are working on
    an Ubuntu machine or Windows, use the path to your executable. On Linux machines,
    you can easily find that out by using the `$ which go` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create two new files in the same directory. These files will be served
    by our file server program. You can create any custom files in this directory
    for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Latin.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`Greek.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the program with this command. This time, instead of firing a CURL
    command, let us use the browser as our output for `GET.` Windows users may not
    have CURL as the firsthand application. They can use API testing software like
    the postman client while developing the REST API. Take a look at the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the first `GET` request looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The second `GET` request requesting `Greek.txt` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will see the file output in Greek as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Building the simple static file server in minutes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, as part of the API, we should serve static files. The other application
    of httprouter is building scalable file servers. It means that we can build a
    Content Delivery Platform of our own. Some of the clients need static files from
    the server. Traditionally, we use Apache2 or Nginx for that purpose. But, from
    within the Go server, in order to serve the static files, we need to route them
    through a universal route like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'See the following code snippet for our implementation. The idea is to use the
    `http.Dir` method to load the filesystem, and then use the **`ServeFiles` **function
    of the `httprouter` instance. It should serve all the files in the given public
    directory. Usually, static files are kept in the folder **`/var/public/www` **on
    a Linux machine. Since I am using OS X, I create a folder called `static` in my
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I copy the `Latin.txt` and `Greek.txt` files,which we created for the
    previous example, to the preceding static directory. After doing this, let us
    write the program for the file server. You will be amazed at the simplicity of
    `httprouter`. Create a program called `fileserver.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the server and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us open another terminal and fire this CURL request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output will be a static file content server from our file server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Introducing Gorilla Mux, a powerful HTTP router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mux stands for the multiplexer. Similarly, Gorilla Mux is a multiplexer designed
    to multiplex HTTP routes (URLs) to different handlers. Handlers are the functions
    which can handle the given requests. Gorilla Mux is a wonderful package for writing
    beautiful routes for our web applications and API servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gorilla Mux provides tons of options to control how routing is done to your
    web application. It allows a lot of features. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Path-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sub-domain based matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse URL generation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing the Mux package is fairly simple. You need to run this command in
    the Terminal (Mac and Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get any errors saying `package github.com/gorilla/mux: cannot download,
    $GOPATH not set. For more details see--go help gopath`, set the `$GOPATH` environment
    variable using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed in the previous chapter, this says that all the packages and
    programs go into this directory. It has three folders: `bin`, **`pkg`,** and `src`.
    Now, add `GOPATH` to the `PATH` variable, to use the installed bin files as system
    utilities that have no `./executable` style. Refer to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'These settings stay until you turn off your machine. So, to make it a permanent
    change, add the preceding lines to your bash profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to go. Assuming Gorilla Mux is installed, proceed to the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of Gorilla Mux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gorilla Mux allows us to create a new router, similar to httprouter. But the
    attachment of the handler function to a given URL route is different in both.
    If we observe, Mux's way of attaching a handler is similar to that of basic ServeMux.
    Unlike httprouter,it modifies the request object instead of using an additional
    argument to pass the URL parameters to the handler function. We can access parameters
    using the `Vars` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am going to take an example from the Gorilla Mux homepage to explain how
    useful it is. Create a file called `muxRouter.go` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'By running the CURL command this way, we can get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Mux parses the variables in the path. All the variables that are parsed are
    available calling the `Vars` function. Don''t get caught up in the custom server
    details of the preceding program. Just observe the Mux code. We attached a handler
    to the URL. We have written the parsed variables back to the HTTP response. This
    line is crucial. Here, an `id` has a regular expression saying that `id` is a
    number (0–9) with one or more digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let us call it a route. With this flexibility of pattern matching, we can design
    the RESTful API very comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: Use `http.StatusOK` to write to the header of a response to announce that an
    API request is successful. Similarly, http has many status codes for various types
    of HTTP request. Use the appropriate one to convey the right message. For example,
    404 - Not found, 500 - Server error, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse mapping URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simple words, a reverse-mapping URL is just getting the URL for an API resource.
    Reverse-mapping is quite useful when we need to share links to our web application
    or API. But in order to create a URL from the data, we should associate a `Name`
    with the Mux route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we have data, we can form an URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Gorilla Mux provides a lot of flexibility in creating custom routes. It also
    allows method chaining to add properties to a created route.
  prefs: []
  type: TYPE_NORMAL
- en: Custom paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can define the preceding route in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the path on the router:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, define the handler on the router:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that the method chained here is `HandlerFunc` and not `HandleFunc`,
    as shown in the preceding code. We can create a top-level path and add subpaths
    to different handlers easily in Mux using `Subrouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So all the URLs of the form `http://localhost:8000/articles/123/settings` redirect
    to `settingsHandler` and URLs of the form `http://localhost:8000/articles/123/details` redirect
    to the **`detailsHandler`.** This might be useful when we create a namespace for
    grouping particular URL paths.
  prefs: []
  type: TYPE_NORMAL
- en: Path Prefix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Path Prefix** is a wildcard for matching after a defined path. The general
    use case is when we serve files from our static folder and all URLs should be
    served as-is. From the official Mux documentation, we can use this for serving
    static files. This is the Mux version of the static file server that we created
    in the preceding program using `httprouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This can serve all kinds of files in the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Strict Slash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Strict Slash is a parameter on the Mux router by which we can order the router
    to redirect URL routes with trailing slashes to those without them. For example, **`/articles/`**
    can be the original path, but routes coming with `/path` will be redirected to
    the original path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL redirects to the preceding `ArticleHandler` if the `StrictSlash` parameter
    is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Encoded paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can have encoded paths from a few clients. To handle these encoded paths,
    Mux provides a method called **`UseEncodedPath`.** If we call this method on the
    router variable, we can even match the encoded URL route and forward it to the
    given handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This can match the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`%2F` stands for `/` in the un-encoded form. If the method `UseEncodedPath`
    is not used, the router might understand it as `/v1/1/2`.'
  prefs: []
  type: TYPE_NORMAL
- en: Query-based matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Query parameters are those that get passed along with the URL. This is what
    we commonly see in a REST `GET` request. Gorilla Mux can create a route for matching
    a URL with the given query parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us add functionality to our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It limits the query with the preceding URL. The `id` and `category` match with
    the `Queries` list. Empty values are allowed for parameters. `QueryHandler` looks
    like this. You can use `request.URL.Query()` to obtain query parameters in your
    handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Host-based matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we need to allow requests from specific hosts. If the host is matched,
    then the request proceeds to the route handlers. This could be very helpful if
    we have multiple domains and subdomains and match them with the custom routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `Host` method on the router variable, we can regulate from which
    hosts routes can be directed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we set this, all requests coming from the host `aaa.bbb.ccc` of the form 
    `http://aaa.bbb.ccc/111/222/333` will be matched. Similarly, we can regulate HTTP
    schemes (http, https) using `Schemes` and REST methods like (`GET`, `POST`) using
    `Methods` Mux functions. The program `queryParameters.go` explains how to use
    query parameters in the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us fire a CURL request in this format in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to escape special characters in the shell. If it is in the browser,
    there is no problem escaping. The output is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The **`r.URL.Query()` **function returns a map with all the parameter and value
    pairs. They are basically strings, and in order to use them in our program logic
    we need to convert the number strings to integers. We can use Go's `strconv` package
    to convert a string to an integer, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Its pattern matching features and simplicity push Gorilla Mux as a popular choice
    for an HTTP router in projects. Many successful projects worldwide are already
    using Mux for their routing needs.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injections in URLs and ways to avoid them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL injection is the process of attacking a database with malicious scripts.
    If we are not careful while writing secure URL routes, there may be an opportunity
    for SQL injection. These attacks usually happen for the `POST`, `PUT`, and `DELETE`
    HTTP verbs. For example, if we are allowing the client to pass variables to the
    server, then there is a chance for an attacker to append a string to those variables.
    If we are inserting those users sending parameters directly into an SQL query,
    then it could be injectable. The right way to talk to DB is to allow driver functions
    to check the parameters before inserting the string and executing it in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we are trying to get information about an article by id and
    category. We are executing an SQL query. But since we are appending the values
    directly, we may include malicious SQL statements like (`--`) comments and (`ORDER
    BY n`) range clauses in the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This will leak information about columns the table has. We can change the number
    and see the breaking point where we get an error message from the database saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see more about this in our upcoming chapters, where we build full-fledged
    REST services with other methods, like `POST`, `PUT`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how to avoid these injections. There are a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the user level permissions to various tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While using URL parameters, carefully observe the pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the **`HTMLEscapeString` **function from Go's **`text/template` **package
    to escape special characters in the API parameters, like `body` and `path `
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a driver program instead of executing raw SQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop database debug messages getting relayed back to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use security tools like `sqlmap` to find out vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic API layout for URL shortening services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever wondered how URL shortening services work? They take a very long
    URL and give a shortened, crisp, and memorable URL back to the user. At first
    sight, it looks like magic, but it is a simple math trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a single statement, URL shortening services are built upon two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A string mapping algorithm to map long strings to short strings ( Base 62)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple web server that redirects a short URL to the original URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few obvious advantages of URL shortening:'
  prefs: []
  type: TYPE_NORMAL
- en: Users can remember the URL; easy to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can use the links where there are restrictions on text length; for example,
    Twitter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predictable shortened URL length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf0a2e5f-f392-415a-bbe6-e449a1baa9e2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the hood, these things happen silently in a URL shortening service:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the original URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply Base62 encoding on it. It generates a shortened URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Store that URL in the database. Map it to the original URl (`[shortened_url:
    orignial_url]`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a request comes to the shortened URL, just do an HTTP redirect to the
    original URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will implement the complete logic in upcoming chapters when we integrate
    databases to our API server, but before that, though, we should specify the API
    design documentation. Let us do that. Take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **URL** | **REST Verb** | **Action** | **Success** | Failure |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/v1/new` | `POST` | Create a shortened URL | 200 | 500, 404 |'
  prefs: []
  type: TYPE_TB
- en: '| `/api/v1/:url` | `GET` | Redirect to original URL | 301 | 404 |'
  prefs: []
  type: TYPE_TB
- en: As an exercise, the reader is allowed to implement this from the fundamentals
    we have built thus far. You can use a dummy JSON file instead of a database like
    we did in the first chapter. We will implement this in upcoming chapters, anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first introduced the HTTP router. We tried to build a basic
    application using Go's http package. Then we briefly discussed ServeMux, with
    an example. We saw how to add multiple handlers to multiple routes. Then we introduced
    a lightweight router package called `httprouter`.`httprouter` allows developers
    to create scalable routes, with the option of parsing parameters passed in the
    URL path. We can also serve files over the HTTP using `httprouter`. We built a
    small service to get the Go version and file contents (read-only). That example
    can be extended to any system information.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced the popular Go routing library: `Gorilla Mux`. We discussed
    how it is different from `httprouter` and explored its functionality by implementing
    solid examples. We explained how `Vars` can be used to get path parameters and
    `r.URL.Query`to parse query parameters. Then we discussed SQL injection and how
    it can happen in our applications. We gave a few pointers on how to avoid it.
    We will see some of these measures in upcoming chapters when we build a complete
    REST service, which includes a database. Finally, we laid down the logic for URL
    shortening and created an API design document.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we look at `Middleware` functions, which act as tamperers
    for HTTP requests and responses. That phenomenon will help us modify the API response
    on-the-fly. The next chapter also features `RPC` (Remote Procedure Call).
  prefs: []
  type: TYPE_NORMAL
