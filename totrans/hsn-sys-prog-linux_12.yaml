- en: Signaling - Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the previous chapter, signals are a crucial mechanism for the
    Linux system developer to understand and exploit. The previous chapter covered
    several areas: an introduction, why signaling is useful to the systems developer,
    and, most importantly, how exactly the developer is to handle and thus exploit
    the signaling mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter continues this exploration. Here, we will drill down into the inner
    details of process crash handling with signaling, how to recognize and avoid common
    issues when dealing with signals, working with real-time signals, sending signals,
    and finally, alternative means of performing signal handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the reader will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Gracefully handling process crashes, and collecting valuable diagnostics at
    that point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling common gotchas to do with signaling—errno races, the correct way to
    sleep (yes, you read that right!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling powerful real-time signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending signals to other processes, and performing IPC via signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative signal-handling techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gracefully handling process crashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A bug in the application that caused a crash at runtime? My God, how is this
    possible?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, to the well-heeled software veteran, though, this is not a big
    surprise. Bugs exist; they can hide really well, for years, sometimes; one day,
    they come out and—bang!*—*the process crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, our intention is not to discuss debugging techniques or tools (let''s
    save that for another book perhaps, shall we?); instead, it''s this key point:
    if our application process does crash, can we do something? Certainly: in the
    previous chapter, we have learned in detail how we can trap signals. Why not design
    our application such that we trap the typical fatal signals—the SIGBUS, SIGFPE,
    SIGILL, and SIGSEGV—and, in their signal handler(s), perform useful tasks such
    as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform critical application cleanup—for example, free up memory regions, flush
    and close open files, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write relevant details to a log file (the signal that caused the crash, the
    signal's origin, reason, CPU register values, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inform the end user that, hey, too bad, we crashed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kindly allow us to collect crash details, and we'll do better next time, we
    promise!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This not only gives us valuable information that can help you debug the root
    cause of the crash, but also has the application die gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Detailing information with the SA_SIGINFO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recall the very first member of the `sigaction` structure we saw in
    the previous, [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*,* The sigaction structure* section; it''s a function pointer, and it
    specifies the signal handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding highlighted code highlights the fact that as it''s in a union, the
    signal handler can be either one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sa_handler` : when the `SA_SIGINFO` flag is cleared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sa_sigaction` : when the `SA_SIGINFO` flag is set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, we have used the `sa_handler` style prototype for the signal handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void (*sa_handler)(int);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'It receives just one parameter: the integer value of the signal that occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you set the **`SA_SIGINFO`** flag (while issuing the `sigaction(2)` system
    call of course), the signal handler function prototype now becomes this: `void
    (*sa_sigaction)(int, siginfo_t *, void *);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The integer value of the signal that occurred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to a structure of type `siginfo_t` (a typedef, obviously)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internal-use-only (undocumented) pointer called the **ucontext**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is where the power lies!
  prefs: []
  type: TYPE_NORMAL
- en: The siginfo_t structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use the `SA_SIGINFO` signal flag and a trapped signal occurs, the
    kernel populates a data structure: the `siginfo_t` structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `siginfo_t` structure definition (slightly simplified; there is some #if wrapping
    around the first few members which we need not worry about here) is shown next(It''s
    in the header `/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h` on Ubuntu 
    and `/usr/include/bits/types/siginfo_t.h` on a Fedora box):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three members are integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`si_signo` : signal number—the signal that was delivered to the process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`si_code` : signal origin; an enum; typical values are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SI_QUEUE`      : Sent by `sigqueue(3)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SI_USER`        : Sent by `kill(2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SI_KERNEL`   : Sent by kernel'
  prefs: []
  type: TYPE_NORMAL
- en: '`SI_SIGIO`      : Sent by queued SIGIO'
  prefs: []
  type: TYPE_NORMAL
- en: '`SI_ASYNCIO` : Sent by AIO completion'
  prefs: []
  type: TYPE_NORMAL
- en: '`SI_MESGQ`      : Sent by real time message queue state change'
  prefs: []
  type: TYPE_NORMAL
- en: '`SI_TIMER`      : Sent by timer expiration'
  prefs: []
  type: TYPE_NORMAL
- en: '`si_errno` : (if non-zero) the errnovalue'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s the really interesting part: the fourth member of the structure is
    a union (`_sifields`) of seven structures. We understand that a union implies
    that any one member will be instantiated at runtime: it will be one of the seven
    structures depending on which signal is received!'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the union within the `siginfo_t` structure previously shown;
    the comments within the union quite clearly point out which signal(s) will cause
    which data structure to be instantiated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we see within the union that this structure will be populated
    when the `SIGCHLD` signal is received (that is, when a child process dies, stops,
    or continues):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The information is with respect to the child process; hence, we receive the
    PID and real UID of the process that died (or was stopped or continued, unless
    the `SA_NOCLDWAIT` flag was used, of course). Further, we receive the integer
    bitmask `si_status` telling us how exactly the child died (and so on). Also, some
    audit information, `si_utime` and `si_stime`, the time spent by the child process
    in user and kernel space respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from our detailed discussion in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),* Process
    Creation*, *The wait API - Details* section*,* that we could obtain the child
    termination status information via (any of) the wait APIs. Well, here, we can
    see, it''s simpler: use the `SA_SIGINFO` flag, trap the `SIGCHLD` signal, and,
    in the handler function, just look up the relevant values from the union!'
  prefs: []
  type: TYPE_NORMAL
- en: The man page on `sigaction(2)` describes the `siginfo_t` structure members in
    depth, providing detailed information. Do read through it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting system-level details when a process crashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A wealth of information can be gleaned from the kernel when a process dies
    via the `SIGSEGV`: memory bugs or defects, a common case, as we have discussed
    in the [Chapters 4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml), *Dynamic Memory
    Allocation*, [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory
    Issues*, and  [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging
    Tools for Memory Issues*. (This section also applies to the fatal signals `SIGBUS`, `SIGILL`,
    and `SIGFPE`. Incidentally, `SIGFPE` occurs not just upon a divide-by-zero error
    but in any kind of arithmetic-related exception).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The man page on `sigaction(2)` reveals the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `SEGV_MAPERR` means that the address the process is attempting to access
    (for read, write, or execute) is invalid; there is either no **Page Table Entry** (**PTE**)
    entry available for it, or it refuses to map to any valid address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SEGV_ACCERR` is easy to understand: the attempted access (read, write,
    or execute) cannot be performed, as permission is lacking (for example, attempting
    to write to a read-only memory page).'
  prefs: []
  type: TYPE_NORMAL
- en: Peculiarly, the `SEGV_BNDERR` and `SEGV_PKUERR` macros fail to compile; we shall
    not attempt to use them here.
  prefs: []
  type: TYPE_NORMAL
- en: The glibc library provides the helper routines `psignal(3)` and `psiginfo(3)`;
    passed an informational string, they print it, appending a :  and then the actual
    signal that occurred and information on the cause of the signal being delivered
    and the faulting address (looked up from the siginfo_t structure) respectively.
    We use the `psiginfo(3)` in our example code as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Trapping and extracting information from a crash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will see a test program `ch12/handle_segv.c`,with deliberate bugs,
    to help us understand the use cases possible. All this will result in the `SIGSEGV` signal being
    generated by the OS. How the application developer handles this signal is important:
    we demonstrate how you can use it to gather important details, such as the address
    of the memory location upon whose access the crash took place and the value of
    all registers at that point in time. These details often provide useful clues
    into the root cause of the memory bug.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To help understand how we are constructing this program, run it without any
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen, we can thus perform four kinds of invalid memory accesses:
    in effect, four bug cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Invalid user [u] mode read [r]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid user [u] mode write [w]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid kernel [k] mode read [r]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid kernel [k] mode write [w]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some typedefs and macros we use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: va = virtual address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the key part: the signal handler for the SIGSEGV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is much to observe here:'
  prefs: []
  type: TYPE_NORMAL
- en: We print out the signal number and origin value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We interpret the signal origin value (via the switch-case)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particularly for SIGSEGV, the SEGV_MAPERR, and SEGV_ACCERR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here comes the interesting bit: the following code prints out the faulting
    instruction or address! Not only that, we devise a means by which we can print
    out most of the CPU registers as well via our `dump_regs` function. As mentioned
    earlier, we also make use of the helper routine `psiginfo(3)` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then just keep some dummy stubs for the functionality you probably want
    in a real-world application, when handling a fatal signal such as this (here,
    we do not actually write any code, as it''s of course very application-specific):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, calling `abort(3)` so that the process terminates (as it''s now in
    an undefined state and cannot continue) is one way to finish. However, think for
    a second: if we abort() now, the process dies without the kernel getting a chance
    to generate a core dump. (As mentioned, a core dump is essentially a snapshot
    of the process''s dynamic memory segments at the time of the crash; it''s very
    useful for developers to debug and determine the root cause of the crash). So,
    having the kernel generate a core dump would indeed be useful. How can we arrange
    for this? Its quite simple really: we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reset the `SIGSEGV` signal's handler to the (kernel) default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have the signal (re)raised on the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This code fragment achieves just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As it's a simple case, we just use the simpler `signal(2)` API to revert the
    signal's action to the default. Then, again, we use the library API `raise(3)` to
    raise a given signal on the calling process. (The error-checking code has been
    left out for easy readability.)
  prefs: []
  type: TYPE_NORMAL
- en: Register dumping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned, the `dump_regs` function prints out CPU register values; here
    are a few things to note regarding this:'
  prefs: []
  type: TYPE_NORMAL
- en: It's very CPU-specific (the example case shown as follows works only for the
    x86_64 CPUs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To actually gain access to the CPU registers, we make use of the undocumented
    third parameter to the signal handler function (note: when used with`SA_SIGINFO`),
    the so-called user context pointer. It is possible to interpret it (as we demonstrate
    here), but, of course, as it''s not officially visible via the glibc system call
    (or other) interfaces, you cannot rely on this functionality. Use with caution
    (and a lot of testing).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having said that, let''s check out the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run two of the test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The origin value is `SEGV_MAPERR`: yes, the arbitrary userspace virtual address
    we attempted to read (`0xdeadface`)  is not present (or mapped), hence the segfault!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The faulting address is revealed as the invalid arbitrary userspace virtual
    address we attempted to read (`0xdeadface`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An aside: an important value—the faulting instruction or address—is actually
    the value saved in the x86''s **control register 2** (**CR2**), as can be seen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The TRAP number shows up as 14; trap 14 on an x86[_64] is the Page Fault. The
    reality is: when the process attempted to read the invalid virtual address (`0xdeadface`),
    the bad access resulted in the x86[_64] MMU raising a bad page fault exception,
    which in turn led to the OS fault handler code running and killing the process
    via the SIGSEGV.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CPU registers are dumped as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The curious reader will perhaps wonder what exactly each register is used for.
    This is an area beyond this book's scope; nevertheless, the reader can find useful
    information by seeking out the CPU OEM's **Application Binary Interface** (**ABI**)
    documentation; among many things, it specifies register usage for function calling,
    return, parameter passing, and so on. Check out the *Further reading *section
    on the GitHub repository for more on ABI docs.
  prefs: []
  type: TYPE_NORMAL
- en: The `psiginfo(3)` takes effect as well, printing out the cause of the signal
    and the faulting address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The message `Segmentation fault (core dumped)` tells us that our strategy worked:
    we reset the signal handling for the SIGSEGV to the default one and re-raised
    the signal, causing the OS (kernel) to generate a core dump. The resulting core
    file (generated on a Fedora 28 x86_64 box) shows up as shown below:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a couple of points to mention:'
  prefs: []
  type: TYPE_NORMAL
- en: The detailed analysis and interpretation of a core dump is beyond the scope
    of this book. Using GDB to analyze a core dump is easy; a little googling will
    yield results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name given to the core file varies; modern Fedora distribution set the name
    to be very descriptive (as you can see); in reality, the core filename is controlled
    via a kernel tunable in the proc filesystem. See the man page on `core(5)`for
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We run the kernel-space, invalid write test case for our `handle_segv`program
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, this time, the trap value is 13; on the x86[_64] MMU, that''s the **General
    Protection Fault** (**GPF**). Again, this bad access resulted in the x86[_64]
    MMU raising a GPF exception, which in turn led to the OS fault handler code running
    and killing the process via the SIGSEGV. The trap being a GPF is a clue: we have
    violated a protection rule; recall from [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml),
    *Linux System Architecture*: a process (or thread) running in a higher, more privileged
    level can always access memory at a lower privilege level but not vice versa of
    course. Here, the process at ring three attempted to access memory at ring zero;
    hence, the MMU raised the GPF exception and the OS killed it (via the `SIGSEGV`).'
  prefs: []
  type: TYPE_NORMAL
- en: This time, unfortunately, the CR2 value and thus the faulting address is 0x0
    (in the case where the crash occurs in kernel-space). However, we still get valuable
    details in other registers (the instruction and stack pointer values, and so on,
    as we shall see next).
  prefs: []
  type: TYPE_NORMAL
- en: Finding the crash location in source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The RIP (Instruction Pointer**;** EIP on IA-32, PC on the ARM) is useful: using
    its value and some utilities, we can pretty much pinpoint the location in code
    when the process crashed. How? There are several ways; some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the toolchain utility `objdump` (with the `-d` `-S` switches)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An easier way is to use `gdb(1)` (see the following)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the `addr2line(1)` utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load up `gdb(1)` with the debug version (compiled with the `-g` switch) of
    the program, and then use the list command as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `list * <address>` command literally pinpoints the code that caused the
    crash, reproduced here for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Line 212 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly right.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `addr2line`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addr2line(1)` utility provides a similar feature; again, run it against
    the built-for-debug (compiled with `-g`) version of the binary executable file
    via it''s `-e` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, think about it: our previous `ch12/altstack.c`program can, and will,
    suffer a segmentation fault when its alternate signal stack is overflowed; we
    leave it as an exercise to the reader to write a `SIGSEGV` handler similar to
    the one shown here to properly handle the case.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, though, we have shown that handling the segfault, the SIGSEGV, can
    be very beneficial to figuring out the cause of a crash; the simple fact remains
    that once this signal is generated upon a process, the process is considered to
    be in an undefined, in effect, unstable, state. Thus, there is no guarantee that
    whatever work we perform in its signal handler will actually go through as intended.
    Thus, keeping the signal handling code to a minimum would be recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Signaling – caveats and gotchas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals, being asynchronous events, can cause errors and bugs in subtle ways
    that are not immediately apparent to the casual reviewer (or programmer, for that
    matter). Some kinds of functionality or behavior are directly or indirectly affected
    by the arrival of one or more signal; you need to be alert to possible subtle
    races and similar conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important area in this that we have already covered is as follows: inside
    a signal handler, you can only invoke functions that are documented as being (or
    have been designed to be) async-signal safe. Other areas too deserve some contemplation;
    read on.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling errno gracefully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A race with the uninitialized global integer `errno` can occur in programs using
    system calls and signals.
  prefs: []
  type: TYPE_NORMAL
- en: What does errno do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember the errnoglobal; it's an uninitialized global integer in the process's uninitialized
    data segment (process layout was covered in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual
    Memory*).
  prefs: []
  type: TYPE_NORMAL
- en: 'What is errno for? Whenever a system call fails, it returns `-1` to userspace.
    But why did it fail? Ah, the error diagnostic, the reason it failed, is returned
    to userspace like this: glibc, in conjunction with the kernel, pokes the global errno with
    a positive integer value. This value is actually an index into a two-dimensional
    array of English error messages (which is NULL-terminated); it''s called`_sys_errlist`.
    So, looking up `_sys_errlist`[errno] reveals the English error message: the reason
    the system call failed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the developer performing all the work, convenience routines such
    as `perror(3)`, `strerror(3)`, and `error(3)` are designed to emit error messages
    by looking up `_sys_errlist[errno]`. Programmers very often use routines such
    as this in the system call error- handling code (in fact, we do: check out our
    code for the macros `WARN` and `FATAL`—they call the `handle_err` function, which
    in turn invokes `perror(3)` as part of its processing).'
  prefs: []
  type: TYPE_NORMAL
- en: Here is a useful-to-look-up item—the list of all possible `errno` values resides
    in the header file `/usr/include/asm-generic/errno-base.h`.
  prefs: []
  type: TYPE_NORMAL
- en: The errno race
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A process sets up a signal handler for several signals:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's say the signal handler for `SIGUSR1` is called `handle_sigusr.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now the process is running a part of its code, a function `foo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: foo issues a system call, say the `open(2)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system call fails returning `-1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: errno gets set to the positive integer `13` reflecting the error permission
    denied (errno macro EACCES).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system call's error-handling code calls `perror(3)`to emit the English error
    message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All this seems innocent enough, yes. However, now let''s consider signals in
    the mix; check out the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<...>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: foo issues a system call, say the `open(2)`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system call fails returning `-1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: errno gets set to the positive integer `13` reflecting the error permission
    denied (errno macro EACCES).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signal `SIGUSR1` is delivered at this instant to the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control is switched to the signal handler routine, `handle_sigusr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code here issues another system call, say, `stat(2)`**.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stat(2)` system call fails returning `-1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: errno now gets set to the positive integer `9` reflecting the error bad file
    number (errno macro EBADF).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signal handler returns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system call's error-handling code calls `perror(3)` to emit the English
    error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As can be seen, the value of errno gets overwritten from the value 13 to the
    value 9 because of the sequence of events. The result is that the application
    developer (along with everyone else on the project) is now confounded by the weird
    error reporting (the error bad file number is possibly reported twice!). Races—the
    bane of programmers!
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the errno race
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fix for the previous race is actually quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you have a signal handler with code within it that could possibly cause
    the errno value to change, save `errno` upon function entry and restore it just
    before returning from the handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gain access to the `errno` variable simply by including its header file. Here
    is a quick example code snippet of a signal handler that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sleeping correctly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, even sleeping requires sufficient knowledge to perform correctly!
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, your process has to enter a sleep state. We have all probably learned
    to use the `sleep(3)` API to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As a simple example, let''s say that the process must work this way (pseudo
    code follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s quite clear: the process must sleep for `10` seconds; the code shown
    should work. Is there a problem?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, yes, signals: what if the process enters the sleep, but three seconds
    into the sleep a signal arrives? The default behavior (meaning, unless signals
    are masked) is to handle the signal, and you would imagine, go back to sleep for
    the remaining time (seven seconds). But, no, that''s not what happens: the sleep is
    aborted! The astute reader might argue that it''s possible to fix this behavior
    (a blocking system call interrupted by signals) by using the `SA_RESTART` flag;
    indeed, it sounds reasonable, but the reality is that even using the flag does
    not help (the sleep has to be manually restarted).'
  prefs: []
  type: TYPE_NORMAL
- en: Further, it's important to realize that the `sleep(3)` API documents that its
    return value is the amount of time remaining to sleep; so unless `sleep(3)` returns
    `0`, the sleep is not done! The developer is actually expected to invoke `sleep(3)` in
    a loop, until the return value is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: What does making a process (or thread) "go to sleep" really mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'The key point is this: a process (or thread) that''s asleep cannot run on the
    CPU while in that state; it is not even a candidate for the OS scheduler (technically,
    the transition from state'
  prefs: []
  type: TYPE_NORMAL
- en: Running->sleeping is a dequeue from a run queue and an enqueue on to a wait
    queue within the OS, and vice versa). More on this in [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml),
    *CPU Scheduling on Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we conclude that just using a `sleep(3)` in the code is not that great
    an idea because of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The sleep, once interrupted by signal delivery, must be manually restarted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The granularity of `sleep(3)` is very coarse: a second. (A second is a very,
    very long time for a modern microprocessor! Many real-world applications rely
    on at least millisecond-to-microsecond-level granularity.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what is the solution?
  prefs: []
  type: TYPE_NORMAL
- en: The nanosleep system call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux provides a system call, `nanosleep(2)`, that in theory can provide nanosecond-level
    granularity, that is, a sleep of a single nanosecond. (Well, in practice, the
    granularity will also depend on the resolution of the hardware timer chip on the
    board.) This is the prototype of this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The system call has two parameters both are pointers to structure of data type
    struct `timespec`; this structure definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, this allows you to specify the sleep time in seconds and nanoseconds;
    the first parameter `req` is the required time (`s.ns`), the second parameter `rem` is
    the remaining time to sleep. See, the OS helps us out here: if the sleep is interrupted
    by a signal (any signal that is non-fatal), the `nanosleep `system call fails
    returning `-1` , and errno is set to the value `EINTR` (Interrupted system call).
    Not only that, the OS calculates and returns (into this second pointer, a value-result type
    of parameter), the amount of time remaining to sleep accurate to the nanosecond. This
    way, we detect the case, set `req` to `rem`, and manually reissue the `nanosleep(2)` to
    have the sleep continue until it''s fully done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate, we show a small application next (source code: `ch12/sleeping_beauty.c`); the
    user can invoke either the usual `sleep(3)` method of sleeping, or use the highly
    superior `nanosleep(2)` API such that the sleep time is accurate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following from the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing `0` as the parameter has us invoke the usual `sleep(3)`*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We deliberately code without using a loop here, as this is how most programmers
    call `sleep(3)` (and thus we can see the pitfalls).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing `1` as the parameter has us invoke the powerful `nanosleep(2)` API;
    we initialize the required time to be 10 seconds (same as in the previous case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, this time, we call the `nanosleep(2)` in a loop, checking for the signal
    interruption case `errno == EINTR`, and if so,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set `req` to `rem` and call it again!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '(For fun, we print the time remaining `s.ns`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try both cases: first, the usual `sleep(3)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A few seconds into the sleep, we press *^C*; the signal arrives, but the sleep
    is aborted (as shown, an additional seven seconds of the sleep remain, which the
    code here simply ignores)!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the good case: sleeping via the `nanosleep(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, our dear `sleeping_beauty` runs (sleeps?) to completion even in
    the presence of continuous interruption via multiple signals. You should notice,
    though, this fact: there is going to be some overhead, yes. The only guarantee
    made by the OS is that the sleep continues for at least as long as required, possibly
    a bit longer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: although using the `nanosleep(2)` results in a highly superior implementation
    to the usual `sleep(3)` API, the fact is that even the `nanosleep` is subject
    to (what could become significant) time overruns when the code is within a loop and a
    sufficiently large number of signals interrupts our loop many, many times (as
    could occur in our previous example). In cases such as this, we can end up oversleeping quite
    a bit. To fix this, the POSIX standard, and Linux, provide an even better `clock_nanosleep(2)` system
    call: using it with a real-time clock and a flag value of `TIMER_ABSTIME` takes
    care of the oversleeping issue. Also note that though Linux''s `sleep(3)` API
    is internally implemented via `nanosleep(2)`, the sleep semantics remain as described;
    it''s the app developer''s responsibility to call the sleep code in a loop, checking
    for return value and the failure case.'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall the output of the `kill -l` (l for list) command; the platform's supported
    signals are displayed—numeric integer and symbolic name, both. The first 31 signals
    are the standard or Unix signals (seen in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, *The standard or Unix signals* section); we have been working
    with them quite a bit now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signal numbers 34 to 64 all start with `SIGRT`—`SIGRTMIN` to `SIGRTMAX`—they
    are called the **real time** signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: (The first one, `SIGSYS` seen here is not a real time signal; it shows up because
    it's in the same line as the other SIGRT's and so `grep(1)` prints it.)
  prefs: []
  type: TYPE_NORMAL
- en: Differences from standard signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, how do the so-called real time signals differ from the regular standard
    signals; the following table reveals  this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Characteristic** | **Standard signals** | **Real time signals** |'
  prefs: []
  type: TYPE_TB
- en: '| Numbering | 1 - 31 ¹ | 34 - 64 ² |'
  prefs: []
  type: TYPE_TB
- en: '| Standard first defined in | POSIX.1-1990 (it''s old) | POSIX 1003.1b : real
    time Extensions to POSIX (2001) |'
  prefs: []
  type: TYPE_TB
- en: '| Meaning assigned | Individual signals have a particular meaning (and are named
    accordingly); the exception is `SIGUSR[1&#124;2]` | Individual RT signals have no particular
    meaning; their meaning is app-defined |'
  prefs: []
  type: TYPE_TB
- en: '| Behavior when blocked and multiple instances of same signal  continuously
    delivered | Out of n instances of the same signal, n-1 are lost; only 1 instance
    is kept pending and delivered to the target process when unblocked | All instances
    of RT signals are queued and delivered to the target process by the OS when unblocked (there
    is a system-wide upper limit ³) |'
  prefs: []
  type: TYPE_TB
- en: '| Signal priority | The same: all standard signals are peers | FCFS unless
    pending; if pending, then signals delivered from lowest to highest numbered realtime
    signal ⁴ |'
  prefs: []
  type: TYPE_TB
- en: '| **Inter Process Communication** (**IPC**) | Crude IPC; you can use `SIGUSR[1&#124;2]` to
    communicate, but no data can be passed | Better: via the `sigqueue(3)`, a single
    data item, an integer or pointer value, can be sent to a peer process (which can
    retrieve it) |'
  prefs: []
  type: TYPE_TB
- en: Differences between standard and realtime signals
  prefs: []
  type: TYPE_NORMAL
- en: ¹ Signal number `0`? Does not exist, used to check for process existence (seen
    later).
  prefs: []
  type: TYPE_NORMAL
- en: '² An FAQ: whatever happened to realtime signal numbers 32 and 33? The answer:
    they are reserved for use by the pthreads implementation, and thus unavailable
    to the application developer.'
  prefs: []
  type: TYPE_NORMAL
- en: '³ The system-wide upper limit is a resource limit and can thus be queried or
    set via the `prlimit(1)` utility (or the `prlimit(2)` system call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: (Recall from [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource
    Limits*, that the first number is the soft limit, the second is the hard limit).
  prefs: []
  type: TYPE_NORMAL
- en: '⁴ RT signal priority: multiple instances of realtime signals are processed
    in exactly the order they were delivered (in other words, **First Come First Served** (**FCFC**).
    However, if these multiple real time signals are pending delivery to the process,
    that is, they are currently blocked, then they are processed in priority order, rather
    non-intuitively, `SIGRTMIN` being the highest priority signal and `SIGRTMAX` being
    the lowest.'
  prefs: []
  type: TYPE_NORMAL
- en: Real time signals and priority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The POSIX standard, and the Linux documentation, states that when multiple
    real time signals of different types are pending delivery to a process (that is the
    process is blocking them); then, at some point, when the process''s signal mask
    is unblocked (thereby allowing the signals to be delivered), the signals are indeed
    delivered in priority order: lowest signal number to highest signal number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test this: we write a program that traps and blocks upon the delivery
    of three real time signals: {`SIGRTMAX-5`, `SIGRTMAX`, `SIGRTMIN+5`}. (Have a
    look at the output of `kill -l`; their integer values are {59, 64, 39} respectively.)'
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, our program will, at the time of `sigaction(2)`, use the `sigfillset(3)` convenience
    method to populate the signal mask member of struct sigaction with all 1s, thereby
    ensuring that all signals are blocked (masked) while the signal handler code is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process (code: `ch12/rtsigs_waiter.c`) traps the RT signals (with sigaction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{`SIGRTMAX-5`, `SIGRTMAX`, `SIGRTMIN+5`} : integer values {59, 64, 39} respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have a shell script (`bombard_sigrt.sh`) send these three real time
    signals continually (or for the number requested) in batches of three, in the
    following order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{`SIGRTMAX-5`, `SIGRTMAX`, `SIGRTMIN+5`} : integer values {59, 64, 39} respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The first of the RT signals (# 59) causes the process to enter the signal handler
    routine; recall, we have specified (at the time of `sigaction(2)`) that all signals are
    blocked (masked) while the signal handler code runs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We deliberately use our `DELAY_LOOP_SILENT` macro to keep the signal handler
    running for a while.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accordingly, the RT signals delivered by the script cannot interrupt the handler
    (they are blocked), so the OS queues them up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the signal handler completes and returns, the next RT signal in the queue
    is delivered to the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In priority order, they are delivered least to highest, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{`SIGRTMIN+5`, `SIGRTMAX-5`, `SIGRTMAX`} : integer values {39, 59, 64}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next run verifies this behavior on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not show the source code here; to view the complete source code, build
    it, and run it, the entire tree is available for cloning from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/rtsigs_waiter.c](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/rtsigs_waiter.c) and [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/bombard_sigrt.sh](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/bombard_sigrt.sh).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In another Terminal window we run the bombard script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the original Terminal window where the `rtsigs_waiter` process is running,
    we now see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first RT signal sent by the script is the `SIGRTMAX-5` (value 59); hence,
    it enters the signal handler and is processed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the signal handler is running, all signals are blocked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The script continues to pump out the remaining RT signals (see its output),
    while they are masked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, they are queued by the OS and delivered once the handler completes in
    priority order: lowest to highest numbered RT signal, that is, the priority order
    is from `SIGRTMIN` (highest) to `SIGRTMAX` (lowest).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As they are queued, no signals are lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a screenshot demonstrating the same, for a larger number of RT signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0438cda-7ad0-4ffc-95e5-d8f4e4019a1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Passing 10 to the script (see the right hand window) has it deliver 3x10: 30
    RT signals in 10 batches of {`SIGRTMIN+5`, `SIGRTMAX-5`, `SIGRTMAX`}). Note, in
    the left hand window, how (except for the first instance of course) they are (queued
    and) processed in priority order, lowest to highest—first, all the 39s {`SIGRTMIN+5`},
    then all the 59s {`SIGRTMAX-5`}, and finally the lowest priority 64s {`SIGRTMAX`}
    RT signals.'
  prefs: []
  type: TYPE_NORMAL
- en: The script sends signals to the process by issuing the `kill(1)` command; it will
    be explained in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude, real time signals are processed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If unblocked, they are processed one after the other in FCFS order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If blocked, they are queued and delivered in priority order—the lowest RT signal
    being the highest priority and the the highest RT signal being the lowest priority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, you, the reader, are strongly encouraged to check out the code and
    try out these experiments yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Sending signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have typically seen cases where the kernel sends signals to a process; there
    is no reason a process cannot send a signal (or several) to another process. In
    this section, we delve into the details of sending signals to processes from a
    process, and ideas related to the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder, even if you could send a signal to another process, how would
    it be useful? Well, think about it: signal-sending could be used as an **interprocess
    communication** (**IPC**) mechanism, for one. Also, it''s a way of checking for
    a process''s existence! There are other useful cases, such as sending yourself
    a signal. Let''s explore these further.'
  prefs: []
  type: TYPE_NORMAL
- en: Just kill 'em
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How do we send a signal to another process: the short answer, via the `kill(2)` system
    call. The kill API can deliver a signal, any signal, to a process given its PID;
    the function signature from the man page on `kill(2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note it's very generic—you can send pretty much any signal to any process (it
    might perhaps have been better named as `sendsig`, but, of course, that's not
    as exciting a name as kill).
  prefs: []
  type: TYPE_NORMAL
- en: The user command `kill(1)` is, of course, a wrapper over the `kill(2)` system
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quite obviously, from the previous API, you can infer that the signal `sig` is
    sent to the process that has the PID value pid. Hang on, though, there are several
    special cases to consider as well; see the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **kill PID value **  | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| > 0 | The signal is sent to the process with numeric PID equal to this value
    (the usual case). |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | The signal is sent to all processes within the process group ¹ of the
    caller. |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | The signal is sent to all processes for which the caller has permission
    to send (see next), except the overall ancestor process, PID 1 (traditionally init,
    nowadays systemd). ² |'
  prefs: []
  type: TYPE_TB
- en: '| < -1 | The signal is sent to all processes within the process group one having
    ID, pid. |'
  prefs: []
  type: TYPE_TB
- en: '¹ Process group: Every process will be a member of a process group (each pgrp
    will have its own unique ID, equal to the PID of the first member, called the process
    group leader. Use `ps j `to look up process group details; also, the system calls
    `get|set]pgid(2), [get|set]pgrp(2)`, are available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run a chain of processes via pipes (for example, `ps aux |tail |sort
    -k6n`) and, once it''s running, type *^C* on the keyboard, then we understand
    the signal SIGINT is generated via the kernel''s tty layer; but to which process?
    All the processes currently running as part of the preceding pipeline form the foreground
    process group. The significance with regard to signaling: any signals generated
    via the keyboard (such as *^C*, *^\*, *^Z*), is delivered to all processes belonging
    in the foreground process group. (Thus all three will receive the signal. Check
    the *Further reading *section for a link to more information on process groups
    on the GitHub repository.)'
  prefs: []
  type: TYPE_NORMAL
- en: ^(2 )On Linux, `kill(-1, sig)` does not send `sig` to the calling process itself.
  prefs: []
  type: TYPE_NORMAL
- en: Killing yourself with a raise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dramatic as it sounds, here we point out a simple wrapper API: the *raise(3) *library
    call. Here is its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s really very simple: given a signal number, the raise API raises, sends,
    the given signal to the calling process (or thread). If the signal in question
    is caught, the raise will return only once the signal handler has completed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that we have used this API in our `handle_segv.c`program earlier in
    this chapter: we used it to ensure that, for the signal SIGSEGV, after our own
    handling is done, we re-raise the same signal on  ourselves, thereby ensuring
    that the core dump occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: (Well, philosophically, though, there's only so much that getting that raise
    will do for your happiness quotient.)
  prefs: []
  type: TYPE_NORMAL
- en: Agent 00 – permission to kill
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Ian Fleming''s books, James Bond is a double-oh agent (007): a secret agent
    with permission to kill!'
  prefs: []
  type: TYPE_NORMAL
- en: Well, like Bond, we too can kill; um, a process, of course, that is, send it
    a signal. It's nowhere as dramatic and exciting as Bond, but, hey, we can! Well,
    IFF (if and only if) we have the permission to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required permission: the sending process must either:'
  prefs: []
  type: TYPE_NORMAL
- en: Have root privileges—Under the modern capabilities model (recall [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml),
    *Process Capabilities*), the requirement becomes that a process has the `CAP_KILL`
    capability bit set; from the man page on capabilities(7): CAP_KILL : Bypass permission
    checks for sending signals (see `kill(2)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Own the target process, which implies that the sender's EUID (effective UID)
    or RUID (real UID) and the target's EUID or RUID, respectively, should match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The man page on `kill(2)` specifies in more detail some corner cases on Linux
    regarding permissions to send signals; take a look if interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, tempting as it sounds, just performing a loop like (pseudo-code follows) will
    not necessarily work for all processes alive, mostly because of a lack of permissions
    of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Even if you were to run code such as the one shown previously as root, the system
    will disallow abruptly terminating key processes such as systemd (or init). (Why
    not try it—it's a suggested exercise anyway. Of course, trying stuff like this
    is asking for trouble; we suggest you try this a test VM.)
  prefs: []
  type: TYPE_NORMAL
- en: Are you there?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking for a process's very existence, is it alive now?, can be crucial to
    an application. For example, an application function receives the PID of a process
    as a parameter. Before it actually does something with the process via the provided
    PID (perhaps send it a signal), it would be a good idea to verify that the process
    is indeed valid (what if it's dead or the PID invalid?).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kill(2)` system call helps us in this regard: the second parameter to kill is
    the signal to send; using the value `0` (recall there is no signal numbered 0)
    validates the first parameter: the PID. How exactly? If the `kill(2)` returns
    failure, either the PID is invalid or we do not have permission to send the process
    (or process group) a signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pseudo-code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Signaling as IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned that a fundamental side effect of the virtual memory architecture
    that modern OSes (such as Linux) use is that a process can only access memory
    within its own **virtual address space** (**VAS**); and that too only the valid
    mapped memory.
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, this implies a process cannot read from or write into
    the VAS of any other process. Yes; but then, how do you communicate with other
    processes? This scenario is critical in many multi-process applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer: IPC mechanisms. The Linux OS has several; here, we make use
    of one of them: signaling.'
  prefs: []
  type: TYPE_NORMAL
- en: Crude IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think about it, it''s quite simple: processes A and B are part of a multi-process
    application. Now process A wants to inform process B that it has completed some
    work; upon receiving this information, we expect process B to acknowledge the
    same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can devise a simple IPC scheme via signaling as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Process A is performing its work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process B is performing its work (they run in parallel of course).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process A reaches a milestone; it informs process B of this by sending it `SIGUSR1`
    (via the `kill(2)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having trapped the signal, process B enters its signal handler and verifies
    things as required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It acknowledges the message by sending process A, say, `SIGUSR2` (via the `kill(2)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having trapped the signal, process A enters its signal handler, understands
    that the ack has been received from B, and life continues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (The reader can try this as a small exercise.)
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we should realize an important detail: IPC implies the ability to
    send data to another process. Above, however, we have not been able to transmit
    or receive any data; just the fact that we can communicate via signals (well,
    you could argue that the signal number itself is data; true, in a limited sense).
    So we think of this as a crude IPC mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: Better IPC – sending a data item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This leads us to the next interesting fact: it is possible to send a data quantum—a
    piece  of data—via signals. To see how, let''s revisit the powerful struct `siginfo_t` we
    studied earlier in this chapter. To have the signal handler receive the pointer
    to it, recall that we use the `SA_SIGINFO` flag when calling `sigaction(2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall the fact that, within struct `siginfo_t`, the first three members are
    simple integers, the fourth member is a union of structures, there are seven of
    them—only one of which will get instantiated at runtime; the one that does depends
    on which signal is being handled!
  prefs: []
  type: TYPE_NORMAL
- en: 'To help us recall, here''s the initial portion of struct `siginfo_t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the union of structures, the structure of interest to us right now is
    the one that deals with real time signals—this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it''s quite straightforward: if we trap some real time signals and use
    `SA_SIGINFO`, we shall be able to retrieve the pointer to this structure; the
    first two members reveal the PID and RUID of the sending process. That itself
    is valuable information!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third member though, the `sigval_t`, is the key (`in /usr/include/asm-generic/siginfo.h`
    on Ubuntu and `in /usr/include/bits/types/__sigval_t.h` on Fedora):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `sigval_t` is itself a union of two members: an integer and a
    pointer! We know that a union can only have one of its members instantiated at
    runtime; so the deal here is: the sender process populates one of the preceding
    members with data and then sends a real time signal to the receiver process. The
    receiver can extract the data quantum sent by appropriately de-referencing the
    preceding union. This way, one is able to send data across processes; the data
    is effectively piggy-backed on a real time signal! Quite cool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But think: we can use only one of the members to piggy-back our data, either
    the integer `int sival_int` or the `void * sival_ptr` pointer. Which should one
    use? It''s instructive to recall what we learned in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process
    Creation* on process creation: every address within a process is a virtual address;
    that is, my  virtual address X is likely not pointing to the same physical memory
    as your virtual address X. In other words, attempting to communicate data via
    a pointer, which is after all nothing but a virtual address, might now work as
    well as expected. (If you are unsure about this, might we suggest rereading the *malloc*
    *and* *The fork* sections in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),
    *Process Creation*.)'
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, using an integer to hold and communicate data to our peer process
    would usually be a better idea. In fact, C programmers know how to extract, literally,
    every last bit from memory; you can always treat the integer as a bitmask and
    communicate even more information!
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the C library provides a helper routine to quite easily send
    a signal with data embedded within, the `sigqueue(3)` API. Its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two parameters are obvious: the process to send the signal `sig`
    to; the third parameter value is the union discussed.'
  prefs: []
  type: TYPE_NORMAL
- en: Lets try this out; we write a small producer-consumer type of application. We
    run the consumer process in the background; it polls, waiting for the producer
    to send it some data. (As you might guess, polling is not ideal; in the multithreading
    topics, we shall cover superior methods; for now, we shall just simplistically
    poll.) When the receiver detects data has been sent to it, it displays all relevant
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a sample run: to begin, we run the consumer (receiver) process (`ch12/sigq_ipc/sigq_recv.c`) 
    in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run the producer (`ch12/sigq_ipc/sigq_sender.c`) , sending a data
    item to the consumer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The consumer processes the signal, understands that data has arrived, and in
    the next polling cycle prints out the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For readability, only key parts of the source code are displayed next; to view
    the complete source code, build it and run it, the entire tree is available for cloning
    from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the receiver: `ch12/sigq_ipc/sigq_recv.c`: `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We poll upon the arrival of the real time signal, sleeping in a loop for three
    seconds on each loop iteration; polling is really not the best way to code; for
    now, we just keep things simple and do so (in the [Chapters 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml),
    *Multithreading with Pthreads Part I - Essentials* and [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml),
    *Multithreading with Pthreads Part II - Synchronization*, we shall cover other
    efficient means of synchronizing on a data value).
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the section *Sleeping correctly*, we prefer to use our own wrapper
    over `nanosleep(2)`, our `r_sleep()` function, keeping the sleep safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, a part of the sender code: `ch12/sigq_ipc/sigq_sender.c`: `send_peer()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This function performs the work of checking that the target process is indeed
    alive, and if so, sending it the real time signal via the useful `sigqueue(3)` library
    API. A key point: we wrap or embed the data to be sent inside the `sigval` union,
    as an integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the receiver: when it does receive the real time signal, its designated
    signal handler code, `read_msg()`, runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We update a structure to hold the data (and metadata), allowing us to conveniently
    print it whenever required.
  prefs: []
  type: TYPE_NORMAL
- en: Sidebar – LTTng
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a very interesting aside, wouldn't it be wonderful if one could actually trace
    the flow of the sender and receiver processes as they execute? Well, Linux provides
    several tools to do precisely this. Among the more sophisticated ones is a software
    called **Linux Tracing Toolkit next generation** (**LTTng**).
  prefs: []
  type: TYPE_NORMAL
- en: LTTng is really powerful; once set up, it has the ability to trace both kernel
    and user space (although tracing user space involves the application developers
    explicitly instrumenting their code). Well, your author used LTTng to perform
    a trace of the system (kernel-space) while the previous processes ran; LTTng did
    its job, capturing trace data (in a format called CTF).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the superb *Trace Compass* GUI application was used to display and interpret
    the trace session in a meaningful manner; the following screenshot shows an example;
    you can see the point at which the sender sent the signal to the receiver process
    via the `sigqueue(3)` library API, which, as you can see, translated to the `rt_sigqueueinfo(2)` system
    call (its entry point inside the kernel shows up as the `syscall_entry_rt_sigqueueinfo`
    event as follows).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the receiver process (`sigq_trc_recv` here) received (and then processed)
    the signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/633873c7-7faa-4f61-9a0b-5ef42fb71bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: '(As a fun thing to do: calculate the time delta between the real time signal
    being sent and the signal being received, bookmarked in purple and red color,
    respectively. It''s approximately 300 ms (microseconds).)'
  prefs: []
  type: TYPE_NORMAL
- en: The details of LTTng is not within the scope of this book's coverage; please
    see the *Further reading *section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completeness, we note the following APIs to send signals as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pthread_kill(3)` : an API to send a signal to a particular thread within the
    same process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tgkill(2)` : an API to send a signal to a particular thread within a given
    thread group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tkill(2)` : a deprecated predecessor to tgkill'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's ignore these for now; these APIs become more relevant in the context of
    multithreading in later [Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml),
    *Multithreading with Pthreads Part I - Essentials*, in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative signal-handling techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, in the previous chapter as well as this one on signaling, we have seen
    and learned to use several techniques with regard to asynchronously trapping and
    working with signals. The essential idea is this: the process is busy performing
    its work, running its business logic; a signal suddenly arrives; nevertheless,
    the process must handle it. We saw in quite some detail how one leverages the 
    powerful `sigaction(2)` system call to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we look at signal handling in a different manner: synchronously handling
    signals, that is, how to have the process (or thread) wait for (block upon) signals and
    handle them as they arrive.
  prefs: []
  type: TYPE_NORMAL
- en: The chapters to come on multithreading will provide some use cases of the same.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronously waiting for signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first glance, and the traditional manner in which signaling is taught, it
    appears that as signals are asynchronous in nature, why would one ever attempt
    to synchronously block upon signals delivered? Well, the reality is: performing
    robust signal handling in large projects is a difficult thing to do correctly
    and consistently. A lot of the complexity stems from the issue of signal-async
    safety; we are not allowed to use just any API within a signal handler; only a
    relatively small subset of APIs is considered async-signal-safe and is viable
    to use. This raises significant hurdles in large programs, and of course, at times,
    programmers inadvertently cause defects (bugs) (that too, ones that are difficult
    to catch during testing).'
  prefs: []
  type: TYPE_NORMAL
- en: These signal-handling difficulties pretty much vanish when one eliminates the
    whole asynchronous signal handler with signal-safety requirements design. How?
    By synchronously blocking upon signals and, when the signal(s) arrive, handling
    them then and there.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the goal in this section is to teach the budding systems programmer these
    important concepts (and their APIs); learning to use these can significantly decrease
    oddities and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: A number of useful mechanisms exist on the Linux OS to perform synchronous signal
    handling; let's start with the simple yet useful `pause(2)` system call.
  prefs: []
  type: TYPE_NORMAL
- en: Pause, please
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pause is a very good example of a blocking call; when a process calls this
    API, it blocks, that is, it goes to sleep waiting for an event; the event: the
    arrival of any signal to it. The moment a signal arrives, the pause is unblocked
    and execution continues. Of course, delivery of a fatal signal will cause the
    unsuspecting process to die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Throughout, we have said that checking system calls for their failure case
    `-1` is considered very important: a best practice to always follow. The `pause(2)`
    throws up an interesting exception case: it seems to be the one system call that always
    returns `-1 `and errno is set to the value `EINTR` Interrupted system call (the
    interruption being the signal of course).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we often code the pause as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The typecast to `void` is to inform tools such as the compiler and static analyzers
    that we don't really care about the return value from pause.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting forever or until a signal arrives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Often, one would like to wait forever, or until a signal arrives. One way to
    do so is the very simple, but very bad, terribly expensive spin on the CPU code
    such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Ugh! That''s just ugly: please do not write code like that!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slightly better, but still quite off, is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The pause can be used to effectively and efficiently set up a useful wait forever
    or until I receive any signal semantic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This semantic is very useful for this wait forever or until I receive any signal situation,
    as it's inexpensive (hardly any CPU usage as the `pause(2)` has the caller immediately
    go to sleep), and get unblocked only when a signal arrives. Then, the whole scenario
    repeats (due to the infinite loop of course).
  prefs: []
  type: TYPE_NORMAL
- en: Synchronously blocking for signals via the sigwait* APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we briefly visit a set of related functions, the sigwait* APIs; they
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sigwait(3)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigwaitinfo(2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigtimedwait(2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these APIs allow a process (or thread) to block (wait) upon the delivery
    of one or more signal.
  prefs: []
  type: TYPE_NORMAL
- en: The sigwait library API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the `sigwait(3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `sigwait(3)` library API allows a process (or thread) to block, wait, until
    any  signal in the signal-set `set` is pending delivery to it. The moment a signal
    arrives, the `sigwait `is unblocked; the particular signal that arrived, its integer
    value, is placed in the value-result second parameter `sig`. Under the hood, the sigwait removes
    the signal just delivered from the process (or thread) pending mask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the `sigwait(3)` is advantageous to the `pause(2)` by virtue of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can wait upon the delivery of particular signals to the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one of those signals is delivered, its value is known
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value from `sigwait(3)` is `0` on success and a positive value on
    error (note that it being a library API, errno remains unaffected). (Internally,
    the `sigwait(3)` is implemented via the `sigtimedwait(2)` API.)
  prefs: []
  type: TYPE_NORMAL
- en: 'However, things are not always as simple as they appear at first glance. The
    reality is that there are a couple of important points to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: A risky situation called a race can be set up if the signals one intends waiting
    upon are not first blocked by the calling process. (Technically, this is as there
    is a window of opportunity between a signal being delivered to the process and
    the sigwait call initializing). Once running, though, the sigwait will atomically unblock the
    signals, allowing them to be delivered upon the caller process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What if a signal (one within the signal set we define), is also trapped (caught)
    via either the `sigaction(2)` or `signal(2)` API, AND via the `sigwait(3)` API?
    In such a scenario, the POSIX standard states that it is up to the implementation
    to decide how to handle the delivered signal; Linux seems  to favor handling the
    signal via the `sigwait(3)`. (This makes sense: if a process  issues the sigwait API,
    the process blocks on signals. If a signal does become pending (meaning, it has
    just been delivered) on the process, then the sigwait API sucks in or consumes
    the signal: it is now no longer pending delivery on the process, and thus cannot
    be caught via signal handlers set up via the `sigaction(2)` or `signal(3)` APIs.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To test this, we write a small application `ch12/sigwt/sigwt.c` as well as
    a shell script `ch12/sigwt/bombard.sh` to shower all signals upon it. (The reader
    will find the code within the book''s GitHub repository, as always; this time,
    we leave it as an exercise to the reader to study the source, and experiment with
    it.) A couple of sample runs follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In one Terminal window, we run our `sigwt`program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note how we have first blocked all signals (via the `sigprocmask(2)`; we invoke
    our generic  `common.c:show_blocked_signals()` function to display all currently
    blocked signals in the process signal mask; as expected, all are blocked, with
    the obvious exception of signal numbers 9, 19, 32, and 33 (why?)). Recall that,
    once running, the `sigwait(3)` will atomically unblock the signals, allowing them
    to be delivered upon the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another Terminal window, run the shell script; the script''s job is simple:
    it sends (via `kill(1)`) every signal—from 1 to 64, except for `SIGKILL (9)`,
    `SIGSTOP (19)`, 32, and 33—the two RT signals reserved for use by the pthreads
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the original window, we observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: All delivered signals were processed via the sigwait! Including the SIGFPE (#
    8) and the SIGSEGV (# 11). This is as they were synchronously sent by another
    process (the shell script) and not by the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick `pkill(1)` kills off the sigwt process (as if one needs reminding:
    SIGKILL and SIGSTOP cannot be masked):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the next test case, running it with option `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note how signal numbers 8 (`SIGFPE`) and 11 (`SIGSEGV`) are not among the rest
    that are now blocked (besides the usual suspects, 9, 19, 32, 33). Recall that,
    once running, the `sigwait(3)` will atomically unblock the signals, allowing them
    to be delivered upon the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another Terminal window, run the shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the original window, we observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As we trapped the `SIGFPE` (via `sigaction(2)`), it was handled; however, the
    uncaught `SIGSEGV` of course causes the process to die abnormally. Not very pleasant
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little tinkering with the code reveals an interesting aspect; the original
    code snippet is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we effectively block the `SIGSEGV` by changing the preceding `#if 1`
    to `#if 0`? Let''s do so, rebuild, and retry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This time the SIGSEGV is processed via the sigwait! Yes, indeed; but only because
    it was artificially generated by a process, and not sent by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as usual, there''s more to it: how exactly signal handling happens is determined
    by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not the process blocks the signal prior to calling sigmask (or variants)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With regard to fatal signals (such as `SIGILL`, `SIGFPE`, `SIGSEGV`, `SIGBUS`,
    and so on), how the  signal is generated matters: artificially, via just a process
    (`kill(2)`) or actually generated via the kernel (due to a bug of some sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We find the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the signal is blocked by the process before invoking the sigwait, then, if
    the signal is delivered artificially via `kill(2)` (or variants), the `sigwait` will
    get unblocked upon delivery of the signal and the application developer can handle
    the signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if the fatal signal is delivered via the OS due to a bug, then, whether
    or not the process blocks it, the default action takes place, abruptly (and disgracefully)
    killing the process! This is probably not what one wants; thus, we conclude that
    it's better to trap fatal signals like the preceding via the usual asynchronous
    `sigaction(2)` style and not via the sigwait (or variants thereof).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sigwaitinfo and the sigtimedwait system calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sigwaitinfo(2)` system call is similar to sigwait: provided with a set
    of signals to watch out for, the function puts the caller to sleep until any one
    of those signals (in set) are pending. Here are their prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In terms of a return, the sigwait API was able to provide us with the signal
    number of the signal that got delivered to the calling process. However, recall
    that there is a much more powerful feature of the `sigaction(2)` API—the ability
    to return valuable diagnostic and other information within the `siginfo_t` data
    structure. Well, that's precisely what the `sigwaitinfo(2)` system call provides!
    (We covered the `siginfo_t` structure and what you can interpret from it earlier
    in the section detailing information with the `SA_SIGINFO`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'And the `sigtimedwait(2)`? Well, it''s quite apparent; it''s identical to the `sigwaitinfo(2)` API,
    except that there is an additional parameter—a timeout value. Hence, the function
    will block the caller either until one of the signals in set is pending, or the
    timeout expires (whichever occurs first). The timeout is specified via a simple `timespec` structure,
    which allows one to provide the time in seconds and nanoseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If the structure is memset to zero, the `sigtimedwait(2)` returns immediately,
    either with information returned about a signal that was pending, or an error
    value. Both the `sigwaitinfo(2)` and the `sigtimedwait(2)` APIs return the actual
    signal number on success and `-1` on failure, with `errno` set appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important point to note (it has been mentioned previously, but it''s key):
    neither the `sigwait`, `sigwaitinfo`, or `sigtimedwait` APIs can wait for synchronously
    generated signals from the kernel; typically the ones that indicate a failure
    of some sort, like the `SIGFPE` and the `SIGSEGV`. These can only be caught in
    the normal asynchronous fashion—via `signal(2)` or `sigaction(2)`. For such cases,
    as we have repeatedly shown, the` sigaction(2)` system callwould be the superior
    choice.'
  prefs: []
  type: TYPE_NORMAL
- en: The signalfd(2) API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reader will recall that, in [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml),
    *Linux System Architecture*, in the section entitled, *The Unix philosophy in
    a nutshell*, we drove home the point that a cornerstone of the Unix philosophy
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: On Unix, everything is a process; if it's not a process, it's a file.
  prefs: []
  type: TYPE_NORMAL
- en: Experienced Unix and Linux developers are very used to the idea (abstraction,
    really) of treating stuff as if it were a file; this includes devices, pipes,
    and sockets. Why not signals?
  prefs: []
  type: TYPE_NORMAL
- en: That's precisely the idea behind the `signalfd(2)` system call; with `signalfd`,
    you can create a file descriptor and associate it with a signal set. Now, the
    application programmer is free to monitor signals using a variety of familiar
    file-based APIs—among them the `read(2)`, `select(2)` and `poll(2)` (and its variations),
    and the `close(2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, similar to the `sigwait*` family of APIs we covered, `signalfd` is another
    way to have a process (or thread) synchronously block upon signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you make use of the `signalfd(2)` API? Its signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, `fd`, is either an existing signal descriptor, or the value
    -1\. When -1 is passed, the system call creates a new signal file descriptor (we
    should obviously call it in this manner at first). The second parameter mask is
    the signal `mask`—the set of signals that this signal descriptor will be associated
    with. As before with the sigwait* APIs, one is expected to block these signals
    (via the `sigprocmask(2)`).
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that the `signalfd(2)` system call, by itself,
    is not a blocking call. The blocking behavior comes into play only on invocation
    of a file-related API, such as `read(2)`, `select(2)`, or `poll(2)`. Only then
    is the caller put into a sleep state. The moment one of the signals in the set
    is delivered to the calling process (or is already pending on it), the file-related API returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter to `signalfd(2)` is a `flags` value—a means to change the
    default behavior. It''s only from Linux kernel version 2.6.27 onwards that the flags work
    well; the possible values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SFD_NONBLOCK` : use non-blocking I/O semantics on the signal descriptor (equivalent
    to the `fcntl(2)` `O_NONBLOCK`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SFD_CLOEXEC` : if the process ever execs another process (via the exec family
    APIs), ensure that the signal descriptor is closed (this is good for security
    as otherwise, all the predecessor process'' open files are inherited across the
    exec operation to the successor; equivalent to the `open(2)` `FD_CLOEXEC`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of return value, the `signalfd(2)` API returns the newly created signal
    descriptor on success; of course, this is if the first parameter was -1\. If not,
    then it should be an already existing signal descriptor; then, this value is returned
    on success. On failure, as usual, `-1` is returned and the `errno` variable reflects
    the diagnostic.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we shall limit the discussion of using the `signalfd(2)` to reading signal
    information via the familiar `read(2)` system call; this time, on the signal descriptor
    returned by the `signalfd` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the `read(2)` works in a nutshell (`read(2)` was covered in detail
    in [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*): we specify a file (in this case, signal) descriptor to
    read from as the first parameter, the buffer to place the just-read data as the
    second parameter, and the maximum number of bytes to read as the third parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: These are the common typdefs:`size_t` is essentially an unsigned long (integer)
  prefs: []
  type: TYPE_NORMAL
- en: '`ssize_t` is essentially a signed long (integer)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter here is special: a pointer to (one or more) structures
    of type `signalfd_siginfo`. The struct `signalfd_siginfo` is quite analogous to
    the `siginfo_t` we saw in some detail in the earlier section, *The siginfo_t structure*.
    Detailed information regarding the signal that arrived will be populated here.'
  prefs: []
  type: TYPE_NORMAL
- en: We leave it to the interested reader to glean the details of the `signalfd_siginfo`
    data structure from the man page on `signalfd(2)` here: [https://linux.die.net/man/2/signalfd](https://linux.die.net/man/2/signalfd). The
    page also contains a small example program.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter to read, the size, must in this case be at least sizeof(`signalfd_siginfo`) bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the reader has been taken through some advanced details with
    regard to signaling: how to handle crashing processes via appropriate fatal signal
    trapping, and once in the handler, getting key details including CPU registers,
    and so on. This was done by learning to interpret the powerful `siginfo_t` data
    structure. Further, handling races when working with the `errno` variable, and
    learning how to sleep correctly was covered.'
  prefs: []
  type: TYPE_NORMAL
- en: Real time signals and their differences from regular Unix signals was covered;
    then, there was a section regarding the different means of sending signals to
    other processes. Finally, we looked at signal handling by synchronously blocking
    upon a given set of signals (using various APIs).
  prefs: []
  type: TYPE_NORMAL
- en: In the next [Chapter 13](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml), *Timers*,we
    shall make use of the knowledge we gained here (and in the preceding) [Chapter
    11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling - Part I*, and learn
    how to set up and use timers effectively.
  prefs: []
  type: TYPE_NORMAL
