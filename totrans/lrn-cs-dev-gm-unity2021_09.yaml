- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic AI and Enemy Behavior
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual scenarios need conflicts, consequences, and potential rewards to feel
    real. Without these three things, there's no incentive for the player to care
    about what happens to their in-game character, much less continue to play the
    game. And while there are plenty of game mechanics that deliver on one or more
    of these conditions, nothing beats an enemy that will seek you out and try to
    end your session.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Programming an intelligent enemy is no easy task, and often goes hand in hand
    with long working hours and frustration. However, Unity has built-in features,
    components, and classes we can use to design and implement AI systems in a more
    user-friendly way. These tools will push the first playable iteration of *Hero
    Born* over the finish line and provide a springboard for more advanced C# topics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll focus on the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The Unity navigation system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static objects and navigation meshes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigation agents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Procedural programming and logic
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking and dealing damage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a loss condition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring and keeping it DRY
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Navigating 3D space in Unity
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about navigation in real life, it's usually a conversation about
    how to get from point A to point B. Navigating around virtual 3D space is largely
    the same, but how do we account for the experiential knowledge we humans have
    accumulated since the day we first started crawling? Everything from walking on
    a flat surface to climbing stairs and jumping off of curbs is a skill we learned
    by doing; how can we possibly program all that into a game without going insane?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Before you can answer any of these questions, you'll need to know what navigation
    components Unity has to offer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Navigation components
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The short answer is that Unity has spent a lot of time perfecting its navigation
    system and delivering components that we can use to govern how playable and non-playable
    characters can get around. Each of the following components comes as standard
    with Unity and has complex features already built in:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: A **NavMesh** is essentially a map of the walkable surfaces in a given level;
    the NavMesh component itself is created from the level geometry in a process called
    baking. Baking a NavMesh into your level creates a unique project asset that holds
    the navigation data.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a **NavMesh** is the level map, then a **NavMeshAgent** is the moving piece
    on the board. Any object with a NavMeshAgent component attached will automatically
    avoid other agents or obstacles it comes into contact with.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The navigation system needs to be aware of any moving or stationary objects
    in the level that could cause a NavMeshAgent to alter their route. Adding NavMeshObstacle
    components to those objects lets the system know that they need to be avoided.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this description of the Unity navigation system is far from complete,
    it's enough for us to move forward with our enemy behavior. For this chapter,
    we'll be focusing on adding a NavMesh to our level, setting up the Enemy Prefab
    as a NavMeshAgent, and getting the Enemy Prefab to move along a predefined route
    in a seemingly intelligent way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll only be using the NavMesh and NavMeshAgent components in this chapter,
    but if you want to spice up your level, take a look at how to create obstacles
    here: [https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html](https://docs.unity3d.com/Manual/nav-CreateNavMeshObstacle.html).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first task in setting up an "intelligent" enemy is to create a NavMesh
    over the arena''s walkable areas. Let''s set up and configure our level''s NavMesh:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Environment** GameObject, click on the arrow icon next to **Static**
    in the **Inspector** window, and choose **Navigation Static**:![](img/B17573_09_01.png)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.1: Setting objects to Navigation Static'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Click **Yes, change children** when the dialog window pops up to set all the
    **Environment** child objects to **Navigation Static**:![](img/B17573_09_02.png)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.2: Changing all child objects'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Window** | **AI** | **Navigation** and select the **Bake** tab. Leave
    everything set to their default values and click **Bake**. Once baking is finished,
    you'll see a new folder inside the **Scenes** folder with lighting, navigation
    mesh, and reflection probe data:![](img/B17573_09_03.png)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.3: Baking navigation mesh'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Every object in our level is now marked as **Navigation Static**, which means
    that our newly baked NavMesh has evaluated their accessibility based on its default
    NavMeshAgent settings. Everywhere you can see a light blue overlay in the preceding
    screenshot is a walkable surface for any object with a NavMeshAgent component
    attached, which is your next task.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Setting up enemy agents
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s register the Enemy Prefab as a NavMeshAgent:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Select the Enemy Prefab in the **Prefabs** folder, click **Add Component** in
    the **Inspector** window, and search for **NavMesh Agent**:![](img/B17573_09_04.png)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.4: Adding a NavMeshAgent component'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **+** **|** **Create Empty** from the **Hierarchy** window and name the
    GameObject `Patrol_Route`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Patrol_Route`, click **+** **|** **Create Empty** to add a child GameObject,
    and name it `Location_1`. Position `Location_1` in one of the corners of the level:![](img/B17573_09_05.png)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 9.5: Creating an empty patrol route object'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Create three more empty child objects in `Patrol_Route`, name them `Location_2`,
    `Location_3`, and `Location_4`, respectively, and position them in the remaining
    corners of the level to form a square:![](img/B17573_09_06.png)
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.6: Creating all empty patrol route objects'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Adding a NavMeshAgent component to the Enemy tells the NavMesh component to
    take notice and register it as an object that has access to its autonomous navigation
    features. Creating the four empty game objects in each corner of the level lays
    out the simple route we want our enemies to eventually patrol; grouping them in
    an empty parent object makes it easier to reference them in code and makes for
    a more organized Hierarchy window. All that's left is the code to make the enemy
    walk the patrol route, which you'll add in the next section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Moving enemy agents
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our patrol locations are set and the Enemy Prefab has a NavMeshAgent component,
    but now we need to figure out how to reference those locations and get the enemy
    moving on its own. To do that, we''ll first need to talk about an important concept
    in the world of software development: procedural programming.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Procedural programming
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though it's in the name, the idea behind procedural programming can be
    elusive until you get your head around it; once you do, you'll never see a code
    challenge the same way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Any task that executes the same logic on one or more sequential objects is the
    perfect candidate for procedural programming. You already did a little procedural
    programming when you debugged arrays, lists, and dictionaries with `for` and `foreach`
    loops. Each time those looping statements were executed, you performed the same
    call to `Debug.Log()`, iterating over each item sequentially. The idea now is
    to use that skill to get a more useful outcome.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common uses of procedural programming is adding items from one
    collection to another, often modifying them along the way. This works great for
    our purposes since we want to reference each child object in the `Patrol_Route`
    parent and store them in a list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Referencing the patrol locations
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand the basics of procedural programming, it''s time to
    get a reference to our patrol locations and assign them to a usable list:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `EnemyBehavior`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Select `Enemy` and drag the `Patrol_Route` object from the **Hierarchy** window
    onto the **Patrol Route** variable in `EnemyBehavior`:![](img/B17573_09_07.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.7: Dragging Patrol_Route to the enemy script'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Hit the arrow icon next to the **Locations** variable in the **Inspector** window
    and run the game to see the list populate:![](img/B17573_09_08.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.8: Testing procedural programming'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: First, it declares a variable for storing the `PatrolRoute` empty parent GameObject.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it declares a `List` variable to hold all the child `Transform` components
    in `PatrolRoute`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, it uses `Start()` to call the `InitializePatrolRoute()` method when
    the game begins.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, it creates `InitializePatrolRoute()` as a private utility method to procedurally
    fill `Locations` with `Transform` values:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that not including an access modifier makes variables and methods `private`
    by default.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we use a `foreach` statement to loop through each child GameObject in
    `PatrolRoute` and reference its Transform component:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each Transform component is captured in the local `child` variable declared
    in the `foreach` loop.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we add each sequential `child` `Transform` component to the list of
    locations using the `Add()` method as we loop through the child objects in `PatrolRoute`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This way, no matter what changes we make in the **Hierarchy** window, `Locations`
    will always be filled in with all the `child` objects under the `PatrolRoute`
    parent.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While we could have assigned each location GameObject to `Locations` by dragging
    and dropping them directly from the **Hierarchy** window into the **Inspector**
    window, it's easy to lose or break these connections; making changes to the location
    object names, object additions or deletions, or project updates can all throw
    a wrench into a class's initialization. It's much safer, and more readable, to
    procedurally fill GameObject lists or arrays in the `Start()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Due to that reasoning, I also tend to use `GetComponent()` in the `Start()`
    method to find and store component references attached to a given class instead
    of assigning them in the **Inspector** window.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need the enemy object to follow the patrol route we laid out, which
    is your next task.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Moving the enemy
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a list of patrol locations initialized on `Start()`, we can grab the enemy
    NavMeshAgent component and set its first destination.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `EnemyBehavior` with the following code and hit play:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: First, it adds the `UnityEngine.AI` `using` directive so that `EnemyBehavior`
    has access to Unity's navigation classes, in this case, `NavMeshAgent`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it declares a variable to keep track of which patrol location the enemy
    is currently walking toward. Since `List` items are zero-indexed, we can have
    the Enemy Prefab move between patrol points in the order they are stored in `Locations`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it declares a variable to store the NavMeshAgent component attached to
    the Enemy GameObject. This is `private` because no other classes should be able
    to access or modify it.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, it uses `GetComponent()` to find and return the attached NavMeshAgent
    component to the agent.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it calls the `MoveToNextPatrolLocation()` method on `Start()`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, it declares `MoveToNextPatrolLocation()` as a private method and sets
    `_agent.destinat``ion`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`destination` is a `Vector3` position in 3D space.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Locations[_locationIndex]` grabs the Transform item in `Locations` at a given
    index.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding `.position` references the Transform component's `Vector3` position.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, when our scene starts, locations are filled with patrol points and `MoveToNextPatrolLocation()`
    is called to set the destination position of the NavMeshAgent component to the
    first item at `_locationIndex 0` in the list of locations. The next step is to
    have the enemy object move from the first patrol location to all the other locations
    in sequence.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Our enemy moves to the first patrol point just fine, but then it stops. What
    we want is for it to continually move between each sequential location, which
    will require additional logic in `Update()` and `MoveToNextPatrolLocation()`.
    Let's create this behavior.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `EnemyBehavior` and hit play:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s break down the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it declares the `Update()` method and adds an `if` statement to check
    whether two different conditions are true:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`remainingDistance` returns how far the NavMeshAgent component currently is
    from its set destination`,` so we''re checking if that is less than 0.2.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pathPending` returns a `true` or `false` Boolean, depending on whether Unity
    is computing a path for the NavMeshAgent component.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If _`agent` is very close to its destination, and no other path is being computed,
    the `if` statement returns `true` and calls `MoveToNextPatrolLocation()`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we added an `if` statement to make sure that `Locations` isn''t empty
    before the rest of the code in `MoveToNextPatrolLocation()` is executed:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `Locations` is empty, we use the `return` keyword to exit the method without
    continuing.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is referred to as defensive programming, and, coupled with refactoring,
    it is an essential skill to have in your arsenal as you move toward more intermediate
    C# topics. We will consider refactoring at the end of the chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we set `_locationIndex` to its current value, `+1`, followed by the modulo
    (`%`) of `Locations.Count`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will increment the index from 0 to 4 and then restart it at 0 so that our
    Enemy Prefab moves in a continuous path.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The modulo operator returns the remainder of two values being divided—2 divided
    by 4 has a remainder of 2 when the result is an integer, so 2 % 4 = 2\. Likewise,
    4 divided by 4 has no remainder, so 4 % 4 = 0.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing an index by the maximum number of items in a collection is a quick
    way to always find the next item. If you're rusty on the modulo operator, revisit
    *Chapter 2*, *The Building Blocks of Programming*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We now need to check that the enemy is moving toward its set patrol location
    every frame in `Update()`; when it gets close, `MoveToNextPatrolLocation()` is
    fired, which increments `_locationIndex` and sets the next patrol point as the
    destination.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'If you drag the **Scene** view down next to the **Console** window, as shown
    in the following screenshot, and hit play, you can watch the Enemy Prefab walk
    around the corners of the level in a continuous loop:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_09_09.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Testing the enemy patrol route'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The enemy now follows the patrol route around the outside of the map, but it
    doesn't seek out the player and attack when it's within a preset range. You'll
    use the NavAgent component to do just that in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Enemy game mechanics
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our enemy is on a continuous patrol circuit, it's time to give it some
    interaction mechanics of its own; there wouldn't be much risk or reward if we
    left it walking around with no way to act against us.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Seek and destroy: changing the agent''s destination'
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we'll be focusing on switching the target of the enemies' NavMeshAgent
    component when the player gets too close and dealing damage if a collision occurs.
    When the enemy successfully lowers the player's health, it will return to its
    patrol route until its next run-in with the player.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: However, we're not going to leave our player helpless; we'll also add in code
    to track enemy health, detect when an enemy is successfully hit with one of the
    player's bullets, and when an enemy needs to be destroyed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Now that the Enemy Prefab is moving around on patrol, we need to get a reference
    to the player's position and change the destination of NavMeshAgent if it gets
    too close.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `EnemyBehavior`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: First, it declares a `public` variable to hold the `Player` capsule's `Transform`
    value.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we use `GameObject.Find("Player")` to return a reference to the player
    object in the scene:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding `.transform` directly references the object's `Transform` value in the
    same line.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we set `_agent.destination` to the player's `Vector3` position in `OnTriggerEnter()`
    whenever the player enters the enemies' attack zone that we set up earlier with
    a Collider component.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you play the game now and get too close to the patrolling enemy, you'll see
    that it breaks from its path and comes straight for you. Once it reaches the player,
    the code in the `Update()` method takes over again and the Enemy Prefab resumes
    its patrol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在玩游戏并离巡逻的敌人太近，你会发现它会中断原来的路径直接向你走来。一旦它到达玩家，`Update()`方法中的代码将再次接管，敌人预制件将恢复巡逻。
- en: We still need the enemy to be able to hurt the player in some way, which we'll
    learn how to do in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要让敌人以某种方式伤害玩家，我们将在下一节中学习如何做到这一点。
- en: Lowering player health
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低玩家生命值
- en: While our enemy mechanic has come a long way, it's still anti-climactic to have
    nothing happen when the Enemy Prefab collides with the player Prefab. To fix this,
    we'll tie in the new enemy mechanics with the game manager.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的敌人机制已经取得了长足的进步，但当敌人预制件与玩家预制件发生碰撞时什么都不发生仍然让人失望。为了解决这个问题，我们将新的敌人机制与游戏管理器联系起来。
- en: 'Update `PlayerBehavior` with the following code and hit play:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`PlayerBehavior`并点击播放：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s break down the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a `private` variable to hold the reference to the instance
    of `GameBehavior` we have in the scene.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明一个`private`变量来保存我们在场景中拥有的`GameBehavior`实例的引用。
- en: 'Then, it finds and returns the `GameBehavior` script that''s attached to the
    `Game Manager` object in the scene:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它找到并返回附加到场景中的`Game Manager`对象的`GameBehavior`脚本：
- en: Using `GetComponent()` on the same line as `GameObject.Find()` is a common way
    to cut down on unnecessary lines of code.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一行上使用`GetComponent()`和`GameObject.Find()`是减少不必要的代码行的常见方法。
- en: Since our player is the object being collided with, it makes sense to declare
    `OnCollisionEnter()` in `PlayerBehavior`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的玩家是发生碰撞的对象，因此在`PlayerBehavior`中声明`OnCollisionEnter()`是有道理的。
- en: Next, we check for the name of the colliding object; if it's the Enemy Prefab,
    we execute the body of the `if` statement.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检查碰撞对象的名称；如果是敌人预制件，我们执行`if`语句的主体。
- en: Finally, we subtract `1` from the public `HP` variable using the `_gameManager`
    instance.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`_gameManager`实例从公共`HP`变量中减去`1`。
- en: Whenever the enemy now tracks and collides with the player, the game manager
    will fire the set property on HP. The UI will update with a new value for player
    health, which means we have an opportunity to put in some additional logic for
    the loss condition later on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当敌人跟踪并与玩家发生碰撞时，游戏管理器将触发HP的设置属性。UI将使用新的玩家生命值更新，这意味着我们有机会为失败条件后期添加一些额外的逻辑。
- en: Detecting bullet collisions
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测子弹碰撞
- en: Now that we have our loss condition, it's time to add in a way for our player
    to fight back and survive enemy attacks.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了失败条件，是时候为我们的玩家添加一种反击敌人攻击并幸存下来的方式了。
- en: 'Open up `EnemyBehavior` and modify it with the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`EnemyBehavior`并使用以下代码进行修改：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s break down the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a `private int` variable called `_lives` with a `public`
    backing variable called `EnemyLives`. This will let us control how `EnemyLives`
    is referenced and set, just like in `GameBehavior`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个名为`_lives`的`private int`变量，并声明了一个名为`EnemyLives`的`public`后备变量。这将使我们能够控制`EnemyLives`的引用和设置方式，就像在`GameBehavior`中一样。
- en: Then, we set the `get` property to always return `_lives`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`get`属性设置为始终返回`_lives`。
- en: Next, we use `private set` to assign the new value of `EnemyLives` to `_lives`
    to keep them both in sync.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`private set`将`EnemyLives`的新值分配给`_lives`，以保持它们两者同步。
- en: We haven't seen `private get` or `set` before, but they can have their access
    modifiers, just like any other executable code. Declaring `get` or `set` as `private`
    means that only the parent class has access to their functionality.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有见过`private get`或`set`，但它们可以像任何其他可执行代码一样具有访问修饰符。将`get`或`set`声明为`private`意味着只有父类才能访问它们的功能。
- en: 'Then, we add an `if` statement to check whether `_lives` is less than or equal
    to 0, meaning that the enemy should be dead:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个`if`语句来检查`_lives`是否小于或等于0，这意味着敌人应该死了：
- en: When that's the case, we destroy the `Enemy` GameObject and print out a message
    to the console.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们销毁`Enemy`游戏对象并在控制台上打印一条消息。
- en: Because `Enemy` is the object getting hit with bullets, it's sensible to include
    a check for those collisions in `EnemyBehavior` with `OnCollisionEnter()`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`Enemy`是被子弹击中的对象，所以在`EnemyBehavior`中包含对这些碰撞的检查是合理的，使用`OnCollisionEnter()`。
- en: Finally, if the name of the colliding object matches a bullet clone object,
    we decrement `EnemyLives` by `1` and print out another message.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果碰撞对象的名称与子弹克隆对象匹配，我们将`EnemyLives`减少`1`并打印出另一条消息。
- en: Notice that the name we're checking for is `Bullet(Clone)`, even though our
    bullet Prefab is named `Bullet`. This is because Unity adds the `(Clone)` suffix
    to any object created with the `Instantiate()` method, which is how we made them
    in our shooting logic.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们检查的名称是`Bullet(Clone)`，即使我们的子弹预制件的名称是`Bullet`。这是因为Unity会在使用`Instantiate()`方法创建的任何对象后添加`(Clone)`后缀，而我们的射击逻辑就是这样创建的。
- en: You can also check for the GameObjects' tag, but since that's a Unity-specific
    feature, we're going to leave the code as-is and do things with pure C#.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以检查游戏对象的标签，但由于这是Unity特有的功能，我们将保持代码不变，只用纯C#来处理事情。
- en: Now, the player can fight back when the enemy tries to take one of its lives
    by shooting it three times and destroying it. Again, our use of the `get` and
    `set` properties to handle additional logic proves to be a flexible and scalable
    solution. With that done, your final task is to update the game manager with a
    loss condition.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，玩家可以在敌人试图夺取其生命时进行反击，射击三次并摧毁敌人。再次，我们使用`get`和`set`属性来处理额外的逻辑，证明这是一个灵活且可扩展的解决方案。完成这些后，你的最后任务是更新游戏管理器的失败条件。
- en: Updating the game manager
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新游戏管理器
- en: 'To fully implement the loss condition, we need to update the manager class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全实现失败条件，我们需要更新管理器类：
- en: 'Open up `GameBehavior` and add the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameBehavior`并添加以下代码：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the **Hierarchy** window, right-click on **Win Condition**, choose **Duplicate**,
    and name it **Loss Condition**:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the arrow to the left of **Loss Condition** to expand it, select the **Text**
    object, and change the text to **You lose...**
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select **Game_Manager** in the **Hierarchy** window and drag **Loss Condition**
    into the **Loss Button** slot in the **Game Behavior (Script)** component:![](img/B17573_09_11.png)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.10: Game behavior script with text and button variables completed
    in the Inspector pane'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare a new button that we want to show when the player loses the
    game.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we add in an `if` statement to check when `_playerHP` drops below `0`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's `true`, `ProgessText` and `Time.timeScale` are updated and the loss
    button is activated.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the player is still alive following an enemy collision, `ProgessText` shows
    a different message: "Ouch… that''s got to hurt.".'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, change _`playerHP` to 1 in `GameBehavior.cs` and get the Enemy Prefab to
    collide with you and observe what happens.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: That's a wrap! You've successfully added a "smart" enemy that can damage the
    player and be damaged right back, as well as a loss screen through the game manager.
    Before we finish this chapter, there's one more important topic that we need to
    discuss, and that's how to avoid repeating code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Repeated code is the bane of all programmers, so it makes sense that you learn
    how to keep it out of your projects early on!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and keeping it DRY
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Don''t Repeat Yourself** (**DRY**) acronym is the software developer''s
    conscience: it tells you when you''re in danger of making a bad or questionable
    decision, and gives you a feeling of satisfaction after a job well done.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In practice, repeated code is part of programming life. Trying to avoid it by
    constantly thinking ahead will put up so many roadblocks in your project that
    it won't seem worthwhile carrying on. A more efficient—and sane—approach to dealing
    with repeating code is to quickly identify it when and where it occurs and then
    look for the best way to remove it. This task is called refactoring, and our `GameBehavior`
    class could use a little of its magic right now.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we set the progress text and timescale in two separate
    places, but we could easily make ourselves a utility method to do this for us
    in a single place.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'To refactor the existing code, you''ll need to update `GameBehavior.cs` as
    follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down the code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We declared a new method called `UpdateScene`, which takes in a string parameter
    that we want to assign to `ProgressText` and sets `Time.timeScale` to `0`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We deleted our first instance of duplicated code and used our new method to
    update our scene when the game is won.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We deleted our second instance of duplicated code and update the scene when
    the game is lost.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's always more to refactor if you look in the right places.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, our enemy and player interactions are complete. We can dish out damage
    as well as take it, lose lives, and fight back, all while updating the on-screen
    GUI. Our enemies use Unity's navigation system to walk around the arena and change
    to attack mode when within a specified range of the player. Each GameObject is
    responsible for its behavior, internal logic, and object collisions, while the
    game manager keeps track of the variables that govern the game's state. Lastly,
    we learned about simple procedural programming and how much cleaner code can be
    when repeated instructions are abstracted out into their methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: You should feel a sense of accomplishment at this point, especially if you started
    this book as a total beginner. Getting up to speed with a new programming language
    while building a working game is no easy trick. In the next chapter, you'll be
    introduced to some intermediate topics in C#, including new type modifiers, method
    overloading, interfaces, and class extensions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – AI and navigation
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How is a NavMesh component created in a Unity scene?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity场景中如何创建NavMesh组件？
- en: What component identifies a GameObject to a NavMesh?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么组件将GameObject标识为NavMesh？
- en: Executing the same logic on one or more sequential objects is an example of
    which programming technique?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个或多个连续对象上执行相同的逻辑是哪种编程技术的例子？
- en: What does the DRY acronym stand for?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DRY首字母缩写代表什么？
- en: JOIN us on Discord!
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户一起阅读这本书，与Unity/C#专家和Harrison Ferrone一起阅读。提出问题，为其他读者提供解决方案，通过*问我任何事*与作者交流，以及更多内容。
- en: Join Now!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
