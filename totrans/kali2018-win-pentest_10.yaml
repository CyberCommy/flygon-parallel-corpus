- en: Reverse Engineering and Stress Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程和压力测试
- en: If you want to know how malware will behave, the easiest way to achieve that
    goal is to let it run rampant in your network and track its behavior in the wild.
    This is not how you want to get to understand malware behavior. You might easily
    miss something that your network environment doesn't enact, and then you'll have
    to remove the malware from all of the machines in your network. Kali has some
    selected tools to help you do that. This chapter also covers stress testing your
    Windows server or application. This is a great idea, if you want to discover how
    much DDoS will turn your server belly-up. This chapter is the beginning of how
    to develop an anti-fragile, self-healing Windows network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道恶意软件的行为，最简单的方法是让它在您的网络中肆虐，并跟踪其在野外的行为。这不是您想要了解恶意软件行为的方式。您可能会轻易错过您的网络环境没有执行的某些内容，然后您将不得不从网络中的所有计算机中删除恶意软件。Kali有一些精选的工具可以帮助您做到这一点。本章还涵盖了压力测试您的Windows服务器或应用程序。如果您想发现DDoS会让您的服务器崩溃多少，这是一个很好的主意。本章是如何开发一个抗脆弱、自我修复的Windows网络的开端。
- en: 'We will learn about the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Setting up a test environment
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立测试环境
- en: Reverse Engineering theory
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆向工程理论
- en: Working with Boolean logic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用布尔逻辑
- en: Practicing Reverse Engineering
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逆向工程实践
- en: Stress testing your Windows machine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压力测试您的Windows机器
- en: There are some changes in the Reverse Engineering tools that are available in
    Kali Linux 2.0 compared to the tools in Kali Linux 1.x. Some tools have disappeared
    from the menu structure, and you can use the last section of [Chapter 6](7b8a5720-a83e-426c-8d7e-76fb427fc041.xhtml), *NetBIOS
    Name Service and LLMNR – Obsolete but Still Deadly*, to put them back if you wish.
    Some tools have not been included in Kali Linux 2 at all, though there are traces
    of them here and there. The following table shows these changes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与Kali Linux 1.x相比，Kali Linux 2.0中提供的逆向工程工具有一些变化。一些工具已经从菜单结构中消失，如果您希望，可以使用[第6章](7b8a5720-a83e-426c-8d7e-76fb427fc041.xhtml)的最后一节，*NetBIOS名称服务和LLMNR
    - 已过时但仍然致命*，将它们放回。一些工具根本没有包含在Kali Linux 2中，尽管在各处都有它们的痕迹。以下表格显示了这些变化。
- en: Tools showing full paths are not in the default Kali 2.0 menu at all, and the
    NASM Shell, a part of the Metasploit Framework suite of tools, was not in the
    Kali 1.x menu.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 显示完整路径的工具在默认的Kali 2.0菜单中根本不存在，NASM Shell，Metasploit Framework套件的一部分，在Kali 1.x菜单中也不存在。
- en: 'The following table shows you the difference between the tools in Kali 1.x
    and 2.0:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了Kali 1.x和2.0中工具的区别：
- en: '![](img/ffda7889-19ed-40d0-8120-33d91c492340.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ffda7889-19ed-40d0-8120-33d91c492340.png)'
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要以下内容：
- en: A running Kali Linux machine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的Kali Linux机器
- en: A running copy of a Windows operating system (this can be a VM)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的Windows操作系统副本（可以是虚拟机）
- en: Setting up a test environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立测试环境
- en: Developing your test environment requires virtual machine examples of all of
    the Windows operating systems that you are testing against. For instance, an application
    developer might be running very old browser/OS test machines to see what breaks
    for customers running antique hardware. In this example, we are running Windows
    XP, Windows 7, and Windows 10\. We are using Oracle VirtualBox for desktop virtualization,
    but if you are more comfortable using VMWare, then use that instead. It is important
    to use machines that you can isolate from the main network, just in case the malware
    acts as it should, and attempts to infect the surrounding machines.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开发您的测试环境需要对您正在测试的所有Windows操作系统进行虚拟机示例。例如，应用程序开发人员可能正在运行非常旧的浏览器/操作系统测试机器，以查看对于运行古董硬件的客户来说会出现什么问题。在这个例子中，我们正在运行Windows
    XP、Windows 7和Windows 10。我们正在使用Oracle VirtualBox进行桌面虚拟化，但如果您更喜欢使用VMWare，那就使用它。重要的是要使用您可以与主网络隔离的机器，以防恶意软件表现如其应该，并试图感染周围的机器。
- en: Creating your victim machine(s)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的受害机器
- en: If you already have Windows VMs set up for some other purpose, you can either
    clone them (probably the safest option) or run them from a snapshot (this is the
    fastest way to set up). These machines should not be able to access the main network
    after you have built them, and you should probably set them up to communicate
    only with an internal network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经为其他目的设置了Windows虚拟机，您可以克隆它们（可能是最安全的选项）或者从快照中运行它们（这是设置的最快方式）。在构建完它们后，这些机器不应该能够访问主网络，并且您可能应该将它们设置为仅与内部网络通信。
- en: Testing your testing environment
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的测试环境
- en: Bring up your Kali VM
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的Kali虚拟机
- en: Make sure your Kali instance can talk to the internet, for ease of getting updates
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Kali实例可以与互联网通信，以便轻松获取更新
- en: Make sure your Kali instance can talk to your host machine
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Kali实例可以与您的主机机器通信
- en: Bring up your target Windows instances
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的目标Windows实例
- en: Make sure your Windows victims are not able to contact the internet, or your
    private Ethernet LAN, to avoid unexpected propagation of malware
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的Windows受害者无法访问互联网，或者您的私人以太网局域网，以避免恶意软件的意外传播
- en: 'The three virtual machines on our test network are on a host-only network inside
    Oracle VirtualBox. The DHCP is provided by the host (`192.168.56.100`), and the
    three testing network machines are `101`, `102`, and `103`, as shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试网络上的三台虚拟机都在Oracle VirtualBox内部的仅主机网络上。DHCP由主机提供（`192.168.56.100`），三台测试网络机器分别是`101`、`102`和`103`，如下所示：
- en: '![](img/bf29f285-779a-40a1-b74a-0e24abb9d844.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf29f285-779a-40a1-b74a-0e24abb9d844.png)'
- en: Reverse Engineering theory
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程理论
- en: 'Theory scares IT professionals for some reason. This is not truly warranted,
    as theory is the underlying bedrock of all of your troubleshooting. It may be
    the axioms you have learned through your X years of hard-knocks trial and error.
    In the land of qualitative research, this is literally called the **Grounded Theory
    Research Method**. The base theory for Reverse Engineering is that the outputs
    infer the interior behavior of the application. When you are faced with a piece
    of malware, you are going to start making working hypotheses from a mixture of
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理论因某种原因使IT专业人员感到恐慌。这并不真正有根据，因为理论是您所有故障排除的基础。这可能是您通过X年的艰难试错学到的公理。在定性研究领域，这实际上被称为**基础理论研究方法**。逆向工程的基本理论是输出推断应用程序的内部行为。当您面对一种恶意软件时，您将开始从以下混合物中提出工作假设：
- en: Prior knowledge, from recalled interactions with malware perceived as similar
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从与被视为相似的恶意软件的交互中回忆的先验知识
- en: Generalizing perceived outcomes of interactions with the malware under test
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与测试中的恶意软件的交互的感知结果的概括
- en: '**Hacker tip**:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客提示**：'
- en: It is probably not useful to label an application in an *a priori* manner. It
    may mask data to apply the *if it walks like a duck and quacks like a duck, it
    is probably a duck* axiom to the application. Especially with malware, it is likely
    that the design includes some deceptive features that are expected to set you
    off on the wrong track. Consider the trojans and rootkits that remove other trojans
    and rootkits as their first task. They are cleaning up your environment, but,
    are they really your friend?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在*a priori*的情况下给应用程序贴标签可能没有用。这可能掩盖了应用“如果它走起来像鸭子，叫起来像鸭子，那它可能就是鸭子”的公理。特别是对于恶意软件，设计可能包括一些欺骗性特征，预期会让你走上错误的道路。考虑一下作为其第一个任务删除其他特洛伊木马和rootkit的特洛伊木马和rootkit。它们正在清理你的环境，但是，它们真的是你的朋友吗？
- en: Malware applications are designed to provide outputs from inputs, but knowing
    the outputs and inputs does not truly give you a good idea of how the outputs
    are achieved. The outputs can be produced in several different ways, and you may
    find that it matters how the developer chose to create the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件应用程序旨在从输入中提供输出，但是知道输出和输入并不能真正让你了解输出是如何实现的。输出可以通过几种不同的方式产生，您可能会发现开发人员选择创建应用程序的方式很重要。
- en: One general theory of Reverse Engineering
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程的一个一般理论
- en: 'This theory was published by Lee and Johnson-Laird in 2013 in the Journal of
    Cognitive Psychology, and is useful for Information Security practitioners because
    it is shown in a Boolean system. A Boolean system is a logic gate. Either a condition
    is true or it is false. A very common definition of the problem might be as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个理论是由李和约翰逊-莱尔德在2013年发表在《认知心理学杂志》上的，对信息安全从业者有用，因为它在布尔系统中显示。布尔系统是逻辑门。条件要么为真，要么为假。问题的一个非常常见的定义可能如下：
- en: '"Any system to be reverse-engineered contains a finite number of components
    that work together in giving rise to the system''s behavior. Some of these components
    are variable, that is, they can be in more than one distinct state that affects
    the performance of the system, for example, the setting on a digital camera that
    allows for the playback or erasing of photographs. Other components of the system
    do not vary, for example, a wire leading from a switch to a bulb. The system has
    a number of distinct inputs from the user and a number of consequent outputs,
    and they are mediated by a finite number of interconnected components. In some
    systems, a component may have a potentially infinite number of particular states,
    for example, different voltages. But, for the purposes of reverse engineering,
    we assume that all variable components can be treated as having a finite number
    of distinct states, that is, the system as a whole is equivalent to a finite-state
    automaton. In other words, analogue systems can be digitized, as in digital cameras,
    CDs, and other formerly analogue devices. We also assume that the device is intended
    to be deterministic, though a nondeterministic finite-state device can always
    be emulated by one that is deterministic."'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “任何要进行逆向工程的系统都包含一定数量的组件，这些组件共同作用产生了系统的行为。其中一些组件是可变的，也就是说，它们可以处于影响系统性能的多个不同状态，例如，数码相机上允许播放或删除照片的设置。系统的其他组件不变，例如，从开关到灯泡的导线。系统具有用户的一些不同输入和一些随之而来的输出，并且它们由有限数量的相互连接的组件中介。在某些系统中，一个组件可能具有潜在的无限数量的特定状态，例如，不同的电压。但是，为了进行逆向工程，我们假设所有可变组件都可以被视为具有有限数量的不同状态，也就是说，整个系统等同于有限状态自动机。换句话说，模拟系统可以被数字化，例如数码相机、CD和其他以前的模拟设备。我们还假设设备旨在是确定性的，尽管非确定性有限状态设备总是可以被确定性设备模拟。”
- en: –(Lee & Johnson-Laird, 2013)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: –（李和约翰逊-莱尔德，2013）
- en: A theory of Reverse Engineering and its application to Boolean systems. *Journal
    of Cognitive Psychology, 25(4)*, 365-389\. [http://doi.org/10.1080/20445911.2013.782033](http://doi.org/10.1080/20445911.2013.782033).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程理论及其在布尔系统中的应用。*认知心理学杂志，25(4)*，365-389。[http://doi.org/10.1080/20445911.2013.782033](http://doi.org/10.1080/20445911.2013.782033)。
- en: 'The Lee and Johnson-Laird model uses only Boolean internal models for the possible
    internal conditions that reveal the behaviors that were noted. Since it is not
    possible to test an infinite number of inputs, it is more useful to test only
    a subset of the possible inputs and outputs. We can start with a simple example,
    for instance, this one here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 李和约翰逊-莱尔德模型仅使用布尔内部模型来表示可能的内部条件，以揭示已注意到的行为。由于不可能测试无限数量的输入，因此测试仅可能的输入和输出的子集更有用。我们可以从一个简单的例子开始，例如这里：
- en: If the malware lands on an Apple platform, and is designed to exploit a Windows
    vulnerability, it is likely not to run at all (switch 1)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果恶意软件降落在苹果平台上，并且旨在利用Windows漏洞，那么它很可能根本无法运行（开关1）。
- en: If it lands on a Windows machine, but is aimed at a vulnerability of the XP
    version, it may test for that OS version and do nothing if it finds itself on
    Windows Server 2012 (switch 2)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it happens to be Windows XP, but is patched for the sought vulnerability,
    it might also do nothing (switch 3)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it lands on a Windows XP machine that contains the sought-after unpatched
    vulnerability, it drops its payload
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/13e08369-520c-4bb4-b21b-d474c3bc2225.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Working with Boolean logic
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer programs are made up **data structures** that use conditions and decisions
    to bring the desired outputs. We will use Python notation here, as it is simple,
    and you may have seen it before. The basic data structures are as follows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Iterators such as while loops and for loops. An iterator loops as many times
    as it is told to, running other commands each time it goes around.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision points such as if structures and case structures. The previous diagram
    is of a set of nested if structures.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Boolean operators** |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| **Notation** | **Description** | **Examples** |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| X == Y | X is equivalent to Y.This is not always a numeric value set. | "shirts"
    == "hats" evaluates to FALSE."shirts" == "shirts" evaluates to TRUE.1 == 11 evaluates
    to FALSE.11 == 11 evaluates to TRUE. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| X != Y | X is not equivalent to Y. | "shirts" != "hats" evaluates to TRUE."shirts"
    != "shirts" evaluates to FALSE.1 != 11 evaluates to TRUE.11 != 11 evaluates to
    FALSE. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| X <= Y | X is smaller than OR equal to Y. | "shirts" <= "hats" evaluates
    to FALSE."shirts" <= "shirts" evaluates to TRUE.(It is counting the characters.)1
    <= 11 evaluates to TRUE.11 <= 11 evaluates to TRUE. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| X >= Y | X is greater than or equal to Y. | "shirts" >= "hats" evaluates
    to TRUE."shirts" >= "shirts" evaluates to TRUE.(It is counting the characters.)1
    <= 11 evaluates to TRUE.11 <= 11 evaluates to TRUE. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| X < Y | X is less than Y. | "shirts" < "hats" evaluates to FALSE."shirts"
    < "shirts" evaluates to FALSE.(It is counting the characters.)1 < 11 evaluates
    to TRUE.11 < 11 evaluates to FALSE. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '| X > Y | X is greater than Y. | "shirts" > "hats" evaluates to TRUE."shirts"
    > "shirts" evaluates to FALSE.(It is counting the characters.)1 > 11 evaluates
    to FALSE.11 > 11 evaluates to FALSE. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: 'The following table shows the Boolean variables that are used in logical operations
    to join elements for more complex conditions. You might want to have limit conditions
    such as the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: X and Y are both true
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X and Y are both false
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either X or Y is true
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything but X
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything but Y
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Boolean variables** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| **Variable** | **Description** | **Examples** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| AND | Produces a Boolean comparison that is only true if all of the elements
    are true. | `if ((1 == 1) and (2 == 2))` evaluates to TRUE, because all elements
    are true.`if ((1 == 1) and (2 > 2))` evaluates to FALSE, because only one of the
    elements is true.`if ((1 < 1) and (2 > 2))` evaluates to FALSE because no element
    evaluates to true. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| OR | Produces a Boolean comparison that is true if any of the elements are
    true. | `if ((1 == 1) or (2 == 2))` evaluates to TRUE, because all elements are
    true.`if ((1 == 1) or (2 > 2))` evaluates to FALSE, because only one of the elements
    is true.`if ((1 < 1) or (2 > 2))` evaluates to FALSE because no element evaluates
    to true. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| NOT | Produces a Boolean comparison that is only true if all of the elements
    are not true. | `X = 2``if not (X == 3)` evaluates to TRUE because X isn''t 3.`X
    = 3``if not (X == 3)` evaluates to FALSE because X is 3. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: 'The following code is testing the two conditions of `X` against a Boolean variable
    of NOT. You are probably starting to see how outputs can be drawn from many different
    internal coding choices. The attacker or original could be testing a condition
    by any of a number of conditions, so you have to think of all the ways that the
    output might be obtained:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5ea8c3b-dc4f-4c92-90fe-7d2ae0238c3b.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Reviewing a while loop structure
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `while` loop is explicitly started and stopped by true/false choice points.
    These can look very complicated, but they resolve to a limited set of tests for
    a single condition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This Python 3 loop will print the value of `X` over and over until it reaches
    10, then stop. It would work exactly the same if we said `while X < Y`, because
    the loop structure is testing `X` as it is incremented. A more complicated loop,
    using a random number for the incrementor element, might go on for much longer
    (or not) before it randomly hits on a value of `X` that was the equivalent of
    `Y`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38da95fe-217a-4e8b-befd-5c08d737b285.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'It is obvious that the program is testing the looping condition each time.
    Here is an example of using that random `X` value. First, the `X` value is chosen,
    and then the `print (X)` command is run twice. Since `X` was only set once in
    the first line, it didn''t change in the two print commands. When the value of
    `X` was reset, it printed a different value. The condition was that `X` would
    not equal `Y`. We set the value of `Y` a few lines up, so it does not need to
    be reset to run this example. The reason why `X` returned only once was that the
    second time through, `X` was randomly set to `11`. The odds of it being set to
    `11` from the random draw was 1 out of eleven, a far better chance than your probability
    of winning the Powerball lottery:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce8da739-431f-4bc7-a4b7-5e593a227eed.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'If we run the loop again, it might run more times, as it randomly avoids a
    value of `X` that''s equivalent to `Y`. Again, it does not print the value of
    `X = 11`, because that is precluded by the `while` loop condition:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6d296a-3de0-446d-964f-4ff56f7a5caa.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: Reviewing the for loop structure
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `for` loop doesn''t need an incrementor because it builds the range into
    the condition, as contrasted with a `while` loop, which only includes a limit
    beyond which the loop will not run. Using Python notation, the following code
    shows what happens if you start with an `X` value of `0` and a range from one
    to eleven. The preset value of `X` is not important to the `for` loop iteration.
    It applies all values to `X` that it tests:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b3c08e1-a9a5-4561-a493-08ed2e3e8596.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'We are starting with `X` set to `100`, but the `for` loop takes the `X` value
    from its own condition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33b6b841-da20-4bf7-b6c7-a569fcb293b7.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'If you really want `X` to remain a constant, you can use it as the base of
    a different range, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cdd090c-6062-468f-9498-a0ebf506060a.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Understanding the decision points
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `if` structure is a binary decision: either yes or no. A light switch on
    the wall is a physical example of an if structure. If the switch is in one position,
    the lights are on, and if it is in the other position, the lights are off:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b04ab4ba-4a4a-4740-9377-35a245614bb0.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'A case structure is a decision structure with more than one right answer, more
    than one YES, and not a single NO. An example of this might be an ice cream dispenser
    with three flavors—chocolate, strawberry, and vanilla. If you do not want ice
    cream, you do not even approach the machine. You have three choices, and they
    are all correct:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b7e5a48-6bd6-4430-8d71-5b5c83905c12.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Practicing Reverse Engineering
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since knowing that the inputs and outputs cannot, with any surety, provide you
    with a true picture of the internal construction of the application you want to
    reverse-engineer, let's look at some helpful utilities from Kali Linux that might
    make it easier. We will look at three debuggers, one disassembly tool, and one
    miscellaneous Reverse Engineering tool.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We will show the usage and output from two Linux-based debuggers, **Valgrind**
    and **EDB-Debugger**, and then a similar output from a Windows-only debugger,
    **OllyDbg**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The disassembler is **JAD**, which is a Java decompiler:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b954cd7-29ad-45a7-8a63-2e6848e62f1e.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: Using debuggers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is debugging? The honor of coining the term is often erroneously attributed
    to Admiral Grace Hopper, on the occasion of her team members finding a physical
    (but dead) moth stuck in a relay inside a Mark II computer at Harvard University.
    The term may actually come from Thomas Edison as he mentioned and defined the
    term as *little faults and difficulties*. In software development, a bug is usually
    a logic error, and not a typographical error in the code. Typos usually stop the
    code from compiling at all, so they do not get out of the developers' lab. Logic
    errors do not stop the program from compiling, but they may cause a failure in
    the output or an unexpected behavior when the program is initiated. Another word
    often used synonymously with **bug** is **defect**. **Technical debt** in a project
    is the number of defects that are unfixed in a project. Different project managers
    have different levels of tolerance for unfixed bugs. Many malware packages have
    several show-stopping bugs in their released versions, but some of the more sophisticated
    recent malware packages appear to be very low in technical debt.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Debuggers allow you to watch the behavior of an application in a step-wise manner.
    You can see what gets put into memory, what system calls are made, and how the
    application pulls and releases memory. The main reason we use debuggers is to
    check the behavior of programs for which we have access to the source code. The
    reason for this is that the programs we are most likely to debug are code that
    was made in our own workshops. This does not quite constitute a code security
    audit, but it can help a lot to find where a program is leaking memory, and how
    well it cleans up its used memory. Many programs display status reports on the
    command line if you start them that way, and these are internal debugging information.
    This could be cleaned up after release of the application, but in most use cases,
    the end user never sees any of it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Using the Valgrind debugger
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programs generally reserve memory from the total RAM available. One program
    we have found useful for debugging on the command line is `valgrind`, which is
    not in the default Kali install. We add it when we find we need to do preliminary
    debugging. For instance, at one time, a version of [http://www.openoffice.org/](http://www.openoffice.org/),
    the free, open source office suite, had a bug in Linux that was allowing the install,
    but failed to run the program. It just seized up at the display of the initial
    splash screen. Running the following command showed that it was looking for a
    file that did not exist. Rather than just sending a bug report, and hoping for
    a solution to be added as a patch to the source code, we just added the missing
    file as a blank text file. This allowed OpenOffice to start. The OpenOffice developers
    added a patch later that removed the bug, but we didn''t have to wait for it.
    As an example of `valgrind`, here is the command-line code to run a test on `gedit`,
    a text editor:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It takes much longer to start a program when it is encased in a debugger, and
    the entire output will go to the log file that's been designated. Once the program
    is open, you can close the program by pressing *Ctrl* + *C* on the command line,
    or if the application under test has a GUI interface, you can close the window,
    and `valgrind` will shut down after watching the application you are testing go
    down.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, there are over 600 lines of output from the debugger, and
    you are going to need to use a more user-friendly debugger to find more useful
    information. Keeping in mind that gedit is a very mature program and that it works
    flawlessly every time we use it to edit text files, it still has 24 memory errors
    noted by `valgrind` in the undemanding use case of opening gedit, typing a few
    characters, and closing without saving the new document:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8051f1c-ef02-4c49-abf4-92f140f6ab51.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: Using the EDB-Debugger
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The EDB-Debugger is a version of a Windows application called the Olly debugger.
    The EDB-Debugger has the following features:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: A GUI interface, which the developers call intuitive
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard debugging operations (step-into/step-over/run/break)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More unusual conditional breakpoints
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A debugging core that is implemented as a plugin (you can drop in replacement
    core plugins)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some platforms may have several debugging APIs available, in which case you
    may have a plugin that implements any of them
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic instruction analysis
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View/Dump memory regions
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective address inspection
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data dump view is tabbed, allowing you to have several views of memory open
    at the same time that you can quickly switch between
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the importing and generation of symbol maps
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has plugins to extend usability
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EDB-Debugger is designed to debug Linux applications, and we will look at the
    same application, gedit, with EDB-Debugger. The GUI interface shows the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The application being tested and the process ID in the title bar
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory location
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General purpose binary command map
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bookmarks: Places of interest in the code'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers set aside for data (specifically for the marked line in 2/3)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data dump: Memory locations and content'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory Stack data
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GUI can be seen in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/684a2a3c-6157-4e31-ae84-f7798c699f06.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: EDB-Debugger symbol mapper
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EDB-Debugger can give you a symbol map via the following command-line entry:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The symbol table maps functions, lines, or variables in a program. In the case
    of gedit, the symbol table looks as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c681ada7-4a79-4293-a374-32e87c12de7b.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Running OllyDbg
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are running the 64-bit version of Kali Linux 2.0, you will first need
    to update Kali. It is missing the 32-bit wine infrastructure, and wine doesn''t
    even want to start without that. Luckily, Kali Linux gives you a useful error
    message. You just have to copy the quoted part of the error message and run it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dce4dcba-bf1e-494a-ae00-d1dea21d9a93.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'The OllyDbg GUI window does look a lot like EDB-Debugger, though it is graphically
    a little uglier. We are looking at `notepad.exe`, which is a Windows-only editor,
    similar to a cut-down version of gedit. The window is broken up into the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The application being tested in the title bar
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory location
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol mapping
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data dump: Memory locations and content'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory Stack data
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you open an executable file (EXE, PIF, or COM), it shows you the entire
    running program:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f1acd3b-5b8e-456f-bdee-b5ee6df4fa63.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: You could choose to run OllyDbg on your target Windows machine, to look at an
    ongoing infection by copying its folder to a flash drive and carrying the flash
    drive over to the infected machine. You could also install Kali Linux to a bootable
    flash drive as we mentioned in [Chapter 1](b18fe074-058f-410f-86de-77499a727708.xhtml),
    *Choosing Your Distro*, and run Kali directly on the infected machine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to disassemblers
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A disassembler takes compiled binary code and displays the assembly code. This
    is similar to what the debuggers can show you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Running JAD
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAD is a Java Decompiler that's included with Kali Linux, and it seems like
    a useful tool for analyzing potentially dangerous Java applets that come from
    web pages. The biggest problem with it is that it has not had a maintainer since
    2011, and so is difficult to find, except in the Kali repository and at Tomas
    Varaneckas's blog page, *Jad Decompiler Download Mirror* ([http://varaneckas.com/jad/](http://varaneckas.com/jad/)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a page from the JAD help file, which you can access from the
    main menu or by typing `jad` in the command line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/567fb42e-0b7f-4c8b-809c-e5590f6e153d.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: For a short example of what it looks like to use `jad`, we created a Java class
    for you. The following three illustrations are of the following
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Original source code (not always available)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running `jad`
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decompiled source
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, here is the source code for a little Java class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfc15700-4027-497a-9286-25dc0c2f0949.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'The application is running. We showed the result of using the inline help (type
    a question mark instead of one of the letter choices) just to show the level of
    detail that''s available. We then chose `a`, and `jad` overwrote the source. This
    will not be a problem when you have only the compiled class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c44bb035-7c44-4db7-8979-3f9e37c34738.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Finally, here is the decompiled source code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dc44f26-9e68-4174-8de9-eb155d7f2ce9.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Creating your own disassembling code with Capstone
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Capstone decompiling engine is well maintained, and has a simple API. The
    basic Capstone libraries come as default on Kali Linux, and you can build your
    own frontend using any language with which you are familiar. We are using Python,
    as it is our go-to scripting language. Using the `aptitude search <keyword>` command
    structure, you can make sure that you have the available packages and can see
    the status of the packages. In this case, you can see that `p` in the first column
    means that there is a package available, and `i` means that it is installed. The
    `A` in the second column shows that the package was installed automatically, and
    is probably a dependency for some other package. We have chosen to `install libcapstone-dev`
    for the 64-bit architecture we have on the Kali instance, in case we want to attempt
    to customize the behavior of Capstone. You don''t need to do this to use Capstone:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a2332d-611a-4d8a-b514-151fa6d53b49.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'Here is a simple disassembler script based on examples from [http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html).
    This could be far more automated, but for the sake of this example, the hexcode
    is hardcoded into the script:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ea09aad-578b-452a-bb66-ca1bfe93bf07.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Some miscellaneous Reverse Engineering tools
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a large category of miscellaneous Reverse Engineering tools, listed
    as such in the Kali Linux 1.x menu, but not categorized in the Kali Linux 2.0
    menu. Rather than randomly picking a couple of these, we are showing you an integrated
    suite of tools led by Radare2.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Running Radare2
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can start Radare2 by clicking the menu link under Reverse Engineering.
    You are probably more comfortable with the command line now, so you will probably
    want to open it directly in the command line. Open the command-line launcher by
    typing the keyboard shortcut, *Alt* + *F2*. Then, the following command opens
    the program''s help file in a new Terminal window:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break this command down for you:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '`bash` opens a Bash shell.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c` directs dash to read from a command string, which follows in double quotes,
    instead of waiting for standard input from the keyboard.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radare2` is the application we are opening.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h` is the option that opens a help file in the Terminal window, if one exists.
    `--help` is the long form of that option (these options are available on almost
    every Linux command-line tool).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Radare2 is an advanced command-line hexadecimal editor, disassembler, and debugger.
    Radare2 ([http://radare.org](http://radare.org)) states that Radare2 is a portable
    reversing framework with the following features:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Disassembles (and assemble for) many different architectures
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugs with local native and remote debuggers (gdb, rap, webui, r2pipe, winedbg,
    and windbg)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs on Linux, *BSD, Windows, OSX, Android, iOS, Solaris, and Haiku
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs forensics on filesystems and data carving
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is scripted in Python, JavaScript, Go, and more
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports collaborative analysis using the embedded web server
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizes data structures of several file types
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patches programs to uncover new features or fix vulnerabilities
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses powerful analysis capabilities to speed up reversing
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aids in software exploitation
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/63b6c01b-49ad-48cf-a871-5ecb87bcc76d.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Radare2 is the tip of a framework that is integrated with ten plugins and several
    other applications. To keep the PG rating, we fuzzed out the last plugin name:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Radare2是一个集成了十个插件和其他几个应用程序的框架的顶端。为了保持PG评级，我们模糊了最后一个插件的名称：
- en: '![](img/610b1ed6-59c0-4d28-8ca1-bcf5c48b2212.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/610b1ed6-59c0-4d28-8ca1-bcf5c48b2212.png)'
- en: The additional members of the Radare2 tool suite
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Radare2工具套件的其他成员
- en: We will discuss additional members of the Radare2 tool suite in the following
    sections.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分讨论Radare2工具套件的其他成员。
- en: Running rasm2
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rasm2
- en: 'rasm2 `/usr/bin/rasm2` is a command-line assembler/disassembler for several
    architectures, for example, Intel x86 and x86-64, MIPS, ARM, PowerPC, Java, and
    MSIL. This may be your go-to for disassembly when JAD is no longer available:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: rasm2 `/usr/bin/rasm2`是一个用于多种架构的命令行汇编器/反汇编器，例如Intel x86和x86-64、MIPS、ARM、PowerPC、Java和MSIL。当JAD不再可用时，这可能是你的反汇编工具：
- en: '![](img/1e81f6b2-70d4-496a-8af9-71e919d37614.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e81f6b2-70d4-496a-8af9-71e919d37614.png)'
- en: Running rahash2
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rahash2
- en: 'rahash2 `/usr/bin/rahash` is a block-based hash tool, which supports many algorithms,
    for example, MD4, MD5, CRC16, CRC32, SHA1, SHA256, SHA384, SHA512, par, xor, xorpair,
    mod255, hamdist, and entropy. You can use `rahash2` to check the integrity of,
    and track changes to, files, memory dumps, and disks:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: rahash2 `/usr/bin/rahash`是一个基于块的哈希工具，支持许多算法，例如MD4、MD5、CRC16、CRC32、SHA1、SHA256、SHA384、SHA512、par、xor、xorpair、mod255、hamdist和entropy。你可以使用`rahash2`来检查文件、内存转储和磁盘的完整性，并跟踪变化：
- en: '![](img/36e0dc00-57dc-44b5-a869-e3fda48c622e.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36e0dc00-57dc-44b5-a869-e3fda48c622e.png)'
- en: 'The following is an example of testing the sha256 hash for a small file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对小文件进行sha256哈希测试的示例：
- en: '![](img/68ab55b7-b278-4ab6-bab6-728074a41cd5.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/68ab55b7-b278-4ab6-bab6-728074a41cd5.png)'
- en: Running radiff2
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行radiff2
- en: 'radiff2 is a binary utility that uses various algorithms to compare files.
    It supports byte-level or delta comparisons for binary files, and code analysis
    comparisons to find changes in code blocks produced by a `radare` code analysis.
    The following is a test that''s comparing two states of the `/var/log/message`
    log over the course of a couple of seconds. This is a comparison at the bit level,
    for random changes:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: radiff2是一个使用各种算法比较文件的二进制实用程序。它支持二进制文件的字节级或增量比较，以及代码分析比较，以找到`radare`代码分析产生的代码块中的变化。以下是一个比较`/var/log/message`日志在几秒钟内的两个状态的测试。这是一个在位级别进行比较的测试，用于随机更改：
- en: '![](img/8c64b9c4-412b-4e9b-8d44-4ff73b16ebc2.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c64b9c4-412b-4e9b-8d44-4ff73b16ebc2.png)'
- en: Running rafind2
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rafind2
- en: 'rafind2 is designed to search for patterns in files. In the following example,
    `rafind2 -s "string searched" <file>` shows you what we can see when we search
    for a string that we know to exist, and one we know to be absent:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: rafind2旨在在文件中搜索模式。在下面的示例中，`rafind2 -s "string searched" <file>`向我们展示了当我们搜索一个我们知道存在的字符串和一个我们知道不存在的字符串时，我们能看到什么：
- en: '![](img/48233c42-8587-4854-81d2-93ba7cb3c44e.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/48233c42-8587-4854-81d2-93ba7cb3c44e.png)'
- en: Running rax2
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行rax2
- en: 'rax2 is a mathematical expression evaluator for the command line. You can do
    many conversion operations, including one that is useful for making base conversions
    between floating point values, hexadecimal representations, hex-pair strings to
    ASCII, octal to integer, and so on. It also supports endianness settings and can
    be used as an interactive shell if no arguments are given:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: rax2是一个命令行的数学表达式求值器。你可以进行许多转换操作，包括对浮点值、十六进制表示、十六进制对字符串到ASCII的基数转换等等。它还支持字节序设置，如果没有给出参数，可以用作交互式shell：
- en: '![](img/c7cd4858-5ad6-43cc-b5ca-d02cb126cab7.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7cd4858-5ad6-43cc-b5ca-d02cb126cab7.png)'
- en: 'Here are some example conversions with rax2:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是rax2的一些示例转换：
- en: Decimal to hexadecimal
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制转十六进制
- en: Hexadecimal to decimal
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制转十进制
- en: Octal to hexadecimal
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制转十六进制
- en: Hashing two strings
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对两个字符串进行哈希
- en: Hashing a single string
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对单个字符串进行哈希
- en: '![](img/c6307c77-db85-484f-a975-a99077185542.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6307c77-db85-484f-a975-a99077185542.png)'
- en: Stress testing Windows
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力测试Windows
- en: Next, let's look at some tools that will make your Windows machine cry. Stress
    testing a system can show you just how much of a load your machine and network
    will carry. Here's a little experiment you can also run. Set up a service on a
    Windows machine and the same type of service on a Linux machine and see which
    can handle the loads better. You will be surprised with the outcome. The outcome
    may make you ask *why would I ever use Windows in the first place?*
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一些会让你的Windows机器哭泣的工具。对系统进行压力测试可以显示出你的机器和网络能承受多大负荷。你也可以进行一个小实验。在Windows机器上设置一个服务，在Linux机器上设置相同类型的服务，看看哪个能更好地处理负载。结果可能会让你感到惊讶。结果可能会让你问*为什么我要使用Windows？*
- en: '**Hacker''s tip**:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑客提示**：'
- en: Use Linux as your daily driver OS—I do!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将Linux作为你的日常驱动操作系统——我就是！
- en: Dealing with Denial
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理拒绝
- en: '**ATK6-Denial6** is an IPv6 network stress tester that sends packets to a target
    host and beats them into submission. This is the help file for ATK6-Denial6:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**ATK6-Denial6**是一个IPv6网络压力测试工具，它向目标主机发送数据包并将其击败。这是ATK6-Denial6的帮助文件：'
- en: '![](img/6ec7068c-d795-4824-9180-9f6b7bb96736.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ec7068c-d795-4824-9180-9f6b7bb96736.png)'
- en: 'The following screenshot is the `nmap -A` reading for the vulnerable Windows
    7 target machine. We want to find out if it has ports open, and which ports they
    are. We can see that ports `139`, `445`, `2869`, `5357`, and `10243` are open.
    The big problem with this tool is that the test network is IPv4:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图是对易受攻击的Windows 7目标机器进行的`nmap -A`读取。我们想要找出它是否有开放的端口，以及它们是哪些端口。我们可以看到端口`139`、`445`、`2869`、`5357`和`10243`是开放的。这个工具的一个大问题是测试网络是IPv4：
- en: '![](img/290e14d3-7991-42ad-b379-31dbb5d56cdf.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/290e14d3-7991-42ad-b379-31dbb5d56cdf.png)'
- en: Let's find a tool with which we can attack our IPv4 network.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找一个可以攻击我们的IPv4网络的工具。
- en: Putting the network under Siege
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让网络陷入围攻
- en: Siege is a web stress tester. Siege is a multi-threaded HTTP load testing and
    benchmarking utility. It was designed to let web developers measure the performance
    of their code under pressure. It allows you to hit a web server with a configurable
    number of concurrent simulated users.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'It is those users who place the web server *under siege*. Performance measures
    include the following, which are quantified and reported at the end of each run:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Elapsed time
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total data transferred
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server response time
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction rate
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughput
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK return count
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their meaning and significance are discussed later. Siege essentially has three
    modes of operation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Regression (when invoked by bombardment)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet simulation
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute force
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The formats for using siege are as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '`siege [options]`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`siege [options] [url]`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`siege -g [url]`'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c7a27efd-88fe-4af4-8294-524938eca229.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Siege imitated 15 users going to the website on the Windows 7 target machine.
    The performance was not all that bad, all in all. There were 8,072 hits on the
    site in four and a half minutes. The Windows 7 target maintained 100% availability
    with better than 1/100th of a second response time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your Siege engine
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What do you think would happen if we increase the number of besiegers to 10,000?
    The configuration is `at /usr/bin/siege.config`. When we run that on the command
    line, it tells us we already have a local configuration file at `/root/siegerc`,
    so let''s go look at that:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ec4021f-e519-44c5-bd87-bc4b7ab93227.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: To edit `/root/.siegerc`, we can use the command line or the Run Launcher (*Alt*
    + *F2*) to enter the name of our favorite text editor. Here, we are going to use
    gedit, so enter gedit `/root/.siegerc` . Alternatively, we could find gedit in
    the `Usual Applications`/`Accessories` folder, and open the file open dialog and
    turn on hidden files, then find `.siegerc` in the `/root` directory. You are probably
    starting to see the reason Linux administrators like the command line so much.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'On line `162` of the configuration file, you will find the number of concurrent
    users. The current default is `15`, but let''s change that to 10,000\. Let''s
    see if we can crack this baby:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df072eea-fec9-4844-b93f-619d19719d7e.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'After forcing the Kali instance to close, let''s try it with fewer besiegers.
    The larger the number of concurrent users, the more RAM it uses on your Kali machine,
    too:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8b800dd-f2d4-40c8-b47f-f1c4c8560daa.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Using 625 besiegers, we got a solid result without crashing the testing machine.
    In-between, we tested 5,000, 2,500, and 1,250, but they all crashed the machine.
    If you have a sense of fun, you could test higher numbers, such as 940, 1,090,
    and so on. The resources available on your testing machine will rule the number
    of besiegers you can employ.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reverse Engineering to get a definitive answer as to the actual code for a complicated
    application is unlikely, since there are many ways to achieve the same output
    via loops or choice structures. It is easier to get a statistical list of possible
    treatments of the inputs by testing several of them. You are likely to get more
    detail from looking at the assembly code outputs from **EDB-Debugger** or **OllyDbg**.
    As you have probably noticed, the assembly code for Linux and for Windows applications
    is basically identical. High-level languages such as C and C++ are just ways to
    get at the assembly code that can be easily converted to machine code to tell
    the machine what to do.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing your Windows hosts comes down to checking their ability to take
    in many inputs over a short period of time, on any open ports whatsoever. Remember,
    when stress testing, you will make a lot of noise on the network, and any intrusion
    detection tool, configured properly, will notice your attack. You may also knock
    the target machine off the network, so you had better alert the management before
    you start your test.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: As this is the last chapter, we hope that you have enjoyed this book and we
    hope that you have learned something to better your understanding of penetration
    testing and exploitation of the Windows operating system.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是最后一章，我们希望您喜欢这本书，也希望您学到了一些东西，以便更好地理解渗透测试和对Windows操作系统的利用。
- en: Thank you for reading this book.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读本书。
- en: Further reading
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**More reading on the Radare2 Tool Suite**: [https://rada.re/r/](https://rada.re/r/)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关Radare2工具套件的更多阅读**：[https://rada.re/r/](https://rada.re/r/)'
- en: '**Radare2 Cheatsheets**: [https://github.com/pwntester/cheatsheets/blob/master/radare2.md](https://github.com/pwntester/cheatsheets/blob/master/radare2.md)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Radare2备忘单**：[https://github.com/pwntester/cheatsheets/blob/master/radare2.md](https://github.com/pwntester/cheatsheets/blob/master/radare2.md)'
- en: '**More on EDB-Debugger**: [https://github.com/eteran/edb-debugger](https://github.com/eteran/edb-debugger)
    and [http://codef00.com/projects](http://codef00.com/projects)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关EDB-Debugger的更多信息**：[https://github.com/eteran/edb-debugger](https://github.com/eteran/edb-debugger)
    和 [http://codef00.com/projects](http://codef00.com/projects)'
- en: '**More on OllyDbg**: [http://www.ollydbg.de/](http://www.ollydbg.de/)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关OllyDbg的更多信息**：[http://www.ollydbg.de/](http://www.ollydbg.de/)'
- en: '**More on Capstone**: [http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关Capstone的更多信息**：[http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html)'
