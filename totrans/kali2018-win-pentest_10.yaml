- en: Reverse Engineering and Stress Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to know how malware will behave, the easiest way to achieve that
    goal is to let it run rampant in your network and track its behavior in the wild.
    This is not how you want to get to understand malware behavior. You might easily
    miss something that your network environment doesn't enact, and then you'll have
    to remove the malware from all of the machines in your network. Kali has some
    selected tools to help you do that. This chapter also covers stress testing your
    Windows server or application. This is a great idea, if you want to discover how
    much DDoS will turn your server belly-up. This chapter is the beginning of how
    to develop an anti-fragile, self-healing Windows network.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a test environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse Engineering theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Boolean logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing Reverse Engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stress testing your Windows machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are some changes in the Reverse Engineering tools that are available in
    Kali Linux 2.0 compared to the tools in Kali Linux 1.x. Some tools have disappeared
    from the menu structure, and you can use the last section of [Chapter 6](7b8a5720-a83e-426c-8d7e-76fb427fc041.xhtml), *NetBIOS
    Name Service and LLMNR – Obsolete but Still Deadly*, to put them back if you wish.
    Some tools have not been included in Kali Linux 2 at all, though there are traces
    of them here and there. The following table shows these changes.
  prefs: []
  type: TYPE_NORMAL
- en: Tools showing full paths are not in the default Kali 2.0 menu at all, and the
    NASM Shell, a part of the Metasploit Framework suite of tools, was not in the
    Kali 1.x menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows you the difference between the tools in Kali 1.x
    and 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffda7889-19ed-40d0-8120-33d91c492340.png)'
  prefs: []
  type: TYPE_IMG
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A running Kali Linux machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running copy of a Windows operating system (this can be a VM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a test environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing your test environment requires virtual machine examples of all of
    the Windows operating systems that you are testing against. For instance, an application
    developer might be running very old browser/OS test machines to see what breaks
    for customers running antique hardware. In this example, we are running Windows
    XP, Windows 7, and Windows 10\. We are using Oracle VirtualBox for desktop virtualization,
    but if you are more comfortable using VMWare, then use that instead. It is important
    to use machines that you can isolate from the main network, just in case the malware
    acts as it should, and attempts to infect the surrounding machines.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your victim machine(s)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you already have Windows VMs set up for some other purpose, you can either
    clone them (probably the safest option) or run them from a snapshot (this is the
    fastest way to set up). These machines should not be able to access the main network
    after you have built them, and you should probably set them up to communicate
    only with an internal network.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your testing environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bring up your Kali VM
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your Kali instance can talk to the internet, for ease of getting updates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your Kali instance can talk to your host machine
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bring up your target Windows instances
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your Windows victims are not able to contact the internet, or your
    private Ethernet LAN, to avoid unexpected propagation of malware
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The three virtual machines on our test network are on a host-only network inside
    Oracle VirtualBox. The DHCP is provided by the host (`192.168.56.100`), and the
    three testing network machines are `101`, `102`, and `103`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf29f285-779a-40a1-b74a-0e24abb9d844.png)'
  prefs: []
  type: TYPE_IMG
- en: Reverse Engineering theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Theory scares IT professionals for some reason. This is not truly warranted,
    as theory is the underlying bedrock of all of your troubleshooting. It may be
    the axioms you have learned through your X years of hard-knocks trial and error.
    In the land of qualitative research, this is literally called the **Grounded Theory
    Research Method**. The base theory for Reverse Engineering is that the outputs
    infer the interior behavior of the application. When you are faced with a piece
    of malware, you are going to start making working hypotheses from a mixture of
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prior knowledge, from recalled interactions with malware perceived as similar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizing perceived outcomes of interactions with the malware under test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hacker tip**:'
  prefs: []
  type: TYPE_NORMAL
- en: It is probably not useful to label an application in an *a priori* manner. It
    may mask data to apply the *if it walks like a duck and quacks like a duck, it
    is probably a duck* axiom to the application. Especially with malware, it is likely
    that the design includes some deceptive features that are expected to set you
    off on the wrong track. Consider the trojans and rootkits that remove other trojans
    and rootkits as their first task. They are cleaning up your environment, but,
    are they really your friend?
  prefs: []
  type: TYPE_NORMAL
- en: Malware applications are designed to provide outputs from inputs, but knowing
    the outputs and inputs does not truly give you a good idea of how the outputs
    are achieved. The outputs can be produced in several different ways, and you may
    find that it matters how the developer chose to create the application.
  prefs: []
  type: TYPE_NORMAL
- en: One general theory of Reverse Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This theory was published by Lee and Johnson-Laird in 2013 in the Journal of
    Cognitive Psychology, and is useful for Information Security practitioners because
    it is shown in a Boolean system. A Boolean system is a logic gate. Either a condition
    is true or it is false. A very common definition of the problem might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Any system to be reverse-engineered contains a finite number of components
    that work together in giving rise to the system''s behavior. Some of these components
    are variable, that is, they can be in more than one distinct state that affects
    the performance of the system, for example, the setting on a digital camera that
    allows for the playback or erasing of photographs. Other components of the system
    do not vary, for example, a wire leading from a switch to a bulb. The system has
    a number of distinct inputs from the user and a number of consequent outputs,
    and they are mediated by a finite number of interconnected components. In some
    systems, a component may have a potentially infinite number of particular states,
    for example, different voltages. But, for the purposes of reverse engineering,
    we assume that all variable components can be treated as having a finite number
    of distinct states, that is, the system as a whole is equivalent to a finite-state
    automaton. In other words, analogue systems can be digitized, as in digital cameras,
    CDs, and other formerly analogue devices. We also assume that the device is intended
    to be deterministic, though a nondeterministic finite-state device can always
    be emulated by one that is deterministic."'
  prefs: []
  type: TYPE_NORMAL
- en: –(Lee & Johnson-Laird, 2013)
  prefs: []
  type: TYPE_NORMAL
- en: A theory of Reverse Engineering and its application to Boolean systems. *Journal
    of Cognitive Psychology, 25(4)*, 365-389\. [http://doi.org/10.1080/20445911.2013.782033](http://doi.org/10.1080/20445911.2013.782033).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lee and Johnson-Laird model uses only Boolean internal models for the possible
    internal conditions that reveal the behaviors that were noted. Since it is not
    possible to test an infinite number of inputs, it is more useful to test only
    a subset of the possible inputs and outputs. We can start with a simple example,
    for instance, this one here:'
  prefs: []
  type: TYPE_NORMAL
- en: If the malware lands on an Apple platform, and is designed to exploit a Windows
    vulnerability, it is likely not to run at all (switch 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it lands on a Windows machine, but is aimed at a vulnerability of the XP
    version, it may test for that OS version and do nothing if it finds itself on
    Windows Server 2012 (switch 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it happens to be Windows XP, but is patched for the sought vulnerability,
    it might also do nothing (switch 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it lands on a Windows XP machine that contains the sought-after unpatched
    vulnerability, it drops its payload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/13e08369-520c-4bb4-b21b-d474c3bc2225.png)'
  prefs: []
  type: TYPE_IMG
- en: Working with Boolean logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer programs are made up **data structures** that use conditions and decisions
    to bring the desired outputs. We will use Python notation here, as it is simple,
    and you may have seen it before. The basic data structures are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators such as while loops and for loops. An iterator loops as many times
    as it is told to, running other commands each time it goes around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision points such as if structures and case structures. The previous diagram
    is of a set of nested if structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Boolean operators** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Notation** | **Description** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| X == Y | X is equivalent to Y.This is not always a numeric value set. | "shirts"
    == "hats" evaluates to FALSE."shirts" == "shirts" evaluates to TRUE.1 == 11 evaluates
    to FALSE.11 == 11 evaluates to TRUE. |'
  prefs: []
  type: TYPE_TB
- en: '| X != Y | X is not equivalent to Y. | "shirts" != "hats" evaluates to TRUE."shirts"
    != "shirts" evaluates to FALSE.1 != 11 evaluates to TRUE.11 != 11 evaluates to
    FALSE. |'
  prefs: []
  type: TYPE_TB
- en: '| X <= Y | X is smaller than OR equal to Y. | "shirts" <= "hats" evaluates
    to FALSE."shirts" <= "shirts" evaluates to TRUE.(It is counting the characters.)1
    <= 11 evaluates to TRUE.11 <= 11 evaluates to TRUE. |'
  prefs: []
  type: TYPE_TB
- en: '| X >= Y | X is greater than or equal to Y. | "shirts" >= "hats" evaluates
    to TRUE."shirts" >= "shirts" evaluates to TRUE.(It is counting the characters.)1
    <= 11 evaluates to TRUE.11 <= 11 evaluates to TRUE. |'
  prefs: []
  type: TYPE_TB
- en: '| X < Y | X is less than Y. | "shirts" < "hats" evaluates to FALSE."shirts"
    < "shirts" evaluates to FALSE.(It is counting the characters.)1 < 11 evaluates
    to TRUE.11 < 11 evaluates to FALSE. |'
  prefs: []
  type: TYPE_TB
- en: '| X > Y | X is greater than Y. | "shirts" > "hats" evaluates to TRUE."shirts"
    > "shirts" evaluates to FALSE.(It is counting the characters.)1 > 11 evaluates
    to FALSE.11 > 11 evaluates to FALSE. |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows the Boolean variables that are used in logical operations
    to join elements for more complex conditions. You might want to have limit conditions
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: X and Y are both true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: X and Y are both false
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either X or Y is true
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything but X
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything but Y
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Boolean variables** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Variable** | **Description** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| AND | Produces a Boolean comparison that is only true if all of the elements
    are true. | `if ((1 == 1) and (2 == 2))` evaluates to TRUE, because all elements
    are true.`if ((1 == 1) and (2 > 2))` evaluates to FALSE, because only one of the
    elements is true.`if ((1 < 1) and (2 > 2))` evaluates to FALSE because no element
    evaluates to true. |'
  prefs: []
  type: TYPE_TB
- en: '| OR | Produces a Boolean comparison that is true if any of the elements are
    true. | `if ((1 == 1) or (2 == 2))` evaluates to TRUE, because all elements are
    true.`if ((1 == 1) or (2 > 2))` evaluates to FALSE, because only one of the elements
    is true.`if ((1 < 1) or (2 > 2))` evaluates to FALSE because no element evaluates
    to true. |'
  prefs: []
  type: TYPE_TB
- en: '| NOT | Produces a Boolean comparison that is only true if all of the elements
    are not true. | `X = 2``if not (X == 3)` evaluates to TRUE because X isn''t 3.`X
    = 3``if not (X == 3)` evaluates to FALSE because X is 3. |'
  prefs: []
  type: TYPE_TB
- en: 'The following code is testing the two conditions of `X` against a Boolean variable
    of NOT. You are probably starting to see how outputs can be drawn from many different
    internal coding choices. The attacker or original could be testing a condition
    by any of a number of conditions, so you have to think of all the ways that the
    output might be obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5ea8c3b-dc4f-4c92-90fe-7d2ae0238c3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Reviewing a while loop structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `while` loop is explicitly started and stopped by true/false choice points.
    These can look very complicated, but they resolve to a limited set of tests for
    a single condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This Python 3 loop will print the value of `X` over and over until it reaches
    10, then stop. It would work exactly the same if we said `while X < Y`, because
    the loop structure is testing `X` as it is incremented. A more complicated loop,
    using a random number for the incrementor element, might go on for much longer
    (or not) before it randomly hits on a value of `X` that was the equivalent of
    `Y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38da95fe-217a-4e8b-befd-5c08d737b285.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is obvious that the program is testing the looping condition each time.
    Here is an example of using that random `X` value. First, the `X` value is chosen,
    and then the `print (X)` command is run twice. Since `X` was only set once in
    the first line, it didn''t change in the two print commands. When the value of
    `X` was reset, it printed a different value. The condition was that `X` would
    not equal `Y`. We set the value of `Y` a few lines up, so it does not need to
    be reset to run this example. The reason why `X` returned only once was that the
    second time through, `X` was randomly set to `11`. The odds of it being set to
    `11` from the random draw was 1 out of eleven, a far better chance than your probability
    of winning the Powerball lottery:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce8da739-431f-4bc7-a4b7-5e593a227eed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we run the loop again, it might run more times, as it randomly avoids a
    value of `X` that''s equivalent to `Y`. Again, it does not print the value of
    `X = 11`, because that is precluded by the `while` loop condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6d296a-3de0-446d-964f-4ff56f7a5caa.png)'
  prefs: []
  type: TYPE_IMG
- en: Reviewing the for loop structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `for` loop doesn''t need an incrementor because it builds the range into
    the condition, as contrasted with a `while` loop, which only includes a limit
    beyond which the loop will not run. Using Python notation, the following code
    shows what happens if you start with an `X` value of `0` and a range from one
    to eleven. The preset value of `X` is not important to the `for` loop iteration.
    It applies all values to `X` that it tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b3c08e1-a9a5-4561-a493-08ed2e3e8596.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are starting with `X` set to `100`, but the `for` loop takes the `X` value
    from its own condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33b6b841-da20-4bf7-b6c7-a569fcb293b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you really want `X` to remain a constant, you can use it as the base of
    a different range, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cdd090c-6062-468f-9498-a0ebf506060a.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the decision points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `if` structure is a binary decision: either yes or no. A light switch on
    the wall is a physical example of an if structure. If the switch is in one position,
    the lights are on, and if it is in the other position, the lights are off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b04ab4ba-4a4a-4740-9377-35a245614bb0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A case structure is a decision structure with more than one right answer, more
    than one YES, and not a single NO. An example of this might be an ice cream dispenser
    with three flavors—chocolate, strawberry, and vanilla. If you do not want ice
    cream, you do not even approach the machine. You have three choices, and they
    are all correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b7e5a48-6bd6-4430-8d71-5b5c83905c12.png)'
  prefs: []
  type: TYPE_IMG
- en: Practicing Reverse Engineering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since knowing that the inputs and outputs cannot, with any surety, provide you
    with a true picture of the internal construction of the application you want to
    reverse-engineer, let's look at some helpful utilities from Kali Linux that might
    make it easier. We will look at three debuggers, one disassembly tool, and one
    miscellaneous Reverse Engineering tool.
  prefs: []
  type: TYPE_NORMAL
- en: We will show the usage and output from two Linux-based debuggers, **Valgrind**
    and **EDB-Debugger**, and then a similar output from a Windows-only debugger,
    **OllyDbg**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disassembler is **JAD**, which is a Java decompiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b954cd7-29ad-45a7-8a63-2e6848e62f1e.png)'
  prefs: []
  type: TYPE_IMG
- en: Using debuggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is debugging? The honor of coining the term is often erroneously attributed
    to Admiral Grace Hopper, on the occasion of her team members finding a physical
    (but dead) moth stuck in a relay inside a Mark II computer at Harvard University.
    The term may actually come from Thomas Edison as he mentioned and defined the
    term as *little faults and difficulties*. In software development, a bug is usually
    a logic error, and not a typographical error in the code. Typos usually stop the
    code from compiling at all, so they do not get out of the developers' lab. Logic
    errors do not stop the program from compiling, but they may cause a failure in
    the output or an unexpected behavior when the program is initiated. Another word
    often used synonymously with **bug** is **defect**. **Technical debt** in a project
    is the number of defects that are unfixed in a project. Different project managers
    have different levels of tolerance for unfixed bugs. Many malware packages have
    several show-stopping bugs in their released versions, but some of the more sophisticated
    recent malware packages appear to be very low in technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: Debuggers allow you to watch the behavior of an application in a step-wise manner.
    You can see what gets put into memory, what system calls are made, and how the
    application pulls and releases memory. The main reason we use debuggers is to
    check the behavior of programs for which we have access to the source code. The
    reason for this is that the programs we are most likely to debug are code that
    was made in our own workshops. This does not quite constitute a code security
    audit, but it can help a lot to find where a program is leaking memory, and how
    well it cleans up its used memory. Many programs display status reports on the
    command line if you start them that way, and these are internal debugging information.
    This could be cleaned up after release of the application, but in most use cases,
    the end user never sees any of it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Valgrind debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programs generally reserve memory from the total RAM available. One program
    we have found useful for debugging on the command line is `valgrind`, which is
    not in the default Kali install. We add it when we find we need to do preliminary
    debugging. For instance, at one time, a version of [http://www.openoffice.org/](http://www.openoffice.org/),
    the free, open source office suite, had a bug in Linux that was allowing the install,
    but failed to run the program. It just seized up at the display of the initial
    splash screen. Running the following command showed that it was looking for a
    file that did not exist. Rather than just sending a bug report, and hoping for
    a solution to be added as a patch to the source code, we just added the missing
    file as a blank text file. This allowed OpenOffice to start. The OpenOffice developers
    added a patch later that removed the bug, but we didn''t have to wait for it.
    As an example of `valgrind`, here is the command-line code to run a test on `gedit`,
    a text editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It takes much longer to start a program when it is encased in a debugger, and
    the entire output will go to the log file that's been designated. Once the program
    is open, you can close the program by pressing *Ctrl* + *C* on the command line,
    or if the application under test has a GUI interface, you can close the window,
    and `valgrind` will shut down after watching the application you are testing go
    down.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, there are over 600 lines of output from the debugger, and
    you are going to need to use a more user-friendly debugger to find more useful
    information. Keeping in mind that gedit is a very mature program and that it works
    flawlessly every time we use it to edit text files, it still has 24 memory errors
    noted by `valgrind` in the undemanding use case of opening gedit, typing a few
    characters, and closing without saving the new document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8051f1c-ef02-4c49-abf4-92f140f6ab51.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the EDB-Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The EDB-Debugger is a version of a Windows application called the Olly debugger.
    The EDB-Debugger has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: A GUI interface, which the developers call intuitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard debugging operations (step-into/step-over/run/break)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More unusual conditional breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A debugging core that is implemented as a plugin (you can drop in replacement
    core plugins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some platforms may have several debugging APIs available, in which case you
    may have a plugin that implements any of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic instruction analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View/Dump memory regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective address inspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data dump view is tabbed, allowing you to have several views of memory open
    at the same time that you can quickly switch between
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the importing and generation of symbol maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has plugins to extend usability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EDB-Debugger is designed to debug Linux applications, and we will look at the
    same application, gedit, with EDB-Debugger. The GUI interface shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The application being tested and the process ID in the title bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General purpose binary command map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bookmarks: Places of interest in the code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers set aside for data (specifically for the marked line in 2/3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data dump: Memory locations and content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory Stack data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GUI can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/684a2a3c-6157-4e31-ae84-f7798c699f06.png)'
  prefs: []
  type: TYPE_IMG
- en: EDB-Debugger symbol mapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EDB-Debugger can give you a symbol map via the following command-line entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The symbol table maps functions, lines, or variables in a program. In the case
    of gedit, the symbol table looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c681ada7-4a79-4293-a374-32e87c12de7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Running OllyDbg
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are running the 64-bit version of Kali Linux 2.0, you will first need
    to update Kali. It is missing the 32-bit wine infrastructure, and wine doesn''t
    even want to start without that. Luckily, Kali Linux gives you a useful error
    message. You just have to copy the quoted part of the error message and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dce4dcba-bf1e-494a-ae00-d1dea21d9a93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The OllyDbg GUI window does look a lot like EDB-Debugger, though it is graphically
    a little uglier. We are looking at `notepad.exe`, which is a Windows-only editor,
    similar to a cut-down version of gedit. The window is broken up into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The application being tested in the title bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data dump: Memory locations and content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory Stack data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you open an executable file (EXE, PIF, or COM), it shows you the entire
    running program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f1acd3b-5b8e-456f-bdee-b5ee6df4fa63.png)'
  prefs: []
  type: TYPE_IMG
- en: You could choose to run OllyDbg on your target Windows machine, to look at an
    ongoing infection by copying its folder to a flash drive and carrying the flash
    drive over to the infected machine. You could also install Kali Linux to a bootable
    flash drive as we mentioned in [Chapter 1](b18fe074-058f-410f-86de-77499a727708.xhtml),
    *Choosing Your Distro*, and run Kali directly on the infected machine.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to disassemblers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A disassembler takes compiled binary code and displays the assembly code. This
    is similar to what the debuggers can show you.
  prefs: []
  type: TYPE_NORMAL
- en: Running JAD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JAD is a Java Decompiler that's included with Kali Linux, and it seems like
    a useful tool for analyzing potentially dangerous Java applets that come from
    web pages. The biggest problem with it is that it has not had a maintainer since
    2011, and so is difficult to find, except in the Kali repository and at Tomas
    Varaneckas's blog page, *Jad Decompiler Download Mirror* ([http://varaneckas.com/jad/](http://varaneckas.com/jad/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a page from the JAD help file, which you can access from the
    main menu or by typing `jad` in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/567fb42e-0b7f-4c8b-809c-e5590f6e153d.png)'
  prefs: []
  type: TYPE_IMG
- en: For a short example of what it looks like to use `jad`, we created a Java class
    for you. The following three illustrations are of the following
  prefs: []
  type: TYPE_NORMAL
- en: Original source code (not always available)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running `jad`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decompiled source
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, here is the source code for a little Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfc15700-4027-497a-9286-25dc0c2f0949.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application is running. We showed the result of using the inline help (type
    a question mark instead of one of the letter choices) just to show the level of
    detail that''s available. We then chose `a`, and `jad` overwrote the source. This
    will not be a problem when you have only the compiled class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c44bb035-7c44-4db7-8979-3f9e37c34738.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, here is the decompiled source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0dc44f26-9e68-4174-8de9-eb155d7f2ce9.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating your own disassembling code with Capstone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Capstone decompiling engine is well maintained, and has a simple API. The
    basic Capstone libraries come as default on Kali Linux, and you can build your
    own frontend using any language with which you are familiar. We are using Python,
    as it is our go-to scripting language. Using the `aptitude search <keyword>` command
    structure, you can make sure that you have the available packages and can see
    the status of the packages. In this case, you can see that `p` in the first column
    means that there is a package available, and `i` means that it is installed. The
    `A` in the second column shows that the package was installed automatically, and
    is probably a dependency for some other package. We have chosen to `install libcapstone-dev`
    for the 64-bit architecture we have on the Kali instance, in case we want to attempt
    to customize the behavior of Capstone. You don''t need to do this to use Capstone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18a2332d-611a-4d8a-b514-151fa6d53b49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a simple disassembler script based on examples from [http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html).
    This could be far more automated, but for the sake of this example, the hexcode
    is hardcoded into the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ea09aad-578b-452a-bb66-ca1bfe93bf07.png)'
  prefs: []
  type: TYPE_IMG
- en: Some miscellaneous Reverse Engineering tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a large category of miscellaneous Reverse Engineering tools, listed
    as such in the Kali Linux 1.x menu, but not categorized in the Kali Linux 2.0
    menu. Rather than randomly picking a couple of these, we are showing you an integrated
    suite of tools led by Radare2.
  prefs: []
  type: TYPE_NORMAL
- en: Running Radare2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can start Radare2 by clicking the menu link under Reverse Engineering.
    You are probably more comfortable with the command line now, so you will probably
    want to open it directly in the command line. Open the command-line launcher by
    typing the keyboard shortcut, *Alt* + *F2*. Then, the following command opens
    the program''s help file in a new Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break this command down for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bash` opens a Bash shell.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c` directs dash to read from a command string, which follows in double quotes,
    instead of waiting for standard input from the keyboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radare2` is the application we are opening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h` is the option that opens a help file in the Terminal window, if one exists.
    `--help` is the long form of that option (these options are available on almost
    every Linux command-line tool).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Radare2 is an advanced command-line hexadecimal editor, disassembler, and debugger.
    Radare2 ([http://radare.org](http://radare.org)) states that Radare2 is a portable
    reversing framework with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Disassembles (and assemble for) many different architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugs with local native and remote debuggers (gdb, rap, webui, r2pipe, winedbg,
    and windbg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs on Linux, *BSD, Windows, OSX, Android, iOS, Solaris, and Haiku
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performs forensics on filesystems and data carving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is scripted in Python, JavaScript, Go, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports collaborative analysis using the embedded web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visualizes data structures of several file types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patches programs to uncover new features or fix vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses powerful analysis capabilities to speed up reversing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aids in software exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/63b6c01b-49ad-48cf-a871-5ecb87bcc76d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Radare2 is the tip of a framework that is integrated with ten plugins and several
    other applications. To keep the PG rating, we fuzzed out the last plugin name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/610b1ed6-59c0-4d28-8ca1-bcf5c48b2212.png)'
  prefs: []
  type: TYPE_IMG
- en: The additional members of the Radare2 tool suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss additional members of the Radare2 tool suite in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Running rasm2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'rasm2 `/usr/bin/rasm2` is a command-line assembler/disassembler for several
    architectures, for example, Intel x86 and x86-64, MIPS, ARM, PowerPC, Java, and
    MSIL. This may be your go-to for disassembly when JAD is no longer available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e81f6b2-70d4-496a-8af9-71e919d37614.png)'
  prefs: []
  type: TYPE_IMG
- en: Running rahash2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'rahash2 `/usr/bin/rahash` is a block-based hash tool, which supports many algorithms,
    for example, MD4, MD5, CRC16, CRC32, SHA1, SHA256, SHA384, SHA512, par, xor, xorpair,
    mod255, hamdist, and entropy. You can use `rahash2` to check the integrity of,
    and track changes to, files, memory dumps, and disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36e0dc00-57dc-44b5-a869-e3fda48c622e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an example of testing the sha256 hash for a small file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68ab55b7-b278-4ab6-bab6-728074a41cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: Running radiff2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'radiff2 is a binary utility that uses various algorithms to compare files.
    It supports byte-level or delta comparisons for binary files, and code analysis
    comparisons to find changes in code blocks produced by a `radare` code analysis.
    The following is a test that''s comparing two states of the `/var/log/message`
    log over the course of a couple of seconds. This is a comparison at the bit level,
    for random changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c64b9c4-412b-4e9b-8d44-4ff73b16ebc2.png)'
  prefs: []
  type: TYPE_IMG
- en: Running rafind2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'rafind2 is designed to search for patterns in files. In the following example,
    `rafind2 -s "string searched" <file>` shows you what we can see when we search
    for a string that we know to exist, and one we know to be absent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48233c42-8587-4854-81d2-93ba7cb3c44e.png)'
  prefs: []
  type: TYPE_IMG
- en: Running rax2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'rax2 is a mathematical expression evaluator for the command line. You can do
    many conversion operations, including one that is useful for making base conversions
    between floating point values, hexadecimal representations, hex-pair strings to
    ASCII, octal to integer, and so on. It also supports endianness settings and can
    be used as an interactive shell if no arguments are given:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7cd4858-5ad6-43cc-b5ca-d02cb126cab7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are some example conversions with rax2:'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal to hexadecimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hexadecimal to decimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Octal to hexadecimal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing two strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing a single string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c6307c77-db85-484f-a975-a99077185542.png)'
  prefs: []
  type: TYPE_IMG
- en: Stress testing Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's look at some tools that will make your Windows machine cry. Stress
    testing a system can show you just how much of a load your machine and network
    will carry. Here's a little experiment you can also run. Set up a service on a
    Windows machine and the same type of service on a Linux machine and see which
    can handle the loads better. You will be surprised with the outcome. The outcome
    may make you ask *why would I ever use Windows in the first place?*
  prefs: []
  type: TYPE_NORMAL
- en: '**Hacker''s tip**:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Linux as your daily driver OS—I do!
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Denial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ATK6-Denial6** is an IPv6 network stress tester that sends packets to a target
    host and beats them into submission. This is the help file for ATK6-Denial6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ec7068c-d795-4824-9180-9f6b7bb96736.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot is the `nmap -A` reading for the vulnerable Windows
    7 target machine. We want to find out if it has ports open, and which ports they
    are. We can see that ports `139`, `445`, `2869`, `5357`, and `10243` are open.
    The big problem with this tool is that the test network is IPv4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/290e14d3-7991-42ad-b379-31dbb5d56cdf.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's find a tool with which we can attack our IPv4 network.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the network under Siege
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Siege is a web stress tester. Siege is a multi-threaded HTTP load testing and
    benchmarking utility. It was designed to let web developers measure the performance
    of their code under pressure. It allows you to hit a web server with a configurable
    number of concurrent simulated users.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is those users who place the web server *under siege*. Performance measures
    include the following, which are quantified and reported at the end of each run:'
  prefs: []
  type: TYPE_NORMAL
- en: Elapsed time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total data transferred
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server response time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughput
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OK return count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their meaning and significance are discussed later. Siege essentially has three
    modes of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Regression (when invoked by bombardment)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brute force
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The formats for using siege are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`siege [options]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`siege [options] [url]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`siege -g [url]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c7a27efd-88fe-4af4-8294-524938eca229.png)'
  prefs: []
  type: TYPE_IMG
- en: Siege imitated 15 users going to the website on the Windows 7 target machine.
    The performance was not all that bad, all in all. There were 8,072 hits on the
    site in four and a half minutes. The Windows 7 target maintained 100% availability
    with better than 1/100th of a second response time.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your Siege engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What do you think would happen if we increase the number of besiegers to 10,000?
    The configuration is `at /usr/bin/siege.config`. When we run that on the command
    line, it tells us we already have a local configuration file at `/root/siegerc`,
    so let''s go look at that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ec4021f-e519-44c5-bd87-bc4b7ab93227.png)'
  prefs: []
  type: TYPE_IMG
- en: To edit `/root/.siegerc`, we can use the command line or the Run Launcher (*Alt*
    + *F2*) to enter the name of our favorite text editor. Here, we are going to use
    gedit, so enter gedit `/root/.siegerc` . Alternatively, we could find gedit in
    the `Usual Applications`/`Accessories` folder, and open the file open dialog and
    turn on hidden files, then find `.siegerc` in the `/root` directory. You are probably
    starting to see the reason Linux administrators like the command line so much.
  prefs: []
  type: TYPE_NORMAL
- en: 'On line `162` of the configuration file, you will find the number of concurrent
    users. The current default is `15`, but let''s change that to 10,000\. Let''s
    see if we can crack this baby:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df072eea-fec9-4844-b93f-619d19719d7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After forcing the Kali instance to close, let''s try it with fewer besiegers.
    The larger the number of concurrent users, the more RAM it uses on your Kali machine,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8b800dd-f2d4-40c8-b47f-f1c4c8560daa.png)'
  prefs: []
  type: TYPE_IMG
- en: Using 625 besiegers, we got a solid result without crashing the testing machine.
    In-between, we tested 5,000, 2,500, and 1,250, but they all crashed the machine.
    If you have a sense of fun, you could test higher numbers, such as 940, 1,090,
    and so on. The resources available on your testing machine will rule the number
    of besiegers you can employ.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reverse Engineering to get a definitive answer as to the actual code for a complicated
    application is unlikely, since there are many ways to achieve the same output
    via loops or choice structures. It is easier to get a statistical list of possible
    treatments of the inputs by testing several of them. You are likely to get more
    detail from looking at the assembly code outputs from **EDB-Debugger** or **OllyDbg**.
    As you have probably noticed, the assembly code for Linux and for Windows applications
    is basically identical. High-level languages such as C and C++ are just ways to
    get at the assembly code that can be easily converted to machine code to tell
    the machine what to do.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing your Windows hosts comes down to checking their ability to take
    in many inputs over a short period of time, on any open ports whatsoever. Remember,
    when stress testing, you will make a lot of noise on the network, and any intrusion
    detection tool, configured properly, will notice your attack. You may also knock
    the target machine off the network, so you had better alert the management before
    you start your test.
  prefs: []
  type: TYPE_NORMAL
- en: As this is the last chapter, we hope that you have enjoyed this book and we
    hope that you have learned something to better your understanding of penetration
    testing and exploitation of the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading this book.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**More reading on the Radare2 Tool Suite**: [https://rada.re/r/](https://rada.re/r/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Radare2 Cheatsheets**: [https://github.com/pwntester/cheatsheets/blob/master/radare2.md](https://github.com/pwntester/cheatsheets/blob/master/radare2.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More on EDB-Debugger**: [https://github.com/eteran/edb-debugger](https://github.com/eteran/edb-debugger)
    and [http://codef00.com/projects](http://codef00.com/projects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More on OllyDbg**: [http://www.ollydbg.de/](http://www.ollydbg.de/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More on Capstone**: [http://www.capstone-engine.org/lang_python.html](http://www.capstone-engine.org/lang_python.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
