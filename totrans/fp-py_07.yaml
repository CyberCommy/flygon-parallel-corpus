- en: Chapter 7. Additional Tuple Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the examples we've looked at have either been `scalar` functions, or
    relatively simple structures built from small tuples. We can often exploit Python's
    immutable `namedtuple` as a way to build complex data structures. We'll look at
    how we use and how we create `namedtuples`. We'll also look at ways that immutable
    `namedtuples` can be used instead of stateful object classes.
  prefs: []
  type: TYPE_NORMAL
- en: One of the beneficial features of object-oriented programming is the ability
    to create complex data structures incrementally. In some respects, an object is
    simply a cache for results of functions; this will often fit well with functional
    design patterns. In other cases, the object paradigm provides for property methods
    that include sophisticated calculations. This is an even better fit for functional
    design ideas.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, however, object class definitions are used statefully to create
    complex objects. We'll look at a number of alternatives that provide similar features
    without the complexities of stateful objects. We can identify stateful class definitions
    and then include meta-properties for valid or required ordering of method function
    calls. Statements such as *If X.p() is called before X.q(), the results are undefined*
    are outside the formalism of the language and are meta-properties of a class.
    Sometimes, stateful classes include the overhead of explicit assertions and error
    checking to assure that methods are used in the proper order. If we avoid stateful
    classes, we eliminate these kinds of overheads.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at some techniques to write generic functions outside any polymorphic
    class definition. Clearly, we can rely on `Callable` classes to create a polymorphic
    class hierarchy. In some cases, this might be a needless overhead in a functional
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Using an immutable namedtuple as a record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Functions, Iterators, and Generators"),
    *Functions, Iterators, and Generators*, we showed two common techniques to work
    with tuples. We''ve also hinted at a third way to handle complex structures. We
    can do any of the following, depending on the circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `lambdas` (or functions) to select a named item using the index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `lambdas` (or functions) with `*parameter` to select an item by parameter
    name, which maps to an index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `namedtuples` to select an item by attribute name or index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our trip data, introduced in [Chapter 4](ch04.html "Chapter 4. Working with
    Collections"), *Working with Collections*, has a rather complex structure. The
    data started as an ordinary time series of position reports. To compute the distances
    covered, we transposed the data into a sequence of legs with a start position,
    end position, and distance as a nested three-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each item in the sequence of legs looks as follows as a three-tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a short trip between two points on the Chesapeake Bay.
  prefs: []
  type: TYPE_NORMAL
- en: A nested tuple of tuples can be rather difficult to read; for example, expressions
    such as `first_leg[0][0]` aren't very informative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the three alternatives for selected values out of a `tuple`.
    The first technique involves defining some simple selection functions that can
    pick items from a `tuple` by index position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With these definitions, we can use `latitude(start(first_leg))` to refer to
    a specific piece of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'These definitions don''t provide much guidance on the data types involved.
    We can use a simple naming convention to make this a bit more clear. The following
    are some examples of selection functions that use a suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When used judiciously, this can be helpful. It can also degenerate into an elaborately
    complex Hungarian notation as a prefix (or suffix) of each variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second technique uses the `*parameter` notation to conceal some details
    of the index positions. The following are some selection functions that use the
    `*` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With these definitions, we can use `latitude(*start(*first_leg))` to refer to
    a specific piece of data. This has the advantage of clarity. It can look a little
    odd to see the `*` operator in front of the `tuple` arguments to these selection
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third technique is the `namedtuple` function. In this case, we have nested
    namedtuple functions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to use `first_leg.start.latitude` to fetch a particular piece
    of data. The change from prefix function names to postfix attribute names can
    be seen as a helpful emphasis. It can also be seen as a confusing shift in the
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We will also replace `tuple()` functions with appropriate `Leg()` or `Point()`
    function calls in our process that builds the raw data. We will also have to locate
    some `return` and `yield` statements that implicitly create tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would be changed to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This would build `Point` objects instead of anonymous tuples of `floating-point`
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can introduce the following to build the complete trip of `Leg`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will iterate through the basic path of points, pairing them up to make
    `start` and `end` for each `Leg` object. These pairs are then used to build `Leg`
    instances using the start point, end point, and the `haversine()` function from
    [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `trip` object will look as follows when we try to print it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that the `haversine()` function was written to use simple
    tuples. We've reused this function with `namedtuples`. As we carefully preserved
    the order the arguments, this small change in representation was handled gracefully
    by Python.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the `namedtuple` function adds clarity. In other cases, the `namedtuple`
    is a needless change in syntax from prefix to suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Building namedtuples with functional constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three ways we can build `namedtuple` instances. The choice of technique
    we use is generally based on how much additional information is available at the
    time of object construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve shown two of the three techniques in the examples in the previous section.
    We''ll emphasize the design considerations here. It includes the following choices:'
  prefs: []
  type: TYPE_NORMAL
- en: We can provide the parameter values according to their positions. This works
    out well when there are one or more expressions that we were evaluating. We used
    it when applying the `haversine()` function to the `start` and `end` points to
    create a `Leg` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `*argument` notation to assign parameters according to their
    positions in a tuple. This works out well when we're getting the arguments from
    another iterable or an existing tuple. We used it when using `map()` to apply
    the `float()` function to the `latitude` and `longitude` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use explicit keyword assignment. While not used in the previous example,
    we might see something like this as a way to make the relationships more obvious:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's helpful to have the flexibility of a variety of ways of created `namedtuple`
    instances. This allows us to more easily transform the structure of data. We can
    emphasize features of the data structure that are relevant for reading and understanding
    the application. Sometimes, the index number of 0 or 1 is an important thing to
    emphasize. Other times, the order of `start`, `end`, and `distance` is important.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding stateful classes by using families of tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In several previous examples, we've shown the idea of **Wrap-Unwrap** design
    patterns that allow us to work with immutable tuples and `namedtuples`. The point
    of this kind of designs is to use immutable objects that wrap other immutable
    objects instead of mutable instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: A common statistical measure of correlation between two sets of data is the
    Spearman rank correlation. This compares the rankings of two variables. Rather
    than trying to compare values, which might have different scales, we'll compare
    the relative orders. For more information, visit [http://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient](http://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient).
  prefs: []
  type: TYPE_NORMAL
- en: Computing the Spearman rank correlation requires assigning a rank value to each
    observation. It seems like we should be able to use `enumerate(sorted())` to do
    this. Given two sets of possibly correlated data, we can transform each set into
    a sequence of rank values and compute a measure of correlation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll apply the Wrap-Unwrap design pattern to do this. We'll `wrap` data items
    with their rank for the purposes of computing the correlation coefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Functions, Iterators, and Generators"),
    *Functions, Iterators, and Generators*, we showed how to parse a simple dataset.
    We''ll extract the four samples from that dataset as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these series is a `tuple` of `Pair` objects. Each `Pair` object has
    `x` and `y` attributes. The data looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply the `enumerate()` function to create sequences of values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first step will create simple two-tuples with `(0)` a rank number and `(1)`
    the original `Pair` object. As the data was sorted by the `y` value in each pair,
    the rank value will reflect this ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The second step will `wrap` these two-tuples into yet another layer of wrapping.
    We'll sort by the *x* value in the original raw data. The second enumeration will
    be by the *x* value in each pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create more deeply nested objects that should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In principle, we can now compute rank-order correlations between the two variables
    by using the *x* and *y* rankings. The extraction expression, however, is rather
    awkward. For each ranked sample in the data set, `r`, we have to compare `r[0]`
    with `r[1][0]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome these awkward references, we can write selector functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to compute correlation using `x_rank(r)` and `y_rank(r)`, making
    references to values less awkward.
  prefs: []
  type: TYPE_NORMAL
- en: We've `wrapped` the original `Pair` object twice, which created new tuples with
    the ranking value. We've avoided stateful class definitions to create complex
    data structures incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why create deeply nested tuples? The answer is simple: laziness. The processing
    required to unpack a `tuple` and build a new, flat `tuple` is simply time consuming.
    There''s less processing involved in `wrapping` an existing `tuple`. There are
    some compelling reasons for giving up the deeply nested structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two improvements we''d like to make; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like a flatter data structure. The use of a nested `tuple` of `(x rank,
    (y rank, Pair()))` doesn''t feel expressive or succinct:'
  prefs: []
  type: TYPE_NORMAL
- en: The `enumerate()` function doesn't deal properly with ties. If two observations
    have the same value, they should get the same rank. The general rule is to average
    the positions of equal observations. The sequence `[0.8, 1.2, 1.2, 2.3, 18]` should
    have rank values of `1, 2.5, 2.5, 4`. The two ties in positions 2 and 3 have the
    midpoint value of `2.5` as their common rank.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning statistical ranks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll break the rank ordering problem into two parts. First, we'll look at a
    generic, higher-order function that we can use to assign ranks to either the *x*
    or *y* value of a `Pair` object. Then, we'll use this to create a `wrapper` around
    the `Pair` object that includes both *x* and *y* rankings. This will avoid a deeply
    nested structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a function that will create a rank order for each observation
    in a dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Our function to create the rank ordering relies on creating an object that is
    like `Counter` to discover duplicate values. We can't use a simple `Counter` function,
    as it uses the entire object to create a collection. We only want to use a key
    function applied to each object. This allows us to pick either the *x* or *y*
    value of a `Pair` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `duplicates` collection in this example is a stateful object. We could have
    written a properly recursive function. We'd then have to do tail-call optimization
    to allow working with large collections of data. We've shown the optimized version
    of that recursion here.
  prefs: []
  type: TYPE_NORMAL
- en: As a hint to how this recursion would look, we've provided the arguments to
    `build_duplicates()` that expose the state as argument values. Clearly, the base
    case for the recursion is when `data_iter` is empty. When `data_iter` is not empty,
    a new collection is built from the old collection and the head `next(data_iter)`.
    A recursive evaluation of `build_duplicates()` will handle all items in the tail
    of `data_iter`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we could have written two properly recursive functions to emit the
    collection with the assigned rank values. Again, we've optimized that recursion
    into nested `for` loops. To make it clear how we're computing the rank value,
    we've included the low end of the range (`base+1`) and the high end of the range
    (`base+dups`) and taken the midpoint of these two values. If there is only a single
    `duplicate`, we evaluate `(2*base+2)/2`, which has the advantage of being a general
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: The following is how we can test this to be sure it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The sample data included two identical values. The resulting ranks split positions
    2 and 3 to assign position 2.5 to both values. This is the common statistical
    practice for computing the Spearman rank-order correlation between two sets of
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `rank()` function involves rearranging the input data as part of discovering
    duplicated values. If we want to rank on both the `x` and `y` values in each pair,
    we need to reorder the data twice.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping instead of state changing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have two general strategies to do wrapping; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallelism**: We can create two copies of the data and rank each copy. We
    then need to reassemble the two copies into a final result that includes both
    rankings. This can be a bit awkward because we''ll need to somehow merge two sequences
    that are likely to be in different orders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serialism**: We can compute ranks on one variable and save the results as
    a wrapper that includes the original raw data. We can then rank this wrapped data
    on the other variable. While this can create a complex structure, we can optimize
    it slightly to create a flatter wrapper for the final results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is how we can create an object that wraps a pair with the rank
    order based on the `y` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a `namedtuple` function that contains the `y` value rank plus
    the original (`raw`) value. Our `rank_y()` function will create instances of this
    tuple by applying the `rank()` function using a `lambda` that selects the `y`
    value of each `pairs` object. We then created instances of the resulting two tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that we can provide the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The raw `Pair` objects have been wrapped in a new object that includes the rank.
    This isn't all we need; we'll need to wrap this one more time to create an object
    that has both x and y rank information.
  prefs: []
  type: TYPE_NORMAL
- en: Rewrapping instead of state changing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use a `namedtuple` named `Ranked_X` that contains two attributes: `r_x`
    and `ranked_y`. The `ranked_y` attribute is an instance of `Ranked_Y` that has
    two attributes: `r_y` and `raw`. Although this looks simple, the resulting objects
    are annoying to work with because the `r_x` and `r_y` values aren''t simple peers
    in a flat structure. We''ll introduce a slightly more complex wrapping process
    that produces a slightly simpler result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the output to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to create a flat `namedtuple` with multiple peer attributes. This
    kind of expansion is often easier to work with than deeply nested structures.
    In some applications, we might have a number of transformations. For this application,
    we have only two transformations: x-ranking and y-ranking. We''ll break this into
    two steps. First, we''ll look at a simplistic wrapping like the one shown previously
    and then a more general unwrap-rewrap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how the `x-y` ranking builds on the y-ranking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `rank_y()` function to build `Rank_Y` objects. Then, we applied
    the `rank()` function to those objects to order them by the original `x` values.
    The result of the second rank function will be two tuples with `(0)` the `x` rank
    and `(1)` the `Rank_Y` object. We build a `Ranked_XY` object from the `x` ranking
    (`r_x)`, the `y` ranking (`rank_y_raw[0]`), and the original object (`rank_y_raw[1]`).
  prefs: []
  type: TYPE_NORMAL
- en: What we've shown in this second function is a more general approach to adding
    data to a `tuple`. The construction of the `Ranked_XY` object shows how to unwrap
    the values from a data and rewrap to create a second, more complete structure.
    This approach can be used generally to introduce new variables to a `tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is some sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to create ranking objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once we have this data with the appropriate *x* and *y* rankings, we can compute
    the Spearman rank-order correlation value. We can compute the Pearson correlation
    from the raw data.
  prefs: []
  type: TYPE_NORMAL
- en: Our multiranking approach involves decomposing a `tuple` and building a new,
    flat `tuple` with the additional attributes we need. We will often need this kind
    of design when computing multiple derived values from source data.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the Spearman rank-order correlation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Spearman rank-order correlation is a comparison between the rankings of
    two variables. It neatly bypasses the magnitude of the values, and it can often
    find a correlation even when the relationship is not linear. The formula is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Computing the Spearman rank-order correlation](graphics/B03652_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This formula shows us that we''ll be summing the differences in rank, ![Computing
    the Spearman rank-order correlation](graphics/B03652_07_02.jpg) and ![Computing
    the Spearman rank-order correlation](graphics/B03652_07_03.jpg), for all of the
    pairs of observed values. The Python version of this depends on the `sum()` and
    `len()` functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We've created `Rank_XY` objects for each `pair`. Given this, we can then subtract
    the `r_x` and `r_y` values from those pairs to compare their difference. We can
    then square and sum the differences.
  prefs: []
  type: TYPE_NORMAL
- en: A good article on statistics will provide detailed guidance on what the coefficient
    means. A value around 0 means that there is no correlation between the data ranks
    of the two series of data points. A scatter plot shows a random scattering of
    points. A value around +1 or -1 indicates a strong relationship between the two
    values. A graph shows a clear line or curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example based on Anscombe''s Quartet series I:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For this particular data set, the correlation is strong.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, we showed how to compute the Pearson correlation coefficient. The
    function we showed, `corr()`, worked with two separate sequences of values. We
    can use it with our sequence of `Pair` objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We've unwrapped the `Pair` objects to get the raw values that we can use with
    the existing `corr()` function. This provides a different correlation coefficient.
    The Pearson value is based on how well the standardized values compare between
    two sequences. For many data sets, the difference between the Pearson and Spearman
    correlations is relatively small. For some datasets, however, the differences
    can be quite large.
  prefs: []
  type: TYPE_NORMAL
- en: To see the importance of having multiple statistical tools for exploratory data
    analysis, compare the Spearman and Pearson correlations for the four sets of data
    in the Anscombe's Quartet.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism and Pythonic pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some functional programming languages offer clever approaches to working with
    statically typed function definitions. The issue is that many functions we'd like
    to write are entirely generic with respect to data type. For example, most of
    our statistical functions are identical for `integer` or `floating-point` numbers,
    as long as division returns a value that is a subclass of `numbers.Real` (for
    example, `Decimal`, `Fraction`, or `float`). In order to make a single generic
    definition work for multiple data types, sophisticated type or pattern-matching
    rules are used by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the (possibly) complex features of statically typed functional languages,
    Python changes the issue using dynamic selection of the final implementation of
    an operator based on the data types being used. This means that a compiler doesn't
    certify that our functions are expecting and producing the proper data types.
    We generally rely on unit testing for this.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we're effectively writing generic definitions because the code isn't
    bound to any specific data type. The Python runtime will locate the appropriate
    operations using a simple set of matching rules. The *3.3.7 Coercion rules* section
    of the language reference manual and the `numbers` module in the library provide
    details on how this mapping from operation to special method name works.
  prefs: []
  type: TYPE_NORMAL
- en: 'In rare cases, we might need to have different behavior based on the types
    of the data elements. We have two ways to tackle this; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `isinstance()` function to distinguish the different cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create our own subclass of `numbers.Number` or `tuple` and implement
    a proper polymorphic special method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, we'll actually need to do both so that we can include appropriate
    data type conversions.
  prefs: []
  type: TYPE_NORMAL
- en: When we look back at the ranking example in the previous section, we're tightly
    bound to the idea of applying rank-ordering to simple pairs. While this is the
    way the Spearman correlation is defined, we might have a multivariate dataset
    and have a need to do rank-order correlation among all the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll need to do is generalize our idea of rank-order information.
    The following is a `namedtuple` that handles a `tuple` of ranks and a `tuple`
    of raw data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For any specific piece of `Rank_Data`, such as `r`, we can use `r.rank_seq[0]`
    to get a specific ranking and `r.raw` to get the original observation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add some syntactic sugar to our ranking function. In many previous examples,
    we''ve required either an iterable or a collection. The `for` statement is graceful
    about working with either one. However, we don''t always use the `for` statement,
    and for some functions, we''ve had to explicitly use `iter()` to make an `iterable`
    out of a collection. We can handle this situation with a simple `isinstance()`
    check, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've included a type check to handle the small difference between the two collection`s`,
    which doesn't work with `next()` and an `iterable`, which supports `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of our rank-ordering function, we will use this variation on
    the design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve decomposed the ranking into three cases for three different types of
    data. We''re forced it to do this when the different kinds of data aren''t polymorphic
    subclasses of a common superclass. The following are the three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Given an `iterable` (without a usable `__getitem__()` method), we'll materialize
    a `tuple` that we can work with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a collection of some unknown type of data, we'll wrap the unknown objects
    into `Rank_Data` tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, given a collection of `Rank_Data` tuples, we'll add yet another ranking
    to the tuple of ranks inside the each `Rank_Data` container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This relies on a `rerank()` function that inserts and returns another ranking
    into the `Rank_Data` tuple. This will build up a collection of individual rankings
    from a complex record of raw data values. The `rerank()` function follows a slightly
    different design than the example of the `rank()` function shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the algorithm uses sorting instead of creating a groups in
    a objects like `Counter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We've started by reassembling a single, sortable collection from the head and
    the data iterator. In the context in which this is used, we can argue that this
    is a bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function relies on two other functions. They can be declared within the
    body of `rerank()`. We''ll show them separately. The following is the ranker,
    which accepts an iterable, a base rank number, a collection of values with the
    same rank, and a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We've extracted the next item from the `iterable` collection of sorted values.
    If this fails, there is no next item, and we need to emit the final collection
    of equal-valued items in the `same_rank_seq` sequence. If this works, then we
    need to use the `key()` function to see whether the next item, which is a value,
    has the same key as the collection of equal-ranked items. If the key is the same,
    the overall value is defined recursively; the reranking is the rest of the sorted
    items, the same base value for the rank, a larger collection of `same_rank` items,
    and the same `key()` function.
  prefs: []
  type: TYPE_NORMAL
- en: If the next item's key doesn't match the sequence of equal-valued items, the
    result is a sequence of equal-valued items. This will be followed by the reranking
    of the rest of the sorted items, a base value incremented by the number of equal-valued
    items, a fresh list of equal-rank items with just the new value, and the same
    `key` extraction function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This depends on the `yield_sequence()` function, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We've written this in a way that emphasizes the recursive definition. We don't
    really need to extract the head, emit it, and then recursively emit the remaining
    items. While a single `for` statement might be shorter, it's sometimes more clear
    to emphasize the recursive structure that has been optimized into a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples of using this function to rank (and rerank)
    data. We''ll start with a simple collection of scalar values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each value becomes the `raw` attribute of a `Rank_Data` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we work with a slightly more complex object, we can also have multiple
    rankings. The following is a sequence of two tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined a collection of pairs. Then, we ranked the two tuples, assigning
    the sequence of `Rank_Data` objects to the `rank_x` variable. We then ranked this
    collection of `Rank_Data` objects, creating a second rank value and assigning
    the result to the `rank_xy` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting sequence can be used to a slightly modified `rank_corr()` function
    to compute the rank correlations of any of the available values in the `rank_seq`
    attribute of the `Rank_Data` objects. We'll leave this modification as an exercise
    for the readers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at different ways to use `namedtuple` objects to
    implement more complex data structures. The essential features of a `namedtuple`
    are a good fit with functional design. They can be created with a creation function
    and accessed by position as well as name.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to use immutable `namedtuples` instead of stateful object definitions.
    The core technique was to wrap an object in an immutable `tuple` to provide additional
    attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at ways to handle multiple data types in Python. For most arithmetic
    operations, Python's internal method dispatch locates proper implementations.
    To work with collections, however, we might want to handle iterators and sequences
    slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two chapters, we'll look at the `itertools` module. This `library`
    module provides a number of functions that help us work with iterators in sophisticated
    ways. Many of these tools are examples of higher-order functions. They can help
    make a functional design stay succinct and expressive.
  prefs: []
  type: TYPE_NORMAL
