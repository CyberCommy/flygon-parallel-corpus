- en: Chapter 5. Network Exploitation and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about host-and application-based exploitation
    and how to use the Metasploit Framework command-line interface and some of the
    other command line and shell environment-driven utilities to reverse engineer
    applications and autonomously launch tools based on Nmap output as well as other
    tools. The following chapter will focus on the network exploitation available
    in Kali Linux and how to take advantage of it in the modern bash shell environment.
  prefs: []
  type: TYPE_NORMAL
- en: To start off with, we're going to talk about MAC spoofing and (**ARP)** **Address
    Resolution Protocol** abuse, something that commonly plagues off-the-shelf network
    solutions and could have, in most cases, a very high impact if left unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: MAC and ARP abuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**(MAC)** **Media Access Control** addresses are the addresses given to devices
    on a local network. These addresses are used by layer 2 protocols to pinpoint
    physical devices such as routers, laptops, DNS servers, and other devices adjacent
    to each other on a logical network. Inherently, unless other controls are enforced,
    nothing prevents one device from forging the origin of its packets by using another
    device''s MAC address. This is termed a MAC spoofing attack. Usually, you will
    want to forge or spoof your MAC if some resources on your target network are controlled
    by means of a MAC address, namely if the protection for a given resource uses
    a MAC address as an authentication credential or as identification material. This
    idea is inherently flawed, purely on the basis that if you''re trying to protect
    something that''s secret, you cannot do so without relying on something that''s
    secret. This is a way of paraphrasing an age-old principle of cryptography and
    information theory. Because MAC addresses are supposed to be broadcasted across
    the network in many common situations, due to the operation of some fundamental
    protocols such as ARP, everyone on the network has access to everyone else''s
    MAC addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: MAC address spoofing (though probably the most simplistic network attack; all
    you are really doing is changing the MAC address field in a packet) is also quite
    fundamental to many exploitation techniques. Essentially, almost all hacking is
    about abusing trust; when there is a lot of trust focused, something as fallible
    as the MAC address in a packet, there's a lot you can pull off by abusing this
    situation.
  prefs: []
  type: TYPE_NORMAL
- en: Spoofing MAC addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, spoofing your MAC address is relatively easy but it's also
    a fundamental ingredient to many exploitation techniques; be it ARP spoofing,
    port stealing, or route mangling, all of these wonderful tricks depend heavily
    on the originating MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change your MAC address using Kali Linux, you can use a tool called `macchanger`,
    and use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, `MAC_ADDRESS` will be the MAC address that you would like to change
    your current MAC address to and `INTERFACE` is the interface that should correspond
    to this new MAC address. The other options will not be discussed here for the
    sake of brevity; I suggest you check out the man file for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is an example of `macchanger` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spoofing MAC addresses](img/5107OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For a random MAC, you could use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding screenshot, you will see that the MAC address configured for
    the host originally is changed to the one specified to macchanger. Additionally,
    you may need to make sure that the interface you are reconfiguring with a new
    MAC address is not in use, as we've done in the preceding screenshot. This was
    the purpose of the `ifconfig` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Abusing address resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The address resolution protocol exists as a service that translates IP addresses
    into MAC addresses. Hosts make ARP requests to obtain information about the MAC
    address associated with a given IP address. A host will broadcast a message across
    the entire local network segment, hoping to receive a response from the host associated
    with the requested IP address. The fundamental flaw in the address resolution
    protocol is that it inherently lacks any form of authentication and message integrity.
    This means that, when a response is received for a MAC address lookup, the receiving
    host has no way of determining its origin, and is left to blindly assume it comes
    from the correct host. To an attacker, what this means is that you can convince
    devices to forward you packets that are actually intended for another user by
    forging responses to ARP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kali Linux has a tool that helps facilitate ARP abuse; it''s called ArpSpoof
    and following is the usage specification for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`-i`: This specifies the interface to send ARP replies from. You can find out
    which of your network interfaces is configured with an address and associated
    with a network by using the `ifconfig` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c`: This specifies the MAC address to use when restoring the ARP resolution
    to its original form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t`: This option specifies the target host, namely the one you would like
    to poison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This tells `arpspoof` to poison both hosts; this means not only sending
    ARP replies to your target but also to the host you are impersonating when you
    reply. The effect of this is that both hosts involved have their ARP tables reflect
    that you are either host; `TARGET` will be convinced that you are `GATEWAY` and
    vice versa.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GATEWAY`: This is the IP address of the host you want to impersonate when
    sending forged ARP replies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example: let''s say we would like to convince the host at address
    `192.168.10.107` that we are the host at address `192.168.10.1`, which is the
    default gateway for our target host. Here''s the command you will issue to ArpSpoof
    in this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abusing address resolution](img/5107OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot shows the attacker''s MAC address in bold. Here, it''s
    configured to be `08:00:27:29:d2:29`. If the ARP spoof attack works in our example,
    this address will be associated with the `192.168.10.1` IP on the target host,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abusing address resolution](img/5107OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Man-in-the-middle attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using what we've learned in the ARP abuse subsection of this chapter, we can
    actually perform more elaborate **man-in-the-middle** (**MITM**)-style attacks
    building on the ability to abuse address resolution and host identification schemes.
    This section will focus on the methods you can use to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: MITM attacks are aimed at fooling two entities on a given network into communicating
    by the proxy of an unauthorized third party, or allowing a third party to access
    information in transit, being communicated between two entities on a network.
    For instance, when a victim connects to a service on the local network or on a
    remote network, a man-in-the-middle attack will give you as an attacker the ability
    to eavesdrop on or even augment the communication happening between the victim
    and its service. By service, we could mean a web (HTTP), FTP, RDP service, or
    really anything that doesn't have the inherent means to defend itself against
    MITM attacks, which turns out to be quite a lot of the services we use today!
  prefs: []
  type: TYPE_NORMAL
- en: Ettercap DNS spoofing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ettercap is a tool that facilitates a simple command line and graphical interface
    to perform MITM attacks using a variety of techniques. In this section, we will
    be focusing on applications of ARP spoofing attacks, namely DNS spoofing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set up a DNS spoofing attack with ettercap by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Before we get ettercap up and running, we need to modify the file that holds
    the DNS records for our soon-to-be-spoofed DNS server. This file is found under
    `/usr/share/ettercap/etter.dns`. What you need to do is either add DNS name and
    IP addresses or modify the ones currently in the file by replacing all the IPs
    with yours, if you'd like to act as the intercepting host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that our DNS server records are set up, we can invoke ettercap. Invoking
    ettercap is pretty straightforward; here''s the usage specification:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform a MITM attack using ettercap, you need to supply the `–M` switch
    and pass it an argument indicating the MITM method you''d like to use. In addition,
    you will also need to specify that you''d like to use the DNS spoofing plugin.
    Here''s what the invocation will look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Where `TARGET1` and `TARGET2` is the host you want to intercept and either the
    default gateway or DNS server, interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'To target the host at address `192.168.10.106` with a default gateway of `192.168.10.1`,
    you will invoke the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once launched, ettercap will begin poisoning the ARP tables of the specified
    hosts and listen for any DNS requests to the domains it's configured to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Interrogating servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any network device to participate in communication, certain information
    needs to be accessible to it, no device will be able to look up a domain name
    or find an IP address without the participation of devices in charge of certain
    information. In this section, we will detail some techniques you can use to interrogate
    common network components for sensitive information about your target network
    and the hosts on it.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP interrogation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Simple Network Management Protocol** (**SNMP**) is used by routers and
    other network components in order to support remote monitoring of things such
    as bandwidth, CPU/Memory usage, hard disk space usage, logged on users, running
    processes, and a number of other incredibly sensitive collections of information.
    Naturally, any penetration tester with an exposed SNMP service on their target
    network will need to know how to proliferate any potentially useful information
    from it. This chapter discusses some tools you can use to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**About SNMP Security**'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP services before Version 3 are not designed with security in mind. Authentication
    to these services often comes in the form a simple string of characters called
    a community string. Another common implementation flaw that is inherent to SNMP
    Version 1 and 2 is the ability to brute-force and eavesdrop on communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enumerate SNMP servers for information using the Kali Linux tools, you could
    resort to a number of techniques. The most obvious one will be `snmpwalk`, and
    you can use it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s say we were targeting `192.168.10.103` with a community
    string of `public`, which is a common community string setting; you will then
    invoke the following command to get information from the SNMP service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we opted to use SNMP Version 1, hence the `–v 1` in the invocation for
    the preceding command. The output will look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP interrogation](img/5107OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, this actually extracts some pretty detailed information about
    the targeted host. Whether this is a critical vulnerability or not will depend
    on which kind of information is exposed.
  prefs: []
  type: TYPE_NORMAL
- en: On Microsoft Windows machines and some popular router operating systems, SNMP
    services could expose user credentials and even allow remote attackers to augment
    them maliciously, should they have write access to the SNMP database. Exploiting
    SNMP successfully is often strongly depended on the device implementing the service.
    You could imagine that for routers, your target will probably be the routing table
    or the user accounts on the device. For other host types, the attack surface may
    be quite different. Try to assess the risk of SNMP-based flaws and information
    leaks with respect to its host and possibly the wider network it's hosted on.
    Don't forget that SNMP is all about sharing information, information that other
    hosts on your network probably trust. Think about the kind of information accessible
    and what you will be able to do with it should you have the ability to influence
    it. If you can attack the host, attack the hosts that trust it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another collection of tools is really great at collecting information from
    SNMP services: the `snmp_enum`, `snmp_login`, and similar scripts available in
    the Metasploit Framework. The `snmp_enum` script pretty much does exactly what
    `snmpwalk` does except it structures the extracted information in a friendlier
    format. This makes it easier to understand. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The options available for this module are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP interrogation](img/5107OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s an example invocation against the host in our running example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP interrogation](img/5107OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that we didn't specify the community string in the invocation.
    This is because the module assumes a default of `public`. You can specify a different
    one using the `COMMUNITY` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other situations, you may not always be lucky enough to preemptively know
    the community string being used. However, luckily SNMP Version 1, 2, 2*c*, and
    3*c* do not inherently have any protection against brute-force attacks, nor do
    any of them use any form of network based encryption. In the case of SNMP Version
    1 and 2*c*, you could use a nifty Metasploit module called `snmp-login` that will
    run through a list of possible community strings and determine the level of access
    the enumerated strings gives you. You can use it by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP interrogation](img/5107OT_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen in the preceding screenshot, once the run is complete it will list the
    enumerated strings along with the level of access granted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `snmp_login` module uses a static list of possible strings to do its enumeration
    by default, but you could also run this module on some of the password lists that
    ship with Kali Linux, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will use the `rockyou.txt` wordlist to look for strings to guess with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because all of these Metasploit modules are command line-driven, you can of
    course combine them. For instance, if you''d like to brute-force a host for the
    SNMP community strings and then run the enumeration module on the strings it finds,
    you can do this by crafting a bash script as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command shows you how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our running example, it is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than guessing or brute-forcing SNMP community strings, you could also
    use TCPDump to filter out any packets that could contain unencrypted SNMP authentication
    information. Here''s a useful example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The specifics of these parameters are covered in later sections. The preceding
    command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SNMP interrogation](img/5107OT_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Without going too much into detail about the SNMP packet structure, looking
    through the printable strings captured, it's usually pretty easy to see the community
    string. For more information about how SNMP packets work, I suggest you to check
    out the links in the *Further reading* section. You may also want to look at building
    a more comprehensive packet-capturing tool using something such as Scapy, which
    is available in Kali Linux versions.
  prefs: []
  type: TYPE_NORMAL
- en: For more about SNMP enumeration, please see the links in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: SMTP server interrogation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SMTP servers are used to forward e-mail, and they operate a simple text-based
    protocol. Because these machines exist on operating systems with users accounts
    defined on them and due to the way some of them are configured to handle falsified
    e-mail recipients, you can often abuse the way e-mail address verification or
    look ups work to enumerate the list of user accounts on the host operating system.
    Kali has a great command-line tool called `smtp-user-enum` to do this. Here''s
    how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The components of the previous command line are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-M`: This is the enumeration method. This is the command that will be used
    to determine whether a user actually exists on the targeted server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`: This is used to specify a single username to check for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-U`: This is used to specify a list of usernames to check for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t`: This is used to specify a single host to target with the enumeration
    attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-T`: This allows you to specify a `HOST_FILE`, which is a list of hosts to
    target with the attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h`: This specifies the `help` file of output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–v`: This specifies the verbosity of output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use `smtp-user-enum` effectively, you need a pretty comprehensive username
    list. There are tons of them on the web; for our purposes, we will simply grab
    the `/etc/passwd`, pull it through `awk`, and use the list of users on our host
    system to guess with. This is also a great way to fingerprint operating systems
    similar to your own. It is done by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strip out the usernames as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Target the `smtp` server with the enum attack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`smtp-user-enum` will then use the `VRFY` command to determine whether the
    users exist on your target. You could also specify other methods for enumeration
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That's about it as far as SMTP enumeration goes; from here on out, you should
    record the usernames you enumerate and replay them the next time you need to run
    an SMTP username enumeration attack.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-forcing authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many successes or failures in penetration tests come down to how well you can
    guess passwords. This may surprise you, but network engineers and developers do
    get it right sometimes and you will need to rely on the predictability of the
    users to find your way "in". Kali Linux offers a range of new, sophisticated,
    old, and well-trusted authentication cracking tools, and these tools will typically
    be your point of call when it comes to guessing passwords really quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Using Medusa
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Medusa is one of the better multipurpose cracker tools available with Kali Linux.
    It supports many different modes of authentication and also allows you to define
    your own plugins should you encounter anything it doesn't inherently support.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can invoke medusa by using the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Medusa supports a number of modules. You can find out which modules your version
    supports by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will produce a list of the supported modules. If you''d
    like to use one of them, you can specify the name of the module using the `–M`
    switch, as in the preceding usage specification. Here''s an example, targeting
    the SSH service on `192.168.10.105`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Medusa](img/5107OT_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, you could target other services, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Medusa also allows you to develop your own modules for brute-forcing and offers
    pretty useful ways of specifying password and username lists. For more about Medusa's
    other options, please refer to the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic filtering with TCPDump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCPDump is one of the most prolifically used network traffic inspection tools
    used to date. It supports a number of rich information-driven features and just
    like the rest of the tools discussed in this book, it offers a purely command-line-driven
    interface. TCPDump allows you to filter network traffic for useful information.
    Here, we will be covering some basic usage. Later, we will move on to how to use
    TCPDump to inspect just the traffic you are interested it, and all this will be
    straight from the comfort of your trusty bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with TCPDump
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, let''s look at the usage specification for TCPDump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this little packet dumping tool is packed with features and
    can pretty much cater to your every packet analysis need. As a proverbial "hello
    world" example, let''s invoke TCPDump in its most basic form and see what it does.
    It can be invoked by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You need root access rights to run `tcpdump` but, since Kali runs as root by
    default, all you need to do is open a terminal and invoke the previous command.
    The preceding command should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with TCPDump](img/5107OT_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What you see in the preceding screenshot is that TCPDump first lets you know
    that there are other invocation options available, specifically those governing
    the verbosity of the output. The TCPDump developers thought it would be a good
    idea to let you know about the more verbose options, if invoked with no arguments.
    If you use the verbose switches, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with TCPDump](img/5107OT_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'TCPDump decodes the structure of the packet a little more as you can see in
    the previous example, and it provides a little more detail. For instance, the
    IP, TCP, and UDP flags are included in the packet dump. Besides controlling the
    verboseness of the output, you can also control how packet capturing works. These
    options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-i`: This allows you to specify the interface to capture on. TCPDump autonomously
    polls the operating system for configured interfaces and starts capturing on the
    first one it finds. This option allows you to strictly specify the interface to
    be used. If you need help finding out which interfaces are available, try executing
    the `ifconfig –a` command. Alternatively, you could use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will list the interfaces that `tcpdump` has identified as available for
    packet capture.
  prefs: []
  type: TYPE_NORMAL
- en: '`-c`: This allows you to specify the number of packets to capture before exiting
    `tcpdump`. This is great if you don''t need to capture packets indefinitely or
    would like to sample a specified number of packets that meet the criteria of a
    given filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w`: This allows you to specify a file to save the packet capture to. This
    option works great for audit trailing on remote penetration tests, since you can
    clearly evidence what your machine sent and received from the host. There is also
    very little evidence that is more succinct than a packet capture for certain penetration
    test findings. In fact, if you can, give these files to your clients to replay
    on their vulnerable devices! Which makes for a pretty effective way of autonomously
    building proof of concepts for your findings as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: This reads packets from a file. This is the complement to the `–w` option
    detailed in the preceding bullet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-A`: When printing packets, this omits the link level header and prints them
    in ASCII as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-x`: This prints packets in hex, without their link level headers. This is
    great if you need to stick the results of your capture in a fuzzing framework
    or C/C++ program to mangle in raw form later on. It''s also a way of printing
    the packet in the most honest and raw form, while still keeping it free from printable
    encoding shortcomings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-I`: This puts interfaces in monitor mode. This only works for certain wireless
    interfaces; some drivers don''t properly support this function. This option allows
    your wireless interface to capture packets that are being broadcast to any and
    all devices on the network, without the requirement of being associated with an
    access point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s`: This allows you to specify `snaplen` or capture length. This is the number
    of maximum bytes to capture per packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCPDump has a number of other useful functions. Here, we've discussed the ones
    you will likely find most useful in your daily activities as a system administrator,
    developer, or penetration tester. For more about TCPDump's other functions, please
    refer to the *Further reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The following section talks about a very powerful function in TCPDump, namely
    the ability to filter packets based on a description of their attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the TCPDump packet filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCPDump has a powerful language you can use to describe and filter packets,
    ranging from matching semantic attributes of the packets, protocols, hosts, and
    ports being used right down to filtering attributes in the TCP and UDP headers.
    In this section, we''re going to go over how the packet filter language works
    and how you filter packets for certain attributes. You can specify some attributes
    for TCPDump to filter on by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the previous command, `[filter]` will be the description of the attributes
    you would like to filter on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an easy to understand structure to the expressions; it works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What this means is that each expression consists either of a collection of
    expressions glued together by logical operators, or of a qualifier and an ID.
    Each of these elements is broken down. If you put all this together, it means
    you can specify filters such as the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command matches all packets that have `192.168.10.102` set as
    either the source or destination. This filter is equivalent to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the TCPDump packet filter](img/5107OT_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You could also match this against entire networks, for example, everything
    in the `192.168.10.0-255` subnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also agglutinate other qualifiers to this as in the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the TCPDump packet filter](img/5107OT_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This will match all the TCP data coming from or going to any host on the `192.168.10.0/24`
    network using port 80.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use any of the qualifiers on their own, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Besides specifying packets based on broad, semantic descriptions of their attributes
    (ports, protocols, and direction), you can also specify very fine-grained details
    about the packets themselves, down to describing any of the values for any of
    the fields in the filtered packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have `tcpdump` match packets against attributes in the `TCP`, `ICMP`,
    or `UDP` or any of the supported protocol header values. This is done by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the TCPDump packet filter](img/5107OT_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What this does is tell TCPDump to check that the TCP header at byte offset
    13 is set to `2`, which means this is a `SYN` packet. Here are a few other popular
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also some mnemonics available for the TCP and ICMP flags; you can
    use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for ICMP packets you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You will need to know a little about the TCP header structure to take full advantage
    of this function. If you'd like to find out more about TCP protocol, packet structure,
    and operation, please see some of the links in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing SSL implementation security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For decades, people have been using encryption, hashing, and key exchange mechanisms
    to securely communicate information over untrusted networks. They will use complex
    and convoluted combinations of hashing, encrypting, and exchanging of cryptographic
    primitives to establish a secure communication channel. The SSL and TLS family
    of protocols are a set of rules specifying how cryptographic primitives, communication
    data, and other attributes of communication are managed in order to ensure secure
    conversations from client to server and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, many SSL/TLS versions have suffered a number of devastating vulnerabilities
    throughout their existence. Some of the attacks published have only surfaced quite
    recently and still impact many SSL/TLS implementations. Besides the flaws in the
    inherent implementation of TLS/SSL, there are also problems that commonly arise
    in configuration of these services—mistakes in how they are used, not how they
    work. Many out-of-the-box configurations support scandalously vulnerable and outdated
    cipher suites and others don't offer much robust protection at all; some even
    completely omit encryption or message authentication schemes!
  prefs: []
  type: TYPE_NORMAL
- en: The following section of this chapter will detail ways you can assess SSL/TLS
    implementations using a very popular tool called SSLyze. It will also show you
    some novel bash hacks you can use to automate risk analysis of SSL/TLS implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Using SSLyze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSLyze is another excellent tool developed by the folks at iSec partners and
    I can honestly say, in my experience not a penetration test or vulnerability assessment
    goes by where it hasn't come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: What SSLyze does is make connections to the SSL service implemented on a target
    server; it tries to detail the SSL/TLS cipher suites and other SSL/TLS configuration
    specifics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the usage specification for SSLyze:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what happens when we point SSLyze at a SSL/TLS-capable web server;
    you can do that by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you want to assess the SSL implementation `192.168.10.101`,
    specifically querying the TLS Version 1 configuration, you will execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SSLyze](img/5107OT_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What we see in the preceding screenshot is the specifications for the configured
    cipher suites on offer. It specifically mentions the cipher suites supported by
    the server and the length of the symmetric keys in use for the given symmetric
    cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each cipher suite is described according to the key exchange algorithm, symmetric
    encryption algorithm and message digest—or hashing—algorithm and pseudorandom
    function. Here''s an example of a cipher suite name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TLS_RSA_WITH_AES_256_CBC_SHA`'
  prefs: []
  type: TYPE_NORMAL
- en: The first few letters before the underscore either mention the key exchange
    mechanism, or that the cipher suite is intended for use in the TLS protocol. Here,
    the key exchange mechanism is `RSA`. The next specification is for the symmetric
    encryption operation. Here, this is indicated as `AES_256`, which is the AES algorithm
    with a block length of 256 used in **Cipher Block Chaining** (**CBC**) mode. After
    the encryption algorithm is mentioned, the cipher suite mentions the hashing algorithm.
    Here, it's indicated as SHA.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSLyze has support for all of the SSL/TLS versions, and you can specify which
    to test for as a command line option. If you''d like to test all of them, you
    would specify the following command line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides TLS/SSL versions, you can also have it test for other attributes. Here''s
    how some of the other options work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--reneg`: This test is used for renegotiation support. Pay attention to the
    client-initiated renegotiation; in SSL versions, this could mean a DoS vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--compression`: This test is used for message compression support. In TLS
    Version 1.0, this presents as a critical information leakage vulnerability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--resum`: This test is used for resumption support using either session IDs
    or TLS session tickets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another very useful option SSLyze offers is a shortcut for most of the commonly
    used options. Here''s how you use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The premise for whether a cipher is potentially dangerous or not depends on
    whether it harbors any practically exploitable flaws if the server supports such
    vulnerable cipher suites. The danger is that clients may be exposed to attacks
    that proliferate information about their communication with the affected server.
    For instance, if the server supports cipher suits that use symmetric ciphers of
    vulnerable key lengths, usually less than 128 bits, it's pretty easy to envision
    that attackers could brute-force the session keys being used during the SSL/TLS
    session. There are probably many assessment methodologies available online. I've
    included a pretty good one from Qualys Labs in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Bash hacks and SSLyze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve come to grips with which SSL suites, key lengths, and other TLS/SSL
    configuration auxiliaries are to be treated as vulnerable, you could filter the
    SSLyze output to highlight vulnerable configuration specifics. One way to do this—and
    avoid reading through all the input and manually looking for vulnerable instances—is
    to use a bash script. Here''s an example you can use and modify during your SSL
    assessments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous script takes the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HOST`: This is the IP address to assess'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SSL_PORT`: This is the port number being used for SSL/TLS service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_LEN_LIMIT`: This is the lowest limit for a secure key, for example 128'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VULN_SUIT_LIST`: This is a list of cipher suits considered vulnerable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bash hacks and SSLyze](img/5107OT_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `./vulnerable_cipher_list` is a file containing a cipher suite name on
    each line, following is an example of one. It mentions some of the cipher suites
    with the word `NULL` in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A more complete list of these cipher is available from the book's site.
  prefs: []
  type: TYPE_NORMAL
- en: Automated web application security assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications are incredibly complex pieces of technology, and they become
    more complex every day. It's not hard to imagine that penetration testing these
    big, heavy, and often very sneaky applications can be quite a cumbersome task.
    Luckily, a considerable portion of the work that goes into web application security
    assessment can be automated. I say "portion" because there are attack surfaces
    for web applications that have not seen much successful automation, that is, XSS
    requiring user interaction, customized encryption flaws, and business logic flaws.
    It is never safe to assume you have a good grip of web application security if
    all you've done is run a scanner! That being said, tasks such as crawling, fuzzing
    headers, picking up authentication forms, and other simple repetitive tasks have
    been automated in web application scanners very well. In this section, we will
    look at a small selection of the command line-driven tools available in Kali Linux
    to automate web application security assessment.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with SkipFish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SkipFish is a tool both used and created by some of the folks who work at Google.
    SkipFish as with most of the tools in its field simply crawls a web application
    and passes each page it picks up through a detection engine in an effort to analyze
    the page for common flaws and wrong configurations. SkipFish reports its output
    in the form of an interactive web page. Let's get a look at how one uses SkipFish
    and some of the functionalities it supports.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch SkipFish, you will need two essential things: a word list and a directory
    to store its results. Perform the following steps to get it working:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare an output directory for SkipFish by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Grab a sample word list for SkipFish to work with by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the medium dictionary. This is merely a demonstration; feel
    free to try some of the other dictionaries in the mentioned folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure the directory is not marked as read-only; you''ll need to remove
    the very first line of this file since it''s shipped with SkipFish as read only.
    You''ll need to remove the line that looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now launch SkipFish by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole process will look like the following screenshot when executed on
    the Kali Linux command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with SkipFish](img/5107OT_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When it''s done running, SkipFish will present you with the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with SkipFish](img/5107OT_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If this is the very first time you're running SkipFish, you could abort it preemptively,
    since it will automatically report all the results collected this far. You can
    do this by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When SkipFish is done running, it will present you with an `index.html` file
    in the directory you created for its output. This file contains the report. A
    SkipFish report looks like the following screenshot when opened in Iceweasel,
    the default browser for Kali Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scanning with SkipFish](img/5107OT_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SkipFish supports a number of other invocation options, some of which control
    how word lists are treated; others control how aggressive SkipFish is during testing.
    For more on these options, I suggest seeing some of the links in the *Further
    reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning with Arachni
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arachni is another great command line-driven web application scanning tool
    available in Kali Linux. It comes with a range of modules and plugins allowing
    its users to assess a mosaic of web application security focus areas. To launch
    Arachni in its default mode, you have to invoke the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, if you''d like to target [privatebankloans.com](http://privatebankloans.com)
    with an Arachni scan, you will issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will load all the scanning modules and have Arachni target all possible
    attack surfaces for the specified web application. You can also focus Arachni
    on a given type of scanning. For instance, to run detection for XSS vulnerabilities
    only, you will specify the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To load all the audit modules, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can list the available modules by using the `–-lsmod` command line option.
    This option takes a regular expression as an argument and looks up all the modules
    whose names produce a match, Arachni then displays some basic information about
    them. Arachni also supports a reporting framework that allows you to generate
    neatly formatted reports about the issues it finds. You can use it by typing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Where `[FORMAT]` is the document format you'd like to report in and `FILENAME`
    is the filename the report is to be saved under. `FORMAT` could be either HTML,
    `.txt`, or many others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example that generates an HTML report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As with many of the command-line arguments, you can specify more than one report
    format. This will cause multiple reports to be generated, as specified in the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Arachni supports a range arguments that control other aspects of its operation.
    Please see the *Further reading* section for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned to use various tools to assess different layers
    of the OSI protocol stack. We covered tools that attack layer 2 protocol implementations,
    namely ARP and other MAC-based authentication schemes.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered simple ARP poisoning attacks using ArpSpoof and saw how to forge
    MAC addresses. Building on this, we applied these techniques to perform full MITM
    attacks that allow us to intercept traffic and spoof DNS servers.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also included sections dedicated to techniques that target SMTP
    and SNMP services on a local network. These sections detailed the usage of a tool
    called `snmpwalk` as well as the Metasploit modules `snmp-enum` and `snmp-login`,
    which were used to brute-force SNMP authentication. The information gathering
    section closed with a discussion of SMTP enumeration attacks, and we learned to
    use the `smtp-user-enum` tool to pull this off.
  prefs: []
  type: TYPE_NORMAL
- en: Other than abusing the function of network protocols, the chapter also talked
    about abusing the implementation of security measures, specifically authentication
    credential—passwords, usernames, security tokens and so on. We covered a very
    powerful authentication brute-forcing tool called Medusa, which supports a variety
    of authentication mechanisms such as SSH, FTP, and even web HTML forms.
  prefs: []
  type: TYPE_NORMAL
- en: After learning to attack, we took a step back for one section and covered a
    useful packet analysis and traffic monitoring tool called TCPDump. We learned
    to use TCPDump to filter packets based on hosts, ports, and even detailed filtering
    down to the very offsets in the transport layer packets.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the chapter covered SSL security assessments and demonstrated how to use
    SSLyze to enumerate the implemented cipher suites and SSL/TLS versions on a targeted
    host. We also learned about a useful bash script that aids detection of flawed
    ciphers and allows us to change the definition of a vulnerable cipher suite dependent
    on our assessment needs.
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter by learning to use two very powerful web application
    scanning tools, namely SkipFish and Arachni.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was meant to serve as an introduction to the very powerful and
    flexible tools discussed. I urge everyone who reads this chapter to study the
    tools we've discussed and get to know their strengths and weaknesses and combine
    them to create a powerful security assessment arsenal. When you're done mastering
    these tools, write some of your own!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCPDump filters at [http://www.wains.be/pub/networking/tcpdump_advanced_filters.txt](http://www.wains.be/pub/networking/tcpdump_advanced_filters.txt)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCPDump manual at [http://www.tcpdump.org/manpages/tcpdump.1.html](http://www.tcpdump.org/manpages/tcpdump.1.html)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCPDump filters at [http://www.cs.ucr.edu/~marios/ethereal-tcpdump.pdf](http://www.cs.ucr.edu/~marios/ethereal-tcpdump.pdf)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCPDump & libpacp at [http://www.tcpdump.org/](http://www.tcpdump.org/) (accessed
    2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethernet Address Resolution Protocol at [http://tools.ietf.org/html/rfc826](http://tools.ietf.org/html/rfc826)
    (accessed 2014/04/03)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSLyze Github page at [https://github.com/iSECPartners/sslyze](https://github.com/iSECPartners/sslyze)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL Deployment Best Practices at [https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices_1.3.pdf](https://www.ssllabs.com/downloads/SSL_TLS_Deployment_Best_Practices_1.3.pdf)
    September 2013, (accessed 2014/04/03)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Transport Layer Security (TLS) Protocol Version 1.2 at [http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Secure Socket Layer (SSL) Protocol Version 3.0 at [http://tools.ietf.org/html/rfc6101](http://tools.ietf.org/html/rfc6101)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysis of the SSL 3.0 Protocol at [https://www.schneier.com/paper-ssl.pdf](https://www.schneier.com/paper-ssl.pdf)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression and Information Leakage of Plaintext at [http://www.iacr.org/cryptodb/archive/2002/FSE/3091/3091.pdf](http://www.iacr.org/cryptodb/archive/2002/FSE/3091/3091.pdf)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS & SSLv3 Renegotiation Vulnerability at [http://www.g-sec.lu/practicaltls.pdf](http://www.g-sec.lu/practicaltls.pdf)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breach TLS HTTP Compression vulnerability at [http://breachattack.com/](http://breachattack.com/)
    (accessed 2014/03/30)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS Cipher Suite Registry at [https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4)
    (accessed 2014/04/01)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the security of RC4 in TLS and WPA at [http://www.isg.rhul.ac.uk/tls/](http://www.isg.rhul.ac.uk/tls/)
    (accessed 2014/04/01)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential SNMP at [http://oreilly.com/catalog/esnmp/chapter/ch02.html](http://oreilly.com/catalog/esnmp/chapter/ch02.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vulnerabilities in SNMPv3 at [https://smartech.gatech.edu/bitstream/handle/1853/44881/lawrence_nigel_r_201208_mast.pdf?sequence=2](https://smartech.gatech.edu/bitstream/handle/1853/44881/lawrence_nigel_r_201208_mast.pdf?sequence=2)
    (accessed 2014/04/06)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cisco Security Advisory : SNMP Version 3 Authentication Vulnerabilities at
    [http://www.securityfocus.com/archive/1/493238](http://www.securityfocus.com/archive/1/493238)
    (accessed 2014/04/06)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple Vendor SNMPv3 HMAC Security bypass at [http://www.iss.net/security_center/reference/vuln/SNMP_V3_HMAC_Security_Bypass.htm](http://www.iss.net/security_center/reference/vuln/SNMP_V3_HMAC_Security_Bypass.htm)
    (accessed 2014/04/06)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL Good Practice Guide at [https://labs.portcullis.co.uk/whitepapers/ssl-good-practice-guide/](https://labs.portcullis.co.uk/whitepapers/ssl-good-practice-guide/)
    (accessed 2014/04/07)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Medusa Parallel Network Login Auditor at [http://foofus.net/goons/jmk/medusa/medusa.html](http://foofus.net/goons/jmk/medusa/medusa.html)
    (accessed 2014/04/07)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ncrack official Page at [http://nmap.org/ncrack/](http://nmap.org/ncrack/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arachni Command line User interface at [https://github.com/Arachni/arachni/wiki/Command-line-user-interface](https://github.com/Arachni/arachni/wiki/Command-line-user-interface)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
