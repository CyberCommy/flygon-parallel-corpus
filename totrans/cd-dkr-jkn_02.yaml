- en: Introducing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will discuss how the modern Continuous Delivery process should look by introducing
    Docker, the technology that changed the IT industry and the way the servers are
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the idea of virtualization and containerization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker for different local and server environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the architecture of the Docker toolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images with Dockerfile and by committing changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running applications as Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Docker networks and port forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Docker volumes as a shared storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Docker?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker is an open source project designed to help with application deployment
    using software containers. This quote is from the official Docker page:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Docker containers wrap a piece of software in a complete filesystem that contains
    everything needed to run: code, runtime, system tools, system libraries - anything
    that can be installed on a server. This guarantees that the software will always
    run the same, regardless of its environment."'
  prefs: []
  type: TYPE_NORMAL
- en: Docker, therefore, in a similar way as virtualization, allows packaging an application
    into an image that can be run everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization versus virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without Docker, isolation and other benefits can be achieved with the use of
    hardware virtualization, often called virtual machines. The most popular solutions
    are VirtualBox, VMware, and Parallels. A virtual machine emulates a computer architecture
    and provides the functionality of a physical computer. We can achieve complete
    isolation of applications if each of them is delivered and run as a separate virtual
    machine image. The following figure presents the concept of virtualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/020d670e-74d0-41e8-af9d-8598b12046c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each application is launched as a separate image with all dependencies and
    a guest operating system. Images are run by the hypervisor, which emulates the
    physical computer architecture. This method of deployment is widely supported
    by many tools (such as Vagrant) and dedicated to development and testing environments.
    Virtualization, however, has three significant drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low performance**: The virtual machine emulates the whole computer architecture
    to run the guest operating system, so there is a significant overhead associated
    with each operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High resource consumption**: Emulation requires a lot of resources and has
    to be done separately for each application. This is why, on a standard desktop
    machine, only a few applications can be run simultaneously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large image size**: Each application is delivered with a full operating system,
    so the deployment on a server implies sending and storing a large amount of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The concept of containerization presents a different solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41c0db73-c10e-42f2-8fec-f45e28ef52f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Each application is delivered together with its dependencies, but, without the
    operating system. Applications interface directly with the host operating system,
    so there is no additional layer of the guest operating system. It results in better
    performance and no waste of resources. Moreover, shipped Docker images are significantly
    smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in the case of containerization, the isolation happens at the level
    of the host operating system's processes. It doesn't mean, however, that the containers
    share their dependencies. Each of them has their own libraries in the right version,
    and if any of them is updated, it has no impact on the others. To achieve this,
    Docker Engine creates a set of Linux namespaces and control groups for the container.
    This is why the Docker security is based on the Linux kernel process isolation.
    This solution, although mature enough, could be considered slightly less secure
    than the complete operating system-based isolation offered by virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: The need for Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker containerization solves a number of problems seen in traditional software
    delivery. Let's take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing and running software is complex. You need to decide about the operating
    system, resources, libraries, services, permissions, other software, and everything
    your application depends on. Then, you need to know how to install it. What's
    more, there may be some conflicting dependencies. What do you do then? What if
    your software needs an upgrade of a library but the other does not? In some companies,
    such issues are solved by having **classes of applications**, and each class is
    served by a dedicated server, for example, a server for web services with Java
    7, another one for batch jobs with Java 8, and so on. This solution, however,
    is not balanced in terms of resources and requires an army of IT operations teams
    to take care of all production and test servers.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the environment complexity is that it often requires a
    specialist to run an application. A less technical person may have a hard time
    setting up MySQL, ODBC, or any other slightly more sophisticated tool. This is
    particularly true for applications not delivered as an operating system-specific
    binary but which require source code compilation or any other environment-specific
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Isolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keep the workspace tidy. One application can change the behavior of the other
    one. Imagine what can happen. Applications share one filesystem, so if application
    A writes something to the wrong directory, application B reads the incorrect data.
    They share resources, so if there is a memory leak in application A, it can freeze
    not only itself but also application B. They share network interfaces, so if applications
    A and B both use port `8080`, one of them will crash. Isolation concerns the security
    aspects too. Running a buggy application or malicious software can cause damage
    to other applications. This is why it is a much safer approach to keep each application
    inside a separate sandbox, which limits the scope of damage impact to the application
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servers often end up looking messy with a ton of running applications nobody
    knows anything about. How will you check what applications are running on the
    server and what dependencies each of them is using? They could depend on libraries,
    other applications, or tools. Without the exhaustive documentation, all we can
    do is look at the running processes and start guessing. Docker keeps things organized
    by having each application as a separate container that can be listed, searched,
    and monitored.
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <q>Write once, run anywhere,</q> said the slogan while advertising the earliest
    versions of Java. Indeed, Java addresses the portability issue quite well; however,
    I can still think of a few cases where it fails, for example, the incompatible
    native dependencies or the older version of the Java runtime. Moreover, not all
    software is written in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Docker moves the concept of portability one level higher; if the Docker version
    is compatible, then the shipped software works correctly regardless of the programming
    language, operating system, or environment configuration. Docker, then, can be
    expressed by the slogan <q>Ship the entire environment instead of just code.</q>
  prefs: []
  type: TYPE_NORMAL
- en: Kittens and cattle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The difference between traditional software deployment and Docker-based deployment
    is often expressed with an analogy of kittens and cattle. Everybody likes kittens.
    Kittens are unique. Each has its own name and needs special treatment. Kittens
    are treated with emotion. We cry when they die. On the contrary, cattle exist
    only to satisfy our needs. Even the form cattle is singular since it's just a
    pack of animals treated together. No naming, no uniqueness. Surely, they are unique
    (the same as each server is unique), but it is irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: This is why the most straightforward explanation of the idea behind Docker is
    <q>Treat your servers like cattle, not pets.</q>
  prefs: []
  type: TYPE_NORMAL
- en: Alternative containerization technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is not the only containerization system available on the market. Actually,
    the first versions of Docker were based on the open source **LXC** (**Linux Containers**)
    system, which is an alternative platform for containers. Other known solutions
    are FreeBSD Jails, OpenVZ, and Solaris Containers. Docker, however, overtook all
    other systems because of its simplicity, good marketing, and startup approach.
    It works under most operating systems, allows you to do something useful in less
    than 15 minutes, has a lot of simple-to-use features, good tutorials, a great
    community, and probably the best logo in the IT industry.
  prefs: []
  type: TYPE_NORMAL
- en: Docker installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker's installation process is quick and simple. Currently, it's supported
    on most Linux operating systems and a wide range of them have dedicated binaries
    provided. Mac and Windows are also well supported with native applications. However,
    it's important to understand that Docker is internally based on the Linux kernel
    and its specifics, and this is why, in the case of Mac and Windows, it uses virtual
    machines (xhyve for Mac and Hyper-V for Windows) to run the Docker Engine environment.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker requirements are specific for each operating system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mac**:'
  prefs: []
  type: TYPE_NORMAL
- en: 2010 or newer model, with Intel’s hardware support for **memory management unit**
    (**MMU**) virtualization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS 10.10.3 Yosemite or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 4GB of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No VirtualBox prior to version 4.3.30 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**:'
  prefs: []
  type: TYPE_NORMAL
- en: 64-bit Windows 10 Pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Hyper-V package enabled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Linux**:'
  prefs: []
  type: TYPE_NORMAL
- en: 64-bit architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel 3.10 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your machine does not meet the requirements, then the solution is to use
    VirtualBox with the Ubuntu operating system installed. This workaround, even though
    it sounds complicated, is not necessarily the worst method, especially taking
    into consideration that the Docker Engine environment is virtualized anyway in
    the case of Mac and Windows. Furthermore, Ubuntu is one of the best-supported
    systems for using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: All examples in this book have been tested on the Ubuntu 16.04 operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing on a local machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dockers installation process is straightforward and very well described on its
    official pages.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/installation/linux/ubuntulinux/](https://docs.docker.com/engine/installation/linux/ubuntulinux/)
    contains a guide on how to install Docker on an Ubuntu machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Ubuntu 16.04, I''ve executed the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After all operations are completed, Docker should be installed. However, at
    the moment, the only user allowed to use Docker commands is `root`. This means
    that the `sudo` keyword must precede every Docker command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enable other users to use Docker by adding them to the `docker` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: After a successful logout, everything is set up. With the latest command, however,
    we need to take some precautions not to give the Docker permissions to an unwanted
    user, and therefore create a vulnerability in the Docker Engine. This is particularly
    important in the case of installation on the server machine.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/installation/linux/](https://docs.docker.com/engine/installation/linux/)
    contains installation guides for most Linux distributions.'
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Mac
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/docker-for-mac/](https://docs.docker.com/docker-for-mac/)
    contains a step-by-step guide on how to install Docker on a Mac machine. It is
    delivered together with a collection of Docker components:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machine with Docker Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Machine (a tool used to create Docker hosts on the virtual machine)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kitematic: a GUI application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Machine tool helps in installing and managing Docker Engine on Mac,
    Windows, on company networks, in data centers, and on cloud providers such as
    AWS or Digital Ocean.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/docker-for-windows/](https://docs.docker.com/docker-for-windows/)
    contains a step-by-step guide on how to install Docker on a Windows machine. It
    is delivered together with a collection of Docker components similar to Mac.'
  prefs: []
  type: TYPE_NORMAL
- en: The installation guides for all supported operating systems and cloud platforms
    can be found on the official Docker page, [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: Testing Docker installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No matter which installation you''ve chosen (Mac, Windows, Ubuntu, Linux, or
    other), Docker should be set up and ready. The best way to test it is to run the
    `docker info` command. The output message should be similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installing on a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use Docker over the network, it is possible to either take advantage
    of cloud platform providers or to manually install Docker on a dedicated server.
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, the Docker configuration differs from one platform to another,
    but it is always very well described in dedicated tutorials. Most cloud platforms
    enable creating Docker hosts via user-friendly web interfaces or describe exact
    commands to execute on their servers.
  prefs: []
  type: TYPE_NORMAL
- en: The second case (installing Docker manually) requires, however, a few words
    of comment.
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Docker manually on a server does not differ much from the local installation.
  prefs: []
  type: TYPE_NORMAL
- en: Two additional steps are required that include setting the Docker daemon to
    listen on the network socket and setting security certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start from the first step. By default, due to security reasons, Docker
    runs via a non-networked Unix socket that only allows local communication. It's
    necessary to add listening on the chosen network interface socket so that the
    external clients can connect. [https://docs.docker.com/engine/admin/](https://docs.docker.com/engine/admin/)
    describes in detail all the configuration steps needed for each Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of Ubuntu, the Docker daemon is configured by the systemd, so in
    order to change the configuration of how it''s started, we need to modify one
    line in the `/lib/systemd/system/docker.service` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By changing this line, we enabled the access to the Docker daemon via the specified
    IP address. All the details on the systemd configuration can be found at [https://docs.docker.com/engine/admin/systemd/](https://docs.docker.com/engine/admin/systemd/).
  prefs: []
  type: TYPE_NORMAL
- en: The second step of server configuration concerns the Docker security certificates.
    This enables only clients authenticated by a certificate to access the server.
    The comprehensive description of the Docker certificates configuration can be
    found at [https://docs.docker.com/engine/security/https/](https://docs.docker.com/engine/security/https/).
    This step isn't strictly required; however, unless your Docker daemon server is
    inside the firewalled network, it is essential.
  prefs: []
  type: TYPE_NORMAL
- en: If your Docker daemon is run inside the corporate network, you have to configure
    the HTTP proxy. The detailed description can be found at [https://docs.docker.com/engine/admin/systemd/](https://docs.docker.com/engine/admin/systemd/).
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker hello world>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker environment is set up and ready, so we can start the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations, you''ve just run your first Docker container. I hope you already
    feel how simple Docker is. Let''s examine step-by-step what happened under the
    hood:'
  prefs: []
  type: TYPE_NORMAL
- en: You ran the Docker client with the `run` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker client contacted the Docker daemon asking to create a container from
    the image called `hello-world`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon checked if it contained the `hello-world` image locally and,
    since it didn't, requested the `hello-world` image from the remote Docker Hub
    registry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker Hub registry contained the `hello-world` image, so it was pulled
    into the Docker daemon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon created a new container from the `hello-world` image that
    started the executable producing the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker daemon streamed this output to the Docker client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker client sent it to your terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The projected flow can be presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/991a6408-e39f-4455-80eb-b42d883c3a49.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at each Docker component that was illustrated in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Docker page says this:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Docker Engine is a client-server application that creates and manages Docker
    objects, such as images and containers."'
  prefs: []
  type: TYPE_NORMAL
- en: Let's sort out what this means.
  prefs: []
  type: TYPE_NORMAL
- en: Docker client and server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a diagram that presents the Docker Engine architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22168b81-9283-421d-8295-d0af9d675db3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Docker Engine consists of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Daemon** (server) running in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Client** running as a command tool'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REST API**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker Engine means installing all the components so that the Docker
    daemon runs on our computer all the time as a service. In the case of the `hello-world`
    example, we used the Docker client to interact with the Docker daemon; however,
    we could do exactly the same using REST API. Also, in the case of the hello-world
    example, we connected to the local Docker daemon; however, we could use the same
    client to interact with the Docker daemon running on a remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the Docker container on a remote machine, you can use the `-H` option:
     `docker -H <server_ip>:2375 run hello-world`'
  prefs: []
  type: TYPE_NORMAL
- en: Docker images and containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An image is a stateless building block in the Docker world. You can imagine
    an image as a collection of all files necessary to run your application together
    with the recipe on how to run it. The image is stateless, so you can send it over
    the network, store it in the registry, name it, version it, and save it as a file.
    Images are layered, which means that you can build an image on top of another
    image.
  prefs: []
  type: TYPE_NORMAL
- en: A container is a running instance of an image. We can create many containers
    from the same image if we want to have many instances of the same application.
    Since containers are stateful, we can interact with them and make changes to their
    states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the example of a container and the image layers structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0099e866-f813-47d3-a4b7-b34fb88f722b.png)'
  prefs: []
  type: TYPE_IMG
- en: At the bottom, there is always the base image. In most cases, it represents
    an operating system, and we build our images on top of the existing base images.
    It's technically possible to create own base images however, this is rarely needed.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `ubuntu` base image provides all the capabilities of the
    Ubuntu operating system. The `add git` image adds the Git toolkit. Then, there
    is an image adding the JDK environment. Finally, on the top, there is a container
    created from the `add JDK` image. Such container is able, for example, to download
    a Java project from the GitHub repository and compile it to a JAR file. As a result,
    we can use this container to compile and run Java projects without installing
    any tools on our operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to notice that layering is a very smart mechanism to save bandwidth
    and storage. Imagine that we have an application that is also based on `ubuntu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/26c3a1aa-7f15-49e9-9c27-e5a2ed80fbdb.png)'
  prefs: []
  type: TYPE_IMG
- en: This time we will use the Python interpreter. While installing the `add python`
    image, the Docker daemon will note that the `ubuntu` image is already installed,
    and what it needs to do is only to add the `python` layer, which is very small.
    So, the `ubuntu` image is a dependency that is reused. The same if we would like
    to deploy our image in the network. When we deploy the Git and JDK application,
    we need to send the whole `ubuntu` image. However, while subsequently deploying
    the `python` application, we need to send just the small `add python` layer.
  prefs: []
  type: TYPE_NORMAL
- en: Docker applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of applications are provided in the form of Docker images that can be
    downloaded from the internet. If we knew the image name, then it would be enough
    to run it in the same way we did with the hello world example. How can we find
    the desired application image on the Docker Hub?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take MongoDB as an example.  If we like to find it on the Docker Hub,
    we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Search on the Docker Hub Explore page ([https://hub.docker.com/explore/](https://hub.docker.com/explore/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `docker search` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the second case, we can perform the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many interesting options. How do we choose the best image? Usually,
    the most appealing one is the one without any prefix, since it means that it''s
    an official Docker Hub image and should be therefore stable and maintained. The
    images with prefixes are unofficial, usually maintained as open source projects.
    In our case, the best choice seems to be `mongo`, so in order to run the MongoDB
    server, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's all, MongoDB has started. Running applications as Docker containers is
    that simple because we don't need to think of any dependencies; they are all delivered
    together with the image.
  prefs: []
  type: TYPE_NORMAL
- en: On the Docker Hub service, you can find a lot of applications; they store more
    than 100,000 different images.
  prefs: []
  type: TYPE_NORMAL
- en: Building images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker can be treated as a useful tool to run applications; however, the real
    power lies in building own Docker images that wrap the programs together with
    the environment. In this section, we will see how to do this using two different
    methods, the Docker `commit` command and the Dockerfile automated build.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with an example and prepare an image with the Git and JDK toolkits.
    We will use Ubuntu 16.04 as a base image. There is no need to create it; most
    base images are available in the Docker Hub registry:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a container from the `ubuntu:16.04` and connect it to its command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've pulled the `ubuntu:16.04` image and run it as a container and then called
    the `/bin/bash` command in an interactive way (`-i` flag). You should see the
    terminal of the container. Since containers are stateful and writable, we can
    do anything we want in its terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the Git toolkit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Check if the Git toolkit is installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Exit the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Check what has changed in the container comparing it to the `ubuntu` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The command should print a list of all files changed in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commit the container to the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve just created our first Docker image. Let''s list all the images of our
    Docker host to see if the image is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we see `hello-world`, `mongo` (installed before), `ubuntu` (base
    image pulled from Docker Hub), and freshly built `ubuntu_with_git`. By the way,
    we can observe the size of each image that corresponds to what we've installed
    on the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we create a container from the image, it will have the Git tool installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the exact same method, we can build `ubuntu_with_git_and_jdk` on top
    of the `ubuntu_with_git` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating each Docker image manually with the commit command could be laborious,
    especially in the case of build automation and the Continuous Delivery process.
    Luckily, there is a built-in language to specify all the instructions that should
    be executed to build the Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an example similar to the one with Git and JDK. This time,
    we will prepare the `ubuntu_with_python` image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory and a file called `Dockerfile` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the command to create the `ubuntu_with_python` image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the image was created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now create a container from the image and check that the Python interpreter
    exists in exactly the same way we did after executing the `docker commit` command.
    Note that the `ubuntu` image is listed only once even though it's the base image
    for both `ubuntu_with_git` and `ubuntu_with_python`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we used the first two Dockerfile instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM` defines the image on top of which the new image will be built'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN` specifies the commands to run inside the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All Dockerfile instructions can be found on the official Docker page at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
    The most widely-used instructions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAINTAINER` defines the metainformation about the author'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY` copies a file or a directory into the filesystem of the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT` defines which application should be run in the executable container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete guide of all Dockerfile instructions can be found on the official
    Docker page at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  prefs: []
  type: TYPE_NORMAL
- en: Complete Docker application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have all the information necessary to build a fully working application
    as a Docker image. As an example, we will prepare, step by step, a simple Python
    hello world program. The same steps exist always, no matter what environment or
    programming language we use.
  prefs: []
  type: TYPE_NORMAL
- en: Write the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new directory and inside this directory, a `hello.py` file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Close the file. This is the source code of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our environment will be expressed in the Dockerfile. We need the instructions
    to define:'
  prefs: []
  type: TYPE_NORMAL
- en: what base image should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (optionally) who the maintainer is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to install the Python interpreter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to include  `hello.py` in the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: how to start the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the same directory, create the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Build the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can build the image exactly the same way we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We run the application by running the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You should see the friendly Hello World from Python! message. The most interesting
    thing in this example is that we are able to run the application written in Python
    without having the Python interpreter installed in our host system. This is possible
    because the application packed as an image has all the environment needed inside.
  prefs: []
  type: TYPE_NORMAL
- en: An image with the Python interpreter already exists in the Docker Hub service,
    so in the real-life scenario, it would be enough to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've run our first home-made Docker application. However, what if the execution
    of the application should depend on some conditions?
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the case of the production server, we would like to print `Hello`
    to the logs, not to the console, or we may want to have different dependent services
    during the testing phase and the production phase. One solution would be to prepare
    a separate Dockerfile for each case; however, there is a better way, environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our hello world application to print `Hello World from` `<name_passed_as_environment_variable>
    !`. In order to do this, we need to proceed with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the Python script to use the environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the container passing environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can define the environment variable value in Dockerfile,
    for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can run the container without specifying the `-e` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Environment variables are especially useful when we need to have different versions
    of the Docker container depending on its purpose, for example, to have separate
    profiles for production and testing servers.
  prefs: []
  type: TYPE_NORMAL
- en: If the environment variable is defined both in Dockerfile and as a flag, then
    the command flag takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Docker container states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every application we''ve run so far was supposed to do some work and stop.
    For example, we''ve printed `Hello from Docker!` and exited. There are, however,
    applications that should run continuously such as services. To run a container
    in the background, we can use the `-d` (`--detach`) option. Let''s try it with
    the `ubuntu` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command started the Ubuntu container but did not attach the console to
    it. We can see that it''s running using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This command prints all containers that are in the running state. What about
    our old, already-exited containers? We can find them by printing all containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all the old containers are in the exited state. There are two more
    states we haven''t observed yet: paused and restarting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the states and the transitions between them are presented in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9b56cc40-6571-4e7b-98f0-7617455661b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Pausing Docker containers is very rare, and technically, it's realized by freezing
    the processes using the SIGSTOP signal. Restarting is a temporary state when the
    container is run with the `--restart` option to define the restarting strategy
    (the Docker daemon is able to automatically restart the container in case of failure).
  prefs: []
  type: TYPE_NORMAL
- en: The diagram also shows the Docker commands used to change the Docker container
    state from one to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can stop the running Ubuntu container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We always used the `docker run` command to create and start the container; however,
    it's possible to just create the container without starting it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications these days do not run in isolation but need to communicate
    with other systems over the network. If we want to run a website, web service,
    database, or a cache server inside a Docker container, then we need to understand
    at least the basics of Docker networking.
  prefs: []
  type: TYPE_NORMAL
- en: Running services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example, and run a Tomcat server directly from Docker
    Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tomcat is a web application server whose user interface can be accessed by the
    port `8080`. Therefore, if we installed Tomcat on our machine, we could browse
    it at `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, however, Tomcat is running inside the Docker container. We started
    it the same way we did with the first `Hello World` example. We can see it''s
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it''s run as a daemon (with the `-d` option), we don''t see the logs
    in the console right away. We can, however, access it by executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If there are no errors, we should see a lot of logs that concludes Tomcat has
    been started and is accessible via port `8080`. We can try going to `http://localhost:8080`, but
    we won't be able to connect. The reason for this is that Tomcat has been started
    inside the container and we're trying to reach it from the outside. In other words,
    we can reach it only if we connect with the command to the console in the container
    and check it there. How to make the running Tomcat accessible from outside?
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to start the container specifying the port mapping with the  `-p` (`--publish`)
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s first stop the running container and start a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After waiting a few seconds, Tomcat must have started and we should be able
    to open its page, `http://localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5a754575-bd73-41d5-9f7c-01590ca4ecb7.png)'
  prefs: []
  type: TYPE_IMG
- en: Such a simple port mapping command is sufficient in most common Docker use cases.
    We are able to deploy (micro) services as Docker containers and expose their ports
    to enable communication. However, let's dive a little deeper into what happened
    under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Docker allows publishing to the specified host network interface with `-p <ip>:<host_port>:<container_port>`.
  prefs: []
  type: TYPE_NORMAL
- en: Container networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have connected to the application running inside the container. In fact,
    the connection is two-way, because if you remember our previous examples, we executed
    the `apt-get install` commands from inside and the packages were downloaded from
    the internet. How is this possible?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the network interfaces on your machine, you can see that one of
    the interfaces is called `docker0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docker0` interface is created by the Docker daemon in order to connect
    with the Docker container. Now, we can see what interfaces are created inside
    the Docker container with the `docker inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints all the information about the container configuration in the JSON
    format. Among others, we can find the part related to the network settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In order to filter the `docker inspect` response, we can use the `--format` option,
    for example, `docker inspect --format '{{ .NetworkSettings.IPAddress }}' <container_id>`.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe that the Docker container has the IP address `172.17.0.2` and
    it communicates with the Docker host with the IP address `172.17.0.1`. This means
    that in our previous example, we could access the Tomcat server even without the
    port forwarding, using the address `http://172.17.0.2:8080`. Nevertheless, in
    most cases, we run the Docker container on a server machine and want to expose
    it outside, so we need to use the `-p` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that by default, the containers are protected by the host''s firewall
    system and don''t open any routes from external systems. We can change this default
    behavior by playing with the `--network` flag and setting it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bridge` (default): network via the default Docker bridge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`none`: no network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container`: network joined with the other (specified) container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host`: host network (no firewall)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The different networks can be listed and managed by the `docker network` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If we specify `none` as the network, then we will not be able to connect to
    the container, and vice versa; the container has no network access to the external
    world. The `host` option makes the container network interfaces identical to the
    host. They share the same IP addresses, so everything started on the container
    is visible outside. The most often used option is the default one (`bridge`) because
    it lets us define explicitly which ports should be published. It is both secure
    and accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing container ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We mentioned a few times that the container exposes the port. In fact, if we
    dug deeper into the Tomcat image on GitHub ([https://github.com/docker-library/tomcat](https://github.com/docker-library/tomcat)),
    we can notice the following line in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile instruction expresses that the port 8080 should be exposed from
    the container. However, as we have already seen, this doesn't mean that the port
    is automatically published. The EXPOSE instruction only informs the users which
    ports they should publish.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic port assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to run the second Tomcat container without stopping the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This error may be common. In such cases, we have to either take care of the
    uniqueness of the ports on our own or let Docker assign the ports automatically
    using one of the following versions of the `publish` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-p <container_port>`: publish the container port to the unused host port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P` (`--publish-all`): publish all ports exposed by the container to the unused
    host ports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the second Tomcat has been published to port `32772`, so it
    can be browsed at `http://localhost:32772`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you would like to run the database as a container. You can start
    such a container and enter the data. Where is it stored? What happens when you
    stop the container or remove it? You can start the new one, but the database will
    be empty again. Unless it's your testing environment, you don't expect such a
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker volume is the Docker host''s directory mounted inside the container.
    It allows the container to write to the host''s filesystem as it was writing to
    its own. The mechanism is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b175c0eb-1e9a-4d07-8f40-8ec867942345.png)'
  prefs: []
  type: TYPE_IMG
- en: Docker volume enables the persistence and sharing of the container's data. Volumes
    also clearly separate the processing from the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an example and specify the volume with the `-v <host_path>:<container_path>` option
    and connect to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create an empty file in `host_directory` in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check if the file was created in the Docker host''s filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the filesystem was shared and the data was therefore persisted
    permanently. We can now stop the container and run a new one to see that our file
    will still be there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of specifying the volume with the `-v` flag, it''s possible to specify
    the volume as an instruction in the Dockerfile, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if we run the docker container without the `-v` flag, then the
    container's `/host_directory` will be mapped into the host's default directory
    for volumes, `/var/lib/docker/vfs/`. This is a good solution if you deliver an
    application as an image and you know it needs the permanent storage for some reason
    (for example, storing application logs).
  prefs: []
  type: TYPE_NORMAL
- en: If the volume is defined both in Dockerfile and as a flag, then the command
    flag takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Docker volumes can be much more complicated, especially in the case of databases.
    More complex use cases of the Docker volume are, however, out of the scope of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: A very common approach to data management with Docker is to introduce an additional
    layer in the form of data volume containers. A data volume container is a Docker
    container whose only purpose is to declare the volume. Then, other containers
    can use it (with the `--volumes-from <container>` option) instead of declaring
    the volume directly. Read more at [https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container).
  prefs: []
  type: TYPE_NORMAL
- en: Using names in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, when we operated on the containers, we always used autogenerated names.
    This approach has some advantages, such as the names being unique (no naming conflicts)
    and automatic (no need to do anything). In many cases, however, it's better to
    give a real user-friendly name for the container or the image.
  prefs: []
  type: TYPE_NORMAL
- en: Naming containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two good reasons to name the container: convenience and the possibility
    of automation:'
  prefs: []
  type: TYPE_NORMAL
- en: Convenience, because it's simpler to make any operations on the container addressing
    it by name than checking the hashes or the autogenerated name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation, because sometimes we would like to depend on the specific naming
    of the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, we would like to have containers that depend on each other and
    to have one linked to another. Therefore, we need to know their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'To name a container, we use the `--name` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check (by `docker ps`) that the container has a meaningful name. Also,
    as a result, any operation can be performed using the container''s name, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Please note that when the container is named, it does not lose its identity.
    We can still address the container by its autogenerated hash ID like we did before.
  prefs: []
  type: TYPE_NORMAL
- en: The container always has both ID and name. It can be addressed by any of them
    and both of them are unique.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Images can be tagged. We''ve already done this while creating our own images,
    for example, in the case of building the `hello-world_python` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `-t` flag describes the tag of the image. If we didn't use it, then the
    image would be built without any tags and, as a result, we would have to address
    it by its ID (hash) in order to run the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The image can have multiple tags, and they should follow the naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The tag consists of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`registry_address`: IP and port of the registry or the alias name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image_name`: name of the image that is built, for example, `ubuntu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: a version of the image in any form, for example, 16.04, 20170310'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover Docker registries in [Chapter 5](881f1493-1456-4c5b-bdc0-b87595433366.xhtml),
    *Automated Acceptance Testing*. If the image is kept on the official Docker Hub
    registry, then we can skip the registry address. This is why we've run the `tomcat`
    image without any prefix. The last version is always tagged as the latest and
    it can also be skipped, so we've run the `tomcat` image without any suffix.
  prefs: []
  type: TYPE_NORMAL
- en: Images usually have multiple tags, for example, all four tags are the same image: `ubuntu:16.04`,
    `ubuntu:xenial-20170119`, `ubuntu:xenial`, and `ubuntu:latest.`
  prefs: []
  type: TYPE_NORMAL
- en: Docker cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have created a number of containers and images.
    This is, however, only a small part of what you will see in real-life scenarios.
    Even when the containers are not running at the moment, they need to be stored
    on the Docker host. This can quickly result in exceeding the storage space and
    stopping the machine. How can we approach this concern?
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s look at the containers that are stored on our machine. To print
    all the containers (no matter of their state), we can use the `docker ps -a` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to delete a stopped container, we can use the `docker rm` command
    (if the container is running, we need to stop it first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to remove all stopped containers, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `-aq` option specifies to pass only IDs (no additional data) for all containers.
    Additionally, `--no-trunc` asks Docker not to truncate the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also adopt a different approach and ask the container to remove itself,
    when it''s stopped using the `--rm` flag, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In most real-life scenarios, we don't use the stopped containers, and they are
    left only for the debugging purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Images are just as important as containers. They can occupy a lot of space,
    especially in the case of the Continuous Delivery process, when each build ends
    up in a new Docker image. This can quickly result in the no space left on device error.
    To check all the images in the Docker container, we can use the `docker images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove an image, we can call the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of images, the automatic cleanup process is slightly more complex.
    Images don''t have states, so we cannot ask them to remove themselves when not
    used. The common strategy would be to set up the Cron cleanup job, which removes
    all old and unused images. We could do this using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to prevent removing the images with tags (for example, to not remove
    all the latest images), it''s very common to use the `dangling` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If we have containers that use volumes, then, in addition to images and containers,
    it's worth to think about cleaning up volumes. The easiest way to do this is to
    use the `docker volume ls -qf dangling=true | xargs -r docker volume rm` command.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commands overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All Docker commands can be found by executing the following `help` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To see all the options of any particular Docker command, we can use `docker
    help <command>`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: There is also a very good explanation of all Docker commands on the official
    Docker page [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/).
    It's really worth reading or at least skimming through.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve covered the most useful commands and their options.
    As a quick reminder, let''s walk through them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| `docker build` | Build an image from a Dockerfile |'
  prefs: []
  type: TYPE_TB
- en: '| `docker commit` | Create an image from the container |'
  prefs: []
  type: TYPE_TB
- en: '| `docker diff` | Show changes in the container |'
  prefs: []
  type: TYPE_TB
- en: '| `docker images` | List images |'
  prefs: []
  type: TYPE_TB
- en: '| `docker info` | Display Docker information |'
  prefs: []
  type: TYPE_TB
- en: '| `docker inspect` | Show the configuration of the Docker image/container |'
  prefs: []
  type: TYPE_TB
- en: '| `docker logs` | Show logs of the container |'
  prefs: []
  type: TYPE_TB
- en: '| `docker network` | Manage networks |'
  prefs: []
  type: TYPE_TB
- en: '| `docker port` | Show all exposed ports by the container |'
  prefs: []
  type: TYPE_TB
- en: '| `docker ps` | List containers |'
  prefs: []
  type: TYPE_TB
- en: '| `docker rm` | Remove container |'
  prefs: []
  type: TYPE_TB
- en: '| `docker rmi` | Remove image |'
  prefs: []
  type: TYPE_TB
- en: '| `docker run` | Run a container from the image |'
  prefs: []
  type: TYPE_TB
- en: '| `docker search` | Search for the Docker image in Docker Hub |'
  prefs: []
  type: TYPE_TB
- en: '| `docker start/stop/pause/unpause` | Manage the container''s state |'
  prefs: []
  type: TYPE_TB
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of material in this chapter. To make well-remembered, we
    recommend two exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `CouchDB` as a Docker container and publish its port:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the `docker search` command to find the `CouchDB` image.
  prefs: []
  type: TYPE_NORMAL
- en: Run the container
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish the `CouchDB` port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the browser and check that `CouchDB` is available
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a Docker image with the REST service replying `Hello World!` to `localhost:8080/hello`.
    Use any language and framework you prefer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The easiest way to create a REST service is to use Python with the Flask framework,
    [http://flask.pocoo.org/](http://flask.pocoo.org/). Note that a lot of web frameworks
    start the application on the localhost interface only by default. In order to
    publish a port, it's necessary to start it on all interfaces (`app.run(host='0.0.0.0')`
    in the case of a Flask framework).
  prefs: []
  type: TYPE_NORMAL
- en: Create a web service application
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Dockerfile to install dependencies and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the container publishing the port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if it's running correctly using the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered the Docker basics that are enough to build
    images and run applications as containers. The key takeaway, from the chapter
    are the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The containerization technology addresses the issues of isolation and environment
    dependencies using the Linux kernel features. This is based on the process separation
    mechanism, therefore no real performance drop is observed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker can be installed on most of the systems but is supported natively only
    on Linux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker allows running applications from the images available on the internet
    and to build own images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An image is an application packed together with all dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker provides two methods for building the images: Dockerfile or committing
    the container. In most cases, the first option is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker containers can communicate over the network by publishing the ports they
    expose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker containers can share the persistent storage using volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of convenience, Docker containers should be named, and Docker
    images should be tagged. In the Docker world, there is a specific convention of
    how to tag images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker images and containers should be cleaned from time to time in order to
    save the server space and avoid the *no space left on device* error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will cover Jenkins configuration and the way Jenkins
    can be used together with Docker.
  prefs: []
  type: TYPE_NORMAL
