- en: Securing Serverless Applications with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: this chapter, we are going to learn about securing Python-based applications
    that are deployed on AWS Lambda. In the previous chapters, we learned about developing
    an application and deploying it on a serverless infrastructure using Zappa. Zappa
    also supports several mechanisms that enable you to implement a security layer
    for your application. Securing an application from unauthorized access is an essential
    process for any web application, but it would be more interesting to be able to
    secure a web application on a serverless infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will be developing an API-based application and will demonstrate
    some mechanisms to secure it from unauthorized access. Let's move on and explore
    detailed information about setting up the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a random quote API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling secure endpoints on the API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing AWS Lambda failures with dead letter queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing Zappa applications with AWS X-Ray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing your Zappa application using AWS VPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover more AWS features in order to enhance
    the security layer using Zappa. Before diving into this chapter, make sure that
    you have fulfilled the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu 16.04/macOS/Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipenv tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gunicorn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zappa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Python packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have enabled the development environment, we can move on and develop
    a simple Falcon-based API for generating a random quote on request. In further sections,
    we will be securing this API with different mechanisms and approaches using Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a random quote API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create a RESTful API that generates a random
    quote. This will include the Falcon-based API implementation with Mashape API
    integration, like we did in [Chapter 9](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d),
    *Asynchronous Task Execution on AWS Lambda*. This time, we are not going to integrate
    a database as we don't want to persist any information. This will be a simple
    HTTP `GET` request to our API and then we will return a JSON response with a randomly
    generated quote using the Mashape API. Let's look at the prerequisites in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you have met the previously mentioned technical requirements and set
    up the development environment using the pipenv tool. Now, you need to sign up
    at the **Mashape** API marketplace ([https://market.mashape.com/](https://market.mashape.com/)),
    where we will be using the **Random Famous Quote** API ([https://market.mashape.com/andruxnet/random-famous-quotes](https://market.mashape.com/andruxnet/random-famous-quotes)).
    Once you acquire the credentials to use this API, then we need to configure it
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use Zappa's `remote_env` feature to share these credentials
    as environment variables from the AWS S3 file, hence why you need to upload a
    JSON file on AWS S3.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`book-config`/`chapter-11-config.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you upload this file to S3 storage, you can use the `remove_env` feature
    in your `zappa_settings.json` file. The following is an example of `zappa_settings.json`
    with `remote_env` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be adding this setting once we initialize Zappa for deployment. As
    of now, you can set up these credentials as environment variables manually, like
    we are doing here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's move to the next section, where we are going to implement the RESTful
    API for generating random quote data.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the random quote API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have discussed the Mashape API configuration, let''s write a code
    snippet to implement functionality for fetching the random quote data. Have a
    look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`mashape.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we wrote a method named `fetch_quote`, which is responsible
    for fetching the random quote data from the Mashape API. We are going to use this
    method for further implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's write a resource API for our users, who will be using our API to
    get a random quote. The following is a code snippet of the resource API.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`resource.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we implemented a RESTful API using the Falcon framework. This API is mapped
    with the root URL, that is,  `"/"`. We used the `on_get` method to only accept
    the HTTP `GET` request; other requests will be denied access. Once a user initiates
    a `GET` request, this API will return the random quote data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute this API on your local environment by running this API on the
    localhost using `gunicorn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you run the `gunicorn resources:api` command, then the API will be available
    on the localhost with `8000` port. Let''s execute the API using the `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We are done with the implementation. Now, it's time to deploy the
    application on AWS Lambda using Zappa. Let's move on to the next section, where
    we will discuss the deployment process further.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To configure Zappa, you should run the `zappa init` command and follow the auto-generated
    questionnaire. I followed the default suggested settings, and so the following
    is the auto-generated `zappa_settings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now, with the help of this configuration, you can perform the deployment
    as mentioned in the following log snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Before going any further, let's integrate a custom domain against this application.
    We learned about creating an SSL certificate using ACM and configuring a custom
    domain in [Chapter 8](part0203.html#61J260-8241a43bed654018b51365a570bcef1d), *Custom
    Domain with SSL*. Hence, we will use the previously created wild SSL certificate.
    It would be very easy to create a new custom domain just from Zappa settings.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add the following settings in the `zappa_settings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, the application is updated on AWS Lambda, but we still need to perform
    the domain certification task to make the domain live. With the help of the `zappa
    certify` command, we can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned in the preceding logs, our application is live with the given custom
    domain ([https://random-quote.abdulwahid.info](https://random-quote.abdulwahid.info)),
    but it can take up to 40 minutes to create the domain and propagate it through
    AWS, though it does not require any further work from your end. Let's move on
    to the next section, where we will execute the deployed application.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the application is live, you can check the API''s execution using the
    cURL tool. The following is the log snippet of the API''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That's all for being serverless. Now, we need to explore some essential steps
    for securing our application from unauthorized access. Let's move on to the following
    sections, where we will discuss and implement some solutions to secure the application.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling secure endpoints on API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Securing API access is an essential criterion. You can limit and restrict the
    access for your customers who are going to consume the API. Amazon API Gateway
    does support several mechanisms to secure, limit, and restrict API uses. This
    will help to maintain the API usages as per your customer base. The following
    are three types of implementations that are supported by API Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: API key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IAM policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API Gateway Lambda authorizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each implementation in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the API Key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we described in [Chapter 1](part0021.html#K0RQ0-8241a43bed654018b51365a570bcef1d), *Amazon
    Web Services for Serverless,* regarding Zappa''s deployment workflow, where Zappa
    configures the API Gateway to invoke the AWS Lambda with a proxy pass mechanism,
    this creates an API on the API Gateway interface. Each API supports various stages.
    In our case, we have created a `dev` stage while deploying the application. Therefore,
    the following screenshot shows the state of the API Gateway console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: API Gateway supports API keys mechanisms, where you can create an API key along
    with a usage plan. With the help of this API key, you can restrict access for
    your customers. Any customer can access the API if they set the `x-api-key` header
    with the API key value. The API key can be mapped against any API or stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows you the manual process of creating an API key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The manual process of creating the API Key can be eliminated using Zappa. That's
    where Zappa plays an important role, as it will automate the entire process just
    by configuring the Zappa settings.
  prefs: []
  type: TYPE_NORMAL
- en: Zappa provides the `api_key_required` attribute with a Boolean value. `api_key_required`
    is set to `false` by default, but if you want to generate the API key, then you
    need to set it to `true`. Once you set this attribute to `true`, then you are
    required to redeploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `api_key_required` settings don't work with the `zappa update` command;
    it only works with the `zappa deploy` command. Therefore, you need to undeploy
    the application and remove `CNAME` of your deployed custom domain from Route 53
    and then remove the Custom domain from the API Gateway console. Once you remove
    these, then you can deploy the application once again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can perform the fresh deployment again using the `zappa deploy` command,
    as mentioned in the following log snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that Zappa will generate the new `x-api-key` and return the API key ID,
    as mentioned in the preceding log snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are done with the deployment, you will be able to see the auto-generated
    API key in the API Gateway console, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, you can use the API key value in Zappa
    settings to associate the Zappa deployed API with this key so that the API application
    needs you to have this value in the `x-api-key` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to associate the API key with a usage plan by clicking on
    `Add to Usage Plan` in the Associated Usage Plans section that''s shown in the
    preceding screenshot. The API key can be associated with multiple usage plans.
    These￼ plans enable you to define a good structure usage plan for your customers
    as per your business model. The following is a screenshot of Chapter 11 Basic
    Usage Plan and its basic usage plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, the usage plan enables you to define
    the throttling limit and timely bounded API request quota for each API key. Once
    you have defined the plan, then you can associate it with any deployed API and
    their respective stages, as mentioned in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We linked the Chapter 11 Basic Usage Plan`dev` API with the `dev` stage to this
    plan. This is how you can set up a business plan of your API for your customers
    and share the API Key to provide authorized access.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's use the API key value that's in the preceding API key screenshot
    in the `zappa_settings.json` file with the ` "api_key"` attribute. The following
    is the updated `zappa_settings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Let''s update the deployment once again using the `zappa update`
    command, as shown in the following mentioned log snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We are done with enabling the API key authentication. Let's move on to the next
    section to see the API's execution.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the API with the API key header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We enabled the API key's authentication, and so the API key is mandatory with
    the `x-api-key` header. If a request hits the API without the `x-api-key` header,
    then it would be denied access with the forbidden response. If a user provides
    the valid API key value in the `x-api-key` header, then it would be allowed to
    access the API resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'API execution without the `x-api-key` header is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'API execution with the `x-api-key` header is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are done with the API key authentication integration. Let's move on to the
    next section, where we will be exploring another option of authentication using
    the IAM policy.
  prefs: []
  type: TYPE_NORMAL
- en: IAM policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Amazon API Gateway supports IAM-based V4 signing request authentication. The
    API Gateway requires a user to authenticate the request by signing the request.
    Signing a request is a complete flow of creating a digital signature using the
    cryptographic function. You can read more about the Signing Request process at
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/](https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/)'
  prefs: []
  type: TYPE_NORMAL
- en: Zappa enables this feature by setting the `"iam_authorization"` attribute to
    `true` in Zappa's settings. This attribute is set to `false` by default. Therefore,
    you can explicitly set it to true in order enable the IAM-based authentication.
    This feature enables you to access the API resources based on the IAM policy.
    You can control this access via the IAM policy ([https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-iam-policy-examples.html](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-iam-policy-examples.html)).
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, I am going to create a different stage and custom
    domain for the same application. The following is a snippet of Zappa's settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a different stage with `iam_authentication`. This flag will
    enable IAM-based authentication. Now, again, you need to perform deploy, update,
    and certify operations to make this stage live with the following domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are required to sign the request to access the deployed resource. Signing
    a request requires that you follow some processes, as mentioned here: [https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/](https://docs.aws.amazon.com/apigateway/api-reference/signing-requests/).
    There are also many third-party libraries available to generate the required headers
    for signing the request. We are going to use the `requests-aws-sign` ([https://github.com/jmenga/requests-aws-sign](https://github.com/jmenga/requests-aws-sign))
    library to access the API resource with a signed request.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a code snippet of signing a request to access the API resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`aws_sign_request_test.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Now, you can see the output of the preceding script, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we got API access with a signed request. This way, you can secure your
    serverless API application with IAM authentication. Let's move on to the next
    section, where we are going to explore another way of securing the serverless
    API application.
  prefs: []
  type: TYPE_NORMAL
- en: API Gateway Lambda authorizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Amazon API Gateway Lambda authorizer is a simple AWS Lambda function that
    acts as an authorizer to control access to API Gateway resources. This is because
    the Lambda authorizer will be responsible for verifying requests via the bearer
    token form authorization header and returning a valid IAM policy. You can write
    your custom Lambda authorizer with different authentication strategies based on **JWT**
    (**JSON Web Token**), OAuth, or SAML.
  prefs: []
  type: TYPE_NORMAL
- en: You can add the authorizer from the API Gateway console, as mentioned in the
    official AWS documentation ([https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html)),
    or you can create the Lambda authorizer from a Lambda blueprint named `api-gateway-authorizer-python`
    ([https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py](https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py))
    and then associate this Lambda function as an authorizer to your API resource
    from the API Gateway console.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have configured the authorizer, the API Gateway expects a request along
    with a bearer token or parameters in the authorization header. It denies the request
    in the case of a missing authorization header. If a client sends a request with
    a bearer token in the authorization header to your API resource, then the API
    Gateway extracts the bearer token and other params from the request header and
    supplies them as event parameters to the Lambda authorizer function. The Lambda
    authorizer verifies the token with existing AWS IAM policies or the AWS Cognito
    users pool and then returns the IAM policies to authorize the request. The API
    Gateway maintains a session for subrequests by caching the return policy with
    the request token over a period of pre-configured **TTL** (**time-to-live**) from
    300 to 3,600 seconds, the default being 300 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zappa supports an easier way to configure the Lambda authorizer. You can define
    the authorizer attribute in the Zappa settings as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define the preceding attributes. Each attribute has its own specific
    usage in order to define a custom Lambda authorizer. Let''s explore these attributes
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function`: This will be your own local function to execute token validation.
    Zappa will automatically create and map this function as an authorizer for your
    API in the API Gateway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arn`: This will be the `arn` of your existing Lambda function to verify the
    token. If you choose the blueprint Lambda authorizer function, `api-gateway-authorizer-python`
    ([https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py](https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints/blob/master/blueprints/python/api-gateway-authorizer-python.py)),
    then you can put in the `arn` of your Lambda function that was created by the
    blueprint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result_ttl`: This is an optional attribute. It enables the **time-to-live** (**TTL**)
    period to cache the authorizer result via the API Gateway. By default, it is set
    to 300 seconds and you can set it to a maximum of 3,600 seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`token_header`: This is an optional attribute. It is used to set the name of
    the custom authorization header. It contains the token as part of a submitted
    request by the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validation_expression`: This is an optional attribute. It is used to set the
    validation expression of the token in the authorization header. By default, it
    supports the `"^Bearer \\w+$"` expression to validate the token expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how you can create a custom Lambda authorizer for your serverless API.
    This enables you to create a centralized authentication for all your distributed
    API microservices that are deployed by Zappa.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move ahead to the next section, where we will be exploring the tracing
    mechanism of AWS failure.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing AWS Lambda failure with dead letter queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dead letter queues** (**DLQ**) is a defined mechanism by Amazon to trace
    the failure of AWS Lambda functions executing asynchronously. AWS Lambda invokes
    asynchronous mode and retires it twice in case of failure before the event is
    discarded. DLQ is used to proceed this failure event to an Amazon SQS queue or
    Amazon SNS topic.'
  prefs: []
  type: TYPE_NORMAL
- en: Manual DLQ configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DLQ can be configured by setting `TargetArn` (that is, the SQS queue ARN or
    SNS topic ARN) on the Lambda function''s `DeadLetterConfig` parameter, as mentioned
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Automating DLQ configuration with Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to automate this process, Zappa enables this feature by setting up
    the SQS queue/SNS topic ARN value to `dead_letter_arn`*.* We created an SNS topic
    in [Chapter 9](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d), *Asynchronous
    Task Execution on AWS Lambda,* which was named `UnhandledException`. So, let's
    use the existing SNS topic, which is already subscribed with my email. DQL will
    only trigger if an asynchronous Lambda function invocation fails and retires.
    Then, DQL will process the failure exception as a message to the configured SNS
    topic and we will receive the processed exception data on an subscribed email.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the following code snippet is for the updated Zappa settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, I updated the `dead_letter_arn` attribute for the `dev` stage only. Hence,
    this feature will be available for the `dev` stage. Now, we are all set with DLQ
    with our `dev` stage Lambda function. Once you are done with this configuration,
    you are required to perform the deployment using the `zappa deploy` command. That's
    it! Now, we should have an asynchronous Lambda function mechanism in our code
    that raises an exception at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that for Lambda function-specific changes, you are required to redeploy
    your function using the `zappa deploy` command. The `zappa update` command will
    not work here as it is responsible for updating the existing code base, not Lambda
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions in the asynchronous Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to raise an exception in the asynchronous Lambda invocation, we need
    to have a mechanism to instantiate an asynchronous Lambda function. Let's write
    a resource API and call an asynchronous task, which will raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the updated code of `resources.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created an `AsyncTaskResource` as a resource class for the `"/async-failure"`
    route. This route is defined with the HTTP `GET` request using the `on_get` method
    in the `AsyncTaskResource` class. We also created the `async_task` method as an
    asynchronous method using the task decorator. We have already seen the implementation
    of asynchronous tasks using Zappa in [Chapter 9](part0219.html#6GRB60-8241a43bed654018b51365a570bcef1d),
    *Asynchronous Task Execution on AWS Lambda*. The task decorator will asynchronously
    execute the method in a separate Lambda instance.
  prefs: []
  type: TYPE_NORMAL
- en: From `async_task`, we are raising a `ValueError` exception. This will result
    in the asynchronous Lambda execution's failure and will raise the DLQ event on
    subsequent failure. DLQ will process the exception data to our configured SNS
    topic ARN. Finally, we will get the exception information in our email.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We requested the `/async-failure` API, which responded immediately and instantiated
    the task in an asynchronous Lambda function. As we explicitly raised an exception
    in the `async_task` method, this will invoke the DLQ and process the exception
    information by publishing to the SNS topic. The following is a screenshot of the
    email notification received from the AWS Notification Message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This way, we can trace the unknown failure. This feature will help us improve
    the application's quality and reduce the failure rate. Let's move on to the next
    section, where we are going to explore analyzing the Zappa application using AWS
    X-Ray.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Zappa application with AWS X-Ray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS X-Ray is an analytics service provided by Amazon Web Services. It helps
    developers to perform analysis on the application behavior and working flow. With
    the help of X-Ray, developers can understand the application's performance and
    trace the root cause in order to improve optimization.
  prefs: []
  type: TYPE_NORMAL
- en: AWS X-Ray can be enabled on any compute AWS services. Once you have enabled
    X-Ray, it starts to generate data segments based on application interaction. For
    example, if you make an HTTP request to your application, then X-Ray will generate
    data about the host, request, response, computed time, and errors. Based on these
    segments of data, X-Ray generates a service graph.
  prefs: []
  type: TYPE_NORMAL
- en: The service graph provides a visualized pattern for the developers to understand
    the application workflow and helps to determine its performance. Apart from the
    request and response data generation, X-Ray also generates records for your application
    interaction with AWS resource, microservices, databases, and HTTP Web API calls.
  prefs: []
  type: TYPE_NORMAL
- en: X-Ray manual integration with AWS Lambda
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The AWS Lambda console has a privilege in that it can configure the Lambda
    function with AWS X-Ray. Hence, any interaction with AWS Lambda will be recorded
    by AWS X-Ray. You can enable X-Ray on your Lambda function by configuring the
    function from its console page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Regarding the AWS Lambda console workflow, you are required to select AWS XRay.
    Then, you can configure its associated settings from the bottom panel of the main
    section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once you choose the X-Ray, the default execution role permissions will attach
    to your Lambda function. This way, AWS X-Ray will record the trace to your Lambda
    function API executions.
  prefs: []
  type: TYPE_NORMAL
- en: Zappa configuration to enable AWS X-Ray support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zappa is always here to avoid manual interactions in order to configure your
    Lambda function. Hence, Zappa provides an easy way to configure the AWS X-Ray
    with your Lambda function. You just need to set `"xray_tracing"` to `true` in
    your Zappa settings. This will automatically enable the X-Ray tracing support
    for your Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create another stage of our existing API application. This stage will
    have a basic configuration without authentication and a custom domain, since we
    just want to demonstrate the X-Ray workflow. The following is the new stage configuration
    with X-Ray support.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, we've added a new stage named `"dev_xray"` with basic
    configuration and AWS X-Ray tracing support. Now, let's deploy this stage using
    the `zappa deploy` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now, our Random Quote API is up and running with different stages.
    Once the application is deployed, Zappa generates a random API Gateway link, as
    mentioned in the preceding log snippet. Now, you can just hit the API using the
    curl tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the log snippet of the API''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have integrated the AWS X-Ray, and so all our application''s interactions
    will be recorded as tracing segments by AWS X-Ray. The following is a screenshot
    of AWS X-Ray''s service map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can see the tracing details of your application. These details are
    available as per the time frame on its console. AWS X-Ray supports the client
    SDK library, which enables the developer to persist these traces as per their
    requirements. AWS X-Ray''s client SDK has many implementations with languages
    and language-specific frameworks. You can read more about AWS X-Ray and its Python-based
    SDK library at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html](https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/aws/aws-xray-sdk-python](https://github.com/aws/aws-xray-sdk-python)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next section, where we will be exploring AWS VPC integration
    with your AWS Lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your Zappa application using AWS VPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS **Virtual Private Cloud** (**VPC**) is an isolated virtual network service
    dedicated to AWS resources. It's similar to a traditional network mechanism in
    your own data center. AWS VPC enables you to secure your AWS resources from unauthorized
    access. AWS provides a default VPC for each region. The default VPC helps you
    configure all of your AWS resources.
  prefs: []
  type: TYPE_NORMAL
- en: AWS VPC is dedicated to your AWS account and enables an isolated layer. You
    can configure your AWS resources with the AWS VPC. Once you enable the VPC for
    your AWS resources, then you can specify the following components as per your
    requirements, such as IP address range, subnets, security groups, route tables,
    and others. These components are used to set up the networking policy and strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Manual configuration of VPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS Lambda has the privilege of configuring the VPC. The following is a screenshot
    of the AWS Lambda configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, we have selected a default VPC. We need
    to configure other components, such as subnets and security groups, that are mandatory.
    Subnets is a range of IP addresses in the VPC. You should use a public subnet
    for any resource which requires internet access. The private subnet is used for
    any resource that doesn't require that you connect to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Security groups, on the other hand, define the inbound and outbound rules for
    authorizing any protocol access.
  prefs: []
  type: TYPE_NORMAL
- en: AWS VPC has a complete implementation of the secure network layer. To understand
    each and every aspect of the VPC concept, you should read its official documentation
    [(](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html)[https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html](https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_Introduction.html)).
    We will be focusing on Zappa configuration to enable VPC in an automated way.
    Let's move on to the next section, where we will be configuring Zappa with VPC.
  prefs: []
  type: TYPE_NORMAL
- en: VPC configuration using Zappa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Zappa has an optimized way of automating the VPC with the deployed application.
    All you need to provide is the `vpc_config` attribute with subnet and security
    groups IDs, as mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'I mentioned the default VPC in the previous section. You can get the default
    subnet IDs from the VPC dashboard page, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can get the security group IDs by selecting Security Groups from the left
    panel, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are going to create another deployment stage with VPC configuration.
    You need to put the subnet IDs and security group IDs from the preceding screenshots
    and configure them using Zappa settings, as shown in the following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'File—`zappa_settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'AWS VPC is an isolated network, hence any service running inside the VPC network
    will not have access to the public internet. In case, you require to have access
    for public internet for any resources then you must have at least two subnets.
    With following settings in VPC dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `subnet-a`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the NAT Gateway section and create a NAT Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Select the Internet Gateway section and create an Internet Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: From the route table section, create a route named as `route-a` pointing the
    Internet Gateway to `0.0.0.0/0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `subnet-b`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure your Lambda function with this subnet.
  prefs: []
  type: TYPE_NORMAL
- en: From the route table section, create a route named as `route-b` pointing the
    NAT that belongs to `subnet-a` to `0.0.0.0/0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Now, our application has been configured with AWS VPC successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about different security mechanisms and demonstrated
    their implementation with a small API-based application. AWS has a very good security
    architecture, but it involves manual interaction processes, whereas Zappa automates
    these processes and prevents manual interaction. We also covered tracing, analytics,
    and the notification process of optimizing the application's workflow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore Zappa development, along with Docker
    containerization. Stay tuned so that you can sharpen a new skill set.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is an API Gateway authorizer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is AWS Lambda DQL?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is AWS VPC important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
