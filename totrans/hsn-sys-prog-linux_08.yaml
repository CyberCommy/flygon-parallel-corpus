- en: Process Capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In two chapter, you will learn concepts and practices regarding process credentials
    and capabilities. Besides being of practical importance to application development
    in Linux, this chapter, by its very nature, delves deeper into an often overlooked
    but extremely important aspect: security.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have divided the coverage of this key area into two major parts, each of
    which is a chapter in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml), *Process Credentials,*
    the traditional-style Unix permissions model is discussed in some detail, and
    techniques to run programs with root privileges but without requiring the root
    password were shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities,*
    the *modern* approach, the POSIX capabilities model, is discussed in some detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will attempt to clearly show the reader that, while it is important to learn
    about the traditional mechanisms and how they operate, this becomes a classic
    weak link as far as *security* is concerned. However you look at it, security
    is of paramount importance, especially these days; the advent of Linux running
    on all sorts of devices—tiny IoT and embedded devices to mobile devices, desktops,
    servers, and super-computing platforms—makes security a key concern for all stakeholders.
    Hence, the modern capabilities approach should be used when developing software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the *modern approach—*the POSIX capabilities
    model—in some detail. We will discuss what exactly it is, and how it provides
    security and robustness. The reader will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What exactly the modern POSIX Capabilities model is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why it is superior to the older (traditional) Unix permissions model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with capabilities on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding capabilities into a process or binary executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security tips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the way, we will use code examples, which will allow you to try out some
    of these facilities so that you can gain a better understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: The modern POSIX capabilities model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this (fictional) scenario: Vidya is on a project developing a Linux
    application for Alan and his team. She is working on a component that captures
    network packets and saves them to a file (for later analysis). The program is
    called **packcap**. However, to successfully capture the network packets, packcap
    must run with *root* privileges. Now, Vidya understands that running applications
    as  *root* is not a good security practice; not only that, she knows the customer
    will not accept the statement: Oh, it didn''t work? You must run it logged in
    as a root or via sudo. Running it via sudo(8) might sound reasonable, but, when
    you stop to think about it, that implies that every member of Alan''s team must
    be given the *root* password, and this is simply not acceptable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does she solve the problem? The answer suddenly jumps out at her: Make
    the *packcap* binary executable a *setuid-*root file; this way, when it''s launched,
    the process will be running with *root* privileges, so there will be no need for
    a root login/password or sudo. Sounds fantastic.'
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This—the setuid—root approach—is *exactly* the traditional manner in which
    problems like the one briefly described above were solved. So, what''s changed
    today (well, over several years now)? In a nutshell: *security concerns over hacking*.
    The reality is this: All real-world non-trivial programs do have defects (bugs)—hidden,
    lurking, undiscovered, perhaps, but very much there. The vast scope and complexity
    of modern real-world software projects make this an unfortunate reality. Certain
    bugs result in *vulnerabilities* "leaking" into the software product; this is
    precisely what hackers look to *exploit*. The well-known, yet dreaded, **Buffer
    Overflow** *(***BoF***)* attacks are based on software vulnerabilities within
    several heavily used library APIs! (We highly recommend reading David Wheeler''s
    book *Secure Programming* *HOWTO - Creating Secure Software—*see the *Further
    reading* section on the GitHub repository.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**At the code level, security issues are bugs; once fixed, the issue disappears.**
    (See a link to Linux''s comments on this in the *Further reading* section on the
    GitHub repository.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what''s the point? Simply put the point is this: It''s entirely possible
    that the setuid-root program you deliver to your customer (packcap) has unfortunate
    and unknown-as-of-now software vulnerabilities embedded within it, which hackers
    could discover and exploit (yes, there''s a whole job description for this—**white-hat
    hacking** or **pentesting.**)'
  prefs: []
  type: TYPE_NORMAL
- en: If the process *hacked into* runs with normal privileges—non-root—at least then
    the damage is limited to that user account, and it goes no further. But if the
    process is running with root privilege and the attack succeeds, the hacker might
    well end up with a *root shell on the system*. The system is now compromised—anything
    can happen (secrets can be stolen, backdoors and rootkits installed, DoS attacks
    become trivial.)
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not only about security, though: by limiting privileges, you gain damage-control
    benefits as well; bugs and crashes are going to cause limited damage—the situation
    is far better *contained* than earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: POSIX capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, going back to our fictional packcap example application, how do we run the
    process—which requires root, it seems—without root privileges (no root login,
    setuid-root*,* or sudo(8) allowed) and yet have it perform its tasks correctly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the POSIX Capabilities model: In this model, instead of giving a process
    *blanket access* as a root (or other) user, there is a way to *embed particular
    capabilities into both the process and/or binary file.* The Linux kernel supports
    the POSIX capabilities model from very early on—the 2.2 Linux kernels (at the
    time of writing, we are now in the 4.x kernel series). From a practical viewpoint,
    the features we describe as follows are available from Linux kernel version 2.6.24
    (released January 2008) onward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how it works in a nutshell: Every process—in fact, every *thread—*as
    part of its OS metadata, contains a bitmask. These are called the *capability
    bits* or the *capability set*, because *each* *bit represents a capability***.**
    By carefully setting and clearing bits, the kernel (as well as the user space,
    if it has the capability) can therefore set *fine granularity permissions* on
    a per-thread basis (we will cover multithreading in detail in later [Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml),
    *Multithreading with Pthreads Part I - Essentials*, for now, treat the term *thread*
    as interchangeable with *process*).'
  prefs: []
  type: TYPE_NORMAL
- en: More realistically, and as we shall see next, the kernel maintains *several
    capability sets (capsets) per thread alive*; each capset consists of an array
    of two 32-bit unsigned values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there is a capability bit called `CAP_DAC_OVERRIDE`**;** it would
    normally be cleared (0). If set, then the process will bypass all the kernel''s
    file permission checks—for anything: reading, writing, and executing! (This is
    known as **DAC**: **Discretionary Access Control.**)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at a few more examples of capability bits would be useful at this point
    (the full list is available at the *man page* on *capabilities(7)* here: [https://linux.die.net/man/7/capabilities](https://linux.die.net/man/7/capabilities)).
    Some snippets follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*In effect, the capabilities model provides fine-grained permissions; a way
    to slice up the (overly) enormous power of the root user into distinct manageable
    pieces.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to understand the significant benefit in the context of our fictional packcap
    example, consider this: With the traditional Unix permissions model, at best,
    the release binary would be a setuid-root binary executable file; the process
    would run with root privileges. In the best case, there''s no bug, no security
    issues (or, if there are, they aren''t discovered), and all goes well—luckily.
    But, we don''t believe in luck, right?"(In the words of Jack Reacher, Lee Child''s
    protagonist, "Hope for the best, prepare for the worst")." In the worst case,
    there are exploitable vulnerabilities lurking in the code and there are hackers
    who will work tirelessly until they find and exploit them. The entire system could
    be compromised.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, with the modern POSIX capabilities model, the packcap binary
    executable file will *not* require to be setuid at all, never mind setuid-root;
    the process would run with normal privileges. The work still gets done because
    we embed the *capability* for precisely that work (in this example, network packet
    capture) and absolutely nothing else. Even if there are exploitable vulnerabilities
    lurking in the code, hackers would probably not be as motivated to find and exploit
    them; the simple reason for this is this is that even if they do manage to gain
    access (say, an arbitrary code execution bounty), all that can be exploited is
    the account of the non-privileged users running the process. It's demotivating
    to the hacker (well, that's a joke, but with truth ingrained within).
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it: the Linux capabilities model is one way to implement a well-accepted
    security practice: *the* ***Principle of Least Privilege (PoLP):*** Each module
    in a product (or project) must have access only to the information and resources
    necessary for its legitimate work, and nothing more.'
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities – some gory details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux capabilities are a fairly complex topic. For the purposes of this book,
    we delve into the subject to the depth necessary for the systems application developer
    to profit from the discussion. To get the complete details, please check out the
    man page on capabilities (7) here: [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
    as well as the kernel documentation on credentials here: [https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst](https://github.com/torvalds/linux/blob/master/Documentation/security/credentials.rst)'
  prefs: []
  type: TYPE_NORMAL
- en: OS support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Capability bitmask**(**s**) are often referred to as **capability sets**—we
    abbreviate this term to **capset**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with the power of the POSIX capabilities model, in the first place,
    the OS itself must provide "life support" for it; full support implies the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a process or thread attempts to perform some operation, the kernel
    is able to check whether the thread is allowed to do so (by checking for the appropriate
    bit being set in the thread's effective capset—see the next section).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System calls (and usually wrapper library APIs) must be provided such that a
    thread can query and set its capsets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux kernel filesystem code must have a facility such that capabilities can
    be embedded (or attached) into a binary-executable file (so that when the file
    "runs", the process acquires those capabilities).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modern Linux (particularly Kernel Version 2.6.24 onward) supports all three,
    and thus fully supports the capabilities model.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing process capabilities via procfs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand more details, we need a quick way to "look into" the kernel and
    retrieve information; the Linux kernel's **proc filesystem** (often abbreviated
    to **procfs**) provides just this feature (along with more).
  prefs: []
  type: TYPE_NORMAL
- en: Procfs is a pseudo-filesystem typically mounted on */proc*. Exploring procfs
    to learn more about Linux is a great idea; do check out some links in the *Further
    reading* section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we shall just focus on the task at hand: to get to the details, procfs
    exposes a directory called `/proc/self` (which refers to the current process''s
    context, somewhat analogous to the *this* pointer in OOP); under it, a pseudo
    file named *status* reveals interesting details about the process (or thread)
    in question. The process''s capsets are seen as "Cap*" so we just grep for this
    pattern. In the next code, we perform this on a regular non-privileged process
    (*grep* itself via the *self* directory), as well as with a privileged (root)
    process (*systemd/init PID 1*), to see the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process/thread capsets: regular process (such as grep):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Process/thread capsets: privileged (root) process (such as systemd/init PID
    1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Enumerated in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Thread Capability Set (capset)** | **Typical Value for Non-Privileged Task**
    | **Typical Value for Privileged Task** |'
  prefs: []
  type: TYPE_TB
- en: '| CapInh (Inherited) | `0x0000000000000000` | `0x0000000000000000` |'
  prefs: []
  type: TYPE_TB
- en: '| CapPrm (Permitted) | `0x0000000000000000` | `0x0000003fffffffff` |'
  prefs: []
  type: TYPE_TB
- en: '| CapEff (Effective) | `0x0000000000000000` | `0x0000003fffffffff` |'
  prefs: []
  type: TYPE_TB
- en: '| CapBnd (Bounded) | `0x0000003fffffffff` | `0x0000003fffffffff` |'
  prefs: []
  type: TYPE_TB
- en: '| CapAmb (Ambient) | `0x0000000000000000` | `0x0000000000000000` |'
  prefs: []
  type: TYPE_TB
- en: (This table describes the output from a Fedora 27/Ubuntu 17.10 Linux on x86_64).
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly, there are two types of *capability sets*:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread capability sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File capability sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread capability sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within thread capsets, there are actually several types per thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux per-**thread** capability sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Permitted (Prm):** The overall limiting *superset* of effective capabilities
    for the thread. If a capability is dropped, it can never be reacquired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritable (Inh):** Inheritance here refers to the absorption of capset
    attributes across an *exec*. What happens to the capsets when a process executes
    another process? (Details on the exec are dealt with in a later chapter. For now,
    suffice it to say that if bash execs vi, then we call bash the predecessor and
    vi the successor).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will the successor process inherit the capsets of the predecessor? Well, yes
    the *inheritable capset*, that is. From the previous table, we can see that for
    a non-privileged process, the inherited capset is all zeros, implying that no
    capabilities are inherited across the exec operation. So, if a process wants to
    execute another process and that (successor) process must run with elevated privileges,
    it should use ambient capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Effective (Eff):** These are the capabilities that the kernel actually uses
    when checking permissions for the given thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ambient (Amb):** (From Linux 4.3 onward). These are the capabilities that
    are inherited across an exec operation. The bits *must* be present (set to 1)
    in both the permitted and inheritable capsets—only then can it be "ambient". In
    other words, if a capability is cleared from either a Prm or an Inh, it is also
    cleared in an Amb.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a *set[u|g]id* program or a program with *file capabilities* (as we will
    see) is executed, the ambient set is cleared. Normally, upon exec, the ambient
    capset is added to Prm and assigned to Eff (of the successor process).
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounding (Bnd):** This capset is a way *to limit* the capabilities bestowed
    upon a process during an exec. Its effect:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the process executes another process, the permitted set is the ANDing
    of the original permitted and bounded capsets: *Prm = Prm* AND *Bnd.* This way,
    you can limit the successor process''s permitted capset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only if a capability is in the bounding set, can it be added to the inheritable
    capset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, from Linux 2.6.25 onward, the capability bounding set is a per-thread
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executing a program will have no impact on the capsets unless either of the
    following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: The successor is a setuid-root or a setgid program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File capabilities are set on the binary executable that is execed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can these thread capsets be programmatically queried and changed? Indeed,
    that's what the *capget(2)* and *capset(2)* system calls are for. However, we
    would suggest one uses  the library-level wrapper APIs *cap_get_proc(3)* and *cap_set_proc(3)*
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: File capability sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, we require the ability to "embed" capabilities into a binary-executable
    file (the discussion regarding the reasons for this is covered in the following
    section). This will obviously require kernel filesystem support. In early Linux,
    this system was a kernel-configurable option; from Linux kernel 2.6.33, file capabilities
    are always compiled into the kernel, and are therefore always present.
  prefs: []
  type: TYPE_NORMAL
- en: 'File capsets are a powerful security feature—you could say they are the modern
    equivalent of the older *set[u|g]id* features. To use them in the first place,
    the OS must support them, and the process (or thread) requires the `CAP_FSETCAP`
    capability. Here is the key point: The (previous) thread capsets along with the
    (coming) file capsets ultimately determine thread capabilities following an *exec*
    operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the Linux file capability sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Permitted (Prm): auto-permitted capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritable (Inh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Effective (Eff): This is a single bit: if set, the new Prm capset gets raised
    in the Eff set; otherwise, it does not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once again, understand the caveat under which the above information has been
    provided: it''s not the complete details. To get them, please check out the man
    page on capabilities(7) here: [https://linux.die.net/man/7/capabilities](https://linux.die.net/man/7/capabilities)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot snippet from this man page, showing the algorithm used
    to determine capabilities during the *exec* operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f94536e7-3ae1-470b-82bb-4a039d23102c.png)'
  prefs: []
  type: TYPE_IMG
- en: Embedding capabilities into a program binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have understood that the fine granularity of the capabilities model is a
    major security advantage over the old-style root only or setuid-root approach.
    So, back to our fictional packcap program: We would like to use *c*apabilities,
    and not the setuid-root. So, lets say that, upon careful study of the available
    capabilities, we conclude that we would like the following capabilities to be
    endowed into our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_NET_ADMIN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_NET_RAW`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up the man page on credentials(7) reveals that the first of them gives
    a process the ability to perform all required network administrative asks; the
    second, the ability to use "raw" sockets.
  prefs: []
  type: TYPE_NORMAL
- en: But how exactly does the developer embed these required capabilities into the
    compiled binary executable file? Ah, that's easily achieved with the `getcap(8)`
    and `setcap(8)` utilities. Obviously, you use `getcap(8)` to query a given file's
    capabilities and `setcap (8)` *to set them upon a given file.*
  prefs: []
  type: TYPE_NORMAL
- en: '"If not already installed, please do install the getcap(8) and setcap(8) utilities
    on your system (the book''s GitHub repo provides a list of madatory and optional
    software packages)"'
  prefs: []
  type: TYPE_NORMAL
- en: 'The alert reader will notice something fishy here: If you are able to arbitrarily
    set capabilities upon a binary executable file, then where is the security? (We
    could just set `CAP_SYS_ADMIN` on the file /bin/bash, and it would now run as 
    the root.) So, the reality is that you can only set capabilities on a file if
    you already have the `CAP_FSETCAP` capability; from the manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In effect, practically speaking, you would thus perform the setcap(8) as root
    via sudo(8); this is because we only get the CAP_SETFCAP capability when running
    with root privilege.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s do an experiment: We build a simple `hello world` program (`ch8/hello_pause.c`);
    the only difference is this: We call the `pause(2)` system call after the `printf`;
    the `pause` has process sleep (forever):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We then write another C program to *query* the capabilities on any given process;
    the code of `ch8/query_pcap.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s simple: the `cap_get_pid(3)` API returns the capability state, essentially
    the `capsets` of the target process. The only hassle is it''s represented via
    an internal data type called `cap_t`; to read it, we''d have to convert it to
    human-readable ASCII text; you guessed it, the `cap_to_text (3)`*.* API has precisely
    that function. We use it and print the result. (Hey, notice how we must `cap_free(3)` the
    variable after use; the manual informs us about this.)'
  prefs: []
  type: TYPE_NORMAL
- en: Several of these APIs to do with capabilities (broadly the `cap_*` ones), require
    the `libcap` library to be installed on the system. If not already installed,
    use your package manager to do so (the correct package is usually called `libcap-dev[el*]`).
    Obviously, you must link with the `libcap` library (we use the `-lcap` to do so
    in the Makefile).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Process PID 1, traditionally (Sys V) *init,* but nowadays `systemd`, runs with
    *root* privileges; thus, when we use our program to query its capsets (in reality,
    we get the effective capset returned), we get quite a long capability list! (as
    expected.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we build and run the `hello_pause` process in the background; then we
    query its capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `hello_pause` process is of course unprivileged, nor does it have any capabilities
    embedded within it; thus, as expected, we see it has *no* capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the interesting part: Firstly, we embed capabilities into our `hello_pause`
    binary executable file using the `setcap(8)` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes sense: as  `root` (technically, now we understand, with `CAP_SYS_ADMIN`
    capability), we of course have the `CAP_SETFCAP` capability, and thus succeed
    in using `setcap(8)`. Syntactically, we need to specify to `setcap(8)` a capability
    list followed by an action list; previously, we''ve specified the `cap_net_admin,cap_net_raw`
    capabilities, and the *add to effective and permitted* as the action list (with
    the `+ep` syntax).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we retry our little experiment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Yes! The *new* `hello_pause` process indeed has the capabilities we wanted it
    to have.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if both the traditional setuid-root *and* the modern (file) capabilities
    are embedded in a binary executable? Well, in that case, when run, *only the capabilities
    embedded into the file* take effect; the process would have an EUID of 0, but
    would *not* have full *root* capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Capability-dumb binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Notice something, though: the `hello_pause` program above *really has no* idea
    that it actually has these capabilities; in other words, it programmatically has
    done nothing to query or set POSIX capabilities on itself. Yet, via the file capabilities
    model (and the setcap(8) utility) we have "injected" capabilities into it. *This
    type of binary is therefore called a* **capability-dumb binary***.*'
  prefs: []
  type: TYPE_NORMAL
- en: It's still vastly superior to doing a clumsy setuid-root security-wise, but
    it could get even "smarter" if the application itself—programmatically—used APIs
    to query and set capabilities upon itself at runtime. We can think of this kind
    of app as a **capability-smart binary*****.***
  prefs: []
  type: TYPE_NORMAL
- en: Often, when porting a legacy setuid-root (or worse, just a *root*) type of application,
    developers will strip it of the setuid-root bit, knock off *root* ownership from
    the binary and then convert it into a *capability-dumb* binary by running setcap(8) on
    it. This is a good first step towards better security (or "hardening").
  prefs: []
  type: TYPE_NORMAL
- en: Getcap and similar utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `getcap(8)` utility can be used to look up the capabilities embedded in
    a (binary) *file.* As a quick example lets run `getcap` on the shell program and
    the ping utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It's clear that bash does not have any file capsets—that's exactly what we expect.
    Ping, on the other hand, does, so that it can carry out its duties without requiring
    root privilege.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getcap` utility usage is amply demonstrated via a bash script (similar
    to the one we saw in the previous chapter): `ch8/show_caps.sh`*.* Run it to see
    various file capability embedded programs installed on the system (left as a simple
    exercise for the reader to try out).'
  prefs: []
  type: TYPE_NORMAL
- en: Similar in some respects to `getcap(8)`, though a superset of it, is the `capsh(1)` utility—a
    **capability shell wrapper**; check out its man pages for details.
  prefs: []
  type: TYPE_NORMAL
- en: Also similar to the `query_pcap` program we wrote, is the `getpcaps(1)` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Wireshark – a case in point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So: the story we cooked up at the beginning of this topic is not entirely fictitious—well,
    it is, but it has a remarkable real-world parallel: the well known *Wireshark*
    (previously called Ethereal) network packet sniffer and protocol analyzer application.'
  prefs: []
  type: TYPE_NORMAL
- en: On older versions, Wireshark used to run as a `setuid-root` process, to perform
    packet capture.
  prefs: []
  type: TYPE_NORMAL
- en: Modern versions of Wireshark separate out the packet capture into a program
    called **dumpcap1.** It does not run as a setuid-root process, it runs with required
    capability bits embedded into it, giving it just the privileges it requires to
    do its job—packet capture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The potential payoff to a hacker now performing a successful attack on it is
    thus dramatically reduced— instead of gaining *root*, the hacker at best gains
    the privileges (EUID, EGID) of the user who is running Wireshark and the wireshark
    group; he does not get root! We use *ls(1)* and *getcap(1)* to see this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, in the long listing above, the others (O) access category has no permissions;
    only a root user and members of Wireshark can execute dumpcap(1). (Do *not* execute
    it as a root; you will then defeat the whole point: security).'
  prefs: []
  type: TYPE_NORMAL
- en: 'FYI, the actual packet-capture code is in a library called `pcap—packet` capture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For your information: A security advisory from Red Hat detailing security issues
    with wireshark: [https://access.redhat.com/errata/RHSA-2012:0509](https://access.redhat.com/errata/RHSA-2012:0509).
    A snippet from the following proves an important point:'
  prefs: []
  type: TYPE_NORMAL
- en: '... Several flaws were found in Wireshark. If Wireshark read a malformed packet
    off a network or opened a malicious dump file, it could crash or, possibly, **execute
    arbitrary code as the user running Wireshark**. (CVE-2011-1590, CVE-2011-4102,
    CVE-2012-1595) ...'
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted text is key: Even if a hacker manages the feat of arbitrary
    code execution, it will execute with the privileges of the user running Wireshark—not
    root!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The details on how exactly to set up W*ireshark* with POSIX capabilities is
    covered here (under the section entitled *GNU/Linux distributions*: [https://wiki.wireshark.org/CaptureSetup/CapturePrivileges](https://wiki.wireshark.org/CaptureSetup/CapturePrivileges)
    *.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should now be amply clear: **dumpcap** is a *capability-dumb* binary; the
    Wireshark process (or file) itself is not privileged in any manner. Security wins,
    both ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting capabilities programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how to build a *capability-dumb* binary; now let's figure out how
    to add or drop process (thread) capabilities at runtime within the program itself.
  prefs: []
  type: TYPE_NORMAL
- en: The other side of the coin from getcap is the setcap of course—we have already
    worked with the utility on the command line. Now lets work with the relevant APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing to understand is this: To work with the process capsets, we require
    what is called a "capability state" in memory. To get this capability state, we
    use the `cap_get_proc(3)` API (of course, as mentioned earlier, all these APIs
    are from the `libcap` library, which we will link into). Once we have a working
    context, the capability state, we will use the `cap_set_flag(3)` API to set up
    the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the capability state we received from the `cap_get_proc()`*;*
    the second parameter is the capability set we wish to affect—one of effective,
    permitted or inherited. The third parameter is the number of capabilities we are
    manipulating with this one API call. The fourth parameter—this is where we identify
    the capabilities that we wish to add or drop, but how? We pass a pointer to an
    *array* of `cap_value_t` . Of course, we must initialize the array; each element
    holds a capability. The final, fifth parameter `value` can be one of two values:
    `CAP_SET` to *set* the capability, `CAP_CLEAR` to *drop* it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, all the work has been within a memory context—the capability state
    variable; it''s not really taken effect upon the process (or thread) capsets.
    To actually set the capsets upon the process, we use the *cap_set_proc(3)* API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int cap_set_proc(cap_t cap_p);`'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter to it is the capability state variable that we carefully set up.
    *Now* the capabilities will be set.
  prefs: []
  type: TYPE_NORMAL
- en: Also realize, unless we run it as *root* (which of course we don't—that's really
    the whole point), we cannot just raise our capabilities. Hence, within the `Makefile`
    itself, once the program binary file is built, we perform a `sudo setcap` upon
    the binary executable file itself (`set_pcap`) enhancing its capabilities; we
    bestow the `CAP_SETUID` and the `CAP_SYS_ADMIN` capability bits into its permitted
    and effective capsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next program briefly demonstrates how a process can add or drop capabilities
    (that are of course *within* it''s permitted capset). When run with option 1,
    it adds the `CAP_SETUID` capability and "proves" it via a simple test function
    (`test_setuid()`). Here is an interesting bit: Since the binary *file* already
    has two capabilities embedded within it (we do a `setcap(8)`  in the `Makefile),`
    we actually *need to drop* the `CAP_SYS_ADMIN` capability (from its effective
    set).'
  prefs: []
  type: TYPE_NORMAL
- en: When run with option 2, we want two capabilities—`CAP_SETUID` and `CAP_SYS_ADMIN`;
    it will work, as these are embedded into the effective and permitted capsets.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the relevant code of `ch8/set_pcap.c`***:***
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `setcap(8)` has embedded file capabilities into the binary executable
    `set_pcap` (which `getcap(8)` verifies).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it out; we''ll first run it with option `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pause(2)` system call has put the process to sleep; this is deliberately
    done so that we can try things out (see the next code). As an aside, to work with
    this, the program has set up some minimal signal handling; however, this topic
    will be discussed in detail in subsequent chapters. For now, just understand that
    the pause (and associated signal handling) allows us to literally "pause" the
    process, inspect stuff, and once done, send it a signal to continue it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Above, we inspect the process via both our own `query_pcap` program and the
    proc filesystem. Both the `CAP_SETUID` and `CAP_SYS_ADMIN` capabilities are present
    in both the *Permitted* and *Effective* capsets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue the process, we send it a signal; a simple way—via the `kill(1)`
    command (details in a later [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*). There''s quite a bit to see now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The funny **(boing!)** is just the process informing us that signal handling
    has occurred. (Ignore it.) We invoke the `test_setuid()` function, the function
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We attempt to become *root* (effectively) with the `seteuid(0)` line of code.
    The output shows us that we have succeeded in doing so as the EUID becomes `0`.
    After this, we call the `drop_caps_be_normal()` function, which "drops" all capabilities
    *and* reverts us to "our original self", using the earlier-seen `setuid(getuid())`
    semantic; the function code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The program output indeed shows us that the EUID now reverts to non-zero (the
    RUID of `1000`) and the `seteuid(0)` fails, as expected (now that we've dropped
    capabilities and root privileges.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The process then invokes `pause(2)` once more (the `"Pausing #2 ..."` statement
    in the output), so that the process remains alive; now we can see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, all capabilities have been dropped. (We leave the test case of running
    the program with option `1` to the reader.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an interesting point: You might come across the statement `CAP_SYS_ADMIN`
    is the new root. Really? Let''s test it: What if we embed only the `CAP_SYS_ADMIN`
    capability into the binary file and modify the code to not drop it when running
    under option `1`? At first glance, it would seem that it should not matter—we
    should still be able to successfully perform the `seteuid(0)` as we''re effectively
    running as root with this capability. But guess what? It doesn''t work! Here''s
    the bottom line: This teaches us that while the statement sounds good, it''s really
    not completely true! We still require the `CAP_SETUID` capability to carry out
    arbitrary usage of the `set*id()` system calls.'
  prefs: []
  type: TYPE_NORMAL
- en: We leave it to the reader to write the code for this case and test it as an
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few remaining miscellaneous, but nevertheless useful, points and tips follow:'
  prefs: []
  type: TYPE_NORMAL
- en: How ls displays different binaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A screenshot of Fedora 27 (x86_64) showing the pretty colors `*ls* -l` displays
    when displaying different binary executable types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40ef71dc-ca7b-45cc-841e-95a96ec8fdf1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What exactly are these binaries? Let''s list just that, in the order they''re
    displayed above:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dumpcap`: a file capabilities binary executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passwd`: a `setuid-root` binary executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ping`: a file capabilities binary executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write`: a `setgid-tty` binary executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: The precise meaning and coloring can certainly vary across Linux distributions;
    the output shown is from a Fedora 27 x86_64 system.'
  prefs: []
  type: TYPE_NORMAL
- en: Permission models layering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have seen details on both models—the traditional UNIX permissions
    in the previous chapter and the modern POSIX capabilities one in this one, we
    take a bird''s-eye view of the same. The reality of a modern Linux kernel is that
    the legacy model is actually layered on top of the newer capabilities model; the
    following table  shows this "layering":'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pros and Cons** | **Model/Attributes** |'
  prefs: []
  type: TYPE_TB
- en: '| Simpler, less secure | UNIX Permissions Process and File with UID, GID values
    embedded |'
  prefs: []
  type: TYPE_TB
- en: '|  | Process credentials: {RUID, RGID, EUID, EGID} |'
  prefs: []
  type: TYPE_TB
- en: '| More complex, more secure | POSIX Capabilities |'
  prefs: []
  type: TYPE_TB
- en: '|  | Thread Capsets, File Capsets |'
  prefs: []
  type: TYPE_TB
- en: '|  | Per Thread: {Inherited, Permitted, Effective, Bounded, Ambient} capsets
    Binary File: {Inherited, Permitted, Effective} capsets |'
  prefs: []
  type: TYPE_TB
- en: 'A few observations to note due to this layering, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the upper layer: What appears as a single integer, the process UID and GID,
    is actually two integers under the hood—the real and effective user | group IDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mid layer: Giving rise to the four process credentials: {RUID, EUID, RGID,
    EGID}.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bottom layer: Which in turn is integrated on modern Linux kernels into the
    POSIX capabilities model:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All kernel subsystems and code now use the capabilities model to control and
    determine access to an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now *root* - the "new" root, really—is predicated on the (overloaded) capability
    bit `CAP_SYS_ADMIN` being set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the set*id() system calls can be arbitrarily used to set real/effective IDs
    once the `CAP_SETUID` capability is present:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thus, you can make EUID = 0, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A quick summation of key points regarding security as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, with all our discussion, as far as is possible, do not use the now-outdated
    root mode any longer; this includes the (non) usage of setuid-root programs. Rather,
    you should use capabilities and assign only the required capabilities to the process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: directly or programmatically via the `libcap(3)` APIs ("capability-smart" binaries),
    or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: indirectly via the `setcap(8)` file capabilities on the binary ("capability-dumb"
    binaries).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the above has been done via the API route, you should consider dropping capabilities
    immediately once the need for that capability is done (and raising it only as
    and when required).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Containers: a "hot" fairly recent technology (essentially, containers are lightweight
    virtual machines in a sense), they are quoted as "safe" as they help isolate running
    code. However, the reality is not so rosy: Container deployment is often done
    with little or no thought toward security, resulting in highly insecure environments.
    You can greatly benefit security-wise from the wise use of the POSIX capabilities
    model. An interesting RHEL blog on how you can ask Docker (a popular container
    technology product) to drop capabilities and thus greatly increase security is
    detailed here: [https://rhelblog.redhat.com/2016/10/17/secure-your-containers-with-this-one-weird-trick/](https://rhelblog.redhat.com/2016/10/17/secure-your-containers-with-this-one-weird-trick/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FYI – under the hood, at the level of the Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (The paragraph that follows is just FYI and optional; if interested in deeper
    details then take a look, or feel free to skip it.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the Linux kernel, all task (process and thread) metadata is kept within
    a data structure called the *task_struct* (also known as the *process descriptor*).
    The information on what Linux calls *the security context of a task* is kept within
    this task structure, embedded inside another data structure called **cred** (short
    for **credentials**). This structure, *cred*, contains everything we''ve discussed:
    The modern POSIX capabilities bitmasks (or capability sets) as well as the traditional-style
    process privileges: the RUID, EUID, RGID, EGID (as well as the set[u|g]id and
    fs[u|g]id bits).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `procfs` method we saw earlier actually looks up the credential information
    from here. Hackers are obviously interested in accessing the cred structure and
    being able to modify it on the fly: filling it with zeros in the appropriate places
    gets them root! Does this sound far-fetched? Check out the *(Some) Linux Kernel
    Exploits* in the *Further reading* section on the GitHub repository. Unfortunately,
    it happens more often than anyone would like.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader has been taken through important ideas on the design
    and implementation of the modern POSIX capabilities model (on the Linux OS). Among
    other things, we have covered what POSIX capabilities are, and, crucially, why
    they are important, especially from the viewpoint of security. The embedding of
    capabilities into a runtime process or binary executable was also covered.
  prefs: []
  type: TYPE_NORMAL
- en: The whole intent of the discussion, which started in the previous chapter, is
    to open the application developer's eyes to key security issues that arise when
    developing code. We hope we have left you, the reader, with a feeling of urgency,
    and of course the knowledge and tools to deal with security in a modern manner.
    Today's applications have to not just work; they have to be written with security
    in mind! or else...
  prefs: []
  type: TYPE_NORMAL
