- en: Chapter 1. Ecosystem Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It has been more than two decades now since the birth of PHP. Originally created
    by Rasmus Lerdorf in 1994, the PHP acronym initially stood for **Personal Home
    Page**. Back then, PHP was merely a few **Common Gateway Interface** (**CGI**)
    programs in C, used to power a simple web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though PHP was not intended to be a new programming language, the idea caught
    on. During the late nineties Zeev Suraski and Andi Gutmans, co-founders of Zend
    Technologies, continued the work on PHP by rewriting its entire parser, giving
    birth to PHP 3\. The PHP language name acronym now stood for **PHP: Hypertext
    Preprocessor**.'
  prefs: []
  type: TYPE_NORMAL
- en: PHP positions itself among the top ten programming languages in the world. According
    to TIOBE, the software quality company, it currently holds sixth place. For the
    last decade, especially since the release of PHP 5 in July 2004, PHP has been
    recognized as the popular solution for building web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Though PHP still presents itself as a scripting language, it's safe to say that
    as of PHP 5 it is far more than that. Some of the world web's most popular platforms
    like WordPress, Drupal, Magento, and PrestaShop are built in PHP. It is projects
    like these that played a role in further raising the popularity of PHP. Some of
    them stretch the boundaries of PHP by implementing complex OOP (Object Oriented
    Programming) design patterns found in other programming languages like Java, C#,
    and their frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Even though PHP 5 had decent OOP support, lots of things were still left to
    be dreamed of. Work on PHP 6 was planned to give more support for the PHP Unicode
    strings. Sadly, its development came to a halt and PHP 6 was canceled in 2010.
  prefs: []
  type: TYPE_NORMAL
- en: That same year, Facebook announced its HipHop compiler. Their compiler was converting
    PHP code into C++ code. The C++ code was further compiled into native machine
    code via a C++ compiler. This concept brought major performance improvements for
    PHP. However, this approach was not very practical, because it took too long to
    compile PHP scripts all the way to native machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Shortly after, Dmitry Stogov, Zend Technologies Chief Performance Engineer,
    announced a project called **PHPNG**, which became the basis for the next PHP
    version, PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Dec 2015, PHP 7 was released, bringing numerous improvements and new features:'
  prefs: []
  type: TYPE_NORMAL
- en: New version of the Zend Engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved performance (twice as fast as PHP 5.6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Significantly reduced memory usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Syntax Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent 64-bit support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved exception hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many fatal errors converted to exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed old and unsupported SAPIs and extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The null coalescing operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return and Scalar type declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero cost asserts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready for PHP 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready for PHP 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 comes with quite a big list of changes. These changes affect both the
    PHP interpreter and the various extensions and libraries. Though most of the PHP
    5 code will continue to operate normally on the PHP 7 interpreter, it is worth
    getting up to speed with the newly available features.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will look into some of these features and the benefits they
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar type hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scalar type hints are not an entirely new feature in PHP. With the introduction
    of PHP 5.0 we were given the ability to type hint classes and interfaces. PHP
    5.1 extended this by introducing array type hinting. Later on, with PHP 5.4, we
    were additionally given the ability to type hint callable. Finally, PHP 7 introduced
    scalar type hints. Extending the type hints to scalars makes this probably one
    of the most exciting features added to PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following scalar type hints are now available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string`: Strings (for example, `hello`, `foo`, and `bar`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`: Integer numbers (for example, `1`, `2`, and `3`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`: Floating point numbers (for example, `1.2`, `2.4`, and `5.6`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: Boolean values (for example, `true` or `false`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, PHP 7 works in weak *type-checking* mode, and will attempt to convert
    to the specified type without complaint. We can control this mode using the `strict_typesdeclare()`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `declare(strict_types=1);` directive must be the first statement in a file,
    or else it will generate a compiler error. It only affects the specific file it
    is used in, and does not affect other included files. The directive is entirely
    compile-time and cannot be controlled at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's assume the following simple function that accepts hinted scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The weak type-checking rules for the new scalar type declarations are mostly
    the same as those of extensions and built-in PHP functions. Because of this automated
    conversion we might unknowingly lose data when passing it into a function. One
    simple example is passing a float into a function that requires an int; in which
    case conversion would simply strip away decimals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the weak type-checking is on, as by default, the following can be
    observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the first function call passes on parameters as they are hinted.
    The second function call does not pass the exact types of parameters but still
    the function manages to execute as parameters go through conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the weak type-checking is off, by using the `declare(strict_types=1);`
    directive, the following can be observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function call broke on the first argument resulting in the `\TypeError`
    exception. The `strict_types=1` directive does not allow any type juggling. The
    parameter has to be of the same type, as hinted by the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Return type hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to type hinting, we can also type hint the return *values*. All
    of the type hints that can be applied to function parameters can be applied to
    function return values. This also implies to the weak type-checking rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a return type hint, simply follow the parameter list with a colon and
    the return type, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function definition says that the `divide` function expects two
    parameters of the `int` type, and is supposed to return a parameter of the `int`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the *weak type-checking* is on, as by default, the following can be
    observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Though the actual result of `divide(10, 3)`should be a float, the return type
    hint triggers conversion into an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the weak type-checking is off, by using the `declare(strict_types=1);`
    directive, the following can be observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the `strict_types=1` directive in place, the `divide(10, 3)` fails with
    the `\TypeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using scalar type hints and return type hints can improve our code readability
    as well as auto-complete features of IDE editors like NetBeans and PhpStorm.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the addition of anonymous classes, PHP objects gained closure-like capabilities.
    We can now instantiate objects through nameless classes, which brings us closer
    to object literal syntax found in other languages. Let''s take a look at the following
    simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example shows an `$object` variable storing a reference to an
    instance of an anonymous class. The more likely usage would be to directly pass
    the new class to a function parameter, without storing it as a variable, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to any normal class, anonymous classes can pass arguments through to
    their constructors, extend other classes, implement interfaces, and use traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example would output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The internal name of an anonymous class is generated with a unique reference
    based on its address.
  prefs: []
  type: TYPE_NORMAL
- en: There is no definitive answer as to when to use anonymous classes. It depends
    almost entirely on the application we are building, and the objects, depending
    on their perspective and usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of using anonymous classes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking application tests becomes trivial. We can create on-the-fly implementations
    for interfaces, avoiding using complex mocking APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid invoking the autoloader every so often for simpler implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes it clear to anyone reading the code that this class is used here and nowhere
    else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Anonymous classes, or rather objects instantiated from anonymous classes, cannot
    be serialized. Trying to serialize them results in a fatal error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Nesting an anonymous class does not give it access to private or protected
    methods and properties of the outer class. In order to use the outer class protected
    methods and properties, the anonymous class can extend the outer class. Ignoring
    methods, private or protected properties of the outer class can be used in the
    anonymous class if passed through its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Though we labeled them as anonymous classes, they are not really anonymous in
    terms of the internal name the PHP engine assigns to objects instantiated from
    these classes. The internal name of an anonymous class is generated with a unique
    reference based on its address.
  prefs: []
  type: TYPE_NORMAL
- en: The statement `get_class(new class{});` would result in something like `class@anonymous/php7.php0x7f33c22381c8`,
    where `0x7f33c22381c8` is the internal address. If we were to define the exact
    same anonymous class elsewhere in the code, its class name would be different
    as it would have a different memory address assigned. The resulting object in
    that case might have the same property values, which means they will be equal
    (`==`) but not identical (`===`).
  prefs: []
  type: TYPE_NORMAL
- en: The Closure::call() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP introduced the Closure class in the 5.3 version. Closure class is used to
    represent anonymous functions. Anonymous functions, implemented in PHP 5.3, yield
    objects of this type. As of PHP 5.4, the Closure class got several methods (`bind`,
    `bindTo`) that allow further control of the anonymous function after it has been
    created. These methods basically duplicate the Closure with a specific bound object
    and class scope. PHP 7 introduced the call method on a Closure class. The `call`
    method does not duplicate the closure, it temporarily binds the closure to new
    this (`$newThis`), and calls it with any given parameters. It then returns the
    return value of the closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `call` function signature looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`$newThis` is the object to bind the closure for the duration of the `call`.
    The parameters, which will be given as `$parameters` to the closure are optional,
    meaning zero or more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example of a simple `Customer` class and
    a `$greeting` closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Within the actual `$greeting` closure, there is no `$this`, it does not exist
    until the actual binding occurs. We could easily confirm this by directly calling
    a closure like `$greeting('Hello');`. However, we assume `$this` will come in
    to existence when we bind the closure to a given object instance via its `call`
    function. In which case, `$this` within the closure becomes `$this` of the `customer`
    object instance. The preceding example shows binding of `$customer` to the closure
    using a `call` method call. The resulting output displays **Hello John Doe!**
  prefs: []
  type: TYPE_NORMAL
- en: Generator delegation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generators provide a simple way to implement *iterators* without the overhead
    of implementing a class that implements the **Iterator** interface. They allow
    us to write code which uses `foreach` to iterate over a set of data without needing
    to build an array in memory. This eliminates the exceeds memory limit errors.
    They were not new to PHP, as they were added in PHP 5.5.
  prefs: []
  type: TYPE_NORMAL
- en: However, PHP 7 brings several new improvements to generators, one of which is
    generator delegation.
  prefs: []
  type: TYPE_NORMAL
- en: Generator delegation allows a generator to yield other generators, arrays, or
    objects that implement the **Traversable** interface. In another words, we might
    say that generator delegation is yielding **subgenerators**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example with three generator type functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Yielding other generators requires using the `yield from <expression>` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Generator return expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prior to PHP 7, generator functions were not able to return expressions. The
    inability of generator functions to specify return values limited their usefulness
    for multitasking in co-routine contexts.
  prefs: []
  type: TYPE_NORMAL
- en: PHP 7 made it possible for generators to return expressions. We can now call
    `$generator->getReturn()` to retrieve the `return` expression. Calling `$generator->getReturn()`
    when the generator has not yet returned, or has thrown an uncaught exception,
    will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: If the generator has no return expression defined and has completed yielding,
    null is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the `gen()` function definition and its `return` expression, one
    might expect the value of the `$generator` variable to be equal to the `gen-return`
    string. However, this is not the case, as the `$generator` variable becomes the
    instance of the `\Generator` class. Calling the `getReturn()` method on the generator
    while it is still open (not iterated over) will result in a fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the code is structured in such a way that it is not obvious if the generator
    has been closed, we can use the `valid` method to check, before fetching the return
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The null coalesce operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In PHP 5 we had the ternary operator which tests a value and then returns the
    second element if that value is `true`, or third element if that value is `false`,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While processing user-provided data in web-centered languages such as PHP,
    it is common to check for variable existence. If a variable doesn''t exist, then
    set it to some default value. A ternary operator makes this easy for us, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: However, easy is not always quick or elegant. With that in mind, PHP 7 set out
    to resolve one of the most common usage patterns, by introducing the null coalesce
    operator(`??`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The null coalesce operator enables us to write even shorter expressions, as
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The coalesce operator(`??`) is added right after the `$_GET['role']` variable,
    which returns the result of its first operand if it exists and is not `NULL`,
    or else its second operand. This means the `$_GET['role'] ?? 'guest'` is completely
    safe and will not raise an `E_NOTICE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also nest the coalesce operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Reading from left to right, the first value which exists and is not null is
    the value that will be returned. The benefit of this construct is that it enables
    a clean and effective way to achieve safe fallback to the desired value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Modular-Programming-with-PHP7](https://github.com/PacktPublishing/Modular-Programming-with-PHP7).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!
  prefs: []
  type: TYPE_NORMAL
- en: The Spaceship operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The three-way comparison operator, also known as the Spaceship operator, was
    introduced in PHP 7\. Its syntax goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The operator returns `0` if both operands are equal, `1` if the left is greater,
    and `-1` if the right is greater.
  prefs: []
  type: TYPE_NORMAL
- en: 'It uses the same comparison rules as other existing comparison operators: `<`,
    `<=`, `==`, `>=`, and `>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some examples of Spaceship operator behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One practical use case for this operator is for writing callbacks used in sorting
    functions like `usort`, `uasort`, and `uksort`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Throwables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though PHP 5 introduced the exception model, overall errors and error handling
    remained somewhat unpolished. Basically PHP had two error handling systems. Traditional
    errors still popped out and were not handled by `try…catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following `E_RECOVERABLE_ERROR` as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `try…catch` block has no effect here, as the error is not interpreted as
    an exception, rather a catchable fatal error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible workaround involves setting a user-defined error handler by using
    the `set_error_handler` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The error handler, as written above, would now transform every error into an
    exception, therefore making it catchable with `try…catch` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: PHP 7 made fatal and catchable fatal errors part of engine exceptions, therefore
    catchable with `try…catch` blocks. This excludes warnings and notices which still
    do not pass through the exception system, which makes sense for backward compatibility
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: It also introduced a new exception hierarchy via the `\Throwable` interface.
    `\Exception` and `\Error` implement the `\Throwable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Standard PHP fatal and catchable fatal are now thrown as `\Error` exceptions,
    though they will continue to trigger traditional fatal error if they are uncaught.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout our application we must use `\Exception` and `\Error`, as we cannot
    implement the `\Throwable` interface directly. We could, however, use the following
    block to catch all errors, regardless of whether it is the `\Exception` or `\Error`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The \ParseError
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **ParseError** is a nice PHP 7 addition to error handling. We can now handle
    parse errors triggered by `eval()`, `include` and `require` statements, as well
    as those thrown by `\ParseError` exceptions. It extends `\Error`, which in turn
    implements a `\Throwable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a broken PHP file, because of a missing "`,`"
    inbetween between array items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a file including `config.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can now safely catch possible parse errors.
  prefs: []
  type: TYPE_NORMAL
- en: Level support for the dirname() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `dirname` function has been with us since PHP 4\. It's probably one of the
    most often used functions in PHP. Up until PHP 7, this function only accepted
    the `path` parameter. With PHP 7, the new levels parameter was added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: By assigning the `levels` value, we indicate how many levels to go up from the
    assigned path value. Though small, the addition of the `levels` parameter will
    certainly make it easier to write some of the code that deals with paths.
  prefs: []
  type: TYPE_NORMAL
- en: The integer division function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `intdiv` is a new integer division function introduced in PHP 7\. The function
    accepts dividend and divisor as parameters and returns the integer quotient of
    their division, as shown here by the function description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If the `dividend` is `PHP_INT_MIN` and the divisor is `-1`, then an `ArithmeticError`
    exception is thrown. If the divisor is `0`, then the `DivisionByZeroError` exception
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Constant arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to PHP 7, constants defined with `define()` could only contain scalar
    expressions, but not arrays. As of PHP 5.6, it is possible to define an array
    constant by using `const` keywords, and as of PHP 7, array constants can also
    be defined using `define()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Constants may not be redefined or undefined once they have been set.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform variable syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make PHP's parser more complete for various variable dereferences, PHP 7
    introduced a uniform variable syntax. With uniform variable syntax all variables
    are evaluated from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike various functions, keywords, or settings being removed, changes in semantics
    like this one can be quite impacting for the existing code base. The following
    code demonstrates the syntax, its old meaning and new:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Aside from previously rewritten examples of old-to-new syntax, there are now
    a few newly supported syntax combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP 7 now supports nested double colons,`::`, and following is an example of
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also nest methods and function calls—or any callables—by doubling up
    on parentheses as shown in the following code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can now dereference any valid expression enclosed with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Secure random number generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP 7 introduced two new **CSPRNG** functions. CSPRNG is an acronym for **cryptographically
    secure pseudo-random number generator**.
  prefs: []
  type: TYPE_NORMAL
- en: The first, `random_bytes`, generates an arbitrary length string of cryptographic
    random bytes that are suitable for cryptographic use, such as when generating
    *salts*, *keys*, or *initialization* vectors. The function accepts only one (`length`)
    parameter, representing the length of the random string that should be returned
    in bytes. It returns a string containing the requested number of cryptographically
    secure random bytes, or, optionally, it throws an exception if an appropriate
    source of randomness cannot be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of `random_bytes` usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The second, `random_int`, generates cryptographic random integers that are suitable
    for use where unbiased results are critical, such as when shuffling a deck of
    cards for a poker game. The function accepts two (`min`, `max`) parameters, representing
    the lowest value to be returned (must be `PHP_INT_MIN` or higher) and the highest
    value to be returned (must be less than or equal to `PHP_INT_MAX`). It returns
    a cryptographically secure random integer in the range min to max (inclusive).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of `random_int` usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Filtered unserialize()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serialized data can include objects. These objects can further include functions
    like destructors, `__toString`, and `__call`. In order to increase security when
    unserializing objects on unstructured data, PHP 7 introduced the optional `options`
    parameter to the existing `unserialize` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `options` parameter is of type array that currently only accepts the `allowed_classes`
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `allowed_classes` can have one of three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`true`: This is a default value and allows all objects just as before'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`: Here no objects allowed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: array of allowed class names, lists the allowed classes for unserialized objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of using the `allowed_classes` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the object of that class which is not accepted is instantiated
    as `__PHP_Incomplete_Class`.
  prefs: []
  type: TYPE_NORMAL
- en: Context sensitive lexer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the [http://php.net/manual/en/reserved.keywords.php](http://php.net/manual/en/reserved.keywords.php)
    list, PHP has over 60 reserved keywords. These make up for language constructs,
    like names for properties, methods, constants within classes, interfaces, and
    traits.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes these reserved words end up clashing with user defined API declarations.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the issue, PHP 7.0 introduced the context sensitive lexer. With the
    context sensitive lexer, we may now use keywords for property, function, and constant
    names within our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few practical examples related to the impact of context
    sensitive lexer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The only exception being the `class` keyword, which remains reserved in *class
    constant context*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Group use declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *group use declarations* are introduced in PHP 7 as a way to cut verbosities
    when importing multiple classes from a common namespace. They enable shorthand
    syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following examples where class names within the *same
    namespace* are group used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the *group use declarations* on part of namespaces, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can further use `group use` for importing functions and constants as shown
    in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Unicode enhancements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unicode, and UTF-8 in particular, have grown increasingly popular in PHP applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP 7 adds the new escape sequence for *double-quoted strings* and *heredocs*,
    with the syntax as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It produces the UTF-8 encoding of a Unicode code point, specified with hexadecimal
    digits. It is worth noting that the length of the code-point within curly braces
    is arbitrary. This means that we can use `\u{FF}` or the more traditional `\u{00FF}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple listing of the four most traded currencies, their
    symbols, and their UTF-8 code points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of these symbols usually exist directly on a keyboard, so it''s easy to
    write them down as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the majority of other symbols are not as easily accessible via the
    keyboard as single keystrokes, and therefore need to be written in the form of
    code-points, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In older versions of PHP, the resulting output of preceding statements would
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This obviously did not parse code-points, as it was outputting them literally.
  prefs: []
  type: TYPE_NORMAL
- en: 'PHP 7 introduced Unicode code-point escape sequence syntax to string literals,
    making previous statements result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]php'
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assertions is a debug feature, used to check the given assertion and take appropriate
    action if its result is `false`. They have been part of PHP for years, ever since
    PHP 4.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions differ from error handling in a way that assertions cover for impossible
    cases, whereas errors are possible and need to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: Using assertions as a general-purpose error handling mechanism should be avoided.
    Assertions do not allow for recovery from errors. Assertion failure will normally
    halt the execution of a program.
  prefs: []
  type: TYPE_NORMAL
- en: With modern debugging tools like Xdebug, not many developers use assertions
    for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions can be easily enabled and disabled using the `assert_options` function
    or the `assert.active INI` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use assertions, we pass in either an expression or a string as shown in
    the following function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]php'
  prefs: []
  type: TYPE_NORMAL
- en: These two signatures differ in the second parameter. PHP 7 can accept either
    string `$description` or `$exception`.
  prefs: []
  type: TYPE_NORMAL
- en: If the expression result or the result of evaluating the string evaluates to
    `false`, then a warning is raised. If the second parameter is passed as `$exception`,
    then an exception will be thrown instead of failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In regards to `php.ini` configuration options, the `assert` function has been
    expanded to allow for so-called *zero-cost assertions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]php'
  prefs: []
  type: TYPE_NORMAL
- en: With zero-cost settings, assertions have zero impact on performance and execution
    as they are not compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Boolean assert.exception` option was added to the **INI** setting.
    Setting it to `true`, results in `AssertionError` exceptions for the failed assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the list() construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In PHP 5, `list()` assigns the values starting with the right-most parameter.
    In PHP 7, `list()` starts with the left-most parameter. Basically, values are
    now assigned to variables in the order they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this only affects the case where `list()` is being used in conjunction
    with the `array []` operator, as discussed in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]php'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output of the preceding code in PHP 5 would result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]php'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output of the preceding code in PHP 7 would result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]php'
  prefs: []
  type: TYPE_NORMAL
- en: The order of assignment might change again in the future, so we should not rely
    heavily on it.
  prefs: []
  type: TYPE_NORMAL
- en: Session options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to PHP 7, the `session_start()` function did not directly accept any
    configuration options. Any configuration options we wanted to set on the session,
    needed to come from `php.ini`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]php'
  prefs: []
  type: TYPE_NORMAL
- en: 'Driven by the goal of performance optimization, a new `lazy_write` runtime
    configuration was added in PHP 7\. When `lazy_write` is set to `1`, the session
    data is only rewritten if it changes. This is the default behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]php'
  prefs: []
  type: TYPE_NORMAL
- en: While changes listed here might not look impressive at first, being able to
    override session options directly via the `session_start` function gives certain
    flexibility to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecated features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Globally accepted, major versions of software have the luxury of breaking backward
    compatibility. Ideally, not much, but in order to keep the software moving forward,
    some old ideas need to be left behind. These changes don't come overnight. Certain
    features are first flagged as deprecated to warn developers that it will be removed
    in future versions of the language. Sometimes this period of deprecation takes
    years.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout PHP 5.x, a number of features have been marked as deprecated, and
    in PHP 7.0, they have all been removed.
  prefs: []
  type: TYPE_NORMAL
- en: The **POSIX-compatible** regular expressions have been deprecated in PHP 5.3,
    and now completely removed in PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions are no longer available for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ereg_replace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ereg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eregi_replace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eregi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spliti`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql_regcase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should instead use **Perl Compatible Regular Expressions** (**PCRE**). The
    [http://php.net/manual/en/book.pcre.php](http://php.net/manual/en/book.pcre.php)
    is a great source of documentation for these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `mysql` extension, which had been deprecated in PHP 5.5, has now been removed.
    None of the `mysql_*` functions are available anymore. We should instead use the
    `mysqli` extension. The good thing is that moving from `mysql` to `mysqli` functions
    is mostly simple, as when adding `i` to our code, the `mysql_*` function calls
    and passes the database handle (returned by `mysqli_connect`) as the first parameter.
    The [http://php.net/manual/en/book.mysqli.php](http://php.net/manual/en/book.mysqli.php)
    is a great source of documentation for these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PHP script and ASP tags are no longer available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Application frameworks are a collection of functions, classes, configurations,
    and conventions all designed to support the development of web applications, services,
    and APIs. Some applications are embracing an API first approach, whereas server-side
    REST and SOAP APIs are built via PHP, and client side in other technologies like
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building a web application, we usually have three obvious choices:'
  prefs: []
  type: TYPE_NORMAL
- en: We can build everything ourselves, from scratch. This way, our development process
    might be slow, but we can achieve architecture built entirely per our standards.
    Needless to say, this is a highly unproductive approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use one of the existing frameworks. This way, our development process
    is fast, but we need to be happy that our application is built on top of other
    things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use one of the existing frameworks but also try to abstract it to the
    level where our application looks independent of it. This is a painful and slow
    approach, to say the least. It involves writing numerous adapters, wrappers, interfaces,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, frameworks are here to make it easier and quicker for us to build
    our software. A great deal of programming languages out there have popular frameworks.
    PHP is no exception to this.
  prefs: []
  type: TYPE_NORMAL
- en: Given the popularity of PHP as a go-to web programming language, it is no surprise
    that dozens of frameworks have sprouted over the years. Choosing the "right" framework
    is a daunting task, even so more for fresh starters. What is right for one project
    or a team might not be right for another.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some general, high level segments each modern framework
    should encompass. These account for:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modular**: It supports modular application development, allowing us to neatly
    separate our code into functional building blocks, whereas it is built in a modular
    manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure**: It provides various cryptographic and other security tooling expected
    of a modern web application. Provides seamless support for things like authentication,
    authorization, and data encryption.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: Manages to easily adopt our application needs, allowing us
    to extend it according to our application needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community**: It is actively developed and supported by a vibrant and active
    community.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High performing**: Built with performance in mind. Many frameworks brag about
    performance, but there are many variables to it. We need to be specific as to
    what we are evaluating here. Measuring cached performance against raw performance
    is often the misleading evaluation, as caching proxies can be put in front of
    many frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise ready**: Depending on the type of project at hand, most likely
    we would want to target a framework which flags itself as enterprise ready. Making
    us confident enough of running critical and high-usage business applications on
    top of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it's perfectly alright to code an entire web application in pure PHP without
    using any framework, the majority of today's projects do use frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using frameworks outweigh the purity of doing it all from scratch.
    Frameworks are usually well supported and documented, which makes it easier for
    teams to catch up with libraries, project structure, conventions, and other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to PHP frameworks, it is worth pointing out a few popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Laravel**: [https://laravel.com](https://laravel.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Symfony**: [http://symfony.com](http://symfony.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zend Framework**: [http://framework.zend.com](http://framework.zend.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CodeIgniter**: [https://www.codeigniter.com](https://www.codeigniter.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CakePHP**: [http://cakephp.org](http://cakephp.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slim**: [http://www.slimframework.com](http://www.slimframework.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yii**: [http://www.yiiframework.com](http://www.yiiframework.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phalcon**: [https://phalconphp.com](https://phalconphp.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is by no means a complete or even a popularity sorted list.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laravel is released under an MIT license, and can be downloaded from [https://laravel.com/](https://laravel.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the usual routing, controllers, requests, responses, views, and (blade)
    templates, out of the box Laravel provides a large amount of additional services
    such as authentication, cache, events, localization, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: Another neat feature of Laravel, is **Artisan**, the command line tool, that
    provides a number of useful commands that we can use during development. Artisan
    can further be extended by writing our own console commands.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel has a pretty active and vibrant community. Its documentation is simple
    and clear, which makes it easy for newcomers to get started. Furthermore, there
    is also [https://laracasts.com](https://laracasts.com), which extends out beyond
    Laravel in terms of documentation and other content. Laracasts is a web service
    providing a series of expert screencasts, some of which are free.
  prefs: []
  type: TYPE_NORMAL
- en: All of these features make Laravel a choice worth evaluating when it comes to
    the selection of a framework.
  prefs: []
  type: TYPE_NORMAL
- en: Symfony
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Symfony is released under an MIT license, and can be downloaded from [http://symfony.com](http://symfony.com).
  prefs: []
  type: TYPE_NORMAL
- en: Over time, Symfony introduced the concept of **Long-term Support**(**LTS**)
    releases. This release process has been adopted as of Symfony 2.2, and strictly
    followed as of Symfony 2.4\. The standard version of Symfony is maintained for
    eight months. Long-term Support versions are supported for three years.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other interesting thing about new releases is the time-based release model.
    All of the new versions of Symfony releases come out every six months: one in
    May and one in November.'
  prefs: []
  type: TYPE_NORMAL
- en: Symfony has great community support via mailing lists, IRC, and StackOverflow.
    Furthermore, SensioLabs professional support provides a full range of solutions
    from consulting, training, coaching, to certification.
  prefs: []
  type: TYPE_NORMAL
- en: Lots of Symfony components are used in other web applications and frameworks,
    such as Laravel, Silex, Drupal 8, Sylius, and others.
  prefs: []
  type: TYPE_NORMAL
- en: What made Symfony such a popular framework is its interoperability. The idea
    of "Don't lock yourself up within Symfony!" made it popular with developers as
    it allowed for building applications that precisely meet our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'By embracing the "don''t reinvent the wheel" philosophy, Symfony itself makes
    heavy use of existing PHP open-source projects as part of the framework, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Doctrine (or Propel): Object-relational mapping layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDO database abstraction layer (Doctrine or Propel)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PHPUnit: A unit testing framework'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Twig: A templating engine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swift Mailer: An e-mail library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on our project needs, we can choose to use a full-stack Symfony framework,
    the Silex micro-framework, or simply some of the components individually.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, Symfony provides a lot of structural ground for new web applications.
    It does so via its bundle system. Bundles are sort of like micro-applications
    inside our main application. Within them, the entire app is nicely structured
    into models, controllers, templates, configuration files, and other building blocks.
    Being able to fully separate logic from different domains helps us to keep a clean
    separation of concerns and autonomously develop every single feature of our domain.
  prefs: []
  type: TYPE_NORMAL
- en: Symfony is one of the PHP pioneers when it comes to embracing the dependency
    injection across the framework, allowing it to achieve decoupled components and
    to keep high flexibility of code.
  prefs: []
  type: TYPE_NORMAL
- en: Documented, modular, highly flexible, performant, supported, those are the attributes
    that make Symfony a choice worth evaluating.
  prefs: []
  type: TYPE_NORMAL
- en: Zend Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Zend Framework is released under a new BSD license, and can be downloaded from
    [http://framework.zend.com](http://framework.zend.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Zend Framework features include:'
  prefs: []
  type: TYPE_NORMAL
- en: Fully object-oriented PHP components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensible MVC supporting layouts and templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple database systems MySQL, Oracle, MS SQL, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mail handling via mbox, Maildir, POP3, and IMAP4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible caching system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from a free Zend Framework, Zend Technologies Ltd provides its own commercial
    version of a PHP stack called Zend Server, and Zend Studio IDE that includes features
    specifically to integrate with Zend Framework. While Zend Framework is perfectly
    fine running on any PHP stack, Zend Server is advertised as an optimized solution
    for running Zend Framework applications.
  prefs: []
  type: TYPE_NORMAL
- en: By its architectural design, Zend Framework is merely a collection of classes.
    There is no strictly imposed structure our application needs to follow. This is
    one of the features that makes it so appealing to a certain range of developers.
    We could either utilize Zend MVC components to create a fully-functional Zend
    Framework project, or we can simply load the components we need.
  prefs: []
  type: TYPE_NORMAL
- en: The so called full-stack frameworks impose structure, ORM implementations, code-generation,
    and other fixed things onto your projects. Zend Framework, on the other hand,
    with its decoupled nature, classifies for a glue type of framework. We can easily
    glue it to an existing application, or use it to build a new one.
  prefs: []
  type: TYPE_NORMAL
- en: The latest versions of Zend Framework follow the **SOLID object oriented design**
    principle. The so called "use-at-will" design allows developers to use whichever
    components they want.
  prefs: []
  type: TYPE_NORMAL
- en: Though the main driving force behind Zend Framework is Zend Technologies, many
    other companies have contributed significant features to the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Zend Technologies provides excellent Zend Certified PHP Engineer
    certifications. Quality community, official company support, education, hosting,
    and development tools make the Zend Framework choice worth evaluating.
  prefs: []
  type: TYPE_NORMAL
- en: CodeIgniter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CodeIgniter is released under an MIT license, and can be downloaded from [https://www.codeigniter.com](https://www.codeigniter.com).
  prefs: []
  type: TYPE_NORMAL
- en: CodeIgniter prides itself in being lightweight. The core system requires only
    a handful of small libraries, which is not always the case with other frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: The framework uses the simple **Model-View-Control** approach, allowing for
    clean separation between logic and presentation. The View layer does not impose
    any special template language, so it uses native PHP out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the outstanding features of CodeIgniter:'
  prefs: []
  type: TYPE_NORMAL
- en: Model-View-Control-based system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extremely light weight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full featured database classes with support for several platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query builder database support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form and data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and XSS filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full page caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search-engine friendly URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible URI routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for hooks and class extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large library of helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeIgniter has an active community gathered around [http://forum.codeigniter.com](http://forum.codeigniter.com).
  prefs: []
  type: TYPE_NORMAL
- en: Small footprint, flexibility, exceptional performance, near-zero configuration,
    and thorough documentation are what makes this framework choice worth evaluating.
  prefs: []
  type: TYPE_NORMAL
- en: CakePHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CakePHP is released under an MIT license, and can be downloaded from [http://cakephp.org](http://cakephp.org).
  prefs: []
  type: TYPE_NORMAL
- en: The CakePHP framework was greatly inspired by **Ruby on Rails**, using many
    of its concepts. It values conventions over configuration.
  prefs: []
  type: TYPE_NORMAL
- en: It comes with "batteries included". Most of the things we need for modern web
    applications are already built-in. Translations, database access, caching, validation,
    authentication, and much more are all built-in.
  prefs: []
  type: TYPE_NORMAL
- en: Security is another big part of the CakePHP philosophy. CakePHP comes with built-in
    tools for input validation, CSRF protection, form tampering protection, SQL injection
    prevention, and XSS prevention, helping us to secure our application.
  prefs: []
  type: TYPE_NORMAL
- en: CakePHP supports a variety of database storage engines, such as MySQL, PostgreSQL,
    Microsoft SQL Server, and SQLite. The built-in CRUD feature is very handy for
    database interaction.
  prefs: []
  type: TYPE_NORMAL
- en: It counts on a big community behind it. It also has a big list of plugins, available
    at [http://plugins.cakephp.org](http://plugins.cakephp.org).
  prefs: []
  type: TYPE_NORMAL
- en: CakePHP provides a certification exam, whereby developers are tested in their
    knowledge of the CakePHP framework, MVC principles, and standards used within
    CakePHP. Certification is geared towards real world scenarios and intimate CakePHP
    specifics.
  prefs: []
  type: TYPE_NORMAL
- en: Commercial support, consultation, code review, performance analysis, security
    audits, and even development services are provided by the Cake Development Corporation
    [http://www.cakedc.com](http://www.cakedc.com). The Cake Development Corporation
    is the commercial entity behind the framework, established in 2007 by Larry Masters,
    a founder of CakePHP.
  prefs: []
  type: TYPE_NORMAL
- en: Slim
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Slim is released under an MIT license, and can be downloaded from [http://www.slimframework.com](http://www.slimframework.com).
  prefs: []
  type: TYPE_NORMAL
- en: While frameworks with the "batteries included" mindset provide robust libraries,
    directory structures, and configurations, micro frameworks get us started with
    a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Micro frameworks usually lack even the basic framework features such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ORM database abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input validation and sanitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This limits their use, but also makes them a great tool for rapid prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: Slim supports any PSR-7 HTTP message implementation. An HTTP message is either
    a request from a client to a server or a response from a server to a client. Slim
    functions like a dispatcher that receives an HTTP request, invokes an appropriate
    callback routine, and returns an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing about Slim is that it plays nicely with middleware. The middleware
    is basically a callable that accepts three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\Psr\Http\Message\ServerRequestInterface`: The PSR7 request object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\Psr\Http\Message\ResponseInterface`: The PSR7 response object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callable`: The next middleware callable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middlewares are free to manipulate request and response objects, as long as
    they return an instance of `\Psr\Http\Message\ResponseInterface`. Furthermore,
    each middleware needs to invoke the next middleware and pass it to request and
    response objects as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: This simple concept gives Slim the power of extensibility, through various possible
    third party middlewares.
  prefs: []
  type: TYPE_NORMAL
- en: Even though Slim provides good documentation, a vibrant community, and the project
    is being actively developed to date, its usage is limited. Micro frameworks are
    hardly a choice for robust enterprise applications. Still, they have their place
    in development.
  prefs: []
  type: TYPE_NORMAL
- en: Yii
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yii is released under a BSD License, and can be downloaded from [http://www.yiiframework.com](http://www.yiiframework.com).
  prefs: []
  type: TYPE_NORMAL
- en: Yii's focus on performance optimization makes it a perfect choice for almost
    any type of project, including the enterprise type of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the outstanding Yii features include:'
  prefs: []
  type: TYPE_NORMAL
- en: The MVC design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic generation of complex service WSDL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translation, localization, locale-sensitive formatting of dates, time, and numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data caching, fragment caching, page caching, and HTTP caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handler that displays errors based on the nature of the errors and the
    mode the application runs in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security measures to help prevent SQL injection, **Cross-site scripting** (**XSS**),
    **Cross-site request forgery** (**CSRF**), and cookie tampering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit and functional testing based on **PHPUnit** and **Selenium**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the neat features of Yii is a tool called **Gii**. It's an extension
    that provides a web-based code generator. We can use Gii's graphical interface
    to quickly set up generate models, forms, modules, CRUD, and so on. There is also
    a command line version of Gii for those who prefer consoles over GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Yii's architecture allows it to play nicely with third-party code, like PEAR
    libraries, Zend Framework, and the like. It adopts the MVC architecture, allowing
    for clean separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Yii provides an impressive library of extensions available at [http://www.yiiframework.com/extensions](http://www.yiiframework.com/extensions).
    The majority of extensions are distributed as composer packages. They empower
    us with accelerated development. We can easily package our code as extensions
    and share it with others. This makes Yii even more interesting for modular application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Official documentation is quite comprehensive. There are also several books
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Rich documentation, a vibrant community, active releases, performance optimization,
    security emphasis, feature richness, and flexibility make Yii a choice worth evaluating.
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Phalcon is released under a BSD License, and can be downloaded from [https://phalconphp.com](https://phalconphp.com).
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon was originally released in 2012, by Andres Gutierrez and collaborators.
    The goal of the project was to find a new approach to traditional web application
    frameworks written in PHP. This new approach came in the form of C language extensions.
    The entire Phalcon framework is developed as a C extension.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of C-based frameworks lies in the fact that an entire PHP extension
    is loaded during runtime. This greatly reduces I/O operations massively since
    there is no need to load `.php` files any more. Furthermore, compiled C language
    code executes faster than PHP bytecode. Since C extensions are loaded together
    with PHP one time during the web server daemon start process, their memory footprint
    is small. The downside of C-based frameworks is that the code is compiled, so
    we cannot easily debug it and patch it as we would with PHP classes.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level architecture and optimizations make Phalcon one of the lowest overheads
    for MVC-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon is a full-stack, loosely coupled framework. While it does provide full
    MVC structure to our application, it also allows us to use its objects as glue
    components based on the needs of our application. We can choose if we want to
    create a full blown MVC application, or the minimal style micro application. Micro
    applications are suitable to implement small applications, APIs, and prototypes
    in a practical way.
  prefs: []
  type: TYPE_NORMAL
- en: All of the frameworks we mentioned so far enable some form of extensions, where
    we can add new libraries or entire packages to a framework. Since Phalcon is a
    C-code framework, contributions to the framework doesn't come in the form of PHP
    code. On the other hand, writing and compiling C language code can be somewhat
    challenging for an average PHP developer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Zephir** project [http://zephir-lang.com](http://zephir-lang.com) addresses
    these challenges by introducing high-level Zephir language. Zephir is designed
    to ease the creation and maintainability of C extensions for PHP with a focus
    on type and memory safety.'
  prefs: []
  type: TYPE_NORMAL
- en: When communicating with databases, Phalcon uses **Phalcon Query Language**,
    **PhalconQL**, or simply **PHQL** for short. PHQL is a high-level, object-oriented
    SQL dialect that allows us to write queries using SQL-like language that works
    with objects instead of tables.
  prefs: []
  type: TYPE_NORMAL
- en: View templates are handled by Volt, Phalcon's own templating engine. It is highly
    integrated with other components, and can be used independently in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Phalcon is pretty easy to pick up. Its documentation covers both the MVC and
    micro applications style of using a framework, with practical examples. The framework
    itself is rich enough to support the structure and libraries we need for most
    of today's applications. On top of that, there is an official Phalcon website
    called **Phalconist** [https://phalconist.com](https://phalconist.com) which provides
    additional resources to framework.
  prefs: []
  type: TYPE_NORMAL
- en: Though there is no official company behind it, no certifications, no commercial
    support, and similar enterprise looking things, Phalcon does a great job of positioning
    itself as a choice worth evaluating even with a robust enterprise application
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking back on the release of PHP 5 and its support to OOP programming, we
    can see the enormous positive impact it had on the PHP ecosystem. A large number
    of frameworks and libraries have sprawled out, offering enterprise level solutions
    to web application development.
  prefs: []
  type: TYPE_NORMAL
- en: The release of PHP 7 is likely to be another leap forward for the PHP ecosystem.
    Though none of the new features are revolutionary as such, as they can be found
    in other programming languages from years ago, they impact PHP greatly. We are
    yet to see how its new features will reshape existing and future frameworks and
    the way we write applications.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of more advanced *errors to exceptions* handling, scalar type
    hints, and function return type hints will surely bring much awaited stability
    to applications and frameworks using them. The speed improvements compared to
    PHP 5.6 are significant enough to cut down the hosting costs for higher load sites.
    Thankfully, the PHP development team minimized backward incomparability changes,
    so they should not stand in the way of swift PHP 7 adoption.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right framework is all but an easy task. What classifies a framework
    as an enterprise class framework is more than just collection of classes. It has
    an entire ecosystem around it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One should never be driven by hype when evaluating a framework for a project.
    Questions like the following should be taken into consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it company or community driven?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it provide quality documentation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it have a stable and frequent release cycle?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it provide some official form of certification?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it provide free and commercial support?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it have occasional seminars we can attend?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it open towards community involvement, so we can submit functionalities and
    patches?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it a full-stack or glue type of framework?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it convention or configuration driven?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it provide enough libraries to get you started (security, validation, templating,
    database abstractions, ORMs, routing, internationalization, and so on)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the core framework be extended and overridden enough to make it more future
    proof with possible changes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of established PHP frameworks and libraries out there, so
    the choice is all but easy. Most of these frameworks and libraries are still to
    fully catch up with the latest features added in PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will look into common design patterns
    and how to integrate them in PHP.
  prefs: []
  type: TYPE_NORMAL
