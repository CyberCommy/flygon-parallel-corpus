- en: Quick Start
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开始
- en: Are you ready to work your way to Angular mastery? My guess is that you are,
    and with this book and your determination, you will. You purchased this book,
    and I not only thank you, but I want to make a promise to you right here, right
    now. Two promises, in fact. The first one is that if you diligently read the material,
    apply the knowledge you'll gain along the way, and build the example application
    with me throughout these pages, you will be well on your way to Angular mastery.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好迈向Angular的精通了吗？我猜你是的，有了这本书和你的决心，你一定会成功的。你购买了这本书，我不仅要感谢你，还要在这里向你做出承诺。事实上，是两个承诺。第一个是，如果你认真阅读材料，应用你在学习过程中获得的知识，并且在这些页面中和我一起构建示例应用程序，你就会在迈向Angular的精通之路上取得很大进展。
- en: If you're anything like me, you have a library packed with literally hundreds
    of technical books and you have read most of them. Some books start off at an
    excruciatingly slow pace, entrenched in theory and historical minutia, while other
    books start off so quickly, they leave the readers scratching their heads wondering
    if they are too dumb to understand the material. The truth is, striking a balance
    while introducing readers to potentially brand new material—and not have them
    nod off as they read their newly acquired 400+ page technical book—is a tricky
    thing to pull off. So, my esteemed budding Angular guru, that is what my second
    promise is to you. I promise to do my utmost in finding that all-elusive happy
    medium between being technically heavy-handed, and being real-world practical
    while making this book as entertaining a read as I possibly can for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你和我一样，你的书架上堆满了成百上千本技术书籍，而你已经读过大部分。有些书开始的速度极其缓慢，深陷于理论和历史细枝末节，而其他书则开始得太快，让读者不知所措，想知道自己是不是太笨，无法理解材料。事实上，介绍读者可能全新的材料，而不让他们在阅读新获得的400多页技术书时打瞌睡，是一件棘手的事情。所以，我尊敬的初学者Angular大师，这就是我对你的第二个承诺。我承诺尽我所能找到技术和实际之间的平衡，让这本书在向你介绍新材料的同时，尽可能地有趣。
- en: With the promises well stated, let's start our journey to Angular mastery together
    by taking a quick look at what we're going to cover in this brisk, but all important
    first chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺已经说得很清楚了，让我们一起开始Angular精通之旅，快速浏览一下我们将在这个简洁但非常重要的第一章中涵盖的内容。
- en: We'll set up your development environment in a jiffy, and we'll build our first
    Angular application in order to get some immediate feeling of accomplishment.
    We're going to skim over the details as we write it, but right after that, we'll
    cover a few critical Angular basics in more detail before concluding this chapter.
    These first few basics are the very first things you should get comfortable with
    because we'll use them over and over again throughout the book as we learn about
    the more advanced stuff.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将迅速设置你的开发环境，并构建我们的第一个Angular应用程序，以便立即获得一些成就感。在编写它时，我们会略过细节，但在那之后，我们将更详细地介绍一些关键的Angular基础知识，然后结束本章。这些最基本的知识是你应该熟悉的第一件事情，因为在学习更高级的内容时，我们会一遍又一遍地使用它们。
- en: After we cover these basics, we'll switch gears from Angular speak and we'll
    take a look at the fully fledged application that we'll be building together throughout
    the remainder of the book. As a bonus (and there are a few bonuses in this book
    that I hope will bring you a bunch of value), we're also going to touch on design
    principles, wireframing, and a little used design strategy called paper prototyping—whose
    focus is on usability testing. Paper prototyping has been around since approximately
    1985 and has largely been replaced by Lean UX design since approximately 2008\.
    Still, I'm always amazed at how many of my clients have never even heard of paper
    prototyping—but I'm also happy when they discover the value it brings to them
    when they try it out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们涵盖了这些基础知识之后，我们将从Angular语言转换，并且我们将看一下我们将在本书的其余部分一起构建的完整应用程序。作为一个奖励（在本书中有一些奖励，我希望能给您带来很多价值），我们还将涉及设计原则、线框图和一种很少使用的设计策略，称为纸质原型设计——其重点是可用性测试。纸质原型设计大约自1985年左右开始流行，并且在大约2008年左右被精益UX设计所取代。然而，我总是惊讶于我的许多客户甚至从未听说过纸质原型设计，但当他们尝试时，他们发现它给他们带来的价值，我也感到很高兴。
- en: 'We''ll cover paper prototyping at a high level at the end of this chapter,
    immediately following the wireframes section, which is the most logical place
    for discussing paper prototyping. We''ll touch on a few UX design principles as
    well, but not on the Lean UX process itself since that would take us too far off
    course from our focus of this book. However, if you have an interest in the Lean
    UX design process, here is a good starting point: [https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux](https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章末尾对纸质原型设计进行高层次的介绍，紧接着线框图部分，这是讨论纸质原型设计的最合逻辑的地方。我们还将涉及一些UX设计原则，但不涉及精益UX设计过程本身，因为那会让我们偏离本书的重点。然而，如果您对精益UX设计过程感兴趣，这是一个很好的起点：[https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux](https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux)。
- en: OK, my esteemed budding Angular guru, are you primed and ready to get started?
    Good! Let's go!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我尊敬的初学者Angular大师，你准备好开始了吗？太好了！让我们开始吧！
- en: 'The topics we will be covering in the chapter are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题有：
- en: Angular's evolution
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的发展
- en: Angular's building blocks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular的构建模块
- en: Setting up your development environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: Writing your first Angular application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的第一个Angular应用程序
- en: Angular basics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular基础知识
- en: Our sample project
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的示例项目
- en: The process of paper prototyping
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纸质原型设计的过程
- en: Angular's evolution
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的发展
- en: Angular is a frontend JavaScript-based web application framework that provides
    you with everything you need, including the kitchen sink, with which to build
    amazingly powerful **Single Page Applications** (**SPAs**). The application we'll
    be building together is an SPA, and we'll be discussing SPA strategies along the
    way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是一个基于前端JavaScript的Web应用程序框架，为您提供了构建强大的单页应用程序（SPA）所需的一切，包括厨房水槽。我们将一起构建的应用程序是一个SPA，并且我们将在此过程中讨论SPA策略。
- en: While Angular wasn't the first JavaScript-based frontend web application framework,
    it was quite possibly the most powerful one of them. This is likely due to Angular's
    SPA-centric focus—since there's more to building an SPA application than there
    is to simply provide two-way data binding on your web pages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Angular不是第一个基于JavaScript的前端Web应用程序框架，但它很可能是其中最强大的一个。这可能是因为Angular专注于SPA，因为构建SPA应用程序比在您的网页上提供双向数据绑定要复杂得多。
- en: The initial release of Angular was in late fall of 2010\. Since then, dozens
    of competing libraries and frameworks have come on the scene, including some that
    also have large adoptions and large production implementations, such as Ember.js,
    Backbone.js, and React.js. Angular, despite having perhaps the highest learning
    curve (and we'll see why this is the case), remains the most powerful one of them
    all.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular naming and versioning jungle can, at first glance, seem confusing.
    There are a few reasons for this, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular''s 1.x releases**: Basically, any release prior to Angular 2 is commonly
    referred to as AngularJS.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS is no more actively in development mode. It has been put under long
    term support mode.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular framework is being actively developed, and so developers need to be
    specific about which of the two Angular frameworks they are referring to when
    discussing them. Fortunately, there are two completely dedicated websites for
    them: [https://angularjs.org/](https://angularjs.org/) and [https://angular.io](https://angular.io),
    respectively. The Angular team adopted semantic versioning, starting with the
    2.0.0 release. You can read more about semantic versioning here: [https://semver.org](https://semver.org).'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 2 was a complete rewrite of Angular 1.x (that is, AngularJS), and is
    thus not backward compatible with AngularJS. While Angular 4 was not a complete
    rewrite of Angular 2, it did have some changes in its core libraries that required
    the team to increment its major number from 2 to 4\. Version 3 was skipped as
    a release number altogether.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All releases from Angular 2 onward are commonly referred to as Angular 2+, or
    simply just as Angular.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to having adopted semantic versioning, the Angular team never released Angular
    3 and so went straight from Angular 2 to Angular 4\. Specifically, there was a
    misalignment of the router package's version, which was already distributed as
    version 3.3.0\. We'll cover routing in Angular in great detail in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*. Don't let this confuse you. Just know that there wasn't ever an Angular
    3\. No big deal. In the Windows OS world, there was never a Windows 9 either.
    These things happen.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After reading the preceding list, you can see why there tends to be some confusion
    around Angular. However, it''s pretty straightforward if you keep these two things
    in mind:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: You should really only be using Angular, and not AngularJS (unless you have
    an exceptionally good reason for it)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您真的应该只使用Angular，而不是AngularJS（除非您有一个非常好的理由）。
- en: With the exception of there not being an Angular 3, there will be two major
    releases per year; they should be contiguous in numbering scheme (that is, 8,
    9, and so on), and they are expected to be backward compatible—at least within
    the same major version number (as per the spirit of semantic versioning)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了没有Angular 3之外，每年将有两个主要版本发布；它们应该在编号方案上是连续的（即8、9等），并且预计它们将向后兼容——至少在相同的主要版本号内（根据语义版本控制的精神）。
- en: 'You can check out the official Angular release schedule here: [https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md). Since
    Angular is a complete rewrite of the AngularJS platform, and this is worlds apart
    from AngularJS, we''ll skip AngularJS altogether and start by taking a look at
    Components which are Angular''s building blocks. Are you with me? Great, let''s
    speedily move ahead.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查看官方的Angular发布时间表：[https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md)。由于Angular是对AngularJS平台的完全重写，与AngularJS相去甚远，我们将完全跳过AngularJS，首先看一下Angular的构建块——组件。跟上我吗？好的，让我们快速前进。
- en: Angular's building blocks
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular的构建块
- en: Adding new features is the business of publishing new frameworks—but luckily,
    the fundamental underlying architecture does not change very often. When it does,
    it's not typically a complete overhaul. With the exception of Angular 2.0, which
    was completely divergent from its predecessor, all major releases so far contain
    largely the same architecture.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新功能是发布新框架的事情，但幸运的是，基本的底层架构并不经常改变。当它改变时，通常不是完全的彻底改变。除了完全不同于其前身的Angular 2.0之外，到目前为止，所有主要版本发布基本上包含相同的架构。
- en: Let's now take a look at the core architectural pieces of the framework.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看框架的核心架构组件。
- en: Components
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件
- en: Components are like widgets that are in charge of displaying themselves along
    with the data they consume and/or manipulate on areas of your screen called views.
    An Angular application is like a tree of components, and Angular provides mechanisms
    for components to communicate with each other in a bidirectional manner—parent
    to child and child to parent.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 组件就像小部件一样，负责在屏幕上的视图区域显示自己以及它们消耗和/或操作的数据。Angular应用程序就像一个组件树，Angular提供了组件之间双向通信的机制——从父级到子级和从子级到父级。
- en: Templates
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: Components rely on their templates for rendering their data. Templates are where
    you define what the component looks like and you can hook in styles to window-dress
    your component any way you like. A component can either contain its template (that
    is, the HTML) and its styling (that is, the CSS) either directly within itself
    or have references to template and style files outside of itself. At the end of
    the day, the world's fanciest frontend frameworks produce HTML, CSS, and JavaScript
    because these three things are the only things browsers understand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 组件依赖于它们的模板来呈现它们的数据。模板是您定义组件外观的地方，您可以添加样式来装饰您喜欢的任何方式。组件可以包含其模板（即HTML）和其样式（即CSS），直接在自身内部，或者引用模板和样式文件在自身外部。归根结底，世界上最花哨的前端框架产生HTML、CSS和JavaScript，因为这三样是浏览器唯一理解的东西。
- en: Directives
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: Within the templates you create for your component, Angular enables you to alter
    the DOM with powerful constructs called directives. There are directives for controlling
    the way things are rendered on the screen (that is, the component view) such as
    repeating snippets of HTML, for displaying things based on conditional logic,
    for hiding or showing things, filtering arrays of data, and much more.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在您为组件创建的模板中，Angular使您能够使用称为指令的强大构造来更改DOM。有用于控制屏幕上的渲染方式（即组件视图）的指令，例如重复HTML片段，根据条件逻辑显示内容，隐藏或显示内容，过滤数据数组等等。
- en: Modules
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Angular is modular. That is to say that its functionality is wrapped up in modules,
    known as NgModules, and are themselves libraries. Modules are perfect for lumping
    code together in an organized way. For instance, there are modules for helping
    with forms, routing, and communicating with RESTful APIs. Many third-party libraries
    are packaged as NgModules so you can incorporate them into your Angular applications.
    Two examples of this are Material Design and AngularFire—we'll be taking a look
    at both of these libraries in later chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Angular是模块化的。也就是说，它的功能被封装在称为NgModule的模块中，并且它们本身就是库。模块非常适合以有组织的方式将代码组合在一起。例如，有用于帮助处理表单、路由和与RESTful
    API通信的模块。许多第三方库被打包为NgModule，因此您可以将它们整合到您的Angular应用程序中。其中两个例子是Material Design和AngularFire
    - 我们将在后面的章节中查看这两个库。
- en: Services
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Services are not really an Angular artifact per se, but rather a very general
    notion representing encompassed functionality, functions, and features that your
    application's components may need to consume. Things such as logging, data retrieval,
    or virtually any calculation or lookup service, can be written as services—these
    services can reside within your application, or live externally from it. You can
    think of a service as a highly specialized class that provides some *service* (such
    as looking up the distance between two zip codes) and does it well. Just as with
    components, not only are there tons of third-party services you can use in your
    Angular applications, but you can create your own custom services. We'll learn
    how to do this in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实际上并不是Angular的一个特定部分，而是一个非常普遍的概念，代表着应用程序组件可能需要消耗的封装功能、函数和特性。诸如日志记录、数据检索或几乎任何计算或查找服务等功能可以被编写为服务
    - 这些服务可以存在于您的应用程序中，也可以存在于外部。您可以将服务视为提供某种*服务*（例如查找两个邮政编码之间的距离）并且做得很好的高度专业化的类。与组件一样，不仅有大量的第三方服务可以在您的Angular应用程序中使用，而且您还可以创建自己的自定义服务。我们将在[第12章](9610f27b-03db-4258-8a68-24eb3901117b.xhtml)中学习如何做到这一点，*集成后端数据服务*。
- en: Dependency injection
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: '**Dependency injection**(**DI**), or **Inversion of Control** (**IoC**), is
    a very useful and common software design pattern. This pattern is used to *inject*
    objects into the objects that depend on them. The object you''re using that depends
    on other objects can just go ahead and use it without needing to worry where it
    is in order to load it, or how to instantiate it—you just use it as if it just
    sprung into existence at the time you needed it. Services are perfect for injecting
    into our application. We''ll learn how to use DI in Angular, and how we can use
    the Angular **command-line interface** (**CLI **) to generate injectable services
    of our own design.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**（**DI**）或**控制反转**（**IoC**）是一种非常有用和常见的软件设计模式。这种模式用于将对象*注入*到依赖于它们的对象中。依赖于其他对象的对象可以直接使用它，而不需要担心它在哪里加载，或者如何实例化它
    - 你只需在需要时使用它，就好像它在你需要它的时候就出现了。服务非常适合注入到我们的应用程序中。我们将学习如何在Angular中使用DI，以及如何使用Angular的**命令行界面**（**CLI**）来生成我们自己设计的可注入服务。'
- en: 'Just before we move on to setting up our development environment, here are
    some interesting things about Angular:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续设置开发环境之前，这里有一些关于Angular的有趣事实：
- en: AngularJS was built using JavaScript, while Angular was built using TypeScript.
    While this adds a level of abstraction when writing Angular applications, using
    TypeScript provides a few important advantages when building larger apps with
    larger teams—we'll get to those shortly.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS是使用JavaScript构建的，而Angular是使用TypeScript构建的。虽然在编写Angular应用程序时这增加了一定程度的抽象，但使用TypeScript在构建更大的应用程序和更大的团队时提供了一些重要的优势-我们很快就会谈到这些。
- en: AngularJS was based on controllers, whereas Angular is component based. You'll
    learn all you need to know about components in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    **Building Angular Components.**
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AngularJS基于控制器，而Angular是基于组件的。您将在[第6章](acd5e47c-07a7-4954-993d-360134221325.xhtml)中学习有关组件的所有必要知识，**构建Angular组件**。
- en: SPAs are notorious for being difficult for implementing **Search Engine Optimization**
    (**SEO **), but Angular is SEO friendly.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序以难以实现**搜索引擎优化**（**SEO**）而臭名昭著，但Angular对SEO友好。
- en: It's possible to build native mobile applications with Angular.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular也可以构建原生移动应用程序。
- en: It's also possible to build cross-platform, desktop-installed applications with
    Angular.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Angular也可以构建跨平台的桌面应用程序。
- en: Angular can also run on the server, using Angular Universal.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular也可以在服务器上运行，使用Angular Universal。
- en: You have to admit, this is a pretty impressive and exciting list. These things
    and more make learning Angular a worthwhile endeavor and the marketplace is asking
    for Angular know-how.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须承认，这是一个相当令人印象深刻和令人兴奋的清单。这些事情以及更多其他事情使学习Angular成为一项值得的努力，市场正在寻求Angular的专业知识。
- en: Setting up your development environment
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的开发环境
- en: In order to get started with Angular, you're going to need to have the **Angular
    CLI** installed; to install that, you first need to have Node.js and **npm** (**node
    package manager**) installed. If you've already got Node.js and npm installed,
    great! If not, don't worry—they are easy to install and I will take you through
    the installation process in Appendix A, *Toolchain for Web Development with Angular*,
    near the back of the book. In Appendix A, I also take you through installing the
    Angular CLI and how to use it for building Angular applications. For brevity,
    I'll refer to the Angular CLI tool as just the CLI from this point forward.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Angular，您需要安装**Angular CLI**；要安装它，您首先需要安装Node.js和**npm**（**node包管理器**）。如果您已经安装了Node.js和npm，太好了！如果没有，不用担心-它们很容易安装，我将在书的后面附录A“使用Angular进行Web开发的工具链”中带您完成安装过程。在附录A中，我还将带您安装Angular
    CLI以及如何使用它构建Angular应用程序。为了简洁起见，从现在开始我将简称Angular CLI工具为CLI。
- en: If you are unsure whether you have NodeJS and npm installed, you can check really
    quickly by typing `$ node -v` and `$ npm -v`, respectively, on your command line.
    Similarly, you can type `$ ng -v` on the command line to see whether you have
    CLI installed. If you get a version number back, you have that particular tool
    installed (as shown in the following screenshot I took).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定是否已安装NodeJS和npm，您可以通过在命令行上分别输入`$ node -v`和`$ npm -v`来快速检查。同样，您可以在命令行上输入`$
    ng -v`来查看是否已安装CLI。如果您收到版本号，那么您已安装了该特定工具（如我所示的下面的截图）。
- en: '**Note**: Do not type `$` at the beginning of the commands. The `$` signifies
    the command prompt, entry point for the commands you''ll type. Unix-based operating
    systems, such as macOS and Linux systems, commonly use `$` or `%` as their command
    prompt—depending on the shell being used, or if there are any custom settings
    specified in a configuration file on your system. Windows operating systems typically
    use the greater than sign, `>`, as their command prompt.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：不要在命令开头输入`$`。`$`表示命令提示符，您要输入的命令的入口点。基于Unix的操作系统，如macOS和Linux系统，通常使用`$`或`%`作为命令提示符，具体取决于所使用的shell，或者系统上的配置文件中指定的任何自定义设置。Windows操作系统通常使用大于号`>`作为命令提示符。'
- en: '![](assets/2d1515f5-ddb3-4f8b-a4bd-f47283a42a15.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2d1515f5-ddb3-4f8b-a4bd-f47283a42a15.png)'
- en: If any of these commands go unrecognized, jump on over to Appendix A real quick,
    install the tools, and jump right back here. I'll be waiting for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中任何命令无法识别，请快速跳转到附录A，安装工具，然后立即回到这里。我会等着你。
- en: We'll also need a code editor. There are many code editors available today,
    including a number of free ones. Though any code editor will suffice, I would
    suggest you use Visual Studio Code for your Angular development—at least while
    working through this book. The reason for this is that Visual Studio Code is free,
    it's cross-platform, and is an excellent code editor. It's also the code editor
    that I've used while writing this book and so when I suggest the use of an extension,
    you can easily install the same one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个代码编辑器。今天有许多代码编辑器可用，包括一些免费的。虽然任何代码编辑器都可以，但我建议您在编写本书时至少使用Visual Studio
    Code进行Angular开发。原因是Visual Studio Code是免费的，跨平台的，是一个优秀的代码编辑器。这也是我在写这本书时使用的代码编辑器，所以当我建议使用某个扩展时，您可以轻松安装相同的扩展。
- en: The preceding is all you need for this first chapter. When we start building
    the example project, which requires us to have a local database, you'll also need
    to install MongoDB. MongoDB, also known as Mongo, is a great NoSQL database that
    is also free and cross-platform. I take you through Mongo's installation process
    in Appendix B, *MongoDB*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容就是本章的全部内容。当我们开始构建示例项目时，需要我们有一个本地数据库，您还需要安装MongoDB。MongoDB，也称为Mongo，是一个很棒的免费跨平台NoSQL数据库。我会在附录B，*MongoDB*中带您完成Mongo的安装过程。
- en: Additionally, there will be other software that you'll need to install, such
    as Chrome extensions, and I will let you know what they are and where to find
    them at the appropriate time. For now, let's get started with writing some Angular
    code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有其他软件需要安装，例如Chrome扩展程序，我会在适当的时候告诉您它们是什么以及在哪里找到它们。现在，让我们开始编写一些Angular代码。
- en: Writing your first Angular application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个Angular应用程序
- en: When it comes to experimenting with Angular code, as you pick up this awesomely
    powerful framework, you generally have two choices of how to proceed. The first
    is to use an online code editor such as JSFiddle, Plunker, StackBlitz, or more.
    In Appendix C, *Working with StackBlitz*, you'll learn about the basics of using
    StackBlitz so you can use it from time to time to test some quick code without
    needing a test project in your development environment. You can visit the StackBlitz
    website here: [https://stackblitz.com](https://stackblitz.com).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始尝试Angular代码时，作为您掌握这个强大的框架，通常有两种选择。第一种是使用在线代码编辑器，如JSFiddle、Plunker、StackBlitz等。在附录C中，*使用StackBlitz*，您将学习如何基本使用StackBlitz，以便您可以不时地使用它来测试一些快速代码，而无需在开发环境中需要测试项目。您可以在StackBlitz网站上访问：[https://stackblitz.com](https://stackblitz.com)。
- en: The second approach is to use your own local development environment—and since
    we've already set it up in the previous section, you can create a project whose
    sole purpose is to run some quick example code if you'd rather use that than an
    online code editor. My goal is to show you that you have options—there's not just
    one way to experiment with some code as you learn Angular.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用您自己的本地开发环境——因为我们已经在前一节中设置了它，您可以创建一个项目，其唯一目的是运行一些快速示例代码，如果您宁愿使用本地开发环境而不是在线代码编辑器。我的目标是向您展示您有选择的余地——学习Angular并不只有一种方法来尝试一些代码。
- en: When you use an online code editor, such as StackBlitz, the only software you
    need installed is a browser—no other tools whatsoever. While this makes things
    very easy, the trade-off is that you are extremely restricted in what you can
    do. That being said, I encourage you to experiment with an online code editor,
    but we'll only be using our development environments throughout this book. So,
    let's do that and create a small application together in just a few minutes time—we'll
    build a to-do list app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用在线代码编辑器（如StackBlitz）时，您唯一需要安装的软件是浏览器——没有任何其他工具。虽然这使事情变得非常容易，但代价是您在所能做的事情上受到极大限制。话虽如此，我鼓励您尝试在线代码编辑器，但在本书中我们将只使用我们的开发环境。所以，让我们做到这一点，并在短短几分钟内一起创建一个小应用程序——我们将构建一个待办事项列表应用程序。
- en: Using your development environment
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用您的开发环境
- en: From this point forward, we'll be using our terminals, the CLI, and the Visual
    Studio Code. Head on over to [https://code.visualstudio.com](https://code.visualstudio.com),
    where you'll be able to download the Visual Studio Code installation package for
    your operating system of choice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用我们的终端、CLI和Visual Studio Code。前往[https://code.visualstudio.com](https://code.visualstudio.com)，在那里您可以下载适用于您选择的操作系统的Visual
    Studio Code安装包。
- en: Location of your files
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的文件位置
- en: When it comes to setting up a local environment, you can, of course, place your
    directories and files wherever you like. If you have a folder where you have your
    web application projects, go to it now. If you don't have a dedicated place for
    projects, this is as good a time as any to get into the habit of being organized.
    For instance, on my machine, I have a folder named `dev` for any and all development
    I do. Within my `dev` folder, I have a folder named `playground`, where I have
    a subfolder for each technology I'm learning, or playing with. I prefer to use
    a Mac when writing code, and so my complete pathname to where I have my Angular
    *play stuff* is `/Users/akii/dev/playground/angular` (as shown at the bottom of
    the screenshot of my terminal, a few pages back). That same screenshot also shows
    the versions of Node.js, npm, and the CLI that I had installed at the time of
    writing. If having a directory structure like this works for you, by all means,
    use it. If you already have a way you organize your work, use that. The important
    thing is to be very disciplined and consistent with how you organize your development
    environment.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置本地环境时，您当然可以将目录和文件放在任何您喜欢的地方。如果您有一个存放Web应用项目的文件夹，请立即转到该文件夹。如果您没有专门的项目存放位置，现在是养成有条理习惯的好时机。例如，在我的电脑上，我有一个名为`dev`的文件夹，用于我所做的任何开发。在我的`dev`文件夹中，我有一个名为`playground`的文件夹，其中有一个我正在学习或玩耍的每种技术的子文件夹。我喜欢在编写代码时使用Mac，因此我存放Angular
    *play stuff*的完整路径是`/Users/akii/dev/playground/angular`（如前几页终端屏幕截图底部所示）。同一屏幕截图还显示了我在写作时安装的Node.js、npm和CLI的版本。如果这样的目录结构适合您，请尽管使用。如果您已经有组织工作的方式，请使用它。重要的是要非常有纪律性和一致性地组织您的开发环境。
- en: Generating our to-do list application
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成我们的待办事项列表应用程序
- en: With the installation of what we need now being out of the way—meaning we have
    our CLI tool available to us—go to your terminal and type the following at your
    command prompt `$ ng new to-dolist --style=scss --routing`, and then hit *Enter*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要的安装已经完成 - 这意味着我们可以使用CLI工具 - 转到您的终端并在命令提示符处键入以下内容`$ ng new to-dolist --style=scss
    --routing`，然后按*Enter*。
- en: The `ng` command runs the CLI tool, and its `new` command instructs it to create
    a new Angular application. The application, in this case, is named `to-dolist`.
    You'll notice that there also are two command-line flags, which are special options
    for the `new` command. The style flag tells the CLI that we'd like to use `scss`,
    instead of `css`, and the routing flag tells the CLI that we'd like it to integrate
    and set up routing for us by default. We'll be using SASS, as opposed to CSS,
    in this book, and SCSS is the file extension for Sass files. As a reminder, we're
    going to have a crash course on Sass in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap
    – Grid Layout and Components.*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ng`命令运行CLI工具，其`new`命令指示它创建一个新的Angular应用程序。在这种情况下，应用程序的名称是`to-dolist`。您会注意到还有两个命令行标志，这是`new`命令的特殊选项。style标志告诉CLI我们想要使用`scss`，而不是`css`，routing标志告诉CLI我们希望它默认集成和设置路由。在本书中，我们将使用SASS，而不是CSS，并且SCSS是Sass文件的文件扩展名。作为提醒，我们将在[第3章](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml)中进行Sass的速成课程，*Bootstrap
    - 网格布局和组件*。'
- en: The first time you use the CLI to create your Angular application, it will take
    anywhere from 45 seconds to well over a minute for it to create your project for
    you. This is because it needs to download and install various things for you before
    it creates the project's folder structure. However, when creating subsequent Angular
    applications, the CLI won't take nearly as long.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用CLI创建您的Angular应用程序时，它将花费45秒到一分钟多的时间为您创建项目。这是因为它需要为您下载和安装各种东西，然后再创建项目的文件夹结构。但是，创建后续的Angular应用程序时，CLI不会花费太长时间。
- en: Serving up our to do list application
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供我们的待办事项应用程序
- en: 'Once the CLI has completed creating the application, you can run it by changing
    to the project directory (`$ cd to-dolist`) and issuing the `$ ng serve` command.
    This will have the CLI run your application. The CLI''s built-in web server will
    be listening on localhost port `4200` by default. By the way, the CLI''s web server
    keeps watch on your project files, and when it notices a change in one of your
    files, it reloads the application—there''s no need for you to stop the server
    and issue the server command again. This is very convenient as you''re making
    lots of changes and tweaks during development. Next, open your browser and visit
    `http://localhost:4200` and you should see something like the following, which
    proves that the CLI is working correctly:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CLI完成创建应用程序，您可以通过转到项目目录（`$ cd to-dolist`）并发出`$ ng serve`命令来运行它。这将使CLI运行您的应用程序。CLI的内置Web服务器默认情况下将在localhost端口`4200`上监听。顺便说一句，CLI的Web服务器会监视您的项目文件，当它注意到文件中的更改时，它会重新加载应用程序
    - 您无需停止服务器并再次发出服务器命令。这在开发过程中进行大量更改和调整时非常方便。接下来，打开浏览器并访问`http://localhost:4200`，您应该会看到类似以下内容的东西，这证明了CLI正在正确工作：
- en: '![](assets/f235b2f8-c85e-4dd7-a3e1-9fcc0f7633e9.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f235b2f8-c85e-4dd7-a3e1-9fcc0f7633e9.png)'
- en: 'Now that the CLI created the to-do list application for you, open that folder
    in Visual Studio Code (note: for brevity, I''ll be referring to Visual Studio
    Code as the IDE). You should see a folder structure for your to-do list project
    in the left-hand panel of your IDE, similar to the following (except for the to-do
    folder, which you won''t have just yet; we''ll get to how to generate that using
    the CLI in the upcoming subsection on components).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the to-dolist project in the IDE (with the
    `app.component.ts` file open):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bbd90490-510f-4844-93ab-2d44cbfdcd46.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: When working on your Angular applications, the vast majority of your time will
    be spent working within the `src | app` folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Angular basics
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the basic building blocks of Angular. In fact, you can think
    of an Angular web application as a tree of components. When you use the CLI to
    generate the shell for your Angular application, the CLI also autogenerates one
    component for you. The filename is app.component.ts and is in the `src/app` folder.
    The app component is how your Angular application is bootstrapped—meaning that
    it is the first component that is loaded, and all the other components are pulled
    into it. This also means that components can be nested. The previous screenshot
    shows our project directory structure, with the `src/app` folder expanded, and
    the `app.component.ts` open in the IDE's file editor window. The `.ts` file extension
    indicates that it is a TypeScript file. Interesting note—when you write Angular
    applications, you use TypeScript instead of JavaScript. In fact, the Angular team
    used TypeScript to write Angular!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: After the following *Components* section, you'll find a complete code listing
    for our Angular application. There are six files that you'll have to edit. Three
    of them are already available in the application that you generated with the CLI.
    The other three will be available in your project once you use the CLI to generate
    the to-do component, which is the directory that you are presently missing when
    you compare your project structure to the previous screenshot. You'll find out
    how to do that in the following *Components* section, which is why the complete
    code listing was inserted afterward. Don't worry—follow along, keep the faith
    that Angular mastery is within your grasp, and you'll be just fine. If you don't
    believe me, just lie down on the floor and mumble these words, *This too, shall
    pass*, three times, slowly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Components
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a high-level fly-by on Angular components—just enough coverage
    of what an Angular component is. [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components*, is completely dedicated to Angular components and is where
    we're going to take a deep dive into them. Consider this section to be a little
    peek behind the component curtain, and when we get to discussing components, we're
    going to pull the curtains wide open and take a good look at the *Component Wizard
    of Oz*. Remember that in the *Wizard of Oz* story, Dorothy and the gang were petrified
    of the Wizard, but when he was finally revealed behind the curtains, they all
    soon stopped being scared.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, you can think of components as the basic building blocks
    or Angular, and of your Angular application as a tree of nested components. Buttons,
    progress bars, input fields, entire tables, advanced things such as carousels,
    and even custom video players—these are all components. The components on your
    web page can communicate with each other, and Angular has a couple of rules and
    protocols for how they can go about doing so. By the end of this book, you will
    become very comfortable with the ins and outs of components. You must, for it's
    simply the way of the Angular guru!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: When you write a component file, as in the code that follows, there are three
    main sections to it. The first is the import section. The middle section is the
    component decorator, and it's where you indicate what the component's template
    file is (which defines what the component looks like), and what the components
    style file is (which is used to style the component).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Since we used the `style=scss` flag, we get our file in SCSS as opposed
    to the traditional CSS type file. The export section is the last section in the
    component file and is where all the logic for the component will be placed. There''s
    a lot more that can go into a component''s TypeScript file than what is shown
    in the following code snippet, as we''ll see in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The CLI created the app component for us by default when it created our application
    for us, but how do we create our own components? The easiest way to generate a
    new component is to use the CLI and issue the following command: `$ ng generate
    component name-of-component`. So, to generate a new component named `to-doitem`,
    we would type `$ ng generate component to-doitem` on our command prompt. Remember
    to do this from within the `src | app` folder. The CLI will generate this component
    and insert it into its own folder, and the name of the newly created folder will
    be the same as the component.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this folder, you will see four new files and their names all start with
    `to-doitem.component` because the name of our component is `todoitem`, and, well,
    it''s a component. We''ll discuss what the file ending in `spec.ts` is used for
    later, but you may already have a good guess as to what the other three files
    are for. Let''s verify what you are probably already thinking; the component file
    itself is indeed the one named `todoitem.component.ts`. This file contains a reference
    to two of the others: `todoitem.component.html`, which is the template for the
    component (the HTML code, for defining its markup structure), and the `todoitem.component.scss`
    file, which will hold the styling for the component. Additionally, the CLI modified
    an existing file named `app.module.ts`. We''ll discuss this file in more detail
    later on, but for now, all you need to know is that this file acts as a registry
    for your application''s components.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking, *That's a lot of files. Are they all needed?* The short
    answer to that is no. In  [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), F*lex-Layout
    – Angular's Responsive Layout Engine,* we'll look at how we can eliminate the
    `.html` file, and the `.scss` files, and just put all of our component *stuff* (the
    HTML and the styling) into our component file. However, there is a reason the
    Angular team provided the mechanism to have all these things be separate—so your
    application's code can be tidy and organized. You can thank them later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: A nice shortcut syntax when using the CLI to generate a component is to type
    `$ ng g c name-of-component`, where `g` is short for generating, and `c` is short
    for the component.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In addition to creating our own components from scratch, which we'll look at
    in depth in [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), F*lex-Layout
    – Angular's Responsive Layout Engine*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Code listing for the to-do list application
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the to-do component generated, you have four new files within
    the `todo` folder. You'll edit three of them to look like the following code listings
    that follow. You also need to edit three of the files that were already in your
    project, (where we'll open the curtains to meet the wizard), we can also integrate
    components from other libraries and frameworks into our application. We'll take
    a look at how to do this with NG Bootstrap in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components*, and with Angular Material in [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml),
    *Templates, Directives, and Pipes*. There's no shortage of components for Angular,
    and the amount available for your use will only grow over time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I learn new technology and follow along with a book, blog post, or
    whatever else, I enter everything in by hand—even when the files are available
    for download. Yes, manual entry can be a tedious process, but it engages your
    brain, and the material and concepts start to get absorbed. Simply downloading
    the files and cutting and pasting the contents into your application does not
    have the same effect. I''ll let you decide which way you want to go. If you opt
    for downloading the code, there are instructions at the beginning of this book
    for doing so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The code listing for `todo.component.html` (within the `src | app | todo` folder)
    is shown here:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The code listing for `todo.component.ts` (within the `src | app | todo` folder)
    is as follows:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The code listing for `todo.component.scss` (within the `src | app | todo` folder)
    is as follows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the code listing for `app.component.html` (within the `src
    | app` folder). [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick
    Start* : to-do List (quick example app):'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code listing for `app.module.ts` (within the `src | app` folder) is as
    follows:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code listing for `styles.scss` (within the `src` folder) is shown here:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cool! So, now you have all the code in place. Do you remember how to run your
    Angular application? Enter `$ ng serve` at your command prompt, and once the message
    comes up that the compilation was successful, open your browser and go to `http://localhost:4200`.
    Does the application work? If so, congratulations on building your first Angular
    application! If not, check for typos.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Play around with your new application. We haven't bothered to take the time
    to add functionality to edit the to-do item, or to delete them, but you can clear
    it out by just reloading the application by hitting your browser's refresh button.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Why do things get cleared out upon refreshing the page? This happens because
    we have an SPA and are not persisting the data that we enter into a database.
    We'll definitely be sure to add the ability to persist our data when we build
    our much larger application, which will be introduced to you by the end of this
    chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interpolation is how you get a value from a variable within your component class
    to render in the component's template. If you recall, the logic for the component
    goes in the export section of the component class. That is the same place where
    variables are that you would like to use interpolation to have their values rendered
    in the template (that is, rendered on the web page). Let's assume that you have
    a variable called `items` and that its value is currently `4`. To render the value
    in the template, you use a pair of double curly braces with the variable in between
    them. The variables and component logic are written inside the class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry—we'll see lots of code snippets throughout the book that use interpolation,
    but for now, you can see this sample code that shows it in action. The code is
    meaningless and hardcoded for now, but it does demonstrate interpolation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The first screenshot is of the component file (`home.component.ts`); the variable
    is declared on line 10:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30572145-f1fc-41da-bb99-4aeefaf4a75e.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'This second screenshot is of the component''s template file (`home.component.html`).
    Notice the pair of double curly braces on line 6:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76e0188f-b097-4146-8680-c70da6505d7b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'This last screenshot shows the rendered value, `4` in this case. That''s the
    basics of interpolation. We''ll see much more advanced usage of it throughout
    the book as we work on our annotated photo album:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3684dbe0-0840-4063-9527-d2a2f7646344.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Templating and styling
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already mentioned something about templating and styling in the last
    few paragraphs of the *Components* section. Now that we have a small project available
    to us—the one that we created with the CLI—we can see what this looks like in
    code. Open your Angular project in the IDE, and open the `app.component.ts` file.
    Lines 5 and 6 in this app component file contain the references to its associated
    template (the `.html` file), and its style file (`.scss`), respectively. The following
    is a screenshot of the open project in my IDE, with the `app.component.ts` file
    open:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e12b6c78-e46f-443e-9ffc-baf3919b0333.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Property binding
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of data binding we can do in Angular, namely, one-way and
    two-way. Interpolation is very similar to one-way data binding. This is because,
    in both cases, data flows from the component class to the component template and
    not the other way around. Property binding is data binding in the sense that the
    data is being bound to a property.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to have two-way property binding—meaning, not only can the
    value of a component property be bound to the template, but the template can alter
    the value of a component property. This is made possible in Angular by `ngModel`.
    Again, don't worry about this for now. We will take a look at two-way property
    binding later on. Just know that both one-way and two-way property binding is
    possible in Angular.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Implementing one-way property binding is very straightforward. All you need
    to do is to put square brackets around the HTML property (in the component's template)
    you want the data bound to, and assign the variable to it. To see a quick example
    of what one-way property binding looks like in code, take a look at the next three
    screenshots.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The first screenshot is of the component file (`home.component.ts`); the variable,
    `txtPlaceholder`, is declared on line 11:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31cdb8a5-ea56-47b0-9f2b-31262d708db0.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: 'This next screenshot is of the component''s template file (`home.component.html`).
    In line 14, you can see the square brackets around the placeholder property of
    the input element:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a85ab11c-81f6-48a4-ae43-e5143ea231b2.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'This last screenshot is of the application running in the browser. You can
    see the text, Enter your todo item here, inserted as the placeholder text for
    the textbox via one-way property binding:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cd5ce0ef-f94c-491c-bea0-ed5154c3108d.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Event binding
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Angular, event binding simply means that an event will be registered on an
    element within a component, and when that event happens, it will trigger a function
    to be called. In other words, an event will call a function. There are a ton of
    events that you can have Angular listen for—such as a button being clicked, a
    mouse hovering over an image, or when the user presses a key down when the cursor
    is in a textbox, and lots more. And, of course, you can write any function you
    can possibly think of to make other stuff happen, such as calling a web service,
    changing the color of the background page, calculating the value of Pi to 1,000
    decimal places, or virtually anything else your heart desires. But how can we
    set up event binding in our Angular application to tie the event we're interested
    in, on the element we're interested in, to run the function we want? Well, thankfully,
    the Angular team made this super easy for us.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we'd like to have some user interaction via events such as click or
    mouseover—we can use event binding to map the functionality.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now, that example is not very interesting, but we do have our to-do list application
    to look at the code we've already written. If you've typed in the code listings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Our sample project
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning a new programming language, or learning a new framework, is a matter
    of hands-on experimentation and repetition. Even Dr. Sheldon Cooper from *The
    Big Bang Theory* can't learn Angular just by reading a book on it. However, just
    following along with random code examples isn't much fun to do and, at the end
    of the day, you don't really have anything you can use. So, the approach we'll
    take on our journey to Angular mastery is to build a fully fledged web application
    that is fun to build and practical since you can deploy it and use it yourself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Annotated photo album
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application that we'll be building together is based on one of the online
    services I've launched called Vizcaro. Vizcaro is a photo sharing service, but
    instead of sharing individual photos, you share albums (groups of photos). Also,
    the photos and albums will be annotated so you can add titles and captions to
    them. Our version won't have all the bells and whistles that my online service
    offers, but it will have just enough parts to make it a great web application
    to build in order to learn the material in this book.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Design principles
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are generally two types of design: the way in which you design your user
    interface (the GUI), and the way in which you design the software components (API
    interfaces, services, components, and more). Throughout this book, we''ll be covering
    quite a few design principles for the code. Angular is a spectacularly well-designed
    piece of software, and this is great for us because it provides a perfect opportunity
    to discuss software design as we learn Angular itself, in addition to when building
    our application. We''ll also be covering user interface design principles in general
    as we build our application throughout the remainder of this book, but particularly
    when we build out our templates using our wireframes to help guide us.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: In general, the term UX design is used when discussing user interface design.
    Borrowing a definition of UX design from *Wikipedia:*
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '*"UX design is the process of enhancing user satisfaction with a product by
    improving the usability, accessibility, and pleasure provided in the interaction
    with the pr*o*duct."*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: This is a good definition and applies to more than just software products.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Wireframes
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wireframes have been around since the early '80s. Their focus, at least initially,
    was on what the screen in the desktop application did (remember, web applications
    were not around yet), and for its general layout. They were not meant to be used
    as what the final design was to look like—including font selection, colors, and
    other properties of the controls on the screen. In essence, they were the *prototype
    on paper*. *Paper prototyping*, conversely, is a process that uses the wireframes.
    It's worth noting that the nouns *wireframes* and *mockups* are used interchangeably—they
    are the same thing. I'll briefly cover the paper prototyping process at the end
    of this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Wireframing tools
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably have already guessed, or already know, there are several tools
    available for creating wireframes when laying out your application, such as Balsamiq
    Mockups, Mockflow, and Visio. For my web applications, and in this book, my preference
    is to use Balsamiq Mockups. Which one you end up using for your applications,
    or are already using, doesn't matter. In fact, even if your wireframes are drawn
    by hand using a pen on the back of your napkin from your favorite fast food restaurant,
    it would be cool with me. Seriously, the important thing is that you get into
    the habit of creating wireframes before writing a single line of code. Why? Because
    it's a smart thing to do, and it saves you a lot of time. Additionally, it gives
    you the perfect opportunity to really think about what you're going to be building.
    And, it's something that you can present to users in order to get their feedback
    on the usability without writing a single line of code. There are even more benefits;
    it gives you some idea on how you would design your data model for the application,
    as well as APIs for services it may consume. Would you start a business without
    a business plan? Would you build your dream home without a blueprint? Building
    a web application shouldn't be any different specification out the pages using
    wireframes. Always. Capiche?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Wireframes for our annotated photo album
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are 10 wireframes that we'll be using for building our application—one
    for each screen it will have. The following is the listing of them, and a short
    description precedes each screenshot.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Home page
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every web application needs a starting page of some kind. It''s known by many
    names, typically one of these: home page, landing page, index page, or splash
    page. Ours will be straightforward. No Flash animation or rainbow-colored backgrounds;
    it will be a simple page that lets the user know what the site does, and hopefully,
    it does that within five to seven seconds. If it doesn''t, you may lose the visitor
    forever:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea890012-567d-4c92-818c-c96051c6c623.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Dashboard
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most web applications don't have a dashboard page, but those that do typically
    provide a summary of *things* the user has, the last time they had logged in,
    and any notifications that the company would like to bring to the user's attention.
    If you use online banking, chances are that your bank's online banking web application
    has a dashboard page—and it probably is a list of accounts (checking, savings,
    credit cards, car loans, and more), and the balances on those accounts that you
    have with them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to build an application that users will implement to create photo
    albums, and so our dashboard will contain the number of photos we have uploaded,
    the number of photo albums, the last time we logged in, and more:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d581b2ce-f2d4-4777-b599-b1bef1e654be.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Image upload
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our application is supposed to enable our users to create photo albums,
    we''d better have a way for them to upload their photos! Yes—we are dedicating
    an entire web page to upload one photo at a time because we will use this same
    page to preview it after it has been uploaded—and to *undo* the upload. You''d
    be surprised to know that there is a well-known photo sharing site that does not
    show what you have just uploaded until you go to the listing of your photos! Having
    an immediate confirmation that the photo you intended to upload is, in fact, the
    one that was uploaded:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7449aa18-12f6-493f-9e4c-1ac9c154bdc7.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: Photo preparation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Uploading a photo is the first step in our annotated photo album application.
    We are devoting another web page to *preparation* the photo. This is where we
    will allow the user to resize the image and annotate it (give it a name and a
    caption). The photo''s caption will be shown when viewing it in the photo album:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5fe4f4c7-bf33-4eb4-b79d-44f984d291c7.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Create Album
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the user can add photos in their photo albums, they have to be able
    to create the albums. This is what the following web page will be used for:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e37499af-b3ba-4e09-a05e-7e5d0843cf35.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Photo listing
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You always need to think of usability and how to design the most intuitive
    user interface you possibly can. This page will show a listing of all the photos
    that the user has uploaded. Additionally, they can edit the name and caption for
    any of the photos right on this same page. The less jumping around from page to
    page that your users need to do, the happier they''ll be:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59af18c7-4b71-4aaa-b476-45bc36327cbc.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Photo album listing
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This page does for photo albums what the previous page did for photos—provides
    a listing of all the albums the user created and has an intuitive way to edit
    their name and description (as opposed to the caption for photos) without going
    to another web page:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/46ec35d7-1d44-4526-a14b-e039003346c0.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Workbench
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The workbench is the place where the user will be able to drag a photo onto
    a photo album. This will be our way of allowing the user to intuitively associate
    a specific photo to a specific album. By the way, not only will our drag and drop
    feature be intuitive and functional, it will add an element of fun for the user.
    Psychologically, users want to *play* on the site. Dragging and dropping—though
    not a mind-blowing experience—is more fun to do than it would be to select a photo
    from a photo dropdown, then select an album from an album dropdown, and, finally,
    click a *connect* or *associate* button. The former method would please the user,
    and the latter would make them send you a nastygram—then leave the site, never
    to return:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16597a79-4baf-40ae-8f85-07d830b16ad7.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: Album viewer
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the end of the day, the users want to see their photo albums in an engaging
    way. The drag and drop stuff was fun but they''re not here for that. They''re
    here to see photos from their son''s birthday party, their daughter''s high school
    graduation, or pictures of their dream home. This is an important page for them;
    it''s where their work of using our site will pay off for them. Let''s not disappoint
    them:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7aa7fb53-ab7c-4a21-8aa1-294ba62bfa96.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: This concludes the introduction of our annotated photo album that we'll be building
    throughout the remainder of the book, the wireframing and this chapter's planned
    material that was to be covered. I did, however, want to quickly discuss paper
    prototyping, as a closing to the chapter, and to tie it back to the planning of
    our Angular application.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Paper prototyping
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned near the beginning of this chapter, paper prototyping is a process.
    We had also mentioned that the core focus of paper prototyping was on usability
    testing. What we hadn't mentioned was that paper prototyping should be a part
    of the software development methodology that your development team uses—be it
    waterfall, or some form of agile. Specifically, paper prototyping should come
    immediately after the requirements documents are delivered to the project manager.
    That is the high-level view of what paper prototyping is and where it fits in.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the mechanics of the process at the lower level, meaning the
    interaction of the development team with the users of the application that is
    to be developed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics, or process in which paper prototyping is done is to first create
    the wireframes and print them out (I know, more trees will be cut down and global
    warming becomes an even larger threat, but paper prototyping is important). Once
    the paper version is in front of you, your boss, your client, or a group of intended
    users (such as a focus group), you, or whomever else, will *use* the paper prototype
    just like they would by clicking their mouse onto the actual web application as
    if it were already finished and in production. You would ask them to pretend that
    it was the actual finished application. It sounds silly at first but human beings
    have an incredible imagination, and with little effort, they will be using it
    as they would the real thing! This is not hypnosis here but rather something quite
    magical starts to happen. Without your direction, except for at the very beginning
    when you explain what you're requesting of them and why, they will start to ramble
    on, talking out loud about the actions they are taking, or are thinking of taking,
    such as, *Ok, so now I need to fill this out and submit the form*, or *Where is
    the button to undo what I just did. I made a mistake*. The best information you're
    going to get from people going through this exercise is when they offer suggestions
    for how something may be improved, such as *It'd be nice if I can easily navigate
    back to where I...* . Can you imagine coding web pages and then realizing the
    changes being asked to have a far-reaching effect and would be a time-consuming
    change? It happens a lot.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Do you realize what you have by doing this? You have test users and you haven't
    written a single line of code! It is quite a powerful exercise! Try it, and email
    me your story.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: So, when I explain this to a client—not to be the user, but how to present the
    paper prototyping process to their users and/or clients, I'm usually asked, *But
    this is paper. How do we change the screen?* I reply the best way I can—by showing
    them an example. I usually have a sample set of wireframes with me. Not only to
    demonstrate the paper prototyping process but also to just show a good example
    of wireframes. I lay down the login screen on the table we're seated at, and I
    ask them to log in using their finger as the mouse pointer, and then typing on
    their imaginary keyboard. After they chuckle and just play along with me by typing
    their username and password by fake typing on the table under the wireframe, they
    then hit the login button, and I become the computer—I pick up the login wireframe
    and put down the dashboard wireframe. They usually stop chuckling, look at the
    dashboard page, take a few seconds, and then look at me nodding and say, *This
    is cool. I get it*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was packed with a wide array of topics, I know. It was inevitable
    because there is no one best starting point for all the readers. For instance,
    some readers know what wireframes are and have used them for years, while other
    readers may have only just heard of the term, or maybe not even that. This is
    the third edition of this book, but it is quite a bit different from the first
    two editions and even if it was largely the same, which it isn't, it doesn't mean
    that readers have already gone through the first two editions. You can think of
    this first chapter as a type of funnel—a wide enough funnel that brings readers
    of all levels of experience, and differing knowledge, into a common track for
    learning Angular, and the other symbiotic technologies that are covered in this
    book. Starting with [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml), *ECMAScript
    and TypeScript Crash Course*, the funnel approach is over. The rest of the chapters
    will be a lot more focused on the subject matter at hand. So, thank you for hanging
    in there with me. Still, I hope that there were a few things that made wading
    through this first couple of dozen pages worthwhile, even if you're not completely
    new to Angular.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: In review, we covered the evolution of Angular, including its semantic versioning
    and release schedule. Although the installation of NodeJS, npm, and the CLI are
    covered in Appendix A, this chapter is what guided that discussion, and we then
    used the CLI to build our first Angular app and a to-do list app together. We'll
    name the app to-do list because we're developers and not marketers (wink). We
    also covered how to use StackBlitz for building the same Angular application without
    having any reliance on our local development environment. We then covered the
    first very basic building blocks of Angular that you need to know well since they
    will be used again and again for any Angular apps you build. Namely, these were
    templating, property binding, event binding, and class binding. Lastly, we introduced
    the annotated photo album application that we'll be building together throughout
    this book and covered UX design principles, wireframing, and paper prototyping
    along the way. Whew! Mama mia!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will first understand the relationship between JavaScript
    and TypeScript. We will the as then, as the name suggests, do a crash course on
    TypeScript and it's advantages over JavaScript.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
