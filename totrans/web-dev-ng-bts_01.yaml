- en: Quick Start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are you ready to work your way to Angular mastery? My guess is that you are,
    and with this book and your determination, you will. You purchased this book,
    and I not only thank you, but I want to make a promise to you right here, right
    now. Two promises, in fact. The first one is that if you diligently read the material,
    apply the knowledge you'll gain along the way, and build the example application
    with me throughout these pages, you will be well on your way to Angular mastery.
  prefs: []
  type: TYPE_NORMAL
- en: If you're anything like me, you have a library packed with literally hundreds
    of technical books and you have read most of them. Some books start off at an
    excruciatingly slow pace, entrenched in theory and historical minutia, while other
    books start off so quickly, they leave the readers scratching their heads wondering
    if they are too dumb to understand the material. The truth is, striking a balance
    while introducing readers to potentially brand new material—and not have them
    nod off as they read their newly acquired 400+ page technical book—is a tricky
    thing to pull off. So, my esteemed budding Angular guru, that is what my second
    promise is to you. I promise to do my utmost in finding that all-elusive happy
    medium between being technically heavy-handed, and being real-world practical
    while making this book as entertaining a read as I possibly can for you.
  prefs: []
  type: TYPE_NORMAL
- en: With the promises well stated, let's start our journey to Angular mastery together
    by taking a quick look at what we're going to cover in this brisk, but all important
    first chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We'll set up your development environment in a jiffy, and we'll build our first
    Angular application in order to get some immediate feeling of accomplishment.
    We're going to skim over the details as we write it, but right after that, we'll
    cover a few critical Angular basics in more detail before concluding this chapter.
    These first few basics are the very first things you should get comfortable with
    because we'll use them over and over again throughout the book as we learn about
    the more advanced stuff.
  prefs: []
  type: TYPE_NORMAL
- en: After we cover these basics, we'll switch gears from Angular speak and we'll
    take a look at the fully fledged application that we'll be building together throughout
    the remainder of the book. As a bonus (and there are a few bonuses in this book
    that I hope will bring you a bunch of value), we're also going to touch on design
    principles, wireframing, and a little used design strategy called paper prototyping—whose
    focus is on usability testing. Paper prototyping has been around since approximately
    1985 and has largely been replaced by Lean UX design since approximately 2008\.
    Still, I'm always amazed at how many of my clients have never even heard of paper
    prototyping—but I'm also happy when they discover the value it brings to them
    when they try it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover paper prototyping at a high level at the end of this chapter,
    immediately following the wireframes section, which is the most logical place
    for discussing paper prototyping. We''ll touch on a few UX design principles as
    well, but not on the Lean UX process itself since that would take us too far off
    course from our focus of this book. However, if you have an interest in the Lean
    UX design process, here is a good starting point: [https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux](https://www.interaction-design.org/literature/article/a-simple-introduction-to-lean-ux).'
  prefs: []
  type: TYPE_NORMAL
- en: OK, my esteemed budding Angular guru, are you primed and ready to get started?
    Good! Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will be covering in the chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Angular's evolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular's building blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first Angular application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our sample project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of paper prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular's evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is a frontend JavaScript-based web application framework that provides
    you with everything you need, including the kitchen sink, with which to build
    amazingly powerful **Single Page Applications** (**SPAs**). The application we'll
    be building together is an SPA, and we'll be discussing SPA strategies along the
    way.
  prefs: []
  type: TYPE_NORMAL
- en: While Angular wasn't the first JavaScript-based frontend web application framework,
    it was quite possibly the most powerful one of them. This is likely due to Angular's
    SPA-centric focus—since there's more to building an SPA application than there
    is to simply provide two-way data binding on your web pages.
  prefs: []
  type: TYPE_NORMAL
- en: The initial release of Angular was in late fall of 2010\. Since then, dozens
    of competing libraries and frameworks have come on the scene, including some that
    also have large adoptions and large production implementations, such as Ember.js,
    Backbone.js, and React.js. Angular, despite having perhaps the highest learning
    curve (and we'll see why this is the case), remains the most powerful one of them
    all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular naming and versioning jungle can, at first glance, seem confusing.
    There are a few reasons for this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular''s 1.x releases**: Basically, any release prior to Angular 2 is commonly
    referred to as AngularJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS is no more actively in development mode. It has been put under long
    term support mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular framework is being actively developed, and so developers need to be
    specific about which of the two Angular frameworks they are referring to when
    discussing them. Fortunately, there are two completely dedicated websites for
    them: [https://angularjs.org/](https://angularjs.org/) and [https://angular.io](https://angular.io),
    respectively. The Angular team adopted semantic versioning, starting with the
    2.0.0 release. You can read more about semantic versioning here: [https://semver.org](https://semver.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular 2 was a complete rewrite of Angular 1.x (that is, AngularJS), and is
    thus not backward compatible with AngularJS. While Angular 4 was not a complete
    rewrite of Angular 2, it did have some changes in its core libraries that required
    the team to increment its major number from 2 to 4\. Version 3 was skipped as
    a release number altogether.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All releases from Angular 2 onward are commonly referred to as Angular 2+, or
    simply just as Angular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Due to having adopted semantic versioning, the Angular team never released Angular
    3 and so went straight from Angular 2 to Angular 4\. Specifically, there was a
    misalignment of the router package's version, which was already distributed as
    version 3.3.0\. We'll cover routing in Angular in great detail in [Chapter 4](66c21daa-b131-470d-a21b-0fbed56c3ec9.xhtml),
    *Routing*. Don't let this confuse you. Just know that there wasn't ever an Angular
    3\. No big deal. In the Windows OS world, there was never a Windows 9 either.
    These things happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After reading the preceding list, you can see why there tends to be some confusion
    around Angular. However, it''s pretty straightforward if you keep these two things
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: You should really only be using Angular, and not AngularJS (unless you have
    an exceptionally good reason for it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the exception of there not being an Angular 3, there will be two major
    releases per year; they should be contiguous in numbering scheme (that is, 8,
    9, and so on), and they are expected to be backward compatible—at least within
    the same major version number (as per the spirit of semantic versioning)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check out the official Angular release schedule here: [https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md](https://github.com/angular/angular/blob/master/docs/RELEASE_SCHEDULE.md). Since
    Angular is a complete rewrite of the AngularJS platform, and this is worlds apart
    from AngularJS, we''ll skip AngularJS altogether and start by taking a look at
    Components which are Angular''s building blocks. Are you with me? Great, let''s
    speedily move ahead.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular's building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding new features is the business of publishing new frameworks—but luckily,
    the fundamental underlying architecture does not change very often. When it does,
    it's not typically a complete overhaul. With the exception of Angular 2.0, which
    was completely divergent from its predecessor, all major releases so far contain
    largely the same architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the core architectural pieces of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are like widgets that are in charge of displaying themselves along
    with the data they consume and/or manipulate on areas of your screen called views.
    An Angular application is like a tree of components, and Angular provides mechanisms
    for components to communicate with each other in a bidirectional manner—parent
    to child and child to parent.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components rely on their templates for rendering their data. Templates are where
    you define what the component looks like and you can hook in styles to window-dress
    your component any way you like. A component can either contain its template (that
    is, the HTML) and its styling (that is, the CSS) either directly within itself
    or have references to template and style files outside of itself. At the end of
    the day, the world's fanciest frontend frameworks produce HTML, CSS, and JavaScript
    because these three things are the only things browsers understand.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the templates you create for your component, Angular enables you to alter
    the DOM with powerful constructs called directives. There are directives for controlling
    the way things are rendered on the screen (that is, the component view) such as
    repeating snippets of HTML, for displaying things based on conditional logic,
    for hiding or showing things, filtering arrays of data, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is modular. That is to say that its functionality is wrapped up in modules,
    known as NgModules, and are themselves libraries. Modules are perfect for lumping
    code together in an organized way. For instance, there are modules for helping
    with forms, routing, and communicating with RESTful APIs. Many third-party libraries
    are packaged as NgModules so you can incorporate them into your Angular applications.
    Two examples of this are Material Design and AngularFire—we'll be taking a look
    at both of these libraries in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services are not really an Angular artifact per se, but rather a very general
    notion representing encompassed functionality, functions, and features that your
    application's components may need to consume. Things such as logging, data retrieval,
    or virtually any calculation or lookup service, can be written as services—these
    services can reside within your application, or live externally from it. You can
    think of a service as a highly specialized class that provides some *service* (such
    as looking up the distance between two zip codes) and does it well. Just as with
    components, not only are there tons of third-party services you can use in your
    Angular applications, but you can create your own custom services. We'll learn
    how to do this in [Chapter 12](9610f27b-03db-4258-8a68-24eb3901117b.xhtml), *Integrating
    Backend Data Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dependency injection**(**DI**), or **Inversion of Control** (**IoC**), is
    a very useful and common software design pattern. This pattern is used to *inject*
    objects into the objects that depend on them. The object you''re using that depends
    on other objects can just go ahead and use it without needing to worry where it
    is in order to load it, or how to instantiate it—you just use it as if it just
    sprung into existence at the time you needed it. Services are perfect for injecting
    into our application. We''ll learn how to use DI in Angular, and how we can use
    the Angular **command-line interface** (**CLI **) to generate injectable services
    of our own design.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just before we move on to setting up our development environment, here are
    some interesting things about Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS was built using JavaScript, while Angular was built using TypeScript.
    While this adds a level of abstraction when writing Angular applications, using
    TypeScript provides a few important advantages when building larger apps with
    larger teams—we'll get to those shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AngularJS was based on controllers, whereas Angular is component based. You'll
    learn all you need to know about components in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml),
    **Building Angular Components.**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SPAs are notorious for being difficult for implementing **Search Engine Optimization**
    (**SEO **), but Angular is SEO friendly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's possible to build native mobile applications with Angular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's also possible to build cross-platform, desktop-installed applications with
    Angular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular can also run on the server, using Angular Universal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to admit, this is a pretty impressive and exciting list. These things
    and more make learning Angular a worthwhile endeavor and the marketplace is asking
    for Angular know-how.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get started with Angular, you're going to need to have the **Angular
    CLI** installed; to install that, you first need to have Node.js and **npm** (**node
    package manager**) installed. If you've already got Node.js and npm installed,
    great! If not, don't worry—they are easy to install and I will take you through
    the installation process in Appendix A, *Toolchain for Web Development with Angular*,
    near the back of the book. In Appendix A, I also take you through installing the
    Angular CLI and how to use it for building Angular applications. For brevity,
    I'll refer to the Angular CLI tool as just the CLI from this point forward.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure whether you have NodeJS and npm installed, you can check really
    quickly by typing `$ node -v` and `$ npm -v`, respectively, on your command line.
    Similarly, you can type `$ ng -v` on the command line to see whether you have
    CLI installed. If you get a version number back, you have that particular tool
    installed (as shown in the following screenshot I took).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Do not type `$` at the beginning of the commands. The `$` signifies
    the command prompt, entry point for the commands you''ll type. Unix-based operating
    systems, such as macOS and Linux systems, commonly use `$` or `%` as their command
    prompt—depending on the shell being used, or if there are any custom settings
    specified in a configuration file on your system. Windows operating systems typically
    use the greater than sign, `>`, as their command prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2d1515f5-ddb3-4f8b-a4bd-f47283a42a15.png)'
  prefs: []
  type: TYPE_IMG
- en: If any of these commands go unrecognized, jump on over to Appendix A real quick,
    install the tools, and jump right back here. I'll be waiting for you.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need a code editor. There are many code editors available today,
    including a number of free ones. Though any code editor will suffice, I would
    suggest you use Visual Studio Code for your Angular development—at least while
    working through this book. The reason for this is that Visual Studio Code is free,
    it's cross-platform, and is an excellent code editor. It's also the code editor
    that I've used while writing this book and so when I suggest the use of an extension,
    you can easily install the same one.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding is all you need for this first chapter. When we start building
    the example project, which requires us to have a local database, you'll also need
    to install MongoDB. MongoDB, also known as Mongo, is a great NoSQL database that
    is also free and cross-platform. I take you through Mongo's installation process
    in Appendix B, *MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there will be other software that you'll need to install, such
    as Chrome extensions, and I will let you know what they are and where to find
    them at the appropriate time. For now, let's get started with writing some Angular
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to experimenting with Angular code, as you pick up this awesomely
    powerful framework, you generally have two choices of how to proceed. The first
    is to use an online code editor such as JSFiddle, Plunker, StackBlitz, or more.
    In Appendix C, *Working with StackBlitz*, you'll learn about the basics of using
    StackBlitz so you can use it from time to time to test some quick code without
    needing a test project in your development environment. You can visit the StackBlitz
    website here: [https://stackblitz.com](https://stackblitz.com).
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is to use your own local development environment—and since
    we've already set it up in the previous section, you can create a project whose
    sole purpose is to run some quick example code if you'd rather use that than an
    online code editor. My goal is to show you that you have options—there's not just
    one way to experiment with some code as you learn Angular.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an online code editor, such as StackBlitz, the only software you
    need installed is a browser—no other tools whatsoever. While this makes things
    very easy, the trade-off is that you are extremely restricted in what you can
    do. That being said, I encourage you to experiment with an online code editor,
    but we'll only be using our development environments throughout this book. So,
    let's do that and create a small application together in just a few minutes time—we'll
    build a to-do list app.
  prefs: []
  type: TYPE_NORMAL
- en: Using your development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From this point forward, we'll be using our terminals, the CLI, and the Visual
    Studio Code. Head on over to [https://code.visualstudio.com](https://code.visualstudio.com),
    where you'll be able to download the Visual Studio Code installation package for
    your operating system of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Location of your files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to setting up a local environment, you can, of course, place your
    directories and files wherever you like. If you have a folder where you have your
    web application projects, go to it now. If you don't have a dedicated place for
    projects, this is as good a time as any to get into the habit of being organized.
    For instance, on my machine, I have a folder named `dev` for any and all development
    I do. Within my `dev` folder, I have a folder named `playground`, where I have
    a subfolder for each technology I'm learning, or playing with. I prefer to use
    a Mac when writing code, and so my complete pathname to where I have my Angular
    *play stuff* is `/Users/akii/dev/playground/angular` (as shown at the bottom of
    the screenshot of my terminal, a few pages back). That same screenshot also shows
    the versions of Node.js, npm, and the CLI that I had installed at the time of
    writing. If having a directory structure like this works for you, by all means,
    use it. If you already have a way you organize your work, use that. The important
    thing is to be very disciplined and consistent with how you organize your development
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Generating our to-do list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the installation of what we need now being out of the way—meaning we have
    our CLI tool available to us—go to your terminal and type the following at your
    command prompt `$ ng new to-dolist --style=scss --routing`, and then hit *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: The `ng` command runs the CLI tool, and its `new` command instructs it to create
    a new Angular application. The application, in this case, is named `to-dolist`.
    You'll notice that there also are two command-line flags, which are special options
    for the `new` command. The style flag tells the CLI that we'd like to use `scss`,
    instead of `css`, and the routing flag tells the CLI that we'd like it to integrate
    and set up routing for us by default. We'll be using SASS, as opposed to CSS,
    in this book, and SCSS is the file extension for Sass files. As a reminder, we're
    going to have a crash course on Sass in [Chapter 3](6694dd13-5500-4563-9688-74a21a06a9a9.xhtml), *Bootstrap
    – Grid Layout and Components.*
  prefs: []
  type: TYPE_NORMAL
- en: The first time you use the CLI to create your Angular application, it will take
    anywhere from 45 seconds to well over a minute for it to create your project for
    you. This is because it needs to download and install various things for you before
    it creates the project's folder structure. However, when creating subsequent Angular
    applications, the CLI won't take nearly as long.
  prefs: []
  type: TYPE_NORMAL
- en: Serving up our to do list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the CLI has completed creating the application, you can run it by changing
    to the project directory (`$ cd to-dolist`) and issuing the `$ ng serve` command.
    This will have the CLI run your application. The CLI''s built-in web server will
    be listening on localhost port `4200` by default. By the way, the CLI''s web server
    keeps watch on your project files, and when it notices a change in one of your
    files, it reloads the application—there''s no need for you to stop the server
    and issue the server command again. This is very convenient as you''re making
    lots of changes and tweaks during development. Next, open your browser and visit
    `http://localhost:4200` and you should see something like the following, which
    proves that the CLI is working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f235b2f8-c85e-4dd7-a3e1-9fcc0f7633e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the CLI created the to-do list application for you, open that folder
    in Visual Studio Code (note: for brevity, I''ll be referring to Visual Studio
    Code as the IDE). You should see a folder structure for your to-do list project
    in the left-hand panel of your IDE, similar to the following (except for the to-do
    folder, which you won''t have just yet; we''ll get to how to generate that using
    the CLI in the upcoming subsection on components).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of the to-dolist project in the IDE (with the
    `app.component.ts` file open):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bbd90490-510f-4844-93ab-2d44cbfdcd46.png)'
  prefs: []
  type: TYPE_IMG
- en: When working on your Angular applications, the vast majority of your time will
    be spent working within the `src | app` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Angular basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components are the basic building blocks of Angular. In fact, you can think
    of an Angular web application as a tree of components. When you use the CLI to
    generate the shell for your Angular application, the CLI also autogenerates one
    component for you. The filename is app.component.ts and is in the `src/app` folder.
    The app component is how your Angular application is bootstrapped—meaning that
    it is the first component that is loaded, and all the other components are pulled
    into it. This also means that components can be nested. The previous screenshot
    shows our project directory structure, with the `src/app` folder expanded, and
    the `app.component.ts` open in the IDE's file editor window. The `.ts` file extension
    indicates that it is a TypeScript file. Interesting note—when you write Angular
    applications, you use TypeScript instead of JavaScript. In fact, the Angular team
    used TypeScript to write Angular!
  prefs: []
  type: TYPE_NORMAL
- en: After the following *Components* section, you'll find a complete code listing
    for our Angular application. There are six files that you'll have to edit. Three
    of them are already available in the application that you generated with the CLI.
    The other three will be available in your project once you use the CLI to generate
    the to-do component, which is the directory that you are presently missing when
    you compare your project structure to the previous screenshot. You'll find out
    how to do that in the following *Components* section, which is why the complete
    code listing was inserted afterward. Don't worry—follow along, keep the faith
    that Angular mastery is within your grasp, and you'll be just fine. If you don't
    believe me, just lie down on the floor and mumble these words, *This too, shall
    pass*, three times, slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is a high-level fly-by on Angular components—just enough coverage
    of what an Angular component is. [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components*, is completely dedicated to Angular components and is where
    we're going to take a deep dive into them. Consider this section to be a little
    peek behind the component curtain, and when we get to discussing components, we're
    going to pull the curtains wide open and take a good look at the *Component Wizard
    of Oz*. Remember that in the *Wizard of Oz* story, Dorothy and the gang were petrified
    of the Wizard, but when he was finally revealed behind the curtains, they all
    soon stopped being scared.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned, you can think of components as the basic building blocks
    or Angular, and of your Angular application as a tree of nested components. Buttons,
    progress bars, input fields, entire tables, advanced things such as carousels,
    and even custom video players—these are all components. The components on your
    web page can communicate with each other, and Angular has a couple of rules and
    protocols for how they can go about doing so. By the end of this book, you will
    become very comfortable with the ins and outs of components. You must, for it's
    simply the way of the Angular guru!
  prefs: []
  type: TYPE_NORMAL
- en: When you write a component file, as in the code that follows, there are three
    main sections to it. The first is the import section. The middle section is the
    component decorator, and it's where you indicate what the component's template
    file is (which defines what the component looks like), and what the components
    style file is (which is used to style the component).
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: Since we used the `style=scss` flag, we get our file in SCSS as opposed
    to the traditional CSS type file. The export section is the last section in the
    component file and is where all the logic for the component will be placed. There''s
    a lot more that can go into a component''s TypeScript file than what is shown
    in the following code snippet, as we''ll see in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The CLI created the app component for us by default when it created our application
    for us, but how do we create our own components? The easiest way to generate a
    new component is to use the CLI and issue the following command: `$ ng generate
    component name-of-component`. So, to generate a new component named `to-doitem`,
    we would type `$ ng generate component to-doitem` on our command prompt. Remember
    to do this from within the `src | app` folder. The CLI will generate this component
    and insert it into its own folder, and the name of the newly created folder will
    be the same as the component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this folder, you will see four new files and their names all start with
    `to-doitem.component` because the name of our component is `todoitem`, and, well,
    it''s a component. We''ll discuss what the file ending in `spec.ts` is used for
    later, but you may already have a good guess as to what the other three files
    are for. Let''s verify what you are probably already thinking; the component file
    itself is indeed the one named `todoitem.component.ts`. This file contains a reference
    to two of the others: `todoitem.component.html`, which is the template for the
    component (the HTML code, for defining its markup structure), and the `todoitem.component.scss`
    file, which will hold the styling for the component. Additionally, the CLI modified
    an existing file named `app.module.ts`. We''ll discuss this file in more detail
    later on, but for now, all you need to know is that this file acts as a registry
    for your application''s components.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be thinking, *That's a lot of files. Are they all needed?* The short
    answer to that is no. In  [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), F*lex-Layout
    – Angular's Responsive Layout Engine,* we'll look at how we can eliminate the
    `.html` file, and the `.scss` files, and just put all of our component *stuff* (the
    HTML and the styling) into our component file. However, there is a reason the
    Angular team provided the mechanism to have all these things be separate—so your
    application's code can be tidy and organized. You can thank them later.
  prefs: []
  type: TYPE_NORMAL
- en: A nice shortcut syntax when using the CLI to generate a component is to type
    `$ ng g c name-of-component`, where `g` is short for generating, and `c` is short
    for the component.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to creating our own components from scratch, which we'll look at
    in depth in [Chapter 5](7a55c9e9-7f80-41bc-9678-eb191fdc4c2d.xhtml), F*lex-Layout
    – Angular's Responsive Layout Engine*.
  prefs: []
  type: TYPE_NORMAL
- en: Code listing for the to-do list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the to-do component generated, you have four new files within
    the `todo` folder. You'll edit three of them to look like the following code listings
    that follow. You also need to edit three of the files that were already in your
    project, (where we'll open the curtains to meet the wizard), we can also integrate
    components from other libraries and frameworks into our application. We'll take
    a look at how to do this with NG Bootstrap in [Chapter 6](acd5e47c-07a7-4954-993d-360134221325.xhtml), *Building
    Angular Components*, and with Angular Material in [Chapter 7](cd8509d5-4bce-4056-8156-557186df18cd.xhtml),
    *Templates, Directives, and Pipes*. There's no shortage of components for Angular,
    and the amount available for your use will only grow over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I learn new technology and follow along with a book, blog post, or
    whatever else, I enter everything in by hand—even when the files are available
    for download. Yes, manual entry can be a tedious process, but it engages your
    brain, and the material and concepts start to get absorbed. Simply downloading
    the files and cutting and pasting the contents into your application does not
    have the same effect. I''ll let you decide which way you want to go. If you opt
    for downloading the code, there are instructions at the beginning of this book
    for doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code listing for `todo.component.html` (within the `src | app | todo` folder)
    is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The code listing for `todo.component.ts` (within the `src | app | todo` folder)
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code listing for `todo.component.scss` (within the `src | app | todo` folder)
    is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code listing for `app.component.html` (within the `src
    | app` folder). [Chapter 1](f1243d74-a120-408f-8181-cb379b457dd1.xhtml), *Quick
    Start* : to-do List (quick example app):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The code listing for `app.module.ts` (within the `src | app` folder) is as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code listing for `styles.scss` (within the `src` folder) is shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cool! So, now you have all the code in place. Do you remember how to run your
    Angular application? Enter `$ ng serve` at your command prompt, and once the message
    comes up that the compilation was successful, open your browser and go to `http://localhost:4200`.
    Does the application work? If so, congratulations on building your first Angular
    application! If not, check for typos.
  prefs: []
  type: TYPE_NORMAL
- en: Play around with your new application. We haven't bothered to take the time
    to add functionality to edit the to-do item, or to delete them, but you can clear
    it out by just reloading the application by hitting your browser's refresh button.
  prefs: []
  type: TYPE_NORMAL
- en: Why do things get cleared out upon refreshing the page? This happens because
    we have an SPA and are not persisting the data that we enter into a database.
    We'll definitely be sure to add the ability to persist our data when we build
    our much larger application, which will be introduced to you by the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interpolation is how you get a value from a variable within your component class
    to render in the component's template. If you recall, the logic for the component
    goes in the export section of the component class. That is the same place where
    variables are that you would like to use interpolation to have their values rendered
    in the template (that is, rendered on the web page). Let's assume that you have
    a variable called `items` and that its value is currently `4`. To render the value
    in the template, you use a pair of double curly braces with the variable in between
    them. The variables and component logic are written inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry—we'll see lots of code snippets throughout the book that use interpolation,
    but for now, you can see this sample code that shows it in action. The code is
    meaningless and hardcoded for now, but it does demonstrate interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first screenshot is of the component file (`home.component.ts`); the variable
    is declared on line 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30572145-f1fc-41da-bb99-4aeefaf4a75e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This second screenshot is of the component''s template file (`home.component.html`).
    Notice the pair of double curly braces on line 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/76e0188f-b097-4146-8680-c70da6505d7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This last screenshot shows the rendered value, `4` in this case. That''s the
    basics of interpolation. We''ll see much more advanced usage of it throughout
    the book as we work on our annotated photo album:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3684dbe0-0840-4063-9527-d2a2f7646344.png)'
  prefs: []
  type: TYPE_IMG
- en: Templating and styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already mentioned something about templating and styling in the last
    few paragraphs of the *Components* section. Now that we have a small project available
    to us—the one that we created with the CLI—we can see what this looks like in
    code. Open your Angular project in the IDE, and open the `app.component.ts` file.
    Lines 5 and 6 in this app component file contain the references to its associated
    template (the `.html` file), and its style file (`.scss`), respectively. The following
    is a screenshot of the open project in my IDE, with the `app.component.ts` file
    open:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e12b6c78-e46f-443e-9ffc-baf3919b0333.png)'
  prefs: []
  type: TYPE_IMG
- en: Property binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of data binding we can do in Angular, namely, one-way and
    two-way. Interpolation is very similar to one-way data binding. This is because,
    in both cases, data flows from the component class to the component template and
    not the other way around. Property binding is data binding in the sense that the
    data is being bound to a property.
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to have two-way property binding—meaning, not only can the
    value of a component property be bound to the template, but the template can alter
    the value of a component property. This is made possible in Angular by `ngModel`.
    Again, don't worry about this for now. We will take a look at two-way property
    binding later on. Just know that both one-way and two-way property binding is
    possible in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing one-way property binding is very straightforward. All you need
    to do is to put square brackets around the HTML property (in the component's template)
    you want the data bound to, and assign the variable to it. To see a quick example
    of what one-way property binding looks like in code, take a look at the next three
    screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first screenshot is of the component file (`home.component.ts`); the variable,
    `txtPlaceholder`, is declared on line 11:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31cdb8a5-ea56-47b0-9f2b-31262d708db0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This next screenshot is of the component''s template file (`home.component.html`).
    In line 14, you can see the square brackets around the placeholder property of
    the input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a85ab11c-81f6-48a4-ae43-e5143ea231b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This last screenshot is of the application running in the browser. You can
    see the text, Enter your todo item here, inserted as the placeholder text for
    the textbox via one-way property binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cd5ce0ef-f94c-491c-bea0-ed5154c3108d.png)'
  prefs: []
  type: TYPE_IMG
- en: Event binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Angular, event binding simply means that an event will be registered on an
    element within a component, and when that event happens, it will trigger a function
    to be called. In other words, an event will call a function. There are a ton of
    events that you can have Angular listen for—such as a button being clicked, a
    mouse hovering over an image, or when the user presses a key down when the cursor
    is in a textbox, and lots more. And, of course, you can write any function you
    can possibly think of to make other stuff happen, such as calling a web service,
    changing the color of the background page, calculating the value of Pi to 1,000
    decimal places, or virtually anything else your heart desires. But how can we
    set up event binding in our Angular application to tie the event we're interested
    in, on the element we're interested in, to run the function we want? Well, thankfully,
    the Angular team made this super easy for us.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we'd like to have some user interaction via events such as click or
    mouseover—we can use event binding to map the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that example is not very interesting, but we do have our to-do list application
    to look at the code we've already written. If you've typed in the code listings.
  prefs: []
  type: TYPE_NORMAL
- en: Our sample project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning a new programming language, or learning a new framework, is a matter
    of hands-on experimentation and repetition. Even Dr. Sheldon Cooper from *The
    Big Bang Theory* can't learn Angular just by reading a book on it. However, just
    following along with random code examples isn't much fun to do and, at the end
    of the day, you don't really have anything you can use. So, the approach we'll
    take on our journey to Angular mastery is to build a fully fledged web application
    that is fun to build and practical since you can deploy it and use it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Annotated photo album
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application that we'll be building together is based on one of the online
    services I've launched called Vizcaro. Vizcaro is a photo sharing service, but
    instead of sharing individual photos, you share albums (groups of photos). Also,
    the photos and albums will be annotated so you can add titles and captions to
    them. Our version won't have all the bells and whistles that my online service
    offers, but it will have just enough parts to make it a great web application
    to build in order to learn the material in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are generally two types of design: the way in which you design your user
    interface (the GUI), and the way in which you design the software components (API
    interfaces, services, components, and more). Throughout this book, we''ll be covering
    quite a few design principles for the code. Angular is a spectacularly well-designed
    piece of software, and this is great for us because it provides a perfect opportunity
    to discuss software design as we learn Angular itself, in addition to when building
    our application. We''ll also be covering user interface design principles in general
    as we build our application throughout the remainder of this book, but particularly
    when we build out our templates using our wireframes to help guide us.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, the term UX design is used when discussing user interface design.
    Borrowing a definition of UX design from *Wikipedia:*
  prefs: []
  type: TYPE_NORMAL
- en: '*"UX design is the process of enhancing user satisfaction with a product by
    improving the usability, accessibility, and pleasure provided in the interaction
    with the pr*o*duct."*'
  prefs: []
  type: TYPE_NORMAL
- en: This is a good definition and applies to more than just software products.
  prefs: []
  type: TYPE_NORMAL
- en: Wireframes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wireframes have been around since the early '80s. Their focus, at least initially,
    was on what the screen in the desktop application did (remember, web applications
    were not around yet), and for its general layout. They were not meant to be used
    as what the final design was to look like—including font selection, colors, and
    other properties of the controls on the screen. In essence, they were the *prototype
    on paper*. *Paper prototyping*, conversely, is a process that uses the wireframes.
    It's worth noting that the nouns *wireframes* and *mockups* are used interchangeably—they
    are the same thing. I'll briefly cover the paper prototyping process at the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Wireframing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably have already guessed, or already know, there are several tools
    available for creating wireframes when laying out your application, such as Balsamiq
    Mockups, Mockflow, and Visio. For my web applications, and in this book, my preference
    is to use Balsamiq Mockups. Which one you end up using for your applications,
    or are already using, doesn't matter. In fact, even if your wireframes are drawn
    by hand using a pen on the back of your napkin from your favorite fast food restaurant,
    it would be cool with me. Seriously, the important thing is that you get into
    the habit of creating wireframes before writing a single line of code. Why? Because
    it's a smart thing to do, and it saves you a lot of time. Additionally, it gives
    you the perfect opportunity to really think about what you're going to be building.
    And, it's something that you can present to users in order to get their feedback
    on the usability without writing a single line of code. There are even more benefits;
    it gives you some idea on how you would design your data model for the application,
    as well as APIs for services it may consume. Would you start a business without
    a business plan? Would you build your dream home without a blueprint? Building
    a web application shouldn't be any different specification out the pages using
    wireframes. Always. Capiche?
  prefs: []
  type: TYPE_NORMAL
- en: Wireframes for our annotated photo album
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are 10 wireframes that we'll be using for building our application—one
    for each screen it will have. The following is the listing of them, and a short
    description precedes each screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every web application needs a starting page of some kind. It''s known by many
    names, typically one of these: home page, landing page, index page, or splash
    page. Ours will be straightforward. No Flash animation or rainbow-colored backgrounds;
    it will be a simple page that lets the user know what the site does, and hopefully,
    it does that within five to seven seconds. If it doesn''t, you may lose the visitor
    forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea890012-567d-4c92-818c-c96051c6c623.png)'
  prefs: []
  type: TYPE_IMG
- en: Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most web applications don't have a dashboard page, but those that do typically
    provide a summary of *things* the user has, the last time they had logged in,
    and any notifications that the company would like to bring to the user's attention.
    If you use online banking, chances are that your bank's online banking web application
    has a dashboard page—and it probably is a list of accounts (checking, savings,
    credit cards, car loans, and more), and the balances on those accounts that you
    have with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to build an application that users will implement to create photo
    albums, and so our dashboard will contain the number of photos we have uploaded,
    the number of photo albums, the last time we logged in, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d581b2ce-f2d4-4777-b599-b1bef1e654be.png)'
  prefs: []
  type: TYPE_IMG
- en: Image upload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our application is supposed to enable our users to create photo albums,
    we''d better have a way for them to upload their photos! Yes—we are dedicating
    an entire web page to upload one photo at a time because we will use this same
    page to preview it after it has been uploaded—and to *undo* the upload. You''d
    be surprised to know that there is a well-known photo sharing site that does not
    show what you have just uploaded until you go to the listing of your photos! Having
    an immediate confirmation that the photo you intended to upload is, in fact, the
    one that was uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7449aa18-12f6-493f-9e4c-1ac9c154bdc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Uploading a photo is the first step in our annotated photo album application.
    We are devoting another web page to *preparation* the photo. This is where we
    will allow the user to resize the image and annotate it (give it a name and a
    caption). The photo''s caption will be shown when viewing it in the photo album:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5fe4f4c7-bf33-4eb4-b79d-44f984d291c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Create Album
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the user can add photos in their photo albums, they have to be able
    to create the albums. This is what the following web page will be used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e37499af-b3ba-4e09-a05e-7e5d0843cf35.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You always need to think of usability and how to design the most intuitive
    user interface you possibly can. This page will show a listing of all the photos
    that the user has uploaded. Additionally, they can edit the name and caption for
    any of the photos right on this same page. The less jumping around from page to
    page that your users need to do, the happier they''ll be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59af18c7-4b71-4aaa-b476-45bc36327cbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo album listing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This page does for photo albums what the previous page did for photos—provides
    a listing of all the albums the user created and has an intuitive way to edit
    their name and description (as opposed to the caption for photos) without going
    to another web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/46ec35d7-1d44-4526-a14b-e039003346c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Workbench
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The workbench is the place where the user will be able to drag a photo onto
    a photo album. This will be our way of allowing the user to intuitively associate
    a specific photo to a specific album. By the way, not only will our drag and drop
    feature be intuitive and functional, it will add an element of fun for the user.
    Psychologically, users want to *play* on the site. Dragging and dropping—though
    not a mind-blowing experience—is more fun to do than it would be to select a photo
    from a photo dropdown, then select an album from an album dropdown, and, finally,
    click a *connect* or *associate* button. The former method would please the user,
    and the latter would make them send you a nastygram—then leave the site, never
    to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/16597a79-4baf-40ae-8f85-07d830b16ad7.png)'
  prefs: []
  type: TYPE_IMG
- en: Album viewer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the end of the day, the users want to see their photo albums in an engaging
    way. The drag and drop stuff was fun but they''re not here for that. They''re
    here to see photos from their son''s birthday party, their daughter''s high school
    graduation, or pictures of their dream home. This is an important page for them;
    it''s where their work of using our site will pay off for them. Let''s not disappoint
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7aa7fb53-ab7c-4a21-8aa1-294ba62bfa96.png)'
  prefs: []
  type: TYPE_IMG
- en: This concludes the introduction of our annotated photo album that we'll be building
    throughout the remainder of the book, the wireframing and this chapter's planned
    material that was to be covered. I did, however, want to quickly discuss paper
    prototyping, as a closing to the chapter, and to tie it back to the planning of
    our Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: Paper prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned near the beginning of this chapter, paper prototyping is a process.
    We had also mentioned that the core focus of paper prototyping was on usability
    testing. What we hadn't mentioned was that paper prototyping should be a part
    of the software development methodology that your development team uses—be it
    waterfall, or some form of agile. Specifically, paper prototyping should come
    immediately after the requirements documents are delivered to the project manager.
    That is the high-level view of what paper prototyping is and where it fits in.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at the mechanics of the process at the lower level, meaning the
    interaction of the development team with the users of the application that is
    to be developed.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanics, or process in which paper prototyping is done is to first create
    the wireframes and print them out (I know, more trees will be cut down and global
    warming becomes an even larger threat, but paper prototyping is important). Once
    the paper version is in front of you, your boss, your client, or a group of intended
    users (such as a focus group), you, or whomever else, will *use* the paper prototype
    just like they would by clicking their mouse onto the actual web application as
    if it were already finished and in production. You would ask them to pretend that
    it was the actual finished application. It sounds silly at first but human beings
    have an incredible imagination, and with little effort, they will be using it
    as they would the real thing! This is not hypnosis here but rather something quite
    magical starts to happen. Without your direction, except for at the very beginning
    when you explain what you're requesting of them and why, they will start to ramble
    on, talking out loud about the actions they are taking, or are thinking of taking,
    such as, *Ok, so now I need to fill this out and submit the form*, or *Where is
    the button to undo what I just did. I made a mistake*. The best information you're
    going to get from people going through this exercise is when they offer suggestions
    for how something may be improved, such as *It'd be nice if I can easily navigate
    back to where I...* . Can you imagine coding web pages and then realizing the
    changes being asked to have a far-reaching effect and would be a time-consuming
    change? It happens a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Do you realize what you have by doing this? You have test users and you haven't
    written a single line of code! It is quite a powerful exercise! Try it, and email
    me your story.
  prefs: []
  type: TYPE_NORMAL
- en: So, when I explain this to a client—not to be the user, but how to present the
    paper prototyping process to their users and/or clients, I'm usually asked, *But
    this is paper. How do we change the screen?* I reply the best way I can—by showing
    them an example. I usually have a sample set of wireframes with me. Not only to
    demonstrate the paper prototyping process but also to just show a good example
    of wireframes. I lay down the login screen on the table we're seated at, and I
    ask them to log in using their finger as the mouse pointer, and then typing on
    their imaginary keyboard. After they chuckle and just play along with me by typing
    their username and password by fake typing on the table under the wireframe, they
    then hit the login button, and I become the computer—I pick up the login wireframe
    and put down the dashboard wireframe. They usually stop chuckling, look at the
    dashboard page, take a few seconds, and then look at me nodding and say, *This
    is cool. I get it*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was packed with a wide array of topics, I know. It was inevitable
    because there is no one best starting point for all the readers. For instance,
    some readers know what wireframes are and have used them for years, while other
    readers may have only just heard of the term, or maybe not even that. This is
    the third edition of this book, but it is quite a bit different from the first
    two editions and even if it was largely the same, which it isn't, it doesn't mean
    that readers have already gone through the first two editions. You can think of
    this first chapter as a type of funnel—a wide enough funnel that brings readers
    of all levels of experience, and differing knowledge, into a common track for
    learning Angular, and the other symbiotic technologies that are covered in this
    book. Starting with [Chapter 2](82376b53-6401-4844-9440-7ba76a2fb6a2.xhtml), *ECMAScript
    and TypeScript Crash Course*, the funnel approach is over. The rest of the chapters
    will be a lot more focused on the subject matter at hand. So, thank you for hanging
    in there with me. Still, I hope that there were a few things that made wading
    through this first couple of dozen pages worthwhile, even if you're not completely
    new to Angular.
  prefs: []
  type: TYPE_NORMAL
- en: In review, we covered the evolution of Angular, including its semantic versioning
    and release schedule. Although the installation of NodeJS, npm, and the CLI are
    covered in Appendix A, this chapter is what guided that discussion, and we then
    used the CLI to build our first Angular app and a to-do list app together. We'll
    name the app to-do list because we're developers and not marketers (wink). We
    also covered how to use StackBlitz for building the same Angular application without
    having any reliance on our local development environment. We then covered the
    first very basic building blocks of Angular that you need to know well since they
    will be used again and again for any Angular apps you build. Namely, these were
    templating, property binding, event binding, and class binding. Lastly, we introduced
    the annotated photo album application that we'll be building together throughout
    this book and covered UX design principles, wireframing, and paper prototyping
    along the way. Whew! Mama mia!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will first understand the relationship between JavaScript
    and TypeScript. We will the as then, as the name suggests, do a crash course on
    TypeScript and it's advantages over JavaScript.
  prefs: []
  type: TYPE_NORMAL
