- en: Chapter 2. Object-Oriented Approach and Design in Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using classes for data encapsulation and abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using polymorphism to reuse code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using copy constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using operator overloading to reuse operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using function overloading to reuse functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using files for input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first simple text-based game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates – when to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following diagram shows the main concepts of **OOP** (**Object-oriented
    programming**). Let us consider that we need to make a car racing game. So, a
    car is made up of an engine, wheels, chassis, and so on. All these parts can be
    considered as individual components, which can be used for other cars as well.
    Similarly, every car's engine can be different and so we can add different functionalities,
    states, and properties to each individual component.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this can be achieved through object-oriented programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B04929_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We need to use an object-oriented system in any design that consists of states
    and behaviors. Let us consider a game like *Space Invaders*. The game consists
    of two main characters, the player ship and the enemy. There is also a boss, but
    that is just an advanced version of the enemy. The player ship can have different
    states such as alive, idle, moving, attack, and dead. It also has a few behaviors,
    such as left/right movement, single shoot/burst shoot/missile. Similarly, the
    enemy has states and behaviors. This is an ideal condition to use an object-oriented
    design. The boss is just an advanced form of the enemy, so we can use the concepts
    of polymorphism and inheritance to achieve the result.
  prefs: []
  type: TYPE_NORMAL
- en: Using classes for data encapsulation and abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is used to organize information into meaningful states and behaviors.
    In games, we deal with so many different types of weapon, player, enemy, and terrain,
    each with its own type of state and behavior, so an object-oriented design with
    classes is a must.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You need
    to have a working copy of Visual Studio installed on your Windows machine. No
    other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to create a game framework using
    object-oriented programming in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp`, `CEnemy.h`, and `CEnemy.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Souce.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `CEnemy.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `CEnemy.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create an object-oriented program, we need to create classes and objects.
    Although we can write the definition and declaration of a class in the same file,
    it is advisable to have two separate files for definition and declaration. A declaration
    class file is called a header file, whereas a definition class file is called
    a source file.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CEnemy` header file, we define the member variables and the functions
    that we need. In a class, we have the option to separate out the variables as
    public, protected, or private. A public state indicates that they are accessible
    from outside the class, a protected state indicates that only the child class
    that inherits from the current base class has access to it, whereas a private
    state indicates that they are accessible by any instance of the class. By default,
    everything in a C++ class is private. Hence, we have created all the member functions
    as public so that we can access them from the driver program, which in this example
    is `Source.cpp`. The member variables in the header file are all private, as they
    should not be directly accessible from outside the class. This is what we call
    abstraction. We define a string type variable for name and armor, and an integer
    type for health and age. It is also advisable to create a constructor and destructor,
    even if we do not have any functionality for them at present. It is also good
    to use a copy constructor. The reason for this is explained later on in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CEnemy` source file, we have the initialization of the member variables
    and also the declarations of the functions. We have used the `const` keyword at
    the end of each function because we do not want the function to change the contents
    of the member variables. We just want them to return the values that are already
    assigned. As a rule of thumb, we should always use it unless it's necessary not
    to use it. It makes the code more secure, organized, and readable. We have initialized
    the variables in the constructor; we could have also created parameterized constructors
    and assigned values to them from the driver program. Alternatively, we can also
    have set functions to assign values.
  prefs: []
  type: TYPE_NORMAL
- en: From the driver program, we create a pointer object of the type `CEnemy`. When
    the object is initialized, it calls its appropriate constructors and the values
    are assigned to them. Then we call the functions by dereferencing the pointer
    using the `->` operator. So when we call the `p->` function, it is the same as
    (`*p`).function. As we are dynamically allocating memory, we should also delete
    the object or else we will get a memory leak. We have used `vld` to check for
    memory leaks. This program does not have any, as we have used the `delete` keyword.
    Just comment out the line `delete pEnemy;` and you will notice that the program
    has few memory leaks on exiting.
  prefs: []
  type: TYPE_NORMAL
- en: Using polymorphism to reuse code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism means having several forms. Typically, we use polymorphism when
    there is a hierarchy of classes and they are related in some way. We generally
    achieve this level of relation by using inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how we can use the same function and override it
    with different functionalities based on our needs. Also, we will see how we can
    share values across base and derived classes:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called Source.cpp and three header files called `Enemy.h`,
    `Dragon.h`, and `Soldier.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Enemy.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Dragon.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Soldier.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism is the ability to have different forms. So in this example, we
    have an `Enemy` interface that does not have any functionality for calculating
    total health. However, we know that all types of enemy should have a function
    to calculate total health. So we have made the function in the base class as a
    pure virtual function by assigning it to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: This enables, or rather forces, all the child classes to have their own implementation
    for calculating total health. So the `CSoldier` class and `CDragon` class have
    their own implementation of `TotalHP`. The advantage of such a structure is that
    we can create a pointer object of the child from the base and when it resolves,
    it calls the correct function of the child class.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not create a virtual function, then the functions in the child classes
    would have hidden the function of the base class. With a pure virtual function,
    however, this is not true as this would create a compiler error. The way the compiler
    resolves the functions at run time is by a technique called dynamic dispatch.
    Most languages use dynamic dispatch. C++ uses single-cast dynamic dispatch. It
    does so with the help of virtual tables. When the `CEnemy` class defines the virtual
    function `TotalHP`, the compiler adds a hidden member variable to the class which
    points an array of pointers to functions called the **virtual** **method table**
    (**VMT** or **Vtable**). At runtime, these pointers will be set to point to the
    right function, because at compile time, it is not yet known if the base function
    is to be called or a derived one implemented by `CDragon` and `CSoldier`.
  prefs: []
  type: TYPE_NORMAL
- en: The member variables in the base class are protected. This means that the derived
    class also has access to the member variables. From the driver program, because
    we have allocated memory dynamically, we should also delete, or else we will have
    memory leaks. When the destructor is marked as virtual, we ensure that the right
    destructor is called.
  prefs: []
  type: TYPE_NORMAL
- en: Using copy constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copy constructors are used to copy one object to another. C++ provides us with
    a default copy constructor, but it is not recommended. We should write our own
    copy constructor for better coding and organizing practices. It also minimizes
    crashes and bugs that may arise if we use the default copy constructor provided
    by C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to write a copy constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp` and `Terrain.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Terrain.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have created our own copy constructor and an assignment
    operator. When we assign two objects that are already initialized, then the assignment
    operator is called. When we initialize an object and set it to the other object,
    a copy constructor is called. If we do not create our own copy constructor, the
    newly created object just holds a shallow reference of the object it is being
    assigned to. If the object gets destroyed, then the shallow object becomes lost
    as the memory is also lost. If we create our own copy constructor, a deep copy
    is created and even if the first object is deleted, the second object stills holds
    the information in a different memory location.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So in effect, a shallow copy (or member-wise copy) copies the exact values
    of one object''s member variables into another object. Pointers in both objects
    end up pointing to the same memory. A deep copy copies the values allocated on
    the free store to newly allocated memory. So in shallow deleting, the object in
    the shallow copy is disastrous:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, a deep copy solves this problem for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use operator overloading to reuse operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of operators that are provided for us by C++. However, sometimes
    we need to overload these operators so that we can use them on data structures
    that we create ourselves. Of course, we can overload the operators to change the
    meaning as well. For example, we can change + (plus) to behave like - (minus),
    but this is not recommended as this usually does not serve any purpose or help
    us in any way. Also, it may confuse other programmers who are using the same code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can overload an operator and which operators
    are allowed to be overloaded in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`, `vector3.h`, and `vector3.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `vector3.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `vector3.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C++ has built-in types: int, char, and float. Each of these types has a number
    of built-in operators, such as addition (+) and multiplication (*). C++ allows
    you to add these operators to your own classes as well. Operators on built-in
    types (int, float) cannot be overloaded. The precedence order cannot be changed.
    There are many reasons for proceeding with caution when overloading an operator.
    The goal is to increase usability and understanding. In our example, we have overloaded
    the basic multiplication operators so that we can add, subtract, and so on our
    `vector3` objects that we create. This is extremely handy, as we can find the
    distance of an object in our game if we know the position vectors of the two objects.
    We have used const functions as much as possible. The compiler will enforce the
    promise to not modify the object. This can be a great way to make sure that your
    code has no unanticipated side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: All functions that accept vectors accept a constant reference to a vector. We
    have to remember that passing an argument by value to a function invokes a constructor.
    Inheritance will not be very useful to the vector class, as we know `CVector3`
    is speed critical. The V-table adds 25% to the class size, so it is not advisable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, data hiding does not make too much sense, as we need the values of the
    vector class. Some operators can be overloaded in C++. The operators that C++
    does not allow us to overload are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Use function overloading to reuse functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function overloading is an important concept in C++. Sometimes, we want to use
    the same function name but have different functions to work on different data
    types or a different number of types. This is useful as the client can choose
    the correct function based on its needs. C++ allows us to do this by using function
    overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to overload a function:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `main.cpp`, `Cspeed.h`, and `Cspeed.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `main.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `CSpeed.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `CSpeed.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overloading a function is a type of functional polymorphism. A function can
    be overloaded only by the number of parameters in the argument list and the type
    of parameter. A function cannot be overloaded only by the return type.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a class to calculate the sum of speeds. We can use the function
    to add two speeds, three speeds, or speeds of different data types. The compiler
    will resolve which function to call based on the signature. One might argue that
    we could create different objects with different speeds and then add them using
    operator overloading, or use templates and write one template function. However,
    we have to remember that in simple templates the implementation will remain the
    same, but in function overloading we can change the implementation of each function
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using files for input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files are really useful for saving data locally, so we can retrieve it the next
    time the program is run or analyze the data after the program exits. For all data
    structures that we create in code and populate with values, the values will get
    lost after the application quits unless we save them locally or to the server/cloud.
    Files serve the purpose of containing the saved data. We can create text files,
    binary files, or even a file with our own encryption. Files are very handy when
    we want to log errors or generate a crash report.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how to use file handling operations in C++
    to write or read from a text file. We can even use C++ operations to create binary
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp`, `File.h`, and `File.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `File.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `File.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use file handling for a variety of reasons. Some of the most important reasons
    are to log data while the game is running, to load data from a text file to be
    used in the game, or to encrypt the save data or load data of a game.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a class called `CFile`. This class helps us to write data to
    a new file, to append to a file, and to read from a file. We use the `fstream`
    header file to load all the file handling operations.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in a file is written and read in terms of streams. While doing C++
    programming, we must write information to a file from our program using the stream
    insertion operator (`<<`), just as we use that operator to output information
    to the screen. The only difference is that you use an `ofstream` or `fstream`
    object, instead of the `cout` object.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a constructor to contain initial data if a file is created without
    any data in it. If we just create or write to a file, each time a new file will
    be created with the new data. This is sometimes useful if we just want to write
    the most recently updated or latest data. However, if we want to add data to an
    existing file, we can use the `append` function. The append function starts writing
    to an existing file from the last file-position pointer position.
  prefs: []
  type: TYPE_NORMAL
- en: The read function starts reading data from the file until it reaches the last
    line of written data. We can display the result to the screen or, if needed, we
    could then write the contents to another file. We also must remember to close
    the file after each operation, or it might lead to ambiguity in the code. We can
    also use the `seekp` and `seekg` functions to reposition the file-position pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first simple game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a simple text-based game is really easy. All we need to do is to create
    some rules and logic and we will have ourselves a game. Of course, as the game
    gets more complex we need to add more functions. When the game reaches a point
    where there are multiple behaviors and states of objects and enemies, we should
    use classes and inheritance to achieve the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to create a simple luck-based lottery game:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Source.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game works by creating a random number from 1 to 100 and asks the user to
    guess that number. Hints are provided as to whether the number guessed is higher
    or lower than the actual number. The user is given just 20 tries to guess the
    number. We first need a pseudo seeder, based on which we are going to generate
    a random number. The pseudo seeder in this case is `srand`. We have chosen TIME
    as a value to generate our random range.
  prefs: []
  type: TYPE_NORMAL
- en: We need to execute the program in an infinite loop so that the program breaks
    only when all tries are used up or when the user correctly guesses the number.
    We can set a variable for tries and increment for every guess a user takes. The
    random number is generated by the rand function. We use `rand%100+1` so that the
    random number is in the range 1 to 100\. We ask the user to input the guessed
    number and then we check whether that number is less than, greater than, or equal
    to the randomly generated number. We then display the correct message. If the
    user has guessed correctly, or all tries have been used, the program should break
    out of the main loop. At this point, we ask the user whether they want to play
    the game again.
  prefs: []
  type: TYPE_NORMAL
- en: Then, depending on the answer, we go back into the main loop and start the process
    of selecting a random number.
  prefs: []
  type: TYPE_NORMAL
- en: Templates – when to use them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are a C++ programming way to lay the foundations for writing a generic
    program. Using templates, we can write code in such a way that it is independent
    of any particular data type. We can use function templates or class templates.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out the importance of templates, how to use them,
    and the advantages that using them provides us.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp` and `Stack.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `Stack.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates are the foundation of generic programming in C++. If the implementation
    of a function or a class is the same but we need them to operate on different
    data types, it is advisable to use templates instead of writing a new class or
    function. One can argue that we can overload a function to achieve the same thing,
    but keep in mind that while overloading a function, we can change the implementation
    based on the data type and we are still writing a new function. With templates,
    the implementation has to be the same for all data types. This is the advantage
    of templates: writing one function is enough. With advanced templates and C++11
    features, we can even change the implementation, but we will reserve that discussion
    for later.'
  prefs: []
  type: TYPE_NORMAL
- en: We have used function templates and class templates in this example. The function
    template is defined in `Source.cpp` itself. On top of the `print` function, we
    have added the line template `<class T>`. The `keyword` class could be replaced
    by `typename` as well. The reason for two keywords is a historic one and we do
    not need to discuss it here. The remaining part of the function definition is
    normal, except instead of using a particular data type, we have used `T`. So when
    we call the function from main, `T` gets replaced with the correct data type.
    In this way, by just using one function, we can print all data types. We can even
    create our own data type and pass it to the function.
  prefs: []
  type: TYPE_NORMAL
- en: '`Stack.h` is an example of a class template, as the data type that the class
    uses is a generic one. We have selected a stack as it is a very popular data structure
    in games programming. It''s a **LIFO** (**Last In First Out**) structure, so we
    can display the latest content from the stack as per our requirements. The push
    function pushes an element onto the stack, whereas a pop removes an element from
    the stack. The top function displays the top-most element of the stack and the
    empty function empties the stack. By using this generic stack class, we can store
    and display the data type of our choice.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to be kept in mind while using templates is that the compiler must
    know at compile time the correct implementation of the template, so generally
    template definition and declaration are both done in the header file. However,
    if you want to separate out the two, you can do so with two popular methods. One
    method is to have another header file and list the implementation at the end of
    it. The other implementation is to create an `.ipp` or `.tpp` file extension and
    have the implementation in those files.
  prefs: []
  type: TYPE_NORMAL
