- en: Chapter 2. Object-Oriented Approach and Design in Games
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Using classes for data encapsulation and abstraction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using polymorphism to reuse code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using copy constructors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using operator overloading to reuse operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using function overloading to reuse functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using files for input and output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first simple text-based game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates – when to use them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following diagram shows the main concepts of **OOP** (**Object-oriented
    programming**). Let us consider that we need to make a car racing game. So, a
    car is made up of an engine, wheels, chassis, and so on. All these parts can be
    considered as individual components, which can be used for other cars as well.
    Similarly, every car's engine can be different and so we can add different functionalities,
    states, and properties to each individual component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'All this can be achieved through object-oriented programming:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/B04929_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: We need to use an object-oriented system in any design that consists of states
    and behaviors. Let us consider a game like *Space Invaders*. The game consists
    of two main characters, the player ship and the enemy. There is also a boss, but
    that is just an advanced version of the enemy. The player ship can have different
    states such as alive, idle, moving, attack, and dead. It also has a few behaviors,
    such as left/right movement, single shoot/burst shoot/missile. Similarly, the
    enemy has states and behaviors. This is an ideal condition to use an object-oriented
    design. The boss is just an advanced form of the enemy, so we can use the concepts
    of polymorphism and inheritance to achieve the result.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Using classes for data encapsulation and abstraction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is used to organize information into meaningful states and behaviors.
    In games, we deal with so many different types of weapon, player, enemy, and terrain,
    each with its own type of state and behavior, so an object-oriented design with
    classes is a must.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You need
    to have a working copy of Visual Studio installed on your Windows machine. No
    other prerequisites are required.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to create a game framework using
    object-oriented programming in C++:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp`, `CEnemy.h`, and `CEnemy.cpp`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Souce.cpp`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following lines of code to `CEnemy.h`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following lines of code to `CEnemy.cpp`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create an object-oriented program, we need to create classes and objects.
    Although we can write the definition and declaration of a class in the same file,
    it is advisable to have two separate files for definition and declaration. A declaration
    class file is called a header file, whereas a definition class file is called
    a source file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In the `CEnemy` header file, we define the member variables and the functions
    that we need. In a class, we have the option to separate out the variables as
    public, protected, or private. A public state indicates that they are accessible
    from outside the class, a protected state indicates that only the child class
    that inherits from the current base class has access to it, whereas a private
    state indicates that they are accessible by any instance of the class. By default,
    everything in a C++ class is private. Hence, we have created all the member functions
    as public so that we can access them from the driver program, which in this example
    is `Source.cpp`. The member variables in the header file are all private, as they
    should not be directly accessible from outside the class. This is what we call
    abstraction. We define a string type variable for name and armor, and an integer
    type for health and age. It is also advisable to create a constructor and destructor,
    even if we do not have any functionality for them at present. It is also good
    to use a copy constructor. The reason for this is explained later on in the chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In the `CEnemy` source file, we have the initialization of the member variables
    and also the declarations of the functions. We have used the `const` keyword at
    the end of each function because we do not want the function to change the contents
    of the member variables. We just want them to return the values that are already
    assigned. As a rule of thumb, we should always use it unless it's necessary not
    to use it. It makes the code more secure, organized, and readable. We have initialized
    the variables in the constructor; we could have also created parameterized constructors
    and assigned values to them from the driver program. Alternatively, we can also
    have set functions to assign values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: From the driver program, we create a pointer object of the type `CEnemy`. When
    the object is initialized, it calls its appropriate constructors and the values
    are assigned to them. Then we call the functions by dereferencing the pointer
    using the `->` operator. So when we call the `p->` function, it is the same as
    (`*p`).function. As we are dynamically allocating memory, we should also delete
    the object or else we will get a memory leak. We have used `vld` to check for
    memory leaks. This program does not have any, as we have used the `delete` keyword.
    Just comment out the line `delete pEnemy;` and you will notice that the program
    has few memory leaks on exiting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Using polymorphism to reuse code
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism means having several forms. Typically, we use polymorphism when
    there is a hierarchy of classes and they are related in some way. We generally
    achieve this level of relation by using inheritance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how we can use the same function and override it
    with different functionalities based on our needs. Also, we will see how we can
    share values across base and derived classes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called Source.cpp and three header files called `Enemy.h`,
    `Dragon.h`, and `Soldier.h`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Enemy.h`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following lines of code to `Dragon.h`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following lines of code to `Soldier.h`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism is the ability to have different forms. So in this example, we
    have an `Enemy` interface that does not have any functionality for calculating
    total health. However, we know that all types of enemy should have a function
    to calculate total health. So we have made the function in the base class as a
    pure virtual function by assigning it to `0`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: This enables, or rather forces, all the child classes to have their own implementation
    for calculating total health. So the `CSoldier` class and `CDragon` class have
    their own implementation of `TotalHP`. The advantage of such a structure is that
    we can create a pointer object of the child from the base and when it resolves,
    it calls the correct function of the child class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If we do not create a virtual function, then the functions in the child classes
    would have hidden the function of the base class. With a pure virtual function,
    however, this is not true as this would create a compiler error. The way the compiler
    resolves the functions at run time is by a technique called dynamic dispatch.
    Most languages use dynamic dispatch. C++ uses single-cast dynamic dispatch. It
    does so with the help of virtual tables. When the `CEnemy` class defines the virtual
    function `TotalHP`, the compiler adds a hidden member variable to the class which
    points an array of pointers to functions called the **virtual** **method table**
    (**VMT** or **Vtable**). At runtime, these pointers will be set to point to the
    right function, because at compile time, it is not yet known if the base function
    is to be called or a derived one implemented by `CDragon` and `CSoldier`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The member variables in the base class are protected. This means that the derived
    class also has access to the member variables. From the driver program, because
    we have allocated memory dynamically, we should also delete, or else we will have
    memory leaks. When the destructor is marked as virtual, we ensure that the right
    destructor is called.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Using copy constructors
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copy constructors are used to copy one object to another. C++ provides us with
    a default copy constructor, but it is not recommended. We should write our own
    copy constructor for better coding and organizing practices. It also minimizes
    crashes and bugs that may arise if we use the default copy constructor provided
    by C++.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to write a copy constructor:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp` and `Terrain.h`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Terrain.h`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have created our own copy constructor and an assignment
    operator. When we assign two objects that are already initialized, then the assignment
    operator is called. When we initialize an object and set it to the other object,
    a copy constructor is called. If we do not create our own copy constructor, the
    newly created object just holds a shallow reference of the object it is being
    assigned to. If the object gets destroyed, then the shallow object becomes lost
    as the memory is also lost. If we create our own copy constructor, a deep copy
    is created and even if the first object is deleted, the second object stills holds
    the information in a different memory location.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_02_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: 'So in effect, a shallow copy (or member-wise copy) copies the exact values
    of one object''s member variables into another object. Pointers in both objects
    end up pointing to the same memory. A deep copy copies the values allocated on
    the free store to newly allocated memory. So in shallow deleting, the object in
    the shallow copy is disastrous:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_02_03.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'However, a deep copy solves this problem for us:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_02_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Use operator overloading to reuse operators
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of operators that are provided for us by C++. However, sometimes
    we need to overload these operators so that we can use them on data structures
    that we create ourselves. Of course, we can overload the operators to change the
    meaning as well. For example, we can change + (plus) to behave like - (minus),
    but this is not recommended as this usually does not serve any purpose or help
    us in any way. Also, it may confuse other programmers who are using the same code
    base.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: C++为我们提供了许多运算符。但是，有时我们需要重载这些运算符，以便我们可以在自己创建的数据结构上使用它们。当然，我们也可以重载运算符以改变其含义。例如，我们可以将+（加号）改为行为像-（减号），但这并不推荐，因为这通常没有任何意义或帮助我们。此外，这可能会让使用相同代码库的其他程序员感到困惑。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Windows机器上安装Visual Studio的工作副本。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In this recipe, we will see how we can overload an operator and which operators
    are allowed to be overloaded in C++.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何重载运算符以及在C++中允许重载哪些运算符。
- en: Open Visual Studio.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select **Win32 Console Application**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add a source file called `Source.cpp`, `vector3.h`, and `vector3.cpp`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`Source.cpp`、`vector3.h`和`vector3.cpp`的源文件。
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`Source.cpp`：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following lines of code to `vector3.h`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`vector3.h`：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following lines of code to `vector3.cpp`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`vector3.cpp`：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'C++ has built-in types: int, char, and float. Each of these types has a number
    of built-in operators, such as addition (+) and multiplication (*). C++ allows
    you to add these operators to your own classes as well. Operators on built-in
    types (int, float) cannot be overloaded. The precedence order cannot be changed.
    There are many reasons for proceeding with caution when overloading an operator.
    The goal is to increase usability and understanding. In our example, we have overloaded
    the basic multiplication operators so that we can add, subtract, and so on our
    `vector3` objects that we create. This is extremely handy, as we can find the
    distance of an object in our game if we know the position vectors of the two objects.
    We have used const functions as much as possible. The compiler will enforce the
    promise to not modify the object. This can be a great way to make sure that your
    code has no unanticipated side effects.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C++具有内置类型：int、char和float。每种类型都有许多内置运算符，如加法（+）和乘法（*）。C++还允许您将这些运算符添加到自己的类中。内置类型（int、float）上的运算符不能被重载。优先级顺序不能被改变。在重载运算符时要谨慎的原因有很多。目标是增加可用性和理解。在我们的示例中，我们已经重载了基本的乘法运算符，以便我们可以对我们创建的`vector3`对象进行加法、减法等操作。这非常方便，因为如果我们知道两个对象的位置向量，我们就可以在游戏中找到对象的距离。我们尽可能使用const函数。编译器将强制执行不修改对象的承诺。这可以是确保您的代码没有意外副作用的好方法。
- en: All functions that accept vectors accept a constant reference to a vector. We
    have to remember that passing an argument by value to a function invokes a constructor.
    Inheritance will not be very useful to the vector class, as we know `CVector3`
    is speed critical. The V-table adds 25% to the class size, so it is not advisable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接受向量的函数都接受向量的常量引用。我们必须记住，将参数按值传递给函数会调用构造函数。继承对于向量类并不是非常有用，因为我们知道`CVector3`是速度关键的。虚函数表会使类大小增加25%，因此不建议使用。
- en: 'Also, data hiding does not make too much sense, as we need the values of the
    vector class. Some operators can be overloaded in C++. The operators that C++
    does not allow us to overload are:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据隐藏并没有太多意义，因为我们需要向量类的值。在C++中可以重载一些运算符。C++不允许我们重载的运算符是：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use function overloading to reuse functions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数重载来重用函数
- en: Function overloading is an important concept in C++. Sometimes, we want to use
    the same function name but have different functions to work on different data
    types or a different number of types. This is useful as the client can choose
    the correct function based on its needs. C++ allows us to do this by using function
    overloading.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载是C++中的一个重要概念。有时，我们希望使用相同的函数名称，但有不同的函数来处理不同的数据类型或不同数量的类型。这是有用的，因为客户端可以根据自己的需求选择正确的函数。C++允许我们通过函数重载来实现这一点。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要一台安装有Visual Studio工作副本的Windows机器。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will learn how to overload a function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何重载函数：
- en: Open Visual Studio.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio。
- en: Create a new C++ project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C++项目。
- en: Select a **Win32 Console Application**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Win32控制台应用程序**。
- en: Add source files called `main.cpp`, `Cspeed.h`, and `Cspeed.cpp`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`main.cpp`、`Cspeed.h`和`Cspeed.cpp`的源文件。
- en: 'Add the following lines of code to `main.cpp`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.cpp`：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following lines of code to `CSpeed.cpp`:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CSpeed.cpp`：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following lines of code to `CSpeed.h`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CSpeed.h`：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Overloading a function is a type of functional polymorphism. A function can
    be overloaded only by the number of parameters in the argument list and the type
    of parameter. A function cannot be overloaded only by the return type.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 函数重载是一种函数多态的类型。函数只能通过参数列表中的参数数量和参数类型进行重载。函数不能仅通过返回类型进行重载。
- en: We have created a class to calculate the sum of speeds. We can use the function
    to add two speeds, three speeds, or speeds of different data types. The compiler
    will resolve which function to call based on the signature. One might argue that
    we could create different objects with different speeds and then add them using
    operator overloading, or use templates and write one template function. However,
    we have to remember that in simple templates the implementation will remain the
    same, but in function overloading we can change the implementation of each function
    as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Using files for input and output
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files are really useful for saving data locally, so we can retrieve it the next
    time the program is run or analyze the data after the program exits. For all data
    structures that we create in code and populate with values, the values will get
    lost after the application quits unless we save them locally or to the server/cloud.
    Files serve the purpose of containing the saved data. We can create text files,
    binary files, or even a file with our own encryption. Files are very handy when
    we want to log errors or generate a crash report.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out how to use file handling operations in C++
    to write or read from a text file. We can even use C++ operations to create binary
    files.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp`, `File.h`, and `File.cpp`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following lines of code to `File.cpp`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following lines of code to `File.h`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use file handling for a variety of reasons. Some of the most important reasons
    are to log data while the game is running, to load data from a text file to be
    used in the game, or to encrypt the save data or load data of a game.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We have created a class called `CFile`. This class helps us to write data to
    a new file, to append to a file, and to read from a file. We use the `fstream`
    header file to load all the file handling operations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Everything in a file is written and read in terms of streams. While doing C++
    programming, we must write information to a file from our program using the stream
    insertion operator (`<<`), just as we use that operator to output information
    to the screen. The only difference is that you use an `ofstream` or `fstream`
    object, instead of the `cout` object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We have created a constructor to contain initial data if a file is created without
    any data in it. If we just create or write to a file, each time a new file will
    be created with the new data. This is sometimes useful if we just want to write
    the most recently updated or latest data. However, if we want to add data to an
    existing file, we can use the `append` function. The append function starts writing
    to an existing file from the last file-position pointer position.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The read function starts reading data from the file until it reaches the last
    line of written data. We can display the result to the screen or, if needed, we
    could then write the contents to another file. We also must remember to close
    the file after each operation, or it might lead to ambiguity in the code. We can
    also use the `seekp` and `seekg` functions to reposition the file-position pointer.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first simple game
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a simple text-based game is really easy. All we need to do is to create
    some rules and logic and we will have ourselves a game. Of course, as the game
    gets more complex we need to add more functions. When the game reaches a point
    where there are multiple behaviors and states of objects and enemies, we should
    use classes and inheritance to achieve the desired result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to create a simple luck-based lottery game:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Source.cpp` file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game works by creating a random number from 1 to 100 and asks the user to
    guess that number. Hints are provided as to whether the number guessed is higher
    or lower than the actual number. The user is given just 20 tries to guess the
    number. We first need a pseudo seeder, based on which we are going to generate
    a random number. The pseudo seeder in this case is `srand`. We have chosen TIME
    as a value to generate our random range.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: We need to execute the program in an infinite loop so that the program breaks
    only when all tries are used up or when the user correctly guesses the number.
    We can set a variable for tries and increment for every guess a user takes. The
    random number is generated by the rand function. We use `rand%100+1` so that the
    random number is in the range 1 to 100\. We ask the user to input the guessed
    number and then we check whether that number is less than, greater than, or equal
    to the randomly generated number. We then display the correct message. If the
    user has guessed correctly, or all tries have been used, the program should break
    out of the main loop. At this point, we ask the user whether they want to play
    the game again.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Then, depending on the answer, we go back into the main loop and start the process
    of selecting a random number.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Templates – when to use them
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are a C++ programming way to lay the foundations for writing a generic
    program. Using templates, we can write code in such a way that it is independent
    of any particular data type. We can use function templates or class templates.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will find out the importance of templates, how to use them,
    and the advantages that using them provides us.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp` and `Stack.h`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following lines of code to `Stack.h`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates are the foundation of generic programming in C++. If the implementation
    of a function or a class is the same but we need them to operate on different
    data types, it is advisable to use templates instead of writing a new class or
    function. One can argue that we can overload a function to achieve the same thing,
    but keep in mind that while overloading a function, we can change the implementation
    based on the data type and we are still writing a new function. With templates,
    the implementation has to be the same for all data types. This is the advantage
    of templates: writing one function is enough. With advanced templates and C++11
    features, we can even change the implementation, but we will reserve that discussion
    for later.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: We have used function templates and class templates in this example. The function
    template is defined in `Source.cpp` itself. On top of the `print` function, we
    have added the line template `<class T>`. The `keyword` class could be replaced
    by `typename` as well. The reason for two keywords is a historic one and we do
    not need to discuss it here. The remaining part of the function definition is
    normal, except instead of using a particular data type, we have used `T`. So when
    we call the function from main, `T` gets replaced with the correct data type.
    In this way, by just using one function, we can print all data types. We can even
    create our own data type and pass it to the function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`Stack.h` is an example of a class template, as the data type that the class
    uses is a generic one. We have selected a stack as it is a very popular data structure
    in games programming. It''s a **LIFO** (**Last In First Out**) structure, so we
    can display the latest content from the stack as per our requirements. The push
    function pushes an element onto the stack, whereas a pop removes an element from
    the stack. The top function displays the top-most element of the stack and the
    empty function empties the stack. By using this generic stack class, we can store
    and display the data type of our choice.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack.h` 是一个类模板的示例，因为类使用的数据类型是通用的。我们选择了堆栈，因为它是游戏编程中非常流行的数据结构。它是一个**LIFO**（**后进先出**）结构，因此我们可以根据我们的需求显示堆栈中的最新内容。push函数将一个元素推入堆栈，而pop函数将一个元素从堆栈中移除。top函数显示堆栈中的顶部元素，empty函数清空堆栈。通过使用这个通用的堆栈类，我们可以存储和显示我们选择的数据类型。'
- en: One thing to be kept in mind while using templates is that the compiler must
    know at compile time the correct implementation of the template, so generally
    template definition and declaration are both done in the header file. However,
    if you want to separate out the two, you can do so with two popular methods. One
    method is to have another header file and list the implementation at the end of
    it. The other implementation is to create an `.ipp` or `.tpp` file extension and
    have the implementation in those files.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板时需要记住的一件事是，编译器必须在编译时知道模板的正确实现，因此通常模板的定义和声明都在头文件中完成。然而，如果你想将两者分开，可以使用两种流行的方法。一种方法是使用另一个头文件，并在其末尾列出实现。另一种方法是创建一个`.ipp`或`.tpp`文件扩展名，并在这些文件中进行实现。
