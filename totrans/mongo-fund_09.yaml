- en: 9\. Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the concepts of query optimization and performance
    improvement in MongoDB. You will first explore the internal workings of query
    execution and identify the factors that can affect query performance, before moving
    on to database indexes and how indexes can reduce query execution time. You will
    also learn how to create, list, and delete indexes, and study the various types
    of indexes and their benefits. In the final sections, you will be introduced to
    various query optimization techniques that can help you use indexes effectively.
    By the end of this chapter, you will be able to analyze queries and use indexes
    and optimization techniques to improve query performance.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned about the MongoDB query language and various
    query operators. We learned how to write queries to retrieve data. We also learned
    about various commands used to add and delete data and also to update or modify
    a piece of data. We ensured that the queries bring us the desired output; however,
    we did not pay much attention to their execution time and their efficiency. In
    this chapter, we will focus on how to analyze a query's performance and optimize
    its performance further, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world applications are made up of multiple components, such as a user interface,
    processing components, databases, and more. The responsiveness of an application
    is dependent on the efficiency of each of these components. The database component
    performs different operations, such as saving, reading, and updating data. The
    amount of data a database table or collection stores, or the amount of data being
    pushed into or retrieved from a database, can affect the performance of the entire
    system. Therefore, it is important to know how efficiently database operations
    are executed and whether further optimization is possible to improve the speed
    of those operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to analyze queries based on the detailed
    statistics provided by the database and use them to identify problems.
  prefs: []
  type: TYPE_NORMAL
- en: Query Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to write efficient queries, it is important to analyze them, find any
    possible performance issues, and fix them. This technique is called performance
    optimization. There are many factors that can negatively affect the performance
    of a query, such as incorrect scaling, incorrectly structured collections, and
    inadequate resources such as RAM and CPU. However, the biggest and most common
    factor is the difference between the number of records scanned and the number
    of records returned during the query execution. The greater the difference is,
    the slower the query will be. Thankfully, in MongoDB, this factor is the easiest
    to address and is done using indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using indexes on a collection narrows down the number of records
    being scanned and improves the query performance noticeably. Before we delve further
    into indexes, though, we first need to cover the details of query execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to find a list of the movies released in the year 2015\. The following
    snippet shows the command for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The query filters the `movies` collection based on the `year` field, projects
    the movie title and awards won in the output, and sorts the results so that the
    movies with the greatest number of wins appear at the top. If we execute this
    query by connecting to the MongoDB Atlas `sample_mflix` database, it returns **484**
    records.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute any such query, the MongoDB query execution engine prepares one
    or more query execution plans. The database has an inbuilt query optimizer that
    chooses the most efficient plan for the execution. A plan is usually composed
    of multiple processing stages that are executed in sequence to produce the final
    output. The previous query we created has a query condition, a projection expression,
    and a sort specification. For the queries with similar shapes, a typical execution
    plan will look as shown in *Figure 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Query execution stages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Query execution stages'
  prefs: []
  type: TYPE_NORMAL
- en: At first, if there is a supporting index for the given query condition, the
    index is scanned to identify the matching records. In our case, the `year` field
    does not have an index, and so the index scan stage will be ignored. In the next
    stage, the full collection is scanned to find the matching records. The matched
    records are then passed to the sort stage, where the records are sorted in memory.
    Finally, projection is applied to the sorted records and the final output is delivered
    to the client.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB provides a query analysis mechanism with which we can fetch some useful
    stats about query execution. In the next section, we will learn how to use query
    analysis and stats to identify performance issues in the previous query.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `explain()` function is extremely useful for exploring the internal workings
    of a query. The function can be used along with a query or a command to print
    detailed statistics pertinent to their execution. The most important metrics it
    can give us are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Query execution time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of documents scanned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of documents returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index that was used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet shows an example of using the `explain` function
    on a query using the same query that you created previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `explain` function can also be used with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aggregate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findAndModify()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, the `explain` function prints the query planner details—that is,
    details of various execution stages. This can be seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the winning plan and a list of rejected plans. In the case
    of the preceding query, the execution began with `COLLSCAN` as there was no suitable
    index. Thus, the query does not have any rejected plans, and the only plan available
    was the winning plan. In the winning plan, there are multiple nested `inputStage`
    objects, which clearly shows the execution sequence of different stages.
  prefs: []
  type: TYPE_NORMAL
- en: The first stage is `COLLSCAN`, where a filter is applied to the `year` field.
    The next stage, `SORT`, performs the sorting based on the `awards.wins` field—that
    is, the number of awards won. Finally. in the `PROJECTION_DEFAULT` stage, the
    `title` and `awards.wins` fields are selected and returned in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `explain` function can take an optional argument called verbosity mode,
    which controls what information is returned by the function. The following list
    details the three different verbosity levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`queryPlanner`: This is the default option and prints query planner details
    such as rejected plans, the winning plan, and the execution stages of the winning
    plan.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`executionStats`: This option prints all the information provided by `queryPlanner`
    along with detailed execution statistics for the query execution. This option
    is useful for finding any performance-related problems in queries.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`allPlansExecution`: This option outputs the details provided by `executionStats`
    along with the details of the rejected execution plans.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Viewing Execution Stats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to view the execution stats, you need to pass `executionStats` as
    an argument to the `explain()` function. The following snippet shows `executionStats`
    for your query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution stats provide useful metrics pertinent to each execution phase,
    along with some top-level fields where some metrics are aggregated over the total
    execution of the query. The following are some of the most important metrics from
    the execution stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`executionTimeMillis`: This is the total time (in milliseconds) taken for query execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalKeysExamined`: This indicates the number of indexed keys that were scanned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`totalDocsExamined`: This indicates the number of documents examined against
    the given query condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nReturned`: This is the total number of records returned in the query output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's analyze the execution stats in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The execution stats (as seen from the preceding snippet) tell us that there
    are a few problems with the querying process. To return `484` matching records,
    the query examined `23539` documents, which is also the total number of documents
    in the collection. Having to scan a large number of documents slows down the query
    execution. Looking at the query execution time of `85` milliseconds, it seems
    like it is fast enough. However, the query execution time can vary based on the
    network traffic, the RAM and CPU loads on the server, and the number of records
    getting scanned. The reason the number of scanned documents slows down the performance
    is explained in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we execute a `find` query with a search criterion on a collection, the
    database search engine picks the first record in the collection and checks whether
    it matches the given criteria. If no match is found, the search engine moves on
    to the next record to find a match, and the process is repeated till a search
    is found.
  prefs: []
  type: TYPE_NORMAL
- en: This search technique is called a sequential or linear search. Linear searches
    perform better when they are applied to a small amount of data, or in the best-case
    scenarios, where the required term is found within the first search. Thus, the
    search performance will be good when searching for a document in a small collection.
    However, it will be noticeably poorer if there is a large amount of data, or in
    the worst-case scenario, when the required term exists at the end of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, when a newly built system goes live, the collections are either
    empty or they hold a very small amount of data. Thus, all the database operations
    are instant. But, over time, as the collections grow in size, the same operations
    start taking longer. The primary reason for the slowness is linear search, which
    is the default search algorithm used by most databases, including MongoDB. Linear
    searches can be avoided or at least limited by creating indexes on specific fields
    of a collection. In the next section, we will explore this concept in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases can maintain and use indexes to make searches more efficient. In MongoDB,
    indexes are created on a field or a combination of fields. The database maintains
    a special registry of indexed fields and some of their data. The registry is easily
    searchable, as it maintains a logical link between the value of an indexed field
    and the respective documents in the collection. During a search operation, the
    database first locates the value in the registry and identifies the matching documents
    in the collection accordingly. The values in a registry are always sorted in ascending
    or descending order of the values, which helps during a range search and also
    while sorting the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how the index registry helps during searches, imagine
    you are searching for a theater by its ID, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When the query is executed on the `sample_mflix` database, it returns a single
    record. Note that the total number of theaters in the collection is 1,564\. The
    following diagram depicts the difference between document searches with and without
    an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Data search with and without an index'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Data search with and without an index'
  prefs: []
  type: TYPE_NORMAL
- en: The following table represents the number of documents scanned against the number
    of documents returned in these two different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Details about the documents scanned and the documents returned'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Details about the documents scanned and the documents returned'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the preceding table, it is clear that searching with an index is
    preferable to searching without one. In this section, we learned that databases
    support indexes for the faster retrieval of data and how the index registry helps
    avoid complete collection scans. We will now learn how to create an index and
    find indexes in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Listing Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Indexes can be created by executing a `createIndex()` command on a collection,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to the command is a list of key-value pairs, where each pair
    consists of a field name and sort order, and the optional second argument is a
    set of options to control the indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a previous section, you wrote the following query to find all the movies
    released in 2015, sort them in descending order of the number of awards won, and
    print the title and number of wins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As the query uses a filter on the `year` field, you need to create an index
    on that field. The next command creates an index on the `year` field by passing
    a sort order of `1`, which indicates ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next snippet shows the output after executing the command on the mongo
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that the index was successfully created. It also mentions
    the number of indexes present before and after the execution of this command (see
    the highlighted part in the code) and the time the index was created.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Indexes on a Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can list the indexes of a collection by using the `getIndexes()` command.
    This command does not take any parameters. It simply returns an array of indexes
    with some basic details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the following command will list all the indexes present in the `movies` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output indicates that there are three indexes on the collection, including
    the one you just created. For each index, it displays the version, indexed fields
    and their sort order, the index name, and a namespace made up of the index name
    and database name. Note that, while creating the index on the `year` field, you
    did not specify its name. You will see how index names are derived in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Index Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB assigns a default name to an index if a name is not provided explicitly.
    The default name of an index consists of the field name and the sort order, separated
    by underscores. If there is more than one key in the index (known as a compound
    index), all the keys are concatenated in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command creates an index for the `theaterId` field without providing
    a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command will result in the creation of an index with the default name `theaterId_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can also create an index with a specific name. To do so, you can
    use the `name` attribute to provide a custom name to the index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will create an index with the name `myTheaterIdIndex`.
    In the next exercise, you will use MongoDB Atlas to create an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Creating an Index Using MongoDB Atlas'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to create an index using the mongo
    shell. In this exercise, you will use the MongoDB Atlas portal to create an index
    on the `accounts` collection, which is present in the `sample_analytics` database.
    Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to your account at [https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `sample_analytics` database and select the `accounts` collection.
    On the collection screen, select the `Indexes` tab, and you should see one index.![Figure
    9.4: The Indexes tab in the accounts collection in the sample_analytics database'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: The Indexes tab in the accounts collection in the sample_analytics
    database'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the `CREATE INDEX` button in the top-right corner. You should be presented
    with a modal, as shown in the following figure:![Figure 9.5: The Create Index
    page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: The Create Index page'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an index on `account_id`, remove the default field and type entries
    from the `FIELDS` section. Introduce `account_id` as the field and type with value
    `1` for ascending index order. The following is a screenshot showing the updated
    `FIELDS` section:![Figure 9.6: Updated FIELDS section'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: Updated FIELDS section'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the `name` parameter to provide a custom name for this index in the `OPTIONS`
    section, as shown here:![Figure 9.7: Passing the name parameter in the OPTIONS
    section'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: Passing the name parameter in the OPTIONS section'
  prefs: []
  type: TYPE_NORMAL
- en: Once you update the fields section, the `Review` button should turn green. Click
    on it to go to the next step:![Figure 9.8 The Review button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 The Review button
  prefs: []
  type: TYPE_NORMAL
- en: 'A confirmation screen will be presented to you. Click the `Confirm` button
    on the following screen to finish creating the index:![Figure 9.9: Confirmation
    screen'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.9: Confirmation screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the index creation is finished, the index list will be updated, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: Updated index list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_09_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.10: Updated index list'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have successfully created indexes using the MongoDB Atlas portal.
  prefs: []
  type: TYPE_NORMAL
- en: You have now learned how to create an index on a collection. Next, you will
    see how an indexed field improves query performance.
  prefs: []
  type: TYPE_NORMAL
- en: Query Analysis after Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Query Analysis* section, you analyzed the performance of a query that
    did not have suitable indexes to support its query condition. Because of this,
    the query scanned all `23539` documents in the collection to return `484` matching
    documents. Now that you have added an index on the `year` field, let's see how
    the query execution stats have changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following query prints the execution statistics for the same query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is slightly different than the previous one, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first difference is that the first stage (that is, `COLLSCAN`) is now replaced
    by `IXSCAN` and `FETCH` stages. This means that first, an index scan stage was
    performed, and then, based on the retrieved index references, the data was fetched
    from the collection. Also, the top-level fields indicate that only `484` documents
    were examined, and the same number of documents were returned.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we see that query performance is greatly improved by reducing the number
    of documents being scanned. This is evident here as the query execution time is
    now reduced to `7` milliseconds from `85` milliseconds. Even as more and more
    documents are pushed into the collection every year, the performance of the query
    will remain consistent.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to create indexes and also how to list the indexes from a collection.
    MongoDB also provides a way to remove or drop an index. The following section
    will explore this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding and Dropping Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dropping an index means removing the values of the fields from the index registry.
    Thus, any searches on the related fields will be performed in a linear fashion,
    provided there are no other indexes present on the field.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that MongoDB does not allow updating an existing index.
    Thus, to fix an incorrectly created index, we need to drop it and recreate it
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'An index is deleted using the `dropIndex` function. It takes a single parameter,
    which can either be the index name or the index specification document, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The index specification document is the definition of the index that is used
    to create it (like the following snippet, for example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This command drops the index on the `title` field of the `movies` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output contains `nIndexesWas` (highlighted), which refers to the index count
    before the command was executed. The `ok` field shows the status as `1`, which
    indicates the command was successful.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping Multiple Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also drop multiple indexes using the `dropIndexes` command. The command
    syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This command can be used to drop all the indexes on a collection except the
    default `_id` index. You can use the command to drop a single index by passing
    either the index name or the index specification document. You can also use the
    command to delete a group of indexes by passing an array of index names. The following
    is an example of the `dropIndexes` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All the indexes except the default `_id` index were dropped, as confirmed in
    the `msg` attribute (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: Hiding an Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB provides a way to hide indexes from the query planner. Creating and
    deleting indexes are expensive operations in terms of time. For large collections,
    these operations take longer to finish. So, before you decide to remove an index,
    you can first hide it to analyze the performance impact and then decide accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hide an index, the `hideIndex()` command can be used on the collection,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The argument to the command is similar to that for the `dropIndex()` function.
    It takes either the name of the index or an index specification document.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note is that hidden indexes appear only on the `getIndexes()`
    function call. They are updated after every write operation on the collection.
    However, the query planner won't see these indexes, and so they cannot be used
    for executing queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an index is hidden, you can analyze the impact on the queries and drop
    the indexes if they are truly unneeded. However, if hiding an index has an adverse
    effect on performance, you can restore or unhide them by using the `unhideIndex()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `unhideIndex()` function takes a single argument, which can either be the
    index name or an index specification document. Since hidden indexes are always
    updated after write operations, they are always in a ready state. Unhiding them
    can immediately put them back in operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Dropping an Index Using Mongo Atlas'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will remove an index from the `accounts` collection of
    the `sample_analytics` database using the Atlas portal. The following steps will
    help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign in to your account at [https://www.mongodb.com/cloud/atlas](https://www.mongodb.com/cloud/atlas).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `sample_ analytics` database and select the `accounts` collection.
    On the collection screen, select the `Indexes` tab and you should see the existing
    indexes. Click on the `Drop Index` button next to the index that you want to remove:![Figure
    9.11: The Indexes tab for the accounts collection of the sample_analytics database'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: The Indexes tab for the accounts collection of the sample_analytics
    database'
  prefs: []
  type: TYPE_NORMAL
- en: 'A confirmation dialog box should be presented as shown in the following figure.
    Enter the index name, which is also displayed in bold in the dialog message:![Figure
    9.12: Entering the name of the index to be dropped'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: Entering the name of the index to be dropped'
  prefs: []
  type: TYPE_NORMAL
- en: 'The index should be removed from the list of indexes, as indicated by the following
    screen. Note the absence of the `accountIdIndex` index:![Figure 9.13: The Indexes
    tab indicating that accountIdIndex was successfully removed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15507_09_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.13: The Indexes tab indicating that accountIdIndex was successfully
    removed'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you practiced dropping an index on the collection by using
    the MongoDB Atlas portal. In the next section, we will look at the types of indexes
    available in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Type of Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how indexes help with query performance and how we can create,
    drop, and list indexes in the collection. MongoDB supports different types of
    indexes, such as single key, multikey, and compound indexes. Each of these indexes
    has different advantages that you will need to know before deciding which type
    is suitable for your collection. Let's start with a brief overview of default
    indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Default Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the previous chapters, each document in a collection has a primary
    key (namely, the `_id` field) and is indexed by default. MongoDB uses this index
    to maintain the uniqueness of the `_id` field, and it is available on all the
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Key Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An index created using a single field from a collection is called a single-key
    index. You used a single-key index earlier in this chapter. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Compound Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Single-key indexes are preferable when using the key in a search significantly
    reduces the number of documents to be scanned. However, in some scenarios, single-key
    indexes are not sufficient to reduce the collection scans. This typically happens
    when the query is based on more than one field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the query you wrote to find movies released in 2015\. You saw that
    adding a single-key index on the `year` field improved the query performance.
    You will now modify the query and add a filter based on the `rated` field, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `explain("executionStats")` on this query and analyze the execution stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet is from the execution stats of the query. The following
    are important observations from these stats:'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the indexes, only `484` documents were scanned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexes helped locate the `484` documents and the second filter, based on the
    `rated` field, was applied by doing the collection scan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From these points, it is clear that we have again widened the difference between
    the number of documents to be scanned and the number of documents returned. This
    could be a potential performance issue when the same query is used with some other
    year that has thousands of records. For such cases, the database allows you to
    create an index based on more than one field (called compound indexes). The `createIndex`
    command can be used to create a compound index using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This syntax is similar to that of a single-field index, except that it accepts
    multiple pairs of fields and their respective sort orders. Note that a compound
    index can consist of a maximum of `32` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a compound index on both the `year` and `rated` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The default name of a compound index contains the field names and their sort
    order, separated by an underscore. The index name for the index created by the
    last index will be `year_1_rated_1`. You can give a custom name to the compound
    indexes as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have created an additional index on the two fields, observe what
    execution stats the query gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet indicates that the compound index is used to execute this
    query and not the single-key index you created earlier. The number of documents
    scanned, and the number of documents returned are the same. Since only `3` documents
    are scanned, the query execution time is reduced as well.
  prefs: []
  type: TYPE_NORMAL
- en: Multikey Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An index created on the fields of an array type is called a multikey index.
    When an array field is passed as an argument to the `createIndex` function, MongoDB
    creates an index entry for each element of the array. The syntax of the `createIndex`
    element is the same as that for creating an index of a regular (non-array) field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB inspects the input field, and if it is an array, a multikey index will
    be created. For example, consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This query adds an index on the `languages` field, which is an array. In MongoDB,
    you can find documents based on an element of their array fields. Multikey indexes
    help accelerate such queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how the preceding query performs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The snippet of the execution stats shows `361` documents are returned and the
    same number of documents were scanned. It proves that the multikey index is correctly
    created and used.
  prefs: []
  type: TYPE_NORMAL
- en: Text Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An index defined on a string field or an array of string elements is called
    a text index. Text indexes are not sorted, meaning that they are faster than normal
    indexes. The syntax to create a text index is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a text index to be created on the `users` collection
    on the `name` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should generate output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You cannot drop a text index by passing the index specification document, and
    such indexes can only be deleted by passing the name of the index in the `dropIndex`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes on Nested Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A document can contain nested objects to group a few attributes. For example,
    the `theaters` collection in the `sample_mflix` database contains the `location`
    field, which has a nested object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a dot (`.`) notation, you can create an index on any of the nested document
    fields, just like any other field in the collection, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create an index on the embedded document. For example, you can
    create an index on the `location` field instead of its attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Such indexes can be used when searching for a location by passing the entire
    nested document.
  prefs: []
  type: TYPE_NORMAL
- en: Wildcard Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB supports flexible schema, and different documents can have fields of
    varying types and quantities. It can be difficult to create and maintain indexes
    on non-uniform fields that are not present in all documents. Also, when a new
    field is introduced into a document, it remains unindexed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put this in perspective, consider the following documents from a hypothetical
    `products` collection. The following table displays two different product documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: Two different product specification documents'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.14: Two different product specification documents'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the fields under `specifications` are dynamic in nature. Different
    products can have different specifications. Defining an index on each of these
    fields will result in too many index definitions. As new products with new fields
    get added all the time, the idea of creating an index on all fields is not practical.
    MongoDB provides wildcard indexes to resolve this problem. For instance, consider
    the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This query uses special wildcard characters (`$**`) to create indexes on the
    `specifications` field. It will create indexes on all the fields under `specifications`.
    If new nested fields are added in the future, they will be automatically indexed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, wildcard indexes can be created on the top-level fields of a collection
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates indexes on all fields of all documents. Thus,
    all the new fields added to the documents will be indexed by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also select or omit specific fields from the wildcard indexes by passing
    a `wildcardProjection` option and one or more field names, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query creates a wildcard index on all the fields of a collection,
    excluding the `name` field. To explicitly include the `name` field, excluding
    all the others, you can pass it with a value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB provides a couple of indexes to support the geometric fields: `2dsphere`
    and `2d`. It is beyond the scope of this book to cover these indexes but interested
    readers can find out more about them at [https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes](https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the types of indexes, we will explore index properties
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Properties of Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover different properties of indexes in MongoDB. An
    index property can influence the usage of an index and can also enforce some behavior
    on the collection. Index properties are passed as an option to the `createdIndex`
    function. We will be looking at unique indexes, TTL (time to live) indexes, sparse
    indexes, and finally, partial indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Unique Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A unique index property restricts the duplication of the index key. This is
    useful if you want to maintain the uniqueness of a field in a collection. The
    unique fields are useful for avoiding any ambiguity in identifying documents precisely.
    For example, in a `license` collection, a unique field such as `license_number`
    can help identify each document individually. This property enforces the behavior
    on the collection to reject duplicate entries. Unique indexes can be created on
    a single field or on a combination of fields. The following is the syntax to create
    a unique index on a single file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `{ unique: true }` option is used to create a unique index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, you may want a combination of fields to be unique. For such
    cases, you can define a unique compound index by passing the `unique: true` flag
    while creating a compound index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 9.03: Creating a Unique Index'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will enforce the uniqueness of the `theaterId` field
    in the `theaters` collection in the `sample_mflix` database:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect your shell to the Atlas cluster and choose the `sample_mflix` database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Confirm whether the `theaters` collection enforces any uniqueness of the `theaterId`
    field. To do so, find a record and try to insert another record using the same
    `theaterId` present in the fetched record. The following is the command to retrieve
    a document from the `theaters` collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output, though you may get a different record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: The result of retrieving a document from the theaters collection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15507_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.15: The result of retrieving a document from the theaters collection'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, insert a record with the same `theaterId` (that is, `1012`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The document is inserted successfully, which proves that `theaterId` is not
    a unique field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a unique index on the `theaterId` field using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will return an error response as it is a prerequisite
    that there should be no duplicate records existing in the collection. The following
    is the output, confirming this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, remove the duplicate record that was inserted in *step 3* using its `_id`
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Try creating the unique index once again, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, you should receive a successful response, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the field has a unique index, try inserting a duplicate record, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will fail due to the duplicate key error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you enforced the property of uniqueness on an index.
  prefs: []
  type: TYPE_NORMAL
- en: TTL Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`expireAfterSeconds` attribute. The following snippet shows the syntax for
    creating a TTL index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `{ expireAfterSeconds: seconds }` option is used to create a TTL
    index. MongoDB removes the documents that have passed the threshold of the `expireAfterSeconds`
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: Creating a TTL index using Mongo Shell'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a TTL index on a collection called `reviews`.
    A field called `reviewDate` will be used to capture the current date and time
    of the review. You will introduce a TTL index to check whether the records that
    have passed the thresholds are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `reviews` collection by inserting two documents, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetch these documents from the `reviews` collection to confirm they exist in
    the collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This command results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Introduce a TTL index to expire documents older than 60 seconds, using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After 60 seconds, execute the `find` query again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The query will not return any records, and it proves both documents are deleted
    after 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you created a TTL index on a collection and saw that the documents
    expired after the specified time—that is, 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an index is created on a field, all the values of that field from all documents
    are maintained in the index registry. If the field does not exist in a document,
    a `null` value is registered for that document. Conversely, if an index is marked
    as `sparse`, then only those documents are registered in which the given field
    exists with some value including `null`. A sparse index will not have entries
    from the collection where the indexed field does not exist, and that is why this
    type of index is called sparse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compound indexes can also be marked as sparse. For a compound sparse index,
    only those documents are registered where the combination of fields exists. Sparse
    indexes are created by passing a flag of `{ sparse: true }` to the `createIndex`
    command, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB does not provide any command to list the documents that are maintained
    by an index. This makes it difficult to analyze the behavior of a sparse index.
    This is where the `db.collection.stats()` function can be really useful, as you
    will observe in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.05: Creating a Sparse Index Using Mongo Shell'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a sparse index on the `review` field in the
    `reviews` collection. You will verify that the index maintains entries only for
    those documents that have the `review` field present. To do so, you will use the
    `db.collection.stats()` command to check the size of the index by first inserting
    the documents with the indexed field, and then again without the field. The size
    of the index should remain the same when a document is inserted without the `review`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a sparse index on the `review` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the size of the index on the current collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This command results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a document that does not have the `review` field, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the size of the index using the `stats()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, insert a document that contains the `review` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the size of the index after a couple of minutes using the `stats()` function
    once again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `indexSizes` portion from the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you created a sparse index and proved that documents without
    the indexed fields are not indexed.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An index can be created to maintain documents that match a given filter expression.
    Such an index is called a partial index. As the documents are filtered depending
    on the input expression, the size of the index is smaller than a normal index.
    The syntax to create a partial index is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `{ partialFilterExpression: filterExpression
    }` option is used to create a partial index. `partialFilterExpression` can only
    accept an expression document that contains operations from the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equality expressions (that is, `field: value` or using the `$eq` operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `$exists: true` expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$gt`, `$gte`, `$lt`, and `$lte` expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$type` expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$and` operator at the top level only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get a better idea of how partial indexes work, let's perform a simple exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.06: Creating a Partial Index Using the Mongo Shell'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will introduce a compound index on `title` and `type`
    fields for all the movies released after 1950\. You will then verify whether the
    index contains the desired entries, using `partialFilterExpression`:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Introduce a partial index on the `title` and `type` fields in the `movies`
    collection, using `partialFilterExpression`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command creates a partial compound index on the given fields
    for all the movies released after 1950\. The following snippet shows the output
    of this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Check and note down the index size on the collection using the `stats()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `indexSizes` section of the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert a movie that was released before 1950:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the index size and ensure it is unchanged using the `stats()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The next snippet shows the `indexSizes` portion of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The output snippet proves that the index size remained unchanged, as can be
    seen from the highlighted part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, insert a movie that was released after 1950:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the index size again, with the help of the `stats()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `indexSizes` portion from the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you introduced a partial index and verified that it worked
    as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Case-Insensitive Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Case-insensitive indexes allow you to find data using indexes in a case-insensitive
    manner. This means that the index will match the documents even if the values
    of a field are written in a different case from the values in the search expression.
    This is possible due to the collation feature in MongoDB, which allows the input
    of language-specific rules, such as case and accent marks, to match documents.
    To create the case-insensitive index, you need to pass the field details and the
    `collation` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax to create a case-insensitive index is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `collation` is made up of `locale` and `strength` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`locale`: This refers to the language to be used, such as `en` (English), `fr`
    (French), and more. The full list of locales can be found at [https://docs.mongodb.com/manual/reference/collation-locales-defaults/#collation-languages-locales](https://docs.mongodb.com/manual/reference/collation-locales-defaults/#collation-languages-locales).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strength`: A value of 1 or 2 indicates a case-level collation. You can find
    the details about collation **International Components for Unicode** (**ICU**)
    levels at [http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels](http://userguide.icu-project.org/collation/concepts#TOC-Comparison-Levels).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use an index that specifies a collation, the query and the sort specification
    must have the same collation as the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.07: Creating a Case-Insensitive Index Using the Mongo Shell'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a case-insensitive index by connecting the
    mongo shell to the Atlas cluster. This feature is immensely useful for web-based
    applications because database querying is executed in a case-sensitive manner
    in the backend. On the frontend though, the user will not necessarily use the
    same case for searches as the one used in the backend. Therefore, it is important
    to make sure that searches are case-insensitive. Perform the following steps to
    complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the mongo shell to the Atlas cluster and switch to the `sample_mflix`
    database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform a case-insensitive search and verify that the expected document is
    not returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The preceding query returns no result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, create a case-insensitive index on the `title` attribute
    of the `movies` collection, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This command results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the command in *step 2* to confirm that the correct movie is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The command returns the correct movie, as shown in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you created a case-insensitive index and verified that it
    worked as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `collation` option allows us to perform case-insensitive searches on unindexed
    fields as well. The only difference is that such queries will do a full collection
    scan.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you reviewed different index properties and learned how to
    create indexes with each of these properties. In the next section, you will explore
    some query optimization techniques that can be used along with indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Other Query Optimization Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen the internal workings of queries and how indexes help limit
    the number of documents to be scanned. We have also explored various types of
    indexes and their properties and learned how we can use the correct index and
    correct index properties in specific use cases. Creating the right index can improve
    query performance, but there are a few more techniques that are required to fine-tune
    the query performance. We will cover those techniques in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch Only What You Need
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The performance of a query is also affected by the amount of data it returns.
    The database server and client communicate over a network. If a query produces
    a large amount of data, it will take longer to transfer it over a network. Moreover,
    to transfer the data over the network, it needs to be transformed and serialized
    by the server and deserialized by the receiving client. This means that the database
    client will have to wait longer to get the final output of the query.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the overall performance, consider the following factors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct Query Condition and Projection**'
  prefs: []
  type: TYPE_NORMAL
- en: An application can have a variety of use cases, and each of them may need a
    different subset of data. Therefore, it is important to analyze all such use cases
    and to make sure we have optimal queries or commands to satisfy each of them.
    This can be done by using optimal query conditions and correctly using projections
    to return only the essential fields pertinent to the use case.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pagination**'
  prefs: []
  type: TYPE_NORMAL
- en: Pagination is about serving only a small subset of data to the client in each
    subsequent request. It is also the best method of performance optimization, especially
    when serving a large amount of data to the client. It improves user experience
    by limiting the amount of data being returned and serving faster results.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Using Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queries often need to return the data in some order. For example, if the user
    chooses an option to view the latest movies, the resulting movies can be sorted
    on the basis of the release date. Similarly, if the user wants to view popular
    movies, we may sort the movies based on their ratings.
  prefs: []
  type: TYPE_NORMAL
- en: By default, sort operations for a query are carried out in memory. First, all
    the matching results are loaded in memory, and then the sort specification is
    applied to them. For a large dataset, such a process requires a lot of memory.
    MongoDB reserves only `allowDiskUse` flag, so that when the memory limit is reached
    the records are written on the disk and then sorted. However, writing records
    on disk and reading them back slows down the query.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, you can use indexes for sorting, since indexes are created and
    maintained with a specific sort order. This means that for an indexed field, the
    index registry is always sorted based on the values of that field. When a sort
    specification is based on such an index field, MongoDB refers to the indexes to
    retrieve an already sorted dataset and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Fitting Indexes in the RAM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Indexes are much more efficient when they are fit in memory. If they exceed
    the available memory, they are written to the disk. As you already know, disk
    operations are slower than in-memory ones. MongoDB intelligently makes use of
    both disk and memory by keeping the most recently added records in the memory
    and older ones on the disk. This logic assumes that the most recent records will
    be queried more than the old ones. To fit indexes in memory, you can use the `totalIndexSize`
    function on a collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: If the size exceeds the available memory on the server, you can choose to increase
    the memory or optimize the indexes. This way, you ensure that all the indexes
    always remain in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Index Selectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Indexes are more effective when they can considerably narrow down the actual
    collection scans. This depends on the `isRunning` field holds a Boolean value,
    which means it will have either `true` or `false` as its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add an index on the `isRunning` field and execute the following query
    to find a running device by its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB will first use the `isRunning` index to locate all the running devices
    before the collection scan to find documents with a matching `name` value. Since
    `isRunning` can have only `true` or `false` values, a significant part of the
    collection will have to be scanned.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, to make the preceding query more efficient, we should put an index on
    the `name` field as there will not be too many documents with the same name. Indexes
    are more efficient on fields that have a broader range of values or unique values.
  prefs: []
  type: TYPE_NORMAL
- en: Providing Hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoDB query planner picks an index for a query depending on its own internal
    logic. When there are multiple indexes available to perform a query execution,
    the query planner uses its default query optimization technique to select and
    use the most appropriate index. However, we can use a `hint()` function to specify
    which index should be used for the execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This command shows a syntax for providing an index hint. The argument to the
    `hint` function can simply be an index name or an index specification document.
  prefs: []
  type: TYPE_NORMAL
- en: Optimal Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After learning about the benefits of indexes, you might be wondering if we can
    create indexes on all fields and their various combinations. However, indexes
    have some overheads as well. Each index requires a dedicated index registry, which
    stores a subset of data in memory or on the disk. Too many indexes consume a lot
    of space. Hence, before adding indexes to the collection, we should first analyze
    the requirements, listing the use cases and the possible queries our application
    will be executing. Then, based on this information, a minimal number of indexes
    should be created.
  prefs: []
  type: TYPE_NORMAL
- en: Although indexes make queries faster, they slow down every write operation on
    the collection. Because of indexes, every write operation on the collection involves
    the overhead of updating the respective index registries. Whenever documents are
    added, removed, or updated in a collection, all the respective index registries
    need to be updated, rescanned, and resorted, which takes longer than the actual
    collection write operations. Hence, before deciding to use indexes, it is recommended
    to check whether the database operations are read-heavy or write-heavy. For write-heavy
    collections, indexes are an overhead, hence they should be created only after
    a careful evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: In short, indexes have their benefits as well as overheads. A higher number
    of indexes generally means faster read operations and slower write operations.
    Hence, we should always use indexes in an optimal fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Optimizing a Query'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine your organization has retail stores throughout the world. Details about
    all the items sold are stored in a MongoDB database. The data analytics team uses
    the sales data to identify the purchase trends of different customers based on
    their age and location. Recently, one of the team members has complained about
    the performance of a query they wrote. The query, which is shown in the following
    snippet, queries the `sales` collection to find the email address and age of the
    customers who have purchased one or more backpacks in the Denver store. Then,
    it sorts the results in descending order of the customers'' ages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Your task for this activity is to analyze the given query, identify the problems,
    and create correct indexes to make it faster. The following steps will help you
    complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the `sample_supplies` dataset using mongo shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the query execution stats and identify the problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create correct indexes on the collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze the query performance again to see if the problems are fixed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15507_Solution_Final_SZ_ePub.xhtml#_idTextAnchor477).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you practiced improving query performance. You first explored
    the internal workings of query execution and the query execution stages. You then
    learned how to analyze a query's performance and identify any existing problems
    based on the execution statistics. Next, you reviewed the concept of indexes;
    how they solve performance issues for a query; various ways to create, list, and
    delete indexes; different types of indexes; and their properties. In the final
    sections of this chapter, you studied query optimization techniques and got a
    brief look at the overheads associated with indexes. In the next chapter, you
    will learn about the concept of replication and how it is implemented in Mongo.
  prefs: []
  type: TYPE_NORMAL
