- en: Penetrating the Target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have gathered information through some detective work, scanned a
    target to learn about where the live targets are and what they have left open,
    before trying to extract more detailed information through enumeration. During
    this process, we learned quite a bit, but we still have further to go as we learn
    more about both the process and how Kali NetHunter can assist us. We are now moving
    into the step where we actually put the penetration in penetration test by attempting
    to gain access to the target itself. Everything up to this point has allowed us
    to plan, learn, and prepare to make a successful attempt at entry.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to gain access to a host and, if we have played our cards right
    so far, the information we have accumulated will help us. When we gain access
    to a system, there are a seemingly endless number of ways to accomplish this,
    but we will limit our focus to a handful of these and show how Kali Nethunter
    may be helpful in carrying them out. Expect to carry out various tasks during
    this part of the process, which is designed to crack or recover passwords, escalate
    privileges, execute applications, hide files, cover tracks, and otherwise conceal
    evidence of your actions. It's all in a day's work, so let's fire Kali Nethunter
    up and get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an approach to cracking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing applications on the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing confidential information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password-cracking techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escalating privileges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running backdoors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need Kali NetHunter (the default installation is
    OK).
  prefs: []
  type: TYPE_NORMAL
- en: Concerning passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular first step to take in order to acquire access to a system is to just
    use a password that you have obtained for an account on the system. Of course,
    obtaining this password is the important part as you must find a way to obtain
    a password for a valid account. This is where a process known as password-cracking
    or password-recovery comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: So, what's the definition of the term *password-cracking*? Well, despite what
    movies and TV have to say about the topic, password-cracking is a catchall term
    for a group of techniques used to gain possession of this piece of information.
    You can expect to use any individual, or combination of, methods during the process—each
    of which has its pros and cons. You can guess a password blindly or you may have
    some information about the system owner that may make the guessing process easier.
    Other techniques to obtain passwords may involve repeatedly guessing or exploiting
    security weaknesses in a system.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an approach to cracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To make things easier, let''s break password-cracking down into a few major
    categories that we can then sort our techniques into. We will sort out the techniques
    into categories based on method of operation as the main characteristic. Be aware
    that each category and the techniques within offer not only unique approaches,
    but their own pros and cons, which we will discuss as we encounter them. The following
    diagram displays a breakdown of password-cracking attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/cafd3606-58a5-4cab-bbf5-4e6d54640049.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The categories of password cracking techniques are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive techniques**: Anything in this category is an attack carried out
    simply by listening and avoiding direct interaction with the target. Offline password
    attacks are designed to exploit inherent design flaws and defects in the way the
    passwords are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Direct techniques**: This technique requires more aggressive and direct interaction
    with the target. These types of attack can be very effective, but the risk of
    detection is higher.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first category, we have those techniques that adopt the low-risk approach
    of patiently waiting. How effective the process and end result turn out to be,
    depends on the approach used, the strength of the password and the system being
    targeted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sniffing** is a very effective method of gaining information, as you are
    simply plugging into a network and turning on a sniffer that will observe and
    capture the information as it flows across in the stream of packets. What makes
    this technique particularly effective is if you are targeting credentials that
    are transmitted over the network using an unsecured method, such as an older networking
    protocol such as File Transfer Protocol (FTP), Telnet, or Simple Mail Transfer
    Protocol (SMTP). Many of these long-lived and commonly-used protocols find themselves
    vulnerable as they lack any appreciable protection on their own. An example would
    be HTTP, which sends information in clear text, and you can use a tool such as
    Wireshark to sniff packets and view the content inside packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/178a9a21-21d2-4dd1-b569-dc0cd3f17d26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows where a sniffer can be placed on a network.
  prefs: []
  type: TYPE_NORMAL
- en: Man-in-the-Middle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building on the principle of sniffing, we have the **Man-in-the-Middle** (**MITM**)
    attack. This attack occurs when two devices are actively communicating and a third
    device moves from listening in to become an active participant. The following
    diagram shows the concept of an MITM attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/d5c37dd6-2830-4330-a9eb-d7ac15a17dcc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This type of attack is useful in capturing network traffic and protocols. However,
    some protocols have been found to be vulnerable as well, such as the Secure Sockets
    Layer (SSL) that is used to secure many e-commerce and similar applications.
  prefs: []
  type: TYPE_NORMAL
- en: Within Kali NetHunter, you will find a few tools able to assist you in the process
    of executing an MITM, such as SSL strip and Burp Suite. In order to demonstrate
    an MITM, let's use SSL strip.
  prefs: []
  type: TYPE_NORMAL
- en: SSL is a widely-used standard that came into existence in the early 1990s and
    has been publicly available from 1995\. The latest version of the protocol is
    SSL 3.0, which was deprecated in mid-2015 and should no longer be used due to
    successful compromises, such at the publicized POODLE attack. To ensure secure
    communications, SSL should be replaced with the newer **Transport Layer Security**
    (**TLS**) version 1.2 in order to maintain the strongest possible level of security.
  prefs: []
  type: TYPE_NORMAL
- en: So, before we get into the actual attack, let's go over a few details in order
    to fully appreciate it.
  prefs: []
  type: TYPE_NORMAL
- en: The **Address Resolution Protocol** (**ARP**) poisoning, will make use of the
    ARP protocol (which associates an IP address with a specific MAC address if you
    recall from your basic network experience) to make the systems we are targeting
    believe we are the router (when we are not).
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using ARP poisoning, we are using falsified ARP messages across
    the network with the goal of changing the ARP cache on systems. Under normal conditions,
    when a system sends out an ARP request, it is looking for the MAC address that
    corresponds to the given IP address. When responded to, the return message will
    include the IP address and MAC address of the system that matches the request,
    which will then be cached in the requester's system. When we poison these caches,
    we send a message out that rewrites the cache with a different MAC address, which
    will route the traffic differently to that which the network owner would have
    intended. This has the effect of directing traffic in a myriad of different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Through this simple act, clients will forward their traffic to our system, where
    we can perform our MITM before forwarding it on, instead of sending it to the
    actual router.
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic analysis**: Behind the scenes, we are using SSL strip to detect requests
    made to URLs using the SSL protocol as they flow through our system. Traffic that
    matches our criteria will be intercepted and modified.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intercepting and altering requests**: Essentially, when it comes down to
    an SSL strip detecting a request, it is stripping off the SSL and then altering
    the request or simply gathering information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we put it all together, we can see what is occurring when an SSL strip
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: The attacker makes themselves appear as the router by spoofing the router's
    MAC address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clients make requests to websites or other locations using SSL as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Requests that should go directly to the router, instead go to the attacker's
    impersonated system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An SSL strip (running on the attacker's system) observes traffic and looks for
    any requests destined for a location using SSL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When an SSL request is made, it is instead stripped of its protection and the
    private information retrieved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request then has its SSL layer reapplied and forwarded to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The server responds and sends the SSL-protected content back to the attacker,
    who strips the SSL off of the request and gathers the return information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The response is then returned to the client who is none the wiser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let's make it happen with SSL strip.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – working with SSL strip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things ready for SSL strip, we need to set a few things up ahead of
    time—fortunately, we already have the skills to do so. We are going to set up
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: IP forwarding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP table for redirect `80` to `8080`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a gateway IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding a target IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arpspoof
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps should be performed to set up IP forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following at the Terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up a redirect to redirect requests from port `80` to `8080`. From the Terminal
    window, issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Discover the router IP by typing the following at the Terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Choose a target from the list. In order to target a client, we need to locate
    one and get its IP. You can do this through the use of nmap, sniffing, or through
    other means. Once you have this IP, move to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Redirect traffic through the attacking computer that is hosting SSL Strip using
    the following at the Terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Leave the Terminal window open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up a second Terminal window and leave the first open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `sslstrip` by typing `sslstrip -l 8080` at the second Terminal window;
    this will tell `sslstrip` to listen (via the `-l` switch) on port `8080`. If you
    look back at our earlier steps, we redirected to port 8080 so we are observing
    traffic going to the port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the target system (the one you found in *step 4*), open up a website that
    uses SSL (you can tell via the `https` in the site's address). Sites such as Gmail
    is an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visitthe site and enter the credentials for your account or other item; you
    will notice that data being captured on the sslstrip system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capture some traffic on the Kali NetHunter system, switch to the window running
    sslstrip, and press *Ctrl* + *C* to stop the process and automatically write the
    results to a file named `sslstrip.log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results can be opened in any text editor, such as nano.
  prefs: []
  type: TYPE_NORMAL
- en: Active techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Active password-cracking techniques are done directly on or against the target
    system. The disadvantage of using this type of technique is that it increases
    the chances of being detected.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ncrack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One method of carrying out this type of attack is to use the Ncrack utility
    included with Kali NetHunter. This utility was designed to audit hosts on a network
    for poor passwords that could be potentially leveraged in an attack against a
    host or networking device. The utility is command-line-based, which allows for
    the use of different combinations of switches and options designed to refine the
    cracking process. Additionally, the utility supports many major protocols and
    services, including RDP, SSH, HTTP(S), SMB, POP3(S), VNC, FTP, SIP, Redis, PostgreSQL,
    MySQL, and Telnet.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – working with Ncrack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use Ncrack, we can take the information we have been gathering
    so far on live systems, port scans, and usernames to get things started:'
  prefs: []
  type: TYPE_NORMAL
- en: Find a live system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for ports that have a service running on them that Ncrack supports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a banner grab against the port using telnet or your banner-grabbing
    tool of choice (such as nmap) to fingerprint the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use any usernames, such as those you gathered from SMTP enumeration, and save
    them to a text file. Save the file with a name you can remember, such as `usernames.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second text file with the passwords you want to try. You can alternatively
    download this file from the internet by locating one with a simple search for
    `password lists` or `word lists`. Save this to a text file named something that
    you can remember, such as `passwords.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have this completed, we can use Ncrack to see what results we can scare
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-vv` to increase the output details while the command is running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-U` to specify the file with the usernames to try.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P` to specify the file with the passwords to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address with the port for the Ncrack-supported service to target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CL` to specify how many connections to open simultaneously with the target.
    More connections may increase the speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the command is successful for an account, your results will be printed onscreen,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the username is `schmuck` and the password is `aesop`.
  prefs: []
  type: TYPE_NORMAL
- en: Offline attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Offline attacks** are not done directly on the target but rather on the attacker''s
    system itself. Offline password-cracking is very CPU-intensive.'
  prefs: []
  type: TYPE_NORMAL
- en: Rainbow tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One very effective demonstration of the functioning and power of offline attacks
    is through a technique known as rainbow tables. This type of attack utilizes pre-computed
    hashes of all the different combinations of characters created using a given hashing
    method. In practice, the rainbow table will be created by the pentester, who will
    choose the parameters for creating the hashes. For example, parameters defining
    the minimum and maximum length of the password, as well as character sets and
    hashing types, will be defined. The result will be a table that can be used to
    find the correct password.
  prefs: []
  type: TYPE_NORMAL
- en: So how do we find the correct password using the table? Simple! We retrieve
    a hashed password from the local storage of the victim or capture it off the wire
    using sniffing.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of rainbow tables is that they must be generated prior to executing
    the attempt to recover the password. One other failing of rainbow tables is that
    the longer the password you are attempting to recover becomes, the larger the
    resulting table and the more time it takes to generate it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – creating the rainbow table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in utilizing the rainbow table cracking method is to actually
    create the table itself. To do this, we will make use of `rtgen` to generate the
    table with the parameters we specify.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – working with rtgen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the `rtgen` command, we must open a Terminal window and provide the
    desired parameters. The following is a list of the options available with `rtgen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to generate a rainbow table, we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When creating rainbow tables, each table is specific for a given hash type,
    such as MD5 or SHA1\. The `rtgen` program supports many hashing algorithms, such
    as MD5 and SHA1.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we generated SHA1 rainbow tables that will speed up
    cracking SHA1 hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the command has executed, you will be left with files with the .rt extension
    in the folder where you executed the command. The next step is to sort the files
    by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will sort the files before we use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will recover the password using one of the following commands. Here''s
    the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This command will attempt to recover the password for the hash provided.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To successfully crack a password, you must have a plan; just stumbling through
    different techniques may bear "fruit" but they are more likely to be not only
    unsuccessful, but may get you detected in the process. So, let's think of a strategy
    to use with our powerful tools within Kali NetHunter.
  prefs: []
  type: TYPE_NORMAL
- en: First, you should understand that the hashes that will most likely be the target
    of your password-cracking attempts will exist in different places depending on
    your approach and the target environment.
  prefs: []
  type: TYPE_NORMAL
- en: In environments with Microsoft Windows, these locations are the SAM file, which
    exists on local computer filesystems and also within Active Directory if the environment
    uses a domain.
  prefs: []
  type: TYPE_NORMAL
- en: Those environments that are either based on Linux or UNIX environments, and
    typically have their hashes stored in a different location entirely. These systems
    store their hashes in a location known as `/etc/shadow`, which is again on a local
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In both situations, the hashes are, as is the design of hashes, one-way encryption
    that generates a unique output or fingerprint for each password. Of course, even
    though a hash isn't reversible, we have already explained that a rainbow table
    may be employed to look up what created a hash; however, there is a problem that
    hasn't been addressed. This problem is that there are multiple hashing algorithms
    and the same input will produce different results on each. So we need to identify
    the hash algorithm before we can go too far; fortunately, we have ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Linux-based systems use the well-known MD5 algorithm, while Windows
    systems make use of HMAC-MD5, and some other technologies make use of SHA1, MD4,
    NTLM, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to use a tool in Kali NetHunter Linux known as hash-identifier.
    This tool can be run simply by opening up a command prompt in Kali NetHunter and
    entering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The hash-identifier tool will proceed to attempt to identify the hash and list
    out the possible types.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use the John the Ripper password-cracker (which is also
    included with Kali Nethunter). In other popular password-cracking tools, however,
    automatic detection is not an option so the hash type must be specified, hence
    the need for hash-identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – recovering passwords with hashcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recover our first set of passwords by using Kali NetHunter Linux and hashcat.
    **Hashcat** is known as one of the fastest CPU-based password-recovery tools available.
    While initially proprietary, the software is now completely free and widely used
    not just in Linux, but in OS X and Windows. It also comes with a version that
    can harness the CPU of a system, but also has the ability to make use of a faster
    Graphic Processing Unit (GPU). Examples of hashcat-supported hashing algorithms
    are Microsoft's LM hashes, MD4, MD5, SHA-family, Unix Crypt formats, MySQL, Cisco
    PIX.
  prefs: []
  type: TYPE_NORMAL
- en: To get the process of password-cracking started in Kali NetHunter, go to `Applications`
    | `Kali Nethunter Linux` | `Password Attacks` | `Offline Attacks` | `hashcat`.
  prefs: []
  type: TYPE_NORMAL
- en: This will open the terminal window with some help information displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the screen, you will see the hashcat syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Some of the most important of these are -m (the hashtype) and -a (attack mode).
  prefs: []
  type: TYPE_NORMAL
- en: Let's dissect hashcat's syntax and options of importance that are available
    to customize and tweak the process of cracking with hashcat. These rules can take
    a wordlist file that you have created and apply capitalization rules, special
    characters, word combinations, and appended and prepended numbers. Each of these
    techniques will make the breaking of more complex passwords more likely. In fact,
    hashcat will let you customize the custom character sets and options that are
    used to attempt recovery of the password(s) on a target.
  prefs: []
  type: TYPE_NORMAL
- en: You will also be presented with the requirement to choose the type of hash being
    cracked. It can be done if you know the hashing type on the system you are targeting
    or have used a hash identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to choose the type of hash we are attempting to crack. Hashcat
    gives us numerous options. When we get ready to target the hash, you will designate
    the type of hash that is being targeted by choosing it (by number) from a list
    that hashcat presents.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download a wordlist from online or you can search your Kali NetHunter
    system using the locate command to find the built-in wordlists in the product.
    You can do this using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are ready with hashcat and a wordlist, we can start by grabbing some
    hashes. In Linux, we can grab these by logging in as root and looking in `/etc/shadow`
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can see the shadow file with the hashes, once this command has executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information in hand, we now need to determine what type of hashing
    is in use by the system. Fortunately, we can do that fairly easily by issuing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Navigate about 80% of the way down the file by tapping the enter key until you
    see an entry labeled `ENCRYPT_METHOD`, which will be followed by a value that
    is typically SHA512\. This is important, as hashcat will need this information
    to reveal the hashes.
  prefs: []
  type: TYPE_NORMAL
- en: With knowledge of where the hashes are located, along with the hashing algorithm
    that is used by the system, it is now possible to start the process of cracking
    the hashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want to place the hashes into a file we will name `hash.lst`, which
    we create by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to ensure that everything was copied over, let''s issue the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If everything completed successfully, you should see that the hashes have been
    copied over to the `hash.lst` file as intended.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can attempt to crack the hashes in this file, we need to strip out
    some information to clean things up. Basically, we are going to remove anything
    that isn't a hash. By default, the file will include username information, which
    is not needed during this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to ensure that the process will be successful, you will need to remove
    the username and the colon immediately proceeding the username. After you have
    removed this, you will then remove everything: go to the end of the line and strip
    out anything that starts with a colon. In order to explain things further, let''s
    consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/504103ce-036e-4788-b546-5109b1361578.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to clean this up a bit to display only the highlighted hash values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](img/a0ecead2-3a40-417c-9d9b-17f1600db71d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the final step, you can now start the process of cracking the hashes. Here''s
    the command to initiate this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`-m 1800` designates the type of hash we are cracking (SHA-512).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a 0` designates a dictionary attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o cracked.txt` is the output file for the cracked passwords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--remove` tells hashcat to remove the hash after it has been cracked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hash.lst` is our input file of hashes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/share/sqlmap/txt/wordlist.txt` is the absolute path to our word list
    for this dictionary attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the cracking process is underway, you can see how things are proceeding
    by pressing *Enter*. This process will take varying periods of time, depending
    on the power of your Android device and what else you have running on the system
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Executing applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss how you can run applications remotely and what
    you can do with that power.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a pentester, you should have a good or definite idea of what you will be
    doing at this point, such as running an application or performing. Need to carry
    out tasks such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Backdoors**: After compromising a system, a hacker would create multiple
    doorways into the compromised computer. This is to ensure the attacker always
    has a way into the computer, whether it''s for remote access purposes or to exfiltrate
    data. This is known as a Backdoor. Backdoors are usually created when a Trojan
    virus installs itself on a host computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keyloggers**: This is a software- or hardware-based device that has the capability
    of recording keystrokes from a user keyboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escalating privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After compromising an operating system, such as Windows, you would have limited
    privileges on the system. This means if you try to execute certain commands or
    run applications, the built-in security will deny such actions. If you're able
    to compromise a user account, it might be a standard user with limited privileges
    as well. As a penetration tester, we would like the ability to execute any command
    and applications on a victim machine without any sort of restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, depending on the objectives of the penetration test, you may be required
    to gain "administrator" privileges in a Windows environment, or root-level access
    on Linux-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Executing applications on the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once access is gained and sufficient privileges obtained, it becomes time to
    execute applications on the victim. Which types of applications or actions are
    executed at this point is something that you will have to decide, but the field
    is wide open as to what you could do.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – planting a backdoor with Netcat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Netcat** is like a Swiss Army knife in the TCP/IP stack. It''s a very popular
    networking tool that provides networking and security professionals with many
    features; some of these features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Able to read and write data over a networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to transfer files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open service ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct port-scanning and banner-grabbing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netcat is not specific to an operating system; it's available to both Windows
    and Linux platforms. In this section, we will look at a few examples and usage
    of Netcat.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to another machine, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To listen for inbound connections, issue the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Simply replace the port number with any unused, valid port on the remote system.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the system that you wish to connect from, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command says to contact the remote system and then connect to the port
    that you have told `nc` to listen to on the remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go a little further.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's create a backdoor on the target system that we can make use of whenever
    we desire. The command will vary slightly based on whether you happen to be targeting
    a Linux or Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For Linux, we use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In both of these commands, the -e switch is used to execute a command when
    the machine is connected to a command shell. This means that we will be presented
    with a shell locally that we can use to pipe commands to the remote system. Then,
    on our attacking system, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: At this point, if you executed the command successfully, you would see a command
    prompt that allows you to interact with the remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Netcat can also be used to exfiltrate files and data from the target. We can
    use a stealth connection to slowly copy that data over to our local system. In
    this example, we will exfiltrate a file called `passwords.xls`, presumably an
    Excel file with passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the source system, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This command says to display the `passwords.xls` file and then pipe (`|`) it
    to netcat (nc) to the `192.168.1.104` remote IP address through port `6996`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the destination system, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command says to create a listener (`l`) on port (`p`) `6996` and then send
    the data received on this listener to a file named `passwords.xls`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started things off by looking at how to utilize information gathered during
    the previous steps for a target. Information from previous chapters was gathered
    with measured, but increasing, levels of direct interaction with a target. The
    intention was to gain additional information that we could use to compromise a
    system while attempting to be less intrusive.
  prefs: []
  type: TYPE_NORMAL
- en: We typically start with cracking or recovering a password to gain access to
    an account before attempting to gain additional access to a system through privilege
    escalation. With this increased access, it is possible to carry out more intrusive
    tasks. Common actions that an attacker may attempt to carry out typically include
    installing software, installing remote software, or creating other backdoors for
    later access.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will learn about clearing tracks and removing evidence
    from a target system.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the Kali Linux/Kali NetHunter tools list at: [http://tools.kali.org](http://tools.kali.org).
  prefs: []
  type: TYPE_NORMAL
