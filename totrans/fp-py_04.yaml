- en: Chapter 4. Working with Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a number of functions that process whole collections. They can
    be applied to sequences (lists or tuples), sets, mappings, and iterable results
    of generator expressions. We'll look at some of Python's collection-processing
    functions from a functional programming viewpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start out by looking at iterables and some simple functions that work
    with iterables. We'll look at some additional design patterns to handle iterables
    and sequences with recursion as well as explicit `for` loops. We'll look at how
    we can apply a `scalar()` function to a collection of data with a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll show examples of how to use the following functions
    to work with collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`any()` and `all()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len()` and `sum()` and some higher-order statistical processing related to
    these functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip()` and some related techniques to structure and flatten lists of data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reversed()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first four functions can all be called reductions; they reduce a collection
    to a single value. The other three functions (`zip()`, `reversed()`, and `enumerate()`)
    are mappings; they produce a new collection from an existing collection(s). In
    the next chapter, we'll look at some `mapping()` and `reduction()` functions that
    use an additional function as an argument to customize their processing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll start out by looking at ways to process data using generator
    expressions. Then, we'll apply different kinds of collection-level functions to
    show how they can simplify the syntax of iterative processing. We'll also look
    at some different ways of restructuring data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll focus on using higher-order collection functions
    to do similar kinds of processing.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of function varieties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to distinguish between two broad species of functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar functions apply to individual values and compute an individual result.
    Functions such as `abs()`, `pow(),` and the entire `math` module are examples
    of scalar functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection()` functions work with iterable collections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can further subdivide the collection functions into three subspecies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduction**: This uses a function that is used to fold values in the collection
    together, resulting in a single final value. We can call this an aggregate function,
    as it produces a single aggregate value for an input collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping**: This applies a function to all items of a collection; the result
    is a collection of the same size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filter**: This applies a function to all items of a collection that rejects
    some items and passes others. The result is a subset of the input. A filter might
    do nothing, which means that the output matches the input; this is an improper
    subset, but it still fits the broader definition of subset.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll use this conceptual framework to characterize ways in which we use the
    built-in collection functions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we noted in the previous chapters, we'll often use Python's `for` loop to
    work with collections. When working with materialized collections such as tuples,
    lists, maps, and sets, the `for` loop involves an explicit management of state.
    While this strays from purely functional programming, it reflects a necessary
    optimization for Python. If we assure that state management is localized to an
    iterator object that's created as part of the `for` statement evaluation, we can
    leverage this feature without straying too far from pure, functional programming.
    For example, if we use the `for` loop variable outside the indented body of `loop`,
    we've strayed too far from purely functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: We'll return to this in [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"),
    *Recursion and Reduction*. It's an important topic, and we'll just scratch the
    surface here with a quick example of working with generators.
  prefs: []
  type: TYPE_NORMAL
- en: One common application of `for` loop iterable processing is the `unwrap(process(wrap(iterable)))`
    design pattern. A `wrap()` function will first transform each item of an iterable
    into a two tuples with a derived sort key or other value and then the original
    immutable item. We can then process these two tuples based on the wrapped value.
    Finally, we'll use an `unwrap()` function to discard the value used to wrap, which
    recovers the original item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This happens so often in a functional context that we have two functions that
    are used heavily for this; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These two functions pick the first and second values from a tuple, and both
    are handy for the `process()` and `unwrap()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Another common pattern is `wrap(wrap(wrap()))`. In this case, we're starting
    with simple tuples and then wrapping them with additional results to build up
    larger and more complex tuples. A common variation on this theme is `extend(extend(extend()))`
    where the additional values build new, more complex `namedtuple` instances without
    actually wrapping the original tuples. We can summarize both of these as the Accretion
    design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: We'll apply the Accretion design to work with a simple sequence of latitude
    and longitude values. The first step will convert the simple points (`lat`, `lon`)
    on a path into pairs of legs (`begin`, `end`). Each pair in the result will be
    ((`lat`, `lon`), (`lat`, `lon`)).
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we'll show how to create a generator function that will
    iterate over the content of a file. This iterable will contain the raw input data
    that we will process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the data, later sections will show how to decorate each leg with
    the **haversine** distance along the leg. The final result of the `wrap(wrap(iterable())))`
    processing will be a sequence of three tuples: ((`lat`, `lon`), (`lat`, `lon`),
    `distance`). We can then analyze the results for the longest, shortest distance,
    bounding rectangle, and other summaries of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing an XML file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll start by parsing an **XML** (short for **Extensible** **Markup** **Language**)
    file to get the raw latitude and longitude pairs. This will show how we can encapsulate
    some not-quite functional features of Python to create an iterable sequence of
    values. We'll make use of the `xml.etree` module. After parsing, the resulting
    `ElementTree` object has a `findall()` method that will iterate through the available
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be looking for constructs such as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The file will have a number of `<Placemark>` tags, each of which has a point
    and coordinate structure within it. This is typical of **Keyhole Markup Language**
    (**KML**) files that contain geographic information.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing an XML file can be approached at two levels of abstraction. At the lower
    level, we need to locate the various tags, attribute values, and content within
    the XML file. At a higher level, we want to make useful objects out of the text
    and attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lower-level processing can be approached in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This function requires a file that was already opened, usually via a `with`
    statement. However, it can also be any of the file-like objects that the XML parser
    can handle. The function includes a simple static `dict` object, `ns_map`, that
    provides the `namespace` mapping information for the XML tags we'll be searching.
    This dictionary will be used by the `XML` `ElementTree.findall()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of the parsing is a generator function that uses the sequence of
    tags located by `doc.findall()`. This sequence of tags is then processed by a
    `comma_split()` function to tease the text value into its comma-separated components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `comma_split()` function is the functional version of the `split()` method
    of a string, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We've used the functional wrapper to emphasize a slightly more uniform syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this function is an iterable sequence of rows of data. Each row
    will be a tuple composed of three strings: `latitude`, `longitude`, and `altitude`
    of a waypoint along this path. This isn''t directly useful yet. We''ll need to
    do some more processing to get `latitude` and `longitude` as well as converting
    these two numbers into useful floating-point values.'
  prefs: []
  type: TYPE_NORMAL
- en: This idea of an iterable sequence of tuples as results of lower-level parsing
    allows us to process some kinds of data files in a simple and uniform way. In
    [Chapter 3](ch03.html "Chapter 3. Functions, Iterators, and Generators"), *Functions,
    Iterators, and Generators*, we looked at how **Comma** **Separated** **Values**
    (**CSV**) files are easily handled as rows of tuples. In [Chapter 6](ch06.html
    "Chapter 6. Recursions and Reductions"), *Recursions and Reductions*, we'll revisit
    the parsing idea to compare these various examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the preceding function looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each row is the source text of the `<ns0:coordinates>` tag split using `,` that's
    part of the text content. The values are the East-West longitude, North-South
    latitude, and altitude. We'll apply some additional functions to the output of
    this function to create a usable set of data.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a file at a higher level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we've parsed the low-level syntax, we can restructure the raw data into
    something usable in our Python program. This kind of structuring applies to XML,
    **JavaScript Object Notation** (**JSON**), CSV, and any of the wide variety of
    physical formats in which data is serialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll aim to write a small suite of generator functions that transforms the
    parsed data into a form our application can use. The generator functions include
    some simple transformations on the text that''s found by the `row_iter_kml()`
    function, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Discarding `altitude`, or perhaps keeping only `latitude` and `longitude`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the order from (`longitude`, `latitude`) to (`latitude`, `longitude`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can make these two transformations have more syntactic uniformity by defining
    a utility function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This function will apply the `pick_lat_lon()` function to each row. We've used
    `*row` to assign each element of the row three tuple to separate parameters of
    the `pick_lat_lon()` function. The function can then extract and reorder the two
    relevant values from each three tuple.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that a good functional design allows us to freely replace
    any function with its equivalent, which makes refactoring quite simple. We've
    tried to achieve this goal when we provide alternative implementations of the
    various functions. In principle, a clever functional language compiler might do
    some replacements as part of an optimization pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the following kind of processing to parse the file and build a structure
    we can use, such as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `urllib` command to open a source. In this case, it's a local
    file. However, we can also open a KML file on a remote server. Our objective with
    using this kind of file opening is to assure that our processing is uniform no
    matter what the source of the data is.
  prefs: []
  type: TYPE_NORMAL
- en: We've shown the two functions that do low-level parsing of the KML source. The
    `row_iter_kml(source)` expression produces a sequence of text columns. The `lat_lon_kml()`
    function will extract and reorder the `latitude` and `longitude` values. This
    creates an intermediate result that sets the stage for further processing. The
    subsequent processing is independent of the original format.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this, we see results like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've extracted just the `latitude` and `longitude` values from a complex XML
    file using an almost purely functional approach. As the result is an iterable,
    we can continue to use functional programming techniques to process each point
    that we retrieve from the file.
  prefs: []
  type: TYPE_NORMAL
- en: We've explicitly separated low-level XML parsing from higher-level reorganization
    of the data. The XML parsing produced a generic tuple of string structure. This
    is compatible with the output from the CSV parser. When working with **SQL** databases,
    we'll have a similar iterable of tuple structures. This allows us to write code
    for higher-level processing that can work with data from a variety of sources.
  prefs: []
  type: TYPE_NORMAL
- en: We'll show a series of transformations to rearrange this data from a collection
    of strings to a collection of waypoints along a route. This will involve a number
    of transformations. We'll need to restructure the data as well as convert from
    `strings` to `floating-point` values. We'll also look at a few ways to simplify
    and clarify the subsequent processing steps. We'll use this data set in later
    chapters because it's reasonably complex.
  prefs: []
  type: TYPE_NORMAL
- en: Pairing up items from a sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common restructuring requirement is to make start-stop pairs out of points
    in a sequence. Given a sequence, ![Pairing up items from a sequence](graphics/B03652_04_01.jpg),
    we want to create a paired sequence ![Pairing up items from a sequence](graphics/B03652_04_02.jpg).
    When doing time-series analysis, we might be combining more widely separated values.
    In this example, it's adjacent values.
  prefs: []
  type: TYPE_NORMAL
- en: A paired sequence will allow us to use each pair to compute distances from point
    to point using a trivial application of a `haversine` function. This technique
    is also used to convert a path of points into a series of line segments in a graphics
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Why pair up items? Why not do something like this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This, clearly, will process each leg of the data as a begin-end pair. However,
    the processing function and the loop that restructures the data are tightly bound,
    making reuse more complex than necessary. The algorithm for pairing is hard to
    test in isolation because it's bound to the `compute_something()` function.
  prefs: []
  type: TYPE_NORMAL
- en: This combined function also limits our ability to reconfigure the application.
    There's no easy way to inject an alternative implementation of the `compute_something()`
    function. Additionally, we've got a piece of explicit state, the `begin` variable,
    which makes life potentially complex. If we try to add features to the body of
    `loop`, we can easily fail to set the `begin` variable correctly if a point is
    dropped from consideration. A `filter()` function introduces an `if` statement
    that can lead to an error in updating the `begin` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We achieve better reuse by separating this simple pairing function. This, in
    the long run, is one of our goals. If we build up a library of helpful primitives
    such as this pairing function, we can tackle problems more quickly and confidently.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to pair up the points along the route to create start and
    stop information for each leg. We'll look at a few here and then revisit this
    in [Chapter 5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions*
    and again in [Chapter 8](ch08.html "Chapter 8. The Itertools Module"), *The Itertools
    Module*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating pairs can be done in a purely functional way using a recursion. The
    following is one version of a function to pair up the points along a route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The essential function is the internal `pair_from()` function. This works with
    the item at the head of an iterable plus the iterable itself. It yields the first
    pair, pops the next item from the iterable, and then invokes itself recursively
    to yield any additional pairs.
  prefs: []
  type: TYPE_NORMAL
- en: We've invoked this function from the `pairs()` function. The `pairs()` function
    ensures that the initialization is handled properly and the terminating exception
    is silenced properly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python iterable recursion involves a `for` loop to properly consume and yield
    the results from the recursion. If we try to use a simpler-looking `return pair_from(nxt,
    iterable_tail)` method, we'll see that it does not properly consume the iterable
    and yield all of the values.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion in a generator function requires `yield` from a statement to consume
    the resulting iterable. For this, use `yield from recursive_iter(args)`.
  prefs: []
  type: TYPE_NORMAL
- en: Something like `return recursive_iter(args)` will return only a generator object;
    it doesn't evaluate the function to return the generated values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our strategy for performing tail-call optimization is to replace the recursion
    with a generator expression. We can clearly optimize this recursion into a simple
    `for` loop. The following is another version of a function to pair up the points
    along a route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The version is quite fast and free from stack limits. It's independent of any
    particular type of sequence, as it will pair up anything emitted by a sequence
    generator. As there's no processing function inside loop, we can reuse the `legs()`
    function as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of this function as one that yields the following kind of sequence
    of pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another view of this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While informative, these other two formulations only work for sequence objects.
    The `legs()` and `pairs()` functions work for any iterable, including sequence
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using the iter() function explicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purely functional viewpoint is that all of our iterables can be processed
    with recursive functions, where the state is merely the recursive call stack.
    Pragmatically, Python iterables will often involve evaluation of other `for` loops.
    There are two common situations: collections and iterables. When working with
    a collection, an iterator object is created by the `for` statement. When working
    with a generator function, the generator function is the iterator and maintains
    its own internal state. Often, these are equivalent from a Python programming
    perspective. In rare cases, generally those situations where we have to use an
    explicit `next()` function, the two won''t be precisely equivalent.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `legs()` function shown previously has an explicit `next()` function call
    to get the first value from the iterable. This works wonderfully well with generator
    functions, expressions, and other iterables. It doesn't work with sequence objects
    such as tuples or `lists`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are three examples to clarify the use of the `next()` and `iter()`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, we applied the `legs()` function to an iterable. In this
    case, the iterable was a generator expression. This is the expected behavior based
    on our previous examples in this chapter. The items are properly paired up to
    create two legs from three waypoints.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, we tried to apply the `legs()` function to a sequence. This
    resulted in an error. While a `list` object and an iterable are equivalent when
    used in a `for` statement, they aren't equivalent everywhere. A sequence isn't
    an iterator; it doesn't implement the `next()` function. The `for` statement handles
    this gracefully, however, by creating an iterator from a sequence automatically.
  prefs: []
  type: TYPE_NORMAL
- en: To make the second case work, we need to explicitly create an iterator from
    a `list` object. This permits the `legs()` function to get the first item from
    the iterator over the `list` items.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a simple loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have two kinds of extensions we might factor into a simple loop. We'll look
    first at a `filter` extension. In this case, we might be rejecting values from
    further consideration. They might be data outliers, or perhaps source data that's
    improperly formatted. Then, we'll look at mapping source data by performing a
    simple transformation to create new objects from the original objects. In our
    case, we'll be transforming `strings` to `floating-point` numbers. The idea of
    extending a simple `loop` with a mapping, however, applies to situations. We'll
    look at refactoring the above `pairs()` function. What if we need to adjust the
    sequence of points to discard a value? This will introduce a `filter` extension
    that rejects some data values.
  prefs: []
  type: TYPE_NORMAL
- en: As the loop we're designing simply returns pairs without performing any additional
    application-related processing, the complexity is minimal. Simplicity means we're
    somewhat less likely to confuse the processing state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a `filter` extension to this design might look something like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have plugged in a processing rule to reject certain values. As the `loop`
    remains succinct and expressive, we are confident that the processing will be
    done properly. Also, we can easily write a test for this function, as the results
    work for any iterable, irrespective of the long-term destination of the pairs.
  prefs: []
  type: TYPE_NORMAL
- en: The next refactoring will introduce additional mapping to a loop. Adding mappings
    is common when a design is evolving. In our case, we have a sequence of `string`
    values. We need to convert these to `floating-point` values for later use. This
    is a relatively simple mapping that shows the design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one way to handle this data mapping, through a generator expression
    that wraps a generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We've applied the `legs()` function to a generator expression that creates `float`
    values from the output of the `lat_lon_kml()` function. We can read this in the
    opposite order as well. The `lat_lon_kml()` function's output is transformed into
    a pair of `float` values, which is then transformed into a sequence of `legs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is starting to get complex. We''ve got a large number of nested functions
    here. We''re applying `float()`, `legs()`, and `tuple()` to a data generator.
    One common refactoring of complex expressions is to separate the generator expression
    from any materialized collection. We can do the following to simplify the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We've assigned the generator function to a variable named `flt`. This variable
    isn't a collection object; we're not using a `list` comprehension to create an
    object. We've merely assigned the generator expression to a variable name. We've
    then used the `flt` variable in another expression.
  prefs: []
  type: TYPE_NORMAL
- en: The evaluation of the `tuple()` method actually leads to a proper object being
    built so that we can print the output. The `flt` variable's objects are created
    only as needed.
  prefs: []
  type: TYPE_NORMAL
- en: There are other refactoring's we might like to do. In general, the source of
    the data is something we often want to change. In our example, the `lat_lon_kml()`
    function is tightly bound in the rest of the expression. This makes reuse difficult
    when we have a different data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case where the `float()` operation is something we''d like to parameterize
    so that we can reuse it, we can define a function around the generator expression.
    We''ll extract some of the processing into a separate function merely to group
    the operations. In our case, the string-pair to float-pair is unique to a particular
    source data. We can rewrite a complex float-from-string expression into a simpler
    function such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `float_from_pair()` function applies the `float()` function to the first
    and second values of each item in the iterable, yielding a two tuple of floats
    created from an input value. We've relied on Python's `for` statement to decompose
    the two tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this function in the following context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We're going to create `legs` that are built from `float` values that come from
    a KML file. It's fairly easy to visualize the processing, as each stage in the
    process is a simple prefix function.
  prefs: []
  type: TYPE_NORMAL
- en: When parsing, we often have sequences of `string` values. For numeric applications,
    we'll need to convert `strings` to `float`, `int`, or `Decimal` values. This often
    involves inserting a function such as the `float_from_pair()` function into a
    sequence of expressions that clean up the source data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our previous output was all strings; it looked like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want data like the following code snippet, where we have floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We'll need to create a pipeline of simpler transformation functions. Above,
    we arrived at `flt= ((float(lat), float(lon)) for lat,lon in lat_lon_kml())`.
    We can exploit the substitution rule for functions and replace a complex expression
    such as `(float(lat), float(lon)) for lat,lon in lat_lon_kml())` with a function
    that has the same value, in this case, `float_from_pair(lat_lon_kml())`. This
    kind of refactoring allows us to be sure that a simplification has the same effect
    as a more complex expression.
  prefs: []
  type: TYPE_NORMAL
- en: There are some simplifications that we'll look at in [Chapter 5](ch05.html "Chapter 5. Higher-order
    Functions"), *Higher-order Functions*. We will revisit this in [Chapter 6](ch06.html
    "Chapter 6. Recursions and Reductions"), *Recursions and Reductions* to see how
    to apply these simplifications to the file-parsing problem.
  prefs: []
  type: TYPE_NORMAL
- en: Applying generator expressions to scalar functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look cat a more complex kind of generator expression to map data values
    from one kind of data to another. In this case, we'll apply a fairly complex function
    to individual data values created by a generator.
  prefs: []
  type: TYPE_NORMAL
- en: We'll call these non-generator functions *scalar*, as they work with simple
    `scalar` values. To work with collections of data, a scalar function will be embedded
    in a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: To continue the example started earlier, we'll provide a `haversine` function
    and then use a generator expression to apply a scalar `haversine()` function to
    a sequence of pairs from our KML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `haversine()` function looks like following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is a relatively simple implementation copied from the **World** **Wide**
    **Web**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we might use our collection of functions to examine some
    KML data and produce a sequence of distances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The essence of the processing is the generator expression assigned to the `trip`
    variable. We've assembled three tuples with a start, end, and the distance from
    start to end. The start and end pairs come from the `legs()` function. The `legs()`
    function works with `floating-point` data built from the `latitude-longitude`
    pairs extracted from a KML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like the following command snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Each individual processing step has been defined succinctly. The overview, similarly,
    can be expressed succinctly as a composition of functions and generator expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, there are several further processing steps we might like to apply to
    this data. First, of course, is to use the `format()` method of a string to produce
    better-looking output.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, there are a number of aggregate values we'd like to extract
    from this data. We'll call these values reductions of the available data. We'd
    like to reduce the data to get the maximum and minimum latitude—for example, to
    show the extreme North and South ends of this route. We'd like to reduce the data
    to get the maximum distance in one leg as well as the total distance for all `legs`.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we'll have using Python is that the output generator in the `trip`
    variable can only be used once. We can't easily perform several reductions of
    this detailed data. We can use `itertools.tee()` to work with the iterable several
    times. It seems wasteful, however, to read and parse the KML file for each reduction.
  prefs: []
  type: TYPE_NORMAL
- en: We can make our processing more efficient by materializing intermediate results.
    We'll look at this in the next section. Then, we can see how to compute multiple
    reductions of the available data.
  prefs: []
  type: TYPE_NORMAL
- en: Using any() and all() as reductions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `any()` and `all()` functions provide `boolean` reduction capabilities.
    Both functions reduce a collection of values to a single `True` or `False`. The
    `all()` function assures that all values are `True`. The `any()` function assures
    that at least one value is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions are closely related to a universal quantifier and an existential
    quantifier used to express mathematical logic. We might, for example, want to
    assert that all elements in a given collection have some property. One formalism
    for this might look like following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using any() and all() as reductions](graphics/B03652_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''d read this as: *for all x in SomeSet, the function* ![Using any() and
    all() as reductions](graphics/B03652_04_04.jpg)  *is true*. We''ve put a quantifier
    in front of the logical expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we switch the order of the items slightly to transcribe the logic
    expression as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will evaluate each argument value (`isprime(x)`) and reduce the collection
    of values to a single `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `any()` function is related to the existential quantifier. If we want to
    assert that no value in a collection is prime, we might have something like one
    of the two equivalent expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using any() and all() as reductions](graphics/B03652_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first states that *it is not the case that all elements in SomeSet are prime*.
    The second version asserts that *there exists one element in SomeSet that is not
    prime*. These two are equivalent—that is, *if not all elements are prime, then
    one element must be non-prime*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can switch the order of the terms and transcribe these to working
    code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As they''re equivalent, there are two reasons for preferring one over the other:
    performance and clarity. The performance is nearly identical, so it boils down
    to clarity. Which of these states the condition the most clearly?'
  prefs: []
  type: TYPE_NORMAL
- en: The `all()` function can be described as an `and` reduction of a set of values.
    The result is similar to folding the `and` operator between the given sequence
    of values. The `any()` function, similarly, can be described as an `or` reduction.
    We'll return to this kind of general-purpose reduce when we look at the `reduce()`
    function in [Chapter 10](ch10.html "Chapter 10. The Functools Module"), *The Functools
    Module*.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to look at the degenerate case of these functions. What if the
    sequence has 0 elements? What are the values of `all(())` or `all([])`?
  prefs: []
  type: TYPE_NORMAL
- en: If we ask, "Are all elements in an empty set prime?", then what's the answer?
    As there are no elements, the question is a bit difficult to answer.
  prefs: []
  type: TYPE_NORMAL
- en: If we ask "Are all elements in an empty set prime and all elements in `SomeSet`
    prime?", we have a hint as to how we have to proceed. We're performing an `and`
    reduction of an empty set and an `and` reduction of `SomeSet`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using any() and all() as reductions](graphics/B03652_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It turns out that the `and` operator can be distributed freely. We can rewrite
    this to a union of the two sets, which is then evaluated for being prime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using any() and all() as reductions](graphics/B03652_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clearly, ![Using any() and all() as reductions](graphics/B03652_04_08.jpg).
    If we union an empty set, we get the original set. The empty set can be called
    the **union identify element**. This parallels the way 0 is the additive identity
    element: ![Using any() and all() as reductions](graphics/B03652_04_09.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, `any(())` must be the `or` identity element, which is `False`. If
    we think of the multiplicative identify element, 1, where ![Using any() and all()
    as reductions](graphics/B03652_04_10.jpg), then `all(())` must be `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate that Python follows these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Python gives us some very nice tools to perform processing that involves logic.
    We have the built-in `and`, `or`, and `not` operators. However, we also have these
    collection-oriented `any()` and `all()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using len() and sum()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `len()` and `sum()` functions provide two simple reductions: a count of
    the elements and the sum of the elements in a sequence. These two functions are
    mathematically similar, but their Python implementation is quite different.'
  prefs: []
  type: TYPE_NORMAL
- en: Mathematically, we can observe this cool parallelism. The `len()` function returns
    the sum of 1's for each value in a collection, X:![Using len() and sum()](graphics/B03652_04_11.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The `sum()` function returns the sum of *x* for each value in a collection,
    X:![Using len() and sum()](graphics/B03652_04_12.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The `sum()` function works for any iterable. The `len()` function doesn't apply
    to iterables; it only applies to sequences. This little asymmetry in the implementation
    of these functions is a little awkward around the edges of statistical algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For empty sequences, both of these functions return a proper additive identity
    element of 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Of course, `sum(())` returns an integer 0\. When other numeric types are used,
    the integer 0 will be coerced to the proper type for the available data.
  prefs: []
  type: TYPE_NORMAL
- en: Using sums and counts for statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definitions of the arithmetic mean have an appealingly trivial definition
    based on `sum()` and `len()`, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While elegant, this doesn't actually work for iterables. This definition only
    works for sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, we have a hard time performing a simple computation of mean or standard
    deviation based on iterables. In Python, we must either materialize a sequence
    object, or resort to somewhat more complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a fairly elegant expression of mean and standard deviation in the following
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These three sums, `s0`, `s1`, and `s2`, have a tidy, parallel structure. We
    can easily compute the mean from two of the sums. The standard deviation is a
    bit more complex, but it's still based on the three sums.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of pleasant symmetry also works for more complex statistical functions
    such as correlation and even least-squares linear regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The moment of correlation between two sets of samples can be computed from
    their standardized value. The following is a function to compute the standardized
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The calculation is simply to subtract the mean, `μ_x`, from each sample, `x`,
    and divide by the standard deviation, `σ_x`. This gives as a value measured in
    units of sigma, `σ`. A value ±1 σ is expected about two-thirds of the time. Larger
    values should be less common. A value outside ±3 σ should happen less than 1 percent
    of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this scalar function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We've materialized `list` that consists of normalized scores based on some raw
    data in the variable, `d`. We used a generator expression to apply the scalar
    function, `z()`, to the sequence object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mean()` and `stdev()` functions are simply based on the examples shown
    above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The three sum functions, similarly, are based on the examples above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: While this is very expressive and succinct, it's a little frustrating because
    we can't simply use an iterable here. We're computing a mean, which requires a
    sum of the iterable, plus a count. We're also computing a standard deviation that
    requires two sums and a count from the iterable. For this kind of statistical
    processing, we must materialize a sequence object so that we can examine the data
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we can compute the correlation between two sets of samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This correlation function gathers basic statistical summaries of the two sets
    of samples: the mean and standard deviation. Given these summaries, we defined
    two generator functions that will create normalized values for each set of samples.
    We can then use the `zip()` function (see the next example) to pair up items from
    the two sequences of normalized values and compute the product of those two normalized
    values. The average of the product of the normalized scores is the correlation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of gathering the correlation between two sets of
    samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've shown two sequences of data points, `xi` and `yi`. The correlation is
    over .99, which shows a very strong relationship between the two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: This shows one of the strengths of functional programming. We've created a handy
    statistical module using a half-dozen functions with definitions that are single
    expressions. The counterexample is the `corr()` function that can be reduced to
    a single very long expression. Each internal variable in this function is used
    just once; a local variable can be replaced with a copy-and-paste of the expression
    that created it. This shows us that the `corr()` function has a functional design
    even though it's written out in six separate lines of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Using zip() to structure and flatten sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `zip()` function interleaves values from several iterators or sequences.
    It will create *n* tuples from the values in each of the *n* input iterables or
    sequences. We used it in the previous section to interleave data points from two
    sets of samples, creating two tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `zip()` function is a generator. It does not materialize a resulting collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example that shows what the `zip()` function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of edge cases for the `zip()` function. We must ask the
    following questions about its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens where then are no arguments at all?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens where there's only one argument?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when the sequences are different lengths?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For reductions (`any()`, `all()`, `len()`, `sum()`), we want an identity element
    from reducing an empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, each of these edge cases must produce some kind of iterable output.
    Here are some examples to clarify the behaviors. First, the empty argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `zip()` function with no arguments is a generator function,
    but there won't be any items. This fits the requirement that the output is iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll try a single iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `zip()` function emitted one tuple from each input value.
    This too makes considerable sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll look at the different-length `list` approach used by the `zip()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This result is debatable. Why truncate? Why not pad the shorter list with `None`
    values? This alternate definition of `zip()` function is available in the `itertools`
    module as the `zip_longest()` function. We'll look at this in [Chapter 8](ch08.html
    "Chapter 8. The Itertools Module"), *The Itertools Module*.
  prefs: []
  type: TYPE_NORMAL
- en: Unzipping a zipped sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`zip()` mapping can be inverted. We''ll look at several ways to unzip a collection
    of tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can't fully unzip an iterable of tuples, since we might want to make multiple
    passes over the data. Depending on our needs, we might need to materialize the
    iterable to extract multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way is something we''ve seen many times; we can use a generator function
    to unzip a sequence of tuples. For example, assume that the following pairs are
    a sequence object with two tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will create two sequences. The `p0` sequence has the first element of each
    two tuple; the `p1` sequence has the second element of each two tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under some circumstances, we can use the multiple ssignment of a `for` loop
    to decompose the tuples. The following is an example that computes the sum of
    products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We used the `for` statement to decompose each two tuple into `p0` and `p1`.
  prefs: []
  type: TYPE_NORMAL
- en: Flattening sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we''ll have zipped data that needs to be flattened. For example,
    our input might be a file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can easily use `((line.split() for line in file)` to create a sequence of
    ten tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might heave data in blocks that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This isn't really what we want, though. We want to get the numbers into a single,
    flat sequence. Each item in the input is a ten tuple; we'd rather not wrangle
    with decomposing this one item at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a two-level generator expression, as shown in the following code
    snippet, for this kind of flattening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The two-level generator is confusing at first. We can understand this through
    a simple rewrite as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This transformation shows us how the generator expression works. The first `for`
    clause (`for line in data`) steps through each ten tuple in the data. The second
    `for` clause (`for x in line`) steps through each item in the first `for` clause.
  prefs: []
  type: TYPE_NORMAL
- en: This expression flattens a sequence-of-sequence structure into a single sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring flat sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we'll have raw data that is a flat list of values that we'd like
    to bunch up into subgroups. This is a bit more complex. We can use the `itertools`
    module's `groupby()` function to implement this. This will have to wait until
    [Chapter 8](ch08.html "Chapter 8. The Itertools Module"), *The Iterools Module*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a simple flat `list` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write nested generator functions to build a sequence-of-sequence structure
    from flat data. In order to do this, we''ll need a single iterator that we can
    use multiple times. The expression looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, we created an iterator that exists outside either of the two loops that
    we'll use to create our sequence-of-sequences. The generator expression uses `tuple(next(flat_iter)
    for i in range(5))` to create five tuples from the iterable values in the `flat_iter`
    variable. This expression is `nested` inside another generator that repeats the
    inner loop the proper number of times to create the required sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: This works only when the flat list is divided evenly. If the last row has partial
    elements, we'll need to process them separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this kind of function to group data into same-sized tuples, with
    an odd sized tuple at the end using the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We've created an initial `list` where each `tuple` is of the size `n`. If there
    are leftovers, we'll have a trailer `tuple` with a non-zero length that we can
    append to the `list` of full-sized items. If the trailer `tuple` is of the length
    0, we'll ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t as delightfully simple and functional-looking as other algorithms
    we''ve looked at. We can rework this into a pleasant-enough generator function.
    The following code uses a `while` loop as part of tail-recursion optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We've created a row of the required length from the input iterable. When we
    get to the end of the input iterable, the value of `tuple(next(iterable) for i
    in range(n))` will be a zero-length tuple. This is the base case of a recursion,
    which we've written as the terminating condition for a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring flat sequences—an alternative approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we have a simple, flat `list` and we want to create pairs from this
    list. The following is the required data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create pairs using list slices as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The slice `flat[0::2]` is all of the even positions. The slice `flat[1::2]`
    is all of the odd positions. If we zip these together, we get a two tuple of `(0)`,
    the value from the first even position, and `(1)`, the value from the first odd
    position. If the number of elements is even, this will produce pairs nicely.
  prefs: []
  type: TYPE_NORMAL
- en: This has the advantage of being quite short. The functions shown in the previous
    section are longer ways to solve the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can be generalized. We can use the `*(args)` approach to generate
    a sequence-of-sequences that must be zipped together. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate `n` slices: `flat[0::n]`, `flat[1::n]`, `flat[2::n]`, …,
    `flat[n-1::n]`. This collection of slices becomes the arguments to `zip()`, which
    then interleaves values from each slice.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that `zip()` truncates the sequence at the shortest `list`. This means
    that, if the `list` is not an even multiple of the grouping factor `n`, (`len(flat)%n
    != 0`), which is the final slice, won't be the same length as the others and the
    others will all be truncated. This is rarely what we want.
  prefs: []
  type: TYPE_NORMAL
- en: If we use the `itertools.zip_longest()` method, then we'll see that the final
    tuple will be padded with enough `None` values to make it have a length of `n`.
    In some cases, this padding is acceptable. In other cases, the extra values are
    undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: The `list` slicing approach to grouping data is another way to approach the
    problem of structuring a flat sequence of data into blocks. As it is a general
    solution, it doesn't seem to offer too many advantages over the functions in the
    previous section. As a solution specialized for making two tuples from a flat
    last, it's elegantly simple.
  prefs: []
  type: TYPE_NORMAL
- en: Using reversed() to change the order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times when we need a sequence reversed. Python offers us two approaches
    to this: the `reversed()` function and slices with reversed indices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example, consider performing a base conversion to hexadecimal or binary.
    The following is a simple conversion function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This function uses a recursion to yield the digits from the least significant
    to the most significant. The value of `x%b` will be the least significant digits
    of `x` in the base `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can formalize it as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using reversed() to change the order](graphics/B03652_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In many cases, we''d prefer the digits to be yielded in the reverse order.
    We can wrap this function with the `reversed()` function to swap the order of
    the digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `reversed()` function produces an iterable, but the argument value must
    be a sequence object. The function then yields the items from that object in the
    reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: We can do a similar kind of thing also with a slice such as `tuple(digits(x,
    b))[::-1]`. The slice, however, is not an iterator. A slice is a materialized
    object built from another materialized object. In this case, for such small collections
    of values, the distinction is minor. As the `reversed()` function uses less memory,
    it might be advantageous for larger collections.
  prefs: []
  type: TYPE_NORMAL
- en: Using enumerate() to include a sequence number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers the `enumerate()` function to apply index information to values
    in a sequence or iterable. It performs a specialized kind of wrap that can be
    used as part of an `unwrap(process(wrap(data)))` design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enumerate()` function transformed each input `item` into a pair with a
    sequence number and the original `item`. It''s vaguely similar to something as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: An important feature of `enumerate()` is that the result is an iterable and
    it works with any iterable input.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at statistical processing, for example, the `enumerate()` function
    comes in handy to transform a single sequence of values into a more proper time
    series by prefixing each sample with a number.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw detailed ways to use a number of built-in reductions.
  prefs: []
  type: TYPE_NORMAL
- en: We've used `any()` and `all()` to do essential logic processing. These are tidy
    examples of reductions using a simple operator such as `or` or `and`.
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at numeric reductions such as `len()` and `sum()`. We've applied
    these functions to create some higher-order statistical processing. We'll return
    to these reductions in [Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"),
    *Recursions and Reductions*.
  prefs: []
  type: TYPE_NORMAL
- en: We've also looked at some of the built-in mappings.
  prefs: []
  type: TYPE_NORMAL
- en: The `zip()` function merges multiple sequences. This leads us to look at using
    this in the context of structuring and flattening more complex data structures.
    As we'll see in examples in later chapters, nested data is helpful in some situations
    and flat data is helpful in others.
  prefs: []
  type: TYPE_NORMAL
- en: The `enumerate()` function maps an iterable to a sequence of two tuples. Each
    two tuple has `(0)` as the sequence number and `(1)` as the original item.
  prefs: []
  type: TYPE_NORMAL
- en: The `reversed()` function iterates over the items in a sequence object with
    their original order reversed. Some algorithms are more efficient at producing
    results in one order, but we'd like to present these results in the opposite order.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at the `mapping` and `reduction` functions that
    use an additional function as an argument to customize their processing. Functions
    that accept a function as an argument are our first examples of higher-order functions.
    We'll also touch on functions that return functions as a result.
  prefs: []
  type: TYPE_NORMAL
