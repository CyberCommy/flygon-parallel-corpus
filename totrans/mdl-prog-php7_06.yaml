- en: Chapter 6. Building the Core Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now we have familiarized ourselves with the latest changes in PHP 7,
    design patterns, design principles, and popular PHP frameworks. We also took a
    more detailed look into Symfony as our framework of choice moving forward. We
    have now finally reached a point where we can start building our modular application.
    Building modular applications with Symfony is done via the bundles mechanism.
    Terminology-wise, from this point on, we will consider bundle and module to be
    the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will be covering the following topics with respect to the
    core module:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Looking back in [Chapter 4](ch04.html "Chapter 4. Requirement Specification
    for a Modular Web Shop App"), *Requirement Specification for Modular Web Shop
    App*, and the wireframes presented there, we can outline some of the requirements
    this module will have. The core module is going to be used to set general, application-wide
    features, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Include Foundation CSS for sites to the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build other static pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a Contact Us page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setup a basic firewall, where admin users can manage all the auto-generated
    CRUD from other modules later on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core module on its own does not have any specific dependencies on other
    modules that we are going to write as part of this book, or any other third-party
    module outside of standard Symfony installation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating an entirely new Symfony project, running the following
    console command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new `shop` directory with all of the required files needed to
    run our application in the browser. Among these files and directories is the `src/AppBundle`
    directory, which is actually our core module. Before we can run our application
    in the browser, we need to map the newly created `shop` directory to a hostname,
    let''s say `shop.app`, so we can access it in the browser via `http://shop.app`
    URL. Once this is done, if we open `http://shop.app`, we should see **Welcome
    to Symfony 3.1.0** screen as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Though we have no need for the database just yet, other modules we will develop
    later on will assume database connection, so it's worth setting it up right from
    the start. We do so by configuring `app/config/parameters.yml` with proper database
    connection parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then download Foundation for Sites from [http://foundation.zurb.com/sites.html](http://foundation.zurb.com/sites.html).
    Once downloaded, we need to unpack it and copy over the `/js` and `/css` directories
    into the `Symfony /web` directory as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth noting that this is a simplified setup of Foundation that we are
    using with our module, where we simply use CSS and JavaScript files without setting
    up anything relating to Sass.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Foundation CSS and JavaScript files in place, we edit the `app/Resources/views/base.html.twig`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we are setting the entire head and before body end areas, with all the
    necessary CSS and JavaScript loading. The Twigs `asset` tag helps us with building
    URL paths, where we simply pass on the URL path itself and it builds a complete
    URL for us. In regard to the actual body of the page, there are several things
    to consider here. How are we going to build category, customer, and checkout menus?
    At this point we do not have any of these modules, and neither do we want to make
    them mandatory for our core module. So how do we solve the challenge of accounting
    for something that is not there yet?
  prefs: []
  type: TYPE_NORMAL
- en: What we can do for category, customer, and checkout menus is to define global
    Twig variables for each of those menu items that will then be used to render the
    menu. These variables will be filed via proper services. Since the core bundle
    is not aware of future catalog, customer, and checkout modules, we will initially
    create a few dummy services and hook them to global Twig variables. Later on,
    when we develop catalog, customer, and checkout modules, those modules will override
    the appropriate services, thus providing the right values for into menus.
  prefs: []
  type: TYPE_NORMAL
- en: This approach might not fit ideally with the notion of modular application,
    but it will suffice for our needs, as we are not hard-coding any dependencies
    as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by adding the following entry into the `app/config/config.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `category_menu_items`, `customer_menu_items`, `checkout_menu_items`, `products_bestsellers`,
    and `products_onsale` variables become global Twig variables that we can use in
    any Twig template as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@` character in the Twig global variable `config` is used to denote a
    beginning of the service name. This is the service that will provide a value object
    for our Twig variable. Next, we go ahead and create the actual `category_menu`,
    `customer_menu`, `checkout_menu`, `bestsellers`, and `onsale` services by modifying
    `app/config/services.yml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we create each of the listed service classes under the `src/AppBundle/Service/Menu/`
    directory. We start with the `src/AppBundle/Service/Menu/Bestsellers.php` file
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the `src/AppBundle/Service/Menu/Category.php` file with content
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, we add the `src/AppBundle/Service/Menu/Checkout.php` file with
    content as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, we will go on and add the following content to the `src/AppBundle/Service/Menu/Customer.php`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the `src/AppBundle/Service/Menu/OnSale.php` file with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have now defined five global Twig variables that will be used to build our
    application menus. Even though variables are now hooked to a dummy service that
    returns nothing more than a dummy array, we have effectively decoupled menu items
    into other soon-to-be built modules. When we get to building our category, customer,
    and checkout modules later on, we will simply write a service override and properly
    fill the menu items array with real items. This would be the ideal situation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally we would want our services to return data as per a certain interface,
    to make sure whoever overrides it or extends it does so by interface. Since we
    are trying to keep our application at a minimum, we will proceed with simple arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go back to our `app/Resources/views/base.html.twig` file and replace
    `<!-- TOP-MENU -->` from the preceding code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace `<!-- SYSTEM-WIDE-MESSAGES -->` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace `<!-- PER-PAGE-BODY -->` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We replace `<!-- FOOTER -->` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and edit the `src/AppBundle/Controller/DefaultController.php`
    file and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the used template files (`about.html.twig`, `customer-service.html.twig`,
    `orders-returns.html.twig`, `privacy-cookie.html.twig`) residing within the `src/AppBundle/Resources/views/default`
    directory can be similarly defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are merely wrapping header and content into the `div` elements with
    the `row` class, just to give it some structure. The result should be pages similar
    to those shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Contact Us** page requires a different approach as it will contain a
    form. To build a form we use Symfony''s `Form` component by adding the following
    to the `src/AppBundle/Controller/DefaultController.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here we started off by building a form via form builder. The `add` methods accept
    both field definitions and field constraints upon which validation can be based.
    We then added a check for the HTTP POST method, in case of which we feed the form
    with request parameters and run validation against it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `contactAction` method in place, we still need a template file to
    actually render the form. We do so by adding the `src/AppBundle/Resources/views/default/contact.html.twig`
    file with content that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on these few tags, Twig handles the form rendering for us. The resulting
    browser output is a page as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are almost there with getting all of our pages ready. One thing is missing,
    though, the body area of our home page. Unlike other pages with static content,
    this one is actually dynamic, as it lists bestsellers and products on sale. This
    data is expected to come from other modules, which are not available yet. Still,
    this does not mean we cannot prepare dummy placeholders for them. Let''s go ahead
    and edit the `app/Resources/views/default/index.html.twig` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to replace `<!-- products_bestsellers -->` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to replace `<!-- products_onsale -->`with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [http://dummyimage.com](http://dummyimage.com) enables us to create a placeholder
    images for our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point we should be seeing the home page as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring application-wide security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we are trying to achieve as part of our applicationwide security is to
    set some basic protection against future customers or any other user being able
    to access and use future auto-generated CRUD controllers. We do so by modifying
    the `app/config/security.yml` file. There are several components to the `security.yml`
    file we need to address: Firewalls, access control, providers, and encoders. If
    we observe the auto-generated CRUD from the previous test app, it becomes clear
    that we need to protect the following from customer access:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET|POST /new`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET|POST /{id}/edit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE /{id}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In another words, everything that has `/new` and `/edit` in the URL, and everything
    that is of `DELETE` method, needs to be protected from the customer. With that
    in mind, we will use Symfony security features to create an in-memory user of
    role `ROLE_ADMIN`. We will then create an access control list that allows only
    `ROLE_ADMIN` to access the resources we just mentioned, and a firewall that triggers
    an HTTP basic authentication login form when we try to access these resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an in-memory provider means hard-coding users in our `security.yml` file.
    For purposes of our application, we will do so for the admin type of users. The
    actual password, however, does not need to be hard-coded. Assuming we will use
    `1L6lllW9zXg0` for the password, let''s jump to the console and type in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will produce an output as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring application-wide security](graphics/B05460_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now edit `security.yml` by adding an in-memory provider and copy-paste
    the generated encoded password into it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we defined a user `john` of role `ROLE_ADMIN` with an encoded `1L6lllW9zXg0`
    password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the providers in place, we can go ahead and add encoders to our
    `security.yml` file. Otherwise Symfony would not know what to make of the current
    password assigned to `john` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the firewall as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `guard_new_edit` and `guard_delete` names are freely given names to our
    two application firewalls. The `guard_new_edit` firewall will be intercepting
    all GET and POST requests to any route containing the `/new` or `/edit` string
    in its URL. The `guard_delete` firewall will be intercepting any HTTP `DELETE`
    method on any URL. Once these firewalls kick in, they will show an HTTP basic
    authentication form, and only allow access if the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add the access control list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With these entries in place, an one who tries to access any URL with any of
    the patterns defined under `access_control` will be presented with the browser
    login as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring application-wide security](graphics/B05460_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The only user that can login is `john` with the password `1L6lllW9zXg0`. Once
    authenticated, the user can access all the CRUD links. This should be enough for
    our simple application.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current module has no specific classes other than the controller class and
    the dummy service class. Therefore, we won't bother ourselves with unit tests
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing our functional tests, we need to edit the `phpunit.xml.dist`
    file by adding our bundle `Tests` directory to the `testsuite` paths, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our functional tests will cover only one controller, since we have no other.
    We start off by creating a `src/AppBundle/Tests/Controller/DefaultControllerTest.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to test each and every one of our controller actions. At the
    very least we should test if the page content is being outputted properly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get an auto-complete in our IDE we can download the `PHPUnitphar` file from
    the official site here [https://phpunit.de](https://phpunit.de). Once downloaded,
    we can simply add it to the root of our project, so that IDE, like **PHPStorm**,
    picks it up. This makes it easy to follow up on all those `$this->assert` method
    calls and their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we want to test is our home page. We do so by adding the following
    to the body of the `DefaultControllerTest` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here we are checking several things at once. We are checking with the page loads
    OK, with HTTP 200 status. Then we are grabbing the left and right menu and counting
    their the items to see if they have any. If all of the individual checks pass,
    the `testHomepage` test is considered to have passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We further test all of the static pages by adding the following to the `DefaultControllerTest`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here we are running the same `assertEquals` and `assertContains` functions for
    all of our pages. We are merely trying to confirm that each page is loaded with
    HTTP 200, and that the proper value is returned for the page title, that is to
    say, the `h1` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we address the form submission test which we perform by adding the
    following into the `DefaultControllerTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here we are grabbing the form element through its **Reach Out!** submit button.
    Once the form is fetched, we trigger the `submit` method on the client passing
    it the instance from element. It is worth noting that the actual form validation
    is not being tested here. Even so, the submitted form should result in an HTTP
    200 status.
  prefs: []
  type: TYPE_NORMAL
- en: These tests are conclusive. We can write them to be much more robust if we wanted
    to, as there are numerous elements we can test against.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have built our first module, or bundle in Symfony terminology.
    The module itself is not really loosely coupled, as it relies on some of the things
    within the `app` directory, such as the `app/Resources/views/base.html.twig` layout
    template. We can get away with this when it comes to core modules, as they are
    merely a foundation we are setting up for rest of the modules.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will build a catalog module. This will
    be the basis of our web shop application.
  prefs: []
  type: TYPE_NORMAL
