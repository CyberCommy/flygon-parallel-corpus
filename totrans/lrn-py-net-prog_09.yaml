- en: Chapter 9. Applications for the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. HTTP and Working with the Web"), *HTTP
    and Working with the Web*, we explored the HTTP protocol—the primary protocol
    used by the World Wide Web—and we learned how to use Python as an HTTP client.
    In [Chapter 3](ch03.html "Chapter 3. APIs in Action"), *APIs in Action*, we expanded
    on this and looked at ways to consume web APIs. In this chapter, we'll be turning
    our focus around and looking at how we can use Python to build applications that
    serve responses to HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python web frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hosting Python and WSGI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I should note up front that hosting modern web applications is a very large
    topic, and a complete treatment is well beyond the scope of this book, where we're
    focusing on applying Python code to network problems. Topics such as database
    access, selecting and configuring load balancers and reverse-proxies, containerization,
    and the system administration techniques needed to keep the whole show up and
    running won't be covered here. There are many great resources online though that
    can give you a start, and we'll try to mention as many as we can where relevant,
    as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, the technologies listed above aren't a requirement for creating
    and serving Python-based web applications, they're simply what a service comes
    to require as it reaches scale. As we'll see, there are options for easily manageable
    small-scale application hosting too.
  prefs: []
  type: TYPE_NORMAL
- en: What's in a web server?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand how we can employ Python in responding to HTTP requests, we need
    to know a bit about what typically needs to occur in order to respond to a request,
    and what tools and patterns already exist to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic HTTP request and response might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What''s in a web server?](graphics/6008OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here our web client sends an HTTP request to a server, where a web server program
    interprets the request, creates a suitable HTTP response, and sends it back. In
    this case, the response body is simply the contents of an HTML file read from,
    with the response headers added by the web server program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web server is responsible for the entire process of responding to the client''s
    request. The basic steps it needs to perform are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What''s in a web server?](graphics/6008OS_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: First the web server program needs to accept the TCP connection attempt by the
    client. It then receives the HTTP request from the client over the TCP connection.
    The server needs to keep the TCP connection open while it generates the HTTP response,
    and it uses the connection to send the response back to the client. What the server
    does with the connection after that depends on the HTTP version in use and the
    value of a possible Connection header in the request (see the RFC for full details
    at [http://tools.ietf.org/html/rfc7230#section-6.3](http://tools.ietf.org/html/rfc7230#section-6.3)).
  prefs: []
  type: TYPE_NORMAL
- en: Once the web server has received the request, it parses it, then generates the
    response. When the requested URL maps to a valid resource on the server, the server
    will respond with the resource at that URL. The resource could be a file on disk
    (so-called **static content**), as shown in the diagram of a basic HTTP request
    and response from before, it could be an HTTP redirect, or it could be a dynamically
    generated HTML page. If something goes wrong, or the URL is not valid, then instead
    the response will include a status code in the `4xx` or `5xx` range. Once the
    response is prepared, the server sends it back to the client over the TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days of the Web, when almost all requested resources consisted
    of static files read from disk, web servers could be written in a single language
    and could easily handle all four steps shown in the preceding image. However,
    as more and more dynamic content came into demand, such as shopping baskets and
    database-driven resources such as blogs, wikis, and social media, it was quickly
    found that hard-coding these functionalities into the web server itself was impractical.
    Instead, facilities were built into web servers to allow the invocation of external
    code as part of the page generation process.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, web servers could be written in a fast language such as C and could deal
    with the low-level TCP connections, initial parsing and validating of requests,
    and handling static content, but then could invoke external code to handle page
    generation duties when a dynamic response was needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This external code is what we commonly refer to when we talk about web applications.
    So the response process duties can be split, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What''s in a web server?](graphics/6008OS_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Web applications can be written in any language that the web server is able
    to invoke, providing great flexibility and allowing higher level languages to
    be used. This can drastically reduce the time it takes to develop a new web service.
    These days there is a great range of languages that can be used to write web applications,
    and Python is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: Python and the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using some of the techniques discussed in this book, in particular [Chapter
    8](ch08.html "Chapter 8. Client and Server Applications"), *Client and Server
    Applications*, it is possible to use Python to write a full web server that handles
    all four of the steps of handling an HTTP request that we listed in the previous
    section. There are several actively developed web servers already in existence
    written in pure Python, including Gunicorn ([http://gunicorn.org](http://gunicorn.org)),
    and CherryPy ([http://www.cherrypy.org](http://www.cherrypy.org)). There is even
    a very basic HTTP server in the standard library http.server module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a full HTTP server is not a trivial task and a detailed treatment is
    well beyond the scope of this book. It is also not a very common requirement nowadays,
    primarily due to the prevalence of excellent web servers that are already ready
    to deploy. If you do feel the need to have a crack at this challenge though, I
    would start with looking through the source code of the web servers mentioned
    earlier, looking in more detail at the frameworks listed in [Chapter 8](ch08.html
    "Chapter 8. Client and Server Applications"), *Client and Server Applications*,
    and reading the full HTTP specifications in the relevant RFCs. You may also want
    to read the WSGI specifications, discussed in the WSGI section later on, so as
    to allow the server to act as a host for other Python web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The much stronger requirement is to build a web service application to generate
    some dynamic content, and to get it up and running quickly. In this situation,
    Python provides us with some excellent options in the form of web frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Web frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web framework is a layer that sits between the web server and our Python code,
    which provides abstractions and streamlined APIs to perform many of the common
    operations of interpreting HTTP requests and generating responses. Ideally, it
    is also structured so that it guides us into employing well-tested patterns for
    good web development. Frameworks for Python web applications are usually written
    in Python, and can be considered part of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic services a framework provides are:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction of HTTP requests and responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management of the URL space (routing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of Python code and markup (templating)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many Python web frameworks in use today, and here''s a non-exhaustive
    list of some popular ones, in no particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: Django ([www.djangoproject.com](http://www.djangoproject.com))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CherryPy ([www.cherrypy.org](http://www.cherrypy.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask ([flask.pocoo.org](http://flask.pocoo.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tornado ([www.tornadoweb.org](http://www.tornadoweb.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TurboGears ([www.turbogears.org](http://www.turbogears.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pyramid ([www.pylonsproject.org](http://www.pylonsproject.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An up-to-date list of frameworks is maintained at [http://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks)
    and [http://docs.python-guide.org/en/latest/scenarios/web/#frameworks](http://docs.python-guide.org/en/latest/scenarios/web/#frameworks).
  prefs: []
  type: TYPE_NORMAL
- en: There are so many frameworks because there are many approaches that can be taken
    to the tasks they perform, and many different opinions about what tasks they should
    even perform.
  prefs: []
  type: TYPE_NORMAL
- en: Some frameworks provide the minimum to quickly build a simple web application.
    These are often called **microframeworks**, the most popular here being Armin
    Ronacher's excellent Flask. Although they may not include the functionality of
    some of the heavyweight frameworks, what they do, they generally do very well,
    and provide hooks to allow easy extension for more complex tasks. This allows
    a fully customizable approach to web application development.
  prefs: []
  type: TYPE_NORMAL
- en: Other frameworks take a much more batteries-included stance, providing for all
    the common needs of modern web applications. The major contender here is Django,
    which includes everything from templating to form management and database abstraction,
    and even a complete out-of-the-box web-based database admin interface. TurboGears
    provides similar functionality by integrating a core microframework with several
    established packages for the other features.
  prefs: []
  type: TYPE_NORMAL
- en: Yet other frameworks provide features such as supporting web applications with
    an event-driven architecture, such as Tornado, and CherryPy. Both of these also
    feature their own built-in production quality web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a framework can be a tricky decision, and there is no right answer.
    We're going to take a quick look at one of today's most popular frameworks to
    get an idea of the services a framework can offer, then discuss how you might
    approach choosing one.
  prefs: []
  type: TYPE_NORMAL
- en: Flask – a microframework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a taste of working with a Python web framework, we''re going to write
    a small app with Flask. We''ve chosen Flask because it provides a lean interface,
    giving us the features we need while getting out of the way and letting us code.
    Also, it doesn''t require any significant preconfiguration, all we need to do
    is install it, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Flask can also be downloaded from the project's homepage at [http://flask.pocoo.org](http://flask.pocoo.org).
    Note that to run Flask under Python 3, you will need Python 3.3 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now create a project directory, and within the directory create a text file
    called `tinyflaskapp.py`. Our app is going to allow us to browse the docstrings
    for the Python built-in functions. Enter this into `tinyflaskapp.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code can be found in this book's source code download for this chapter
    within the `1-init` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask includes a development web server, so to try out our application all
    we need to do is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Flask server tells us the IP address and port it's listening
    on. Connect to the URL it displays (in the preceding example this is `http://127.0.0.1:5000/`)
    now in a web browser, and you should see a page with a list of Python built-in
    functions. Clicking on one should display a page showing the function name and
    its docstring.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run the server on another interface or port, you can change the
    `app.run()` call, for example, to `app.run(host='0.0.0.0', port=5001)`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through our code. From the top, we create our Flask app by creating
    a `Flask` instance, in this case giving it the name of our main module. We then
    set debug mode to active, which provides nice tracebacks in the browser when something
    goes wrong, and also sets the development server to automatically reload code
    changes without needing a restart. Note that debug mode should never be left active
    in a production app! This is because the debugger has an interactive element,
    which allows code to be executed on the server. By default, debug is off, so all
    we need to do is delete the `app.config.debug` line when we put the app into production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we filter the built-in function objects out of the globals and extract
    their docstrings for later use. Now we have the main section of the app, and we
    encounter the first of Flask''s superpowers: URL routing. The heart of a Flask
    app is a set of functions, usually called **views**, that handle requests for
    various parts of our URL space—`index()` and `show_docstring()` are such functions.
    You will see both are preceded by a Flask decorator function, `app.route()`. This
    tells Flask which parts of our URL space the decorated function should handle.
    That is, when a request comes in with a URL that matches a pattern in an `app.route()`
    decorator, the function with the matching decorator is called to handle the request.
    View functions must return a response that Flask can return to the client, but
    more on that in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: The URL pattern for our `index()` function is just the site root, `'/'`, meaning
    that only requests for the root will be handled by `index()`.
  prefs: []
  type: TYPE_NORMAL
- en: In `index()`, we just compile our output HTML as a string—first our list of
    links to the functions' pages, then a header—and then we return the string. Flask
    takes the string and creates a response out of it, using the string as the response
    body and adding a few HTTP headers. In particular, for `str` return values, it
    sets `Content-Type` to `text/html`.
  prefs: []
  type: TYPE_NORMAL
- en: The `show_docstrings()` view does a similar thing—it returns the name of the
    built-in function we're viewing in an HTML header tag, plus the docstring wrapped
    in a `<pre>` tag (to preserve new lines and whitespace).
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is the `app.route('/functions/<func_name>')` call. Here
    we're declaring that our functions' pages will live in the `functions` directory,
    and we're capturing the name of the requested function using the `<func_name>`
    segment. Flask captures the section of the URL in angle brackets and makes it
    available to our view. We pull it into the view namespace by declaring the `func_name`
    argument for `show_docstring()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the view, we check that the name supplied is valid by seeing whether it appears
    in the `docstrings` dict. If it's okay, we build and return the corresponding
    HTML. If it's not okay, then we return a `404 Not Found` response to the client
    by calling Flask's `abort()` function. This function raises a Flask `HTTPException`,
    which if not handled by our application, will cause Flask to generate an error
    page and return it to the client with the corresponding status code (in this case
    404). This is a good way to fail fast when we encounter bad requests.
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can see from our preceding views that even when cheekily omitting the usual
    HTML formalities such as `<DOCTYPE>` and the `<html>` tag to save complexity,
    constructing HTML in Python code is clunky. It's difficult to get a feel for the
    overall page, and it's impossible for designers with no Python knowledge to work
    on the page design. Also, mixing the generation of the presentation code with
    the application logic makes both harder to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pretty much all web frameworks solve this problem by employing the template
    idiom. Since the bulk of the HTML is static, the question arises: Why keep it
    in the application code at all? With templates, we extract the HTML entirely into
    separate files. These then comprise HTML code, with the inclusion of some special
    placeholder and logic markup to allow dynamic elements to be inserted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask uses another Armin Ronacher creation, the *Jinja2* templating engine,
    for this task. Let''s adapt our application to use templates. In your project
    folder, create a folder called `templates`. In there, create three new text files,
    `base.html`, `index.html`, and `docstring.html`. Fill them out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `base.html` file will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.html` file will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `docstring.html` file will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `render_template` to the `from flask import...` line at the top of `tinyflaskapp.py`,
    then modify your views to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code can be found in the `2-templates` folder of this chapter's source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the views become much simpler, and the HTML is much more readable
    now? Instead of composing a return string by hand, our views simply call `render_template()`
    and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: So what does `render_template()` do? Well, it looks in the `templates` folder
    for the file supplied as the first argument, reads it, runs any processing instructions
    in the file, then returns the processed HTML as a string. Any keyword arguments
    supplied to `render_template()` are passed to the template and become available
    to its processing instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the templates, we can see they are mostly HTML, but with some extra
    instructions for Flask, contained in `{{ }}` and `{% %}` tags. The `{{ }}` instructions
    simply substitute the value of the named variable into that point of the HTML.
    So for example the `{{ func_name }}` in `docstrings.html` substitutes the value
    of the `func_name` value we passed to `render_template()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `{% %}` instructions contain logic and flow control. For example, the `{%
    for func in funcs %}` instruction in `index.html` loops over values in `funcs`
    and repeats the contained HTML for each value.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you may have spotted that templates allow **inheritance**. This is
    provided by the `{% block %}` and `{% extends %}` instructions. In `base.html`
    we declare some shared boilerplate HTML, then in the `<body>` tag we just have
    a `{% block body %}` instruction. In `index.html` and `docstring.html`, we don't
    include the boilerplate HTML; instead we `extend` `base.html`, meaning that these
    templates will fill the `block` instructions declared in `base.html`. In both
    `index.html` and `docstring.html`, we declare a `body block`, the contents of
    which Flask inserts into the HTML in `base.html`, replacing the matching `{% block
    body %}` there. Inheritance allows the reuse of common code, and it can cascade
    through as many levels as needed.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more functionality available in Jinja2 template instructions;
    check out the template designer documentation for a full list at [http://jinja.pocoo.org/docs/dev/templates/](http://jinja.pocoo.org/docs/dev/templates/).
  prefs: []
  type: TYPE_NORMAL
- en: Other templating engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jinja2 is certainly not the only templating package in existence; you can find
    a maintained list of Python templating engines at [https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating).
  prefs: []
  type: TYPE_NORMAL
- en: Like frameworks, different engines exist because of differing philosophies on
    what makes a good engine. Some feel that logic and presentation should be absolutely
    separate and that flow control and expressions should never be available in templates,
    providing only value substitution mechanisms. Others take the opposite tack and
    allow full Python expressions within template markup. Others, such as Jinja2,
    take a middleground approach. And some engines use different schemes altogether,
    such as XML-based templates or declaring logic via special HTML tag attributes.
  prefs: []
  type: TYPE_NORMAL
- en: There isn't a "right" approach; it's best to experiment with a few and see what
    works best for you. Where a framework has its own engine though, like Django,
    or is tightly integrated with an existing engine, like Flask, you'll usually have
    a smoother run sticking with what they supply, if you can.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the moment, our pages look a little plain. Let's add some style. We'll do
    this by including a static CSS document, but the same approach can be used to
    include images and other static content. The code for this section can be found
    in the `3-style` folder in this chapter's source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First create a new `static` folder in your project folder, and in there create
    a new text file called `style.css.` Save the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next update the `<head>` section of your `base.html` file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note the third and forth lines in the preceding code—that is the `<link>` tag—should
    be a single line in your code. Try your web application in the browser again and
    notice that it looks (hopefully) a little more up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Here we've just added a stylesheet to our boilerplate HTML in `base.html`, adding
    a `<link>` tag pointing to our `static/style.css` file. We use Flask's `url_for()`
    function for this. The `url_for()` function returns paths to named parts of our
    URL space. In this case, it's the special `static` folder, which by default Flask
    looks for in the root of our web application. Another thing we can use `url_for()`
    for is to get the paths of our view functions, for example, `url_for('index')`
    would return `/`.
  prefs: []
  type: TYPE_NORMAL
- en: You can put images and other resources in the `static` folder, and reference
    them in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: A note on security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're new to web programming, then I strongly recommend you read up on two
    common types of security flaw in web applications. Both are fairly easily avoided
    but can have serious consequences if not addressed.
  prefs: []
  type: TYPE_NORMAL
- en: XSS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first is **Cross-Site Scripting** (**XSS**). This is where an attacker injects
    malicious script code into a site's HTML, causing a user's browser to carry out
    operations in the security context of that site without the user's knowledge.
    A typical vector is user submitted info being redisplayed to users without proper
    sanitization or escaping.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one method is to trick users into visiting URLs containing carefully
    crafted `GET` parameters. As we saw in [Chapter 2](ch02.html "Chapter 2. HTTP
    and Working with the Web"), *HTTP and* *Working with the Web*, these parameters
    can be used by web servers to generate pages, and sometimes their content is included
    in the HTML of the response page itself. If the server is not careful to replace
    special characters in the URL parameters with their HTML escape codes when displayed,
    an attacker can put executable code, for example Javascript, into URL parameters
    and actually have it executed when that URL is visited. If they can trick a victim
    into visiting that URL, that code will be executed in the user's browser, enabling
    the attacker to potentially perform any action the user could.
  prefs: []
  type: TYPE_NORMAL
- en: The basic XSS prevention is to ensure that any input received from outside the
    web application is escaped properly when returned to the client. Flask is very
    helpful in this regard since it activates Jinja2's auto-escaping feature by default,
    meaning that anything we render via template is automatically protected. Not all
    frameworks have this feature though, and some that do need it to be manually set.
    Also, this only applies in situations where your user-generated content can't
    include markup. In situations like a wiki that allows some markup in user-generated
    content, you need to take much greater care—see the source code download for this
    chapter in the `5-search` folder for an example of this. You should always make
    sure you check out your framework's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: CSRF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second form of attack is the **Cross-Site Request Forgery** (**CSRF**).
    In this attack, a site is tricked into carrying out actions in the security context
    of a user, without the user's knowledge or consent. Frequently this is initiated
    by an XSS attack that causes a user's browser to perform an operation on the target
    site while the user is logged in. It should be noted that this can affect sites
    even when a user isn't actively browsing them; sites often clear cookie authentication
    tokens only when a user explicitly logs out, and hence from the site and browser's
    point of view, any request coming from the browser even after the user has stopped
    browsing a site—if they haven't logged out—will be as if the user is still logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: One technique to help prevent CSRF attacks is to make potentially abusable operations,
    such as submitting forms, require a one-time nonce value that is only known to
    the server and the client. CRSF attacks often take the form of a pre-composed
    HTTP request, mimicking a user submitting a form or similar. However, if every
    time a server sends a form to a client it includes a different nonce value, then
    the attacker has no way of including this in the pre-composed request, and hence
    the attack attempt can be detected and rejected. This technique is less effective
    against XSS initiated attacks, and attacks where an attacker is eavesdropping
    the HTTP traffic of a browsing session. The former is difficult to completely
    protect against, and the best solution is to ensure XSS vulnerabilities are not
    present in the first place. The latter can be mitigated using HTTPS rather than
    HTTP. See the OWASP pages linked to below for further information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different frameworks have different approaches to providing nonce-based CSRF
    protection. Flask doesn''t have this functionality built in, but it is very easy
    to add something, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in templates with forms, just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is from the Flask site: [http://flask.pocoo.org/snippets/3/](http://flask.pocoo.org/snippets/3/).
    Although this contains some Flask functionality, we haven''t covered, including
    sessions and the `@app.before_request()` decorator, you just need to include the
    above code in your app, and make sure you include a `_` `csrf_token` hidden input
    in every form. An alternative approach is to use the Flask-WTF plugin that provides
    integration with the `WTForms` package, which has built-in CSRF protection.'
  prefs: []
  type: TYPE_NORMAL
- en: Django on the other hand has built-in protection, though you need to enable
    and use it. Other frameworks vary. Always check your chosen framework's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is more information on XSS and CSRF on the Flask and Django sites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://flask.pocoo.org/docs/latest/security/](http://flask.pocoo.org/docs/latest/security/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.djangoproject.com/en/1.7/topics/security/](https://docs.djangoproject.com/en/1.7/topics/security/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also on the OWASP site, there is a repository of all sorts of computer security
    related information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/XSS](https://www.owasp.org/index.php/XSS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/CSRF](https://www.owasp.org/index.php/CSRF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finishing up with frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That's as far as we're going to take our dip into Flask, here. There are some
    examples of further adaptations to our application in the downloadable source
    code of this chapter, notably form submission, accessing form values in the request,
    and sessions. The Flask tutorial covers many of these elements in some detail,
    and is well worth checking out [http://flask.pocoo.org/docs/0.10/tutorial/](http://flask.pocoo.org/docs/0.10/tutorial/).
  prefs: []
  type: TYPE_NORMAL
- en: So that's a taste of what a very basic Python web application can look like.
    There are obviously as many ways to write the same app as there are frameworks
    though, so how do you choose a framework?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it helps to have a clear idea of what you're looking to achieve with
    your application. Do you require database interaction? If so, a more integrated
    solution like Django may be quicker to get started with. Will you need a web-based
    data entry or administration interface? Again if so, Django has this out of the
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Next you can look at your environment. Are there already preferred packages
    in your organization for operations you might want to perform, such as database
    access or unit testing? If so, do any frameworks already use these? If not then
    a microframework might be a better option, plugging in your required packages.
    Do you have a preferred operating system or web server for hosting, and which
    frameworks support these? Does your hosting restrict you in terms of Python version,
    database technology, or similar? Also, if you have web designers, do you have
    time to get them up to speed on a complex templating language, or must it be kept
    simple?
  prefs: []
  type: TYPE_NORMAL
- en: Answers to these questions can help you narrow down your choices. Then, researching
    the frameworks, asking people who are using them, and trying out a few likely
    looking ones will get you where you need to go.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, for a general web application that needs some user form submission
    and database access, you can't really go wrong with Django. It really is "batteries
    included", its database model is elegant, and its out-of-the box database administration
    and data entry interface is very powerful and can be a huge timesaver. And for
    simpler applications such as APIs, Flask is also a great choice, coupled with
    SQLAlchemy if database access is needed.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, there's no right answer, but there's a lot to be learned
    by exploring what's available and seeing the different approaches that the frameworks
    take.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, once we've got our web application, we need a way to host it. We're
    going to look at some options now.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting Python web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed at the beginning of this chapter, in order to run a Python web
    application, we need a web server to host it. There are many web servers in existence
    today, and you will very likely have heard of several. Popular examples are Apache,
    nginx (pronounced *engine-x*), lhttpd (pronounced *lighty*), and Microsoft's **Internet
    Information Services** (**IIS**).
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of terminology around web servers and various mechanisms they
    can use to invoke Python web applications. We're going to take a very brief tour
    of the history of web applications to help explain some of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: CGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days of the Web, web servers would mostly only be required to send
    clients HTML pages, or the occasional image file. As in the earlier figure of
    a HTTP request journey, these static resources would live on the hard disk of
    the server, and the web server's main task would be to accept socket connections
    from clients, map the URL of a request to a local file, and send the file back
    over the socket as an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the rise of the need for dynamic content, web servers were given
    the ability to generate pages by invoking external programs and scripts, which
    we today call web applications. Web applications originally took the form of scripts
    or compiled executables that lived on disk next to the regular static content
    as part of the published web tree. The web server would be configured so that
    when a client requested these web application files, instead of just reading the
    file and returning it, the web server would launch a new operating system process
    and execute the file, returning the result as the requested HTML web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we update our HTTP request''s journey from our earlier image, our request''s
    journey would now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CGI](graphics/6008OS_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There obviously needs to be some kind of protocol for the web server and the
    web application to pass the HTTP request and the returned HTML page between them.
    The earliest mechanism for this was called the **Common Gateway Interface** (**CGI**).
    The web server would decompose the request into environment variables, which it
    would add to the environment of the handler program when it was invoked, and pass
    the body of the request, if there was one, to the program via its standard input.
    The program would then simply pipe the HTTP response it generated to its standard
    output, which the web server would catch and return to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Due to performance issues however, CGI is slowly falling out of favor these
    days, and writing a Python CGI application is something that should be avoided
    if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: Recycling for a better world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CGI works, but the major drawback is that a new process has to be launched for
    each request. Launching processes is expensive in terms of operating system resources,
    and so this approach is very inefficient. Alternatives have been developed.
  prefs: []
  type: TYPE_NORMAL
- en: Two approaches became common. The first was to make web servers launch and maintain
    multiple processes at startup, ready to accept new connections— a technique known
    as **pre-forking**. With this technique, there is still a one-process-per- client
    relationship, but the processes are already created when a new client connects,
    improving response time. Also the processes can be reused instead of being re-created
    anew with each connection.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside this, web servers were made extensible and bindings were created to
    different languages so that the web application could be embedded within the web
    server processes themselves. The most commonly seen examples of these are the
    various language modules for the Apache web server for languages such as PHP and
    Perl.
  prefs: []
  type: TYPE_NORMAL
- en: 'With pre-forking and web application embedding, our request''s journey might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recycling for a better world](graphics/6008OS_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the request is transformed by the language binding code, and the request
    our web application sees depends on the design of the binding itself. This approach
    to managing a web application works fairly well for general web loads, and remains
    a popular way to host web applications today. Modern browsers usually also offer
    multithreaded variants, where each process can handle requests using multiple
    threads, one for each client connection, further improving efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach to solving CGI''s performance problems was to hand off
    the management of the web application processes completely to a separate system.
    The separate system would pre-fork and maintain a pool of processes running the
    web application code. Like web server pre-forking, these could be reused for each
    client connection. New protocols were developed to allow the web server to pass
    requests to the external processes, the most notable being FastCGI and SCGI. In
    this situation, our journey would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recycling for a better world](graphics/6008OS_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, how the request is transformed and presented to the web application depends
    on the protocol used.
  prefs: []
  type: TYPE_NORMAL
- en: Although in practice this is somewhat more complex to configure, it has advantages
    over embedding a copy of the application code in pre-forked web server processes.
    Primarily, the web application process pool can be managed independently of the
    web server process pool, allowing more efficient tuning of both.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web client numbers continued to grow though, and the need arose for servers
    to be able to handle very large numbers of simultaneous client connections, numbers
    that proved problematic using the multiprocessing approaches. This spurred the
    development of event-driven web servers, such as *nginx* and *lighttpd*, which
    can handle many thousands of simultaneous connections in a single process. These
    servers also leverage preforking, maintaining a number of event-driven processes
    in line with the number of CPU cores in a machine, and hence making sure the server's
    resources are fully utilized while also receiving the benefits of the event-driven
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: WSGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python web applications were originally written against these early integration
    protocols: CGI, FastCGI, and a now mostly defunct `mod_python` Apache module.
    This proved troublesome though since Python web applications were tied to the
    protocol or server they had been written for. Moving them to a different server
    or protocol required some reworking of the application code.'
  prefs: []
  type: TYPE_NORMAL
- en: This problem was solved with PEP 333, which defined the **Web Services Gateway
    Interface** (**WSGI**) protocol. This established a common calling convention
    for web servers to invoke web application code, similar to CGI. When web servers
    and web applications both support WSGI, servers and applications can be exchanged
    with ease. WSGI support has been added to many modern web servers and is nowadays
    the main method of hosting Python applications on the Web. It was updated for
    Python 3 in PEP 3333.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the web frameworks we discussed earlier support WSGI behind the scenes
    to communicate with their hosting web servers, Flask and Django included. This
    is another big benefit to using such a framework— you get full WSGI compatibility
    for free.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways a web server can use WSGI to host a web application. Firstly
    it can directly support hosting WSGI applications. Pure Python servers such as
    Gunicorn follow this approach, and they make serving Python web applications very
    easy. This is becoming a very popular way to host Python web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is for a non-Python server to use an adapter plugin, such
    as Apache's `mod_wsgi`, or the `mod_wsgi` plugin for nginx.
  prefs: []
  type: TYPE_NORMAL
- en: The exception to the WSGI revolution is event-driven servers. WSGI doesn't include
    a mechanism to allow a web application to pass control back to the calling process,
    hence there is no benefit to using an event-driven server with a blocking-IO style
    WSGI web application because as soon as the application blocks, for example, for
    database access, it will block the whole web server process.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, most event-driven frameworks include a production-ready web server—making
    the web application itself event-driven and embedding it in the web server process
    is really the only way to host it. To host web applications with these frameworks,
    check out the framework's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So how does this all work in practice? Well as we saw with Flask, many frameworks
    come with their own built-in development web servers. However, these are not recommended
    for use in a production environment as they're generally not designed to be used
    where security and scalability are important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, probably the quickest way to host a Python web application with
    a production quality server is with the Gunicorn server. Using our Flask application
    from earlier, we can get it up and running using just a few steps. First we install
    Gunicorn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we need to slightly modify our Flask app so that it''s use of `__builtins__`
    works correctly under Gunicorn. In your `tinyflaskapp.py` file, find the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run Gunicorn. From within your Flask application project folder,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will launch the Gunicorn web server, listening on port 5000 on all available
    interfaces and serving our Flask application. If we now visit it in a web browser
    via `http://127.0.0.1:5000`, we should see our documentation index page. There
    are instructions to daemonize Gunicorn, so that it runs in the background and
    starts and stops automatically with the system, available in the documentation
    pages at [http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#monitoring](http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#monitoring).
  prefs: []
  type: TYPE_NORMAL
- en: Gunicorn uses the pre-fork process model described earlier. You can set the
    number of processes (Gunicorn calls them workers) using the `-w` command line
    option. The 'Design' section of the documentation contains details on determining
    the best number of workers to use, though a good place to start is `(2 x $num_cores)
    + 1`, where `$num_cores` is the number of CPU cores available to Gunicorn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gunicorn offers two standard worker types: sync and async. The sync type provides
    strictly one-worker-per-client-connection behavior, the async type uses eventlet
    (see [Chapter 8](ch08.html "Chapter 8. Client and Server Applications"), *Client
    and Server Applications*, for details and installation instructions for this library)
    to provide an event-based worker, which can handle multiple connections. The sync
    type is only recommended if you are using Gunicorn behind a reverse proxy (see
    below), as using the sync type to serve directly to the Internet leaves your application
    vulnerable to Denial of Service attacks (see the Design section of the documentation
    for more details). If you are not using a reverse proxy, the async type should
    be used instead. The worker type is set on the command line using the `-k` option.'
  prefs: []
  type: TYPE_NORMAL
- en: One effective way to improve performance and scale further is to employ a fast,
    event-driven web server, such as nginx, as a **reverse proxy** in front of your
    Gunicorn instance. A reverse proxy acts as a first line server for incoming web
    requests. It directly responds to any requests it can determine are erroneous,
    and can also be configured to serve static content in place of our Gunicorn instance.
    However, it is also configured to forward any requests that do require dynamic
    content to our Gunicorn instance so our Python web application can handle them.
    In this way, we get the performance benefits of nginx to deal with the bulk of
    our web traffic, and Gunicorn and our web application can focus on delivering
    just the dynamic pages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detailed instructions on configuring this reverse proxy configuration can be
    found on the Gunicorn pages at [http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#nginx-configuration](http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#nginx-configuration).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re more comfortable with Apache, then another effective hosting method
    is Apache with the `mod_wsgi` module. This takes a little more configuring, and
    full instructions can be found at: [https://code.google.com/p/modwsgi/](https://code.google.com/p/modwsgi/).
    `mod_wsgi` defaults to running applications in embedded mode, where the web application
    is hosted in each Apache process, and which results in a setup like the preceding
    pre-forking example. Alternatively it provides a daemon mode, where `mod_wsgi`
    manages a pool of processes external to Apache, similar to the earlier FastCGI
    example. Daemon mode is in fact recommended for stability and memory performance.
    See the `mod_wsgi` quick configuration documentation for instructions on this
    configuration, it can be found at: [https://code.google.com/p/modwsgi/wiki/QuickConfigurationGuide](https://code.google.com/p/modwsgi/wiki/QuickConfigurationGuide).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've taken a whistle-stop tour of putting Python applications on the Web. We
    got an overview of web application architectures and their relationship to web
    servers. We looked at the utility of Python web frameworks, noting how they give
    us tools and structure to write better web applications more quickly, and help
    us integrate our applications with web servers.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote a tiny application in the Flask web framework, we saw how it can help
    us elegantly manage our URL space, and how templating engines can help us cleanly
    manage the seperation of application logic and HTML. We also highlighted a couple
    of common potential security vulnerabilities— XSS and CSRF— and looked at some
    basic mitigation techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed web hosting architectures and the various methods that
    can be used to deploy Python web applications to the Web. In particular, WSGI
    is the standard protocol of web server/web application interaction, and Gunicorn
    can be used for rapid deployment and scaled with an nginx reverse proxy. Apache
    with mod_wsgi is also an effective hosting approach.
  prefs: []
  type: TYPE_NORMAL
- en: We've covered a lot of ground in this book, and there's still plenty more exploring
    to be done. We hope this book has given you a taste of what's possible and an
    appetite for discovering more, and that this is just the start of your adventures
    in network programming with Python.
  prefs: []
  type: TYPE_NORMAL
