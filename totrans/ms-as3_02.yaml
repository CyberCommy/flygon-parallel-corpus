- en: UI Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The one feature that stands out in Android Studio above all others, including
    the Gradle build system, is the powerful **User Interface**(**UI**) development
    tools. The IDE provides a variety of views of our designs, allowing us to combine
    drag and drop construction and hard code in the development of a UI. Android Studio
    also comes equipped with a comprehensive preview system, which allows us to test
    our designs on any manner of device before running the project on an actual device.
    Along with these features, Android Studio also includes useful support libraries,
    such as the design library for creating material design layouts and the Percent
    Support Library for simplifying complex, proportional designs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is the first of four, covering UI development. In it, we take a
    closer look at Studio's Layout Editors and tools. We will be building working
    interfaces using each of the most useful Layout/ViewGroup classes and designing
    for and managing screen rotation. The chapter continues by exploring Studio's
    preview system and how XML layout resources are stored and applied. The chapter
    concludes by returning to themes, Material Design, and the design support library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Explore the Layout Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply linear and relative layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the constraint library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `ConstraintLayout`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the graphical constraints editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add constraint guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Align `TextView` baselines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply bias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use auto-connect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a hardware profile for a virtual device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a virtual SD card
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Layout Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If there were only one reason to use Android Studio, it would be the Layout
    Editor and its associated tools and preview system. The differences are apparent
    as soon as you open a project. The difference between layout and blueprint view
    is also shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d69c83c-2fb0-4383-a0c0-689c018bdb3c.png)'
  prefs: []
  type: TYPE_IMG
- en: The design and blueprint layout views
  prefs: []
  type: TYPE_NORMAL
- en: The **blueprint mode** is new to Android Studio 2.0 and portrays a simplified,
    outlined view of our UI. This is particularly useful when it comes to editing
    the spacing and proportions of complex layouts without the distraction of content.
    By default, the IDE displays both design and blueprint views side by side, but
    the editor's own toolbar allows us to view only one, and in most cases one would
    select the mode most suitable to the task in hand.
  prefs: []
  type: TYPE_NORMAL
- en: The *B* key can be used to toggle between design, blueprint, and combined views
    as an alternative to the toolbar icons.
  prefs: []
  type: TYPE_NORMAL
- en: It would be perfectly possible to generate every layout required for a project
    using these graphical views without any knowledge of the underlying code. This
    is not a very professional approach though, and a good understanding of the XML
    under the hood is essential for good testing and debugging and, if we know what
    we are doing, very often tweaking the code is faster than dragging and dropping
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The XML responsible for the previous layout is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, the terms used in the preceding code will be familiar to you. The
    use of `layout_weight` is frequently used with linear layouts to assign proportion,
    a great time saver when developing for screens with slightly different aspect
    ratios.
  prefs: []
  type: TYPE_NORMAL
- en: Until recently, the only choice we had for creating more complex UIs were the
    linear and relative layouts. Both of these are less than ideal, being either unnecessarily
    expensive or fiddly. Android Studio 2 introduced the constraint layout, which
    offers an elegant solution to these problems. To best appreciate its value, it
    makes sense here to first take a look at the older classes, which still have their
    place in many simpler designs.
  prefs: []
  type: TYPE_NORMAL
- en: Linear and relative layout classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The linear layout is relatively lightweight and very useful for layouts based
    on single rows or columns. However, more complex layouts require nesting layouts
    inside each other and this very quickly becomes resource hungry. Take a look at
    the following layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d483da95-3c6d-4df7-920f-e12192336edc.png)'
  prefs: []
  type: TYPE_IMG
- en: Nested linear layouts
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding layout was built using only linear layouts, as can be seen from
    the following Component Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76d6e913-677d-4b6b-aa83-4b253436db6d.png)'
  prefs: []
  type: TYPE_IMG
- en: The component tree
  prefs: []
  type: TYPE_NORMAL
- en: Although perfectly workable and easy to understand, this layout is not as efficient
    as it could be. Even a single extra layer of layout nesting will have an impact
    on performance. Prior to the constraint layout, this problem was solved with the
    relative layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, the relative layout allows us to place screen components
    in relation to each other, using markup such as `layout_toStartOf` or `layout_below`.
    This allows us to flatten view hierarchies and the preceding layout could be recreated
    with just one single relative, root viewgroup. The following code demonstrates
    how the row of images in the previous layout can be generated without nesting
    any new layouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Even if you are new to Android Studio, it is assumed that you will be familiar
    with linear and relative layouts. It is less likely that you will have encountered
    the constraint layout, which has been especially developed for Studio to alleviate
    the shortcomings of these older approaches.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples, we used `app:srcCompat` as opposed to `android:src`.
    This is not strictly required here, but if we wished to apply any tinting to the
    image and hope to distribute the app for older Android versions, this choice will
    enable that.
  prefs: []
  type: TYPE_NORMAL
- en: The constraint layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The constraint layout is similar to the relative layout, in that it allows us
    to generate complex layouts without having to create memory sapping, view group
    hierarchies. Android Studio makes creating such layouts far easier, because it
    provides a visual editor that enables us to drag and drop not only screen components,
    but also their connections. Being able to experiment with layout structures so
    easily provides us with a great sandbox environment to  develop new layouts.
  prefs: []
  type: TYPE_NORMAL
- en: The following exercise will take you through the process of installing the constraint
    library so that you can begin experimenting yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Android Studio 3.0 the `ConstraintLayout` is downloaded by default, but
    if you want to update an earlier project, you will need to open the SDK manager.
    The ConstraintLayout and constraint solver can both be found under the SDK Tools
    tab, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/42d28968-df7b-4f04-8a7e-afc6f001b10c.png)'
  prefs: []
  type: TYPE_IMG
- en: The constraint layout API
  prefs: []
  type: TYPE_NORMAL
- en: Check the Show Package Details box and make a note of the version number as
    this will be required shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add the `ConstraintLayout` library to our dependencies. The simplest way
    to do this is selecting your module and then the Dependencies tab of the Project
    Structure dialog, which can be accessed from the File menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constraint library can be found by clicking on the + button and then 1 Library
    dependency and selecting it from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, synchronize your project from the toolbar, the build menu, or *Ctrl*
    + *Alt* + *Y*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the simplest way to add module dependencies, but it is always good
    as developers to understand what is going on under the hood. In this case, we
    could have added the library manually by opening the module level `build.gradle`
    file and adding the following, highlighted text to the `dependencies` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Those of you that have developed with the relative layout will be familiar with
    commands such as `layout_toRightOf` or `layout_toTopOf`. These attributes can
    still be applied to a `ConstraintLayout`, but there are more. In particular, the
    `ConstraintLayout` allows us to position views based on individual sides, for
    example `layout_constraintTop_toBottomOf `, which aligns the top of our view to
    the bottom of the one specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful documentation on these attributes can be found at: [developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html](https://developer.android.com/reference/android/widget/RelativeLayout.LayoutParams.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ConstraintLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to create a ConstraintLayout. The first is to convert an
    existing layout to a ConstraintLayout, which can be done by right-clicking on
    the layout in either the component tree or the graphical editor and selecting
    the convert option. You will be presented with the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2333857b-14b5-4d2d-a0f7-65c57f242b5a.png)'
  prefs: []
  type: TYPE_IMG
- en: The Convert to ConstraintLayout dialog
  prefs: []
  type: TYPE_NORMAL
- en: It is usually best to check both these options, but it is worth noting that
    these conversions will not always produce the desired results and often view dimensions
    will require a little tweaking to faithfully reproduce the original.
  prefs: []
  type: TYPE_NORMAL
- en: When it works, the previous approach provides a fast solution, but if we are
    to master the topic, we need to know how to create constraint layouts from scratch.
    This is particularly important as once we have become familiar with the working
    of the constraint layout; we will see that it is by far the easiest and most flexible
    way to design our interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `ConstraintLayout` is so well incorporated with the Layout Editor, that
    it is perfectly possible to design any layout we choose without ever having to
    write any XML. However, here we will be looking closely at both the graphical
    and textual perspectives, so as to develop a deeper understanding of the technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a fresh `ConstraintLayout` from the `res/layout` directory in
    project explorer''s context-sensitive menu as a New | Layout resource file with
    the following root element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2bc3fc1-d778-434b-8134-c7b5315cb046.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a new ConstraintLayout
  prefs: []
  type: TYPE_NORMAL
- en: 'This will produce the XML shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As with other layout types, the constraint layer provides mechanisms for positioning
    and aligning the views and widgets within it. This is done largely through the
    use of handles that can be positioned graphically to size and align our views.
  prefs: []
  type: TYPE_NORMAL
- en: Applying constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to see how this works is to try it, as these few simple steps
    will demonstrate. Create a `ConstraintLayout` as described previously and drag
    and drop one or two views or widgets from the palette onto the blueprint screen,
    similar to following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34893a39-2340-4710-ae6c-9b7b94addbed.png)'
  prefs: []
  type: TYPE_IMG
- en: Constraint handles
  prefs: []
  type: TYPE_NORMAL
- en: Each view has constraint handles on its corners and its sides. Those on the
    corners are for simply resizing a view in the way that we are all familiar with.
    Those along the sides, however, are used to create constraints. These position
    views are relative to their parents or each other in a way that is not dissimilar
    to the relative layout.
  prefs: []
  type: TYPE_NORMAL
- en: As this is largely a graphical form of editing, it is best demonstrated by action.
    Drag the left side anchor point of one of your views toward the left side of the
    layout and release the mouse button as prompted to create a parent constraint.
    This being a layout that contains others will be a parent constraint.
  prefs: []
  type: TYPE_NORMAL
- en: As you experiment with constraints, you will notice how the margins automatically
    stick to those values recommended by the creative design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now open the text editor, you will see the constraint realized like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also notice from the code that an error is generated by this view.
    This is because we need both vertical and horizontal constraints for each view.
    This is achieved in exactly the same way, with something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Constraints can be created between child views as well, using the same drag
    and drop technique or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Setting a constraint on all four sides of a view will center it in its container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints can be used to align sibling views as well as joining two adjacent
    sides, which generates code along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A constraint can be deleted very simply, in either editor mode, by clicking
    on its originating handle.
  prefs: []
  type: TYPE_NORMAL
- en: This drag and drop method is not peculiar to Android Studio, but there is one
    editing tool that is unique to Android Studio by providing a editable schematic
    perspective in the Properties tool.
  prefs: []
  type: TYPE_NORMAL
- en: Graphic Properties tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will no doubt have noticed the diagrammatic representation of a view that
    pops up in the Properties window, when a ConstraintLayout view is selected as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0e2a02c-07a2-4221-9001-356602d5156d.png)'
  prefs: []
  type: TYPE_IMG
- en: The Properties schematic.
  prefs: []
  type: TYPE_NORMAL
- en: This tool allows size and position properties to be edited with a single click
    and for the output to be instantly understood in a simple schematic form. It only
    takes seconds to learn and can speed up interface design considerably, particularly
    when experimenting with different layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the central square, representing our view, there are four lines, which
    when clicked on cycle through the following three states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unbroken line**: The view is an exact width, for example, `240dp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzzy line**: The view can be any size (dependent on bias), `match_parent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directed line**: The view matches its own content, `wrap_content`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Often, we will not want to constrain a view to the very edge of its container.
    For example, we may wish to divide the layout into two or more sections and have
    views organized within them. Guidelines allow us to divide our screens into sections
    and can be used exactly like parent edges. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a533c49-852b-47ac-b844-6c7e14d366d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Constraint guidelines
  prefs: []
  type: TYPE_NORMAL
- en: 'Guidelines like this are most easily added from the constraint toolbar at the
    top of the design editor. Guidelines are added as XML components and look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use these guidelines to center elements according to the whole layout
    or any of the four panes we have created, and all without nesting a single layout.
    In the following screenshot, we have a centered header and side panel with another
    view contained in a single pane, and we can of course apply bias to any of these
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46252969-e6c1-41f2-a286-77d40759f680.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying constraint guidelines
  prefs: []
  type: TYPE_NORMAL
- en: If this system did not already provide enough advantages, there are more. Firstly,
    it proves very useful when aligning text as well as a more enhanced positioning
    technique referred to as bias, which performs a similar function to the weight
    attribute, but is better when it comes to designing for multiple screens. We will
    take a look first at text alignment constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Baseline alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aligning text across multiple views using their baselines can be fiddly, especially
    when text is of different sizes. Fortunately, constraint layouts offer a simple
    and easy way to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any constrained view or widget designed to contain text, will contain a bar
    across its center. Hover over this for a moment, until it flashes, and then drag
    it to the view whose text you wish to align it with, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c95dfcb4-4527-4277-8214-63f694d4f3a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Baseline alignment.
  prefs: []
  type: TYPE_NORMAL
- en: You will probably be familiar with the gravity attributes that the relative
    layout class uses to control positioning.
  prefs: []
  type: TYPE_NORMAL
- en: Baseline constraints can only be connected to other baselines.
  prefs: []
  type: TYPE_NORMAL
- en: The constraint layout introduces a new approach, allowing us to control the
    relative distances either side of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling position with bias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bias can be best understood here as a percentage value, but rather than position
    the view according to its center or a corner, it is the percentage of space either
    side of it. So if the bias towards the top is 33%, then the margin below will
    be twice the size of the one below it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting bias is even easier than understanding it, as once a constraint is
    set on any opposing sides of a view, an associated slider will appear in the Properties
    graphic Properties editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c2997bb-0521-4554-9160-70ef9728306e.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying bias with the GUI
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick glance at the generated code shows the format for this attribute as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The value of using bias to position screen elements lies partly in the simplistic
    approach, but its true value comes when it comes to developing for multiple screens.
    There are so many models available and they all seem to have slightly different
    proportions. This can make design layouts that look fantastic on all of them,
    very time consuming and even shapes as similar as 720 x 1280 and 768 x 1280 can
    produce undesirable results when tested with the same layout. The use of the bias
    attribute goes a long way to solving these issues, and we shall see more of this
    later when we take a look at layout previews and the percent library.
  prefs: []
  type: TYPE_NORMAL
- en: The Design and Text modes of the editor can be switched between using *Alt*
    + Left or Right.
  prefs: []
  type: TYPE_NORMAL
- en: 'As if all this didn''t make designing a layout easy enough, constraint layouts
    have two other extremely handy functions that almost automate UI design: auto-connect
    and inference.'
  prefs: []
  type: TYPE_NORMAL
- en: The constraints toolbar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we will always want to spend a lot of time perfecting our final designs,
    a lot of the development cycle will be taken up with experimentation and trying
    out new ideas. We want to test these individual designs as quickly as possible,
    and this is where auto-connect and inference come in. These functions can be accessed
    through the constraints toolbar, which contains other useful tools and is worth
    looking at in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1c5a472-32d7-461c-9786-b7c28f60f3fb.png)'
  prefs: []
  type: TYPE_IMG
- en: The constraints toolbar
  prefs: []
  type: TYPE_NORMAL
- en: From left to right, the toolbar breaks down as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Show Constraints: Displays all constraints, not just those of the selected
    components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Auto-connect: When this is enabled, new views and widgets will have their constraints
    set automatically according to where they are placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clear All Constraints: As its title suggests, a one click solution to starting
    again. This can cause some unexpected results, so it should be used with a little
    caution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Infer Constraints: Apply this once you have designed your layout. It will automatically
    apply constraint in a similar fashion to auto-connect, but it will do so to all
    views in a single pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4db07488-596a-4494-9c89-cdf2b755a3c2.png)'
  prefs: []
  type: TYPE_IMG
- en: The infer process
  prefs: []
  type: TYPE_NORMAL
- en: 'Default Margins: Sets the margins for the whole layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pack: This offers a series of distribution patterns, which help to evenly expand
    or shrink the area used by the selected items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Align: This drop-down offers the most commonly used group alignment options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guidelines: Allows the quick insertion of guidelines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both auto-connect and infer offer intelligent and fast methods of building constraint
    layouts, and although they make fantastic tools for testing out ideas, they are
    far from perfect. Very often these automations will include unnecessary constraints
    that will need removing. Also, if you examine the XML after you have employed
    these techniques, you will notice that some values are hardcoded, and as you will
    know this is somewhat less than best practice.
  prefs: []
  type: TYPE_NORMAL
- en: As you will have hopefully have seen in this section, Android Studio and the
    ConstraintLayout are literally made for each other. This is not to say that it
    should replace the linear and relative layouts in all cases. When it comes to
    simple lists, the linear layout is still the most efficient. And for layouts with
    only two or three children, a relative layout is often cheaper too.
  prefs: []
  type: TYPE_NORMAL
- en: There is still more to the `ConstraintLayout` class, such as distribution chaining
    and runtime constraint modification, and we will return to the subject frequently
    throughout the book, but for now we will take a look at another of Android Studio's
    unique and powerful tools, device preview and emulation.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple screen previewing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting challenges an Android developer faces is the bewildering
    number of devices that employ it. Everything from wristwatches to widescreen televisions.
    It is rare that we would want to develop a single application to run across such
    a range, but even developing layouts for all mobile phones is still a daunting
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this process is aided by the way the SDK allows us to categorize
    features such as screen shape, size, and density into broader groups. Android
    Studio adds another powerful UI development tool, in the form of a complex preview
    system. This can be used to preview many popular device configurations as well
    as allowing us to create custom configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we took a look at the ConstraintLayout toolbar, but
    as you will have noticed, there is a more generic design editor toolbar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36bb732a-af2c-4949-a5f1-ab60d7a03376.png)'
  prefs: []
  type: TYPE_IMG
- en: Design editor toolbar
  prefs: []
  type: TYPE_NORMAL
- en: Most of these tools are self explanatory, and you will have used many of them.
    One or two, however, are worth taking a closer look at, especially if you are
    new to Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: By far, one of the most useful design tools available to us is the Device in
    Editor tool, displaying in the preceding figure as Nexus 4\. This allows us to
    preview our layouts as they would appear in any number of devices, without having
    to compile the project. The drop-down provides a selection of generic and real-world
    profiles, any AVD we might have created, and the option to add our own device
    definition. It is this option that we shall look at now.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selecting Add Device Definition... from the Device in Editor drop-down will
    open the AVD manager. To create a new hardware profile click on the Create Virtual
    Device... button. The Select Hardware dialog allows us to install and edit all
    the device profiles listed in the previous drop-down as well as the option to
    create or import a definition.
  prefs: []
  type: TYPE_NORMAL
- en: A standalone version of the AVD manager can be run from `user\AppData\Local\Android\sdk\`.
    This can be useful on lower end machines, as AVDs can be booted up without Studio
    running.
  prefs: []
  type: TYPE_NORMAL
- en: It is usually easier to take an existing definition and adapt it to our needs,
    but to gain further insight into the operation, here we will create one from scratch
    by clicking on the New Hardware Profile button from the Select Hardware dialog.
    This will take you to the Configure Hardware Profile dialog where you can select
    hardware emulators such as cameras and sensors as well as defining internal and
    external storage options.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68d3e3c6-b08f-46dc-9357-e8a96d74ed43.png)'
  prefs: []
  type: TYPE_IMG
- en: Hardware configuration
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your profile and click on Finish, you will be returned to the
    hardware selection screen where your profile will now have been added to the list.
    Before moving on, however, we should take a quick look at how we can emulate storage
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each profile contains an SD card disk image to emulate external storage, and
    obviously this is a useful feature. However, it would be even more useful if we
    could remove these cards and share them with other devices. Fortunately, Android
    Studio has some very handy command-line tools, which we will be encountering throughout
    this book. The command that interests us here though is `mksdcard`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mksdcard` executable can be found in `sdk/tools/` and the format for creating
    a virtual SD card is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When testing an application on a large number of virtual devices, it can save
    a lot of time to be able to share external memory, and of course such images can
    be stored on actual SD cards, which not only makes them more portable, but can
    reduce the load on a hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: Our profile is now ready to be combined with a system image to form an AVD,
    but first we will export it to get a better look at how it is put together. This
    is saved as an XML file and can be achieved by right-clicking on your profile
    in the main table of the hardware selection screen. Not only does this provide
    an insight as well as a handy way to share devices across networks, but it is
    also very quick and simple to edit itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration itself can be quite long, so the following is a sample node
    to provide an idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the way a screen is defined here, provides a useful window into the
    features and definitions we need to consider when developing for multiple devices.
  prefs: []
  type: TYPE_NORMAL
- en: To see our profile in action we need to connect it to a system image and run
    it on the emulator. This is done by selecting the profile and clicking on Next.
  prefs: []
  type: TYPE_NORMAL
- en: To test an app thoroughly, it is usually best to create an AVD for each API
    level, screen density, and hardware configuration you intend to publish the app
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having selected an image, you will be given the opportunity to tweak your hardware
    profile and then create the AVD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94b22b0f-4f29-4e67-9e72-d68afd45efac.png)'
  prefs: []
  type: TYPE_IMG
- en: An Android AVD
  prefs: []
  type: TYPE_NORMAL
- en: Emulating the latest mobile devices is an impressive task, even for the toughest
    of computers and, even with HAXM hardware acceleration, it can be frustratingly
    slow, although the addition of Instant Run has considerably speeded this process
    up. There is little in the way of alternatives, with the exception of Genymotion,
    which provides faster virtual devices and several features unavailable on the
    native emulator. These include the drag and drop installation, real-time window
    resizing, working network connection, and one click mock location setting. The
    only drawbacks being that there are no system images for Android Wear, TV, or
    Auto and it is only free for personal use.
  prefs: []
  type: TYPE_NORMAL
- en: This section shows how we can preview our layouts across a large number of form
    factors and how we can build a virtual device to match the exact specifications
    of any target device, but this is only part of the story. In the next chapter,
    we will see how to create layout files for all our target devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the fundamentals of interface development, and this
    is largely a matter of using and understanding the various layout types. A lot
    of the chapter was devoted to the constraint layout as this is the latest and
    most flexible of these viewgroups and is catered for fully in Android Studio with
    intuitive visual tools.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter concluded by seeing how we take the completed layouts and view them
    on an emulator using a customized hardware profile.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will look more deeply into these layouts and see
    how the coordinator layout is used to coordinate a number of child components
    to work together with very little coding required from us.
  prefs: []
  type: TYPE_NORMAL
