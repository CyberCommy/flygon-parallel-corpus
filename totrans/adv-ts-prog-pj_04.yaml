- en: The MEAN Stack - Building a Photo Gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, it's almost impossible to write Node.js applications and not hear
    about the MEAN stack. MEAN is the acronym used to describe a set of common technologies
    used on both the client and server side to build web applications with persistent
    server-side storage. The technologies that make up the **MEAN** stack are **MongoDB**,
    **Express** (sometimes known as **Express.js**), **Angular**, and **Node.js**.
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to build on the knowledge we developed in the previous chapters
    to write a photo gallery application using the MEAN stack. Unlike previous chapters,
    we will not be using Bootstrap in this chapter, preferring to use Angular Material
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The components of the MEAN stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Angular Material to create the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Material to add our navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a file upload component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using services to read the file in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Express support into our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing Express routing support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RxJS to watch for images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transferring data using `HttpClient`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter04](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the project, you will have to install the package requirements
    using `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: The MEAN stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we use the term the MEAN stack, we are talking about a set of separate
    JavaScript technologies that go together to create web applications that span
    both the client and server side. MEAN is an acronym of the core technologies used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MongoDB**: This is something called a document database, which is used to
    store data in JSON form. Document databases are different from relational databases,
    so if you have come from a technology such as SQL Server or Oracle, it can take
    a little bit of time to adjust to the way that document databases work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Express**: This is a backend web application framework that sits on top of
    Node.js. The idea behind having Express in the stack is that it simplifies things
    that Node.js provides on the server side. While Node.js can do everything that
    Express does, the complexity of writing code to do things such as adding cookies
    or routing web requests means that Express''s simplification aids us by cutting
    development time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular**: Angular is a client-side framework that runs the client side of
    an application. Typically, Angular is used to create **Single-Page Applications**
    (**SPAs**), whereby small sections of the client are updated rather than having
    to reload the whole page when a navigation event happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js**: Node.js is the server-side runtime environment for an application.
    We can think of this as the web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows where the components of the MEAN stack exist in
    terms of our application architecture. The part of the application that our user
    sees, sometimes known as the frontend, is the client in this diagram. The rest
    of our application is commonly referred to as the backend and is the web server
    and database in the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/28a2cdaf-cd75-4d1f-a0c0-c1c55894b3e0.png)'
  prefs: []
  type: TYPE_IMG
- en: There is an equivalent for using React in place of Angular. It's known as the
    MERN stack.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project we are going to build in this chapter will introduce us to writing
    server-side applications as well as introduce us to the popular Angular framework.
    We will build a picture gallery application where our users can upload pictures
    and save them in a server-side database that allows them to view them again later.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as you work alongside the code in the GitHub repository, this chapter
    should take about three hours to complete. The finished application will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a569134c-b4b1-4a88-bc95-111d96c87fda.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is not intended to be a comprehensive tutorial on all aspects of
    the MEAN stack. By the end of the chapter, we will only have begun to scratch
    the surface of what the different parts provide. As we are introducing many topics
    here, we will focus more on those topics than on advanced features of TypeScript
    because this could lead to information overload, but we will still be covering
    features such as generic constraints and fluent code, even though we aren't going
    to refer to them explicitly. At this point, we should be familiar enough with
    them to recognize them when we encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as in the previous chapter, this chapter will use Node.js, which is available
    at [https://nodejs.org](https://nodejs.org). We will also be using the following
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: The Angular **Command-Line Interface** (**CLI**) (I'm using version 7.2.2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cors` (version 2.8.5 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body-parser` (version 1.18.3 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`express` (version 4.16.4 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongoose` (version 5.4.8 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/cors` (version 2.8.4 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/body-parser` (version 1.17.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/express` (version 4.16.0 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/mongodb` (version 3.1.19 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@types/mongoose` (version 5.3.11 or greater)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also be using MongoDB. The Community Edition is available at [https://www.mongodb.com/download-center/community](https://www.mongodb.com/download-center/community).
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB also comes with a GUI that makes it easier to view, query, and edit
    your MongoDB databases. MongoDB Community Edition can be downloaded from [https://www.mongodb.com/download-center/compass](https://www.mongodb.com/download-center/compass).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular photo gallery with the MEAN stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did in previous chapters, we are going to start out by defining the requirements
    of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: The user must be able to select a picture to transfer to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to supply additional metadata for the pictures, such as
    descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploaded pictures will be saved in a database with the metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user will be able to automatically view the uploaded pictures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular was created as a platform for creating client-side applications using
    a combination of HTML and TypeScript. Originally, Angular was written in JavaScript
    (it was known as Angular.js back then), but it underwent a complete rewrite using
    TypeScript and was rebranded to just Angular. The architecture of Angular itself
    revolves around a series of modules that we can bring into our application or
    write ourselves, which can contain services and components that we can use to
    build up our client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, one of the key drivers behind Angular was the idea that fully reloading
    web pages is a wasteful practice. So many websites were serving the same navigation,
    headers, footers, sidebars, and more that it was a waste of time reloading those
    items every time the user navigated to a new page because they hadn't actually
    changed. Angular helped to popularize an architecture known as the SPAs, where
    only small parts of the page that need to change actually do so. This reduces
    the amount of traffic that a web page has to deal with so that, when done properly,
    the responsiveness of a client application is increased.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a typical SPA format. The vast majority of the
    page is static in nature so it doesn''t have to be re-sent, but the Junk Email
    section in the center will be dynamic—only that part needs to be updated. This
    is the beauty of SPAs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb8ad46b-5832-4607-91a8-f52441cf10cb.png)'
  prefs: []
  type: TYPE_IMG
- en: This does not mean that we can't create multi-page applications in Angular.
    It just means that unless we have a real need to create a multi-page application,
    then Angular SPA applications are the way we should write our Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of what Angular is about, we can move on to using Angular
    to write our client.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unless you have recently installed Angular, you need to install it using `npm`.
    The part that we are going to install is the Angular CLI. This gives us everything
    we need to run from Command Prompt to generate our application, add components,
    scaffold the application, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As we are going to develop both client and server code, it will be helpful to
    keep our code together to do this; therefore, we are going to create `Client`
    and `Server` folders under a common directory. Any Angular commands will be run
    in the `Client` folder. It is relatively common to share code between the client
    and server side, so this arrangement is a simple way to keep the application together
    and simplify sharing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an application with Angular is easily accomplished using the `ng new`
    command, which was added to our system when we added the Angular CLI. We are going
    to specify command-line arguments to choose SCSS to generate our CSS, as well
    as choosing the prefix we want to give to any components that we create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The naming convention I have chosen to follow reflects the name of the book,
    so we use `atp` to reflect *Advanced TypeScript Projects*. While we aren't going
    to make heavy use of CSS in this chapter, I tend to use SCSS as my CSS pre-processor
    more than I use raw CSS because it has a rich syntax for using things such as
    style mixins, which means that this is the style engine I tend to go to by default. The
    reason that we are choosing to use the `atp` prefix is to make our component selectors
    unique. Suppose that we had a component that we wanted to call label; obviously,
    this would clash with the built-in HTML label. To avoid the clash, our component
    selector would be the `atp` label. As HTML controls never use hyphens, we guarantee
    that we aren't going to *collide* with existing control selectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to accept the installation defaults, so just press *Enter* when
    prompted about whether or not to add Angular routing support. When the installation
    completes, we are going to start our Angular server, which also watches to see
    whether files change and rebuilds the application on the fly. Normally, I would
    install all of the required components before I did this part, but it is useful
    to see exactly what Angular gives us as a starting point and the ability to view
    live changes is highly useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unlike React, the default web address for opening our application is `http://localhost:4200`.
    When the browser opens, it displays the default Angular sample page. Obviously,
    we are going to remove lots from this, but in the short term, we are going to
    keep this page as it is while we start adding some of the infrastructure we need.
  prefs: []
  type: TYPE_NORMAL
- en: Angular creates a lot of files for us, so it's worth identifying which ones
    are the ones that we are going to work with the most and what purpose they serve.
  prefs: []
  type: TYPE_NORMAL
- en: App.Module.ts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the process of developing large Angular applications, especially if we
    are just one of a number of teams developing different parts of the same overall
    application, it's common to break them down into modules. We can view this file
    as our entry point into saying how a module is grouped together. For our purposes,
    we are interested in two sections in the module definition covered by `@NgModule`.
  prefs: []
  type: TYPE_NORMAL
- en: The first section is the `declarations` section, which tells Angular what components
    we have developed. For our application, we will develop three components that
    belong in here—`AppComponent` (which is added by default), `FileuploadComponent`,
    and `PageBodyComponent`. Fortunately for us, when we use the Angular CLI to generate
    components, their declarations are automatically added into this section.
  prefs: []
  type: TYPE_NORMAL
- en: The other section we are interested in is the `imports` section. This tells
    us what external modules need to be imported into our application. We cannot just
    reference a feature from an external module in our application; we actually have
    to tell Angular that we are going to use the module that the feature comes from.
    This means that Angular is very good at minifying the dependencies that we have
    when we deploy the application because it will only deploy modules that we have
    said that we are using.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through this chapter, we will add items into this section in order
    to enable features such as Angular Material support.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular Material for our UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The frontend of our application is going to use something called Angular Material
    instead of relying on Bootstrap. We are going to look at Material because it's
    widely used with Angular applications; therefore, if you are going to develop
    with Angular commercially, there's a good chance that you will use it in your
    career at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Material was built by the Angular team to bring Material Design components
    to Angular. The idea behind them is that they integrate seamlessly into the Angular
    development process so that they feel no different to using standard HTML components.
    These design components go well beyond what we can do with single standard controls,
    so we can easily build complex navigation layouts with them, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Material components bring behaviors and visual appearance together so that,
    out of the box, we can use them to create professional-looking applications with
    minimal effort on our part. To a certain extent, Material can be thought of as
    a similar experience to using Bootstrap. In this chapter, we are going to concentrate
    on using Material instead of Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of paragraphs ago, we rather glibly mentioned that Angular Material
    brings Material Design components to Angular. This is a largely circular statement
    until we understand what Material Design is. If we search Google for the term,
    we get lots of articles telling us that Material Design is Google's design language.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, if we do Android development, the term comes up frequently because
    Android and Material are fundamentally linked. The idea behind Material is that
    it is in the best interests of our users if we can present interface elements
    in a way that is consistent. So, if we adopt Material, our applications will look
    familiar to users who are used to applications such as Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: The term *design language* is too vague, though. What does it actually mean
    to us? Why does it have its own fancy term? In the same way that our own language
    is broken down and structured into words and punctuation, we can break visual
    elements down into structures such as color and depth. As an example, the language
    tells us what colors mean, so if we see a button with one color on one screen
    in our application, it should have the same underlying usage across other screens
    in our application; we wouldn't use a green button to signify OK on one dialog
    and then Cancel on another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Angular Material is a simple process. We run the following command
    to add support for Angular Material, the **Component Design Toolkit** (**CDK**),
    flexible layout support, and animation support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: During the installation of the libraries, we will be prompted to choose what
    theme we want to use. The most visible aspect of the theme is the color scheme
    that is applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can choose from the following themes (examples of the themes are also supplied):'
  prefs: []
  type: TYPE_NORMAL
- en: Indigo/Pink ([https://material.angular.io?theme=indigo-pink](https://material.angular.io?theme=indigo-pink))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep Purple/Amber ([https://material.angular.io?theme=deeppurple-amber](https://material.angular.io?theme=deeppurple-amber))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pink/Blue Grey ([https://material.angular.io?theme=pink-bluegrey](https://material.angular.io?theme=pink-bluegrey))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purple/Green ([https://material.angular.io?theme=purple-green](https://material.angular.io?theme=purple-green))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our application, we are going to use the Indigo/Pink theme.
  prefs: []
  type: TYPE_NORMAL
- en: We are also prompted about whether or not we want to add HammerJS support. This
    library provides gesture recognition so our applications can respond to things
    such as panning or rotating using touch or the mouse. Finally, we have to choose
    whether or not we want to set up browser animations for Angular Material.
  prefs: []
  type: TYPE_NORMAL
- en: The CDK is an abstraction that says how common Material features work, but it
    does not say what they will look like. Without installing the CDK, many features
    of the Material library just won't work, so it's important to ensure that it is
    installed alongside `@angular/material`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Material to add navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will see, over and over again, that so much of what we need to do to add
    features to our application requires us to start with changes in `app.module.ts`.
    Material is no different, so we start by adding the following `import` lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the modules are available to us, we need to reference them in the
    `import` section of `NgModule`. Any module listed in this section will have its
    capabilities available in the templates that are in our application. When we add
    side-navigation support, for instance, we are relying on the fact that we have
    made `MatSidenavModule` available in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to set our application to use side navigation (the navigation
    strip that appears down the side of the screen). Structurally, we need to add
    three elements to enable side navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mat-sidenav-container` to host side navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat-sidenav` to display side navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mat-sidenav-content` to add the content that we are going to display'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start, we are going to add the following content to our `app.component.html`
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `mat-sidenav` line sets up a couple of the behaviors that we will exploit.
    We want the navigation to be fixed in the viewport and we give it the ID of drawer
    through the use of `#drawer`. We will use this ID shortly, when we trigger toggling
    whether the drawer is open or not.
  prefs: []
  type: TYPE_NORMAL
- en: Possibly the most interesting part of this line is `[opened]="false"`. This
    is the first point at which we encounter binding in our application. The use of
    `[]` here tells us that we want to bind to a particular property, `opened` in
    this case, and set it to `false`. As we will see as we go through this chapter,
    Angular has a rich binding syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the container to hold our navigation, we are going to add
    side-navigation content. We are going to add a toolbar to hold the `Menu` text
    and a navigation list that allows the user to import an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using `mat-list-item` in a standard anchor tag simply tells the Material engine
    that we want to lay the anchors in a list. Effectively, this section is an unordered
    list of anchors that are styled using Material styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to add the ability to toggle our navigation. The way that we do
    this is by adding a toolbar to our navigation content area. This toolbar will
    host a button that triggers the opening of the side-navigation drawer. In the
    `mat-sidenav-content` section, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The button uses another example of binding here—in this case, reacting to the
    `click` event—to trigger the `toggle` operation on the `mat-sidenav` item with
    the `drawer` ID. Rather than using `[eventName]` to bind to commands, we use `(eventName)`
    instead. Inside the button, we host `mat-icon` to represent the image used to
    toggle the navigation. In keeping with the philosophy that Material design represents
    a common way to show applications, Angular Material provides us with a number
    of standard icons, such as `menu`.
  prefs: []
  type: TYPE_NORMAL
- en: The Material fonts that we are using represent certain words, such as home and
    menu, as particular images via something called **ligatures**. This is a standard
    typography term that just means that there are well-known combinations of letters,
    numbers, and symbols that can be represented as an image. For instance, if we
    had `mat-icon` with the text `home`, this would be represented as a home icon.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first component – the FileUpload component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Import Image` link on our navigation has to actually do something, so
    we are going to write a component that will be displayed inside a dialog. As we
    are going to upload a file, we are going to call this `FileUpload`, and creating
    it is as simple as running the following Angular CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can shorten these standard Angular commands if we want, so we can use `ng
    g c` instead of `ng generate component`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command creates four files for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fileupload.component.html`: The HTML template for our component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileupload.component.scss`: Anything that we need to convert into CSS for
    our component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileupload.component.spec.ts`: Now, `spec.ts` files are used when we want
    to run unit tests against our Angular applications. Properly testing web applications
    is outside the scope of this book as it''s a book in its own right.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileupload.component.ts`: The logic for the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the `ng` command to generate the component also results in it being
    added into the `declarations` section in `app.module.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we open up `fileupload.component.ts`, the structure roughly looks like
    this (ignoring the imports at the top):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that Angular is making full use of TypeScript features that
    we have already looked at. In this case, `FileuploadComponent` has a `Component`
    decorator that tells Angular that we use `atp-fileupload` when we want to use
    a `FileuploadComponent` instance in our HTML. As we are using a separate HTML
    template and style, the other parts of the `@Component` decorator identify where
    those elements are. We could define styles and templates directly in this class,
    but in general, it's better to separate them out into their own files.
  prefs: []
  type: TYPE_NORMAL
- en: We can see our naming convention here, having specified `atp` when we created
    our application. It's a good idea to use something meaningful. When working in
    a team, you should find out what the standard is that your team follows and, if
    there is no standard, you should take the time to agree on how you want this to
    be named up front.
  prefs: []
  type: TYPE_NORMAL
- en: One of the features of the dialog is that it will show us a preview of the image
    that the user selects. We are going to separate the logic for reading the image
    from the component to keep a nice and clean separation of concerns going on.
  prefs: []
  type: TYPE_NORMAL
- en: Previewing files using a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges of developing UI applications is that there is a tendency
    for logic to creep into views that does not belong there. It becomes convenient
    to put a piece of logic in our `ts` views file because we know that the view is
    going to call out to it, but it does something that does not have any visible
    impact on the client.
  prefs: []
  type: TYPE_NORMAL
- en: We might, for instance, want to write some values from the UI back to the server.
    The only part of this that is relevant to the view is the data part; the actual
    writing to the server is a completely different responsibility. It would be useful
    to us if we had a simple way to create external classes that we could inject wherever
    we needed so that we would not need to worry about how to instantiate them. They
    would just be available to us to use whenever we needed them. Fortunately for
    us, the authors of Angular saw that there would be a need for this and provided
    us with services.
  prefs: []
  type: TYPE_NORMAL
- en: 'A service is simply a class that uses the `@Injectable` decorator and has an
    entry in the `declarations` section of the module. Apart from those requirements,
    there''s nothing else that is needed, so we could easily handcraft the class if
    we needed to. While we could do this, there''s no real reason to, because Angular
    helps us to generate the service using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create the `service`, we don''t actually have to add `service` at the
    end of the name as this command automatically does that for us. To see how this
    works, we are going to create a `service` that takes a file that has been chosen
    using the file selector and then reads it in so that it can be displayed back
    in the image upload dialog and on the main screen, or transferred over to be saved
    in the database. We start with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I like to generate my services in a `Services` sub-folder. Putting this in the
    filename creates it in the `Services` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ng generate service` command gives us the following basic outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading a file can be a time-consuming process, so we know that we want this
    operation to happen asynchronously. As we discussed in earlier chapters, we could
    do this with a callback, but a much better method is to use a promise. We add
    the following method call to the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is the point at which we are going to read the file in, this is when
    we are going to create the model that we are going to use to pass the data around
    our application. The model that we are going to use looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Image` holds the actual image that we are going to read in, and `Name` is
    the name of the file. This is why we populate this model at this point; we are
    working with the file itself so this is the point at which we have the filename
    available to us. The `Description` and `Tags` strings will be added by the image
    upload component. While we could create an intersection type at that point, for
    a simple model like this, it is enough to have a single model hold them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that we have said that we are using `Promise` means that we need to
    `retu``rn` an appropriate `Promise` from our `Preview` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `Promise`, we are going to create an instance of our model. As it
    is good practice, we are going to add some defensive code to ensure that we have
    an image file. If the file is not an image file, we are going to reject it, which
    can be handled gracefully by the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we reach this point, we know that we have a valid file, so we are going
    to set the name in the model using the filename, as well as using `FileReader`
    to read the image using `readAsDataURL`. When the read finishes, the `onload`
    event is raised, allowing us to add the image data to our model. At this point,
    we can resolve our promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using the service in the dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a working `preview` service, we can use it in our dialog.
    In order to use it, we are going to pass it into our constructor. As the service
    is injectable, we can let Angular take care of injecting it for us as long as
    we add an appropriate reference in our constructor. At the same time, we are going
    to add in a reference to the dialog itself, as well as a set of declarations that
    will be used in the corresponding HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The technique that allows Angular to automatically build up constructors with
    dependencies, without us having to explicitly instantiate them with `new`, is
    known as dependency injection. This fancy term simply means that we tell Angular
    what our class needs and leave the building of the objects for that class to Angular.
    In effect, we tell Angular *what* we need without worrying about *how* it will
    be built. The act of building the classes can lead to very complex internal hierarchies,
    as the dependency injection engine may have to build up classes that our code
    relies on as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this reference in place, we are going to create a method to accept the
    file selection from the file upload component and call our `Preview` method. `catch`
    is in place to cater for our defensive coding in the service, as well as to cater
    for situations where the user tries to upload a non-image file. If the file is
    invalid, the dialog will show a message informing the user of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do with the code side of the dialog is to allow the
    user to close the dialog and pass the selected values back to the calling code.
    We update the image source description and tags with the relevant local values.
    The `close` method closes the current dialog and returns `imageSource` back to
    the calling code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The file upload component template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final bit of work on our component is the actual HTML template in `fileupload.component.html`.
    As this is going to be a Material dialog, we are going to use a number of Material
    tags here. The simplest of these tags is used to add the dialog title, which is
    a standard header tag with the `mat-dialog-title` attribute. The reason that this
    attribute is used is to anchor the title to the top of the dialog so that if there
    was any scrolling, the title would stay fixed in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the title anchored to the top, we are ready to add our content and action
    buttons. First, we are going to add our content using the `mat-dialog-content`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element inside our content is the message that will be displayed
    if the message in the code for the component is set. The test to show whether
    or not the message is displayed uses another Angular binding, `*ngIf`. Here, the
    Angular binding engine evaluates the expression and renders out the value if the
    expression is true. In this case, it''s checking to see whether a message is present.
    It''s probably not going to come as a surprise to learn that the funny-looking `{{}}`
    code is also a binding. This one is used to write out the text of the item being
    bound to, in this case the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the change is one of my favorite parts of the application.
    There is no Material version of the standard HTML file component, so if we want
    to display a modern-looking equivalent, we have to show the file input as a hidden
    component and trick it into thinking it has been activated when the user presses
    a Material button. The file upload input is given the `fileUpload` ID and triggered
    when the button is clicked using `(click)="fileUpload.click()"`. When the user
    chooses something, the change event triggers the `OnImageSelected` code we wrote
    a couple of minutes ago:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding an image preview is as simple as adding an `img` tag that is bound to
    the preview image created when we successfully read in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add in fields for reading in the tags and description.
    We lay these out inside the `mat-form-field` sections. `matInput` tells the template
    engine what styling should be put in place for text input. The most interesting
    part is the use of the `[(ngModel)]="..."` part. This applies model binding for
    us, telling the binding engine what field to use from our underlying TypeScript
    component code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you have previously used an earlier version of Angular (prior to version
    6), you have probably come across `formControlName` as a means of binding to values.
    In Angular 6+, trying to combine `formControlName` and `ngModel` no longer works.
    See [https://next.angular.io/api/forms/FormControlName#use-with-ngmodel](https://next.angular.io/api/forms/FormControlName#use-with-ngmodel)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a touch of styling that needs to be associated with `mat-form-field`.
    In the `fileupload.component.scss` file, we add `.mat-form-field { display: block;
    }` to style the field so that it appears on a new line. If we miss this out, the
    input fields appear side by side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s no good having a dialog that we cannot close, or that cannot return values
    back to the calling code. The convention that we should follow for such operations
    is to put our Save and Cancel buttons inside a `mat-dialog-actions` section. The
    Cancel button is marked with `mat-dialog-close` so that it closes the dialog for
    us without us having to take any actions. The Save button follows the pattern
    that we should be familiar with by now, and calls the `Save` method in our component
    code when the button click is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have reached the point where we need to consider where we are going to store
    the images when they have been selected by the user, and where they are going
    to be retrieved from. In the previous chapter, we used a client-side database
    to store our data. From now on, we are going to work with server-side code as
    well. Our data is going to be stored in a MongoDB database, so we now need to
    look at how to use Node.js and Express to connect to the MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Express support into our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we develop client/server applications with Node.js, it makes our lives
    a lot easier if we can use a framework that allows us to develop the server-side
    part, especially if it comes with a rich ecosystem of *add-in* functionality to
    cover features such as connecting to databases and working with the local filesystem.
    This is where Express comes into play; it's a middleware framework that fits neatly
    alongside Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are going to create our server-side code completely from scratch, we
    should start off by creating the base `tsconfig.json` and `package.json` files.
    To do this, run the following commands in the `Server` folder, which will also
    add Express support by importing the Express and TypeScript Express definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a number of unnecessary options in our `tsconfig.json` file. We only
    need the bare minimum of options, so we set our configuration to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our server-side code is going to start with a class called `Server`. This class
    is going to `import express`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In order to create an instance of the Express application, we are going to create
    a private instance called `app` and set it to `express()` in the constructor.
    This has the effect of initializing the Express framework for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor also accepts a port number, which we will use when we tell
    our application to listen in our `Start` method. Obviously, we need to respond
    to web requests, so when our app receives a `get` request from `/`, we are going
    to respond by using `send` to send a message back to the web page. In our example,
    if we navigate to `http://localhost:3000/`, the web page URL that this method
    receives is the root and the function that is called returns `Hello from the server`
    back to the client. If we browse to anything other than `/`, our server will respond
    with `404`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To start our server, we must give it the port that we want to serve the content
    from and call `Start`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The reason that we have started off with a `Server` class, rather than following
    the approach of most Node.js/Express tutorials we see on the internet, is that
    we are looking to build the foundations of something that we will be able to re-use
    in future chapters. This chapter represents a starting point for this class, as
    future chapters will take what we have done here and grow the capabilities of
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: In its current state, the server will not be able to handle any incoming requests
    from Angular. It's time to start enhancing the server so that it can cope with
    requests that come across from the client. When the client sends its data, it
    will come across as a JSON-formatted request. This means that we need to tell
    the server to take the request and expose it in the body of any request we see.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we cover routing, shortly, we will see an example of us taking in the
    `request.Body` in its entirety. Something that we have to be aware of is that
    we will receive large requests from Angular; photographs can take up a lot of
    space. By default, the body parser has a limit of 100 KB, which won''t be large
    enough. We are going to raise the limit for the size of requests to 100 MB, which
    should be more than enough for any image we care to throw at our picture gallery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are talking about the data that is going to come across from Angular,
    we need to think about whether or not our application will accept the requests.
    Before we get into the topic of how our server will know which operation to perform
    based on which request, we need to address the issue of something called **Cross-Origin
    Request Sharing** (**CORS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'With CORS, we let known outside locations have access to restricted operations
    on our site. As Angular is running from a different site to our web server (`localhost:4200`
    as opposed to `localhost:3000`), we need to enable CORS support to post; otherwise,
    we will not return anything when we make requests from Angular. The first thing
    we have to do is add the `cors` middleware to our Node.js server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding CORS support is as simple as telling the application to use CORS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: CORS support provides a lot of fine-tuning that we don't need to take advantage
    of. For instance, it allows us to set the types of request methods that we are
    allowing, using `Access-Control-Allow-Methods`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can accept requests from Angular, we need to put the mechanism in
    place to route requests to appropriate request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Providing routing support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a request comes into our web server, we have to determine what response
    we want to send back. What we are building is going to respond to post and receive
    requests, which is similar to the way we build REST APIs. The ability to route
    incoming requests to responses is known as routing. Our application is going to
    handle three types of request:'
  prefs: []
  type: TYPE_NORMAL
- en: A `POST` request with `add` as the URL (in other words, when we see `http://localhost:3000/add/`).
    This will add an image and the associated details to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `GET` request with `get` in the URL (as in `http://localhost:3000/get/`).
    This gets the IDs of all the saved pictures and returns an array of these IDs
    back to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `GET` request with `/id/` in the URL. This uses an additional parameter in
    the URL to get the ID of the individual picture to send back to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason that we are returning an array of IDs is that an individual image
    can be large. If we were to attempt to return all the images in one go, we would
    slow down the displaying of the images at the client side as they can be displayed
    as each one is being loaded. We could also breach the limits of how big the response
    we are passing back can be. In the case of large chunks of data, it's always worth
    looking to see how we can minimize what we are transmitting with each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The destination of each request corresponds to a unique action that we want
    to take. This gives us a hint that we should be able to split each route into
    a single class that does nothing but service that action. To enforce the single
    action, we define the interface that we want our routing classes to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to add a helper class that will be responsible for instantiating
    each router instance. The class starts off simply enough, creating an `IRouter`
    array that the route instances will be added into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Things get interesting with the method that we use to add the instances in.
    What we are going to do is accept a generic type as a parameter and instantiate
    the type. To do this, we must take advantage of a TypeScript feature that allows
    us to accept a generic type and specify that when `new` is called on it, it returns
    an instance of the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have specified a generic constraint on our type, we will only accept
    `IRouter` implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The route that is passed into the method comes from Express. It's the router
    instance that we tell our application to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our routing support in place, we need to write the classes
    that correspond with the route requests we identified previously. The first one
    that we are going to look at is the class that accepts the `add` post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This method works by stating that when we receive an `/add/` post, we will take
    the request, process it, and send a response back. What we do with the request
    is up to us, but whenever the routing determines that we have a match here, we
    will execute this method. In this method, we are going to create a server-side
    representation of the picture and save it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this application, we have only introduced Express routing.
    Angular has its own routing engine, but for the purposes of what we wanted to
    put in place in our code, we have no need for it. In [Chapter 5](05f23d63-20d8-4d72-97af-042e8a5a3864.xhtml),
    *Angular ToDo App with GraphQL and Apollo*, we introduce Angular routing.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with MongoDB requires us to use something such as the popular Mongoose
    package. Installing Mongoose requires us to add both the `mongoose` and `@types/mongoose`
    packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Before we do anything with our database, we need to create a schema to represent
    the object that we want to save to the database. Unfortunately, this is where
    things can become a little bit tedious when we are developing applications using
    MEAN. While the schema superficially represents the model that we created on the
    Angular side, it is not the same model, so we have to type it in again.
  prefs: []
  type: TYPE_NORMAL
- en: 'More importantly, this means that if we change our Angular model, we have to
    regenerate our MongoDB schema to go hand in hand with the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For the purposes of our application, we are going to keep the image in the database—in
    the `Image` field—because this simplifies the infrastructure we have to put in
    place. In commercial-grade applications, we would choose to store the actual image
    separate to the database and the `Image` field would point to the physical location
    of the image. The location of the image would have to be accessible to our web
    application, and there would be policies in place to ensure that the images were
    safely backed up and could be easily restored.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the schema in place, we want to create a model that represents it. A good
    way to think about the interaction between the model and the schema is that the
    schema tells us *what* we want our data to look like. The model tells us *how*
    we want to manipulate it with the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the model ready, we need something to establish a connection
    to the database. The connection string for the MongoDB database has its own protocol,
    so it starts with the `mongodb://` pattern. For the purposes of our application,
    we are going to have MongoDB running on the same server as our server-side code;
    for larger applications, we really would want to separate these out, but for now,
    we are going to use `localhost:27017` in the connection string as MongoDB is listening
    on port `27017`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we want to be able to host many databases in MongoDB, the mechanism to tell
    the engine what database to use will supply a database name as part of the connection
    string. If the database doesn''t exist, it will be created. For our application,
    our database is going to be called `packt_atp_chapter_04`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As long as `Connect` is called before we attempt to do anything inside the database,
    our database should be available for us to use. Internally, `Connect` calls `mongoose.connect`
    using our connection string.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `Picture` model available to us, we can populate it directly from
    inside our `add` route. The request body contains the same parameters as our schema,
    so the mapping is invisible to us. When it has been populated, we call the `save`
    method. If there''s an error, we will send this back to the client; otherwise,
    we are going to send the picture back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In production applications, we wouldn't really want to send the error back to
    the client as that exposes the inner workings of our application. With a small
    application, intended for our own use only, it is less of an issue and it is a
    useful way to determine what has gone wrong with our application because we can
    simply view the error in the browser console window. Professionally, I would recommend
    sanitizing the error and sending one of the standard HTTP responses back instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler for `get` requests is no more complicated. It starts off in a similar
    fashion to the `add` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `Request` and `Response` types in our routes come from Express, so they
    should be added as `imports` in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are trying to do with this call is get the unique list of pictures
    the user has uploaded. Internally, each schema adds an `_id` field, so we are
    going to use the `Picture.distinct` method to get the full list of these IDs,
    which we are then going to send back to the client code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The last router that we need to put in place takes an individual ID request
    and retrieves the related item from the database. What makes this class slightly
    more complicated than the preceding ones is that we need to manipulate the schema
    slightly to exclude the `_id` field before we transmit the data back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we didn''t remove this field, the data our client would receive wouldn''t
    match the type that it was expecting, so it wouldn''t be able to automatically
    populate an instance. This would result in our client not displaying this data
    even though it received it back unless we manually populated it at the client
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The syntax with `:id` tells us that we are going to receive a parameter called
    `id` here. The request exposes a `params` object, which will expose this parameter
    as `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that the `id` parameter we have received is unique so we can use the
    `Picture.findOne` method to retrieve the matching entry from the database. In
    order to exclude the `_id` field from the result we are going to send back to
    the client, we must use `-_id` in the parameters to remove this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `Server` class needs a little bit of extra attention at this point. We have
    created the `RoutingEngine` and `Mongo` classes, but there is nothing in the `Server` class
    to hook them up. This is easily sorted by extending the constructor to add instances
    of them. We also need to add a call to `Start` to `connect` to the database. If
    we changed our `Server` class to an abstract class and added an `AddRouting` method,
    we would stop anyone from directly instantiating the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our applications will need to derive from this class and add their own routing
    implementations using the `RoutingEngine` class. This is the first step to breaking
    the server into smaller discrete units that separate out the responsibilities.
    One of the big changes in the `Start` method is that, once we have added our routing,
    we tell the application to use the same `express.Router()` that our routing engine
    is using, so any requests are then automatically hooked up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now create a concrete class that extends our `Server`
    class and adds the routers that we have created. This is the class that we will
    start when we run our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to remove the original call to start the `new Server(3000).Start();` server.
  prefs: []
  type: TYPE_NORMAL
- en: Our server-side code is finished. We aren't going to add any more features to
    it, so we can get back to the client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After all our hard work writing the server-side code and letting the user choose
    what image they want to upload, we need something to actually show the images.
    We are going to create a `PageBody` component, which we will display and add as
    an element inside our main navigation. Again, we''re going to let Angular do the
    hard work and create the infrastructure for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'With this component created, we''re going to update `app.component.html` with
    the `PageBody` component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When we installed Material support, one of the features we added was Flex Layout,
    which provides flexible layout support for Angular. We are going to take advantage
    of this in our application by setting the cards to lay out, initially in rows
    of three, wrapping to the next line when we need to. Internally, the layout engine
    uses **Flexbox** (a **flexible box**) to perform the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that the engine can adjust widths and heights as it sees fit, in
    order to take advantage of screen real estate. This behavior should be familiar
    to you, from the way we set up Bootstrap, which adopted Flexbox. As Flexbox defaults
    to trying to lay items out on one line, we''re going to start by creating a `div` tag
    that alters the behavior to wrap along rows with a 1% space gap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With the layout container in place, we now need to set up the cards to hold
    the images and relevant details. As we could have a dynamic number of cards, we
    really hope that Angular has a means that allows us to define a card effectively
    as a template and add the individual elements inside. A card is added using `mat-card`,
    and with a little bit of Angular magic (okay, another bit of Angular binding),
    we can iterate over the pictures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'What this section is doing is setting up our card using `ngFor`, which is an
    Angular directive that iterates over an underlying array, `Pictures` in this case,
    and is effective for creating a variable that we can use in the body of our card.
    With this, we are going to add a card title that binds to `picture.Name`, and
    an image that binds the source to `picture.Image`. Finally, we are going to display `picture.Description`
    below the image inside a paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'For completeness, we have added a bit of styling to our `picture-card-layout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be good to see what our card styling looks like in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02d7a720-b84f-41a6-973c-6fdd95d4b614.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s the HTML in place for our page body, but we need to put the code in
    the TypeScript behind this to actually start serving some of the data that our
    cards are going to bind to. In particular, we have to provide the `Pictures` array
    that we are going to populate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We have a number of services here that we haven't encountered yet. We are going
    to start by looking at how our application knows when instances of `IPictureModel`
    have become available.
  prefs: []
  type: TYPE_NORMAL
- en: Using RxJS to watch for images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's no good having our application be capable of choosing images through the
    dialog, or fetching them from the server during the load process, if we can't
    display them in the page body. As our application has features that are loosely
    related to each other, we don't want to introduce events as the mechanism for
    controlling when these happen, since this introduces tight coupling between things
    such as our page body component and the loading service.
  prefs: []
  type: TYPE_NORMAL
- en: What we need are services that sit between the code that handles the interaction
    (such as loading the data) and the page body, and passes notifications from one
    side to the other when something interesting has happened. The mechanism that
    Angular provides to do this is called **Reactive Extensions for JavaScript** (**RxJS**).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive extensions are an implementation of something called the observer pattern
    (there's that word pattern again). This is a simple pattern to understand and
    you will have been using it for a while now, possibly without even recognizing
    it. The idea with the observer pattern is that we have a class that has something
    called a `Subject` type. Internally, this `Subject` type maintains a list of dependencies
    and, when it needs to do so, notifies those dependencies that they need to react,
    potentially passing the state over that they need to react to.
  prefs: []
  type: TYPE_NORMAL
- en: This might ring a vague bell that this is precisely what events do, so why should
    we concern ourselves with this pattern? You would be correct in your understanding—events
    are just a very specialist form of the observer pattern, but they have some weaknesses
    that things such as RxJS are designed to overcome. Suppose we had a real-time
    stock trading application where we had tens of thousands of stock ticks coming
    to our client every second. Obviously, we wouldn't want our client to handle all
    of those ticks, so we would have to write code inside our event handlers to start
    filtering out notifications. That's a lot of code that we would have to write,
    which would potentially be duplicated across different events. There also has
    to be a tight relationship between classes when we use events, so one class has
    to know about another in order to hook up to an event.
  prefs: []
  type: TYPE_NORMAL
- en: As our applications get bigger and more complex, there could be a lot of *distance*
    between the class that brings in the stock tick and the one that displays it.
    Therefore, we would end up building a complex hierarchy of events, where `class
    A` listens to an event on `class B` and when `class B` raises that event, it has
    to re-raise it so that `class C` can react to it. The more distributed our code
    becomes internally, the less we want to encourage this tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: With libraries such as RxJS, we solve these issues (and many more) by decoupling
    away from events. With RxJS, we can make sophisticated subscription mechanisms,
    where we can do things such as throttling the number of notifications we react
    to or choosing only to subscribe to data and changes where certain conditions
    are met. As new components are added at runtime, they can query the observable
    class to see what values are already available, in order to prepopulate the screen
    with data that has already been received. These features are more than we need
    in this application, but as we will use them in future chapters, it makes sense
    for us to be aware that they are available to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application has two things we need to react to:'
  prefs: []
  type: TYPE_NORMAL
- en: When the page is loaded, the images will be loaded from the server, so we need
    to react to each image being loaded in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user chooses an image from the dialog, after the dialog has closed
    because the user chose Save, we need to trigger a save to the database, and also
    display the image on the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It''s probably not going to come as a surprise to learn that we are going to
    create services to satisfy these two requirements. As they both internally do
    the same thing, the only difference is what the subscriber needs to do once it
    reacts. We start off by creating a simple base class that these services will
    derive from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Our starting point in this class is to define the `Subject` that our observable
    will use. As we noted, there are different `Subject` specializations in RxJS.
    As we only want our `Subject` to notify other classes of the latest value, we
    are going to use `BehaviorSubject` and set the current value to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We aren''t going to expose the `Subject` to external classes; instead, we are
    going to create a new observable with this subject as the source. We do this so
    that, if we wanted to, we could customize the subscription logic—the throttling
    issue being an example of why we might want to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We call this property the `context` property because it will carry the context
    of the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, external classes now have access to the observable source,
    so whenever we notify them that they need to react, they can. As the operation
    that we want to perform is based either on the user adding `IPictureModel`, or
    the data loading adding one, we are going to call the method that triggers the
    observable `add` chain. Our `add` method will receive the instance of the model
    that we want to send to our subscribing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We identified that we needed two services to handle the different ways `IPictureModel`
    was received. The first service is called `AddImageService` and, as we would expect,
    can be generated for us by using Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already written the logic for our observable, our service simply
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Our second service is called `LoadImageService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this class is going to extend `ContextServiceBase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you might be wondering why we have two services that appear to
    do the same thing. Theoretically, we could have had both do exactly the same thing.
    The reason that I chose to implement two versions comes back to understanding
    that one of the things that we want to do is display the image and trigger a save
    whenever we raise a notification through `AddImageService`. Suppose we also used `AddImageService`
    when the page was loaded. If we did this, then whenever the page was loaded, it
    would also trigger the save so we would end up duplicating images. Now, we could
    introduce filtering to prevent duplicates from happening, but I chose to keep
    things simple by using two separate classes for this first visit to RxJS. In the
    coming chapters, we will see how to make more complex subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have covered one side of the client/server interaction. It''s now time for
    us to address the other side—the code that actually calls the routes that our
    server exposes. Not surprisingly, we add a service that takes care of this communication.
    We start with the code to create the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Our service is going to make use of three things. The first thing that it will
    rely on is an `HttpClient` instance to manage the `get` and `post` operations.
    We also bring in the `AddImageService` and `LoadImageService` classes that we
    have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The first point of contact between our server and client is the piece of code
    we are going to use when the user has chosen the image from the dialog. Once they
    have clicked Save, we are going to set off a chain of actions that results in
    the data being saved in the server. We are going to set up our HTTP header to
    set the content type to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Thinking back to our RxJS classes, we know that we have two separate subscriptions
    available to us. The one that we want to use here reacts when `AddImageService`
    is pushed out, so we are going to add this subscription to `SubscribeToAddImageContextChanges`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When we receive a message in this subscription, we are going to post it to
    the server, which will end up saving the data to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the post is to pass the endpoint address, which ties nicely back
    to the server-side code that we wrote earlier, along with the message and any
    HTTP options. Because our message content is semantically the same as the model
    that is received at the server side, it will automatically be decoded at that
    side. As we can receive content back from the server, we have a subscription that
    we can use to decode the messages coming back from our Express code base. When
    we put this code together, we end up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The other side of our transfer service is responsible for getting the images
    back from the server. As you may remember from our Express code, we are going
    to receive the data in two stages. The first stage is that we will receive an
    array of IDs that match all the pictures available to us. To fetch this array,
    we call `get` on `HttpClient`, telling it that we are going to get an array of
    strings, by pointing to the `/get/` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the array of strings, we need to iterate over each element
    and call `get` again, this time adding `/id/...` to tell the server which one
    we are interested in. When the data comes back, we call the `add` method on `LoadImageService`,
    passing in `IPictureModel`. This ties back to our page body, as we will see shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are going to add an `Initialize` method, which we will use to initialize
    the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Back to the page body component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have `LoadImageService`, `AddImageService`, and `TransferDataService`
    written, we can use them in the `PageBodyComponent` initialization code in `ngOnInit`,
    which is called when the component is initializing. The first thing we need to
    do is affect is to call the `Initialize` function in `TransferDataService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish off this component, and to actually populate the `Pictures` array,
    we need to hook up to the context for both of our RxJS services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping up by displaying the dialog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have probably noticed that we haven't actually put any code in place
    to display the dialog or trigger `AddImageService` when the user closes the dialog.
    To do this, we are going to add the code in `app.component.ts` and make a minor
    adjustment to the related HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a constructor that accepts a Material dialog and `AddImageService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add a public method that our HTML template will bind to. We are
    going to call this `ImportImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The related change to our HTML template is to add the call to `ImportImage` to
    respond to the `click` event, via the `(click)` event binding, on our menu list
    item in `app.component.html`. Once again, we see Angular binding coming into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to configure our dialog to behave in a certain way. We don''t
    want the user to be able to automatically close it by pressing the *Esc* key.
    We want it to be automatically focused and to be 500 pixels wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can show our dialog using this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to be able to identify when the dialog is closed and automatically
    call our add image service—our `add` method—which will notify the transfer data
    service that the data must be sent to the client, and will also notify the page
    body that there is a new image to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the last piece of code that we put in place. Our client code now has
    neatly segregated services and components that work in co-operation with our Material
    dialog. Our dialog looks like this when in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1edd640e-c713-4728-ab76-200216af5a09.png)'
  prefs: []
  type: TYPE_IMG
- en: We have finished wiring our dialog into our Angular code. We have a fully working
    application that we can use to save images into our database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, using the MEAN stack, we have developed an application that
    allows the user to load images from their disk, add information about the images,
    and transfer data from the client to the server. We wrote code that created a
    server that could respond to incoming requests, as well as being able to save
    data to and retrieve data from a database. We discovered how to use Material Design
    and laid out our screen using Angular Material, along with navigation elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to expand our Angular knowledge and create
    a ToDo application that uses GraphQL to visualize its data.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say that we are developing an application using the MEAN stack, what
    are the major components of the stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we supply a prefix when we created our Angular client?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we start an Angular application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we state that Material is a design language, what do we mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we tell Angular to create a service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Express routing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which pattern does RxJS implement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is CORS and why do we need it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about the full MEAN stack, Packt has the following book available: *MongoDB,
    Express, Angular, and Node.js Fundamentals* by Paul Oluyege ([https://www.packtpub.com/web-development/mongodb-express-angular-and-nodejs-fundamentals](https://www.packtpub.com/web-development/mongodb-express-angular-and-nodejs-fundamentals))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about learning reactive coding with JavaScript, Packt also
    has the following book available: *Mastering Reactive JavaScript* by Erich de
    Souza Oliveira ([https://www.packtpub.com/in/web-development/mastering-reactive-javascript](https://www.packtpub.com/in/web-development/mastering-reactive-javascript))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
