- en: Integration Of JUnit 5 With External Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5与外部框架的集成
- en: If I have seen further than others, it is by standing upon the shoulders of
    giants.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我看得比别人更远，那是因为我站在巨人的肩膀上。
- en: '- Isaac Newton'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 艾萨克·牛顿'
- en: 'As described in [Chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What''s New in JUnit*, the extension model of JUnit 5 allows us to extend the
    core functionality of JUnit 5 by a third party (tool vendor, developers, and so
    on). In the Jupiter extension model, an extension point is a callback interface
    that the extension implements and then registers (activates) in the JUnit 5 framework.
    As we will discover in this chapter, the JUnit 5 extension model can be used to
    provide seamless integration with existing third-party frameworks. Concretely,
    in this chapter, we review JUnit 5 extension for the following technologies:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb)中描述的，JUnit 5的扩展模型允许我们通过第三方（工具供应商、开发人员等）扩展JUnit
    5的核心功能。在Jupiter扩展模型中，扩展点是扩展实现的回调接口，然后在JUnit 5框架中注册（激活）。正如我们将在本章中发现的那样，JUnit 5的扩展模型可以用于与现有第三方框架提供无缝集成。具体来说，在本章中，我们将审查JUnit
    5与以下技术的扩展：
- en: '**Mockito**: Mock (test double) unit testing framework.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mockito**：模拟（测试替身）单元测试框架。'
- en: '**Spring**: A Java framework for building enterprise applications.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spring**：用于构建企业应用程序的Java框架。'
- en: '**Selenium**: A testing framework to automate the navigation and assessment
    of web applications.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Selenium**：用于自动化导航和评估Web应用程序的测试框架。'
- en: '**Cucumber**: Testing framework which allows us to create acceptance tests
    written following a **Behavior-Driven Development** (**BDD**) style.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cucumber**：测试框架，允许我们按照**行为驱动开发**（**BDD**）风格编写验收测试。'
- en: '**Docker**: A software technology which allows us to pack and run any application
    as a lightweight and portable container.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：一种软件技术，允许我们将任何应用程序打包并作为轻量级和可移植的容器运行。'
- en: 'Moreover, we discover that the JUnit 5 extension model is not the only way
    to integrate with the external world. Concretely, we study how JUnit 5 can be
    used together with the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们发现JUnit 5扩展模型并不是与外部世界集成的唯一方式。具体来说，我们研究了JUnit 5如何与以下内容一起使用：
- en: '**Android** (mobile operating system based on Linux): We can run Jupiter tests
    in an Android project using a Gradle plugin for JUnit 5.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**（基于Linux的移动操作系统）：我们可以使用JUnit 5的Gradle插件在Android项目中运行Jupiter测试。'
- en: '**REST** (architectural style for designing distributed systems): We can interact
    and verify REST services simply using third-party libraries (such as REST Assured
    or WireMock), or using the fully integrated approach of Spring (tests together
    with the service implementation).'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST**（用于设计分布式系统的架构风格）：我们可以简单地使用第三方库（如REST Assured或WireMock）与REST服务进行交互和验证，或者使用Spring的完全集成方法（测试与服务实现一起）。'
- en: Mockito
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito
- en: 'Mockito ([http://site.mockito.org/](http://site.mockito.org/)) is an open source
    mock unit testing framework for Java, first released in April 2008\. Of course,
    Mockito is not the only mock framework for Java; there are others, such as the
    following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Mockito ([http://site.mockito.org/](http://site.mockito.org/))是一个用于Java的开源模拟单元测试框架，于2008年4月首次发布。当然，Mockito并不是Java的唯一模拟框架；还有其他的，比如以下这些：
- en: EasyMock ([http://easymock.org/](http://easymock.org/)).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EasyMock ([http://easymock.org/](http://easymock.org/)).
- en: JMock ([http://www.jmock.org/](http://www.jmock.org/)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMock ([http://www.jmock.org/](http://www.jmock.org/)).
- en: PowerMock ([http://powermock.github.io/](http://powermock.github.io/)).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerMock ([http://powermock.github.io/](http://powermock.github.io/)).
- en: JMockit ([http://jmockit.org/](http://jmockit.org/)).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JMockit ([http://jmockit.org/](http://jmockit.org/)).
- en: 'We can say that, at the time of writing, Mockito is the preferred mock framework
    in Java tests for the most developers and testers. To justify that claim, we use
    the following screenshot, which shows the evolution of the terms Mockito, EasyMock,
    JMock, PowerMock, and JMockit in Google Trends ([https://trends.google.com/](https://trends.google.com/))
    from 2004 to 2017\. At the beginning of this period, we can see there was a significant
    interest on EasyMock and JMock; nevertheless, Mockito was more in demand compared
    with the rest of the frameworks:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，在撰写本文时，Mockito是大多数开发人员和测试人员在Java测试中首选的模拟框架。为了证明这一点，我们使用了以下截图，显示了Google趋势（[https://trends.google.com/](https://trends.google.com/)）中Mockito、EasyMock、JMock、PowerMock和JMockit从2004年到2017年的发展。在这段时期的开始，我们可以看到EasyMock和JMock受到了很大的关注；然而，与其他框架相比，Mockito更受欢迎：
- en: '![](img/00096.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: Google Trends evolution of Mockito, EasyMock, JMock, PowerMock, and JMockit
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Google趋势演变的Mockito、EasyMock、JMock、PowerMock和JMockit
- en: Mockito in a nutshell
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mockito简介
- en: As introduced in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective on Software Quality and Java Testing*, there are different levels
    of software testing, such as unit, integration, system, or acceptance. Regarding
    unit tests, they should be executed in isolation for a single piece of software,
    for example, an individual class. The objective in this level of tests is to verify
    the functionality of the unit and not of its dependencies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)中介绍的，软件测试有不同的级别，如单元测试、集成测试、系统测试或验收测试。关于单元测试，它们应该在单个软件部分（例如单个类）的隔离环境中执行。在这个测试级别，目标是验证单元的功能，而不是它的依赖关系。
- en: In other words, we want to test what is known as the **System Under Test** (**SUT**)
    but not its **Depended-On Components** (**DOCs**). To achieve this isolation,
    we use typically *test doubles* to replace these DOCs. Mock objects are a kind
    of test double, which are programmed with expectations about the real DOC.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们想要测试所谓的**被测系统**（**SUT**），而不是它的**依赖组件**（**DOCs**）。为了实现这种隔离，我们通常使用*测试替身*来替换这些DOCs。模拟对象是一种测试替身，它们被编程为对真实DOC的期望。
- en: 'In few words, Mockito is a testing framework that allows mock object creation,
    stubbing, and verification. To that aim, Mockito provides an API to isolate the
    SUT and its DOCs. Generally speaking, using Mockito involves three different steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Mockito是一个允许创建模拟对象、存根和验证的测试框架。为此，Mockito提供了一个API来隔离SUT及其DOC。一般来说，使用Mockito涉及三个不同的步骤：
- en: '**Mocking objects**: In order to isolate our SUT, we use the Mockito API to
    create mocks of its associated DOC(s). This way, we guarantee that the SUT is
    not depending on its real DOC(s), and our unit test is actually focused on the
    SUT.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟对象**：为了隔离我们的SUT，我们使用Mockito API来创建其关联DOC的模拟对象。这样，我们确保SUT不依赖于其真实的DOC，我们的单元测试实际上是专注于SUT。'
- en: '**Setting expectations**: The differential aspect of mocks object with respect
    to other test doubles (such as stub) is that mock objects can be programmed with
    custom expectations according to the needs of the unit test. This process in the
    Mockito jargon is known as stubbing methods, in which these methods belong to
    the mocks. By default, mock objects mimic the behavior of real objects. In practical
    terms, it means that mock objects return appropriate dummy values such as false
    for Boolean types, null for objects, 0 for integer or long return types, and so
    on. Mockito allows us to change this behavior with a rich API, which allows stubbing
    to return a specific value when a method is called.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置期望**：与其他测试替身（如存根）相比，模拟对象的差异性在于可以根据单元测试的需要编程自定义期望。在Mockito的术语中，这个过程被称为存根方法，这些方法属于模拟对象。默认情况下，模拟对象模仿真实对象的行为。在实际操作中，这意味着模拟对象返回适当的虚拟值，例如布尔类型的false，对象的null，整数或长整数返回类型的0，等等。Mockito允许我们使用丰富的API更改这种行为，该API允许存根在调用方法时返回特定值。'
- en: When a mock object is not programmed with any expectation (that is, it has no
    *stubbing method*), technically speaking, it is not a *mock* object but a *dummy*
    object (take a look at [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective on Software Quality and Java Testing* for the definition).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟对象没有编程任何期望（即，它没有*存根方法*），从技术上讲，它不是*模拟*对象，而是*虚拟*对象（请参阅[第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)，*软件质量和Java测试的回顾*，以获取定义）。
- en: '**Verification**: At the end of the day, we are creating tests, and thus, we
    need to implement some kind of verification for the SUT. Mockito provides a powerful
    API to carry out different types of verifications. With this API, we assess the
    interactions with the SUT and DOCs, verifying the invocation order with a mock,
    or capturing and verifying the argument passed to a stubbed method. Furthermore,
    the verification capabilities of Mockito can be complemented with the built-in
    assertion capabilities of JUnit or using a third-party assertion library (for
    example, Hamcrest, AssertJ, or Truth). See section *Assertions* within [Chapter
    3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb), *JUnit 5 Standard Tests*.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**验证**：归根结底，我们正在创建测试，因此，我们需要为SUT实现某种验证。Mockito提供了一个强大的API来进行不同类型的验证。通过这个API，我们评估与SUT和DOC的交互，验证模拟对象的调用顺序，或捕获和验证传递给存根方法的参数。此外，Mockito的验证能力可以与JUnit的内置断言能力或使用第三方断言库（例如Hamcrest、AssertJ或Truth）相结合。请参阅[第3章](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb)中的*断言*部分，*JUnit
    5标准测试*。'
- en: 'The following table summarizes the Mockito APIs grouped by the aforementioned
    phases:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了按前述阶段分组的Mockito API：
- en: '| **Mockito API** | **Description** | **Phase** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **Mockito API** | **描述** | **阶段** |'
- en: '| `@Mock` | This annotation identifies a mock object to be created by Mockito.
    This is used typically for DOC(s). | 1.Mocking objects |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `@Mock` | 此注解标识要由Mockito创建的模拟对象。这通常用于DOC。 | 1.模拟对象 |'
- en: '| `@InjectMocks` | This annotation identifies the object in which the mocks
    are going to be injected. This is used typically to the unit we want to test,
    that is, our SUT. | 1.Mocking objects |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `@InjectMocks` | 此注解标识要注入模拟对象的对象。这通常用于我们要测试的单元，也就是我们的SUT。 | 1.模拟对象 |'
- en: '| `@Spy` | In addition to mocks, Mockito allows us to create spy objects (that
    is, a partial mock implementation, since they use the real implementation in non-stubbed
    methods). | 1.Mocking objects |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `@Spy` | 除了模拟对象，Mockito还允许我们创建间谍对象（即部分模拟实现，因为它们在非存根方法中使用真实实现）。 | 1.模拟对象 |'
- en: '| `Mockito.when(x).thenReturn(y)``Mockito.doReturn(y).when(x)` | These methods
    allow us to specify the value (`y`) that should be returned by the stubbed method
    (`x`) of a given mock object. | 2.Setting expectations (*stubbing methods*) |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenReturn(y)``Mockito.doReturn(y).when(x)` | 这些方法允许我们指定给定模拟对象的存根方法（`x`）应返回的值（`y`）。
    | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.when(x).thenThrow(e)``Mockito.doThrow(e).when(x)` | These methods
    allow us to specify the exception (`e`) that should be thrown when calling a stubbed
    method (`x`) of a given mock object. | 2.Setting expectations (*stubbing methods*)
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenThrow(e)``Mockito.doThrow(e).when(x)` | 这些方法允许我们指定在调用给定模拟对象的存根方法（`x`）时应抛出的异常（`e`）。
    | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.when(x).thenAnswer(a)``Mockito.doAnswer(a).when(x)` | Unlike returning
    a hardcoded value, a dynamic user-defined logic (`Answer a`) is executed when
    a given method (`x`) of the mock is invoked. | 2.Setting expectations (*stubbing
    methods*) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenAnswer(a)``Mockito.doAnswer(a).when(x)` | 与返回硬编码值不同，当调用模拟对象的给定方法（`x`）时，将执行动态用户定义的逻辑（`Answer
    a`）。 | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.when(x).thenCallRealMethod()``Mockito.doCallRealMethod().when(x)`
    | This method allows us the real implementation of a method instead the mocked
    one. | 2.Setting expectations (*stubbing methods*) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `Mockito.when(x).thenCallRealMethod()``Mockito.doCallRealMethod().when(x)`
    | 此方法允许我们调用实际方法而不是模拟方法。 | 2.设置期望（*存根方法*） |'
- en: '| `Mockito.doNothing().when(x)` | When using a spy, the default behavior is
    calling the real methods of the object. In order to avoid the execution of a `void`
    method `x`, this method is used. | 2.Setting expectations (*stubbing methods*)
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| `BDDMockito.given(x).willReturn(y)``BDDMockito.given(x).willThrow(e)``BDDMockito.given(x).willAnswer(a)``BDDMockito.given(x).willCallRealMethod()`
    | Behaviour-driven development is a test methodology in which tests are specified
    in terms of scenarios and implemented as *given* (initial context), *when* (event
    occurs), and *then* (ensure some outcomes). Mockito supports this type of tests
    through the class `BDDMockito`. The behavior of the stubbed methods (`x`) is equivalent
    to `Mockito.when(x)`. | 2.Setting expectations (*stubbing methods*) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.verify()` | This method verifies the invocation of mock objects.
    This verification can be optionally enhanced using the following methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '`times(n)`: The stubbed method is invoked exactly `n` times.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never()`: The stubbed method is never called.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atLeastOnce()`: The stubbed method is invoked at least once.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atLeast(n)`: The stubbed method is called at least n times.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atMost(n)`: The stubbed method is called at the most n times.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`only()`: A mock fails if any other method is called on the mock object.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout(m)`: This method is called in `m` milliseconds at the most.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| 3.Verification |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.verifyZeroInteractions()``Mockito.verifyNoMoreInteractions()` |
    These two methods verify that a stubbed method has no interactions. Internally,
    they use the same implementation. | 3.Verification |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `@Captor` | This annotation allows us to define an `ArgumentChaptor` object,
    aimed to verify the arguments passed to a stubbed method. | 3.Verification |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.inOrder` | It facilitates verifying whether interactions with a
    mock were performed in a given order. | 3.Verification |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: 'The use of the different annotations depicted in preceding the table (`@Mock`,
    `@InjectMocks`, `@Spy`, and `@Captor`) is optional, although it is recommendable
    for the shake of test readability. In other words, there are alternatives to the
    use of annotation using different Mockito classes. For instance, in order to create
    a `Mock`, we can use the annotation `@Mock` as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The alternative to this would be using the method `Mockito.mock`, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following sections contains comprehensive examples using the Mockito APIs
    described in preceding table within Jupiter tests.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Mockito
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of this writing, there is no official JUnit 5 extension to use
    Mockito in Jupiter tests. Nevertheless, the JUnit 5 team provides a simple ready
    to use Java class implementing a simple but effective extension for Mockito. This
    class can be found in the JUnit 5 user guide ([http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/)),
    and its code is the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This extension (among others) is planned to be released in the open source project
    JUnit Pioneer ([http://junit-pioneer.org/](http://junit-pioneer.org/)). This project
    is maintained by Nicolai Parlog, Java developer and author of the blog CodeFX
    ([https://blog.codefx.org/](https://blog.codefx.org/)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the preceding class, we can check that it is simply a use case of
    the Jupiter extension model (described in [chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What''s New In JUnit 5,* of this book), which implements the extensions callback
    `TestInstancePostProcessor` and `ParameterResolver`. Thanks to the first, after
    the test case is instantiated, the `postProcessTestInstance` method is invoked,
    and in the body of this method, the initialization of mocks is carried out:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This has the same effect that using the JUnit 4 runner for Mockito: `@RunWith(MockitoJUnitRunner.class)`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this extension also implements the interface `ParameterResolver`.
    That means that dependency injection at method level will be allowed in tests,
    which register the extension (`@ExtendWith(MockitoExtension.class)`). In particular,
    the annotation will inject mock objects for test parameters annotated with `@Mock`
    (located in package `org.mockito`).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个扩展还实现了接口`ParameterResolver`。这意味着在测试中，注册了这个扩展（`@ExtendWith(MockitoExtension.class)`）的情况下，将允许在方法级别进行依赖注入。特别是，这个注解将为用`@Mock`注解的测试参数注入模拟对象（位于`org.mockito`包中）。
- en: 'Let’s see some examples to clarify the use of this extension together with
    Mockito. As usual, we can find the source code of this examples on the GitHub
    repository [https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5).
    A copy of the preceding extension (`MockitoExtension`) is contained in the project
    `junit5-mockito`. To guide these examples, we implement a typical use case in
    software applications: the login of a user in a software system.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子来澄清这个扩展与Mockito一起使用的情况。像往常一样，我们可以在GitHub仓库[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)上找到这些例子的源代码。前面的扩展（`MockitoExtension`）的副本包含在项目`junit5-mockito`中。为了指导这些例子，我们在软件应用程序中实现了一个典型的用例：用户在软件系统中的登录。
- en: 'In this use case, we suppose that a user interacts with a system made up by
    three classes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，我们假设用户与由三个类组成的系统进行交互：
- en: '`LoginController`: The class which receives the request from the user, returning
    a response as a result. This request is dispatched to the `LoginService` component.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginController`：接收用户的请求，并返回响应的类。这个请求被分派到`LoginService`组件。'
- en: '`LoginService`: This class implements the functionality of the use case. To
    that aim, it needs to confirm whether or not the user is authenticated in the
    system. To that, it needs to read the persistence layer, implemented in the `LoginRepository`
    class.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginService`：这个类实现了用例的功能。为了实现这个目的，它需要确认用户是否在系统中得到了认证。为了做到这一点，它需要读取`LoginRepository`类中实现的持久化层。'
- en: '`LoginRepository`: This class allows to access the persistence layer of the
    system, typically implemented by means of a database. This class can also be called
    **Data Access Object** (**DAO**).'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoginRepository`：这个类允许访问系统的持久化层，通常是通过数据库实现的。这个类也可以被称为**数据访问对象**（**DAO**）。'
- en: 'In terms of composition, the relationship of these three classes are is following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合方面，这三个类的关系如下：
- en: '![](img/00097.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: Login use case class diagram (composition relationship among the classes)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用例类图（类之间的组合关系）
- en: 'The sequence diagram of the two basic operations involved in the use case (login
    and logout) is depicted in the following chart:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 用例中涉及的两个基本操作（登录和注销）的序列图如下图所示：
- en: '![](img/00098.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: Login use case sequence diagram
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 登录用例序列图
- en: 'We implement this example with several simple Java classes. First, the `LoginController`
    uses the `LoginService` by composition:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用几个简单的Java类来实现这个例子。首先，`LoginController`通过组合使用`LoginService`：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `UserForm` object is a simple Java class, sometimes called **Plain-Old
    Java Object** (**POJO**), with two properties username and password:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserForm`对象是一个简单的Java类，有时被称为**普通的Java对象**（**POJO**），有两个属性username和password：'
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, the service depends on the repository (`LoginRepository`) for data access.
    In this example, the service also implements a user registry using a Java list
    in which the authenticated users are stored:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务依赖于`LoginRepository`进行数据访问。在这个例子中，服务还使用Java列表实现了用户注册，其中存储了经过认证的用户：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, the `LoginRepository` is as follows. For the sake of simplicity, instead
    of accessing a real database, this component implements a map in which the credentials
    of the hypothetical user of the system are stored (where `key`*=* username, and
    `value`=password):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`LoginRepository`如下。为了简单起见，这个组件实现了一个映射，而不是访问真实的数据库，其中存储了系统中假设用户的凭据（其中`key`*=*
    username，`value`=password）：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we are going to test our system using JUnit 5 and Mockito. First of all,
    we test the controller component. Since we are doing unit tests, we need to isolate
    the `LoginController` login from the rest of the system. To do that, we need to
    mock its dependencies, in this example, the `LoginService` component. Using the
    SUT/DOC terminology explained at the beginning, in this test, our SUT is the class
    `LoginController` and its DOC is the class `LoginService`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用JUnit 5和Mockito来测试我们的系统。首先，我们测试控制器组件。由于我们正在进行单元测试，我们需要将`LoginController`登录与系统的其余部分隔离开来。为了做到这一点，我们需要模拟它的依赖关系，在这个例子中，是`LoginService`组件。使用在开头解释的SUT/DOC术语，在这个测试中，我们的SUT是`LoginController`类，它的DOC是`LoginService`类。
- en: 'To implement our test with JUnit 5, first we need to register the `MockitoExtension`
    with `@ExtendWith`. Then, we declare the SUT with `@InjectMocks` (class `LoginController`)
    and its DOC with `@Mock` (class `LoginService`). We implement two tests (`@Test`).
    First one (`testLoginOk`) specifies when the method login of mock `loginService`
    is called, this method should return true. After that, the SUT is actually exercised,
    and its response is verified (in this case, the returned String must be `OK`).
    Moreover, the Mockito API is used again to assess that no more interactions with
    the mock `LoginService` is done. The second test (`testLoginKo`) is equivalent,
    but stubbing the method login to return false and therefore the response of the
    SUT `(LoginController)` must be `KO` in this case:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用JUnit 5实现我们的测试，首先我们需要使用`@ExtendWith`注册`MockitoExtension`。然后，我们用`@InjectMocks`（类`LoginController`）声明SUT，用`@Mock`（类`LoginService`）声明它的DOC。我们实现了两个测试（`@Test`）。第一个测试（`testLoginOk`）指定了当调用模拟`loginService`的login方法时，这个方法应该返回true。之后，SUT被实际执行，并且它的响应被验证（在这种情况下，返回的字符串必须是`OK`）。此外，Mockito
    API再次被用来评估与模拟`LoginService`的交互是否没有更多。第二个测试（`testLoginKo`）是等价的，但是将login方法的存根设为返回false，因此SUT（`LoginController`）的响应在这种情况下必须是`KO`：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we execute this test, simply inspecting the traces on the standard output
    we can check that the SUT have been actually executed. In addition, we assure
    that the verification stage has been succeeded in both tests since both of them
    have passed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.gif)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginControllerLoginTest* with JUnit 5 and Mockito
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move now to other example in which the negative scenarios (that is, error
    situations) are tested for the component `LoginController`. The following class
    contains two tests, first one (`testLoginError`) is devoted to assess the response
    of the system (it should be `ERROR`) when a null form is used. In the second test
    (`testLoginException`), we program the method login of the mock `loginService`
    to raise an exception when any form is used first. Then, we exercise the SUT (`LoginController`)
    and assess that the response is actually an `ERROR`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the argument matcher any (provided out of the box by
    Mockito) when setting the expectations for the mock method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, when running the tests in the shell, we can confirm that both of tests
    are correctly executed and the SUT is exercised:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.gif)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginControllerErrorTest* with JUnit 5 and Mockito
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example using the BDD style. To that aim, the class `BDDMockito`
    is used. Notice that the static method given of this class is imported in the
    example. Then, four tests are implemented. In fact, these four tests are exactly
    the same implemented in the previous examples (`LoginControllerLoginTest` and
    `LoginControllerErrorTest`), but this time using the BDD style and a more compact
    style (one-liner commands).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The execution of this test class supposes that four tests are executed. As
    shown in the following screenshot, all of them pass:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.gif)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginControllerBDDTest* with JUnit 5 and Mockito
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move now to the next component of our system: `LoginService`. In the
    following example, we aim to unit test that component, and thus first we use the
    annotation `@InjectMocks` to inject the SUT in our test. Then, the DOC (`LoginRepository`)
    is mocked using the annotation `@Mock`. The class contains three tests. The first
    (`testLoginOk`) is devoted to verify the answer of the SUT when a correct form
    is received. The second test (`testLoginKo`) verifies the opposite scenario. Finally,
    the third test also verifies an error situation of the system. The implementation
    of this service keeps a registry of the users logged, and will not allowed to
    login the same user twice. For this reason, we implemented a test (`testLoginTwice`),
    which verifies that the exception `LoginException` is raised when the same user
    tries to login twice:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As usual, the execution of the test in shell gives us an idea of how things
    have gone. We can check that the login service has been exercised four times (since
    in the third test, we did twice). But due to the fact that the `LoginException`
    was expected, that test is succeeded (as well the other two):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.gif)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginServiceTest* with JUnit 5 and Mockito
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class provides a simple example for capturing the argument of
    a mock object. We define a class property of type `ArgumentCaptor<UserForm>`,
    which is annotated with `@Captor`. Then, in the body of the test, the SUT (`LoginService`
    in this case) is exercised and the argument of the method login are captured.
    Finally, the value of this argument is assessed:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once again, in the console, we check that the SUT was exercised and the test
    is declared as successful:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginServiceChaptorTest* with JUnit 5 and Mockito
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The last example we see in this chapter related to Mockito has to do with the
    use of an spy. As introduced before, by default, an spy uses the real implementation
    in non-stubbed methods. Therefore, if we do not stub methods in an spy object,
    what we get is the real object in our test. This is what happens in the next example.
    As we can see, we are using the `LoginService` as our SUT, and then we spy the
    object `LoginRepository`. Due to the fact that in the body of the tests we are
    not programming expectations in the spy object, we are assessing the real system
    in the test.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, the test data is prepared to get a login correct (using username
    as `user` and password as `p1`, which is present in the hardcoded values in the
    real implementation of `LoginRepository`), and then some dummy values for an unsuccessful
    login:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the shell, we can check that both tests were correctly executed, and in
    this case, the real components (both `LoginService` and `LoginRepository`) were
    actually exercised:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.gif)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginServiceSpyTest* with JUnit 5 and Mockito
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: These examples demonstrate several of the capabilities of Mockito, but of course
    not all. For further information, visit the official Mockito reference at [http://site.mockito.org/](http://site.mockito.org/).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Spring
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring ([https://spring.io/](https://spring.io/)) is an open source Java framework
    for building enterprise applications. It was first written by Rod Johnson together
    with his book *Expert One-on-One J2EE Design and Development* in October 2002\.
    The original motivation of Spring was getting rid of the complexity of J2EE, providing
    a light-weight infrastructure aimed to ease the development of enterprise application
    using simple POJOs as building blocks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Spring in a nutshell
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core technology of the Spring Framework is known as **Inversion of Control**
    (**IoC**), which is the process of instantiating objects outside the class in
    which these objects are actually used. These objects are known as beans or components
    in the Spring jargon and are created as *singleton* objects by default. The entity
    in charge of the creation of beans is known as the Spring IoC container. This
    is achieved by **Dependency Injection** (**DI**), which is the process of providing
    dependencies of one object instead of constructing them itself.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: IoC and DI are often used interchangeably. Nevertheless, as depicted in the
    paragraph earlier, these concepts are not exactly the same (IoC is achieved through
    DI).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in the next part of this section, Spring is a modular framework.
    The core functionally of Spring (that is, IoC) is provided in the `spring-context`
    module. This module provides the ability of creating **application context**,
    that is, the Spring’s DI container. There are many different ways to define application
    contexts in Spring. Two of the most significant types are the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`AnnotationConfigApplicationContext`: Application context, which accepts annotated
    classes to identify the Spring beans to be executed in the container. In this
    type of context, beans are identified by annotating plain classes with the annotation
    `@Component`. It is not the only one to declare a class as a Spring bean. There
    are further stereotypes annotations: `@Controller` (stereotype for presentation
    layer, used in the web module, MVC), `@Repository` (stereotype for the persistence
    layer, used in the data access module, called Spring Data), and `@Service` (used
    in the service layer). These three annotations are used to separate the layers
    of an application. Finally, classes annotated with `@Configuration` allows to
    define Spring beans by annotating methods with `@Bean` (the object returned by
    these methods will be Spring beans living in the container):'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: Spring stereotypes used to define beans
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`ClassPathXmlApplicationContext`: Application context, which accepts bean definitions
    declared in an XML file located in the project classpath.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The annotation-based context configuration was introduced in Spring 2.5\. The
    Spring IoC container is totally decoupled from the format in which configuration
    metadata (that is, bean definition) is actually written. Nowadays many developers
    chose annotation-based configuration rather than XML based. For this reason, in
    this book, we are going to use only annotation-based context configuration in
    the examples.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a simple example. First of all, we need to include the `spring-context`
    dependency in our project. For example, as a Maven dependency:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we create an executable Java class (that is, with a main method). Notice
    that in this class there is one annotation at class level: `@ComponentScan`. This
    is a very important annotation in Spring, since it allows to declare the package
    in which Spring will look for beans definition in the form of annotations. If
    specific packages are not defined (just like in the example), scanning will occur
    from the package of the class that declares this annotation (in the example the
    package `io.github.bonigarcia`). In the body of the main method, we create the
    Spring application context with `AnnotationConfigApplicationContext`. From that
    context, we get the Spring component whose class is `MessageComponent`, and we
    write the result of its `getMessage()` method on the standard output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The bean `MessageComponent` is defined in the following class. Notice that
    it is declared as the Spring component simply using the annotation `@Component`
    at class level. Then, in this example, we are injecting another Spring component
    called `MessageService` using the class constructor:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At this point, it is worth reviewing the different manners to carry out dependency
    injection of Spring components:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Field injection: The injected component is a class field annotated with `@Autowired`,
    just like the example before. As a benefit, this kind of injection removes clutter
    code such as setter methods or constructor parameters.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Setter injection: The injected component is declared as a field in the class,
    and then a setter for this field is created and annotated with `@Autowired`.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Constructor injection: The dependency is injected in the class constructor,
    which is annotated with `@Autowired` (3-a in the diagram here). This is the way
    shown in the example earlier. As of Spring 4.3, it is not required anymore to
    annotate the constructor with `@Autowired` to carry out the injection (3-b).'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The latest way of injection (*3-b*) was several benefits, such as the promotion
    of testability without the need of reflection mechanism (implemented, for example,
    by mocking library). In addition, it can make developers to think over the design
    of the class, since many injected dependencies suppose many constructor parameters,
    and this should be avoided (*God object* anti-pattern).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Different ways of dependency injection (Autowired) in Spring
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The last component in our example is named `MessageService`. Note that is also
    a Spring component, this time annotated with `@Service` to remark its service
    nature (from a functional perspective, it would be the same than annotating the
    class with `@Component`):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, if we execute the main class of this example (called `MySpringApplication`,
    see the source code here), we create an annotation-based application context with
    a try with resources (this way the application context will be closed at the end).
    The Spring IoC container will create two beans: `MessageService` and `MessageComponet`.
    Using the application context, we seek the bean `MessageComponet` and invoke its
    method `getMessage`, which is finally written in the standard output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Spring modules
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring framework is modular, allowing developers to use only the needed
    modules provided by the framework. The complete list of this modules can be found
    on [https://spring.io/projects](https://spring.io/projects). The following table
    summarizes some of the most important ones:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '| **Spring project** | **Logo** | **Description** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **Spring项目** | **标志** | **描述** |'
- en: '| Spring Framework | ![](img/00107.jpeg) | Provides core support for DI, transaction
    management, web applications (Spring MCV), data access, messaging, and so on.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Spring框架 | ![](img/00107.jpeg) | 提供了对DI，事务管理，Web应用程序（Spring MCV），数据访问，消息传递等的核心支持。
    |'
- en: '| Spring IO Platform | ![](img/00108.jpeg) | Brings together the core Spring
    APIs into a cohesive and versioned foundational platform for modern applications.
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| Spring IO平台 | ![](img/00108.jpeg) | 将核心Spring API整合成一个具有连贯性和版本化的基础平台，用于现代应用程序。
    |'
- en: '| Spring Boot | ![](img/00109.jpeg) | Simplifies the creation of standalone,
    production-grade Spring-based applications with the minimal configuration. It
    follows the convention-over-configuration approach. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Spring Boot | ![](img/00109.jpeg) | 简化了独立的，生产级的基于Spring的应用程序的创建，最小化配置。它遵循约定优于配置的方法。'
- en: '| Spring Data | ![](img/00110.jpeg) | Simplifies data access by means of comprehensive
    APIs to work with the relational databases, NoSQL, map-reduce algorithms, and
    so on. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| Spring数据 | ![](img/00110.jpeg) | 通过全面的API简化数据访问，以处理关系数据库，NoSQL，映射-减少算法等。'
- en: '| Spring Cloud | ![](img/00111.jpeg) | Provides a set of libraries and common
    patterns for building and deploying distributed systems and microservices. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Spring Cloud | ![](img/00111.jpeg) | 提供了一组库和常见模式，用于构建和部署分布式系统和微服务。 |'
- en: '| Spring Security | ![](img/00112.jpeg) | Provides customizable authentication
    and authorization capabilities for Spring-based applications. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| Spring安全 | ![](img/00112.jpeg) | 为基于Spring的应用程序提供可定制的身份验证和授权功能。 |'
- en: '| Spring Integration | ![](img/00113.jpeg) | Provides a lightweight, POJO-based
    messaging for Spring-based applications to integrate with external systems. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Spring集成 | ![](img/00113.jpeg) | 为基于Spring的应用程序提供了基于轻量级POJO的消息传递，以与外部系统集成。
    |'
- en: '| Spring Batch | ![](img/00114.jpeg) | Provides a lightweight framework designed
    to enable the development of robust batch applications for operations of enterprise
    systems. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| Spring批处理 | ![](img/00114.jpeg) | 提供了一个轻量级框架，旨在实现企业系统操作的稳健批处理应用程序的开发。 |'
- en: Introduction to Spring Test
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring测试简介
- en: 'Spring a module called `spring-test`, which supports unit and integration testing
    of Spring components. Among other features, this module provides the ability to
    create Spring application context for testing purposes or create mock objects
    that to test our code in isolation. There are different annotations supporting
    this testing capabilities. A list of the most significant one is the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Spring有一个名为`spring-test`的模块，支持对Spring组件进行单元测试和集成测试。除其他功能外，该模块提供了创建用于测试目的的Spring应用程序上下文或创建模拟对象以隔离测试代码的能力。有不同的注解支持这些测试功能。最重要的注解列表如下：
- en: '`@ContextConfiguration`: This annotation is used to determine how to load and
    configure an `ApplicationContext` for integration tests. For example, it allows
    to load the application context from annotated classes (using the element classes)
    or bean definitions declared in XML files (using the element locations).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ContextConfiguration`：此注解用于确定如何为集成测试加载和配置`ApplicationContext`。例如，它允许从注释类（使用元素类）加载应用程序上下文，或者从XML文件中声明的bean定义（使用元素位置）加载应用程序上下文。'
- en: '`@ActiveProfiles`: This annotation is used to instruct the container about
    which definition profiles should be active during the application context loading
    (for example, development and test profiles).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ActiveProfiles`：此注解用于指示容器在应用程序上下文加载期间应激活哪些定义配置文件（例如，开发和测试配置文件）。'
- en: '`@TestPropertySource`: This annotation is used to configure the locations of
    the properties files and the inline properties to be added.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@TestPropertySource`：此注解用于配置属性文件的位置和要添加的内联属性。'
- en: '`@WebAppConfiguration`: This annotation is used to instruct the Spring context
    that `ApplicationContext` loaded is `WebApplicationContext.`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@WebAppConfiguration`：此注解用于指示Spring上下文加载的`ApplicationContext`是`WebApplicationContext`。'
- en: 'In addition, the `spring-test` module offers several capabilities to carry
    out different actions typically required in tests, namely:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`spring-test`模块提供了几种功能，用于执行测试中通常需要的不同操作，即：
- en: The `org.springframework.mock.web` package contains a set of Servlet API mock
    objects, useful for testing web contexts. For instance, the object `MockMvc` allows
    to perform HTTP requests (`POST`, `GET`, `PUT`, `DELETE`, and so on) and verify
    the response (status code, content type, or response body).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring的`org.springframework.mock.web`包含一组Servlet API模拟对象，用于测试web上下文。例如，`MockMvc`对象允许执行HTTP请求（`POST`，`GET`，`PUT`，`DELETE`等），并验证响应（状态码，内容类型或响应主体）。
- en: The `org.springframework.mock.jndi` package contains an implementation of the
    **Java Naming and Directory Interface** (**JNDI**) SPI, which can be used to set
    up a simple JNDI environment for tests. For instance, using the class `SimpleNamingContextBuilder`
    we can make a JNDI data source available in our tests.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.mock.jndi`包含**Java命名和目录接口**（**JNDI**）SPI的实现，可用于为测试设置简单的JNDI环境。例如，使用`SimpleNamingContextBuilder`类，我们可以在测试中提供JNDI数据源。'
- en: The `org.springframework.test.jdbc` package contains the class `JdbcTestUtils`,
    which is a collection of JDBC utility functions aimed to simplify standard database
    access.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.test.jdbc`包含`JdbcTestUtils`类，这是一组旨在简化标准数据库访问的JDBC实用函数。'
- en: The `org.springframework.test.util` package contains the class `ReflectionTestUtils`,
    which is a collection of utility methods to set a non-public field or invoke a
    private/protected setter method when testing the application code.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.springframework.test.util`包含`ReflectionTestUtils`类，这是一组实用方法，用于在测试应用程序代码时设置非公共字段或调用私有/受保护的setter方法。'
- en: Testing Spring Boot applications
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Spring Boot应用程序
- en: 'As introduced before, Spring Boot is a project of the Spring portfolio aimed
    to simplify the development of Spring applications. The main benefits of using
    Spring Boot are summarized as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spring Boot是Spring系列项目的一个项目，旨在简化Spring应用程序的开发。使用Spring Boot的主要好处总结如下：
- en: A Spring Boot application is just a Spring `ApplicationContext` in which the
    principal convention over configuration is used. Thank to this, it is faster to
    get started with the Spring development.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The annotation `@SpringBootApplication` is used to identify the main class in
    a Spring Boot project.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A range of non-functional features are provided out of the box: embedded servlet
    containers (Tomcat, Jetty, and Undertow), security, metrics, health checks, or
    externalized configuration.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A creation of standalone running applications that just run using the command
    `java -jar` (even for web applications).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot **command line interface** (**CLI**) allows to run Groovy scripts
    for quickly prototyping with Spring.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Boot works in the same way as any standard Java library, that is, to
    use it, we simply need to add the appropriate `spring-boot-*.jar` in our project
    classpath (typically using build tools such as Maven or Gradle). Spring Boot provides
    a number of *starters* aimed to ease the process of adding the different libraries
    to the classpath. The following table contains several of those starters:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter` | Core starter, including auto-configuration support
    and logging |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-batch` | Starter for using Spring Batch |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-cloud-connectors` | Starter for using Spring Cloud Connectors,
    which simplifies connecting to services in Cloud platforms like Cloud Foundry
    and Heroku |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-jpa` | Starter for using Spring Data JPA with Hibernate
    |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-integration` | Starter for using Spring Integration
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jdbc` | Starter for using JDBC with the Tomcat JDBC
    connection pool |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-test` | Starter for testing Spring Boot applications
    with libraries, including JUnit, Hamcrest, and Mockito |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-thymeleaf` | Starter for building MVC web applications
    using Thymeleaf views |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web` | Starter for building web, including REST, applications
    using Spring MVC. Uses Tomcat as the default embedded container |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-websocket` | Starter for building WebSocket applications
    using Spring Framework’s WebSocket support |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: 'For complete information about Spring Boot visit the official reference: [https://projects.spring.io/spring-boot/.](https://projects.spring.io/spring-boot/)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides different capabilities to simplify the tests. For instance,
    it provides the `@SpringBootTest` annotation, which is used at classlevel in test
    classes. This annotation will create `ApplicationContext` for these tests (similarly
    to `@ContextConfiguration` but for Spring Boot based applications). As we have
    seen in the section before, in the `spring-test` module, we use the annotation
    `@ContextConfiguration(classes=… )` to specify, which bean definition (Spring
    `@Configuration`) to be loaded. When testing Spring Boot applications this is
    often not required. Spring Boot’s tests annotations will search the primary configuration
    automatically if not explicitly define one. The search algorithm works up from
    the package that contains the test until it finds a `@SpringBootApplication` annotated
    class.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot also facilitates the use of mocks for Spring components. To that,
    the annotation `@MockBean` is provided. This annotation allows defining a Mockito
    mock for a bean inside our `ApplicationContext`. It can be new beans, but also
    to it can replace a single existing bean definition. Mock beans are automatically
    reset after each test method. This method is usually known as in-container testing,
    in counterpart to out-of-container, in which a mock library (example, Mockito)
    is used to unit test the Spring components in isolation and without the need of
    a Spring `ApplicationContext`. For example of both types of unit tests for Spring
    applications is shown in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Spring
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to integrate the `spring-test` capabilities into JUnit 5's Jupiter
    programming model, `SpringExtension` has been developed. This extension is part
    of the `spring-test` module, as of Spring 5\. Let's see several examples of JUnit
    5 and Spring 5 together.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we want to make an integration in-container test of the Spring
    application described in the former section, made up of three classes: `MySpringApplication`,
    `MessageComponent`, and `MessageService`. As we have learned, in order to implement
    a Jupiter test against this application, we need to make the following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Annotate our test class with `@ContextConfiguration` to specify which `ApplicationContext`
    needs to be loaded.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate our test class with `@ExtendWith(SpringExtension.class)` to enable
    `spring-test` into Jupiter.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the Spring component we want to assess in our test class.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement our test (`@Test`).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a very simple example in which the Spring component called `MessageComponent`
    is assessed. When this test is started, our `ApplicationContext` is initiated
    with and all our Spring components inside. After that, in this example, the bean
    `MessageComponent` is injected in the test, which is assessed simply calling the
    method `getMessage()` and verifying its response.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth to review which dependencies are needed for this test. When using
    Maven, these dependencies are the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other side, if we use Gradle, the dependencies clause would be as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that in both cases the `spring-context` dependency is needed to implement
    the application, and then we need `spring-test` and `junit-jupiter` to test it.
    In order to implement the equivalent application and test, but this time using
    Spring Boot, first we would need to change our `pom.xml` (when using Maven):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or our `build.gradle` (when using Gradle):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to transform our raw Spring application into Spring Boot, our components
    (in the example called `MessageComponent` and `MessageService`) would be exactly
    the same, but our main class would change a bit (see here). Notice that we use
    the annotation `@SpringBootApplication` at class level, implementing the main
    method with the typically bootstrapping mechanism of Spring Boot. Just for logging
    purposes, we are implementing a method annotated with `@PostConstruct`. This method
    will be triggered just before the application context is started:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The implementation of the test would be straightforward. The only change we
    need to do is to annotate the test with `@SpringBootTest` instead of `@ContextConfiguration`
    (Spring Boot automatically looks for and starts our `ApplicationContext`):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Executing the test in the console, we can see that actually the application
    is started before the test (notice the unmistakable spring ASCII banner at the
    beginning).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, our test uses the `ApplicationContext` to verify one Spring component,
    and as a result the test is succeeded:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.gif)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Execution of test using Spring Boot
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: To finish with this part, we see a simple web application implemented with Spring
    Boot. With respect to the dependencies, the only change we need to do is to include
    the started `spring-boot-starter-web` (instead of the generic `spring-boot-starter`).
    That’s it, we can start implementing our Spring-based web application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement a very simple `@Controller`, that is, the Spring
    bean, which handles the request from the browsers. In our example, the only URL
    mapped by the controller is the default resource `/`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This component injects a service called `PageService`, responsible of returning
    the actual page to be loaded in response to the request to `/`. The content of
    this service is also very simple:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By convention (we are using Spring Boot here), the static resource for Spring-based
    web applications are located in a folder called `static` within the project classpath.
    Following the structure of Maven/Gradle project, this folder is located in the
    `src/main/resources` path (see screenshot below). Note that there are two pages
    there (we switch from one to the other in the tests, stay tuned):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Content of the example project *junit5-spring-boot-web*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on not the interesting part: the tests. We are implementing three
    Jupiter tests in this project. The first one is devoted to verify a direct call
    to the page `/index.html`. As depicted before, this test needs to use the Spring
    extension (`@ExtendWith(SpringExtension.class)`) and be declared as Spring Boot
    test (`@SpringBootTest`). To carry out the request to web application, we use
    an instance of the `MockMvc`, verifying the response in several ways (HTTP response
    code, content-type, and response content body). This instance is automatically
    configured using the Spring Boot annotation `@AutoConfigureMockMvc`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Out of Spring Boot, instead of using `@AutoConfigureMockMvc`, the object `MockMvc`
    can be created using a builder class called `MockMvcBuilders`. In this case, the
    application context is used as parameter for that builder.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Again, running this test in the shell, we check that the application is actually
    executed. By default, the embedded Tomcat listens the port `8080`. After that,
    test is executed successfully:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.gif)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Console output of in-container first test
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Second test is similar, but as a differential factor it uses the test capability
    `@MockBean` to override a spring component (in this example, `PageService`) by
    a mock. In the body of the test, first we stub the method `getPage` of the mock
    to change the default response of the component to `redirect:/page.html`. As a
    result, when requesting the resource `/` in the test with the object `MockMvc`,
    we will obtain an HTTP 302 response (redirect) to the resource `/page.html` (which
    is actually an existing page, as shown in the project screenshot):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, in the shell we can confirm that the test starts the Spring application
    and then it is executed correctly:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.gif)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: Console output of in-container second test
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The last test in this project is an example of an *out-of-container* test.
    In the previous test examples, the Spring context was used within the test. On
    the other side, the following relies completely in Mockito to exercise the components
    of the system, this time without starting the Spring application context. Note
    that we are using the `MockitoExtension` extension here, using the component `WebController`
    as our SUT (`@InjectMocks`) and the component `PageService` as DOC (`@Mock`):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This time, in the execution of the test, we do not see spring traces since
    the application container was not started before executing the test:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.gif)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Console output of out-of-container test
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)) is an open
    source web testing framework, since its inception in 2008 has established itself
    as the *de facto* web automation library. In the next section, we are going to
    review the main features of Selenium and how to use it from JUnit 5 tests.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Selenium in a nutshell
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium is composed by different projects. First, we found the Selenium IDE.
    It is a Firefox plugin implementing the R**ecord and Playback** (**R&P**) pattern
    for web applications. Thus, it allows to record manual interactions with Firefox
    and the playback that recording in an automated fashion.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: The second project was named **Selenium Remote Control** (**RC**). This component
    was capable of driving different types of browser automatically using different
    programming languages, such as Java, C#, Python, Ruby, PHP, Perl, or JavaScript.
    This component injected a JavaScript library (called Selenium Core) in the SUT.
    This library was controlled with an intermediate component called Selenium RC
    Server which receives requests from the test code (see the following figure).
    Selenium RC had important security problems due to same-origin policy.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, it was deprecated on 2016 in favor of Selenium WebDriver:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: Selenium RC schema
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: We review Selenium RC just to introduce Selenium WebDriver. Nowadays, Selenium
    RC is deprecated and its use is highly discouraged.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: From a functional point of view, Selenium WebDriver is equivalent to RC (that
    is, allows to control browsers using code). As a differential aspect, Selenium
    WebDriver makes calls to the browser using each browser’s native support for automation.
    The language bindings provided by Selenium WebDriver (labeled as Test in next
    figure) communicates with and a browser-specific binary, which acts as a bridge
    between real browser. For instance, this binary is called *chromedriver* ([https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/))
    for Chrome and *geckodriver* ([https://github.com/mozilla/geckodriver](https://github.com/mozilla/geckodriver))
    for Firefox. The communication between the Test and the driver is done with JSON
    messages over HTTP using the so-called JSON Wire Protocol.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'This mechanism, originally proposed by the WebDriver team is standardized in
    the W3C WebDriver API ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)Selenium WebDriver schema'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The last project of the Selenium portfolio is called Selenium Grid. It can
    be seen as extension of Selenium WebDriver, since it allows distributing browser
    execution on remote machines. There are a number of Nodes, each running on different
    operating systems and with different browsers. The Hub server keeps a track of
    the nodes and proxies requests to them (see figure below):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)Selenium Grid schema'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the main features of the WebDriver API:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '| **WebDriver feature and description** | **Example** |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| WebDriver object creation:It allows to create WebDriver instances, which
    are used from the test code to control a browser remotely. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '| Navigation:It allows to navigate to a given URL. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '| Locate elements:It allows to identify elements with a web page (WebElement)
    using different strategies: by id, name, class name, CSS selector, link text,
    tag name, or XPath |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '| Interact with elements:From a given WebElement, we can carry out different
    types of automated interaction, such as click elements, type text or clear input
    fields, read attributes, and so on. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '| Handle waits:WebDriver can handle wait both explicit and implicitly. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: XPath (XML Path Language) is a language to build expressions to parse and process
    XML-like documents (for example, HTML)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Selenium
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to simplify the use of Selenium WebDriver in JUnit 5, the open source
    JUnit 5 extension called `selenium-jupiter` can be used. This extension has been
    built using the dependency injection capability provided by the extension model
    of JUnit 5\. Thanks to this feature, different types objects can be injected in
    JUnit 5 in `@Test` methods as parameters. Concretely, `selenium-jupiter` allows
    to inject subtypes of the `WebDriver` interface (for example, `ChromeDriver`,
    `FirefoxDriver`, and so on).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `selenium-jupiter` is very easy. First, we need to import the dependency
    in our project (typically as test dependency). In Maven, it is done as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`selenium-jupiter` depends on several libraries, which are added in our project
    as transitive `dependencies`, namely:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '`Selenium-java` (`org.seleniumhq.selenium:selenium-java`): Java library for
    Selenium WebDriver.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebDriverManager` (`io.github.bonigarcia:webdrivermanager`): Java library
    for automatic Selenium WebDriver binaries management in runtime for Java ([https://github.com/bonigarcia/webdrivermanager](https://github.com/bonigarcia/webdrivermanager)).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appium (`io.appium:java-client`): Java client for Appium, testing framework
    that extends Selenium to automate testing of native, hybrid, and mobile web apps
    ([http://appium.io/](http://appium.io/)).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once `selenium-jupiter` is included in our project, we need to declare `selenium-jupiter`
    extension in our JUnit 5 test, simply annotating it with `@ExtendWith(SeleniumExtension.class)`.
    Then, we need to include one or more parameters in our `@Test` methods whose types
    implement the WebDriver interface, and `selenium-jupiter` control the lifecycle
    of the WebDriver object internally. He WebDriver subtypes supported by `selenium-jupiter`
    are the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '`ChromeDriver`: This is used to control Google Chrome browser.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirefoxDriver`: This is used to control Firefox browser.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EdgeDriver`: This is used to control Microsoft Edge browser.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OperaDriver`: This is used to control Opera browser.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafariDriver`: This is used to control Apple Safari browser (only possible
    in OSX El Capitan or greater).'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HtmlUnitDriver`: This is used to control HtmlUnit (headless browser, that
    is, a browser without GUI).'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhantomJSDriver`: This is used to control PhantomJS (another headless browser).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InternetExplorerDriver`: This is used to control Microsoft Internet Explorer.
    Although this browser is supported, Internet Explorer is deprecated (in favor
    of Edge) and its use is highly discouraged.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoteWebDriver`: This is used to control remote browsers (Selenium Grid).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppiumDriver`: This is used to control mobile devices (Android and iOS).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following class, which uses `selenium-jupiter` , that is, declaring
    the Selenium extension using `@ExtendWith(SeleniumExtension.**class**)`. This
    example defines three tests, which are going be executed using local browsers.
    First one (named `testWithChrome`) uses Chrome as browsers. To that aim, and thanks
    to the dependency injection feature of `selenium-jupiter`*,* the method simply
    needs to declare a method argument using the type `ChromeDriver`. Then, in the
    body of the test, the `WebDriver` API is invoked in that object. Note that this
    test simple opens a web page and asserts that the title is as expected. Next,
    test (`testWithFirefoxAndOpera`) is similar, but this time using two different
    browsers at the same time: Firefox (using an instance of `FirefoxDriver`) and
    Opera (using an instance of `OperaDriver`). The third and last test (`testWithHeadlessBrowsers`)
    declares and uses two headless browsers (`HtmlUnit` and `PhantomJS`):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In order to execute properly this test class, the required browsers (Chrome,
    Firefox, and Opera) should be installed beforehand running it. On the other hand,
    the headless browsers (HtmlUnit and PhantomJS) are consumed as Java dependencies,
    and so there is no need to install them manually.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see another example, this time using remote browsers (that is, Selenium
    Grid). Again, this class uses the `selenium-jupiter` extension. The test (`testWithRemoteChrome`)
    declares a single parameter called `remoteChrome`, of type `RemoteWedbrider`.
    This argument is annotated with `@DriverUrl` and `@DriverCapabilities`, specifying
    the Selenium Server (or Hub) URL and the required capabilities respectively. Regarding
    the capabilities, we are configuring to use a Chrome browser version 59:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: To run this test properly, a Selenium Server should up and running in the localhost,
    and a node (Chrome 59) needs to be registered in the Hub.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the last example of this section, we use `AppiumDriver`. Concretely, we
    set up as capabilities the use of a Chrome browser in an Android emulated device
    (`@DriverCapabilities`). Again, this emulator needs to be up and running in the
    machine running the test beforehand:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For further examples of `selenium-jupiter`, visit [https://bonigarcia.github.io/selenium-jupiter/](https://bonigarcia.github.io/selenium-jupiter/).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber ([https://cucumber.io/](https://cucumber.io/)) is testing framework
    aimed to automate acceptance tests written following a **Behavior-Driven Development**
    (**BDD**) style. Cucumber has been written in Ruby, although implementations for
    other languages (including Java, JavaScript, and Python) are available.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber in a nutshell
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber executes tests specified written in language called Gherkin. It is
    a plaint-text natural language (for example, English or one of other 60+ languages
    supported by Cucumber) with a given structure. Gherkin has been designed to be
    used by non-programmers, typically customers, business analysis, managers, and
    so on.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The extension for Gherkin files is `*.feature*`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Gherkin file, non-blank lines can start with a keyword, followed by text
    in natural language. The main keywords are the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature**: High-level description of the software feature to be tested. It
    can be seen as a use case description.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scenario**: Concrete example that illustrates a business rule. Scenarios
    follow the same pattern:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe initial context.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe an event.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the expected outcome.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These actions are known in the Gherkin jargon as steps, which are mainly **Given**,
    **When**, or **Then**:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two additional steps: **And** (used for logical and for different
    steps) and **But** (used in for negative form of **And**).'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: Preconditions and initial state before the start of a test.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: Actions taken by a user during a test.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then**: Outcome from actions taken in the **When** clause.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background**: To avoid repeat steps in different scenarios, the keyword background
    allows to declared these steps, which are reused in subsequent scenarios.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scenario Outline**: Scenarios in which steps are marked with variables (using
    the symbols `**<**` and `**>**`).'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**: A scenario outline declaration is always followed by one or more
    examples sections, which is a container table with values for the declared variables
    in the **Scenario Outline**.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one line does not start with a keyword, that line is not interpreted by
    Cucumber. It is used to custom description.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we defined our features to be tested we need what it is called *steps
    definition*, which allows to translate plain text Gherkin into actions that actually
    exercise our SUT. In Java, it can be easily done by annotations to annotate methods
    for the step implementation: `@Given`, `@Then`, `@When`, `@And`, and `@But`. The
    string value of each step can contain regular expression which are mapped as fields
    in the method. See an example in the next section.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Cucumber
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest versions of the Cucumber artifacts for Java incorporates a JUnit
    5 extension for Cucumber. This section contains a complete example of a feature
    defined in Gherkin and the JUnit 5 to execute it with Cucumber. As usual, the
    source code of this example is hosted on GitHub ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the project containing this example is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: JUnit 5 with Cucumber project structure and content
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create our Gherkin file, which is aimed to test a
    simple calculator system. This calculator will be the SUT or our test. The content
    of our feature file is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, we need to implement our steps definition. As described earlier, we use
    annotations and regular expression to map the text contained in the Gherkin file
    to the actual exercise of SUT depending on the step:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Of course, we still need to implement our JUnit 5 test. To achieve the integration
    of Cucumber and JUnit 5, the Cucumber extension needs to be registered in our
    class by means of `@ExtendWith(CucumberExtension.**class**)`. Internally, `CucumberExtension`
    implements the `ParameterResolver` callback of the Jupiter extension model. The
    objective is to inject the corresponding tests of the Cucumber feature as Jupiter
    `DynamicTest` objects in the tests. Notice in the example how a `@TestFactory`
    is used.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, we can annotate our test class with `@CucumberOptions`. This annotation
    allows to configure the Cucumber settings for our test. The allowed elements for
    this annotation are:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`plugin`: Built-in formatter: pretty, progress, JSON, usage, among others.
    Default: `{}`.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dryRun`: Checks if all steps have definitions. Default: `false`.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`features`: Paths of the features files. Default: `{}`.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glue`: Paths for step definitions. Default: `{}`.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags`: Tags in the features to be executed. Default `{}`.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monochrome`: Displays console output in a readable way. Default: `false`.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: Reports formatter to be used. Default: `{}`.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strict`: Fails if there are undefined or pending steps. Default: `false`.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At this point, we are able to execute our Cucumber suite with JUnit 5\. In
    the following example we see the output when running the test with Gradle:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.gif)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Execution of JUnit 5 using Cucumber with Gradle
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker ([https://www.docker.com/](https://www.docker.com/)) is an open source
    software technology, which allows to pack and run any application as a lightweight
    and portable container. It provides a command-line program, a background daemon,
    and a set of remote services that simplifies the life cycle of containers.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Docker in a nutshell
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, UNIX-style operating systems used the term jail to describe modified
    isolated runtime environments. The **Linux Containers** (**LXC**) project started
    in 2008 and brought together cgroups, kernel namespaces, or chroot (among others)
    to provide complete isolation execution. The problem with LXC is the difficulty,
    and for that reason, the Docker technology emerged.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Docker hides in underlying complexity of the aforementioned resource isolation
    features of the Linux kernel (cgroups, kernel namespaces, and so on) to allow
    independent containers to run within a single Linux instance. Docker provides
    a high-level API, which allows to pack, ship and run any application as a container.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: In Docker, a container contains an application and its dependencies together.
    Multiple containers can run on the same machine and share the same OS kernel with
    other containers. Each container is running as isolated process in user space.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Unlike **virtual machines** (**VMs**), in Docker containers there is no need
    of using a hypervisor, which is the software that allows to create and runs VM
    (example; VirtualBox, VMware, QEMU or Virtual PC).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of VM and container are depicted in the following diagram:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: Virtual machine versus container
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker platform has two components: the Docker Engine, which is responsible
    for creating and running containers; and the Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)),
    a cloud service for distributing containers. The Docker Hub provides an enormous
    number of public container images for download. The Docker Engine is a client-server
    application composed by three major components:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: A server implemented as a daemon process (the `dockerd` command).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A REST API, which specifies interfaces that programs can use to talk to the
    daemon and instruct it what to do.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **command line interface** (**CLI**) client (the `docker` command).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 extension for Docker
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, containers are changing the way we develop, distribute, and run software.
    This is especially interesting for **Continuous Integration** (**CI**) testing
    environment, in which the convergence with Docker has a direct impact on the improvement
    of efficiency.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding JUnit 5, at the moment of this writing there is an open source JUnit
    5 extension for Docker, named JUnit5-Docker ([https://faustxvi.github.io/junit5-docker/](https://faustxvi.github.io/junit5-docker/)).
    This extension acts as client of the Docker engine and allows to start a Docker
    container (downloaded from the Docker Hub), before running the tests of a class.
    That container is stopped at the end of the tests. In order to use JUnit5-Docker,
    first we need to add the dependency in our project. In Maven:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In Gradle:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The use of JUnit5-Docker is quite straightforward. We simply need to annotate
    our test class with `@Docker`. The elements available in this annotation are the
    following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '`image`: Docker image to be started.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: Port mapping for the Docker container. This is required since at least
    one port must be visible for the container to be useful.'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environments`: Optional environment variables to pass to the docker container.
    Default: `{}`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitFor`: Optional log to wait for before running the tests. Default: `@WaitFor(NOTHING)`.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newForEachCase`: Boolean flag, which determines if the container should be
    recreated for each test case. This value will be false if it should be created
    only once for the test class. Default: `true`.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example. This test class uses the `@Docker` annotation
    to start a MySql container (container image MySQL) and the beginning of each test.
    The internal container port is `3306`, which will be mapped to the host port `8801`.
    Then, several environment attributes are defined (MySql root password, default
    database, and user name and password). The execution of the test will not start
    until the trace *mysqld: ready for connections* appears in the container log (which
    indicates that the MySql instance is up and running). In the body of the test,
    we start a JDBC connection against the MySQL instance running in the container.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: This test has been executed in a Windows machine. For that reason, the host
    of the JDBC URL is 192.168.99.100, which is the IP for the Docker Machine. It
    is a tool which allows to install Docker Engine on virtual hosts, such as Windows
    or Mac ([https://docs.docker.com/machine/](https://docs.docker.com/machine/)).
    In a Linux machine, this IP could be 127.0.0.1 (localhost).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The execution of this test in the Docker Windows terminal is as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.gif)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
- en: Execution of test using JUnit5-Docker extension
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Android
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android ([https://www.android.com/](https://www.android.com/)) is an open source
    mobile operating system based on a modified version of Linux. It was originally
    developed by a startup named Android, acquired and championed by Google in 2005.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the report by Gartner Inc. (American IT research and advisory
    company), in 2017 Android and iOS account more than 99% of global smartphone sales,
    as shown in the following chart:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: Smartphone operative system market. Picture created by www.statista.com.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Android in a nutshell
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android is a Linux-based software stack divided into several layers. Those
    layers, from down to top are the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux kernel**: This is the foundation of the Android platform. This layer
    contains all the low-level device drivers for the various hardware components
    of an Android device.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware Abstraction Layer** (**HAL**): This layer provides standard interfaces
    that expose hardware capabilities to the higher-level Java API framework.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android Runtime** (**ART**): It provides a runtime environment for `.dex`
    files, a bytecode format designed for minimal memory footprint. ART was the first
    release on Android 5.0 (see table below). Prior to that version, Dalvik was the
    Android runtime.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native C/C++ libraries**: This layer contains native libraries written in
    C and C++, such as OpenGL ES for high-performance 2D and 3D graphics processing.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java API framework**: The entire feature-set of Android is available for
    developers through APIs written in Java. These APIs are the building block for
    creating Android apps, for instance: the View System (for apps UIs), the Resource
    Manager (for I18N, graphics, layouts), the Notification Manager (for custom alerts
    in the status bar), the Activity Manager (to manage the apps lifecycle), or the
    Content Provider (to enable apps access data from other apps, such as the Contacts,
    and so on).'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apps**: Android comes with a set of core apps, such as Phone, Contacts, Browser,
    and so on. In addition, many others apps can be downloaded and installed from
    Google Play (formerly Android Market):'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00128.jpeg)Android layered architecture'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has gone through quite a number of updates since its first release,
    as described in the following table:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '| **Android version** | **Codename** | **API level** | **Linux kernel version**
    | **Release date** |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| 1.5 | Cupcake | 3 | 2.6.27 | April 30, 2009 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| 1.6 | Donut | 4 | 2.6.29 | September 15, 2009 |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| 2.0, 2.1 | Eclair | 5, 6, 7 | 2.6.29 | October 26, 2009 |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| 2.2 | Froyo | 8 | 2.6.32 | May 20, 2010 |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| 2.3 | Gingerbread | 9, 10 | 2.6.35 | December 6, 2010 |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| 3.0, 3.1, 3.2 | Honeycomb | 11, 12, 13 | 2.6.36 | February 22, 2011 |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| 4.0 | Ice Cream Sandwich | 14, 15 | 3.0.1 | October 18, 2011 |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| 4.1, 4.2, 4.3 | Jelly Bean | 16, 17, 18 | 3.0.31, 3.0.21, 3.4.0 | July 9,
    2012 |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| 4.4 | KitKat | 19, 20 | 3.10 | October 31, 2013 |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| 5.0, 5.1 | Lollipop | 21, 22 | 3.16.1 | November 12, 2014 |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | Marshmallow | 23 | 3.18.10 | October 5, 2015 |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: '| 7.0, 7.1 | Nougat | 24, 25 | 4.4.1 | August 22, 2016 |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
- en: '| 8.0 | Android O | 26 | TBA | TBA |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
- en: From a developer point of view, Android provides a rich application framework,
    which allows to build apps for mobile devices. Android apps are written in the
    Java programming language. The Android **Software Development Kit** (**SDK**)
    compile out Java code along with any data and resource files into an `.apk` (Android
    package) file, which contains can be installed in Android-powered devices, such
    as smartphones, tablets, smart TVs, or smartwatches.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: For complete information about Android development, visit [https://developer.android.com/](https://developer.android.com/).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Studio is the official IDE for Android development. It is built based
    on IntelliJ IDEA. In Android Studio, the build process of Android projects is
    managed by the Gradle build system. During the Android Studio installation, two
    additional tools can be also installed:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '**Android SDK**: This contains all of the packages and tools required to develop
    Android apps. The SDK Manager allows to download and install SDK for different
    versions (see the preceding table).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android Virtual Device** (**AVD**): This is an emulator that allows us to
    model an actual device. The AVD Manager allows to download and install different
    emulated Android virtual devices grouped into four categories: phones, tables,
    TV, and wears.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle plugin for JUnit 5 in Android projects
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of this writing, there is no official support for JUnit 5 in Android
    projects. To solve this problem, an open source Gradle plugin named `android-junit5`
    has been created ([https://github.com/aurae/android-junit5](https://github.com/aurae/android-junit5)).
    To use this plugin, first we need to specify the proper dependency in our `build.gradle`
    file:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In order to use this plugin in our project, we need to extend our project capabilities
    using the clause `apply plugin` in our `build.gradle` file:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `android-junit5` plugin configures the `junitPlatform` task, attaching
    automatically attaches both the Jupiter and Vintage engines during the test execution
    phase. As an example, consider the following project example, as usual hosted
    on GitHub ([https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android)).
    The following is a screenshot of this project imported in Android Studio:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)Android project compatible with JUnit 5 on IntelliJ'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create an Android JUnit run configuration of Android Studio.
    As can be seen in the screenshot, we use the option `All in package` referred
    to the package containing the tests (`io.github.bonigarcia.myapplication` in this
    example):'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
- en: Android JUnit run configuration
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'If we launch the aforementioned run configuration, all the tests of the project
    will be executed. These tests can use the JUnit 4 programming model (Vintage)
    and even the JUnit 5 (Jupiter) in a seamless way:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: Execution on Jupiter and Vintage tests within an Android project in IntelliJ
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: REST
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roy Fielding is an American computer scientist born in 1965\. He is one of the
    authors of the HTTP protocol and the co-authors of the Apache Web server. In the
    year 2000, Fielding coined the term REST (short for REpresentational State Transfer)
    in his doctoral dissertation entitled *Architectural Styles and the Design of
    Network-based Software Architecture.* REST is an architectural style for designing
    distributed systems. It’s not a standard, but rather a set of constraints. REST
    is commonly used in conjunction with HTTP. On the one hand, the implementations
    which follows the strict principles of REST are often referred as RESTful. On
    the other hand, those which follow a loose adherence of such principles are called
    RESTlike.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: REST in a nutshell
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST follows a client-server architecture. The server is in charge of handling
    a set of services, listening for requests made by clients. The communication between
    client and server must be stateless, meaning that server do not store any record
    from the clients and therefore each request done from the client must contain
    all the information required for the server to process it separately.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of REST architectures are named resources. Resources define
    the type of information that is going to be transferred. Resources should be identified
    in a unique way. In HTTP, the way to access the resource it to provide its full
    URL, also known as API endpoint. Each resource has a representation, which is
    a machine-readable explanation of the current state of a resource. Nowadays, representations
    are usually with JSON, but it can be done in other formats such as XML or YAML.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we identified the resources and the representation format, we need to
    specify what can be done with them, that is, the actions. Actions could potentially
    be anything, although there is a set of common actions that any resource-oriented
    system should provide: CRUD (create, retrieve, update, and delete) actions. REST
    actions can be mapped to the HTTP methods (so-called verbs), as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Reads a resource.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Sends a new resource to the server.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Updates a given resource.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Deletes a resource.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: update partially a resource.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: Asks if a given resource exists without returning any of its representations.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: Retrieves a list of available verbs on a given resource.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In REST, it is important the notion of *idempotency*. For example, `GET`, `DELETE`,
    or `PUT` are said to be idempotent, since the effect of these requests should
    be the same whether the command is sent one or several times. On the other hand,
    `POST` is not idempotent, since it creates a different resource each time it is
    requested.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'REST, when based on HTTP can benefit on standard HTTP status codes. A status
    code is a number that summarizes the response associated to it. The typical HTTP
    status code reused in REST are:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '`200 OK`: The request went fine and the content requested was returned. Normally
    used on GET requests.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201 Created`: The resource was created. Useful on responses to POST or PUT
    requests.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204 No content`: The action was successful, but there is no content returned.
    Useful for actions that do not require a response body, such as a DELETE.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`301 Moved permanently`: This resource was moved to another location and the
    location is returned.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400 Bad request`: The request issued has problems (for example, lacking some
    required parameters).'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401 Unauthorized`: Useful for authentication when the requested resource is
    not accessible to the user owning the request.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403 Forbidden`: The resource is not accessible, but unlike 401, authentication
    will not affect the response.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404 Not found`: The URL provided does not identify any resource.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 405 Method not allowed. The HTTP verb used on a resource is not allowed. (for
    example, a PUT on a read-only resource).
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500 Internal server error`: A generic error code when an unexpected condition
    in the server side.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following picture shows an example of client-server interaction with REST.
    The body of the HTTP messages uses JSON both for requests and responses:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)REST sequence diagram example'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Using REST test libraries with Jupiter
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs are becoming more and more pervasive nowadays. For that reason, a
    proper strategy for assessing REST services is desirable. In this section, we
    are going to learn how to use several test libraries in our JUnit 5 tests.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we can use the open source library REST Assured ([http://rest-assured.io/](http://rest-assured.io/)).
    REST Assured allows the validation of REST services by means of a fluent API inspired
    in dynamic languages such as Ruby or Groovy. To use REST Assured in our test project,
    we simply need to add the proper dependency in Maven:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'or in Gradle:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After that, we can use the REST Assured API. The following class contains two
    test examples. First sends a request to the free online REST service [http://echo.jsontest.com/](http://echo.jsontest.com/).
    Then verifies if the response code and the body content are as expected. The second
    test consumes another free online REST service ([http://services.groupkt.com/](http://services.groupkt.com/))
    and also verifies the response:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running this test in console with Maven, we can check that both tests succeed:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.gif)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: Execution of test using REST Assured
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we are going to study, in addition to the test, we are
    also going to implement the server side, that is, the REST service implementation.
    To that aim, we are going to use Spring MVC and Spring Boot, previously introduced
    on this chapter (see section *Spring*).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of REST services in Spring is quite straightforward. First,
    we simply need to annotate a Java class with `@RestController`. In the body of
    this class, we need to add methods annotated with `@RequestMapping`. These methods
    will listen to the different URLs (endpoints) implemented in our REST API. The
    accepted elements for the `@RequestMapping` are:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: This is the path mapping URL.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This finds the HTTP request methods to map to.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: This finds parameters of the mapped request, narrowing the primary
    mapping.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: his finds the headers of the mapped request.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`consumes`: This finds consumable media types of the mapped request.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`produces`: This finds producible media types of the mapped request.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As can be seen inspecting the code of the following class, our service example
    implements three different operations: `GET /books` (to read all book in the system),
    `GET /book/{index}` (to read a book given its identifier), and `POST /book` (to
    create a book).'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since we are implementing a Jupiter test for Spring, we need to use the `SpringExtension`
    and also the `SpringBootTest` annotation. As a novelty, we are going to inject
    a test component provided by `spring-test`, named `TestRestTemplate`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: This component is a wrapper of the standard Spring's `RestTemplate` object,
    which allows to implement REST clients in a seamless way. In our test, it requests
    to our service (which is started before executing the tests), and responses are
    used to verify the outcome.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the object `MockMvc` (explained in the section *Spring*) could be
    also used to test REST services. The difference with respect to `TestRestTemplate`
    is that the former is used to test from the client-side (that is, response code,
    body, content type, and so on), while the the latter is used to test the service
    from the server side. For instance, in the example here, the responses to the
    service calls (`getForEntity` and `postForEntity`) are Java objects, whose scope
    is only the server side (in the client side, this information is serialized as
    JSON).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As shown in the screenshot below, our Spring application is started before
    running our tests, which are executed successfully:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.gif)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
- en: Output of Jupiter test using TestRestTemplate to verify a REST service.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this section, we see an example in which the library WireMock ([http://wiremock.org/](http://wiremock.org/))
    is used. This library allows to mock REST services, that is, a so-called HTTP
    *mock server*. This mock server captures incoming requests to the service, providing
    stubbed responses. This capability is very useful to test a system which consumes
    a REST service, but the service is not available during the tests (or we can test
    the component that calls the service in isolation).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we see an example to demonstrate its usage. Let''s suppose we have
    a system which consumes a remote REST service. To implement a client for that
    service we use Retrofit 2 ([http://square.github.io/retrofit/](http://square.github.io/retrofit/)),
    which is a highly configurable HTTP client for Java. We define the interface to
    consume this service as illustrated in the class below. Notice that the service
    exposes three endpoints aimed to read a remote file (open file, read stream, and
    close stream):'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then we implement the class which consumes the REST service. In this example,
    it is a simple Java class which connects to the remote service given its URL passed
    as constructor parameter:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Finally, we implement a JUnit 5 test to verify our service. Notce that we are
    creating the mock server (`**new** WireMockServer`) and stubbing the REST service
    calls using the static methods `stubFor(...)` provided by WireMock in the setup
    of the test (`@BeforeEach`). Since in this case, the SUT is very simple and it
    has no DOCs, we directly instantiate the class `RemoteFileService` also in the
    setup of each test, using the mock server URL as constructor argument. Finally,
    we test our service (which uses the mock server) simply exercising the object
    called `wireMockServer`, in this example, by calling to the method `getFile` and
    assessing its output.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Executing the test in the console, in the traces we can see how the internal
    HTTP server controlled by WireMock is started before the test execution. Then,
    the three REST operations (open stream, read bytes, close stream) are executed
    by the test, and finally the mock server is disposed:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.gif)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
- en: Execution of test using a mock REST server using WireMock
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section provides a detailed insight of how JUnit 5 can be used in conjunction
    with third-party frameworks, libraries, and platforms. Thanks to the Jupiter extension
    model, developers can create extensions which allows seamless integration with
    external frameworks to JUnit 5\. First, we have seen the *MockitoExtension*, an
    extension provided by the JUnit 5 team to use Mockito (a notorious mock framework
    for Java) in Jupiter tests. Then, we have used the *SpringExtension*, which is
    the official extension provided in the version 5 of the Spring Framework. This
    extension integrates Spring into the JUnit 5 programming model. This way, we are
    able to use Spring’s application contexts (that is, the Spring’s DI container)
    in our tests.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: We have also reviewed the *SeleniumExtension* implemented by *selenium-jupiter,*
    an open source project providing a JUnit 5 extension for Selenium WebDriver (testing
    framework for web applications). Thank to thins extension, we can use different
    browsers to interact automatically with web applications and emulated mobile devices
    (using Appium). Then, we have seen the *CucumberExtension,* allows to specify
    JUnit 5 acceptance tests following a BDD style using the Gherkin language. Finally,
    we have seen how the open source JUnit5-Docker extension can be used to start
    Docker containers (downloading the image from Docker Hub) before the execution
    of our JUnit 5 tests.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, we discovered that the extension model is not the only way of interacting
    with external technologies by JUnit tests. For example, in order to run Jupiter
    tests in an Android project, we can use the `android-junit5` plugin. On the other
    hand, even though there is no custom extension for assessing REST services using
    JUnit 5, the integration with such libraries is strait forward: we simply need
    to include the proper dependency in our project and use it in our tests (for example,
    REST Assured, Spring, or WireMock).'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
