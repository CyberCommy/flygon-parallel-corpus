- en: Integration Of JUnit 5 With External Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If I have seen further than others, it is by standing upon the shoulders of
    giants.
  prefs: []
  type: TYPE_NORMAL
- en: '- Isaac Newton'
  prefs: []
  type: TYPE_NORMAL
- en: 'As described in [Chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What''s New in JUnit*, the extension model of JUnit 5 allows us to extend the
    core functionality of JUnit 5 by a third party (tool vendor, developers, and so
    on). In the Jupiter extension model, an extension point is a callback interface
    that the extension implements and then registers (activates) in the JUnit 5 framework.
    As we will discover in this chapter, the JUnit 5 extension model can be used to
    provide seamless integration with existing third-party frameworks. Concretely,
    in this chapter, we review JUnit 5 extension for the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mockito**: Mock (test double) unit testing framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring**: A Java framework for building enterprise applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selenium**: A testing framework to automate the navigation and assessment
    of web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cucumber**: Testing framework which allows us to create acceptance tests
    written following a **Behavior-Driven Development** (**BDD**) style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: A software technology which allows us to pack and run any application
    as a lightweight and portable container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Moreover, we discover that the JUnit 5 extension model is not the only way
    to integrate with the external world. Concretely, we study how JUnit 5 can be
    used together with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android** (mobile operating system based on Linux): We can run Jupiter tests
    in an Android project using a Gradle plugin for JUnit 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REST** (architectural style for designing distributed systems): We can interact
    and verify REST services simply using third-party libraries (such as REST Assured
    or WireMock), or using the fully integrated approach of Spring (tests together
    with the service implementation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mockito ([http://site.mockito.org/](http://site.mockito.org/)) is an open source
    mock unit testing framework for Java, first released in April 2008\. Of course,
    Mockito is not the only mock framework for Java; there are others, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: EasyMock ([http://easymock.org/](http://easymock.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMock ([http://www.jmock.org/](http://www.jmock.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerMock ([http://powermock.github.io/](http://powermock.github.io/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMockit ([http://jmockit.org/](http://jmockit.org/)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can say that, at the time of writing, Mockito is the preferred mock framework
    in Java tests for the most developers and testers. To justify that claim, we use
    the following screenshot, which shows the evolution of the terms Mockito, EasyMock,
    JMock, PowerMock, and JMockit in Google Trends ([https://trends.google.com/](https://trends.google.com/))
    from 2004 to 2017\. At the beginning of this period, we can see there was a significant
    interest on EasyMock and JMock; nevertheless, Mockito was more in demand compared
    with the rest of the frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Google Trends evolution of Mockito, EasyMock, JMock, PowerMock, and JMockit
  prefs: []
  type: TYPE_NORMAL
- en: Mockito in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As introduced in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective on Software Quality and Java Testing*, there are different levels
    of software testing, such as unit, integration, system, or acceptance. Regarding
    unit tests, they should be executed in isolation for a single piece of software,
    for example, an individual class. The objective in this level of tests is to verify
    the functionality of the unit and not of its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we want to test what is known as the **System Under Test** (**SUT**)
    but not its **Depended-On Components** (**DOCs**). To achieve this isolation,
    we use typically *test doubles* to replace these DOCs. Mock objects are a kind
    of test double, which are programmed with expectations about the real DOC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In few words, Mockito is a testing framework that allows mock object creation,
    stubbing, and verification. To that aim, Mockito provides an API to isolate the
    SUT and its DOCs. Generally speaking, using Mockito involves three different steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mocking objects**: In order to isolate our SUT, we use the Mockito API to
    create mocks of its associated DOC(s). This way, we guarantee that the SUT is
    not depending on its real DOC(s), and our unit test is actually focused on the
    SUT.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Setting expectations**: The differential aspect of mocks object with respect
    to other test doubles (such as stub) is that mock objects can be programmed with
    custom expectations according to the needs of the unit test. This process in the
    Mockito jargon is known as stubbing methods, in which these methods belong to
    the mocks. By default, mock objects mimic the behavior of real objects. In practical
    terms, it means that mock objects return appropriate dummy values such as false
    for Boolean types, null for objects, 0 for integer or long return types, and so
    on. Mockito allows us to change this behavior with a rich API, which allows stubbing
    to return a specific value when a method is called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a mock object is not programmed with any expectation (that is, it has no
    *stubbing method*), technically speaking, it is not a *mock* object but a *dummy*
    object (take a look at [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective on Software Quality and Java Testing* for the definition).
  prefs: []
  type: TYPE_NORMAL
- en: '**Verification**: At the end of the day, we are creating tests, and thus, we
    need to implement some kind of verification for the SUT. Mockito provides a powerful
    API to carry out different types of verifications. With this API, we assess the
    interactions with the SUT and DOCs, verifying the invocation order with a mock,
    or capturing and verifying the argument passed to a stubbed method. Furthermore,
    the verification capabilities of Mockito can be complemented with the built-in
    assertion capabilities of JUnit or using a third-party assertion library (for
    example, Hamcrest, AssertJ, or Truth). See section *Assertions* within [Chapter
    3](part0077.html#29DRA0-ef8404ed083f459d860f84cc8198f8bb), *JUnit 5 Standard Tests*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following table summarizes the Mockito APIs grouped by the aforementioned
    phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mockito API** | **Description** | **Phase** |'
  prefs: []
  type: TYPE_TB
- en: '| `@Mock` | This annotation identifies a mock object to be created by Mockito.
    This is used typically for DOC(s). | 1.Mocking objects |'
  prefs: []
  type: TYPE_TB
- en: '| `@InjectMocks` | This annotation identifies the object in which the mocks
    are going to be injected. This is used typically to the unit we want to test,
    that is, our SUT. | 1.Mocking objects |'
  prefs: []
  type: TYPE_TB
- en: '| `@Spy` | In addition to mocks, Mockito allows us to create spy objects (that
    is, a partial mock implementation, since they use the real implementation in non-stubbed
    methods). | 1.Mocking objects |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.when(x).thenReturn(y)``Mockito.doReturn(y).when(x)` | These methods
    allow us to specify the value (`y`) that should be returned by the stubbed method
    (`x`) of a given mock object. | 2.Setting expectations (*stubbing methods*) |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.when(x).thenThrow(e)``Mockito.doThrow(e).when(x)` | These methods
    allow us to specify the exception (`e`) that should be thrown when calling a stubbed
    method (`x`) of a given mock object. | 2.Setting expectations (*stubbing methods*)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.when(x).thenAnswer(a)``Mockito.doAnswer(a).when(x)` | Unlike returning
    a hardcoded value, a dynamic user-defined logic (`Answer a`) is executed when
    a given method (`x`) of the mock is invoked. | 2.Setting expectations (*stubbing
    methods*) |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.when(x).thenCallRealMethod()``Mockito.doCallRealMethod().when(x)`
    | This method allows us the real implementation of a method instead the mocked
    one. | 2.Setting expectations (*stubbing methods*) |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.doNothing().when(x)` | When using a spy, the default behavior is
    calling the real methods of the object. In order to avoid the execution of a `void`
    method `x`, this method is used. | 2.Setting expectations (*stubbing methods*)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BDDMockito.given(x).willReturn(y)``BDDMockito.given(x).willThrow(e)``BDDMockito.given(x).willAnswer(a)``BDDMockito.given(x).willCallRealMethod()`
    | Behaviour-driven development is a test methodology in which tests are specified
    in terms of scenarios and implemented as *given* (initial context), *when* (event
    occurs), and *then* (ensure some outcomes). Mockito supports this type of tests
    through the class `BDDMockito`. The behavior of the stubbed methods (`x`) is equivalent
    to `Mockito.when(x)`. | 2.Setting expectations (*stubbing methods*) |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.verify()` | This method verifies the invocation of mock objects.
    This verification can be optionally enhanced using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`times(n)`: The stubbed method is invoked exactly `n` times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never()`: The stubbed method is never called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atLeastOnce()`: The stubbed method is invoked at least once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atLeast(n)`: The stubbed method is called at least n times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atMost(n)`: The stubbed method is called at the most n times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`only()`: A mock fails if any other method is called on the mock object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout(m)`: This method is called in `m` milliseconds at the most.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| 3.Verification |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.verifyZeroInteractions()``Mockito.verifyNoMoreInteractions()` |
    These two methods verify that a stubbed method has no interactions. Internally,
    they use the same implementation. | 3.Verification |'
  prefs: []
  type: TYPE_TB
- en: '| `@Captor` | This annotation allows us to define an `ArgumentChaptor` object,
    aimed to verify the arguments passed to a stubbed method. | 3.Verification |'
  prefs: []
  type: TYPE_TB
- en: '| `Mockito.inOrder` | It facilitates verifying whether interactions with a
    mock were performed in a given order. | 3.Verification |'
  prefs: []
  type: TYPE_TB
- en: 'The use of the different annotations depicted in preceding the table (`@Mock`,
    `@InjectMocks`, `@Spy`, and `@Captor`) is optional, although it is recommendable
    for the shake of test readability. In other words, there are alternatives to the
    use of annotation using different Mockito classes. For instance, in order to create
    a `Mock`, we can use the annotation `@Mock` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The alternative to this would be using the method `Mockito.mock`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following sections contains comprehensive examples using the Mockito APIs
    described in preceding table within Jupiter tests.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of this writing, there is no official JUnit 5 extension to use
    Mockito in Jupiter tests. Nevertheless, the JUnit 5 team provides a simple ready
    to use Java class implementing a simple but effective extension for Mockito. This
    class can be found in the JUnit 5 user guide ([http://junit.org/junit5/docs/current/user-guide/](http://junit.org/junit5/docs/current/user-guide/)),
    and its code is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This extension (among others) is planned to be released in the open source project
    JUnit Pioneer ([http://junit-pioneer.org/](http://junit-pioneer.org/)). This project
    is maintained by Nicolai Parlog, Java developer and author of the blog CodeFX
    ([https://blog.codefx.org/](https://blog.codefx.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspecting the preceding class, we can check that it is simply a use case of
    the Jupiter extension model (described in [chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What''s New In JUnit 5,* of this book), which implements the extensions callback
    `TestInstancePostProcessor` and `ParameterResolver`. Thanks to the first, after
    the test case is instantiated, the `postProcessTestInstance` method is invoked,
    and in the body of this method, the initialization of mocks is carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the same effect that using the JUnit 4 runner for Mockito: `@RunWith(MockitoJUnitRunner.class)`.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this extension also implements the interface `ParameterResolver`.
    That means that dependency injection at method level will be allowed in tests,
    which register the extension (`@ExtendWith(MockitoExtension.class)`). In particular,
    the annotation will inject mock objects for test parameters annotated with `@Mock`
    (located in package `org.mockito`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples to clarify the use of this extension together with
    Mockito. As usual, we can find the source code of this examples on the GitHub
    repository [https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5).
    A copy of the preceding extension (`MockitoExtension`) is contained in the project
    `junit5-mockito`. To guide these examples, we implement a typical use case in
    software applications: the login of a user in a software system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this use case, we suppose that a user interacts with a system made up by
    three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginController`: The class which receives the request from the user, returning
    a response as a result. This request is dispatched to the `LoginService` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoginService`: This class implements the functionality of the use case. To
    that aim, it needs to confirm whether or not the user is authenticated in the
    system. To that, it needs to read the persistence layer, implemented in the `LoginRepository`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoginRepository`: This class allows to access the persistence layer of the
    system, typically implemented by means of a database. This class can also be called
    **Data Access Object** (**DAO**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of composition, the relationship of these three classes are is following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Login use case class diagram (composition relationship among the classes)
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence diagram of the two basic operations involved in the use case (login
    and logout) is depicted in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Login use case sequence diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'We implement this example with several simple Java classes. First, the `LoginController`
    uses the `LoginService` by composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserForm` object is a simple Java class, sometimes called **Plain-Old
    Java Object** (**POJO**), with two properties username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the service depends on the repository (`LoginRepository`) for data access.
    In this example, the service also implements a user registry using a Java list
    in which the authenticated users are stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `LoginRepository` is as follows. For the sake of simplicity, instead
    of accessing a real database, this component implements a map in which the credentials
    of the hypothetical user of the system are stored (where `key`*=* username, and
    `value`=password):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are going to test our system using JUnit 5 and Mockito. First of all,
    we test the controller component. Since we are doing unit tests, we need to isolate
    the `LoginController` login from the rest of the system. To do that, we need to
    mock its dependencies, in this example, the `LoginService` component. Using the
    SUT/DOC terminology explained at the beginning, in this test, our SUT is the class
    `LoginController` and its DOC is the class `LoginService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement our test with JUnit 5, first we need to register the `MockitoExtension`
    with `@ExtendWith`. Then, we declare the SUT with `@InjectMocks` (class `LoginController`)
    and its DOC with `@Mock` (class `LoginService`). We implement two tests (`@Test`).
    First one (`testLoginOk`) specifies when the method login of mock `loginService`
    is called, this method should return true. After that, the SUT is actually exercised,
    and its response is verified (in this case, the returned String must be `OK`).
    Moreover, the Mockito API is used again to assess that no more interactions with
    the mock `LoginService` is done. The second test (`testLoginKo`) is equivalent,
    but stubbing the method login to return false and therefore the response of the
    SUT `(LoginController)` must be `KO` in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this test, simply inspecting the traces on the standard output
    we can check that the SUT have been actually executed. In addition, we assure
    that the verification stage has been succeeded in both tests since both of them
    have passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginControllerLoginTest* with JUnit 5 and Mockito
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move now to other example in which the negative scenarios (that is, error
    situations) are tested for the component `LoginController`. The following class
    contains two tests, first one (`testLoginError`) is devoted to assess the response
    of the system (it should be `ERROR`) when a null form is used. In the second test
    (`testLoginException`), we program the method login of the mock `loginService`
    to raise an exception when any form is used first. Then, we exercise the SUT (`LoginController`)
    and assess that the response is actually an `ERROR`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the argument matcher any (provided out of the box by
    Mockito) when setting the expectations for the mock method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, when running the tests in the shell, we can confirm that both of tests
    are correctly executed and the SUT is exercised:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginControllerErrorTest* with JUnit 5 and Mockito
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example using the BDD style. To that aim, the class `BDDMockito`
    is used. Notice that the static method given of this class is imported in the
    example. Then, four tests are implemented. In fact, these four tests are exactly
    the same implemented in the previous examples (`LoginControllerLoginTest` and
    `LoginControllerErrorTest`), but this time using the BDD style and a more compact
    style (one-liner commands).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of this test class supposes that four tests are executed. As
    shown in the following screenshot, all of them pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginControllerBDDTest* with JUnit 5 and Mockito
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move now to the next component of our system: `LoginService`. In the
    following example, we aim to unit test that component, and thus first we use the
    annotation `@InjectMocks` to inject the SUT in our test. Then, the DOC (`LoginRepository`)
    is mocked using the annotation `@Mock`. The class contains three tests. The first
    (`testLoginOk`) is devoted to verify the answer of the SUT when a correct form
    is received. The second test (`testLoginKo`) verifies the opposite scenario. Finally,
    the third test also verifies an error situation of the system. The implementation
    of this service keeps a registry of the users logged, and will not allowed to
    login the same user twice. For this reason, we implemented a test (`testLoginTwice`),
    which verifies that the exception `LoginException` is raised when the same user
    tries to login twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the execution of the test in shell gives us an idea of how things
    have gone. We can check that the login service has been exercised four times (since
    in the third test, we did twice). But due to the fact that the `LoginException`
    was expected, that test is succeeded (as well the other two):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginServiceTest* with JUnit 5 and Mockito
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class provides a simple example for capturing the argument of
    a mock object. We define a class property of type `ArgumentCaptor<UserForm>`,
    which is annotated with `@Captor`. Then, in the body of the test, the SUT (`LoginService`
    in this case) is exercised and the argument of the method login are captured.
    Finally, the value of this argument is assessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, in the console, we check that the SUT was exercised and the test
    is declared as successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginServiceChaptorTest* with JUnit 5 and Mockito
  prefs: []
  type: TYPE_NORMAL
- en: The last example we see in this chapter related to Mockito has to do with the
    use of an spy. As introduced before, by default, an spy uses the real implementation
    in non-stubbed methods. Therefore, if we do not stub methods in an spy object,
    what we get is the real object in our test. This is what happens in the next example.
    As we can see, we are using the `LoginService` as our SUT, and then we spy the
    object `LoginRepository`. Due to the fact that in the body of the tests we are
    not programming expectations in the spy object, we are assessing the real system
    in the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, the test data is prepared to get a login correct (using username
    as `user` and password as `p1`, which is present in the hardcoded values in the
    real implementation of `LoginRepository`), and then some dummy values for an unsuccessful
    login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the shell, we can check that both tests were correctly executed, and in
    this case, the real components (both `LoginService` and `LoginRepository`) were
    actually exercised:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of unit test of *LoginServiceSpyTest* with JUnit 5 and Mockito
  prefs: []
  type: TYPE_NORMAL
- en: These examples demonstrate several of the capabilities of Mockito, but of course
    not all. For further information, visit the official Mockito reference at [http://site.mockito.org/](http://site.mockito.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring ([https://spring.io/](https://spring.io/)) is an open source Java framework
    for building enterprise applications. It was first written by Rod Johnson together
    with his book *Expert One-on-One J2EE Design and Development* in October 2002\.
    The original motivation of Spring was getting rid of the complexity of J2EE, providing
    a light-weight infrastructure aimed to ease the development of enterprise application
    using simple POJOs as building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Spring in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core technology of the Spring Framework is known as **Inversion of Control**
    (**IoC**), which is the process of instantiating objects outside the class in
    which these objects are actually used. These objects are known as beans or components
    in the Spring jargon and are created as *singleton* objects by default. The entity
    in charge of the creation of beans is known as the Spring IoC container. This
    is achieved by **Dependency Injection** (**DI**), which is the process of providing
    dependencies of one object instead of constructing them itself.
  prefs: []
  type: TYPE_NORMAL
- en: IoC and DI are often used interchangeably. Nevertheless, as depicted in the
    paragraph earlier, these concepts are not exactly the same (IoC is achieved through
    DI).
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in the next part of this section, Spring is a modular framework.
    The core functionally of Spring (that is, IoC) is provided in the `spring-context`
    module. This module provides the ability of creating **application context**,
    that is, the Spring’s DI container. There are many different ways to define application
    contexts in Spring. Two of the most significant types are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnnotationConfigApplicationContext`: Application context, which accepts annotated
    classes to identify the Spring beans to be executed in the container. In this
    type of context, beans are identified by annotating plain classes with the annotation
    `@Component`. It is not the only one to declare a class as a Spring bean. There
    are further stereotypes annotations: `@Controller` (stereotype for presentation
    layer, used in the web module, MVC), `@Repository` (stereotype for the persistence
    layer, used in the data access module, called Spring Data), and `@Service` (used
    in the service layer). These three annotations are used to separate the layers
    of an application. Finally, classes annotated with `@Configuration` allows to
    define Spring beans by annotating methods with `@Bean` (the object returned by
    these methods will be Spring beans living in the container):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Spring stereotypes used to define beans
  prefs: []
  type: TYPE_NORMAL
- en: '`ClassPathXmlApplicationContext`: Application context, which accepts bean definitions
    declared in an XML file located in the project classpath.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The annotation-based context configuration was introduced in Spring 2.5\. The
    Spring IoC container is totally decoupled from the format in which configuration
    metadata (that is, bean definition) is actually written. Nowadays many developers
    chose annotation-based configuration rather than XML based. For this reason, in
    this book, we are going to use only annotation-based context configuration in
    the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see a simple example. First of all, we need to include the `spring-context`
    dependency in our project. For example, as a Maven dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create an executable Java class (that is, with a main method). Notice
    that in this class there is one annotation at class level: `@ComponentScan`. This
    is a very important annotation in Spring, since it allows to declare the package
    in which Spring will look for beans definition in the form of annotations. If
    specific packages are not defined (just like in the example), scanning will occur
    from the package of the class that declares this annotation (in the example the
    package `io.github.bonigarcia`). In the body of the main method, we create the
    Spring application context with `AnnotationConfigApplicationContext`. From that
    context, we get the Spring component whose class is `MessageComponent`, and we
    write the result of its `getMessage()` method on the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The bean `MessageComponent` is defined in the following class. Notice that
    it is declared as the Spring component simply using the annotation `@Component`
    at class level. Then, in this example, we are injecting another Spring component
    called `MessageService` using the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it is worth reviewing the different manners to carry out dependency
    injection of Spring components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Field injection: The injected component is a class field annotated with `@Autowired`,
    just like the example before. As a benefit, this kind of injection removes clutter
    code such as setter methods or constructor parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Setter injection: The injected component is declared as a field in the class,
    and then a setter for this field is created and annotated with `@Autowired`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Constructor injection: The dependency is injected in the class constructor,
    which is annotated with `@Autowired` (3-a in the diagram here). This is the way
    shown in the example earlier. As of Spring 4.3, it is not required anymore to
    annotate the constructor with `@Autowired` to carry out the injection (3-b).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The latest way of injection (*3-b*) was several benefits, such as the promotion
    of testability without the need of reflection mechanism (implemented, for example,
    by mocking library). In addition, it can make developers to think over the design
    of the class, since many injected dependencies suppose many constructor parameters,
    and this should be avoided (*God object* anti-pattern).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Different ways of dependency injection (Autowired) in Spring
  prefs: []
  type: TYPE_NORMAL
- en: 'The last component in our example is named `MessageService`. Note that is also
    a Spring component, this time annotated with `@Service` to remark its service
    nature (from a functional perspective, it would be the same than annotating the
    class with `@Component`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we execute the main class of this example (called `MySpringApplication`,
    see the source code here), we create an annotation-based application context with
    a try with resources (this way the application context will be closed at the end).
    The Spring IoC container will create two beans: `MessageService` and `MessageComponet`.
    Using the application context, we seek the bean `MessageComponet` and invoke its
    method `getMessage`, which is finally written in the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Spring modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring framework is modular, allowing developers to use only the needed
    modules provided by the framework. The complete list of this modules can be found
    on [https://spring.io/projects](https://spring.io/projects). The following table
    summarizes some of the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Spring project** | **Logo** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Framework | ![](img/00107.jpeg) | Provides core support for DI, transaction
    management, web applications (Spring MCV), data access, messaging, and so on.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Spring IO Platform | ![](img/00108.jpeg) | Brings together the core Spring
    APIs into a cohesive and versioned foundational platform for modern applications.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Boot | ![](img/00109.jpeg) | Simplifies the creation of standalone,
    production-grade Spring-based applications with the minimal configuration. It
    follows the convention-over-configuration approach. |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Data | ![](img/00110.jpeg) | Simplifies data access by means of comprehensive
    APIs to work with the relational databases, NoSQL, map-reduce algorithms, and
    so on. |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Cloud | ![](img/00111.jpeg) | Provides a set of libraries and common
    patterns for building and deploying distributed systems and microservices. |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Security | ![](img/00112.jpeg) | Provides customizable authentication
    and authorization capabilities for Spring-based applications. |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Integration | ![](img/00113.jpeg) | Provides a lightweight, POJO-based
    messaging for Spring-based applications to integrate with external systems. |'
  prefs: []
  type: TYPE_TB
- en: '| Spring Batch | ![](img/00114.jpeg) | Provides a lightweight framework designed
    to enable the development of robust batch applications for operations of enterprise
    systems. |'
  prefs: []
  type: TYPE_TB
- en: Introduction to Spring Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring a module called `spring-test`, which supports unit and integration testing
    of Spring components. Among other features, this module provides the ability to
    create Spring application context for testing purposes or create mock objects
    that to test our code in isolation. There are different annotations supporting
    this testing capabilities. A list of the most significant one is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@ContextConfiguration`: This annotation is used to determine how to load and
    configure an `ApplicationContext` for integration tests. For example, it allows
    to load the application context from annotated classes (using the element classes)
    or bean definitions declared in XML files (using the element locations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ActiveProfiles`: This annotation is used to instruct the container about
    which definition profiles should be active during the application context loading
    (for example, development and test profiles).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@TestPropertySource`: This annotation is used to configure the locations of
    the properties files and the inline properties to be added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@WebAppConfiguration`: This annotation is used to instruct the Spring context
    that `ApplicationContext` loaded is `WebApplicationContext.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the `spring-test` module offers several capabilities to carry
    out different actions typically required in tests, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: The `org.springframework.mock.web` package contains a set of Servlet API mock
    objects, useful for testing web contexts. For instance, the object `MockMvc` allows
    to perform HTTP requests (`POST`, `GET`, `PUT`, `DELETE`, and so on) and verify
    the response (status code, content type, or response body).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.springframework.mock.jndi` package contains an implementation of the
    **Java Naming and Directory Interface** (**JNDI**) SPI, which can be used to set
    up a simple JNDI environment for tests. For instance, using the class `SimpleNamingContextBuilder`
    we can make a JNDI data source available in our tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.springframework.test.jdbc` package contains the class `JdbcTestUtils`,
    which is a collection of JDBC utility functions aimed to simplify standard database
    access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `org.springframework.test.util` package contains the class `ReflectionTestUtils`,
    which is a collection of utility methods to set a non-public field or invoke a
    private/protected setter method when testing the application code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Spring Boot applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As introduced before, Spring Boot is a project of the Spring portfolio aimed
    to simplify the development of Spring applications. The main benefits of using
    Spring Boot are summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A Spring Boot application is just a Spring `ApplicationContext` in which the
    principal convention over configuration is used. Thank to this, it is faster to
    get started with the Spring development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The annotation `@SpringBootApplication` is used to identify the main class in
    a Spring Boot project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A range of non-functional features are provided out of the box: embedded servlet
    containers (Tomcat, Jetty, and Undertow), security, metrics, health checks, or
    externalized configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A creation of standalone running applications that just run using the command
    `java -jar` (even for web applications).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot **command line interface** (**CLI**) allows to run Groovy scripts
    for quickly prototyping with Spring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Boot works in the same way as any standard Java library, that is, to
    use it, we simply need to add the appropriate `spring-boot-*.jar` in our project
    classpath (typically using build tools such as Maven or Gradle). Spring Boot provides
    a number of *starters* aimed to ease the process of adding the different libraries
    to the classpath. The following table contains several of those starters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter` | Core starter, including auto-configuration support
    and logging |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-batch` | Starter for using Spring Batch |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-cloud-connectors` | Starter for using Spring Cloud Connectors,
    which simplifies connecting to services in Cloud platforms like Cloud Foundry
    and Heroku |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-jpa` | Starter for using Spring Data JPA with Hibernate
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-integration` | Starter for using Spring Integration
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jdbc` | Starter for using JDBC with the Tomcat JDBC
    connection pool |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-test` | Starter for testing Spring Boot applications
    with libraries, including JUnit, Hamcrest, and Mockito |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-thymeleaf` | Starter for building MVC web applications
    using Thymeleaf views |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web` | Starter for building web, including REST, applications
    using Spring MVC. Uses Tomcat as the default embedded container |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-websocket` | Starter for building WebSocket applications
    using Spring Framework’s WebSocket support |'
  prefs: []
  type: TYPE_TB
- en: 'For complete information about Spring Boot visit the official reference: [https://projects.spring.io/spring-boot/.](https://projects.spring.io/spring-boot/)'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot provides different capabilities to simplify the tests. For instance,
    it provides the `@SpringBootTest` annotation, which is used at classlevel in test
    classes. This annotation will create `ApplicationContext` for these tests (similarly
    to `@ContextConfiguration` but for Spring Boot based applications). As we have
    seen in the section before, in the `spring-test` module, we use the annotation
    `@ContextConfiguration(classes=… )` to specify, which bean definition (Spring
    `@Configuration`) to be loaded. When testing Spring Boot applications this is
    often not required. Spring Boot’s tests annotations will search the primary configuration
    automatically if not explicitly define one. The search algorithm works up from
    the package that contains the test until it finds a `@SpringBootApplication` annotated
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot also facilitates the use of mocks for Spring components. To that,
    the annotation `@MockBean` is provided. This annotation allows defining a Mockito
    mock for a bean inside our `ApplicationContext`. It can be new beans, but also
    to it can replace a single existing bean definition. Mock beans are automatically
    reset after each test method. This method is usually known as in-container testing,
    in counterpart to out-of-container, in which a mock library (example, Mockito)
    is used to unit test the Spring components in isolation and without the need of
    a Spring `ApplicationContext`. For example of both types of unit tests for Spring
    applications is shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to integrate the `spring-test` capabilities into JUnit 5's Jupiter
    programming model, `SpringExtension` has been developed. This extension is part
    of the `spring-test` module, as of Spring 5\. Let's see several examples of JUnit
    5 and Spring 5 together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we want to make an integration in-container test of the Spring
    application described in the former section, made up of three classes: `MySpringApplication`,
    `MessageComponent`, and `MessageService`. As we have learned, in order to implement
    a Jupiter test against this application, we need to make the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotate our test class with `@ContextConfiguration` to specify which `ApplicationContext`
    needs to be loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Annotate our test class with `@ExtendWith(SpringExtension.class)` to enable
    `spring-test` into Jupiter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject the Spring component we want to assess in our test class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement our test (`@Test`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple example in which the Spring component called `MessageComponent`
    is assessed. When this test is started, our `ApplicationContext` is initiated
    with and all our Spring components inside. After that, in this example, the bean
    `MessageComponent` is injected in the test, which is assessed simply calling the
    method `getMessage()` and verifying its response.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth to review which dependencies are needed for this test. When using
    Maven, these dependencies are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other side, if we use Gradle, the dependencies clause would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in both cases the `spring-context` dependency is needed to implement
    the application, and then we need `spring-test` and `junit-jupiter` to test it.
    In order to implement the equivalent application and test, but this time using
    Spring Boot, first we would need to change our `pom.xml` (when using Maven):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Or our `build.gradle` (when using Gradle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to transform our raw Spring application into Spring Boot, our components
    (in the example called `MessageComponent` and `MessageService`) would be exactly
    the same, but our main class would change a bit (see here). Notice that we use
    the annotation `@SpringBootApplication` at class level, implementing the main
    method with the typically bootstrapping mechanism of Spring Boot. Just for logging
    purposes, we are implementing a method annotated with `@PostConstruct`. This method
    will be triggered just before the application context is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the test would be straightforward. The only change we
    need to do is to annotate the test with `@SpringBootTest` instead of `@ContextConfiguration`
    (Spring Boot automatically looks for and starts our `ApplicationContext`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Executing the test in the console, we can see that actually the application
    is started before the test (notice the unmistakable spring ASCII banner at the
    beginning).
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, our test uses the `ApplicationContext` to verify one Spring component,
    and as a result the test is succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of test using Spring Boot
  prefs: []
  type: TYPE_NORMAL
- en: To finish with this part, we see a simple web application implemented with Spring
    Boot. With respect to the dependencies, the only change we need to do is to include
    the started `spring-boot-starter-web` (instead of the generic `spring-boot-starter`).
    That’s it, we can start implementing our Spring-based web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to implement a very simple `@Controller`, that is, the Spring
    bean, which handles the request from the browsers. In our example, the only URL
    mapped by the controller is the default resource `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This component injects a service called `PageService`, responsible of returning
    the actual page to be loaded in response to the request to `/`. The content of
    this service is also very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By convention (we are using Spring Boot here), the static resource for Spring-based
    web applications are located in a folder called `static` within the project classpath.
    Following the structure of Maven/Gradle project, this folder is located in the
    `src/main/resources` path (see screenshot below). Note that there are two pages
    there (we switch from one to the other in the tests, stay tuned):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Content of the example project *junit5-spring-boot-web*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on not the interesting part: the tests. We are implementing three
    Jupiter tests in this project. The first one is devoted to verify a direct call
    to the page `/index.html`. As depicted before, this test needs to use the Spring
    extension (`@ExtendWith(SpringExtension.class)`) and be declared as Spring Boot
    test (`@SpringBootTest`). To carry out the request to web application, we use
    an instance of the `MockMvc`, verifying the response in several ways (HTTP response
    code, content-type, and response content body). This instance is automatically
    configured using the Spring Boot annotation `@AutoConfigureMockMvc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Out of Spring Boot, instead of using `@AutoConfigureMockMvc`, the object `MockMvc`
    can be created using a builder class called `MockMvcBuilders`. In this case, the
    application context is used as parameter for that builder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, running this test in the shell, we check that the application is actually
    executed. By default, the embedded Tomcat listens the port `8080`. After that,
    test is executed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of in-container first test
  prefs: []
  type: TYPE_NORMAL
- en: 'Second test is similar, but as a differential factor it uses the test capability
    `@MockBean` to override a spring component (in this example, `PageService`) by
    a mock. In the body of the test, first we stub the method `getPage` of the mock
    to change the default response of the component to `redirect:/page.html`. As a
    result, when requesting the resource `/` in the test with the object `MockMvc`,
    we will obtain an HTTP 302 response (redirect) to the resource `/page.html` (which
    is actually an existing page, as shown in the project screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, in the shell we can confirm that the test starts the Spring application
    and then it is executed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of in-container second test
  prefs: []
  type: TYPE_NORMAL
- en: 'The last test in this project is an example of an *out-of-container* test.
    In the previous test examples, the Spring context was used within the test. On
    the other side, the following relies completely in Mockito to exercise the components
    of the system, this time without starting the Spring application context. Note
    that we are using the `MockitoExtension` extension here, using the component `WebController`
    as our SUT (`@InjectMocks`) and the component `PageService` as DOC (`@Mock`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, in the execution of the test, we do not see spring traces since
    the application container was not started before executing the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of out-of-container test
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)) is an open
    source web testing framework, since its inception in 2008 has established itself
    as the *de facto* web automation library. In the next section, we are going to
    review the main features of Selenium and how to use it from JUnit 5 tests.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium is composed by different projects. First, we found the Selenium IDE.
    It is a Firefox plugin implementing the R**ecord and Playback** (**R&P**) pattern
    for web applications. Thus, it allows to record manual interactions with Firefox
    and the playback that recording in an automated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The second project was named **Selenium Remote Control** (**RC**). This component
    was capable of driving different types of browser automatically using different
    programming languages, such as Java, C#, Python, Ruby, PHP, Perl, or JavaScript.
    This component injected a JavaScript library (called Selenium Core) in the SUT.
    This library was controlled with an intermediate component called Selenium RC
    Server which receives requests from the test code (see the following figure).
    Selenium RC had important security problems due to same-origin policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that reason, it was deprecated on 2016 in favor of Selenium WebDriver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Selenium RC schema
  prefs: []
  type: TYPE_NORMAL
- en: We review Selenium RC just to introduce Selenium WebDriver. Nowadays, Selenium
    RC is deprecated and its use is highly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: From a functional point of view, Selenium WebDriver is equivalent to RC (that
    is, allows to control browsers using code). As a differential aspect, Selenium
    WebDriver makes calls to the browser using each browser’s native support for automation.
    The language bindings provided by Selenium WebDriver (labeled as Test in next
    figure) communicates with and a browser-specific binary, which acts as a bridge
    between real browser. For instance, this binary is called *chromedriver* ([https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/))
    for Chrome and *geckodriver* ([https://github.com/mozilla/geckodriver](https://github.com/mozilla/geckodriver))
    for Firefox. The communication between the Test and the driver is done with JSON
    messages over HTTP using the so-called JSON Wire Protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mechanism, originally proposed by the WebDriver team is standardized in
    the W3C WebDriver API ([https://www.w3.org/TR/webdriver/](https://www.w3.org/TR/webdriver/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)Selenium WebDriver schema'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last project of the Selenium portfolio is called Selenium Grid. It can
    be seen as extension of Selenium WebDriver, since it allows distributing browser
    execution on remote machines. There are a number of Nodes, each running on different
    operating systems and with different browsers. The Hub server keeps a track of
    the nodes and proxies requests to them (see figure below):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)Selenium Grid schema'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the main features of the WebDriver API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **WebDriver feature and description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| WebDriver object creation:It allows to create WebDriver instances, which
    are used from the test code to control a browser remotely. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Navigation:It allows to navigate to a given URL. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Locate elements:It allows to identify elements with a web page (WebElement)
    using different strategies: by id, name, class name, CSS selector, link text,
    tag name, or XPath |'
  prefs: []
  type: TYPE_TB
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Interact with elements:From a given WebElement, we can carry out different
    types of automated interaction, such as click elements, type text or clear input
    fields, read attributes, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Handle waits:WebDriver can handle wait both explicit and implicitly. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: XPath (XML Path Language) is a language to build expressions to parse and process
    XML-like documents (for example, HTML)
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to simplify the use of Selenium WebDriver in JUnit 5, the open source
    JUnit 5 extension called `selenium-jupiter` can be used. This extension has been
    built using the dependency injection capability provided by the extension model
    of JUnit 5\. Thanks to this feature, different types objects can be injected in
    JUnit 5 in `@Test` methods as parameters. Concretely, `selenium-jupiter` allows
    to inject subtypes of the `WebDriver` interface (for example, `ChromeDriver`,
    `FirefoxDriver`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `selenium-jupiter` is very easy. First, we need to import the dependency
    in our project (typically as test dependency). In Maven, it is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`selenium-jupiter` depends on several libraries, which are added in our project
    as transitive `dependencies`, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Selenium-java` (`org.seleniumhq.selenium:selenium-java`): Java library for
    Selenium WebDriver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebDriverManager` (`io.github.bonigarcia:webdrivermanager`): Java library
    for automatic Selenium WebDriver binaries management in runtime for Java ([https://github.com/bonigarcia/webdrivermanager](https://github.com/bonigarcia/webdrivermanager)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Appium (`io.appium:java-client`): Java client for Appium, testing framework
    that extends Selenium to automate testing of native, hybrid, and mobile web apps
    ([http://appium.io/](http://appium.io/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once `selenium-jupiter` is included in our project, we need to declare `selenium-jupiter`
    extension in our JUnit 5 test, simply annotating it with `@ExtendWith(SeleniumExtension.class)`.
    Then, we need to include one or more parameters in our `@Test` methods whose types
    implement the WebDriver interface, and `selenium-jupiter` control the lifecycle
    of the WebDriver object internally. He WebDriver subtypes supported by `selenium-jupiter`
    are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ChromeDriver`: This is used to control Google Chrome browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FirefoxDriver`: This is used to control Firefox browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EdgeDriver`: This is used to control Microsoft Edge browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OperaDriver`: This is used to control Opera browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafariDriver`: This is used to control Apple Safari browser (only possible
    in OSX El Capitan or greater).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HtmlUnitDriver`: This is used to control HtmlUnit (headless browser, that
    is, a browser without GUI).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PhantomJSDriver`: This is used to control PhantomJS (another headless browser).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InternetExplorerDriver`: This is used to control Microsoft Internet Explorer.
    Although this browser is supported, Internet Explorer is deprecated (in favor
    of Edge) and its use is highly discouraged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoteWebDriver`: This is used to control remote browsers (Selenium Grid).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AppiumDriver`: This is used to control mobile devices (Android and iOS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following class, which uses `selenium-jupiter` , that is, declaring
    the Selenium extension using `@ExtendWith(SeleniumExtension.**class**)`. This
    example defines three tests, which are going be executed using local browsers.
    First one (named `testWithChrome`) uses Chrome as browsers. To that aim, and thanks
    to the dependency injection feature of `selenium-jupiter`*,* the method simply
    needs to declare a method argument using the type `ChromeDriver`. Then, in the
    body of the test, the `WebDriver` API is invoked in that object. Note that this
    test simple opens a web page and asserts that the title is as expected. Next,
    test (`testWithFirefoxAndOpera`) is similar, but this time using two different
    browsers at the same time: Firefox (using an instance of `FirefoxDriver`) and
    Opera (using an instance of `OperaDriver`). The third and last test (`testWithHeadlessBrowsers`)
    declares and uses two headless browsers (`HtmlUnit` and `PhantomJS`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In order to execute properly this test class, the required browsers (Chrome,
    Firefox, and Opera) should be installed beforehand running it. On the other hand,
    the headless browsers (HtmlUnit and PhantomJS) are consumed as Java dependencies,
    and so there is no need to install them manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see another example, this time using remote browsers (that is, Selenium
    Grid). Again, this class uses the `selenium-jupiter` extension. The test (`testWithRemoteChrome`)
    declares a single parameter called `remoteChrome`, of type `RemoteWedbrider`.
    This argument is annotated with `@DriverUrl` and `@DriverCapabilities`, specifying
    the Selenium Server (or Hub) URL and the required capabilities respectively. Regarding
    the capabilities, we are configuring to use a Chrome browser version 59:'
  prefs: []
  type: TYPE_NORMAL
- en: To run this test properly, a Selenium Server should up and running in the localhost,
    and a node (Chrome 59) needs to be registered in the Hub.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last example of this section, we use `AppiumDriver`. Concretely, we
    set up as capabilities the use of a Chrome browser in an Android emulated device
    (`@DriverCapabilities`). Again, this emulator needs to be up and running in the
    machine running the test beforehand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: For further examples of `selenium-jupiter`, visit [https://bonigarcia.github.io/selenium-jupiter/](https://bonigarcia.github.io/selenium-jupiter/).
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber ([https://cucumber.io/](https://cucumber.io/)) is testing framework
    aimed to automate acceptance tests written following a **Behavior-Driven Development**
    (**BDD**) style. Cucumber has been written in Ruby, although implementations for
    other languages (including Java, JavaScript, and Python) are available.
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber executes tests specified written in language called Gherkin. It is
    a plaint-text natural language (for example, English or one of other 60+ languages
    supported by Cucumber) with a given structure. Gherkin has been designed to be
    used by non-programmers, typically customers, business analysis, managers, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: The extension for Gherkin files is `*.feature*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Gherkin file, non-blank lines can start with a keyword, followed by text
    in natural language. The main keywords are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature**: High-level description of the software feature to be tested. It
    can be seen as a use case description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scenario**: Concrete example that illustrates a business rule. Scenarios
    follow the same pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe initial context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe an event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the expected outcome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These actions are known in the Gherkin jargon as steps, which are mainly **Given**,
    **When**, or **Then**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two additional steps: **And** (used for logical and for different
    steps) and **But** (used in for negative form of **And**).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: Preconditions and initial state before the start of a test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: Actions taken by a user during a test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then**: Outcome from actions taken in the **When** clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background**: To avoid repeat steps in different scenarios, the keyword background
    allows to declared these steps, which are reused in subsequent scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scenario Outline**: Scenarios in which steps are marked with variables (using
    the symbols `**<**` and `**>**`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Examples**: A scenario outline declaration is always followed by one or more
    examples sections, which is a container table with values for the declared variables
    in the **Scenario Outline**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one line does not start with a keyword, that line is not interpreted by
    Cucumber. It is used to custom description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we defined our features to be tested we need what it is called *steps
    definition*, which allows to translate plain text Gherkin into actions that actually
    exercise our SUT. In Java, it can be easily done by annotations to annotate methods
    for the step implementation: `@Given`, `@Then`, `@When`, `@And`, and `@But`. The
    string value of each step can contain regular expression which are mapped as fields
    in the method. See an example in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: JUnit 5 extension for Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest versions of the Cucumber artifacts for Java incorporates a JUnit
    5 extension for Cucumber. This section contains a complete example of a feature
    defined in Gherkin and the JUnit 5 to execute it with Cucumber. As usual, the
    source code of this example is hosted on GitHub ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the project containing this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: JUnit 5 with Cucumber project structure and content
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to create our Gherkin file, which is aimed to test a
    simple calculator system. This calculator will be the SUT or our test. The content
    of our feature file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to implement our steps definition. As described earlier, we use
    annotations and regular expression to map the text contained in the Gherkin file
    to the actual exercise of SUT depending on the step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we still need to implement our JUnit 5 test. To achieve the integration
    of Cucumber and JUnit 5, the Cucumber extension needs to be registered in our
    class by means of `@ExtendWith(CucumberExtension.**class**)`. Internally, `CucumberExtension`
    implements the `ParameterResolver` callback of the Jupiter extension model. The
    objective is to inject the corresponding tests of the Cucumber feature as Jupiter
    `DynamicTest` objects in the tests. Notice in the example how a `@TestFactory`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, we can annotate our test class with `@CucumberOptions`. This annotation
    allows to configure the Cucumber settings for our test. The allowed elements for
    this annotation are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`plugin`: Built-in formatter: pretty, progress, JSON, usage, among others.
    Default: `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dryRun`: Checks if all steps have definitions. Default: `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`features`: Paths of the features files. Default: `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`glue`: Paths for step definitions. Default: `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags`: Tags in the features to be executed. Default `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`monochrome`: Displays console output in a readable way. Default: `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: Reports formatter to be used. Default: `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strict`: Fails if there are undefined or pending steps. Default: `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are able to execute our Cucumber suite with JUnit 5\. In
    the following example we see the output when running the test with Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of JUnit 5 using Cucumber with Gradle
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker ([https://www.docker.com/](https://www.docker.com/)) is an open source
    software technology, which allows to pack and run any application as a lightweight
    and portable container. It provides a command-line program, a background daemon,
    and a set of remote services that simplifies the life cycle of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, UNIX-style operating systems used the term jail to describe modified
    isolated runtime environments. The **Linux Containers** (**LXC**) project started
    in 2008 and brought together cgroups, kernel namespaces, or chroot (among others)
    to provide complete isolation execution. The problem with LXC is the difficulty,
    and for that reason, the Docker technology emerged.
  prefs: []
  type: TYPE_NORMAL
- en: Docker hides in underlying complexity of the aforementioned resource isolation
    features of the Linux kernel (cgroups, kernel namespaces, and so on) to allow
    independent containers to run within a single Linux instance. Docker provides
    a high-level API, which allows to pack, ship and run any application as a container.
  prefs: []
  type: TYPE_NORMAL
- en: In Docker, a container contains an application and its dependencies together.
    Multiple containers can run on the same machine and share the same OS kernel with
    other containers. Each container is running as isolated process in user space.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike **virtual machines** (**VMs**), in Docker containers there is no need
    of using a hypervisor, which is the software that allows to create and runs VM
    (example; VirtualBox, VMware, QEMU or Virtual PC).
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of VM and container are depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Virtual machine versus container
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker platform has two components: the Docker Engine, which is responsible
    for creating and running containers; and the Docker Hub ([https://hub.docker.com/](https://hub.docker.com/)),
    a cloud service for distributing containers. The Docker Hub provides an enormous
    number of public container images for download. The Docker Engine is a client-server
    application composed by three major components:'
  prefs: []
  type: TYPE_NORMAL
- en: A server implemented as a daemon process (the `dockerd` command).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A REST API, which specifies interfaces that programs can use to talk to the
    daemon and instruct it what to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **command line interface** (**CLI**) client (the `docker` command).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5 extension for Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, containers are changing the way we develop, distribute, and run software.
    This is especially interesting for **Continuous Integration** (**CI**) testing
    environment, in which the convergence with Docker has a direct impact on the improvement
    of efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding JUnit 5, at the moment of this writing there is an open source JUnit
    5 extension for Docker, named JUnit5-Docker ([https://faustxvi.github.io/junit5-docker/](https://faustxvi.github.io/junit5-docker/)).
    This extension acts as client of the Docker engine and allows to start a Docker
    container (downloaded from the Docker Hub), before running the tests of a class.
    That container is stopped at the end of the tests. In order to use JUnit5-Docker,
    first we need to add the dependency in our project. In Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of JUnit5-Docker is quite straightforward. We simply need to annotate
    our test class with `@Docker`. The elements available in this annotation are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image`: Docker image to be started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: Port mapping for the Docker container. This is required since at least
    one port must be visible for the container to be useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environments`: Optional environment variables to pass to the docker container.
    Default: `{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waitFor`: Optional log to wait for before running the tests. Default: `@WaitFor(NOTHING)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newForEachCase`: Boolean flag, which determines if the container should be
    recreated for each test case. This value will be false if it should be created
    only once for the test class. Default: `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the following example. This test class uses the `@Docker` annotation
    to start a MySql container (container image MySQL) and the beginning of each test.
    The internal container port is `3306`, which will be mapped to the host port `8801`.
    Then, several environment attributes are defined (MySql root password, default
    database, and user name and password). The execution of the test will not start
    until the trace *mysqld: ready for connections* appears in the container log (which
    indicates that the MySql instance is up and running). In the body of the test,
    we start a JDBC connection against the MySQL instance running in the container.'
  prefs: []
  type: TYPE_NORMAL
- en: This test has been executed in a Windows machine. For that reason, the host
    of the JDBC URL is 192.168.99.100, which is the IP for the Docker Machine. It
    is a tool which allows to install Docker Engine on virtual hosts, such as Windows
    or Mac ([https://docs.docker.com/machine/](https://docs.docker.com/machine/)).
    In a Linux machine, this IP could be 127.0.0.1 (localhost).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of this test in the Docker Windows terminal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of test using JUnit5-Docker extension
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android ([https://www.android.com/](https://www.android.com/)) is an open source
    mobile operating system based on a modified version of Linux. It was originally
    developed by a startup named Android, acquired and championed by Google in 2005.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the report by Gartner Inc. (American IT research and advisory
    company), in 2017 Android and iOS account more than 99% of global smartphone sales,
    as shown in the following chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Smartphone operative system market. Picture created by www.statista.com.
  prefs: []
  type: TYPE_NORMAL
- en: Android in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android is a Linux-based software stack divided into several layers. Those
    layers, from down to top are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux kernel**: This is the foundation of the Android platform. This layer
    contains all the low-level device drivers for the various hardware components
    of an Android device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardware Abstraction Layer** (**HAL**): This layer provides standard interfaces
    that expose hardware capabilities to the higher-level Java API framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android Runtime** (**ART**): It provides a runtime environment for `.dex`
    files, a bytecode format designed for minimal memory footprint. ART was the first
    release on Android 5.0 (see table below). Prior to that version, Dalvik was the
    Android runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native C/C++ libraries**: This layer contains native libraries written in
    C and C++, such as OpenGL ES for high-performance 2D and 3D graphics processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java API framework**: The entire feature-set of Android is available for
    developers through APIs written in Java. These APIs are the building block for
    creating Android apps, for instance: the View System (for apps UIs), the Resource
    Manager (for I18N, graphics, layouts), the Notification Manager (for custom alerts
    in the status bar), the Activity Manager (to manage the apps lifecycle), or the
    Content Provider (to enable apps access data from other apps, such as the Contacts,
    and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apps**: Android comes with a set of core apps, such as Phone, Contacts, Browser,
    and so on. In addition, many others apps can be downloaded and installed from
    Google Play (formerly Android Market):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00128.jpeg)Android layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has gone through quite a number of updates since its first release,
    as described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Android version** | **Codename** | **API level** | **Linux kernel version**
    | **Release date** |'
  prefs: []
  type: TYPE_TB
- en: '| 1.5 | Cupcake | 3 | 2.6.27 | April 30, 2009 |'
  prefs: []
  type: TYPE_TB
- en: '| 1.6 | Donut | 4 | 2.6.29 | September 15, 2009 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.0, 2.1 | Eclair | 5, 6, 7 | 2.6.29 | October 26, 2009 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.2 | Froyo | 8 | 2.6.32 | May 20, 2010 |'
  prefs: []
  type: TYPE_TB
- en: '| 2.3 | Gingerbread | 9, 10 | 2.6.35 | December 6, 2010 |'
  prefs: []
  type: TYPE_TB
- en: '| 3.0, 3.1, 3.2 | Honeycomb | 11, 12, 13 | 2.6.36 | February 22, 2011 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.0 | Ice Cream Sandwich | 14, 15 | 3.0.1 | October 18, 2011 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.1, 4.2, 4.3 | Jelly Bean | 16, 17, 18 | 3.0.31, 3.0.21, 3.4.0 | July 9,
    2012 |'
  prefs: []
  type: TYPE_TB
- en: '| 4.4 | KitKat | 19, 20 | 3.10 | October 31, 2013 |'
  prefs: []
  type: TYPE_TB
- en: '| 5.0, 5.1 | Lollipop | 21, 22 | 3.16.1 | November 12, 2014 |'
  prefs: []
  type: TYPE_TB
- en: '| 6.0 | Marshmallow | 23 | 3.18.10 | October 5, 2015 |'
  prefs: []
  type: TYPE_TB
- en: '| 7.0, 7.1 | Nougat | 24, 25 | 4.4.1 | August 22, 2016 |'
  prefs: []
  type: TYPE_TB
- en: '| 8.0 | Android O | 26 | TBA | TBA |'
  prefs: []
  type: TYPE_TB
- en: From a developer point of view, Android provides a rich application framework,
    which allows to build apps for mobile devices. Android apps are written in the
    Java programming language. The Android **Software Development Kit** (**SDK**)
    compile out Java code along with any data and resource files into an `.apk` (Android
    package) file, which contains can be installed in Android-powered devices, such
    as smartphones, tablets, smart TVs, or smartwatches.
  prefs: []
  type: TYPE_NORMAL
- en: For complete information about Android development, visit [https://developer.android.com/](https://developer.android.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Studio is the official IDE for Android development. It is built based
    on IntelliJ IDEA. In Android Studio, the build process of Android projects is
    managed by the Gradle build system. During the Android Studio installation, two
    additional tools can be also installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Android SDK**: This contains all of the packages and tools required to develop
    Android apps. The SDK Manager allows to download and install SDK for different
    versions (see the preceding table).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Android Virtual Device** (**AVD**): This is an emulator that allows us to
    model an actual device. The AVD Manager allows to download and install different
    emulated Android virtual devices grouped into four categories: phones, tables,
    TV, and wears.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle plugin for JUnit 5 in Android projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of this writing, there is no official support for JUnit 5 in Android
    projects. To solve this problem, an open source Gradle plugin named `android-junit5`
    has been created ([https://github.com/aurae/android-junit5](https://github.com/aurae/android-junit5)).
    To use this plugin, first we need to specify the proper dependency in our `build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use this plugin in our project, we need to extend our project capabilities
    using the clause `apply plugin` in our `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `android-junit5` plugin configures the `junitPlatform` task, attaching
    automatically attaches both the Jupiter and Vintage engines during the test execution
    phase. As an example, consider the following project example, as usual hosted
    on GitHub ([https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android](https://github.com/bonigarcia/mastering-junit5/tree/master/junit5-android)).
    The following is a screenshot of this project imported in Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)Android project compatible with JUnit 5 on IntelliJ'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create an Android JUnit run configuration of Android Studio.
    As can be seen in the screenshot, we use the option `All in package` referred
    to the package containing the tests (`io.github.bonigarcia.myapplication` in this
    example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Android JUnit run configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'If we launch the aforementioned run configuration, all the tests of the project
    will be executed. These tests can use the JUnit 4 programming model (Vintage)
    and even the JUnit 5 (Jupiter) in a seamless way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Execution on Jupiter and Vintage tests within an Android project in IntelliJ
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roy Fielding is an American computer scientist born in 1965\. He is one of the
    authors of the HTTP protocol and the co-authors of the Apache Web server. In the
    year 2000, Fielding coined the term REST (short for REpresentational State Transfer)
    in his doctoral dissertation entitled *Architectural Styles and the Design of
    Network-based Software Architecture.* REST is an architectural style for designing
    distributed systems. It’s not a standard, but rather a set of constraints. REST
    is commonly used in conjunction with HTTP. On the one hand, the implementations
    which follows the strict principles of REST are often referred as RESTful. On
    the other hand, those which follow a loose adherence of such principles are called
    RESTlike.
  prefs: []
  type: TYPE_NORMAL
- en: REST in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST follows a client-server architecture. The server is in charge of handling
    a set of services, listening for requests made by clients. The communication between
    client and server must be stateless, meaning that server do not store any record
    from the clients and therefore each request done from the client must contain
    all the information required for the server to process it separately.
  prefs: []
  type: TYPE_NORMAL
- en: The building blocks of REST architectures are named resources. Resources define
    the type of information that is going to be transferred. Resources should be identified
    in a unique way. In HTTP, the way to access the resource it to provide its full
    URL, also known as API endpoint. Each resource has a representation, which is
    a machine-readable explanation of the current state of a resource. Nowadays, representations
    are usually with JSON, but it can be done in other formats such as XML or YAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we identified the resources and the representation format, we need to
    specify what can be done with them, that is, the actions. Actions could potentially
    be anything, although there is a set of common actions that any resource-oriented
    system should provide: CRUD (create, retrieve, update, and delete) actions. REST
    actions can be mapped to the HTTP methods (so-called verbs), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Reads a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: Sends a new resource to the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: Updates a given resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Deletes a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: update partially a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: Asks if a given resource exists without returning any of its representations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: Retrieves a list of available verbs on a given resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In REST, it is important the notion of *idempotency*. For example, `GET`, `DELETE`,
    or `PUT` are said to be idempotent, since the effect of these requests should
    be the same whether the command is sent one or several times. On the other hand,
    `POST` is not idempotent, since it creates a different resource each time it is
    requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'REST, when based on HTTP can benefit on standard HTTP status codes. A status
    code is a number that summarizes the response associated to it. The typical HTTP
    status code reused in REST are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200 OK`: The request went fine and the content requested was returned. Normally
    used on GET requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`201 Created`: The resource was created. Useful on responses to POST or PUT
    requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`204 No content`: The action was successful, but there is no content returned.
    Useful for actions that do not require a response body, such as a DELETE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`301 Moved permanently`: This resource was moved to another location and the
    location is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400 Bad request`: The request issued has problems (for example, lacking some
    required parameters).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`401 Unauthorized`: Useful for authentication when the requested resource is
    not accessible to the user owning the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`403 Forbidden`: The resource is not accessible, but unlike 401, authentication
    will not affect the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`404 Not found`: The URL provided does not identify any resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 405 Method not allowed. The HTTP verb used on a resource is not allowed. (for
    example, a PUT on a read-only resource).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500 Internal server error`: A generic error code when an unexpected condition
    in the server side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following picture shows an example of client-server interaction with REST.
    The body of the HTTP messages uses JSON both for requests and responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)REST sequence diagram example'
  prefs: []
  type: TYPE_NORMAL
- en: Using REST test libraries with Jupiter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST APIs are becoming more and more pervasive nowadays. For that reason, a
    proper strategy for assessing REST services is desirable. In this section, we
    are going to learn how to use several test libraries in our JUnit 5 tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we can use the open source library REST Assured ([http://rest-assured.io/](http://rest-assured.io/)).
    REST Assured allows the validation of REST services by means of a fluent API inspired
    in dynamic languages such as Ruby or Groovy. To use REST Assured in our test project,
    we simply need to add the proper dependency in Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'or in Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can use the REST Assured API. The following class contains two
    test examples. First sends a request to the free online REST service [http://echo.jsontest.com/](http://echo.jsontest.com/).
    Then verifies if the response code and the body content are as expected. The second
    test consumes another free online REST service ([http://services.groupkt.com/](http://services.groupkt.com/))
    and also verifies the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this test in console with Maven, we can check that both tests succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of test using REST Assured
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we are going to study, in addition to the test, we are
    also going to implement the server side, that is, the REST service implementation.
    To that aim, we are going to use Spring MVC and Spring Boot, previously introduced
    on this chapter (see section *Spring*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of REST services in Spring is quite straightforward. First,
    we simply need to annotate a Java class with `@RestController`. In the body of
    this class, we need to add methods annotated with `@RequestMapping`. These methods
    will listen to the different URLs (endpoints) implemented in our REST API. The
    accepted elements for the `@RequestMapping` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: This is the path mapping URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This finds the HTTP request methods to map to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: This finds parameters of the mapped request, narrowing the primary
    mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: his finds the headers of the mapped request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`consumes`: This finds consumable media types of the mapped request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`produces`: This finds producible media types of the mapped request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As can be seen inspecting the code of the following class, our service example
    implements three different operations: `GET /books` (to read all book in the system),
    `GET /book/{index}` (to read a book given its identifier), and `POST /book` (to
    create a book).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Since we are implementing a Jupiter test for Spring, we need to use the `SpringExtension`
    and also the `SpringBootTest` annotation. As a novelty, we are going to inject
    a test component provided by `spring-test`, named `TestRestTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: This component is a wrapper of the standard Spring's `RestTemplate` object,
    which allows to implement REST clients in a seamless way. In our test, it requests
    to our service (which is started before executing the tests), and responses are
    used to verify the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the object `MockMvc` (explained in the section *Spring*) could be
    also used to test REST services. The difference with respect to `TestRestTemplate`
    is that the former is used to test from the client-side (that is, response code,
    body, content type, and so on), while the the latter is used to test the service
    from the server side. For instance, in the example here, the responses to the
    service calls (`getForEntity` and `postForEntity`) are Java objects, whose scope
    is only the server side (in the client side, this information is serialized as
    JSON).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the screenshot below, our Spring application is started before
    running our tests, which are executed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.gif)'
  prefs: []
  type: TYPE_IMG
- en: Output of Jupiter test using TestRestTemplate to verify a REST service.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this section, we see an example in which the library WireMock ([http://wiremock.org/](http://wiremock.org/))
    is used. This library allows to mock REST services, that is, a so-called HTTP
    *mock server*. This mock server captures incoming requests to the service, providing
    stubbed responses. This capability is very useful to test a system which consumes
    a REST service, but the service is not available during the tests (or we can test
    the component that calls the service in isolation).
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we see an example to demonstrate its usage. Let''s suppose we have
    a system which consumes a remote REST service. To implement a client for that
    service we use Retrofit 2 ([http://square.github.io/retrofit/](http://square.github.io/retrofit/)),
    which is a highly configurable HTTP client for Java. We define the interface to
    consume this service as illustrated in the class below. Notice that the service
    exposes three endpoints aimed to read a remote file (open file, read stream, and
    close stream):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we implement the class which consumes the REST service. In this example,
    it is a simple Java class which connects to the remote service given its URL passed
    as constructor parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we implement a JUnit 5 test to verify our service. Notce that we are
    creating the mock server (`**new** WireMockServer`) and stubbing the REST service
    calls using the static methods `stubFor(...)` provided by WireMock in the setup
    of the test (`@BeforeEach`). Since in this case, the SUT is very simple and it
    has no DOCs, we directly instantiate the class `RemoteFileService` also in the
    setup of each test, using the mock server URL as constructor argument. Finally,
    we test our service (which uses the mock server) simply exercising the object
    called `wireMockServer`, in this example, by calling to the method `getFile` and
    assessing its output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the test in the console, in the traces we can see how the internal
    HTTP server controlled by WireMock is started before the test execution. Then,
    the three REST operations (open stream, read bytes, close stream) are executed
    by the test, and finally the mock server is disposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of test using a mock REST server using WireMock
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section provides a detailed insight of how JUnit 5 can be used in conjunction
    with third-party frameworks, libraries, and platforms. Thanks to the Jupiter extension
    model, developers can create extensions which allows seamless integration with
    external frameworks to JUnit 5\. First, we have seen the *MockitoExtension*, an
    extension provided by the JUnit 5 team to use Mockito (a notorious mock framework
    for Java) in Jupiter tests. Then, we have used the *SpringExtension*, which is
    the official extension provided in the version 5 of the Spring Framework. This
    extension integrates Spring into the JUnit 5 programming model. This way, we are
    able to use Spring’s application contexts (that is, the Spring’s DI container)
    in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: We have also reviewed the *SeleniumExtension* implemented by *selenium-jupiter,*
    an open source project providing a JUnit 5 extension for Selenium WebDriver (testing
    framework for web applications). Thank to thins extension, we can use different
    browsers to interact automatically with web applications and emulated mobile devices
    (using Appium). Then, we have seen the *CucumberExtension,* allows to specify
    JUnit 5 acceptance tests following a BDD style using the Gherkin language. Finally,
    we have seen how the open source JUnit5-Docker extension can be used to start
    Docker containers (downloading the image from Docker Hub) before the execution
    of our JUnit 5 tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, we discovered that the extension model is not the only way of interacting
    with external technologies by JUnit tests. For example, in order to run Jupiter
    tests in an Android project, we can use the `android-junit5` plugin. On the other
    hand, even though there is no custom extension for assessing REST services using
    JUnit 5, the integration with such libraries is strait forward: we simply need
    to include the proper dependency in our project and use it in our tests (for example,
    REST Assured, Spring, or WireMock).'
  prefs: []
  type: TYPE_NORMAL
