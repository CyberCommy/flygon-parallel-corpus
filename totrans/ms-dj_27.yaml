- en: Appendix F. Request and Response Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django uses request and response objects to pass state through the system.
  prefs: []
  type: TYPE_NORMAL
- en: When a page is requested, Django creates an `HttpRequest` object that contains
    metadata about the request. Then Django loads the appropriate view, passing the
    `HttpRequest` as the first argument to the view function. Each view is responsible
    for returning an `HttpResponse` object.
  prefs: []
  type: TYPE_NORMAL
- en: This document explains the APIs for `HttpRequest` and `HttpResponse` objects,
    which are defined in the `django.http` module.
  prefs: []
  type: TYPE_NORMAL
- en: HttpRequest objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All attributes should be considered read-only, unless stated otherwise below.
    `session` is a notable exception.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.scheme**'
  prefs: []
  type: TYPE_NORMAL
- en: A string representing the scheme of the request (`http` or `https` usually).
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.body**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The raw HTTP request body as a byte string. This is useful for processing data
    in different ways than conventional HTML forms: binary images, XML payload etc.
    For processing conventional form data, use `HttpRequest.POST`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also read from an HttpRequest using a file-like interface. See `HttpRequest.read()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.path**'
  prefs: []
  type: TYPE_NORMAL
- en: A string representing the full path to the requested page, not including the
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `/music/bands/the_beatles/`'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.path_info**'
  prefs: []
  type: TYPE_NORMAL
- en: Under some web server configurations, the portion of the URL after the host
    name is split up into a script prefix portion and a path info portion. The `path_info`
    attribute always contains the path info portion of the path, no matter what web
    server is being used. Using this instead of `path` can make your code easier to
    move between test and deployment servers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the `WSGIScriptAlias` for your application is set to `/minfo`,
    then `path` might be `/minfo/music/bands/the_beatles/` and `path_info` would be
    `/music/bands/the_beatles/`.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A string representing the HTTP method used in the request. This is guaranteed
    to be uppercase. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**HttpRequest.encoding**'
  prefs: []
  type: TYPE_NORMAL
- en: A string representing the current encoding used to decode form submission data
    (or `None`, which means the `DEFAULT_CHARSET` setting is used). You can write
    to this attribute to change the encoding used when accessing the form data.
  prefs: []
  type: TYPE_NORMAL
- en: Any subsequent attribute accesses (such as reading from `GET` or `POST`) will
    use the new `encoding` value. Useful if you know the form data is not in the `DEFAULT_CHARSET`
    encoding.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.GET**'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary-like object containing all given HTTP `GET` parameters. See the
    `QueryDict` documentation below.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.POST**'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary-like object containing all given HTTP `POST` parameters, providing
    that the request contains form data. See the `QueryDict` documentation below.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to access raw or non-form data posted in the request, access this
    through the `HttpRequest.body` attribute instead.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible that a request can come in via `POST` with an empty `POST` dictionary-if,
    say, a form is requested via the `POST` HTTP method but does not include form
    data. Therefore, you shouldn't use `if request.POST` to check for use of the `POST`
    method; instead, use `if request.method == 'POST'` (see above).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: `POST` does *not* include file-upload information. See `FILES`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.COOKIES**'
  prefs: []
  type: TYPE_NORMAL
- en: A standard Python dictionary containing all cookies. Keys and values are strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.FILES**'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary-like object containing all uploaded files. Each key in `FILES`
    is the `name` from the `<input type="file" name="" />`. Each value in `FILES`
    is an `UploadedFile`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `FILES` will only contain data if the request method was `POST` and
    the `<form>` that posted to the request had `enctype="multipart/form-data"`. Otherwise,
    `FILES` will be a blank dictionary-like object.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.META**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard Python dictionary containing all available HTTP headers. Available
    headers depend on the client and server, but here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTENT_LENGTH`: The length of the request body (as a string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONTENT_TYPE`: The MIME type of the request body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_ACCEPT_ENCODING`: Acceptable encodings for the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_ACCEPT_LANGUAGE`: Acceptable languages for the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_HOST`: The HTTP Host header sent by the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_REFERER`: The referring page, if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTP_USER_AGENT`: The client''s user-agent string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QUERY_STRING`: The query string, as a single (unparsed) string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REMOTE_ADDR`: The IP address of the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REMOTE_HOST`: The hostname of the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REMOTE_USER`: The user authenticated by the web server, if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REQUEST_METHOD`: A string such as "`GET`" or "`POST`"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERVER_NAME`: The hostname of the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERVER_PORT`: The port of the server (as a string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the exception of `CONTENT_LENGTH` and `CONTENT_TYPE`, as given above, any
    HTTP headers in the request are converted to `META` keys by converting all characters
    to uppercase, replacing any hyphens with underscores and adding an `HTTP_` prefix
    to the name. So, for example, a header called `X-Bender` would be mapped to the
    `META` key `HTTP_X_BENDER`.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.user**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object of type `AUTH_USER_MODEL` representing the currently logged-in user.
    If the user isn''t currently logged in, `user` will be set to an instance of `django.contrib.auth.models.AnonymousUser`.
    You can tell them apart with `is_authenticated()`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`user` is only available if your Django installation has the `AuthenticationMiddleware`
    activated.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.session**'
  prefs: []
  type: TYPE_NORMAL
- en: A readable-and-writable, dictionary-like object that represents the current
    session. This is only available if your Django installation has session support
    activated.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.urlconf**'
  prefs: []
  type: TYPE_NORMAL
- en: Not defined by Django itself, but will be read if other code (for example, a
    custom middleware class) sets it. When present, this will be used as the root
    URLconf for the current request, overriding the `ROOT_URLCONF` setting.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.resolver_match**'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of `ResolverMatch` representing the resolved url. This attribute
    is only set after url resolving took place, which means it's available in all
    views but not in middleware methods which are executed before url resolving takes
    place (like `process_request`, you can use `process_view` instead).
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HttpRequest.get_host()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the originating host of the request using information from the `HTTP_X_FORWARDED_HOST`
    (if `USE_X_FORWARDED_HOST` is enabled) and `HTTP_HOST` headers, in that order.
    If they don't provide a value, the method uses a combination of `SERVER_NAME`
    and `SERVER_PORT` as detailed in PEP 3333.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `127.0.0.1:8000`'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_host()` method fails when the host is behind multiple proxies. One
    solution is to use middleware to rewrite the proxy headers, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This middleware should be positioned before any other middleware that relies
    on the value of `get_host()`-for instance, `CommonMiddleware` or `CsrfViewMiddleware`.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.get_full_path()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the `path`, plus an appended query string, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `/music/bands/the_beatles/?print=true`'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.build_absolute_uri(location)**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the absolute URI form of `location`. If no location is provided, the
    location will be set to `request.get_full_path()`.
  prefs: []
  type: TYPE_NORMAL
- en: If the location is already an absolute URI, it will not be altered. Otherwise
    the absolute URI is built using the server variables available in this request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: `http://example.com/music/bands/the_beatles/?print=true`'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.get_signed_cookie()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a cookie value for a signed cookie, or raises a `django.core.signing.BadSignature`
    exception if the signature is no longer valid. If you provide the `default` argument
    the exception will be suppressed and that default value will be returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: The optional `salt` argument can be used to provide extra protection against
    brute force attacks on your secret key. If supplied, the `max_age` argument will
    be checked against the signed timestamp attached to the cookie value to ensure
    the cookie is not older than `max_age` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**HttpRequest.is_secure()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `True` if the request is secure; that is, if it was made with HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.is_ajax()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `True` if the request was made via an `XMLHttpRequest`, by checking
    the `HTTP_X_REQUESTED_WITH` header for the string "`XMLHttpRequest`". Most modern
    JavaScript libraries send this header. If you write your own `XMLHttpRequest`
    call (on the browser side), you'll have to set this header manually if you want
    `is_ajax()` to work.
  prefs: []
  type: TYPE_NORMAL
- en: If a response varies on whether or not it's requested via AJAX and you are using
    some form of caching like Django's `cache middleware`, you should decorate the
    view with `vary_on_headers('HTTP_X_REQUESTED_WITH')` so that the responses are
    properly cached.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.read(size=None)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.readline()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.readlines()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.xreadlines()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpRequest.__iter__()**'
  prefs: []
  type: TYPE_NORMAL
- en: Methods implementing a file-like interface for reading from an `HttpRequest`
    instance. This makes it possible to consume an incoming request in a streaming
    fashion. A common use-case would be to process a big XML payload with iterative
    parser without constructing a whole XML tree in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this standard interface, an `HttpRequest` instance can be passed directly
    to an XML parser such as `ElementTree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: QueryDict objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an `HttpRequest` object, the `GET` and `POST` attributes are instances of
    `django.http.QueryDict`, a dictionary-like class customized to deal with multiple
    values for the same key. This is necessary because some HTML form elements, notably
    `<select multiple>`, pass multiple values for the same key.
  prefs: []
  type: TYPE_NORMAL
- en: The `QueryDict`s at `request.POST` and `request.GET` will be immutable when
    accessed in a normal request/response cycle. To get a mutable version you need
    to use `.copy()`.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`QueryDict` implements all the standard dictionary methods because it''s a
    subclass of dictionary, with the following exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.__init__()**'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiates a `QueryDict` object based on `query_string`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If `query_string` is not passed in, the resulting `QueryDict` will be empty
    (it will have no keys or values).
  prefs: []
  type: TYPE_NORMAL
- en: Most `QueryDict`s you encounter, and in particular those at `request.POST` and
    `request.GET`, will be immutable. If you are instantiating one yourself, you can
    make it mutable by passing `mutable=True` to its `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: Strings for setting both keys and values will be converted from `encoding` to
    Unicode. If encoding is not set, it defaults to `DEFAULT_CHARSET`.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.__getitem__(key)**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the value for the given key. If the key has more than one value, `__getitem__()`
    returns the last value. Raises `django.utils.datastructures.MultiValueDictKeyError`
    if the key does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.__setitem__(key, value)**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the given key to `[value]` (a Python list whose single element is `value`).
    Note that this, as other dictionary functions that have side effects, can only
    be called on a mutable `QueryDict` (such as one that was created via `copy()`).
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.__contains__(key)**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `True` if the given key is set. This lets you do, for example, `if "foo"
    in request.GET`.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.get(key, default)**'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the same logic as `__getitem__()` above, with a hook for returning a default
    value if the key doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.setdefault(key, default)**'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the standard dictionary `setdefault()` method, except it uses `__setitem__()`
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.update(other_dict)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Takes either a `QueryDict` or standard dictionary. Just like the standard dictionary
    `update()` method, except it appends to the current dictionary items rather than
    replacing them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**QueryDict.items()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the standard dictionary `items()` method, except this uses the same
    last-value logic as `__getitem__()`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**QueryDict.iteritems()**'
  prefs: []
  type: TYPE_NORMAL
- en: Just like the standard dictionary `iteritems()` method. Like `QueryDict.items()`
    this uses the same last-value logic as `QueryDict.__getitem__()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.iterlists()**'
  prefs: []
  type: TYPE_NORMAL
- en: Like `QueryDict.iteritems()` except it includes all values, as a list, for each
    member of the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.values()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the standard dictionary `values()` method, except this uses the same
    last-value logic as `__getitem__()`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**QueryDict.itervalues()**'
  prefs: []
  type: TYPE_NORMAL
- en: Just like `QueryDict.values()`, except an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, `QueryDict` has the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.copy()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a copy of the object, using `copy.deepcopy()` from the Python standard
    library. This copy will be mutable even if the original was not.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.getlist(key, default)**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the data with the requested key, as a Python list. Returns an empty
    list if the key doesn't exist and no default value was provided. It's guaranteed
    to return a list of some sort unless the default value was no list.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.setlist(key, list)**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the given key to `list_` (unlike `__setitem__()`).
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.appendlist(key, item)**'
  prefs: []
  type: TYPE_NORMAL
- en: Appends an item to the internal list associated with key.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.setlistdefault(key, default_list)**'
  prefs: []
  type: TYPE_NORMAL
- en: Just like `setdefault`, except it takes a list of values instead of a single
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryDict.lists()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `items()`, except it includes all values, as a list, for each member of
    the dictionary. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**QueryDict.pop(key)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a list of values for the given key and removes them from the dictionary.
    Raises `KeyError` if the key does not exist. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**QueryDict.popitem()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removes an arbitrary member of the dictionary (since there''s no concept of
    ordering), and returns a two value tuple containing the key and a list of all
    values for the key. Raises `KeyError` when called on an empty dictionary. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**QueryDict.dict()**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `dict` representation of `QueryDict`. For every (key, list) pair in
    `QueryDict`, `dict` will have (key, item), where item is one element of the list,
    using same logic as `QueryDict.__getitem__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**QueryDict.urlencode([safe])**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a string of the data in query-string format. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, urlencode can be passed characters which do not require encoding.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: HttpResponse objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to `HttpRequest` objects, which are created automatically by Django,
    `HttpResponse` objects are your responsibility. Each view you write is responsible
    for instantiating, populating and returning an `HttpResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: The `HttpResponse` class lives in the `django.http` module.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Passing strings**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical usage is to pass the contents of the page, as a string, to the `HttpResponse`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you want to add content incrementally, you can use `response` as a file-like
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**Passing iterators**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can pass `HttpResponse` an iterator rather than strings. `HttpResponse`
    will consume the iterator immediately, store its content as a string, and discard
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If you need the response to be streamed from the iterator to the client, you
    must use the `StreamingHttpResponse` class instead.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting header fields**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set or remove a header field in your response, treat it like a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike a dictionary, `del` doesn't raise `KeyError` if the header
    field doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: For setting the `Cache-Control` and `Vary` header fields, it is recommended
    to use the `patch_cache_control()` and `patch_vary_headers()` methods from `django.utils.cache`,
    since these fields can have multiple, comma-separated values. The patch methods
    ensure that other values, for example, added by a middleware, are not removed.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP header fields cannot contain newlines. An attempt to set a header field
    containing a newline character (CR or LF) will raise `BadHeaderError.`
  prefs: []
  type: TYPE_NORMAL
- en: '**Telling the browser to treat the response as a file attachment**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell the browser to treat the response as a file attachment, use the `content_type`
    argument and set the `Content-Disposition` header. For example, this is how you
    might return a Microsoft Excel spreadsheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing Django-specific about the `Content-Disposition` header, but
    it's easy to forget the syntax, so we've included it here.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HttpResponse.content**'
  prefs: []
  type: TYPE_NORMAL
- en: A bytestring representing the content, encoded from a Unicode object if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.charset**'
  prefs: []
  type: TYPE_NORMAL
- en: A string denoting the charset in which the response will be encoded. If not
    given at `HttpResponse` instantiation time, it will be extracted from `content_type`
    and if that is unsuccessful, the `DEFAULT_CHARSET` setting will be used.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.status_code**'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP status code for the response.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.reason_phrase**'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP reason phrase for the response.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.streaming**'
  prefs: []
  type: TYPE_NORMAL
- en: This is always `False`.
  prefs: []
  type: TYPE_NORMAL
- en: This attribute exists so middleware can treat streaming responses differently
    from regular responses.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.closed**'
  prefs: []
  type: TYPE_NORMAL
- en: '`True` if the response has been closed.'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**HttpResponse.__init__()**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiates an `HttpResponse` object with the given page content and content
    type. `content` should be an iterator or a string. If it''s an iterator, it should
    return strings, and those strings will be joined together to form the content
    of the response. If it is not an iterator or a string, it will be converted to
    a string when accessed. Has four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`content_type` is the MIME type optionally completed by a character set encoding
    and is used to fill the HTTP `Content-Type` header. If not specified, it is formed
    by the `DEFAULT_CONTENT_TYPE` and `DEFAULT_CHARSET` settings, by default: text/html;
    charset=utf-8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status` is the HTTP status code for the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reason` is the HTTP response phrase. If not provided, a default phrase will
    be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charset` is the charset in which the response will be encoded. If not given
    it will be extracted from `content_type`, and if that is unsuccessful, the `DEFAULT_CHARSET`
    setting will be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HttpResponse.__setitem__(header, value)**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the given header name to the given value. Both `header` and `value` should
    be strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.__delitem__(header)**'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the header with the given name. Fails silently if the header doesn't
    exist. Case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.__getitem__(header)**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the value for the given header name. Case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.has_header(header)**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `True` or `False` based on a case-insensitive check for a header with
    the given name.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.setdefault(header, value)**'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a header unless it has already been set.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.set_cookie()**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Sets a cookie. The parameters are the same as in the `Morsel` cookie object
    in the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: '`max_age` should be a number of seconds, or `None` (default) if the cookie
    should last only as long as the client''s browser session. If `expires` is not
    specified, it will be calculated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expires` should either be a string in the format `"Wdy, DD-Mon-YY HH:MM:SS
    GMT"` or a `datetime.datetime` object in UTC. If `expires` is a `datetime` object,
    the `max_age` will be calculated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `domain` if you want to set a cross-domain cookie. For example, `domain=".lawrence.com"`
    will set a cookie that is readable by the domains www.lawrence.com, blogs.lawrence.com
    and calendars.lawrence.com. Otherwise, a cookie will only be readable by the domain
    that set it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `httponly=True` if you want to prevent client-side JavaScript from having
    access to the cookie.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HTTPOnly` is a flag included in a Set-Cookie HTTP response header. It is not
    part of the RFC 2109 standard for cookies, and it isn''t honored consistently
    by all browsers. However, when it is honored, it can be a useful way to mitigate
    the risk of client side script accessing the protected cookie data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.set_signed_cookie()**'
  prefs: []
  type: TYPE_NORMAL
- en: Like `set_cookie()`, but cryptographic signing the cookie before setting it.
    Use in conjunction with `HttpRequest.get_signed_cookie()`. You can use the optional
    `salt` argument for added key strength, but you will need to remember to pass
    it to the corresponding `HttpRequest.get_signed_cookie()` call.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.delete_cookie()**'
  prefs: []
  type: TYPE_NORMAL
- en: Deletes the cookie with the given key. Fails silently if the key doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the way cookies work, `path` and `domain` should be the same values you
    used in `set_cookie()`-otherwise the cookie may not be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.write(content)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.flush()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.tell()**'
  prefs: []
  type: TYPE_NORMAL
- en: These methods implement a file-like interface with an `HttpResponse`. They work
    the same way as the corresponding Python file method.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.getvalue()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the value of `HttpResponse.content`. This method makes an `HttpResponse`
    instance a stream-like object.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.writable()**'
  prefs: []
  type: TYPE_NORMAL
- en: Always `True`. This method makes an `HttpResponse` instance a stream-like object.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponse.writelines(lines)**'
  prefs: []
  type: TYPE_NORMAL
- en: Writes a list of lines to the response. Line separators are not added. This
    method makes an `HttpResponse` instance a stream-like object.
  prefs: []
  type: TYPE_NORMAL
- en: HttpResponse subclasses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django includes a number of `HttpResponse` subclasses that handle different
    types of HTTP responses. Like `HttpResponse`, these subclasses live in `django.http`.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseRedirect**'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to the constructor is required-the path to redirect to. This
    can be a fully qualified URL (for example, [http://www.yahoo.com/search/](http://www.yahoo.com/search/))
    or an absolute path with no domain (for example, `/search/`). See `HttpResponse`
    for other optional constructor arguments. Note that this returns an HTTP status
    code 302.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponsePermanentRedirect**'
  prefs: []
  type: TYPE_NORMAL
- en: Like `HttpResponseRedirect`, but it returns a permanent redirect (HTTP status
    code 301) instead of a found redirect (status code 302).
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseNotModified**'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor doesn't take any arguments and no content should be added to
    this response. Use this to designate that a page hasn't been modified since the
    user's last request (status code 304).
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseBadRequest**'
  prefs: []
  type: TYPE_NORMAL
- en: Acts just like `HttpResponse` but uses a 400 status code.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseNotFound**'
  prefs: []
  type: TYPE_NORMAL
- en: Acts just like `HttpResponse` but uses a 404 status code.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseForbidden**'
  prefs: []
  type: TYPE_NORMAL
- en: Acts just like `HttpResponse` but uses a 403 status code.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseNotAllowed**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `HttpResponse`, but uses a 405 status code. The first argument to the
    constructor is required: a list of permitted methods (for example, `[''GET'',
    ''POST'']`).'
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseGone**'
  prefs: []
  type: TYPE_NORMAL
- en: Acts just like `HttpResponse` but uses a 410 status code.
  prefs: []
  type: TYPE_NORMAL
- en: '**HttpResponseServerError**'
  prefs: []
  type: TYPE_NORMAL
- en: Acts just like `HttpResponse` but uses a 500 status code.
  prefs: []
  type: TYPE_NORMAL
- en: If a custom subclass of `HttpResponse` implements a `render` method, Django
    will treat it as emulating a `SimpleTemplateResponse`, and the `render` method
    must itself return a valid response object.
  prefs: []
  type: TYPE_NORMAL
- en: JsonResponse Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An `HttpResponse` subclass that helps to create a JSON-encoded response. It
    inherits most behavior from its superclass with some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Its default `Content-Type` header is set to `application/json`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first parameter, `data`, should be a `dict` instance. If the `safe` parameter
    is set to `False` (see below) it can be any JSON-serializable object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `encoder`, which defaults to `django.core.serializers.json.DjangoJSONEncoder`,
    will be used to serialize the data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `safe` boolean parameter defaults to `True`. If it's set to `False`, any
    object can be passed for serialization (otherwise only `dict` instances are allowed).
    If `safe` is `True` and a non-`dict` object is passed as the first argument, a
    `TypeError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Typical usage could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Serializing non-dictionary objects**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to serialize objects other than `dict` you must set the `safe` parameter
    to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Without passing `safe=False`, a `TypeError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing the default JSON encoder**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to use a different JSON encoder class, you can pass the `encoder`
    parameter to the constructor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: StreamingHttpResponse objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `StreamingHttpResponse` class is used to stream a response from Django to
    the browser. You might want to do this if generating the response takes too long
    or uses too much memory. For instance, it's useful for generating large CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django is designed for short-lived requests. Streaming responses will tie a
    worker process for the entire duration of the response. This may result in poor
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, you should perform expensive tasks outside of the request-response
    cycle, rather than resorting to a streamed response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StreamingHttpResponse` is not a subclass of `HttpResponse`, because it
    features a slightly different API. However, it is almost identical, with the following
    notable differences:'
  prefs: []
  type: TYPE_NORMAL
- en: It should be given an iterator that yields strings as content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot access its content, except by iterating the response object itself.
    This should only occur when the response is returned to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no `content` attribute. Instead, it has a `streaming_content` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot use the file-like object `tell()` or `write()` methods. Doing so
    will raise an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamingHttpResponse` should only be used in situations where it is absolutely
    required that the whole content isn''t iterated before transferring the data to
    the client. Because the content can''t be accessed, many middlewares can''t function
    normally. For example, the `ETag` and `Content-Length` headers can''t be generated
    for streaming responses.'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`StreamingHttpResponse` has the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '* `*.streaming_content.` An iterator of strings representing the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* `*.status_code.` The HTTP status code for the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* `*.reason_phrase.` The HTTP reason phrase for the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* `*.streaming.` This is always `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FileResponse objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FileResponse` is a subclass of `StreamingHttpResponse` optimized for binary
    files. It uses `wsgi.file_wrapper` if provided by the wsgi server, otherwise it
    streams the file out in small chunks.'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileResponse` expects a file open in binary mode like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Error views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django comes with a few views by default for handling HTTP errors. To override
    these with your own custom views, see customizing-error-views.
  prefs: []
  type: TYPE_NORMAL
- en: The 404 (page not found) view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`defaults.page_not_found(request, template_name=''404.html'')`'
  prefs: []
  type: TYPE_NORMAL
- en: When you raise `Http404` from within a view, Django loads a special view devoted
    to handling 404 errors. By default, it's the view `django.views.defaults.page_not_found()`,
    which either produces a very simple Not Found message or loads and renders the
    template `404.html` if you created it in your root template directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default 404 view will pass one variable to the template: `request_path`,
    which is the URL that resulted in the error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three things to note about 404 views:'
  prefs: []
  type: TYPE_NORMAL
- en: The 404 view is also called if Django doesn't find a match after checking every
    regular expression in the URLconf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 404 view is passed a `RequestContext` and will have access to variables
    supplied by your template context processors (for example, `MEDIA_URL`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `DEBUG` is set to `True` (in your settings module), then your 404 view will
    never be used, and your URLconf will be displayed instead, with some debug information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 500 (server error) view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`defaults.server_error(request, template_name=''500.html'')`'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, Django executes special-case behavior in the case of runtime errors
    in view code. If a view results in an exception, Django will, by default, call
    the view `django.views.defaults.server_error`, which either produces a very simple
    Server Error message or loads and renders the template `500.html` if you created
    it in your root template directory.
  prefs: []
  type: TYPE_NORMAL
- en: The default 500 view passes no variables to the `500.html` template and is rendered
    with an empty `Context` to lessen the chance of additional errors.
  prefs: []
  type: TYPE_NORMAL
- en: If `DEBUG` is set to `True` (in your settings module), then your 500 view will
    never be used, and the traceback will be displayed instead, with some debug information.
  prefs: []
  type: TYPE_NORMAL
- en: The 403 (HTTP Forbidden) view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`defaults.permission_denied(request, template_name=''403.html'')`'
  prefs: []
  type: TYPE_NORMAL
- en: In the same vein as the 404 and 500 views, Django has a view to handle 403 Forbidden
    errors. If a view results in a 403 exception then Django will, by default, call
    the view `django.views.defaults.permission_denied`.
  prefs: []
  type: TYPE_NORMAL
- en: This view loads and renders the template `403.html` in your root template directory,
    or if this file does not exist, instead serves the text 403 Forbidden, as per
    RFC 2616 (the HTTP 1.1 Specification).
  prefs: []
  type: TYPE_NORMAL
- en: '`django.views.defaults.permission_denied` is triggered by a `PermissionDenied`
    exception. To deny access in a view you can use code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The 400 (bad request) view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`defaults.bad_request(request, template_name=''400.html'')`'
  prefs: []
  type: TYPE_NORMAL
- en: When a `SuspiciousOperation` is raised in Django, it may be handled by a component
    of Django (for example resetting the session data). If not specifically handled,
    Django will consider the current request a 'bad request' instead of a server error.
  prefs: []
  type: TYPE_NORMAL
- en: '`django.views.defaults.bad_request`, is otherwise very similar to the `server_error`
    view, but returns with the status code 400 indicating that the error condition
    was the result of a client operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`bad_request` views are also only used when `DEBUG` is `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing error views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default error views in Django should suffice for most web applications,
    but can easily be overridden if you need any custom behavior. Simply specify the
    handlers as seen below in your URLconf (setting them anywhere else will have no
    effect).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `page_not_found()` view is overridden by `handler404`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `server_error()` view is overridden by `handler500`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `permission_denied()` view is overridden by `handler403`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bad_request()` view is overridden by `handler400`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
