- en: Input Devices Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Input devices are devices by which one can interact with the system. Such devices
    are buttons, keyboards, touchscreens, mouse, and so on. They work by sending events,
    caught and broadcasted over the system by the input core. This chapter will explain
    each structure used by input core to handle input devices. That being said, we
    will see how one can manage events from the user space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Input core data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and registering input devices, and well as polled devices family
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating and reporting events to the input core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input device from user space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a driver example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input device structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, the main file to include in order to interface with the input
    subsystem is `linux/input.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever type of input device it is, whatever type of event it sends, an input
    device is represented in the kernel as an instance of `struct input_dev` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The meaning of the fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` represents the name of the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phys` is the physical path to the device in the system hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`evbit` is a bitmap of types of events supported by the device. Some types
    of areas are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EV_KEY` for devices supporting sending key events (keyboards, button, and
    so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EV_REL` for device supporting sending relative positions (mouse, digitizers,
    and so on)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EV_ABS` for device supporting sending absolute positions(joystick)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of events is available in the kernel source in the `include/linux/input-event-codes.h`
    file. One uses the `set_bit()` macro in order to set the appropriate bit depending
    on our input device capabilities. Of course a device can support more than one
    type of event. For example, a mouse will set both `EV_KEY` and `EV_REL` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`keybit` is for an `EV_KEY` type enabled device, a bitmap of keys/buttons that
    this device exposes. For example, `BTN_0` , `KEY_A` , `KEY_B` , and so on. The
    complete list of keys/buttons is in the `include/linux/input-event-codes.h` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`relbit` is for an `EV_REL` type enabled device, a bitmap of relative axes
    for the device. For example, `REL_X` , `REL_Y` , `REL_Z` , `REL_RX` , and so on.
    Have a look at `include/linux/input-event-codes.h` for the complete list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`absbit` is for an `EV_ABS` type enabled device, bitmap of absolute axes for
    the device. For example, `ABS_Y` , `ABS_X` , and so on. Have a look at the same
    previous file for the complete list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mscbit` is for `EV_MSC` type enabled device, a bitmap of miscellaneous events
    supported by the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat_key` stores the key code of the last key pressed; used to implement
    software auto repeat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rep` , current values for auto repeat parameters (delay, rate).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`absinfo` is an array of `&struct input_absinfo` elements holding information
    about absolute axes (current value, min, max, flat, fuzz, resolution). You should
    use the `input_set_abs_params()` function in order to set those values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`min` and `max` specify lower and upper bound values. `fuzz` indicates the
    expected noise on the specified channel of the specified input device. The following
    is an example in which we set each channel''s bound only:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`key` reflects the current state of the device''s keys/buttons.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open` is a method called when the very first user calls `input_open_device()`
    . Use this method to prepare the device, such as interrupt request, polling thread
    start, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close` is called when the very last user calls `input_close_device()` . Here
    you can stop polling (which consumes lot of resource).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users` stores the number of users (input handlers) that opened this device.
    It is used by `input_open_device()` and `input_close_device()` to make sure that
    `dev->open()` is only called when the first user opens the device and `dev->close()`
    is called when the very last user closes the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev` is the struct device associated with this device (for device model).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_vals` is the number of values queued in the current frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_vals` is the maximum number of values queued in a frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Vals` is the array of values queued in the current frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devres_managed` indicates that devices are managed with `devres` framework
    and needs not be explicitly unregistered or freed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating and registering an input device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to the registering and sending the event with an input device, it should
    be allocated with the `input_allocate_device()` function. In order to free the
    previously allocated memory for a non-registered input device, `input_free_device()`
    function should be used. If the device has already been registered, `input_unregister_device()`
    should be used instead. Like every function where memory allocation is needed,
    we can use a resource-managed version of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Device allocation may sleep and therefore must not be called in the atomic context
    or with a spinlock held.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an excerpt of the `probe` function of an input device siting
    on the I2C bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Polled input device sub-class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polled input devices is a special type of input device, which relies on polling
    to sense device state changes, whereas the generic input device type relies on
    IRQ to sense change and send events to the input core.
  prefs: []
  type: TYPE_NORMAL
- en: 'A polled input device is described in the kernel as an instance of `struct
    input_polled_dev` structure, which is a wrapper around the generic `struct input_dev`
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the meanings of elements in this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private` is the driver''s private data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`open` is an optional method that prepares a device for polling (enabled the
    device and maybe flushes device state).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close` is an optional method that is called when the device is no longer being
    polled. It is used to put devices into the low power mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll` is a mandatory method called whenever the device needs to be polled.
    It is called at the frequency of `poll_interval` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll_interval` is the frequency at which the `poll()` method should be called.
    Defaults to 500 msec unless overridden when registering the device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll_interval_max` specifies the upper bound for the poll interval. Defaults
    to the initial value of `poll_interval` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poll_interval_min` specifies the lower bound for the poll interval. Defaults
    to 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`input` is the input device around which the polled device is built. It must
    be properly initialized by the driver (ID, name, bits). Polled input device just
    provides an interface to use polling instead of IRQ, to sense device state change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allocating/freeing the `struct input_polled_dev` structure is done using `input_allocate_polled_device()`
    and `input_free_polled_device()` . You should take care of initializing mandatory
    fields of the `struct input_dev` embedded in it. Polling interval should be set
    too, otherwise, it defaults to 500 msec. One can use resource manage version too.
    Both prototypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For resource-managed devices, the field `input_dev->devres_managed` will be
    set to true by the input core.
  prefs: []
  type: TYPE_NORMAL
- en: 'After allocation and proper fields initialization, the polled input device
    can be registered using `input_register_polled_device()` , which returns 0 on
    success. The reverse operation (unregister) is done with the `input_unregister_polled_device()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical example of the `probe()` function for such a device looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is how our `struct my_struct` structure looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And following is how the `open` function looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `open` method is used to prepare resources needed by the device. We do not
    really need this method for this example.
  prefs: []
  type: TYPE_NORMAL
- en: Generating and reporting an input event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Device allocation and registration are essential, but they are not the main
    goal of an input device driver, which is designed to report even to the input
    core. Depending on the type of event your device can support, the kernel provides
    appropriate APIs to report them to the core.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an `EV_XXX` capable device, the corresponding report function would be
    `input_report_xxx()` . The following table shows a mapping between the most important
    event types and their report functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Event type** | **Report function** | **Code example** |'
  prefs: []
  type: TYPE_TB
- en: '| `EV_KEY` | `input_report_key()` | `input_report_key(poll_dev->input, BTN_0,
    gpiod_get_value(ms-> reset_btn_desc) & 1)` ; |'
  prefs: []
  type: TYPE_TB
- en: '| `EV_REL` | `input_report_rel()` | `input_report_rel(nunchuk->input, REL_X,
    (nunchuk->report.joy_x - 128)/10)` ; |'
  prefs: []
  type: TYPE_TB
- en: '| `EV_ABS` | `input_report_abs()` | `input_report_abs(bma150->input, ABS_X,
    x_value)` ;`input_report_abs(bma150->input, ABS_Y, y_value)` ;`input_report_abs(bma150->input,
    ABS_Z, z_value)` ; |'
  prefs: []
  type: TYPE_TB
- en: 'Their respective prototypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of available report functions can be found in `include/linux/input.h`
    in the kernel source file. They all have the same skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev` is the input device responsible for the event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code` represents the event code, for example,`REL_X` or `KEY_BACKSPACE` .
    The complete list is in `include/linux/input-event-codes.h` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is the value the event carries. For `EV_REL` event type, it carries
    the relative change. For a `EV_ABS` (joysticks and so on.) event type, it contains
    an absolute new value. For `EV_KEY` event type, it should be set to `0` for key
    release, `1` for key press, and `2` for auto repeat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After all changes have been reported, the driver should call `input_sync()`
    on the input device, in order to indicate that this event is complete. The input
    subsystem will collect these into a single packet and send it through `/dev/input/event<X>`
    , which is the character device representing our `struct input_dev` on the system,
    and where `<X>` is the interface number assigned to the driver by the input core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see an example, which is an excerpt of the `bma150` digital acceleration
    sensors drivers in `drivers/input/misc/bma150.c` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding sample, `input_sync()` tells the core to consider the three
    reports as the same event. It makes sense since the position has three axes (X,
    Y, Z) and we do not want X, Y, or Z to be reported separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to report the event is inside the `poll` function for a polled
    device, or inside the IRQ routine (threaded part or not) for an IRQ enabled device.
    If you perform some operations that may sleep, you should process your report
    inside the threaded part of the IRQ handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: User space interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every registered input device is represented by a `/dev/input/event<X>` char
    device, from which we can read the event from the user space. An application reading
    this file will receive event packets in the `struct input_event` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see the meaning of each element in the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`time` is the timestamp, it returns the time at which the event happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` is the event type. For example, `EV_KEY` for a key press or release,
    `EV_REL` for relative moment, or `EV_ABS` for an absolute one. More types are
    defined in `include/linux/input-event-codes.h` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code` is the event code, for example: `REL_X` or `KEY_BACKSPACE` , again a
    complete list is in `include/linux/input-event-codes.h` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is the value that the event carries. For `EV_REL` event type, it carries
    the relative change. For an `EV_ABS` (joysticks and so on) event type, it contains
    the absolute new value. For `EV_KEY` event type, it should be set to `0` for key
    release, `1` for keypress and `2` for auto repeat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A user space application can use blocking and non-blocking reads, but also
    `poll()` or `select()` system calls in order to get notified of events after opening
    this device. Following is an example with `select()` system call, with the complete
    source code provided in the book source repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have described structures used when writing drivers for input devices,
    and how they can be managed from the user space.
  prefs: []
  type: TYPE_NORMAL
- en: Allocate a new input device, according to its type, polled or not, using `input_allocate_polled_device()`
    or `input_allocate_device()` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the mandatory fields or not (if necessary):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify type of event the device supports by using `set_bit()` helper macro
    on the `input_dev.evbit` field
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on event type, `EV_REL` , `EV_ABS` , `EV_KEY` or other, indicate code
    this device can report using either `input_dev.relbit` , `input_dev.absbit` ,
    `input_dev.keybit` , or other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify `input_dev.dev` in order to set up a proper device tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill `abs_` info if necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For polled device, indicate at which interval the `poll()` function should
    be called:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write your `open()` function if necessary, in which you should prepare and set
    up resource used by the device. This function is called only once. In this function,
    setup GPIO, request interrupt if needed, initialize the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write your `close()` function, in which you will release and deallocate what
    you have done in the `open()` function. For example, free GPIO, IRQ, put device
    to power saving mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass either your `open()` or `close()` function (or both) to `input_dev.open`
    and `input_dev.close` fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register your device using `input_register_polled_device()` if polled, or `input_register_device()`
    if not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your IRQ function (threaded or not) or in your `poll()` function, gather
    and report events depending on their types, using either `input_report_key()`
    , `input_report_rel()` , `input_report_abs()` or other, and then, call `input_sync()`
    on the input device to indicate the end of frame (the report is complete).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The usual way is to use classic input devices if no IRQ is provided, or else
    fall back to polled device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To see how to manage such devices from the user space, please refer to the example
    provided within the source of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Driver examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One can summarize thing in the two following drivers. The first one is a polled
    input device, based on a GPIO non-mapped to IRQ. The polled input core will poll
    the GPIO to sense any change. This driver is configured to send 0 key code. Each
    GPIO state corresponds either to key press or key release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This second driver sends events to the input core according to the IRQ on which
    the button''s GPIO is mapped. When using IRQ to sense key press or release, it
    is a good practice to trig the interrupt on edge change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For both examples, when a device matches the module, a node will be created
    in `/dev/input` directory. The node corresponds to `event0` in our example. One
    can use `udevadm` tool in order to display information about the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The tool that actually allows us to print the event key to the screen is `evtest`
    , given the path of the input device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the second module is based on IRQ, one can easily check if the IRQ request
    succeeded, and how many time it has been fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, one can successively push/release the button, and check whether the
    GPIO''s state changed or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described the whole input framework, and highlighted the difference
    between polled and interrupt driven input devices. By the end of this chapter,
    you have the necessary knowledge to write a driver for any input driver, whatever
    its type, and whatever input event it supports. The user space interface was discussed
    too, with a sample provided. The next chapter discusses another important framework,
    the RTC, which is the key element of time management in PC as well as embedded
    devices.
  prefs: []
  type: TYPE_NORMAL
