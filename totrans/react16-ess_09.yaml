- en: Chapter 9. Testing Your React Application with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you have created a number of React components. Some of them are quite
    straightforward, but some are sophisticated enough. Having built both, you might
    have gained a certain confidence, which makes you believe that no matter how complex
    the user interface is, you can build it with React, without any major pitfalls.
    This is a good confidence to have. After all, this is why we're investing time
    in learning React. However, there is a trap that many confident React developers
    fall into—the act of not writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: What is a **unit test**? As the name suggests, it's a test for a single unit
    of your application. A single unit in your application is often a function, which
    suggests that writing unit tests means writing tests for your functions.
  prefs: []
  type: TYPE_NORMAL
- en: Why write unit tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering why you should write unit tests. Let me tell you a story
    from my personal experience. I released a website that I built recently. A few
    days later, my colleague who was using the website sent me an email with two files
    that the website kept rejecting. I closely examined the files, and the requirement
    of having the IDs matched was met in both of them. However, the files were still
    rejected and the error message said that the IDs didn't match. Can you guess what
    the problem was?
  prefs: []
  type: TYPE_NORMAL
- en: I wrote a function that checked whether the IDs from the two files matched.
    The function checked both the value and the type of the IDs, so if the values
    were the same and the types were different, it would return no match; it turned
    out that this was exactly the case with the files from my colleague.
  prefs: []
  type: TYPE_NORMAL
- en: The important question is, how can I prevent this from happening? The answer
    is a number of unit tests for my function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating test suites, specs, and expectations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does one write a test for JavaScript functions? You need a testing framework,
    and luckily, Facebook has built its own unit test framework for JavaScript, called
    **Jest**. It is inspired by **Jasmine**—another well-known JavaScript test framework.
    Those who are familiar with Jasmine will find Jest's approach to testing very
    similar. However, I'll make no assumptions about your prior experience with testing
    frameworks and discuss the basics first.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental idea of unit testing is that you test only one piece of functionality
    in your application that usually is implemented by one function. You test it in
    isolation, which means that all the other parts of your application that the function
    depends on are not used by your tests. Instead, they are imitated by your tests.
    To imitate a JavaScript object is to create a fake one that simulates the behavior
    of the real object. In unit testing, the fake object is called **mock** and the
    process of creating it is called **mocking**.
  prefs: []
  type: TYPE_NORMAL
- en: Jest automatically mocks the dependencies when you're running your tests. It
    automatically finds tests to be executed in your repository. Let's take a look
    at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the `~/snapterest/source/utils/` directory. Then, create a new
    `TweetUtils.js` file in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `TweetUtils.js` file is a module with the `getListOfTweetIds()` utility
    function for our application to use. Given an object with tweets, `getListOfTweetIds()`
    returns an array of tweet IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's write our first unit test with Jest. We'll test our `getListOfTweetIds()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `TweetUtils.test.js` file inside `~/snapterest/source/utils/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we require the `TweetUtils` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we call a global `describe()` Jest function. It's important to understand
    the concept behind it. In our `TweetUtils.test.js` file, we're not just creating
    a single test, instead we're creating a suite of tests. A suite is a collection
    of tests that collectively tests a bigger unit of functionality. For example,
    a suite can have multiple tests, which tests all the individual parts of a larger
    module. In our example, we have a `TweetUtils` module with potentially a number
    of utility functions. In this situation, we would create a suite for the `TweetUtils`
    module, and then create tests for each individual utility function, such as `getListOfTweetIds()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `describe()` function defines a suite and takes these two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Suite name**: This is the title that describes what is being tested by this
    test suite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suite implementation**: This is the function that implements this suite'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, the suite is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'How do you create an individual test? In Jest, you create individual tests
    by calling another global Jest function—`test()`. Just like `describe()`, the
    `test()` function takes two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test name**: This is the title that describes what is being tested by this
    test, for example: `''getListOfTweetIds returns an array of tweet ids''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test implementation**: This is the function that implements this test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, the test is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at the implementation of our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We test whether the `getListOfTweetIds()` method of our `TweetUtils` module
    returns an array of tweet IDs, when given an object with tweet objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a mock object that simulates the real tweets object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only requirement for this mock object is to have tweet IDs as object keys.
    The values are not important, so we choose empty objects. The key names are not
    important as well, so we choose to name them `tweet1`, `tweet2`, and `tweet3`.
    This mock object doesn't fully simulate the real tweet object—its sole purpose
    is to simulate the fact that its keys are tweet IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create an expected list of tweet IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We know what tweet IDs to expect because we've mocked the tweets object with
    the same IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to extract the actual tweet IDs from our mocked tweets object.
    For this, we use the `getListOfTweetIds()` method that takes the tweets object
    and returns an array of tweet IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We pass the `tweetsMock` object to that method and store the results in the
    `actualListOfTweetIds` constant. The reason it's named `actualListOfTweetIds`
    is that this list of tweet IDs is produced by the actual `getListOfTweetIds()`
    function that we're testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step will introduce us to a new important concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's think about the process of testing. We need to take an actual value produced
    by the method that we're testing, that is, `getListOfTweetIds()`, and match it
    to the expected value that we know in advance. The result of that match will determine
    whether our test has passed or failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why we can guess what `getListOfTweetIds()` will return in advance
    is because we''ve prepared the input for it; this is our mock object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can expect the following output by calling `TweetUtils.getListOfTweetIds(tweetsMock)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because something can go wrong inside `getListOfTweetIds()`, we cannot guarantee
    this result; we can only *expect* it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why we need to create an expectation. In Jest, an **expectation** is
    built using the `expect()` function, which takes an actual value; for example,
    the `actualListOfTweetIds` object: `expect(actualListOfTweetIds)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we chain it with a **matcher** function that compares the actual value
    with the expected value and tells Jest whether the expectation was met or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we use the `toEqual()` matcher function to compare the two arrays.
    You can find a list of all the built-in matcher functions in Jest at [https://facebook.github.io/jest/docs/expect.html](https://facebook.github.io/jest/docs/expect.html)
  prefs: []
  type: TYPE_NORMAL
- en: This is how you write a test. A test contains one or more expectations. Each
    expectation tests the state of your code. A test can be either a **passing test**
    or a **failing test**. A test is a passing test only when all the expectations
    are met; otherwise, it's a failing test.
  prefs: []
  type: TYPE_NORMAL
- en: Well done, you've written your first test suite with a single test that has
    one expectation! How can you run it?
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s install the **Jest command-line interface** (**Jest CLI**) module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command installs and adds the Jest module as a development dependency to
    our `~/snapterest/package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Installing Powerful Tools for Your Project"),
    *Installing Powerful Tools for Your Project*, we installed and discussed Babel.
    We use Babel to transpile our newer JavaScript syntax into the older JavaScript
    syntax, as well as compile JSX syntax into plain JavaScript syntax. In our tests,
    we''ll be testing React components written in JSX syntax, but Jest doesn''t understand
    JSX syntax out of the box. We need to tell Jest to automatically compile our tests
    with Babel. To do this, we need to install the `babel-jest` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to configure Babel. To do this, create the following `.babelrc`
    file in the `~/snapterest/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s edit the `package.json` file. We''ll replace the existing `"scripts"`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the preceding object with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to run our test suite. Navigate to the `~/snapterest/` directory,
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following message in your Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This output message tells you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PASS`: Your test has passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source/utils/TweetUtils.test.js`: Jest ran tests from this file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's all it takes to write and test a tiny unit test. Now, let's create another
    one!
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple tests and expectations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we''ll create and test the collection utility module. Create the
    `CollectionUtils.js` file in the `~/snapterest/source/utils/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CollectionUtils` module has two functions: `getNumberOfTweetsInCollection()`
    and `isEmptyCollection()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s discuss `getNumberOfTweetsInCollection()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function calls the `getListOfTweetIds()` method from the
    `TweetUtils` module and passes the `collection` object as a parameter. The result
    returned by `getListOfTweetIds()` is stored in the `listOfCollectionTweetIds`
    constant, and since it's an array, `getNumberOfTweetsInCollection()` returns a
    `length` property of that array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `isEmptyCollection()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method reuses the `getNumberOfTweetsInCollection()` method that we just
    discussed. It checks whether the result returned by a call to `getNumberOfTweetsInCollection()`
    is equal to zero. Then, it returns the result of that check, which is either `true`
    or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we export both methods from this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We just created our `CollectionUtils` module. Our next task is to test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `~/snapterest/source/utils/` directory, create the following `CollectionUtils.test.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First we define our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We give our test suite the name of the module that we're testing—`CollectionUtils`.
    Now let's take a look at the implementation of this test suite. Instead of immediately
    defining test specs like we did in our previous test suite, we're creating the
    `collectionTweetsMock` object. So, are we allowed to do this? Absolutely. The
    test suite implementation function is just another JavaScript function, where
    we can do some work before we define our test specs.
  prefs: []
  type: TYPE_NORMAL
- en: This test suite will implement more than one test. All of our tests will use
    the `collectionTweetsMock` object, so it makes sense to define it outside the
    specs' scope and reuse it inside the specs. As you might have already guessed,
    the `collectionTweetsMock` object imitates a collection of tweets.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's implement the individual test specs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first spec tests whether the `CollectionUtils` module returns a number
    of tweets in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We first get the actual number of tweets in our mock collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For this, we call the `getNumberOfTweetsInCollection()` method and pass the
    `collectionTweetsMock` object to it. Then, we define the number of expected tweets
    in our mock collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we call the `expect()` global function to create an expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We use the `toBe()` matcher function to match the actual value and the expected
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now run the `npm test` command, you will see that both the test suites
    pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember that for a test suite to pass, it must have only the passing specs.
    For a spec to pass, it must have all its expectations to be met. This is the case
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: How about running a little evil experiment?
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `~/snapterest/source/utils/CollectionUtils.js` file, and inside the
    `getNumberOfTweetsInCollection()` function, go to the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What this tiny update will do is return an incorrect number of tweets in any
    given collection. Now run `npm test` once more. You should see that all your specs
    in `CollectionUtils.test.js` have failed. Here is the one we''re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We haven't seen a failing test before, so let's take a closer look at what it's
    trying to tell us.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it gives us the bad news that the `CollectionUtils.test.js` test has
    failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it tells us in a human-friendly manner which test has failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, what went wrong—the unexpected test result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Jest prints a stack trace that should give us enough technical details
    to quickly identify which part of our code has produced the unexpected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright! Enough of failing our tests on purpose. Let''s revert our `~/snapterest/source/utils/CollectionUtils.js`
    file to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A test suite in Jest can have many specs that test different methods from a
    single module. Our `CollectionUtils` module has two methods. Now let's discuss
    the second one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next spec in `CollectionUtils.test.js` checks whether the collection is
    not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, we call the `isEmptyCollection()` method and pass the `collectionTweetsMock`
    object to it. We store the result in the `actualIsEmptyCollectionValue` constant.
    Notice how we're reusing the same `collectionTweetsMock` object, as in our previous
    spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create not one but three expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You might have already guessed what we're expecting from our `actualIsEmptyCollectionValue`
    constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we expect our collection to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This means that the `isEmptyCollection()` function must return something other
    than `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we expect its value to be `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, we used the `toEqual()` matcher function to compare the arrays. The
    `toEqual()` method does a deep comparison, which is perfect for comparing arrays,
    but it is an overkill for primitive values such as `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we expect `actualIsEmptyCollectionValue` not to be `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The next comparison is inversed by `.not`. It matches the expectation with the
    inverse of `toBe(true)` with `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that `toBe(false)` and `not.toBe(true)` produce the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Only when all the three expectations are met, does this spec pass.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've tested the utility modules, but how do you test the React components
    with Jest?
  prefs: []
  type: TYPE_NORMAL
- en: We'll find out next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's step back from writing code for a minute and talk about what it means
    to test the user interface. What exactly are we testing? We're testing the fact
    that our user interface renders as expected. In other words, if we tell React
    to render a button, we expect it to render a button—not more, not less.
  prefs: []
  type: TYPE_NORMAL
- en: Now how can we check that this is the case? One way of doing this is to write
    a React component, bundle our application, run it in a web browser, and see with
    our own eyes that it displays what we want it to display. This is manual testing
    and we do it at least once. But it is time consuming and unreliable in the long
    term.
  prefs: []
  type: TYPE_NORMAL
- en: How can we automate this process? Jest can do most of the work for us, but Jest
    doesn't have it's own eyes, so it will need to borrow our eyes at least once for
    each component. If Jest "can't see" the result of rendering a React component,
    then how can it even test a React component?
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Creating Your First React Element"), *Creating
    Your First React Element*, we discussed React elements. They are plain JavaScript
    objects that describe what we want to see on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this HTML markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be represented by the following plain JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Having plain and simple JavaScript objects that represent the output that our
    components produce when we render them allows us to describe certain expectations
    about our components and their behavior. Let's see this in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first React component that we''ll test will be our `Header` component.
    Create the `Header.test.js` file in the `~/snapterest/source/components/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: By now, you can recognize the structure of our test files. First, we define
    our test suite, and we give it the name `Header`. Our test suite has two test
    specs named `renders default header text` and `renders provided header text`.
    As their names suggest, they test that our `Header` component can render both
    the default and provided text. Let's take a closer look at this test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we import the React module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we import the `react-test-renderer` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A React renderer renders React components to pure JavaScript objects. It doesn''t
    require the DOM, so we can use it to render React components outside of a web
    browser. It works great with Jest. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in order to test our `Header` component, we need to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We're also importing `DEFAULT_HEADER_TEXT` from our `Header` module. We do this
    because we don't want to hardcode the actual string value that is the default
    header text. It would add extra work for maintaining this value. Instead, since
    out `Header` component knows what this value is, we're going to import and reuse
    it in our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our first test named `renders default header text`. Our
    first task in this test is to render the `Header` component to the plain JavaScript
    object. The `react-test-renderer` module has the `create` method that does exactly
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the `<Header/>` element to the `create()` function as an argument and
    we get back a JavaScript object that represents an instance of our `Header` component.
    It''s not a simple representation of our component yet, so our next step is to
    convert that object into a simple tree representation of our component using the
    `toJSON` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, `tree` is a JavaScript object as well, but it''s also a simple representation
    of our `Header` component that we can easily read and understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'I recommend that you log both the `component` and `tree` objects and see how
    different they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You'll quickly see that the `component` object is for React's internal use—it's
    hard to read and tell what it represents. On the other hand, the `tree` object
    is very easy to read and it's clear what it represents.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, our approach for testing React components so far is to convert
    `<Header/>` to `{ type: ''h2'', props: {}, children: [ ''Default header'' ] }`.
    Now that we have a simple JavaScript object that represents our component, we
    can check that this object has the expected values. If it does, we can conclude
    that our component will render in a web browser as expected. If it doesn''t, then
    we might have introduced a bug.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we render our `Header` component without any properties, `<Header/>`,
    we expect it to render a default text: `''Default header''`. To check that this
    is indeed the case, we need to access the `children` property from a tree representation
    of our `Header` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We expect our `Header` component to only have one child, so the text element
    will be the first child.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to write our expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here we expect `firstChild` to have the same value as `DEFAULT_HEADER_TEXT`.
    Behind the scenes, `toBe` matcher uses `===` to do the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: This is it for our first test!
  prefs: []
  type: TYPE_NORMAL
- en: 'In our second test named `''renders provided header text''`, we''re testing
    that our `Header` component has the custom test that we provide via the `text`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you understand the core idea behind testing React components:'
  prefs: []
  type: TYPE_NORMAL
- en: Render your component to the JavaScript object representation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find some value on that object and check that this value is what you expect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, this is quite straightforward when your components are simple.
    But what if you need to test components that are composed of other components
    and so on? Imagine how complex the JavaScript object that represents that component
    will be. It will have many properties that are deeply nested. You might end up
    writing and maintaining a lot of code for accessing and comparing deeply nested
    values. This is when writing unit tests becomes too expensive and some developers
    might choose to give up on testing their components altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily there're two solutions available for us.
  prefs: []
  type: TYPE_NORMAL
- en: Here's one of them. Remember, when traversing and mutating DOM directly was
    too much work, so jQuery library was created to simplify that process? Well, for
    React components we have **Enzyme**—a JavaScript testing utility library from
    AirBnB that simplifies the process of traversing and manipulating the output produced
    from rendering React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enzyme is a separate library from Jest. Let''s install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To use Enzyme together with Jest, we need to install three modules. Remember
    that Jest runs our tests, whereas Enzyme will help us to write our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s rewrite our tests for our `Header` component using Enzyme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the `shallow` function from the `enzyme` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside of our test, we call the `shallow` function and pass our `Header`
    component as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: What we get in return is an object that wraps the result of rendering our `Header`
    component. This object is created by Enzyme's `ShallowWrapper` class and has some
    very useful methods for us to use. We'll call it `wrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this `wrapper` object available to us, we're ready to write
    our expectations. Notice that unlike `react-test-renderer`, with Enzyme we don't
    need to convert our `wrapper` object into a simplified representation of our component.
    This is because we're not going to traverse our `wrapper` object directly—it's
    not a simple object that is easy for us to read; try to log that object and see
    it for yourself. Instead, we'll use methods provided by Enzyme's `ShallowWrapper`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our first expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're calling the `find` method on our `wrapper` object. This
    is the power of Enzyme. Instead of traversing our React component output object
    directly and finding the nested elements, we can simply call the `find` method
    and tell it what we're looking for. In this example, we're telling Enzyme to find
    all `h2` elements inside of our `wrapper` object, and since it wraps the output
    of our `Header` component, we expect the `wrapper` object to have exactly one
    `h2` element. We use Jest's `toHaveLength` matcher to check this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our second expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can guess, we're checking that our wrapper object contains `DEFAULT_HEADER_TEXT`.
    This check allows us to conclude that our `Header` component renders the default
    text when we don't provide any custom text. We're using Enzyme's `contains` method
    that allows us to conveniently check if our component contains any node. In this
    case, we're checking for a text node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enzyme''s API provides many more methods for us to conveniently inspect our
    component''s output. I recommend that you familiarize yourself with those methods
    by reading the official documentation: [http://airbnb.io/enzyme/docs/api/shallow.html](http://airbnb.io/enzyme/docs/api/shallow.html)'
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how to test the behavior of your React component.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we'll discuss next!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Button.test.js` file in the `~/snapterest/source/components/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Button.test.js` file will test our `Button` component, and specifically,
    check whether it triggers the click event handler function when you click on it.
    Without further ado, let''s focus on the `''calls click handler function on click''`
    spec implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In this spec, we''re testing that our `Button` component calls a function that
    we provide via the `handleClick` property. Here''s our testing strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a mock function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the `Button` component with our mock function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `button` element in a wrapper object created by Enzyme as a result
    of rendering our `Button` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simulate a click event on that `button` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether our mock function was called exactly once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a plan, let''s implement it. Let''s create a mock function
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `jest.fn()` function call returns the newly generated Jest mock function;
    we name it `handleClickMock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we get the output of our `Button` component by calling Enzyme''s `shallow`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We pass our `handleClickMock` function as a property to our `Button` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we find the `button` element and we simulate a click event on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our button element is expected to call its `onClick` event handler,
    which, in this case is our `handleClickMock` function. This mock function should
    record the fact that it was called one time, or at least this is how we expect
    our `Button` component to behave. Let''s create this expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we check how many times our `handleClickMock` function was called? Our
    `handleClickMock` function has a special mock property that we can inspect to
    find out how many times `handleClickMock` was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In turn, our `mock` object has a `calls` object that knows everything about
    every call made to our `handleClickMock` function. The `calls` object is an array
    and in our case we expect its `length` property to equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with Enzyme it's easier to write expectations. Our tests require
    less work to write them in the first place and maintain them for the long term.
    This is good because now we have more motivation to write more tests.
  prefs: []
  type: TYPE_NORMAL
- en: But can we make writing tests with Jest even easier?
  prefs: []
  type: TYPE_NORMAL
- en: Turns out that we can.
  prefs: []
  type: TYPE_NORMAL
- en: Right now we render a React component into an object representation, and then
    inspect that object either with Jest only or with the help of Enzyme. This inspection
    requires us, as developers, to write extra code for our tests to work. How can
    we avoid that?
  prefs: []
  type: TYPE_NORMAL
- en: We can render a React component into a text string that we could easily read
    and understand. Then we can store that text representation in our code base. Later,
    when we run our tests again, we can simply create a new text representation and
    compare it with the one that we're storing. If they're different, then this could
    mean that either we updated our component intentionally and now we need to update
    our text representation as well, or we introduced a bug to our component so that
    now it produces an unexpected text representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This idea is called **snapshot testing** in Jest. Let''s rewrite tests for
    our `Header` component using snapshot testing. Replace the existing code in your
    `Header.test.js` file with this new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're not using Enzyme in this case, which should make sense
    to us, because we don't want to inspect anything anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we''re using the `react-test-renderer` module again to render
    and convert our components into a simple JavaScript object that we named `tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The key line of code that puts snapshot testing in action is this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We're simply telling Jest that we expect our tree object to match to an existing
    snapshot. Wait a minute, but we don't have an existing snapshot. Good observation!
    So what happens in this case? Jest won't find an existing snapshot for this test,
    and instead it will create a very first snapshot for this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our test command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'All tests should pass and you should see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here Jest is telling us that it created two snapshots—one for each test found
    in our `Header.test.js` test suite. Where did Jest store these two snapshots?
    If you check your `~/snapterest/source/components/` directory, you will find a
    new folder there: `__snapshots__`. Inside it, you''ll find the `Header.test.js.snap`
    file. Open this file and look at its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: What you can see in this file is the text representation of the output that
    our `Header` component produces when we render it with Jest. It's very easy for
    us to read this file and confirm that this is what we expect our `Header` component
    to render. Now our `Header` component has its own snapshots. It's important to
    treat and store these snapshots as part of your source code.
  prefs: []
  type: TYPE_NORMAL
- en: You should commit them to your Git repository if you have one and you should
    be aware of any changes that you're making to them.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've seen three different ways of writing React tests, you need to
    make your own choice of how to test your React components. Now I would recommend
    that you use snapshot testing and Enzyme.
  prefs: []
  type: TYPE_NORMAL
- en: Great, we've written four test suites. Now it's time to run all our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `~/snapterest/` and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'All your test suites should `PASS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Log messages, such as these, will help you sleep well at night and go on holidays,
    without the need to constantly check your work emails.
  prefs: []
  type: TYPE_NORMAL
- en: Well done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how to create the React components and unit test them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned the essentials of Jest—the unit testing framework
    from Facebook that works well with React. You got introduced to the Enzyme library
    and learned how it simplifies writing unit tests for React components. We discussed
    the test suites, specs, expectations, and matchers. We created mocks and simulated
    click events.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn the essentials of the Flux architecture and
    how to improve the maintainability of our React application.
  prefs: []
  type: TYPE_NORMAL
