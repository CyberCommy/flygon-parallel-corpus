- en: Java Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will help the reader to become more familiar with the most commonly
    used Java collections. The code examples illustrate their functionality and allow
    an experimentation that emphasizes the difference between different collection
    types and their implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are collections?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List and ArrayList
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set and HashSet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map and HashMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – EnumSet methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are collections?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you read about the Java Collection Framework, you may assume there is something
    special about such an assemblage. Meanwhile, the word framework is quite overloaded
    and misused, as the word technology is one we have refused to use already. In
    the English language, the word framework means *a basic structure underlying a
    system, concept, or text.* In computer programming, a framework is a software
    system constructed so that its functionality can be customized by additional user-written
    code or configuration settings in order to fit the application-specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: But then we look closer into the content of the Java Collection Framework and
    realize that all its members belong to the `java.util` package, which is part
    of the Java Class Library, or Java standard library, as we have described it in
    the previous chapter. And, at the other extreme, the graphic user interfaces in
    the packages `java.awt`, `javax.swing`, or `javafx` have all the signs of a framework;
    they just provide gadgets and other graphic elements, which have to be filled
    by the application-specific content. And yet they belong to the Java Class Library
    too.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we avoid using the word framework and mention it here only to explain
    what is hiding behind the title Java Collection Framework.
  prefs: []
  type: TYPE_NORMAL
- en: The java.util package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following interfaces and classes of the package `java.util` compose the
    Java Collections Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interfaces that extend `java.util.Collection` (which in turn extends the `java.lang.Iterable`
    interface): `List`, `Set`, and `Queue`, to name the most popular ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The classes that implement the fore mentioned interfaces: `ArrayList`, `HashSet`,
    `Stack`, and `LinkedList`, as an example'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes that implement interface `java.util.Map` and its children: `HashMap`,
    `HashTable`, and `TreeMap`, to name just three of the most commonly used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the Java Collection Framework, or just Java Collections, are
    composed of the interfaces that extend the `java.util.Collection` interface or
    the `java.util.Map` interface and the classes that implement these interfaces
    – all are contained in the `java.util` package.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that those classes that implement—directly or indirectly—the `Collection`
    interface also implement the `Iterable` interface and thus can be used in iteration
    statements as described in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Commons collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project Apache Commons contains (in the package `org.apache.commons.collections`)
    multiple implementations of Java collection interfaces that complement the implementations
    in the `java.util` package. But, unless you work on an application that requires
    a particular collection algorithm, you probably won't need to use them. Nevertheless,
    we recommend that you look through the `org.apache.commons.collections` package
    API, so that you know its content in case you encounter a need to use it in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Collections vs arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All collections are data structures similar to arrays in the sense that they
    also contain elements, and each is represented by an object of a class. There
    are two significant differences between arrays and collections, though:'
  prefs: []
  type: TYPE_NORMAL
- en: An array requires assigning a size when instantiated, while a collection increases
    and decreases in size automatically when elements are added or removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An element of a collection cannot be a value of a primitive type, but only
    a reference type, including wrapper classes such as `Integer` or `Double`. The
    good news is that you can add a primitive value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: list.add(42);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The boxing conversion (see [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*) in the preceding statement will be applied
    to the primitive value automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Although arrays are expected to provide better performance while accessing its
    elements, in practice, modern algorithms make the differences in performance of
    arrays and collections negligible, except in some very specialized cases. That
    is why the only reason you would have to use arrays is when some algorithms or
    methods require it.
  prefs: []
  type: TYPE_NORMAL
- en: Here is what we are going to discuss
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following subsections, we will discuss the most popular interfaces and
    classes of Java collections from standard libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: The `List` interface and the `ArrayList` class – they preserve the order of
    the elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Set` interface and the `HashSe` class –  they do not allow duplicate elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Map` and `HashMap` interfaces – they store objects by with a key and thus
    allow key-to-value mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please notice that most of the methods described in the following sections come
    from the `java.util.Collection` interface – the parent interface of almost all
    the collections, except those that implement the `java.util.Map` interface.
  prefs: []
  type: TYPE_NORMAL
- en: List - ArrayList preserves order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` is an interface, while the `ArrayList` class is its most often used
    implementation. Both are residing in the `java.util` package. The `ArrayList` class
    has a few more methods - in addition to those declared in the `List` interface.
    The `removeRange()` method, for example, is not present in the `List` interface
    but available in the `ArrayList` API.'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer variable type List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a good practice, while creating an object of an `ArrayList`, to assign
    its reference to a variable of type `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List listOfNames = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'More likely than not, using a variable of type `ArrayList` will not change
    anything in your program, not today, nor in the future:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList listOfNames = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding reference can still be passed to any method that accepts a parameter
    of type `List`. However, coding to an interface (that is what we do when we make
    the variable of an interface type) is a good habit in general because you never
    know when the requirements to your code might change and you would need to use
    another implementation of `List`, like the `LinkedList` class, for example. If
    the variable type was `List`, switching an implementation is easy. But if the
    variable type was `ArrayList`, changing it to `List` or to `LinkedList` requires
    tracking down all the places the variable was used and run various tests to make
    sure that `ArrayList` methods were not called anywhere. And if the code is complex,
    one can never be sure that all possible execution paths were checked and the code
    will not break in production. That's why we prefer to use an interface type for
    the variable that holds the reference to an object, unless you really need it
    to be the class type. We talked about this extensively in [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called ArrayList?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ArrayList` class is named so because its implementation is based on an
    array. It actually uses an array behind the scenes. If you right-click on `ArrayList` in
    IDE and view the source code, here is what you are going to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
  prefs: []
  type: TYPE_NORMAL
- en: public ArrayList() {
  prefs: []
  type: TYPE_NORMAL
- en: this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is just a wrapper around the array `Object[]`. And here is how method `add(E)`
    is implemented, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean add(E e) {
  prefs: []
  type: TYPE_NORMAL
- en: modCount++;
  prefs: []
  type: TYPE_NORMAL
- en: add(e, elementData, size);
  prefs: []
  type: TYPE_NORMAL
- en: return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private void add(E e, Object[] elementData, int s) {
  prefs: []
  type: TYPE_NORMAL
- en: if (s == elementData.length)
  prefs: []
  type: TYPE_NORMAL
- en: elementData = grow();
  prefs: []
  type: TYPE_NORMAL
- en: elementData[s] = e;
  prefs: []
  type: TYPE_NORMAL
- en: size = s + 1;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you study the source code more and look inside the method `grow()`,
    you will see how it increases the size of the array when new elements are added
    to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: private Object[] grow() {  return grow(size + 1); }
  prefs: []
  type: TYPE_NORMAL
- en: private Object[] grow(int minCapacity) {
  prefs: []
  type: TYPE_NORMAL
- en: return elementData = Arrays.copyOf(elementData,
  prefs: []
  type: TYPE_NORMAL
- en: newCapacity(minCapacity));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private static final int DEFAULT_CAPACITY = 10;
  prefs: []
  type: TYPE_NORMAL
- en: private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
  prefs: []
  type: TYPE_NORMAL
- en: private int newCapacity(int minCapacity) {
  prefs: []
  type: TYPE_NORMAL
- en: // overflow-conscious code
  prefs: []
  type: TYPE_NORMAL
- en: int oldCapacity = elementData.length;
  prefs: []
  type: TYPE_NORMAL
- en: int newCapacity = oldCapacity + (oldCapacity >> 1);
  prefs: []
  type: TYPE_NORMAL
- en: if (newCapacity - minCapacity <= 0) {
  prefs: []
  type: TYPE_NORMAL
- en: if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
  prefs: []
  type: TYPE_NORMAL
- en: return Math.max(DEFAULT_CAPACITY, minCapacity);
  prefs: []
  type: TYPE_NORMAL
- en: if (minCapacity < 0) // overflow
  prefs: []
  type: TYPE_NORMAL
- en: throw new OutOfMemoryError();
  prefs: []
  type: TYPE_NORMAL
- en: return minCapacity;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return (newCapacity - MAX_ARRAY_SIZE <= 0)
  prefs: []
  type: TYPE_NORMAL
- en: '? newCapacity'
  prefs: []
  type: TYPE_NORMAL
- en: ': hugeCapacity(minCapacity);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when the allocated array size is not enough for storing another
    element, the new array is created with a minimum capacity of 10\. All the already
    existing elements are copied to the new array using the `Arrays.copyOf()` method
    (we will talk about the `Arrays` class later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: And that is why `ArrayList` was so named.
  prefs: []
  type: TYPE_NORMAL
- en: For using `List` and `ArrayList`, you do not need to know all that, unless you
    have to process really big lists of elements and the frequent copying of the underlying
    array affects the performance of your code. In such a case, consider using different
    data structures that have been designed specifically for the type of processing
    you need. But that is already outside the scope of this book. Besides, the vast
    majority of mainstream programmers have probably never used any collections that
    are not in the `java.util` package.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `List` interface provides two methods for adding an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add(E)`: This adds the element to the end of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add(index, E)`: This inserts the element into the specified (by index, starting
    with zero) position in the list by shifting the element the specified position
    (if any) and any subsequent elements to the right by adding 1 to their indices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both methods can throw a `RuntimeException` if something goes wrong. So, putting
    a try-catch block around the method makes the code more robust (if the catch block
    does not simply rethrow the exception but does something meaningful). Read the
    documentation of the `List` interface API online and see what the names of the
    exceptions these methods can throw are and under which conditions they can happen.
  prefs: []
  type: TYPE_NORMAL
- en: The `add(E)` method also returns a Boolean value (`true`/`false`) that indicates
    the success of the operation. This method overrides the method in the `Collection`
    interface, so all Java collections that extend or implement the `Collection` interface
    have it. In the case of `List` implementations, this method most likely always
    returns `true` because list allows duplicate entries. By contrast, the implementations
    of the `Set` interface return `false` if such an element is present already because
    `Set` does not allow duplicates. We will discuss this in subsequent sections,
    as well as how the code determines if two elements are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the examples of the `add()` method of the `List` interface''s
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list.add(1);
  prefs: []
  type: TYPE_NORMAL
- en: list.add("ss");
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new A());
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);  //prints: [null, 1, ss, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(2, 42);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);  //prints: [null, 1, 42, ss, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding list, we have mixed up in the same list values of different
    types. The classes `A` and `B`, used in the preceding code, have parent-child
    relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() { return "A"; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() { return "B"; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have added the `toString()` method to each of them, so we
    can see their objects printed in an expected format.
  prefs: []
  type: TYPE_NORMAL
- en: size(), isEmpty(), clear()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These three methods are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size()`: This returns count of elements in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty()`: This returns `true` if there is no elements in the list (`size()`
    returns 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: This removes  all elements from the list so that `isEmpty()` returns
    `true` and `size()` returns 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate and stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every collection that implements the `Collection` interface (which extends
    the `Iterable` interface) can be iterated over using the enhanced `for` statement
    discussed in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list.add(1);
  prefs: []
  type: TYPE_NORMAL
- en: list.add("ss");
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new A());
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Object o: list){'
  prefs: []
  type: TYPE_NORMAL
- en: //code that does something with each element
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Iterable` interface also adds the following three methods to the `List`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach(Consumer function)`: It applies the provided function to each collection
    element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterator()`: It returns an object of class `Iterator` that allows walking
    through (iterating) each element of the collection and manipulating each of them
    as needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splititerator()`: It returns an object of class `Splititerator` that allows
    splitting the collection for parallel processing (discussion of this functionality is
    outside the scope of this book)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*, we will explain how the function can be passed as
    a parameter, so for now, we just show an example of the `forEach()` method''s
    usage (if we re-use the list created in the previous example):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the passed-in function take each element generated by the `forEach()` method
    and just prints it. It is called `Consumer` because it gets (consumes) the input
    and returns no value back it, just prints. If we run the preceding code, the result
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42802e7f-83a1-4e82-98ed-3c2ae7c83e06.png)'
  prefs: []
  type: TYPE_IMG
- en: The `forEach()` method provides the same functionality as the `for` statement
    (see the previous example) but requires writing less code. That is why programmers
    love functional programming (when a function can be treated as an object), because
    after writing the same boilerplate code hundreds of times, one can enjoy the shorthand
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Iterator` interface returned by the `iterator()` method has the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next()`: It returns the next element in the iteration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasNext ()`: It returns `true` if the iteration has more elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachRemaining (Consumer<? super E> function)`: It applies the provided
    function to each of remaining elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`: It removes from the underlying collection the last element returned
    by this iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods `next()` and `hasNext()` are used by `for` statements behind the
    scenes. You can also use them and in fact reproduce the `for` statement functionality.
    But why? The `for` statements are doing it already. The only reason to use the `Iterator` interface
    we could think about is to remove some objects from the list (using the `remove()` method)
    while iterating over the list. This brings us to the point of discussing a mistake
    a beginner often makes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we would like to remove all the objects of type `String` from
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list.add(1);
  prefs: []
  type: TYPE_NORMAL
- en: list.add("ss");
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new A());
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that attempts to do it, but has a defect:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Object o: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(o);
  prefs: []
  type: TYPE_NORMAL
- en: if(o instanceof String){
  prefs: []
  type: TYPE_NORMAL
- en: list.remove(o);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding code, the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1378467-d097-4151-a4ec-64ec09d2a9e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ConcurrentModificationException` was thrown because we tried to modify
    the collection while iterating over it. The `Iterator` class helps to avoid this
    problem. The following code works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);  //prints: [null, 1, ss, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: Iterator iter = list.iterator();
  prefs: []
  type: TYPE_NORMAL
- en: while(iter.hasNext()){
  prefs: []
  type: TYPE_NORMAL
- en: Object o = iter.next();
  prefs: []
  type: TYPE_NORMAL
- en: if(o instanceof String){
  prefs: []
  type: TYPE_NORMAL
- en: iter.remove();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);  //prints: [null, 1, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not going to discuss why `Iterator` allows removing an element during
    the iteration and why the collection throws an exception in a similar situation
    for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires going much deeper into the JVM implementation than an introductory
    course allows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams and Pipelines*,
    we will demonstrate a more compact way to do it using Java functional programming.
    Such a code looks so clean and elegant that many programmers working with Java
    8 and higher almost never use `for` statements while working with collections
    and other data structures that generate streams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also four other ways to iterate over a list of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`listIterator()` and `listIterator(index)`: Both return `ListIterator`, which
    is very similar to `Iterator` but allows going back and forth along the list (`Iterator` allows
    only going forth, as you have seen). These methods are rarely used, so we are
    going to skip their demonstration. But if you need to use them, look at the preceding `Iterator`
    example. The usage of `ListIterator` is very similar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream()` and `parallelStream()`: Both return the `Stream` object, which we
    are going to discuss in more detail in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add using generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes having different types in the same list is exactly what we want. But,
    most of the time, we would like the list to contain values of the same type. Meanwhile,
    code may have logical errors that allow a different type to be added to the list,
    which can have unexpected consequences. If it leads to throwing an exception,
    it is not as bad as some default conversion and incorrect results at the end,
    which may not be noticed for a long time, if ever.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid such a problem, one can use generics that allow defining the expected
    type of the collection elements, so that the compiler can check and fail the case
    when a different type is added. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> list1 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list1.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list1.add(1);
  prefs: []
  type: TYPE_NORMAL
- en: //list1.add("ss");          //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list1.add(new A());       //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list1.add(new B());       //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list1);  //prints: [null, 1]'
  prefs: []
  type: TYPE_NORMAL
- en: list1.add(2, 42);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list1);  //prints: [null, 1, 42]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a `null` value can be added anyway, because it is a default
    value of any reference type, while, as we have pointed out at the beginning of
    this section already, the elements of any Java collection can only be of a reference
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a subclass has a type of any of its superclasses, the generic `<Object>`
    does not help to avoid the previously described problem, because every Java object
    has the `Object` class as its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Object> list2= new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list2.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list2.add(1);
  prefs: []
  type: TYPE_NORMAL
- en: list2.add("ss");
  prefs: []
  type: TYPE_NORMAL
- en: list2.add(new A());
  prefs: []
  type: TYPE_NORMAL
- en: list2.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list2);    //prints: [null, 1, ss, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: list2.add(2, 42);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list2);    //prints: [null, 1, 42, ss, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, the following generics are more restrictive:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list3= new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list3.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: //list3.add(1);            //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list3.add("ss");         //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: list3.add(new A());
  prefs: []
  type: TYPE_NORMAL
- en: list3.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list3); //prints: [null, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: list3.add(2, new A());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list3); //prints: [null, A, A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: List<B> list4= new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list4.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: //list4.add(1);            //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list4.add("ss");         //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list4.add(new A());      //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: list4.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list4); //prints: [null, B]'
  prefs: []
  type: TYPE_NORMAL
- en: list4.add(2, new B());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list4); //prints: [null, B, B]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only case when you might use a generic `<Object>` is when you would like
    to allow values of different types to be added to the list, but you do not want
    to allow the reference to the list itself to refer to a list with other generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List list = new ArrayList();
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> list1 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: List<Object> list2= new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list = list1;
  prefs: []
  type: TYPE_NORMAL
- en: //list2 = list1;   //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the list without generics (called raw type) allows its reference
    to refer to any other list with any generics, while the list with a generic `<Object>`
    does not allow its variable to refer to a list with any other generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java collection also allows a wildcard generic, `<?>`, which allows only
    `null` to be assigned to the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<?> list5= new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list5.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: //list5.add(1);            //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list5.add("ss");         //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list5.add(new A());      //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list5.add(new B());      //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list5); //prints: [null]'
  prefs: []
  type: TYPE_NORMAL
- en: //list5.add(1, 42);        //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the usage of the wildcard generics can be demonstrated as follows.
    Let''s assume that we write a method that has `List` (or any collection, for that
    matter) as a parameter but we would like to ensure that this list will be not
    modified inside the method, which changes the original list. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void doSomething(List<B> list){
  prefs: []
  type: TYPE_NORMAL
- en: //some othe code goes here
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: list.add(0, new B());
  prefs: []
  type: TYPE_NORMAL
- en: //some other code goes here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the preceding method, we get an undesirable side effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<B> list= new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list); //prints: [B]'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(0, null);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list); //prints: [null, B]'
  prefs: []
  type: TYPE_NORMAL
- en: doSomething(list);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list); //[B, null, B, null, B]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid the side effect, one can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void doSomething(List<?> list){
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: //list.add(1);            //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list.add("ss");         //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list.add(new A());      //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list.add(new B());      //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: //list.add(0, 42);        //compilation error
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this way the list cannot be modified, except by adding `null`.
    Well, it comes at a price of removing the generic, `<B>`. Now, it is possible
    that the passed-in list contains objects of different types, and the typecasting
    `(B)` will throw `ClassCastException`. Nothing comes free, but the possibilities
    are available.
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of an encapsulation, the best practice recommends using as many
    narrow (or specialized) a types for generics as possible. This ensures much lower
    chances of unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the collection from being modified inside the method, it is possible
    to make the collection immutable. It can be done inside or outside the method
    (before passing it as the parameter). We will show you how to do it in the [Chapter
    14](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml), *Managing Collections and Arrays*.
  prefs: []
  type: TYPE_NORMAL
- en: Add collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two methods of the `List` interface allow adding the whole collection of objects
    to the existing list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addAll(Collection<? extends E> collection)`: It adds the provided collection
    of objects to the end of the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addAll(int index, Collection<? extends E> collection)`: It inserts the provided
    elements into the list at the specified position. The operation shifts the element
    currently at that position (if any) and any subsequent elements to the right (increases
    their indices by the size of the provided collection).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both methods throw several `RuntimeExceptions` if something goes wrong. Also,
    both methods return a Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`false`: If the list has not changed after this method invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`true`: If the list has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the case of adding a single element, all `List` implementations of these
    methods most likely always return true because `List` allows duplicates, which
    is not the case for `Set` (we will discuss this shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have read the description of generics a few pages back, you can guess
    what the notation `Collection<? extends E>` means.  The generic `<? extends E>`
    means a type that is either `E` or a child of `E`, where `E` is the type used
    as the generics of the collection. To relate to our previous examples, observe
    the following, classes, `A` and `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class A {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() { return "A"; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class B extends A {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() { return "B"; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We can add to `List<A>` objects of classes `A` and of `B`.
  prefs: []
  type: TYPE_NORMAL
- en: The notation `addAll(Collection<? extends E> collection)` means this method
    allows the addition to `List<E>` objects of type `E` or any subtype of `E`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<A> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new A());
  prefs: []
  type: TYPE_NORMAL
- en: List<B> list1 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list1.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: list.addAll(list1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [A, B]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `addAll(int index, Collection<? extends E> collection)` method acts very
    similar, but only starting from the specified index. And, of course, the value
    of the provided index should be equal to 0 or less than the length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: For the `addAll(int index, Collection<? extends E> collection)` method, the
    value of the provided index should be equal to 0 or less than the length of the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing equals() and hashCode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very important subsection because, more often than not, while creating
    a class, programmers are focused on the main functionality and forget to implement
    the `equals()` and `hashCode()` methods. It does not cause any problems until
    objects are compared using the `equals()` method or added to a collection and
    then searched or assumed to be unique (in the case of `Set`).
  prefs: []
  type: TYPE_NORMAL
- en: As we demonstrated in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*, the `equals()` method can be used for
    object identification. If a class does not override the default implementation
    of the `equals()` method in the base class `Object`, then every object is unique.
    Even if two objects of the same class have the same state, the default `equals()` method
    reports them as different. So, if you need two objects of the same class with
    the same state being treated as equal, you have to implement the `equals()` method
    in that class, so that it overrides the default implementation in `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: Since every Java collection is using the `equals()` method while searching for
    the object among its elements, you have to implement it, because a typical business
    logic requires including the object state or at least some of the state values
    into consideration during the object identification process. You also have to
    decide on which level of the class inheritance chain two children should be considered
    equal, as we discussed in [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml),
    *Operators, Expressions, and Statements*, while comparing objects of the classes  `PersonWithHair`
    and `PersonWithHairDressed`; both extend the `Person` class. We decided then that
    the objects of these classes represent the same person if they are equal according
    to the `equals()` method implemented in the `Person` class. We also decided to
    consider for the purpose of the identification (equality) only the fields `age`
    and `name`, although the `Person` class may have had several other fields (such
    as `currentAddress`, for example) which are not relevant for the person's identification.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you expect that the class you create will be used for generating objects
    that will be used as members of some Java collection, you''d better implement
    the `equals()` method. To do it, you have to make two decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: On which level of the class inheritance hierarchy to implement the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which fields of the object (which aspects of the object state, in other words)
    to include into the consideration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `equals()` method is used by Java collections for the element identification.
    While implementing the `equals()` method, consider doing it in one of the parent classes
    and decide which fields to use while comparing two objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `hashCode()` is not used by the `List` implementation, so we will
    discuss it in more detail in relation to the implementations of the interfaces
    `Set` and `Map` in the following code. But since we are on the topic here, we
    would like to mention that the best Java programming practices recommend implementing
    the `hashCode()` method every time the `equals()` method is implemented. While
    doing it, use the same fields that the `equals()` method uses. For example, the
    `Person` class we implemented in  [Chapter 9](33ed1fb4-36e0-499b-8156-4d5e88a2c404.xhtml), *Operators,
    Expressions, and Statements*, should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person{
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name, currentAddress;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name, String currAddr) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: this.name = name;
  prefs: []
  type: TYPE_NORMAL
- en: this.currentAddress = currAddr;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: if(!(o instanceof Person)) return false;
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person)o;
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.getAge() &&
  prefs: []
  type: TYPE_NORMAL
- en: Objects.equals(name, person.getName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int hashCode(){
  prefs: []
  type: TYPE_NORMAL
- en: return Objects.hash(age, name);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have added an implementation of the `hashCode()` method based
    on the `hash()` method of the `Objects` class, which we will discuss later in
    this chapter. We have also added a new field, but will not use it in either the `equals()` method nor
    in the `hashCode()` method, because we think it is not relevant for a person's
    identification.
  prefs: []
  type: TYPE_NORMAL
- en: Every time you implement the `equals()` method, implement the `hashCode()` method
    as well, because the object of the class you create may be used not only in a
    `List` but in `Set` or `Map` too, which requires `hashCode()` to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We will talk about the motivation of the `hashCode()` method's implementation
    for `Set` and `Map` in the corresponding sections of this chapter. We will also
    explain why we cannot use `hashCode()` for the purpose of the object identification,
    similar to like when we use the `equals()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Locating element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three methods in the `List` interface that allow checking the presence
    and location of an element in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contains(E)`: It returns `true` if the provided element is present in the
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf(E)`: It returns an index (position) of the provided element in the
    list. If  there are several such elements in the list, the smallest index is returned
    – the index of the first element from the left that equals the provided element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastIndexOf(E)`: It returns an index (position) of the provided element in
    the list. If there are several such elements in the list, the biggest index is
    returned – the index of the last element from the left that equals the provided
    element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that shows how to use these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.contains("s1"));    //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.indexOf("s1"));     //prints: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.lastIndexOf("s1")); //prints: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things worth noticing:'
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the list has an index of 0 (like an array, too)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding methods rely on the implementation of the `equals()` method to
    identify the provided object in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two methods in the `List` interface that allow element retrieval:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get(index)`: It returns the element that has the provided index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sublist(index1, index2)`: It returns the list of elements starting with `index1`
    until (but not including) the element that has `index2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates how these methods can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.get(1));       //prints: s2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.subList(0,2)); //prints: [s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four methods in the `List` interface that remove (delete) elements
    from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove(index)`: It removes an element that has the provided index and returns
    the removed element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(E)`: It removes the provided element and returns `true` if the list
    contained it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAll(Collection)`: It removes the provided elements and returns `true` if
    the list has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retainAll(Collection)`: It removes all the elements that are not in the provided
    collection and returns `true` if the list has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two points we would like to make about these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The last three methods use the `equals()` method to identify the elements to
    be removed or retained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If one or more elements were removed from the list, the indices of the remaining
    elements are recalculated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the code examples now:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.remove(1));    //prints: s2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);              //prints: [s1, s3, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: //System.out.println(list.remove(5));  //throws IndexOutOfBoundsException
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.remove("s1")); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);              //prints: [s3, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list.remove("s5")); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);              //prints: [s3, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, it is worth noticing that the list has two elements, `s1`
    but only the first from the left is removed by the statement `list.remove("s1")`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list.removeAll(List.of("s1", "s2", "s5")));   //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);                                        //[s3]
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list.removeAll(List.of("s5")));               //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);                                        //[s3]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To save space, we have used the `of()` method to create a list, which we will
    discuss in [Chapter 14](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml), *Managing
    Collections and Arrays*. By contrast with the previous example, the statement
    `list.removeAll("s1","s2","s5")` in the preceding code removed both elements `s1`
    from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list.retainAll(List.of("s1","s2","s5"))); //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);                                    //[s1, s2, s1]
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list.retainAll(List.of("s1","s2","s5"))); //false
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);                                    //[s1, s2, s1]
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list.retainAll(List.of("s5")));           //true
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);                                    //[]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Please note in the preceding code how the `retainAll()` method returns `false`
    the second time because the list was not changed. Also, notice how the statement
    `list.retainAll(List.of("s5")` clears the list because none of its elements were
    equal to any of the provided elements.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two methods in the `List` interface that allow replacing elements
    in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(index, E)`: It replaces the element that has the provided index with the
    provided element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replaceAll(UnaryOperator<E>)`: It replaces each element of the list with the
    result returned by the provided operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the usage of the method `set()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.set(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [s1, null]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is pretty straightforward and doesn't seem to require any comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method, `replaceAll()`, is based on the function `UnaryOperator<E>`
    – one of the Java functional interfaces introduced in Java 8\. We will discuss
    it in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*. For now, we would just like to show the code examples.
    They seem quite simple, so you should be able to understand how it works. Let''s
    assume we start with the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are a few possible element modifications (just remember that the `replaceAll()`
    method replaces each element with the result returned by the provided function):'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.replaceAll(s -> s.toUpperCase()); //cannot process null
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [S1, S2, S3, S1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'list.replaceAll(s -> ("S1".equals(s) ? "S5" : null));'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [S5, null, null, S5]'
  prefs: []
  type: TYPE_NORMAL
- en: list.replaceAll(s -> "a");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [a, a, a, a]'
  prefs: []
  type: TYPE_NORMAL
- en: list.replaceAll(s -> {
  prefs: []
  type: TYPE_NORMAL
- en: String result;
  prefs: []
  type: TYPE_NORMAL
- en: //write here any code you need to get the value
  prefs: []
  type: TYPE_NORMAL
- en: // for the variable result based in the value of s
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s);   //prints "a" four times
  prefs: []
  type: TYPE_NORMAL
- en: result = "42";
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [42, 42, 42, 42]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the last example, we have put the body of the operation in braces `{}` and
    added an explicit `return` statement, so you can see what we mean when we say
    the operation returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: While comparing the elements of a collection with a `String` literal or any
    other object using the `equals()` method, it is a good habit to invoke `equals()`
    on the literal, such as `"s1".equals(element)`, or on the object you use to compare
    with, such as `someObject.equals(element)`. It helps to avoid `NullPointerException`
    in case the collection has a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples of functions can be re-written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: UnaryOperator<String> function = s -> s.toUpperCase();
  prefs: []
  type: TYPE_NORMAL
- en: list.replaceAll(function);
  prefs: []
  type: TYPE_NORMAL
- en: 'function = s -> ("S1".equals(s) ? "S5" : null);'
  prefs: []
  type: TYPE_NORMAL
- en: list.replaceAll(function);
  prefs: []
  type: TYPE_NORMAL
- en: function = s -> "a";
  prefs: []
  type: TYPE_NORMAL
- en: list.replaceAll(function);
  prefs: []
  type: TYPE_NORMAL
- en: function = s -> {
  prefs: []
  type: TYPE_NORMAL
- en: String result;
  prefs: []
  type: TYPE_NORMAL
- en: //write here any code you need to get the value
  prefs: []
  type: TYPE_NORMAL
- en: // for the variable result based in the value of s
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(s);   //prints "a" four times
  prefs: []
  type: TYPE_NORMAL
- en: result = "42";
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: list.replaceAll(function);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This way, they can be passed around as any other parameters, and that is the
    power of functional programming. But again, we will talk more about it and explain
    all the syntax in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting String and numeral types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have mentioned already, a collection of type `List` preserves an order
    of the elements, so, naturally, it has also an ability to sort the elements, and
    the `sort(Comparator<E>)` method serves this purpose. This method became possible
    after functional programming was introduced with Java 8\. We will talk about it
    in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will just show you a few examples and point where to look for the standard
    comparators. We start with the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("ab");
  prefs: []
  type: TYPE_NORMAL
- en: //list.add(null); //throws NullPointerException for sorting
  prefs: []
  type: TYPE_NORMAL
- en: //     String.CASE_INSENSITIVE_ORDER
  prefs: []
  type: TYPE_NORMAL
- en: //     Comparator.naturalOrder()
  prefs: []
  type: TYPE_NORMAL
- en: //     Comparator.reverseOrder()
  prefs: []
  type: TYPE_NORMAL
- en: list.add("a");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("Ab");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);                //[s3, s2, ab, a, Ab]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here are a few examples of sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(String.CASE_INSENSITIVE_ORDER);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);                //[a, ab, Ab, s2, s3]
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.naturalOrder());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);               //[Ab, a, ab, s2, s3]
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.reverseOrder());
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);               //[Ab, a, ab, s2, s3]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding sortings are not null-safe, as the preceding comments point out.
    You can know this by reading API documentation about the preceding comparators
    or just by experimenting with them. One often tries various edge cases even after
    reading the documentation, to understand the described functionality better and
    to see if you understand the description correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also comparators that handle `null` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.nullsFirst(Comparator.naturalOrder()));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);              //[null, Ab, a, ab, s2, s3]
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.nullsLast(Comparator.naturalOrder()));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);              //[Ab, a, ab, s2, s3, null]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, many popular comparators can be found as static methods of
    class `java.util.Comparator`. But if you do not see a ready-to-use comparator
    you need, you can also write your own. For example, let''s assume we need to sort
    null value so as if it is `String` value "null". For such a case, we can write
    a  custom comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Comparator<String> comparator = (s1, s2) ->{
  prefs: []
  type: TYPE_NORMAL
- en: 'String s = (s1 == null ? "null" : s1);'
  prefs: []
  type: TYPE_NORMAL
- en: return s.compareTo(s2);
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(comparator);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(list);              //[Ab, a, ab, null, s2, s3]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also comparators for various number types in `Comparator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`comparingInt(ToIntFunction<? super T> keyExtractor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comparingLong(ToLongFunction<? super T> keyExtractor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comparingDouble(ToDoubleFunction<? super T> keyExtractor)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We leave them for the readers to study on their own if they need to use these
    methods for numbers comparison. However, it seems that most mainstream programmers
    never use them; the ready-to-use comparators we have demonstrated are usually
    more than enough.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting custom objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the more frequently encountered cases is the need to sort custom objects,
    such as `Car`, or `Person` type, for example. To do it, there are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `Comparable` interface. It has only one method, `compareTo(T)`,
    which accepts an object of the same type and returns a negative integer, zero,
    or a positive integer if this object is less than, equal to, or greater than the
    specified object. Such an implementation is called a natural ordering because
    objects that implement the `Comparable` interface can be ordered by the method
    `sort()` of a collection. Many of the examples of the previous subsection demonstrated
    how it works for the objects of type `String`. Comparators are returned by the
    methods `naturalOrder()`, `reverseOrder()`, `nullFirst()`, and `nullLast()` –
    they all are based on using the `compareTo()` implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement an external comparator that compares two objects of the type of collection
    elements using the static `comparing()` method of the `Comparator` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the code examples for each of the preceding options and discuss
    the pros and cons of each approach. First, let enhance the classes `Person`, `PersonWithHair`,
    and `PersonWithHairDressed` and implement the `Comparable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person implements Comparable<Person> {
  prefs: []
  type: TYPE_NORMAL
- en: private int age;
  prefs: []
  type: TYPE_NORMAL
- en: private String name, address;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int age, String name, String address) {
  prefs: []
  type: TYPE_NORMAL
- en: this.age = age;
  prefs: []
  type: TYPE_NORMAL
- en: 'this.name = name == null ? "" : name;'
  prefs: []
  type: TYPE_NORMAL
- en: this.address = address;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: return name.compareTo(p.getName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean equals(Object o) {
  prefs: []
  type: TYPE_NORMAL
- en: if (this == o) return true;
  prefs: []
  type: TYPE_NORMAL
- en: if (o == null) return false;
  prefs: []
  type: TYPE_NORMAL
- en: if(!(o instanceof Person)) return false;
  prefs: []
  type: TYPE_NORMAL
- en: Person person = (Person)o;
  prefs: []
  type: TYPE_NORMAL
- en: return age == person.getAge() &&
  prefs: []
  type: TYPE_NORMAL
- en: Objects.equals(name, person.getName());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int hashCode(){ return Objects.hash(age, name); }
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() { return "Person{age=" + age +
  prefs: []
  type: TYPE_NORMAL
- en: '", name=" + name + "}";'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have added another instance field, `address`, but do not
    use it in either the  `equals()`, `hashCode()`, or `compareTo()` methods. We did
    it just to show that it is completely up to you how to define the identity of
    the object of class `Person` and its children.  We also implemented the `toString()` method
    (which prints only the fields included in the identity), so we can identify each
    object when they are displayed. And we have implemented the method of the `Comparable`
    interface, `compareTo()`, which is going to be used for sorting. Right now it
    takes into account only the name, so when sorted, the objects will be ordered
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The children of class `Person` did not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class PersonWithHair extends Person {
  prefs: []
  type: TYPE_NORMAL
- en: private String hairstyle;
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithHair(int age, String name,
  prefs: []
  type: TYPE_NORMAL
- en: String address, String hairstyle) {
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name, address);
  prefs: []
  type: TYPE_NORMAL
- en: this.hairstyle = hairstyle;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: class PersonWithHairDressed extends PersonWithHair{
  prefs: []
  type: TYPE_NORMAL
- en: private String dress;
  prefs: []
  type: TYPE_NORMAL
- en: public PersonWithHairDressed(int age, String name,
  prefs: []
  type: TYPE_NORMAL
- en: String address, String hairstyle, String dress) {
  prefs: []
  type: TYPE_NORMAL
- en: super(age, name, address, hairstyle);
  prefs: []
  type: TYPE_NORMAL
- en: this.dress = dress;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create the list that we are going to sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new PersonWithHair(45, "Bill", "27 Main Street",
  prefs: []
  type: TYPE_NORMAL
- en: '"Pompadour"));'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new PersonWithHair(42, "Kelly","15 Middle Street",
  prefs: []
  type: TYPE_NORMAL
- en: '"Ponytail"));'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new PersonWithHairDressed(34, "Kelly", "10 Central Square",
  prefs: []
  type: TYPE_NORMAL
- en: '"Pompadour", "Suit"));'
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new PersonWithHairDressed(25, "Courtney", "27 Main Street",
  prefs: []
  type: TYPE_NORMAL
- en: '"Ponytail", "Tuxedo"));'
  prefs: []
  type: TYPE_NORMAL
- en: list.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execution of the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=45, name=Bill}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=42, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=34, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=25, name=Courtney}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The persons are printed in the order they were added to the list. Now, let''s
    sort them:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.naturalOrder());
  prefs: []
  type: TYPE_NORMAL
- en: list.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new order looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=45, name=Bill}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=25, name=Courtney}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=42, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=34, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The objects are ordered alphabetically by name – that is how we have implemented
    the `compareTo()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the `reverseOrder()` comparator, the order shown be reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.reverseOrder());
  prefs: []
  type: TYPE_NORMAL
- en: list.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we see if we run the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=42, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=34, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=25, name=Courtney}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=45, name=Bill}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The order was reversed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change our implementation of the `compareTo()` method and order the
    objects by age:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: return age - p.getAge();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can implement it so that the `Person` objects will be sorted by both
    fields – first by name, then by age:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public int compareTo(Person p){
  prefs: []
  type: TYPE_NORMAL
- en: int result = this.name.compareTo(p.getName());
  prefs: []
  type: TYPE_NORMAL
- en: if (result != 0) {
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return this.age - p.getAge();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we sort the list in natural order now, the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=45, name=Bill}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=25, name=Courtney}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=34, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: Person{age=42, name=Kelly}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the objects are ordered by name, but two persons with the same
    name Kelly are ordered by age too.
  prefs: []
  type: TYPE_NORMAL
- en: That is the advantage of implementing the `Comparable` interface – the sorting
    is always performed the same way. But this is also a disadvantage because to change
    the order, one has to re-implement the class. Besides, it might be not possible
    if the `Person` class comes to us from a library, so we cannot modify its code.
  prefs: []
  type: TYPE_NORMAL
- en: In such cases, the second option—using the `Comparator.comparing()` method—comes
    to the rescue. And, by the way, we can do it even when the `Person` class does
    not implement the `Comparable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Comparator.comparing()` method accepts a function as parameter. We will
    talk about functional programming in more detail in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*. For now, we will just say that
    the `Comparator.comparing()` method generates a comparator based on the field
    (of the class to be sorted) passed in as a parameter. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.comparing(Person::getName));
  prefs: []
  type: TYPE_NORMAL
- en: list.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code sorts `Person` objects by name. The only modification we
    had to do was adding the `getName()` method to the `Person` class. Similarly,
    if we add the `getAge()` method,  we can sort the `Person` objects by age:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.comparing(Person::getAge));
  prefs: []
  type: TYPE_NORMAL
- en: list.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we can sort them by both fields – exactly the same way we did it when implemented
    the `Comparable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: list.sort(Comparator.comparing(Person::getName).thenComparing(Person::getAge));
  prefs: []
  type: TYPE_NORMAL
- en: list.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding code how the sorting methods can be chained using
    `thenComparing()`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the classes usually have getters to access the fields value, so adding
    getters typically is not needed and any library class can be sorted this way.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing with another collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Java collection implements the `equals()` method, which compares it with
    another collection. In the case of `List`, two lists are considered equal (the
    method `list1.equals(list2)` returns `true`) when:'
  prefs: []
  type: TYPE_NORMAL
- en: Each collection is of type `List`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each element of one list is equal to the element of another list in the same
    position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that illustrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list1 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list2.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list2.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list1.equals(list2)); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: list2.sort(Comparator.reverseOrder());
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list2);               //prints: [s2, s1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list1.equals(list2)); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If two lists are equal, their `hashCode()` methods return the same integer value.
    But the equality of `hashCode()` results does not guarantee that the lists are
    equal. We will talk about the reason for that while discussing the `hashCode()`
    method implementation for the elements of the `Set` collection in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The `containsAll(Collection)` method of the `List` interface (or any collection
    that implements the `Collection` interface) returns `true` only if all elements
    of the provided collection are present in the list. If the size of the list and
    the size of the provided collection are equal, we can be sure that the same (well,
    equal) elements compose each of the compared collections. It does not guarantee
    though that the elements are of the same type, because they might be children
    of different generations with the `equals()` method implemented only in the common
    parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, we can find the difference using the methods `retainAll(Collection)`
    and `removeAll(Collection)`, described earlier in this section. Let''s assume
    we have two lists as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list1 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: list1.add("s4");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list2 = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list2.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list2.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list2.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list2.add("s5");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find which elements in one list are not present in the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>(list1);
  prefs: []
  type: TYPE_NORMAL
- en: list.removeAll(list2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [s3, s4]'
  prefs: []
  type: TYPE_NORMAL
- en: list = new ArrayList<>(list2);
  prefs: []
  type: TYPE_NORMAL
- en: list.removeAll(list1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [s5]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we have created a temporary list to avoid corruption of the original
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this difference does not tell us about possibly duplicate elements present
    in each of the list. To find it, we can use the `retainAll(Collection)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>(list1);
  prefs: []
  type: TYPE_NORMAL
- en: list.retainAll(list2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [s1, s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: list = new ArrayList<>(list2);
  prefs: []
  type: TYPE_NORMAL
- en: list.retainAll(list1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(list);    //prints: [s1, s2, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have the full picture of the differences between the two lists.
  prefs: []
  type: TYPE_NORMAL
- en: Also, please, notice that the `retainAll(Collection)` method can be used to
    identify the elements that belong to each of the lists.
  prefs: []
  type: TYPE_NORMAL
- en: But neither `retainAll(Collection)` nor `removeAll(Collection)` guarantee that
    the compared list and the collection passed in contain elements of the same type.
    They might be a mix of children with a common parent that have the `equals()` method implemented
    in the parent only, and the parent type is the type of the list and the collection
    passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two methods that allow converting a list to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toArray()`: It converts the list to array `Object[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toArray(T[])`: It converts the list to array `T[]`, where `T` is the type
    of the elements in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both methods preserve the order of the elements. Here is the demo code that
    shows how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: Object[] arr1 = list.toArray();
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Object o: arr1){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(o);       //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr2 = list.toArray(new String[list.size()]);
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String s: arr2){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(s);      //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, there is another way to convert a list or any collection for that matter
    to an array – using a stream and functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Object[] arr3 = list.stream().toArray();
  prefs: []
  type: TYPE_NORMAL
- en: 'for (Object o : arr3) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(o);       //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr4 = list.stream().toArray(String[]::new);
  prefs: []
  type: TYPE_NORMAL
- en: 'for (String s : arr4) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(s);       //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Streams and functional programming have made many traditional coding solutions
    obsolete. We will discuss this in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming* and in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipeline*.
  prefs: []
  type: TYPE_NORMAL
- en: List implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many classes that implement the `List` interface for various purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayList`: As we have discussed in this section, it is by far the most popular
    `List` implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinkedList`: Provides fast adding and removing of the elements at the end
    of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stack`: Provides a **last-in-first-out** (**LIFO**) storage for objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other classes referred to in the online documentation of the `List` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set - HashSet does not allow duplicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a reason for the creation of the `Set` interface; it was designed
    not to allow duplicate elements. A duplicate is identified using the `equals()` method,
    implemented in the class whose objects are elements of the set.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring variable type Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of `List`, using type `Set` for the variable that holds a reference
    to the object of the class that implements the `Set` interface is a good programming
    practice called coding to an interface. It assures independence of the client
    code from any particular implementation. So, it is a good habit to write `Set<Person>
    persons = new HashSet<>()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called HashSet?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, a hash value is a 32-bit signed integer that represents some
    data. It is used in such data structures as a `HashTable`. After a record is created
    in a `HashTable`, its hash value can be used later to quickly find and retrieve
    the stored data. A hash value is also called a hash code, digest, or simply hash.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the `hashCode()` method in the base `Object` class returns a hash value
    as the object representation, but it it does not take into account the values
    of any children's fields. This means that if you need the hash value to include
    the child object state, you need to implement the `hashCode()` method in that
    child class.
  prefs: []
  type: TYPE_NORMAL
- en: A hash value is an integer that represents some data. In Java, it represents
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: The `HashSet` class uses hash value as a unique key to store and retrieve an
    object. Although the number of possible integers is big, the variety of objects
    is still bigger. So, it is quite possible that two not-equal objects have the
    same hash value. That is why each hash value in `HashSet` refers not to an individual
    object, but potentially a group of objects (called a bucket or bin). `HashSet`
    resolves this clash using the `equals()` method.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there are several objects of class `A` stored in a `HashSet` object
    and you want to know if a particular object of class `A` is there. You call the `contains(object
    of A)` method on the `HashSet` object. The method calculates the hash value of
    the provided object and looks for a bucket with such a key. If none was found,
    the `contains()` method returns `false`. But if a bucket with such hash value
    exists, it may contain several objects of class `A`. That is when the `equals()` method
    comes into play. The code compares each of the objects in the bucket with the
    provided one using the `equals()` method. If one of the calls to `equals()` returns
    `true`, the `contains()` method returns `true`, thus confirming that such an object
    is stored in the already.  Otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: That is why, as we have already stated while discussing the `List` interface,
    it is very important that, if the objects of the class you are creating are going
    to be elements of a collection, both methods—`equals()` and `hashCode()`—have
    to be implemented and use the same instance fields. Since `List` does not use
    a hash value, it is possible to get away using the `List` interface for the objects
    that do not have the `hashCode()` method implemented in a child of `Object`. But
    any collection that has "Hash" in its name will work incorrectly without it. Thus,
    the name.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Set` interface provides only one method for adding a single element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add(E)`: It adds the provided element `E1` to the set if there is not already
    such an element `E2` there such that the statement `Objects.equals(E1, E2)` returns
    `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Objects` class is a utility class located in the package `java.util`. Its
    `equals()` method compares two objects in a null-safe manner by returning `true`
    when both objects are `null` and using the `equals()` method otherwise. We will
    talk more about utility class `Objects` in this chapter in an upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: The `add()` method can throw a `RuntimeException` if something goes wrong. So,
    putting a try-catch block around the method makes the code more robust (if the
    catch block does not simply rethrow the exception but does something meaningful).
    Read the description of the `Set` interface API online and see what the names
    of the exceptions this method throws are and under which conditions they can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add(E)` method also returns a Boolean value (`true`/`false`) that indicates
    the success of the operation. This method overrides the method in the `Collection` interface,
    so all Java collections that extend or implement the `Collection` interface have
    it. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set.add("s1"));  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set.add("s1"));  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set.add("s2"));  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set.add("s3"));  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set);            //prints: [s3, s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, first, how the `add()` method returns `false` when we try to add element
    `s1` the second time. Then look at the last line of the code above and observe
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only one element `s1` was added to the set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the elements is not preserved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last observation is important. The Java Specification explicitly states
    that, by contrast with `List`, `Set` does not guarantee the order of the elements.
    It can be different when the same code is run on different JVM instances or even
    at different runs on the same instance. The factory methods `Set.of()` shuffle
    the unordered collections a bit while creating them (we will talk about collections
    factory methods in [Chapter 14](5c3dd438-a957-4fcc-b8e8-045ea7b43277.xhtml), *Managing
    Collections and Arrays)*. This way, an inappropriate reliance on a certain order
    of the elements of `Set` and other unordered collections can be discovered earlier,
    before the code is deployed to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: size(), isEmpty(), and clear()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These three methods are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size()`: It returns count of elements in the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty()`: It returns `true` if there is no elements in the list (`size()` returns
    0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: It removes  all elements from the list, so that `isEmpty()` returns `true` and `size()` returns
    0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate and stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This `Set` functionality is not different from `List` as described previously,
    because every collection that implements the `Collection` interface also implements
    the `Iterable` interface (because `Collection` extends `Iterable`) Set can be
    iterated using a traditional enhanced `for` statement or its own method `forEach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set set = new HashSet();
  prefs: []
  type: TYPE_NORMAL
- en: set.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: set.add(1);
  prefs: []
  type: TYPE_NORMAL
- en: set.add("ss");
  prefs: []
  type: TYPE_NORMAL
- en: set.add(new A());
  prefs: []
  type: TYPE_NORMAL
- en: set.add(new B());
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Object o: set){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(o);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: set.forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda Expressions
    and Functional Programming*, we will explain how the function can be passed as
    a parameter of the method `forEach()`. The result of both iteration styles is
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acd75458-ede5-4fa8-938a-ec78ec470e33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The other related methods that come from the interface `Iterable` are the same
    as in the `List` interface too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iterator()`: It returns an object of class `Iterator` that allows walking
    through (iterate) each element of the collection and manipulating each of them
    as needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`splititerator()`: It returns an object of class `Splititerator` that allows
    splitting the collection for parallel processing (discussion of this functionality is
    outside the scope of this book)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Iterator` interface returned by the `iterator()` method has the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`next()`: It returns the next element in the iteration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasNext ()`: It returns `true` if the iteration has more elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachRemaining (Consumer<? super E> function)`: It applies the provided
    function to each of remaining elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()`: It removes from the underlying collection the last element returned
    by this iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `next()` and `hasNext()` methods are used by `for` statements behind the
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to iterate over collection elements using objects of the
    `Stream` class that can be obtained by the methods `stream()` and `parallelStream()`.
    We will show you how to do this in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines.*
  prefs: []
  type: TYPE_NORMAL
- en: Adding using generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of `List`, generics can be used with `Set`, too (or any collection
    for that matter). The rules and `Set` behavior with generics are exactly the same
    as described for `List` in the section *List – ArrayList preserves order* (subsection
    *Add using generics*).
  prefs: []
  type: TYPE_NORMAL
- en: Adding collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `addAll(Collection<? extends E> collection)` method adds the provided collection
    of objects to a set, but only those that are not present already in the set. The
    method returns the Boolean value `true` if the set was changed, and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: The generic `<? extends E>` means type `E` or any subtype of `E`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set1 = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1.addAll(list)); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1);              //prints: [s3, s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s4");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1.addAll(list)); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1);              //prints: [s3, s4, s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing equals() and hashCode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have talked about implementing the methods `equals()` and `hashCode()` several
    times already and here will only repeat that, if your class is going to be used
    as a `Set` element, both methods have to be implemented. See the explanation in
    the preceding *Why is it called HashSet?* section.
  prefs: []
  type: TYPE_NORMAL
- en: Locating element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only `Set` functionality related to the location of a particular element
    directly is provided by the `contains(E)` method, which returns `true` if the
    provided element is present in the set. You can also iterate and locate the element
    this way, using the `equals()` method, but it is not a direct location.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By contrast with `List`, it is not possible to retrieve an element from `Set`
    directly, because you cannot use index or another way to point to the object.
    But it is possible to iterate through the set as was described previously, in
    the subsection *Iterate and stream*.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four methods in the `Set` interface that remove (delete) elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove(E)`: It removes the provided element and returns `true` if the list
    contained it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeAll(Collection)`: It removes the provided elements and returns `true` if
    the list has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retainAll(Collection)`: It removes all the elements that are not in the provided
    collection and returns `true` if the list has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeIf(Predicate<? super E> filter)`: It removes all the elements that for
    which the provided predicate returns `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three methods behave the same way as with the `List` collection, so
    we will not repeat the explanations(see the subsection *Remove elements* of the
    section *List – ArrayList preserves order*).
  prefs: []
  type: TYPE_NORMAL
- en: As for the last of the listed methods, a predicate is a function that returns
    a Boolean value. It is another example of a functional interface (an interface
    that has only one abstract method) and functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: The notation `Predicate<? super E>` means a function that accepts a parameter
    of type `E` or any of its base (parent) class and returns a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk more about functions in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*. Meanwhile, the following example
    shows how the `removeIf()` method can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet();
  prefs: []
  type: TYPE_NORMAL
- en: set.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s4");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(set);    //[null, s3, s4, s1, s2]
  prefs: []
  type: TYPE_NORMAL
- en: set.removeIf(e -> "s1".equals(e));
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(set);   //[null, s3, s4, s2]
  prefs: []
  type: TYPE_NORMAL
- en: set.removeIf(e -> e == null);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(set);    //[s3, s4, s2]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Please, notice how we put `s1` first when trying to find the element `e` that
    equals `s1`. It does not match the way we express it in English, but it helps
    to avoid `NullPointerException` in case one of the elements is `null` (as it was
    in our case).
  prefs: []
  type: TYPE_NORMAL
- en: Replacing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By contrast with `List`, it is not possible to replace an element in `Set` directly,
    because you cannot use index or another way to point to the object. But it is
    possible to iterate through the set as was described previously, or by using a `Stream` object
    (we will discuss this in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipelines)* and check each element and see if this is the one you are looking
    to replace. Those elements that did not match the criteria, you can add to a new
    set. And those you would like to replace, skip and add another object (that will
    replace the one you skip) to the new set:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet();
  prefs: []
  type: TYPE_NORMAL
- en: set.add(null);
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(set);    //[null, s3, s2]
  prefs: []
  type: TYPE_NORMAL
- en: //We want to replace s2 with s5
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> newSet = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: set.forEach(s -> {
  prefs: []
  type: TYPE_NORMAL
- en: if("s2".equals(s)){
  prefs: []
  type: TYPE_NORMAL
- en: newSet.add("s5");
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: newSet.add(s);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: set = newSet;
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(set);    //[null, s3, s5]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: After we switch reference from original set to a new set (`set = newSet`), the
    original set will be eventually removed from memory by the garbage collector and
    the result will be the same as if we have just replaced that one element in the
    original set.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Set` interface does not allow sorting and does not guarantee order preservation.
    If you need these features added to the set, you can use the interfaces `java.util.SortedSet` or
    `java.util.NavigableSet` and their implementations `java.util.TreeSet` or `java.util.ConcurrentSkipListSet`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing with another collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Java collection implements the `equals()` method, which compares it with
    another collection. In the case of `Set`, two sets are considered equal (`set1.equals(set2)` returns `true`)
    when:'
  prefs: []
  type: TYPE_NORMAL
- en: Each collection is of type `Set`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have the same size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each element of one set is contained in another set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code illustrates the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set1 = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: List<String> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: list.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1.equals(list)); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding collections are not equal because they are of different types.
    Now, let''s compare two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set2 = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: set2.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: set2.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1.equals(set2)); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: set2.remove("s3");
  prefs: []
  type: TYPE_NORMAL
- en: set2.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1.equals(set2)); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding sets are equal or not depending on the composition of their elements,
    even if the size of the sets is the same.
  prefs: []
  type: TYPE_NORMAL
- en: If two sets are equal, their `hashCode()` methods return the same integer value.
    But the equality of the `hashCode()` result does not guarantee that the sets are
    equal. We have talked about the reason for that while discussing the `hashCode()` method's
    implementation in the preceding subsection *Implement equals() and hashCode()*.
  prefs: []
  type: TYPE_NORMAL
- en: The `containsAll(Collection)` method of the `Set` interface (or any collection
    that implements the `Collection` interface for that matter) returns `true` only
    if all elements of the provided collection are present in the set. If the size
    of the set and the size of the provided collection are equal, we can be sure that
    the same (well, equal) elements compose each of the compared collections. It does
    not guarantee though that the elements are of the same type, because they might
    be children of different generations with the `equals()` method implemented only
    in the common parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, we can find the difference using the methods `retainAll(Collection)`
    and `removeAll(Collection)`, described earlier in this section. Let''s assume
    we have two lists as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set1 = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s3");
  prefs: []
  type: TYPE_NORMAL
- en: set1.add("s4");
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set2 = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: set2.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set2.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: set2.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: set2.add("s5");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find which elements in one set are not present in the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet<>(set1);
  prefs: []
  type: TYPE_NORMAL
- en: set.removeAll(set2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set);    //prints: [s3, s4]'
  prefs: []
  type: TYPE_NORMAL
- en: set = new HashSet<>(set2);
  prefs: []
  type: TYPE_NORMAL
- en: set.removeAll(set1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set);    //prints: [s5]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we have created a temporary set to avoid corruption of the original
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `Set` does not allow duplicate elements, there is no need to use the
    `retainAll(Collection)` method for the purpose of finding more differences between
    the sets, like we did for `List`. Instead, the `retainAll(Collection)` method
    can be used to find common elements in two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet<>(set1);
  prefs: []
  type: TYPE_NORMAL
- en: set.retainAll(set2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set);    //prints: [s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: set = new HashSet<>(set2);
  prefs: []
  type: TYPE_NORMAL
- en: set.retainAll(set1);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set);    //prints: [s1, s2]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can from the preceding code, to find the common elements between two
    sets, it is enough to use the `retainAll()` method only once, no matter which
    set is the main and which one is used as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Also, please notice that neither the `retainAll(Collection)` nor the `removeAll(Collection)`
    method guarantee that the compared set and the collection passed in contain elements
    of the same type. They might be a mix of children with a common parent that have
    the `equals()` method implemented in the parent only, and the parent type is the
    type of the set and the collection passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Converting to array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two methods that allow converting a set to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toArray()`: It converts the set to array `Object[]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toArray(T[])`: It converts the set to array `T[]`, where `T` is the type of
    the elements in the set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both methods preserve the order of the elements only in the case the set preserves
    order too, such as `SortedSet` or `NavigableSet`, for example. Here is the demo
    code that shows how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Set<String> set = new HashSet<>();
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s1");
  prefs: []
  type: TYPE_NORMAL
- en: set.add("s2");
  prefs: []
  type: TYPE_NORMAL
- en: Object[] arr1 = set.toArray();
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Object o: arr1){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(o);       //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr2 = set.toArray(new String[set.size()]);
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String s: arr2){'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(s);     //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet, there is another way to convert a set, or any collection for that matter,
    to an array – using a stream and functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Object[] arr3 = set.stream().toArray();
  prefs: []
  type: TYPE_NORMAL
- en: 'for (Object o : arr3) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(o);       //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: String[] arr4 = set.stream().toArray(String[]::new);
  prefs: []
  type: TYPE_NORMAL
- en: 'for (String s : arr4) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(s);       //prints: s1s2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Streams and functional programming have made many traditional coding solutions
    obsolete. We will discuss them in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming* and in [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml), *Streams
    and Pipeline*.
  prefs: []
  type: TYPE_NORMAL
- en: Set implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many classes that implement the `Set` interface for various purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the `HashMap` class in this section; it is by far the most
    popular `Set` implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LinkedHashSet` class stores unique elements in order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TreeSet` class orders its elements based on their values natural order
    or using the `Comparator` provided at creation time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other classes referred in the online documentation of the `Set` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map – HashMap stores/retrieves objects by key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Map` interface itself is not related to the `Collection` interface directly,
    but it uses the `Set` interface for its keys and `Collection` for its values.
    For example, for `Map<Integer, String> map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<Integer> keys = map.keySet();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<String> values = map.values();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each value is stored in a map with a unique key that is passed in along with
    the value when added to the map. In the case of `Map<Integer, String> map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: map.put(42, "whatever");        //42 is the key for the value "whatever"
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then later, the value can be retrieved by its key:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String v = map.get(42);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(v);     //prints: whatever'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: These are the basic map operations that convey the `Map` interface's purpose
    – to provide a storage for key-value pairs, where both—key and value—are objects
    and the class used as the key implements the `equals()` and  `hashCode()` methods,
    which override the default implementations in the `Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a closer look at the `Map` interface, its implementation, and
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Preferring variable type Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of `List` and `Set`, using type `Map` for the variable that holds
    a reference to the object of the class that implements the `Map` interface is
    a good programming practice called coding to an interface. It assures independence
    of the client code from any particular implementation. So, it is a good habit
    to write `Map<String, Person> persons = new HashMap<>()` to store all persons
    as values by their key – a social security number, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called HashMap?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, it should be already obvious to you that the reason the `HashMap` class
    has "Hash" in its name that it stores the keys using their hash values, calculated
    by the `hashCode()` method. Since we have already discussed it at great length
    in the previous sections, we are not going to talk here about hash value and its
    usage; you can refer back to the subsection *Why is it called HashSet?* in the
    previous section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and maybe replace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Map` interface stores key-value pairs, also called entries, because in
    a `Map`, each key-value pair is also represented by the `Entry` interface, which
    is a nested interface of `Map` and thus referred as `Map.Entry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key-value pair or an entry can be added to a `Map` using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V put(K, V)`: It adds a key-value pair (or creates a key-value association).
    If the provided key exists already, the method overrides the old value and returns
    it (if the old value was `null`, then `null` is returned). If the provided key
    is not in the map already, the method returns `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V putIfAbsent(K, V)`: It adds a key-value pair (or creates a key-value association).
    If the provided key exists already and the associated value is not `null`, the
    method does not override the old value but just returns it. If the provided key
    is not in the map already or if the associated value is `null`, the method overrides
    the old value and returns `null`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates the described functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.put(1, null));  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.put(1, "s1"));  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.put(2, "s1"));  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.put(2, "s2"));  //prints: s1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.put(3, "s3"));  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);               //prints: {1=s1, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.putIfAbsent(1, "s4"));  //prints: s1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);               //prints: {1=s1, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.put(1, null));  //prints: s1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);               //prints: {1=null, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.putIfAbsent(1, "s4"));  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);               //prints: {1=s4, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.putIfAbsent(4, "s4"));  //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);               //prints: {1=s4, 2=s2, 3=s3, 4=s4}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in a case where the returned value is `null`, there is some ambiguity
    about the result - whether the new entry was added (and replaced the entry with
    value `null`) or not. So, one has to pay attention while using the described methods
    on the maps that may contain a `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: There are also the `compute()` and `merge()` methods, which allow you to add
    and modify data in the map, but their usage is much too complex for the introductory
    course, so we will leave them out of this discussion. Besides, they are not very
    often used in mainstream programming.
  prefs: []
  type: TYPE_NORMAL
- en: size(), isEmpty(), and clear()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These three methods are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size()`: It returns count of key-value pairs (entries) in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty()`: It returns `true` if there is nokey-value pairs (entries) in the
    map (`size()` returns 0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: It removes  allkey-value pairs (entries) from the map, so that `isEmpty()`
    returns `true` and `size()` returns 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterate and stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to iterate over the map content using the following
    `Map` methods, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set<K> keySet()`: It returns the keys associated with the values stored in
    the map. One can iterate over this set and retrieve from the map the value for
    each key (see the preceding section for who to iterate over a set).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection<V> values()`: It returns the values stored in the map. One can
    iterate over this collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Set<Map.Entry<K,V>> entrySet()`: It returns the entries (key-value pairs)
    stored in the map. One can iterate over this set and get the key and the value
    from each entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach (BiConsumer<? super K,? super V> action)`: It iterates over key-value
    pairs stored in the map and provides them as an input into the function `BiConsumer`,
    which accepts two parameters of the map key and value types and returns `void`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how to read the notation `BiConsumer<? super K,? super V>`: It describes
    a function. The `Bi` in the function''s name indicates that it accepts two parameters:
    one of type `K` or any of its superclasses and another of type `V` or any of its
    superclasses. The `Consumer` in the functions name indicates that it returns nothing
    (`void`).'
  prefs: []
  type: TYPE_NORMAL
- en: We will talk more about functional programming in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the preceding methods, we are going to use the following map:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is how this map can be iterated:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Integer key: map.keySet()){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("key=" + key + ", value=" + map.get(key));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: map.keySet().stream()
  prefs: []
  type: TYPE_NORMAL
- en: .forEach(k->System.out.println("key=" + k + ", value=" + map.get(k)));
  prefs: []
  type: TYPE_NORMAL
- en: 'for(String value: map.values()){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("value=" + value);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: map.values().stream().forEach(System.out::println);
  prefs: []
  type: TYPE_NORMAL
- en: map.forEach((k,v) -> System.out.println("key=" + k + ", value=" + v));
  prefs: []
  type: TYPE_NORMAL
- en: map.entrySet().forEach(e -> System.out.println("key=" + e.getKey() +
  prefs: []
  type: TYPE_NORMAL
- en: '", value=" + e.getValue()));'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding methods produce the same results, except the `values()` method,
    which returns only values. Which one to use is a matter of style, but it seems
    that `map.forEach()` requires fewer keystrokes to implement the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Adding using generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From our examples, you have seen already how generics can be used with `Map`.
    It provides a valuable help to a programmer by allowing the compiler to check
    the match between the map and the objects one tries to store in it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding another Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `putAll(Map<? extends K, ? extends V> map)` method adds each key-value
    pair from the provided map the same way the `put(K, V)` method does for one pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map1 = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map1.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map1.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map1.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map2 = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map2.put(1, "s1");
  prefs: []
  type: TYPE_NORMAL
- en: map2.put(2, null);
  prefs: []
  type: TYPE_NORMAL
- en: map2.put(4, "s4");
  prefs: []
  type: TYPE_NORMAL
- en: map1.putAll(map2);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map1); //prints: {1=s1, 2=null, 3=s3, 4=s4}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `putAll()` method adds a new pair or overrides a value in
    the existing pair (based on the key) and does not return anything.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing equals() and hashCode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are going to use the class you are writing as a key in a `Map`, implementing
    both the `equals()` and `hashCode()` methods is very important. See the explanation
    in the preceding section, *Why is it called HashSet?* In our examples, we have
    used objects of the `Integer` class as keys. This class has an implementation
    of both these methods based on the integer value of the class.
  prefs: []
  type: TYPE_NORMAL
- en: The class that is going to be stored as a value in a `Map` has to implement
    the `equals()` method, at least (see the next subsection, *Locate element*).
  prefs: []
  type: TYPE_NORMAL
- en: Locating element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two methods answer the question if the particular key of value
    is present in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '`containsKey(K)`: It returns `true`, if the provided key is present already'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containsValue(V)`: It returns `true`, if the provided value is present already'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both methods rely on the `equals()` method to identify the match.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve elements from a `Map`, you can use any of the following four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V get(Object K)`: It returns the value by the provided key, or `null` if the
    provided key is not in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`V getOrDefault(K, V)`: It returns the value by the provided key, or the provided
    (default) value if the provided key is not in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map.Entry<K,V> entry(K,V)`: A static method that converts the provided key-value
    pair into an immutable object of `Map.Entry` (immutable means it can be read,
    but cannot be changed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Map<K,V> ofEntries(Map.Entry<? extends K,? extends V>... entries)`: It creates
    an immutable map based on the provided entries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code demonstrates these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.get(2));                 //prints: s2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.getOrDefault(2, "s4"));  //prints: s2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.getOrDefault(4, "s4"));  //prints: s4'
  prefs: []
  type: TYPE_NORMAL
- en: Map.Entry<Integer, String> entry = Map.entry(42, "s42");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(entry);      //prints: 42=s42'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> entries =
  prefs: []
  type: TYPE_NORMAL
- en: Map.ofEntries(entry, Map.entry(43, "s43"));
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(entries);   //prints: {42=s42, 43=s43}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: And it is always possible to retrieve elements of a map by iterating, as we
    have described in the subsection *Iterate and stream*.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two methods allow the direct removal of Map elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V remove(Object key)`: It removes an object associated with the key and returns
    its value, or, if such a key is not present in the map, returns `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean remove(Object key, Object value)`: It removes an object associated
    with the key only if the current value associated with the key equals the provided
    one; returns `true`, if the element was removed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that illustrates the described behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.remove(2));        //prints: s2'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                  //prints: {1=null, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.remove(4));        //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                  //prints: {1=null, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.remove(3, "s4"));  //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                  //prints: {1=null, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.remove(3, "s3"));  //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                  //prints: {1=null}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also another way to remove a `Map` element by key. If the key from
    the map is removed, the corresponding value is removed too. Here is the code that
    demonstrates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: Set<Integer> keys = map.keySet();
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(keys.remove(2));      //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                 //prints: {1=null, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(keys.remove(4));      //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                 //prints: {1=null, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the methods `removeAll(Collection)`, `retainAll(Collection)`, and `removeIf(Predicate<?
    super E> filter)` from the `Set` interface, described in the subsection *Remove
    elements* of the section *Set - HashSet does not allow duplicates**,* can be used
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To replace elements of the `Map`, one can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`V replace(K, V)`: It replaces the value with the provided one only if the
    provided key is present in the map; returns the previous (replaced) value if such
    a key is present or `null` if such a key is not in the map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean  replace(K, oldV, newV) `: It replaces the current value (`oldV`)
    with a new one (`newV`) only if the provided key is present in the map and is
    currently associated with the provided value `oldV`; returns `true` if the value
    was replaced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)`:
    It allows you to replace the values using a provided function that takes two parameters—key
    and value—and returns a new value that will replace the current one in this key-value
    pair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how to read the notation `BiFunction<? super K, ? super V, ? extends
    V>`: It describes a function. The `Bi` in the function''s name indicates that
    it accepts two parameters: one of type `K` or any of its superclasses and another
    of type V or any of its superclasses. The `Function` part in the functions name
    indicates that it returns something. The returned value is listed the last. In
    this case, it is `<? extends V>`, which means value of type `V` or any of its
    subclasses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the map we are going to change is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code that illustrates the first two methods looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.replace(1, "s1"));   //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                    //prints: {1=s1, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.replace(4, "s1"));   //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                    //prints: {1=s1, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.replace(1, "s2", "s1"));   //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                    //prints: {1=s1, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map.replace(1, "s1", "s2"));   //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                    //prints: {1=s2, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And here is the code that helps to understand how the last of the listed replacing
    methods works:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(2, null);
  prefs: []
  type: TYPE_NORMAL
- en: map.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: 'map.replaceAll((k,v) -> v == null? "s" + k : v);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                 //prints: {1=s1, 2=s2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'map.replaceAll((k,v) -> k == 2? "n2" : v);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                 //prints: {1=s1, 2=n2, 3=s3}'
  prefs: []
  type: TYPE_NORMAL
- en: 'map.replaceAll((k,v) -> v.startsWith("s") ? "s" + (k + 10) : v);'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map);                 //prints: {1=s11, 2=n2, 3=s13}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we were able to use the `v.startsWith()` method only after we had
    replaced all the `null` values with something else. Otherwise, this line could
    throw a `NullPointerException` and we would need to change it for the following
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: map.replaceAll((k,v) -> (v != null && v.startsWith("s")) ?
  prefs: []
  type: TYPE_NORMAL
- en: '"s" + (k + 10) : v);'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Map` interface does not allow sorting and does not guarantee order preservation.
    If you need these features added to the map, you can use the interfaces `java.util.SortedMap`
    or `java.util.NavigableMap`, and their implementations `java.util.TreeMap` or
    `java.util.ConcurrentSkipListMap`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing with another collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Java collection implements the `equals()` method, which compares it with
    another collection. In the case of `Map`, two maps are considered equal (`map1.equals(map2)` returns `true`)
    when:'
  prefs: []
  type: TYPE_NORMAL
- en: Both are `Map` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One map has the same set of key-value pairs as another map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code that illustrates the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map1 = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map1.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map1.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map1.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: Map<Integer, String> map2 = new HashMap<>();
  prefs: []
  type: TYPE_NORMAL
- en: map2.put(1, null);
  prefs: []
  type: TYPE_NORMAL
- en: map2.put(2, "s2");
  prefs: []
  type: TYPE_NORMAL
- en: map2.put(3, "s3");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map2.equals(map1)); //prints: true'
  prefs: []
  type: TYPE_NORMAL
- en: map2.put(1, "s1");
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(map2.equals(map1)); //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, the `map1.equals(map2)` method returns exactly the same
    result as the `map1.entrySet().equals(map2.entrySet())` method, because the `entrySet()` method
    returns `Set<Map.Entry<K,V>` and we know (see the subsection *Compare with another
    collection* for `Set`) that two sets are equal when each element of one set is
    contained in another set.
  prefs: []
  type: TYPE_NORMAL
- en: If two maps are equal, their `hashCode()` methods return the same integer value.
    But the equality of `hashCode()` results does not guarantee that the maps are
    equal. We have talked about the reason for that while discussing the `hashCode()` method's
    implementation for the elements of the `Set` collection in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'If two maps are not equal and there is a need to find out exactly what the
    difference is, there are a variety of ways to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: map1.entrySet().containsAll(map2.entrySet());
  prefs: []
  type: TYPE_NORMAL
- en: map1.entrySet().retainAll(map2.entrySet());
  prefs: []
  type: TYPE_NORMAL
- en: map1.entrySet().removeAll(map2.entrySet());
  prefs: []
  type: TYPE_NORMAL
- en: map1.keySet().containsAll(map2.keySet());
  prefs: []
  type: TYPE_NORMAL
- en: map1.keySet().retainAll(map2.keySet());
  prefs: []
  type: TYPE_NORMAL
- en: map1.keySet().removeAll(map2.keySet());
  prefs: []
  type: TYPE_NORMAL
- en: map1.values().containsAll(map2.values());
  prefs: []
  type: TYPE_NORMAL
- en: map1.values().retainAll(map2.values());
  prefs: []
  type: TYPE_NORMAL
- en: map1.values().removeAll(map2.values());
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Using any combination of these methods, one can get the full picture of the
    difference between the two maps.
  prefs: []
  type: TYPE_NORMAL
- en: Map implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many classes that implement the `Map` interface for various purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HashMap`, which we have discussed in this section; it is by far the most popular `Map` implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LinkedHashMap` class stores its key-value pairs in their insertion order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TreeMap` class orders its key-value pairs based on the keys natural order
    or using the `Comparator` provided at creation time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many other classes referred to in the online documentation of the `Map` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – EnumSet methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We did not talk about the collection `java.util.EnumSet`. It is lesser known
    but very useful class in cases where you need to work with some `enum` values. Look
    up its API online and write code that demonstrates the usage of its four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`of()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`complementOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming the `enum` class looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: enum Transport { AIRPLANE, BUS, CAR, TRAIN, TRUCK }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the code that demonstrates the four methods of `EnumSet` may look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: EnumSet<Transport> set1 = EnumSet.allOf(Transport.class);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set1);   //prints: [AIRPLANE, BUS, CAR, TRAIN, TRUCK]'
  prefs: []
  type: TYPE_NORMAL
- en: EnumSet<Transport> set2 = EnumSet.range(Transport.BUS, Transport.TRAIN);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set2);   //prints: [BUS, CAR, TRAIN]'
  prefs: []
  type: TYPE_NORMAL
- en: EnumSet<Transport> set3 = EnumSet.of(Transport.BUS, Transport.TRUCK);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set3);   //prints: [BUS, TRUCK]'
  prefs: []
  type: TYPE_NORMAL
- en: EnumSet<Transport> set4 = EnumSet.complementOf(set3);
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(set4);   //prints: [AIRPLANE, CAR, TRAIN]'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has made the reader familiar with the Java collections and the
    most popular ones - the `List`, `Set`, and `Map` interfaces. The code examples
    made their functionality more clear. The comments of the code attracted the reader's
    attention to the possible pitfalls and other useful details.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to overview the most popular classes of
    the Java Standard Library and Apache Commons. Most of them are utilities, such
    as `Objects`, `Collections`, `StringUtils`, and `ArrayUtils`. Others are just
    classes, such as `StringBuilder`, `StringBuffer`, and `LocalDateTime`. Some help
    to manage collections; others, objects. What is common among them is that they
    belong to the small set of tools that every Java programmer has to master before
    they can become effective coders.
  prefs: []
  type: TYPE_NORMAL
