- en: AWS II–S3, SQS, API Gateway, and DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll continue covering the massive topic of Amazon Web Services.
    In this chapter, we'll cover the S3 service, SQS service, AWS API Gateway service,
    and DynamoDB service. Every single one of these services is a powerful tool in
    your arsenal to build production applications deployed on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The AWS S3 storage service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQS message queue service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AWS API gateway service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DynamoDB database service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple Storage Service (S3)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon S3 is an AWS service responsible for storing and analyzing data. The
    data typically includes files of all sorts and shapes (including music files,
    photos, text files, and video files). S3, for example, can be utilized to store
    code files for static data. Let's take a tour of how to use the S3 service in
    AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring S3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The S3 service stores files in buckets. Each bucket can hold files directly
    or can include a number of folders, and, in turn, each folder can hold a number
    of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the AWS web console to configure S3, similar to what we did with
    EC2\. The first step will be to navigate to the AWS web console and then select
    S3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa3ea49a-4f8e-4191-bfb1-ddc51cd6d8d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the Amazon S3 console; from there, we can click on Create bucket
    to create a new bucket to store data folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2cb783f-9073-4468-8c89-c36969afa322.png)'
  prefs: []
  type: TYPE_IMG
- en: This will start a wizard that will walk you through the different steps needed
    to properly create a bucket. This will give you the power to set the bucket name,
    enable versioning or logging, set tags, and set permissions. Once done, a new
    bucket will get created for you. The bucket name has to be unique so that it won't
    get conflicted with buckets used by other AWS users.
  prefs: []
  type: TYPE_NORMAL
- en: 'I created a bucket called `mnandbucket`; it will show up in the list of buckets
    in my S3 main web page. If you have more buckets than what the page can show,
    you can search for buckets in the search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9209eb72-1f0b-412b-8674-e8f855a5c7d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we enter a bucket, we can then create folders and upload files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84fb98d0-037a-4d65-b425-8a8de899ec32.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect! With that, we have a practical idea of what S3 is about.
  prefs: []
  type: TYPE_NORMAL
- en: You can download this file from [https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Cloud-Native-Programming-with-Golang](https://github.com/PacktPublishing/Cloud-Native-programming-with-Golang).
  prefs: []
  type: TYPE_NORMAL
- en: S3 storage can be utilized to store our application files for later use. So,
    for example, say we built our `events` microservice to run in a Linux environment,
    and the filename for the application is simply `events`. We can then simply store
    the file in an S3 folder; then, whenever we need an EC2 instance to obtain the
    file, we can use the AWS command-line tools in the Ec2 instance to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to ensure that the AWS roles are properly defined to allow our
    EC2 instance to access the S3 storage as was covered earlier. Then, from there,
    to copy the file from S3 to our EC2 instance, we will need to issue the following
    command from our EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will retrieve the `events` file from the S3 storage, then
    copy it to a new file called `my_local_events_copy`, which will live in the current
    folder. `<my_bucket>` and `<my_folder>` represent the bucket and the folder where
    the events file exists on the S3 storage, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we copy an executable file to EC2, we will need to give it access to
    execute via the Linux `chmod` command. This is achieved utilizing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, `<my_executable_file>` is the file that we would like
    to obtain enough access in our EC2 instance to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Queue Service (SQS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, SQS is the message queue provided by AWS. Applications
    that can interact with SQS can send and receive messages within the AWS ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by discussing how to configure an SQS from the Amazon console.
    As usual, the first step is to log in to the Amazon console and then select our
    service from the main dashboard. The service name in this case will be called
    Simple Queue Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffd92463-21cb-4417-a776-8e51ca287e69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, we will need to either click on Getting started or on Create New
    Queue. The queue creation page will offer us the ability to configure the behavior
    of the new queue. For example, we can set the maximum message size allowed, the
    number of days we can retain a message, or even the wait time to receive a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d01b6f1b-b33e-4864-8925-295cc565b8f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you are satisfied with your settings, click on Create Queue—I picked the
    name `eventqueue`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5027860c-394a-4bde-9e32-7a8c8b3ee3f5.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create a new AWS SQS queue that we can utilize in our code. Now, it's
    time to discuss how we can write code to interact with our new queue.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! With our queue created, we are ready to write some code to send and
    receive messages via the newly created AWS SQS queue. Let's start with exploring
    the code we need to write in order to send some data.
  prefs: []
  type: TYPE_NORMAL
- en: The docs for the AWS SDK Go SQS package can be found at [https://godoc.org/github.com/aws/aws-sdk-go/service/sqs](https://godoc.org/github.com/aws/aws-sdk-go/service/sqs).
  prefs: []
  type: TYPE_NORMAL
- en: 'As any other AWS service, there are two first key steps we will need to get
    out of the way:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining or creating a session object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a service client for our desired AWS service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding steps are covered via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets the region via the code when calling the `NewSession()` constructor;
    however, we have the choice to use a shared configuration instead, as mentioned
    in the preceding chapter. I made use of `log.Fatal()` in this code since it's
    only testing code, so if anything fails, I would want to exit with the error message
    reported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to obtain the message queue URL. The URL is important because
    it serves as a unique identifier for the message queue in the SDK method calls.
    We can obtain the URL either from the AWS console SQS page, where the URL of our
    queue will show in the Details tab when the queue is selected or via code by utilizing
    the queue name we chose when creating our queue. In my case, I called my queue
    `eventqueue`; so, let''s take a look at how we can obtain the URL from that name
    through our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `QUResult` object is of the `*GetQueueUrlOutput` type, which is a pointer
    to a struct that contains a field called `QueueUrl` of the `*string` type. This
    field should have our queue URL if the `GetQueueUrl()` method  is executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! Now that we have the URL of our queue, we are ready to send some data
    over the message queue. However, before we do that, we will need to cover some
    important definitions to understand the code that is yet to come.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message body***:* A message body is simply the core message we are trying
    to send. For example, if I want to send a hello message via SQS, then the message
    body would be hello.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message attributes***:* Message attributes are a collection of structured
    metadata items. You can think of them simply as a list of key value pairs that
    you can define and send with your message. Message attributes are optional; however,
    they can be powerful because they allow sending messages that are more structured
    and sophisticated than just text. Message attributes allow us to understand what
    the message might contain before we start processing the message body. We can
    include up to 10 message attributes per message. Message attributes support three
    main data types: string, number, and binary. A Binary type represents binary data
    such as compressed files and images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s return to our sample code; let''s say that we want to send a message
    via SQS for our events app to represent a customer reservation for  some concerts;
    our message will have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message attributes**: We would like two message attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message_type`: The type of the message we are trying to send—in our case,
    the value of this attribute will be "RESERVATION"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: The number of reservations included in this message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message body**: This entails the reservation data in JSON format. The data
    includes the customer names reserving the concert and the event name (the concert,
    in this case)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes use of the `SendMessage()` method to send the message. `SendMessage()` takes
    an argument of the `*SendMessageInput{}` type, which is where we define the message
    attributes, message body, and where we identify the queue URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, we can then check whether any error occurred. We can obtain the
    ID for the message we created via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! With this piece of sample code, we now know how to send message over
    SQS. Now, let's learn how to receive them.
  prefs: []
  type: TYPE_NORMAL
- en: There are some concepts that we will need to cover and questions we will need
    answered before we start looking into the message receiving code. Let's assume
    that we have a microservice architecture where more than one microservices are
    reading messages from an SQS message queue. An important question to answer is,
    what do we do after one of our services receives a message? Should that message
    be allowed to be received by the other services afterward? The answer for those
    two questions depends on the purpose of the said message. If the message is supposed
    to be consumed and processed once, then we will need to ensure that the first
    service to properly receive this message should then delete it from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of AWS SQS, a message does not get deleted from the queue when
    it gets received in a standard queue. We will instead need to explicitly delete
    the message from the queue after we receive it in order to ensure that it disappears,
    if that's our intention. However, there is another complication. Let's assume
    that microservice A received a message and started processing it. However, before
    microservice A got to deleting the message from the queue, microservice B received
    the message and started processing it, which we don't want.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid that scenario, SQS introduces a concept called **visibility timeout**.
    A visibility timeout simply makes a message invisible for a certain period of
    time after it gets received by one consumer. This timeout gives us some time to
    decide what to do with the message before other consumers get to see it and process
    it.
  prefs: []
  type: TYPE_NORMAL
- en: One important remark is that there is not always a guarantee against receiving
    a message twice. The reason for that is because SQS queues are typically distributed
    among multiple servers. There are rare cases where a delete request doesn't reach
    the server because it is offline, which means the message might survive despite
    a delete request.
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept in the world of SQS is long polling or wait time.
    Since SQS is distributed and might have some delays every now and then, some messages
    might be slow to be received. If we care about receiving messages even if they
    are slow, then we will need to wait longer when listening to incoming messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample piece of code that shows receiving a message from
    a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we attempt to listen to incoming message from the SQS
    queue, which we created. We use the `GetQueueURL()` method as before to retrieve
    the queue URL to utilize in the `ReceiveMessage()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `ReceiveMessage()` method allows us to specify the message attributes (which
    we discussed earlier) that we would like to capture, as well as the general  system
    attributes. System attributes are general properties of the message, such as the
    time stamp that came with it. In the preceding code, we ask for all the message
    attributes, but only for the message time stamp system attribute.
  prefs: []
  type: TYPE_NORMAL
- en: We set the maximum number of messages we would like to receive in a single call
    to be 10\. It is important to point out that this is only the maximum number of
    message requested, so it is common to receive less. Finally, we will set the polling
    time to be a maximum of 20 seconds. If we receive messages faster than 20 seconds,
    the call returns with the captured messages without having to wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what should we do with the captured messages? For the sake of showcasing
    code, let''s say that we would like to print the message body and message attributes
    to the standard output. Afterward, we delete the messages. Here is what this would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding code, we used an object called `msg.ReceiptHandle` in
    the `DeleteMessage()` method in order to identify the message we would like to
    delete. ReceiptHandle is an object that we obtain whenever we receive a message
    from the queue; the purpose of this object is to allow us to delete the message
    that we received afterward. Whenever a message is received, a ReceiptHandle is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we received the message in the preceding code and then dissect it:'
  prefs: []
  type: TYPE_NORMAL
- en: We call `msg.Body` to retrieve the body of our message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `msg.MessageAttributes` to obtain the message attributes of our message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call `msg.Attributes` to obtain the system attributes that came with our
    message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we have enough knowledge to implement an SQS message queue emitter
    and listener for our `events` application. In a previous chapter, we created two
    key interface that need to be implemented for message queues in our application.
    One of them was the emitter interface, which was responsible for sending a message
    over a message queue. The other was the listener interface, which was responsible
    for receiving a message from a message queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick refresher, how is what the emitter interface looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, here is what the listener interface looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Listen` method takes a list of event names, then return those events in
    a channel, as well as any errors occurred while trying to receive the events via
    the message queue. This is called the channel generator pattern.
  prefs: []
  type: TYPE_NORMAL
- en: So, for our application to support the SQS message queue, we will need to implement
    those two interfaces. Let's start with the `Emitter` interface. We'll create a
    new folder inside `./src/lib/msgqueue`; the new folder name will be `sqs`. Inside
    the `sqs` folder, we create two files—`emitter.go` and `listener.go`. `emitter.go`
    is where we will implement the emitter interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating a new object to implement the emitter interface—the object
    is called `SQSEmitter`. It will contain the SQS service client object, as well
    as the URL of our queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then need to create a constructor for our emitter. In the constructor,
    we''ll create the SQS service client from either an existing session or from a
    newly created session. We will also utilize the `GetQueueUrl` method in order
    to obtain the URL of our queue. Here is what this will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the `Emit()` method of the emitter interface.
    The message we will emit should have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It will contain a single message attribute called `event_name`, which will hold
    the name of the event we are trying to send. As covered before, in this book,
    an event name describes the type of the event our application is trying to process.
    We had three event names—`eventCreated`, `locationCreated`, and `eventBooked`.
    Remember here that `eventCreated` and `eventBooked` , refer to application events
    (and not message queue events) being created or booked, like concerts or circus
    acts for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will contain a message body, which will hold the event data. The message
    body will be in JSON format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have an SQS message queue implementation for the emitter interface.
    Now, let's discuss the listener interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listener interface will be implemented in the `./src/lib/msgqueue/listener.go` file.
    We start with the object that will implement the interface. The object name is
    `SQSListener`. It will contain the message queue event type mapper, the SQS client
    service object, the URL of the queue, the maximum number of messages to be received
    from one API call, the wait time for messages to be received, and the visibility
    timeout. Here is what this will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first start with the constructor; the code will be similar to the constructor
    we built for the emitter. We will ensure that we have an AWS session object, a
    service client object, and obtain the URL of our queue based on the queue name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, we will need to implement the `Listen()` method of the `listener`
    interface. The method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes a list of event names as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It listens to incoming messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it receives a message, it checks the message event name and compares it
    with the list of event names that were passed as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a message is received that does not belong to a requested event, it gets
    ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a message is received that belongs to a known event, it gets passed through
    the a Go channel of the 'Event' type to the outside world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages that are accepted get deleted after they pass through the Go channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any errors that occur get passed through another Go channel for error objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s focus on the code that will listen and receive messages for the time
    being. We will create a new method called `receiveMessage()` for that. Here is
    how it is broken down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we receive messages and pass any errors to a Go error channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then go through the received messages one by one and check their message
    attributes—if the event name does not belong to the list of requested event names,
    we ignore it by moving to the next message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we continue, we retrieve the message body, then use our event mapper object
    to translate it to an Event type that we can use in our external code. The event
    mapper object was created in [Chapter 4](0a806398-0654-46f9-8e6f-02af9334821b.xhtml),
    *Asynchronous Microservice Architectures Using Message Queues*; it simply takes
    an event name and the binary form of the event, then it returns an Event object
    to us. After that, we obtain the event object and pass it to the events channel.
    If we detect errors, we pass the error to the errors channel, then move to the
    next message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we reach to this point without errors, then we know we succeeded
    in processing the message. So, the next step will be to delete the message so
    that it won''t be processed by someone else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is great. You might wonder, however, how come we didn''t put this code
    directly in the `Listen()` method? The answer is simple: we did that to clean
    up our code and avoid one massive method. This is because the piece of code we
    just covered needs to be called in a loop so that we keep receiving messages from
    the message queue continuously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `Listen()` method. The method will need to call `receiveMessage()` in
    a loop inside a goroutine. The reason why a goroutine is needed is because otherwise
    the `Listen()` method would block its calling thread. Here is what this will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code first ensures that the `*SQSListener` object is not nil,
    then it creates the events and the errors Go channels to be utilized for communicating
    the results of the `receiveMessage()` method to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: AWS API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step in our quest to dive into cloud native applications is to take
    a tour into the AWS API gateway. As mentioned earlier, the AWS API gateway is
    a hosted service that allows developers to build flexible APIs for their applications.
    In this section, we will go through a practical introduction about the service
    and how it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the other services that we have covered so far, we will create an
    API gateway via the AWS console. The first step, as usual, would be to visit and
    log in to the AWS console at [aws.amazon.com](http://aws.amazon.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step would be to go to the home page, and then select API Gateway
    from under Application Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4769d0c-1552-453c-97eb-858fb84c6788.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will need to select API from the left-hand side, then click on Create
    API. This will start the process of creating a new API to use for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca26727e-794e-46a8-a48b-b373300c0a3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, we get to pick a name of our new API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fecc87a-19a7-464a-bc6a-deea81ef9aba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, after creating the API, we will need to create mappings between the AWS
    API gateway, and the addresses of the RESTful APIs embedded in our MyEvents application.
    The MyEvents application included more than one microservice. One of those microservices
    was the events services; it supported several tasks that could be activated via
    its RESTful API. As a refresher, here is a quick summary of the API tasks and
    examples of their relative URL addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Searching for events**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ID**: The relative URL is `/events/id/3434`, method is `GET`, and no data
    expected in the HTTP body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: The relative URL is `/events/name/jazz_concert`, method is `GET`,
    and no data expected in the HTTP body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieving all events at once**: The relative URL is `/events`, method is
    `GET`, and no data expected in the HTTP body'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating a new event**: The relative URL is `/events`, method is `POST`,
    and the expected data in the HTTP body needs to be the JSON representation of
    the new event we would like to add. Let’s say we would like to add the event of
    `opera aida` that would play in the U.S. Then, the HTTP body would look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Let's explore the events microservice API task by task and learn how to get
    the AWS API gateway to act as a front door to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding description, we have three relative URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/events/id/{id}`, where `{id}` is a number. We support `GET` HTTP requests
    with that URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/events/name/{name}`, where `{name}` is a string. We support `GET` HTTP requests
    with that URL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/events`, where we support `GET` and `POST` requests with this URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To represent those relative URLs with their methods in our AWS API gateway,
    we will need to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new resource and call it `events`. We will first visit our newly created
    API page. Then, from there, we will create a new resource by clicking on Actions
    and selecting Create Resource:![](img/0f3fdfa1-1a5b-484e-899b-6d84c1f92329.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that you set both the name and the path to `events` on the new resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f64e9d5-4c76-44f1-8619-dcb9dd28cf83.png)'
  prefs: []
  type: TYPE_IMG
- en: Afterwards, select the newly created `events` resource and create a new resource
    called `id`. Select the `events` resource again, but this time, create a new resource
    called `name`. Here is what this will look like:![](img/c3ee5533-1b7b-4d69-bf25-4fc82b937394.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `id` resource, then create a new resource. This time, call the resource
    name `id` again; however, the resource path needs to be `{id}`. This is important
    because it indicates that `id` is a parameter that can accept other values. Meaning
    that this resource can represent a relative URL that looks like this `/events/id/3232`:![](img/aac14ca8-f2ab-409e-8c10-9b70f2b7b08c.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similar to step 4, we will select the `name` resource, then create another resource
    underneath, which will have the resource name as `name` and the resource path
    as `{name}`. Here is what this will end up looking like:![](img/26f4531e-fb61-48cf-b537-ede864da0d7e.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, this should cover all our relative URLs. We need to attach the supported
    HTTP methods to their corresponding resources. First, we will go the `events`
    resource and then attach a `GET` method as well as a `POST` method to it. To do
    that, we need to click on s, then select Create Method:![](img/136c1c91-6bc1-4cb8-b5a0-1ee19ebc5beb.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then select GET as the method type:![](img/fb182a15-d591-4060-aafd-36923b802351.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then select the integration type of HTTP. From there, we will need to set
    the endpoint URL. The endpoint URL needs to be the absolute path of the API endpoint
    that corresponds to this resource. In our case, since we are under the 'events'
    resource, the absolute address for the resource on the 'events' microservice would
    be `<EC2 DNS Address>/events`. Let's assume that the DNS is `http://ec2.myevents.com`;
    this will make the absolute path `http://ec2.myevents.com/events`. Here is what
    this configuration will look like:![](img/7f554357-b403-4375-b3a6-8b06db91e1d6.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will repeat the preceding step; however, this time we will create a `POST`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We select the `{id}` resource, then create a new `GET` method. The `EndPoint`
    URL needs to include the `{id}`; here is what this will look like:![](img/9eb620b8-1220-4b85-8857-cfb8a0c7dc39.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will repeat the same step with the `{name}` resource; here is what the Endpoint
    URL will look like: `http://ec2.myevents.com/events/name/{name}`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perfect! With this, we created AWS API gateway mappings to our events microservice
    API. We can use the same technique to add more resources in our MyEvents API that
    would point to other microservices that belong to the MyEvents application. The
    next step is to deploy the API. The first thing we need to do is to create a new
    stage. A stage is a way to identify a deployed RESTful API that is callable by
    users. We will need to create a stage before we can deploy a RESTful API. To deploy
    an API, we will need to click on Actions and then on Deploy API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f19c7c-5bd3-48b3-b059-fc6327340fdc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we don''t already have a stage, we will need to select [New Stage] as our
    Deployment stage, then pick a stage name, and finally click on Deploy. I will
    call my stage `beta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4035639-deb8-48ed-85a4-bfd9e61d9a85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we deploy our RESTful API resources to a stage, we can start using it.
     We can find out the API URLs for our AWS API gateway door to our events microservice
    by navigating to Stages, then clicking on the desired resource to explore, the
    selected resource API URL is defined here as `Invoke URL`. In the below figure,
    we selected the events resource, the API URL can be found on the right hand side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/747e1c87-2da3-44a7-bbbb-90e4df64b407.png)'
  prefs: []
  type: TYPE_IMG
- en: DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DynamoDB is a very important part of the AWS ecosystem; it typically serves
    as the backend database for numerous cloud native applications. DynamoDB is a
    distributed high-performance database hosted in the cloud, which is offered as
    a service by AWS.
  prefs: []
  type: TYPE_NORMAL
- en: DynamoDB components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss how to write code that can interact with DynamoDB, we will
    need to first cover some important concepts regarding the database. DynamoDB consists
    of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tables***:* Like a typical database engine, DynamoDB stores data in a collection
    of tables. For example, in our MyEvents application, we can have an `events` table
    that would store events information such as concert names and start dates. Similarly,
    we can also have a `bookings` table to host booking information for our users.
    We can also have a `users` table to store our users information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Items***:* Items are nothing more than the rows of the DynamoDB tables. Information
    inside an item is known as attributes. If we take the `events` table as an example,
    an item would be a single event in that table. Similarly, if we take the `users` table
    as an example, each item is a user. Each item in the table needs a unique identifier,
    also known as primary key, that will distinguish the item from all the other items
    in the table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attributes**: As mentioned in the previous point, attributes represent the
    information inside an item. Each item consists of one or more attributes. You
    can think of an attribute as the holders of your data. Each attribute consists
    of an attribute name and attribute value. If we take the `events` table as an
    example, each `event` item will have an `ID` attribute to represent the event
    ID, a `name` attribute to represent an event name, a `startdate` attribute, an
    `enddate` attribute, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The item primary key is the only attribute in an item that must be defined beforehand.
    However, any other attribute inside an item doesn't need to be predefined. This
    makes DynamoDB a schemaless database, which means that the structure of the database
    table does not need to be defined before filling the table with data.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the attributes in DynamoDB are scalar. This means that they can have
    only one value. An example of a scalar attribute is a string attribute or number
    attribute. Some attributes can be nested, where an attribute can host another
    attribute and so on. Attributes are allowed to get nested up to 32 levels deep.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute value data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, each DynamoDB attribute consists of an attribute name
    and an attribute value. The attribute value in turn consists of two pieces: the
    value''s data type name, and the value data. In this section, we''ll focus on
    the data types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main data types categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalar Types***:* This is the simplest data type; it represents a single
    value. The scalar type category encompasses the following data type names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*S*`**: **This is simply a string type; it utilizes the UTF-8 encoding; the
    length of the string must be between zero and 400 KB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`N`**: **This is a number type. They can be positive, negative, or simply zero.
    They can go up to 38 digits precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*B*`**: **An attribute of type binary. Binary data includes compressed texts,
    encrypted data, or images. The length needs to be between 0 and 400 KB. Our applications
    must encode binary data values in base64-encoded format before sending them to
    DynamoDB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*BOOL*`**: **An attribute of Boolean. It can be either true or false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document Types***:* The document types is a complex structure with nested
    attributes. There are two data types name that fall under this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L`**: **An attribute of type list. This type can store an ordered collection
    of values. There are no restrictions on the data types that can be stored in a
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*Map*`**: **A map type stores data in an unordered collection of name-value
    pairs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set Types***: *A set type can represent multiple scalar values. All items
    in a set type must be of the same type. There are three data type names that fall
    under this category:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*NS*`**: **A set of numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SS`**: **A set of strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BS`**: **A set of binary values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, the only part of a DynamoDB table item that needs to be
    defined beforehand is the primary key. In this section, we'll take a deeper look
    into the primary keys of the DynamoDB database engine. The main task of the primary
    key is to uniquely identify each item in a table so that no two items can have
    the same key.
  prefs: []
  type: TYPE_NORMAL
- en: 'DynamoDB supports two different kinds of primary keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Partition key***:* This is a simple type of primary key. It is composed of
    one attribute known as the partition key. DynamoDB stores its data in multiple
    partitions. A partition is the storage layer for a DynamoDB table, backed by solid
    state hard drives. The partition key''s value is used as an input to an internal
    hash function, which generates an output that determines the partition in which
    the item will be stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composite key***:* This type of key is composed of two attributes. The first
    attribute is the partition key which we discussed earlier, whereas the second
    attribute is what is known as the ''sort key''. If you utilize a composite key
    as your primary key, then more than one item can share the same partition key.
    Items with the same partition key are stored together. The sort key is then utilized
    to sort items with the same partition key. The sort key must be unique for each
    item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each primary key attribute must be a scalar, which means it can only hold a
    single value. There are three datatypes allowed for primary key attributes—a string,
    number, or binary.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primary keys in DynamoDB provide efficient and fast access to items in tables,
    when we query the items via their primary keys. However, there are a lot of scenarios
    where we may want to query items in tables via attributes other than the primary
    keys. DynamoDB allows us to create secondary indexes that target attributes different
    than primary key attributes. These indexes enable us to run efficient queries
    on nonprimary key items.
  prefs: []
  type: TYPE_NORMAL
- en: A secondary index is nothing more than a data structure that contains a subset
    of attributes from a table. A table is allowed to have multiple secondary indexes,
    which provides flexibility when querying data from tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to further understand secondary queries, we will need to cover some
    basic definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Base Table**: Each and every secondary index belongs to exactly one table.
    The table from which the index is based and from where the index obtains its data
    is called the base table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projected attributes***:* Project attributes are the attributes that get
    copied from the base table into the index. DynamoDB copies these attributes into
    the data structure of the index, along with the primary keys of the base table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global secondary index***:* An index with a partition key and a sort key
    that are different from those on the base table. This type of index is considered
    `global` because queries performed on that index can span all the data in the
    base table. You can create a global secondary index either at the same time you
    create a table or at a later time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local secondary index***:* An index with the same partition key as the base
    table, but a different sort key. This type of index is `local` because every partition
    of a local secondary index is associated with the base table partition that has
    the same partition key value. You can only create a local secondary index at the
    same time when you create a table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make use of the AWS web console to create DynamoDB tables that we can
    then access later in our code. The first step is to visit the AWS management console
    main dashboard, then click on DynamoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbf657e8-3fd0-422b-bce5-0a885e5138d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on DynamoDB, we will move to the DynamoDB main dashboard, where
    we can create a new table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/198c41bb-7bec-468e-bd0b-503c805615c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to pick the table name and the primary keys. As we mentioned
    earlier, the primary key in DynamoDB can consist of up to two attributes—the partition
    key and the sort key. Let''s say we are creating a table called `events`. Let''s
    use a simple primary key that consists only of a partition key called `ID` that
    is of the `Binary` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca49341a-0bd3-45b7-8476-66525e3d9459.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will also leave the default settings. We will revisit some of those settings
    such as secondary indexes later. After we are done with the configuration, we
    will need to click on Create to create the table. We will then repeat the process
    with all other tables that we would like to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/480544e0-799f-4345-becd-7df929b5a06f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once a table is created, we can now connect to it, edit it, and read from it
    through our code. However, before we start discussing code, we will need to create
    a secondary index. To do that, we will need to first visit our newly created table
    by selecting the Tables option on the left-hand side. We will then select the
    `events` table from tables list. Afterward, we will need to pick the Indexes tab,
    then click on Create Index to create a new secondary index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46bf125c-75b5-4d92-9907-664ff938dc5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The secondary index name needs to be the attribute name from our table that
    we would like to use as our secondary index. In our case, the attribute that we
    would like to use for queries is the event name. This attribute represents the
    index that we need in order to run an efficient query when querying for events
    by their names instead of their IDs. Here is what the Create index dialog looks
    like; let''s fill the different fields, then click on Create Index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1356996-0d2d-423e-9014-bbd34892db27.png)'
  prefs: []
  type: TYPE_IMG
- en: Perfect! With this step, we now have our table ready for our code. Note that
    in the screenshot above how the index name is `EventName-index`. We will utilize
    that name later in our Go code.
  prefs: []
  type: TYPE_NORMAL
- en: The Go language and DynamoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon has provided the Go language with powerful packages that we can utilize
    to build applications that can efficiently interact with DynamoDB. The main package
    can be found at [https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/](https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start diving into the code, let''s take a refresher on the `DatabaseHandler`
    interface we discussed in [Chapter 2](def2621c-74c4-4f60-a37a-b0b2f86c6339.xhtml),
    *Building Microservices Using Rest APIs*. This interface represents the database
    handler layer of our microservices, which is where the database access code lives.
    In case of the `events` service, this interface supported  four methods. Here
    is what it looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In our quest to gain a practical understanding on how to write applications
    that can work with DynamoDB, we will implement the preceding four methods to utilize
    DynamoDB as the backend database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to other AWS services, the AWS Go SDK provides a service client object
    that we can use to interact with DynamoDB. Also, similar to other AWS services,
    we will need to obtain a session object first, then use it to create a DynamoDB
    service client object. Here is what that code should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`dynamodbsvc` ends up being our service client object, which we can then use
    to interact with DynamoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to create a new file called dynamolayer.go, which will exist
    under the relative folder `./lib/persistence/dynamolayer`, which is under our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f489a243-776b-4e69-bfef-7f9e3020517a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `dynamolayer.go` file is where our code will live. The first step we will
    need to follow in order to implement the `databasehandler` interface is to create
    a `struct` type, which will implement the interface methods. Let''s call the new
    type `DynamoDBLayer`; here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `DynamoDBLayer` struct contains one field of type `*dynamodb.DynamoDB`;
    this struct field represents the AWS service client for DynamoDB, which is the
    key object type we'll use in our code to interact with DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to write some constructors to initialize the `DynamoDBLayer`
    struct. We will create two constructors—the first constructor assumes that we
    don''t have an existing AWS session object to use in our code. It will take a
    single string argument, which represents our AWS region (for example, `us-west-1`).
    It will then utilize the region string to create a session object targeting that
    region. Afterward, the session object will be used to create a DynamoDB service
    client object, which can be assigned to a new `DynamoDBLayer` object. Here is
    what the first constructor will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second constructor is the one we would use if we already had an existing
    AWS session object. It takes the session object as an argument, then use it to
    create a new DynamoDB service client, which we can assign to a new `DynamoDBLayer`
    object. Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now, with the constructors out of the way, let's implement the `DatabaseHandler`
    interface methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue writing our code, we will need to first cover two important
    concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*dynamoDB.AttributeValue`: This is a struct type that lives inside the dynamodb
    Go package. It represents a DynamoDB item attribute value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dynamodbattribute`: This is a subpackage that falls underneath the dynamodb
    package. The docs for this package can be found at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/dynamodbattribute/`.
    The package is responsible for converting between Go types and `dynamoDB.AttributeValues.`
    This provides a very convenient way to convert Go types inside our application
    into types that can be understood by the dynamoDB package methods, and vice versa.
    `dynamodbattribute` can convert slices, maps, structs, and even scalar values
    to and from `dynamoDB.AttributeValues` by utilizing marshal and unmarshal methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We will be utilizing the power of the `dynamoDB.AttributeValue` type as well
    as the `dynamodbattribute` package from now on to write code capable of working
    with DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first `DatabaseHandler` interface method that we will cover is the `AddEvent()`
    method. This method takes an argument of the `Event` type, and then adds it as
    an item into the events table in the database. Before we start covering the method''s
    code, we will need to first understand the AWS SDK components that we''ll need
    to utilize:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddEvent()` will need to make use of an AWS SDK method called `PutItem()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PutItem()` method takes an argument of the PutItemInput type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PutItemInput` needs two pieces of information to serve our purposes—the table
    name, and the item that we would like to add'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table name field of the `PutItemInput` type is of the *string type, whereas
    the item is of the `map[string]*AttributeValue` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to convert our Go type Event into `map[string]*AttributeValue`, which
    as per the preceding point is the item field type we will need for `PutItemInput`,
    we can utilize a method called `dynamodbattribute.MarshalMap()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is one more important remark we will need to cover; the following is
    what our `Event` type looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains all the key information we typically need to describe an event
    such as a concert. However, when working with DynamoDB, there is one issue with
    the `Event` type—the keyword `Name` is a reserved keyword in the DynamoDB world.
    This means that if we leave the struct like this, we won''t be able to use the
    `Name` field of the Event struct in our queries. Fortunately, the `dynamodbattribute`
    package supports a struct tag called `dynamodbav`, which allows us to mask the
    struct field name with another name. This will allow us to use the struct field
    Name in our Go code, but have it exposed as a different name to DynamoDB. The
    following is what the code will look like after adding the struct field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we utilized the `dynamodbav` struct tag to define the
    `Name` struct field as `EventName` when interfacing with DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perfect! Now, let''s look at the `AddEvent()` method code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first step in the preceding code was to marshal the event object to `map[string]*AttributeValue`.
    The next step was to call the `PutItem()` method, which belongs to the DynamoDB
    service client. `PutItem` took an argument of the `PutItemInput` type as discussed
    earlier, which contained the table name and the marshaled item data that we would
    like to add. At the end, if no errors occur, we will return a byte representation
    of the event ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next `DatabaseHandler` interface method that we will need to discuss is
    `FindEvent()`. This method retrieves an event via its ID. Remember here that when
    we created the `events`  table, we set the ID attribute as its key. Here are some
    points we will need to cover to understand the incoming piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FindEvent()` utilizes an AWS SDK method called `GetItem()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FindEvent()` takes an argument of the `GetItemInput` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `GetItemInput` type needs two pieces of information: the table name and
    the value of the item key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetItem()` method returns a struct type called `GetItemOutput`, which has
    a field called `Item`. The `Item` field is where our retrieved database table
    item will be hosted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The item obtained from the database will be represented with the `map[string]*AttributeValue`
    type. We can then make use of the `dynamodbattribute.UnmarshalMap()` function
    to convert it to an `Event` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the code will look like at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in the preceding code that the `Key` field of the `GetItemInput` struct
    was of the `map[string]*AttributeValue` type. The key to this map is the attribute
    name, which is `ID` in our case, whereas the value of this map is of the `*AttributeValue` type and
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `B` in the preceding code is a struct field in `AttributeValue`, which represents
    a binary type, whereas `id` is simply the byte slice argument that got passed
    to our `FindEvent()` method.  The reason why we used the binary type field is
    because our ID key attribute of the events table was of type binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now move to the third `DatabaseHandler` interface method for the events
    microservice, which is the `FindEventByName()` method. This method retrieves an
    event via its name. Remember that when we created the `events` table earlier,
    we set the `EventName` attribute as the secondary index. The reason why we did
    that is because we wanted the ability to query items from the `events` table via
    the event names. Again, before we start covering the code, here is what we need
    to know about the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FindEventByName()` utilizes an AWS SDK method called `Query()` in order to
    query the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Query()` method takes an argument of the `QueryInput` type, which needs
    four pieces of information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The query that we would like to execute, in our case, the query is simply `EventName
    = :n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The  value of `:n` in the above expression. This is a parameter that we will
    need to fill with the name of the event we are trying to find.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index name that we would like to utilize for our query. In our case, the
    secondary index we created for the EventName attribute was called `EventName-index`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table name where we would like to run the query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `Query()` method succeeds, we get our result items as slice of maps;
    the result items will be of the `[]map[string]*AttributeValue` type. Since we
    only seek a single item, we can just retrieve the first item of that map slice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Query()` method returns an object of the type `QueryOutput` struct, which
    contains a field called `Items`. The `Items` field is where our query result set
    will be hosted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then will need to utilize the `dynamodbattribute.UnmarshalMap()` function
    in order to convert the item of the `map[string]*AttributeValue` type into an
    `Event` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Queries in DynamoDB is an important topic. I recommend that you read the AWS
    docs explaining queries, which can be found at [http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html](http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Query.html)
    to properly understand how queries work in DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last `DatabaseHandler` interface method we will discuss in this chapter
    is the `FindAllAvailableEvents()` method. This method retrieves all the items
    of the ''events'' table in DynamoDB. Here is what we need to know before diving
    into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FindAllAvailableEvents()` needs to utilize an AWS SDK method called `Scan()`.
    This method performs a scan operation. A scan operation can be simply defined
    as a read that goes through every single item in a table or in a secondary index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Scan()` method requires an argument of the type `ScanInput` struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ScanInput` type needs to know the table name in order to perform the scan
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Scan()` method returns an object of the `ScanOutput` struct type. The `ScanOutput`
    struct contains a field called `Items` of the `[]map[string]*AttributeValue` type.
    This is where the results of the scan operation will go.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Items` struct field can be converted to a slice of `Event` types via the
    `dynamodbattribute.UnmarshalListofMaps()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: One important remark to mention about scan operations is that since in a production
    environment, a scan operation can return a massive number of results, it is sometimes
    advised to utilize the pagination feature of the AWS SDK that we mentioned in
    the preceding chapter with the scans. The pagination feature allows the results
    of your operations to come in multiple pages, which you can then iterate through.
    Scan pagination can be performed via the `ScanPages()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a practical dive into some of the most popular services
    in the AWS world. By now, we have covered enough knowledge to build production-level
    Go applications that are capable of utilizing some of the key features that AWS
    provides for cloud native applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take another step to learn more about building Go
    cloud native applications by covering the topic of continuous delivery.
  prefs: []
  type: TYPE_NORMAL
