- en: Chapter 3. Application Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we looked at a brief description of the application
    we will build. It is now time to give you an in-depth look of the overall project.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to build a geolocalization application and we chose to create it like
    a game so that it is more fun and easier to understand. Feel free to adapt the
    example to any other idea, for example, a tourism application with geolocalization
    embedded.
  prefs: []
  type: TYPE_NORMAL
- en: Our game will use geolocalization to find different secrets all around the world
    (or in a specific geographic area if you want a smaller map). The backend system
    will generate new secrets and place them randomly on our map, allowing the users
    to explore their environment to find them. As a player of our game, you will collect
    the different secrets and store them in your *wallet*, which is where you will
    find more information about each of them.
  prefs: []
  type: TYPE_NORMAL
- en: To make our game more fun, we will have a battle engine. While you are discovering
    our *secret world*, you can battle against other players to steal his/her *secrets*.
    The battle engine will be a simple one--just throw a dice and the highest score
    wins the battle.
  prefs: []
  type: TYPE_NORMAL
- en: A project of this kind cannot be completed without other services, such as a
    user/player management system among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you start with a specification and you try to decompose it
    into smaller parts. From our little description, we can start defining our microservices
    and their responsibilities as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User service**: The main responsibility of this service is user registration
    and management. To keep the example small, we will also add extra functionalities, such
    as user notifications and secrets wallet management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battle service**: This service will be responsible for the users battle,
    keeping a record of each battle and moving secrets from the loser wallet to the
    winner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secret service**: This is one of the core services for our game because it
    will be responsible for all the secrets stuff.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location service**: To add an extra layer of complexity, we decided to create
    a service to manage any task related to locations. The main responsibility is
    to know where everything is located; for example, if the user service needs to
    know if there are other players in the area, sending a message with the geolocalization
    to this service, the response will tell the User Service who is in the area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we are not only creating services for our game, but we will be using
    other supporting services to make everything work smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes the communication paths between our different
    services. Every service will be able to talk to other services so that we can
    compose bigger and more complex tasks. The following diagram depicts connections
    between our microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices structure](graphics/B06142_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Microservice patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A design pattern is a reusable solution to a recurrent problem in a real-world
    application development. These solutions have a proven track record of success
    and they are widely used, so adding them to our project will make our software
    more stable and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are building a microservice application and because we want it to be as
    stable and reliable as possible, we will use some microservice patterns, such
    as: API gateway, service discovery and registry, and shared database or database
    per service.'
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will have a frontend for the users to register and interact with our application
    and it will be the main client of our microservices. Also, we are planning to
    have native mobile applications in the future. Having different clients using
    our application can create headaches for us because their use of our microservices
    can be very different.
  prefs: []
  type: TYPE_NORMAL
- en: 'To unify the way any client uses our microservices, we will be adding an extra
    layer--an API gateway. This API gateway becomes the single entry point for any
    client (for example, browser and native application). In this layer, our gateway
    can handle the request in two ways: some requests are simply proxied and others
    are fanned out to multiple services. We can even use this API gateway as a security
    layer, checking whether each request from the client is allowed to use our microservices
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '![API gateway](graphics/B06142_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Assets' requests
  prefs: []
  type: TYPE_NORMAL
- en: 'Having an API gateway has numerous benefits, among which we can highlight the
    following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Our application will have a single point of access, removing the problem of
    clients needing to know where each microservice is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a bigger control of how our services are used, and we can even provide
    custom endpoints for specific clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces the number of requests/roundtrips. With one single round-trip, a
    client can retrieve data from multiple services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery and registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our services will need to call other services. On monolithic applications, the
    solution is very simple--we can call methods or use procedure calls. We are building
    a microservices application running in containers, so there is no easy way of
    knowing where some service is located. Our containers infrastructure is very flexible
    and we need to build a service discovery system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of our services will obtain the location of all the other linked services
    by querying our service registry (a place where we store information about all
    our services using Consul). Our registry will know the locations of each service
    instance. The following figure shows the autodiscovery pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service discovery and registry](graphics/B06142_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To achieve this, we will use different tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consul**: This is our service registry with loads of features, such as clustering
    support, among others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fabio**: This is a reverse proxy built on Go and has a deep integration with
    Consul. What we like about this proxy is the easy connection with Consul and its
    ability to do blue-green deploys. Another interesting tool you can try is Træfik.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NGINX**: A powerful HTTP server and reverse proxy, this is a very well-known
    tool for most of the web developers and was chosen due to its performance and
    low memory footprint. We will be using Fabio and NGINX as reverse proxies indistinctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ContainerPilot**: This is a small tool written in Go. We will use this software
    to register our services in Consul, send stats of our containers to a centralized
    telemetry system, send health checks to Consul, and detect changes in other services.
    We will create some kind of auto-healing system with this tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared database or database per service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In one way or another, an application generates data that we need to store.
    In a monolithic application, there is no doubt that all the data is stored at
    the same place. The problem is when you are dealing with a microservice application
    and there is no easy response. Each application domain is unique, so there is
    no rule of thumb to solve the problem; you need to analyze your data and decide
    if you want to store all the data in a shared store, if each service has its own
    data store, or a mixture.
  prefs: []
  type: TYPE_NORMAL
- en: In our sample application, we will cover both the approaches but let's explain
    the benefits of each option.
  prefs: []
  type: TYPE_NORMAL
- en: Database per service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this approach, we keep each microservice''s persistent data private to that
    service, the data is only accesible via its API and has numerous benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It makes the services loosely coupled; you can make changes to the battle service
    without impacting the user service, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases the flexibility of our application due to the fact that the data
    can only be accessed by its API; we can use different storage engines. For example,
    we can use a relational database in our user service and a NoSQL in the Location
    service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, this solution has a few drawbacks, the difficulty of joining data
    shared between different services being the most notable problem.
  prefs: []
  type: TYPE_NORMAL
- en: Shared database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach works like a database in a monolithic application--all the data
    is stored in the same engine. The main benefit is the simplicity of having everything
    in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simplicity has some drawbacks; we highlight the following ones among them:'
  prefs: []
  type: TYPE_NORMAL
- en: Any database change can break or impact other services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Results in a less flexible application as you are using the same engine for
    all the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the data store is down, all the services that use the shared database will
    note the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a developer, your job is to find the best solution for each problem you need
    to solve. You need to decide how you are going to store the application data,
    always keeping in mind the benefits and drawbacks of each option.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** is the name of the method used to communicate
    with the APIs. As the name suggests, it is *stateless*; in other words, the services
    do not keep the data transferred, so if you call a microservice sending data (for
    example, a username and a password), the microservice will not remember the data
    next time you call it. The state is kept by the client, so the client needs to
    send the state every time the microservice is called.'
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this is when a user is logged in and the user is able to call
    a specific method, so it is necessary to send the user credentials (username and
    password or token) every time.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a Rest API is not a service anymore; instead of that, it is like
    a resource container available to be communicated by identifiers (URIs).
  prefs: []
  type: TYPE_NORMAL
- en: In the following lines, we will define some interesting conventions about APIs.
    It is important to know these kinds of tips because you should do things as you
    would like to find them when you are working on an API. In other words, writing
    an API is like writing a book for yourself--it will be read by developers like
    you, so the perfect functionality is not the only important thing, the friendly
    way to talk is important too.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a RESTful API will be easier for you and the consumers if you follow
    some conventions in order to make them happy. I have been using some recommendations
    on my RESTful APIs and the results were really good. They help to organize your
    application and its future maintenance needs. Also, your API consumers will thank
    you when they enjoy working with your application.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security in your RESTful API is important, but it is especially important if
    your API is going to be consumed by people you do not know, in other words, if
    it is going to be available to everybody.
  prefs: []
  type: TYPE_NORMAL
- en: Use SSL everywhere--it is important for the security of your API. There are
    many public places without an SSL connection and it is possible to sniff packages
    and get other people's credentials.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use token authentication, but it is mandatory to use SSL if you want to use
    a token to authenticate the users. Using a token avoids sending entire credentials
    every time you need to identify the current user. If it is not possible, you can
    use OAuth2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide response headers useful to limit and avoid too many requests by the
    same consumer. One of the problems with big companies is the traffic or even people
    trying to do bad things with your API. It is good to have some kind of method
    to avoid these kinds of problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bit by bit, more standards for PHP and microservices are appearing. As we saw
    in the last chapter, there are groups, such as PHP-FIG, trying to establish them.
    Here are some tips to make your API more standard:'
  prefs: []
  type: TYPE_NORMAL
- en: Use JSON everywhere. Avoid using XML; if there is a standard for RESTful APIs,
    it is JSON. It is more compact and can be easily loaded in web languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use camelCase instead of snake_case; it is easier to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use HTTP status code errors. There are standard statuses for each situation,
    so use them to avoid explaining every response of your API better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include the versioning in the URL, do not put it on the header. The version
    needs to be in the URL to ensure browser explorability of the resources across
    versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a way to override the HTTP method. Some browsers only allow `POST` and
    `GET` requests, so it will be good to allow a `X-HTTP-Method-Override` header
    to override `PUT`, `PATCH`, and `DELETE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consumer amenities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The consumers of your API are the most important, so you need to provide useful,
    helpful, and friendly ways to make the developer''s job easier. Develop the methods
    thinking about them:'
  prefs: []
  type: TYPE_NORMAL
- en: Limit the response data. The developer will not need all the available data,
    so you can limit the response using a filter for the fields to return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use query parameters to filter and sort results. It will help you simplify your
    API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that your API is going to be used by different developers, so look
    after your documentation--it needs to be really clear and friendly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return something useful on the `POST`, `PATCH`, and `PUT` requests. Avoid making
    the developer call to the API too many times to get the required data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is good to provide a way to autoload related resource representations in
    the response. It would be helpful for the developers in order to avoid requesting
    the same thing many times to get all the necessary data. It is possible to do this
    by including filters to define specific parameters in the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the pagination using link headers, then the developers will not need to
    make the links on their own.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include response headers that facilitate caching. HTTP has included a framework
    to do this just by adding some headers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a lot more tips, but these ones are enough for the first approach
    to RESTful conventions. In the subsequent chapters, we will see examples of these
    RESTful conventions and explain how they should be used better.
  prefs: []
  type: TYPE_NORMAL
- en: Caching strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phil Karlton
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*"There are only two hard things in Computer Science: cache invalidation and
    naming things."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A cache is a component that stores data temporarily so that future requests
    for that data can be served faster. This temporal storage is used to shorten our
    data access times, reduce latency, and improve I/O. We can improve the overall
    performance using different types of caches in our microservice architecture.
    Let's take a look at this subject.
  prefs: []
  type: TYPE_NORMAL
- en: General caching strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To maintain the cache, we have algorithms that provide instructions which tell
    us how the cache should be maintained. The most common algorithms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Least Frequently Used (LFU)**: This strategy uses a counter to keep track
    of how often an entry is accessed and the element with the lowest counter is removed
    first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Least Recently Used (LRU)**: In this case, the recently-used items are always
    near the top of the cache and when we need some space, elements that have not
    been accessed recently are removed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Most Recently Used (MRU)**: The recently-used items are removed first. We
    will use this approach in situations where older items are more commonly accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The perfect time to start thinking about your cache strategy is when you are
    designing each of the microservices required by your app. Every time your service
    returns data, you need to ask to yourself some questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Are we returning sensible data we can't store at any place?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are we returning the same result if we keep the input the same?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How long can we store this data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we want to invalidate this cache?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add a cache layer at any place you want in your application. For example,
    if you are using Percona/MySQL/MariaDB as a data storage, you can enable and set
    up the query cache correctly. This little setup will give your database a boost.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to think about cache even when you are coding. You can do lazy loading
    on objects and data or build a custom cache layer to improve the overall performance.
    Imagine that you are requesting and processing data from an external storage,
    the requested data can be repeated several times in the same execution. Doing
    something similar to the following piece of code will reduce the calls to your
    external storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that our examples omit big chunks of code, such as namespaces or other
    functions. We only want to give you the overall idea so that you can create your
    own code.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will store our data in the `$myCache` variable every time we
    make a request to our external storage using an ID as the key identifier. The
    next time we request an element with the same ID as a previous one, we will get
    the element from `$myCache` instead of requesting the data from the external storage.
    Note that this strategy is only successful if you can reuse the data in the same
    PHP execution.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, you have access to the most popular cache servers, such as **memcached**
    and **Redis**; both of them store their data in a key-value format. Having access
    to these powerful tools will allow us to increase the performance of our microservices
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rebuild our preceding example using `Redis` as our cache storage. In
    the following piece of code, we will assume that you have a `Redis` library available
    in your environment (for example, phpredis) and a `Redis` server running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we connected to the Redis server first and adapted the `getMyDataById`
    function to use our new Redis instance. This example can be more complicated,
    for example, by adding the dependence injection and storing a JSON in the cache,
    among other infinite options. One of the benefits of using a cache engine instead
    of building your own is that all of them come with a lot of cool and useful features.
    Imagine that you want to keep the data in cache for only 10 seconds; this is very
    easy to do with Redis--simply change the set call with `$this->myCache->set($id,
    $externalData, 10)` and after ten seconds your record will be wiped from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Something even more important than adding data to the cache engine is invalidating
    or removing the data you have stored. In some cases, it is fine to use old data
    but in other cases, using old data can cause problems. If you do not add a TTL
    to make the data expire automatically, ensure that you have a way of removing
    or invalidating the data when it is required.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this example and the previous one in mind, we will be using both strategies
    in our microservice application.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you don't need to be tied to a specific cache engine; wrap it,
    create an abstraction, and use that abstraction so that you can change the underlying
    engine at any point without changing all the code.
  prefs: []
  type: TYPE_NORMAL
- en: This general caching strategy can be used in any scope of your application--you
    can use it inside the code of your microservice or even between microservices.
    In our application example, we will deal with *secrets*; their data doesn't change
    very often, so we can store all this information on our cache layer (Redis) the
    first time they are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Future petitions will obtain the secrets' data from our cache layer instead
    of getting it from our data storage, improving the performance of our app. Note
    that the service that retrieves and stores the *secrets* data is the one that
    is responsible for managing this cache.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see some other caching strategies that we will be using in our microservices
    application.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This strategy uses some HTTP headers to determine whether the browser can use
    a local copy of the response or it needs to request a fresh copy from the origin
    server. This cache strategy is managed outside your application, so you don't
    have much control over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the HTTP headers we can use are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expires**: This sets a time in the future when the content will expire. When
    this point in the future is reached, any similar requests will have to go back
    to the origin server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Last-modified**: This specifies the last time that the response was modified;
    it can be used as part of your custom validation strategy to ensure that your
    users always have fresh content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Etag**: This header tag is one of the several mechanisms that HTTP provides
    for web cache validation, which allows a client to make conditional requests.
    An Etag is an identifier assigned by a server to a specific version of a resource.
    If the resource changes, the Etag also changes, allowing us to quickly compare
    two resource representations to determine if they are the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pragma**: This is an old header, from the HTTP/1.0 implementation. HTTP/1.1
    Cache-control implements the same concept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache-control**: This header is the replacement for the expires header; it
    is well supported and allows us to implement a more flexible cache strategy. The
    different values for this header can be combined to achieve different caching
    behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**no-cache**: This says that any cached content must be revalidated on each
    request before being sent to a client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**no-store**: This indicates that the content cannot be cached in any way.
    This option is useful when the response contains sensitive data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**public**: This marks the content as public and it can be cached by the browser
    and any intermediate caches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**private**: This marks the content as private; this content can be stored
    by the user''s browser, but not by intermediate parties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**max-age**: This sets the maximum age that the content may be cached before
    it must be revalidated. This option value is measured in seconds, with a maximum
    of 1 year (31,536,000 seconds).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**s-maxage**: This is similar to the max-age header; the only difference is
    that this option is only applied to intermediary caches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**must-revalidate**: This tag indicates that the rules indicated by max-age,
    s-maxage, or the expires header must be obeyed strictly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**proxy-revalidate**: This is similar to s-maxage, but only applies to intermediary
    proxies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**no-transform**: This header tells caches that they are not allowed to modify
    the received content under any circumstances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example application, we will have a public UI that can be reached through
    any web browser. Using the right HTTP headers, we can avoid requests for the same
    assets again and again. For example, our CSS and JavaScript files won't change
    frequently, so we can set up an expiry date in the future and the browser will
    keep a copy of them; the future requests will use the local copy instead of requesting
    a new copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add an expires header to all `.jpg`, `.jpeg`, `.png`, `.gif`, `.ico`,
    `.css`, and `.js` files with a date of 123 days in the future from the browser
    access time in NGINX with a simple rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Static files caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some static elements are very cache-friendly, among them you can cache the
    following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Logos and non-auto generated images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloadable content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any media files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These elements tend to change infrequently, so they can be cached for longer
    periods of time. To alleviate your servers' load, you can use a **Content Delivery
    Network** (**CDN**) so that these infrequently changed files can be served by
    these external servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, there are two types of CDNs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push CDNs**: This type requires you to **push** the files you want to store.
    It is your responsibility to ensure that you are uploading the correct file to
    the CDN and the pushed resource is available. It is mostly used with uploaded
    images, for example, the avatar of your user. Note that some CDNs can return an
    OK response after a push, but your file is not really ready yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pull CDNs**: This is the lazy version, you don''t need to send anything to
    the CDN. When a request comes through the CDN and the file is not in their storage,
    they get the resource from your server and it stores it for future petitions.
    It is mostly used with CSS, images, and JavaScript assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to have this in mind when you are designing your microservice application
    because you may allow your users to upload some files.
  prefs: []
  type: TYPE_NORMAL
- en: Where are you going to store these files? If they are to be public, why not
    use CDN to deliver these files instead of them being gutted from your servers.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the well-known CDNs are CloudFlare, Amazon CloudFront, and Fastly, among
    others. What they all have in common is that they have multiple data centers around
    the world, allowing them to try to give you a copy of your file from the closest
    server.
  prefs: []
  type: TYPE_NORMAL
- en: By combining HTTP with static files caching strategies, you will reduce the
    asset requests on your server to a minimum. We will not explain other cache strategies, such
    as full page caching; with what we have covered, you have enough to start building
    a successful microservice application.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Domain-driven design** (**DDD** from here on) is an approach for the development
    when it has complex needs. This concept is not new; it was created by Eric Evans
    in his book with the same title in 2004, but now it is mainstream as microservices
    are popular among developers and very common in huge projects.'
  prefs: []
  type: TYPE_NORMAL
- en: This is happening as there is great compatibility between the microservices
    concepts (regarding the software architecture, dividing every functionality into
    services) and DDD concepts (about the bounded contexts).
  prefs: []
  type: TYPE_NORMAL
- en: Before knowing where and how we can use DDD in our microservices project, it
    is necessary to understand what DDD is and how it works, so let me introduce you
    to the main concepts as a summary of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: How domain-driven design works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Evans introduced some concepts that are necessary to understand to learn how
    domain-driven design works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context**:This is the setting in which a word or statement appears that determines
    its meaning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain**: This is a sphere of knowledge (ontology), influence, or activity.
    The subject area to which the user applies a program is the domain of the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Model**:This is a system of abstractions that describes selected aspects
    of a domain and can be used to solve problems related to that domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ubiquitous language**:This is a language structured around the domain model
    and used by all team members to connect all the activities of the team with the
    software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **software domain** is not related to the technical terms, programming or
    computers in any way. In most projects, the most challenging part is to understand
    the business domain, so DDD suggests using a **model domain**; this is abstract,
    ordered, and selective knowledge reproduced in a diagram, code, or just words.
  prefs: []
  type: TYPE_NORMAL
- en: 'The model domain is like the roadmap to build projects with complex functionalities,
    and it is necessary to follow five steps to achieve it. These five steps need
    to be agreed on by the development team and the domain expert:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Brainstorming and refinement**: There should be a communication channel between
    the development team and the domain expert. So, all the people in the project
    should be able to talk to everyone because they all need to know how the project
    should work.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Draft domain model**: During the conversation, it is necessary to start drawing
    a draft of the domain model, so that it can be checked and corrected by the domain
    expert until they both agree.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Early class diagram**:Using the draft, we can start building an early version
    of the class diagram.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simple prototype**: Using the draft of the early class diagram and domain
    model, it is possible to build a very simple prototype. Evans suggests avoiding
    things that are not related to the domain to ensure that the domain business was
    modeled properly. It can be a very simple program as a trace.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Prototype feedback**: The domain expert interacts with the prototype in order
    to check whether all the needs are met and then the entire team will improve the
    model domain and the prototype.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process will have all the iterations needed until the domain model is
    correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How domain-driven design works](graphics/B06142_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The model, code, and design must evolve and grow together.They cannot be unsynchronized
    at all. If a concept is updated on the model, it should also be updated on the
    code and on the design automatically, and the same goes for the rest.
  prefs: []
  type: TYPE_NORMAL
- en: A model is an abstraction system that describes selective concepts of a domain
    and it can be used to resolve problems related to that domain. If there is a piece
    of the model that is not reflected in the code, it should be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the domain model is the base of the common language in a project.
    This common language in DDD is called **ubiquitous language** and it should have
    the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Class names and their functions related to the domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terms to discuss the domain rules included on the model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names of analysis and design patterns applied to the domain model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ubiquitous language should be used by all the members of the project, including
    developers and domain experts, so the developers should be able to describe all
    the tasks and functions.
  prefs: []
  type: TYPE_NORMAL
- en: It is absolutely necessary to use this language in all the discussions between
    the team, such as meetings, diagrams, or documentation, but this language was
    not born in the first iteration of the process, meaning that it can take many
    iterations of refactoring having the model, language, and code synchronized. If,
    for example, the developers discover that a class from the domain should be renamed,
    they cannot refactor this without refactoring the name on the domain model and
    the ubiquitous language.
  prefs: []
  type: TYPE_NORMAL
- en: The ubiquitous language, domain model, and code should evolve togetheras a single
    knowledge block.
  prefs: []
  type: TYPE_NORMAL
- en: There is controversial concept on DDD. Eric Evans says that it is necessary
    for the domain expert to use the same language as the team, but some people do
    not like this idea. Usually, the domain experts do not have knowledge of object-oriented
    concepts or microservices because they are too abstract for non-developers. Anyway,
    DDD says that if the domain expert does not understand the domain model, it is
    because there is something wrong with it.
  prefs: []
  type: TYPE_NORMAL
- en: There are diagrams in the domain model, but Evans suggests using text as well,
    because diagrams do not explain the concepts properly. Also, the diagrams should
    be superficial; if you want to see more details you have the code for it.
  prefs: []
  type: TYPE_NORMAL
- en: Some projects are affected by the connection between the domain model and the
    code. This happens because there is a division between analysis and design. The
    analysts make a model independent of the design and the developers cannot develop
    the functionalities because some information is missing. In addition, they cannot
    talk with the domain expert. The development team will not follow the model and,
    in the end, the domain model will not be updated and it will not work. Therefore,
    the project will not meet the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, DDD works to achieve the software development as an iterative process
    of refinement of the model, design, and code as a single task in a block.
  prefs: []
  type: TYPE_NORMAL
- en: Using domain-driver design in microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said before, DDD meets the microservice's needs perfectly. A common problem
    with microservices appears because they have decentralized data management; this
    has advantages but can be problematic sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: The concept model between two services will be different, and it can cause problems
    in huge companies. For example, a user can differ depending on the service, the
    attributes for each service regarding the user can differ and, also, the attribute
    semantic can differ.
  prefs: []
  type: TYPE_NORMAL
- en: It is even more complex when, in a big company, the application evolves a lot
    and has updates for many years. Each service can have different attributes for
    the user and, generally, they do not match. So, a great way to solve this is using
    DDD.
  prefs: []
  type: TYPE_NORMAL
- en: As microservices do, DDD divides a complex domain into different contexts, making
    relationships between them and asking for the collaboration of all the members
    to get a ubiquitous language in a particular domain and bounded context, iterating
    this process until they achieve a real concept regarding the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Evans suggests designing each microservice as a DDD-bounded context so that
    it will provide a logical boundary for microservices inside a system. Every single
    microservice (or team working on it) will be responsible for that part of the
    system, and it will give clearer and maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Michael Plöd gave more ideas about how DDD can help microservices. There are four
    significant areas regarding building microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategic design**: This is basically bounded context, but context maps and
    other patterns are important too. A context map should show all the bounded contexts
    of the project and their relationships with each other; it also describes the
    contract between them. The context map is very useful for monolithic applications
    wanting to move into microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal building blocks**: This refers to using tactical patterns, such
    as aggregates, entities, or repositories, when designing the inside of a bounded
    context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large-scale structures**: This is used to create a structure using evolving
    order and responsibility layers. This is a concept in microservices too. In huge
    projects, it is helpful to create large-scale structures into boundary contexts.
    They should be designed to evolve individually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distillation**: Distilling a core domain from an already grown system is
    very useful when migrating a monolithic application into microservices. The most
    important part should be identifying and extracting the core domain, along with
    the iteration process of identifying a subdomain, extracting it from the core,
    and refactoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To sum up, microservices and DDD match perfectly, but it is necessary to have
    a larger scope and understand more than the boundary contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Event-driven architecture** (**EDA**) is a pattern of architecture for applications
    following the tips of production, detection, consumption of, and reaction to events.'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to describe an event as a change of state. For example, if a
    door is closed and somebody opens it, the state of the door changes from closed
    to opened. The service to open the door has to make this change like an event,
    and that event can be known by the rest of the services.
  prefs: []
  type: TYPE_NORMAL
- en: An event notification is a message that was produced, published, detected, or
    consumed asynchronously and it is the status changed by the event. It is important
    to understand that an event does not move around the application, it just happens.
    The term *event* is a little controversial because it usually means the message
    event notification instead of the event, so it is important to know the difference
    between the event and the event notification.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is commonly used in applications based on components or microservices
    because they can be applied by the design and implementation of applications.
    An application driven by events has event creators and event consumers or sink
    (they have to execute the action as soon as the event is available).
  prefs: []
  type: TYPE_NORMAL
- en: An **event creator** is the producer of the event; it only knows that the event
    has occurred, nothing else. Then we have the event consumers, which are the entities
    responsible of knowing that the event was fired. The consumers are involved in
    processing or changing the event.
  prefs: []
  type: TYPE_NORMAL
- en: The **event consumers** are subscribed to some kind of middleware event manager which,
    as soon as it receives notification of an event from a creator event, forwards
    the event to the registered consumers to be taken by them.
  prefs: []
  type: TYPE_NORMAL
- en: Developing applications as microservices around an architecture such as EDA
    allows these applications to be constructed in a way that facilitates more responsiveness
    because the EDA applications are, by design, ready to be in unpredictable and
    asynchronous environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of using EDA are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uncoupling systems**: The creator service does not need to know the rest
    of the services, and the rest of the services do not know the creator. So, it
    allows it to uncouple the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interaction publish/subscribe**: EDA allows many-to-many interactions, where
    the services publish information about some event and the services can get that
    information and do what is necessary with the event. So, it enables many creator
    events and consumer events to exchange status and respond to information in real
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous**: EDA allows asynchronous interactions between the services,
    so they do not need to wait for an immediate response and it is not mandatory
    to have a connection working while they are waiting for the response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven architecture in microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices are commonly used in large projects to divide their services into
    smaller ones. So, it is really important to have good and organized communication
    between them. Event-driven architecture can be used to solve the common issues of
    communication between microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In a project based on microservices, usually every microservice communicates
    with each other using HTTP requests. This has some problems that we will now explain.
  prefs: []
  type: TYPE_NORMAL
- en: In our `Finding secrets` project, there is a function to create events for the
    users. When a new event is created, the event name and the images attached in
    the event form need to be sent to a service to create a video from the data received.
    Once the video is generated, the event will be updated and sent to the users by
    e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: If we make HTTP requests for each service, the problem is that all the services
    need to know about the others. For example, the service to generate the video
    needs to know how to update the event once the video is generated; in other words,
    the service has to contain code to do this update.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this becomes more and more difficult once we add many services because
    it will need more communication between them. It will have more failures and the
    main problem is that if a microservice is down, the video will not be generated.
    So, using HTTP requests is not going to scale pretty well and we should use a
    different strategy to communicate microservices in projects like this one.
  prefs: []
  type: TYPE_NORMAL
- en: What if we do the things differently? In other words, the service to generate
    the video will not update the event directly and the event will not ask the video
    service to generate the video. So, how can we make the microservices communicate?
    The answer is with event-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue of events for each microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the microservices have to send the event to a centralized BUS (we can use
    AWS to do this)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every queue of microservices has to be subscribed to the centralized BUS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every microservice has a background worker listening to the queue of events
    and it will execute the necessary action when receiving an event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the different services involved and the
    process flow, indicated with arrows. The following figure shows the event-driven
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Event-driven architecture in microservices](graphics/B06142_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we create a new event on the **EVENTS SERVICE API** (**1**), the event
    goes to the centralized BUS (**2**) and the corresponding worker gets the event
    from the centralized BUS (**3**); the rest of them just ignore the event. The
    event is placed in the video generator service queue and it waits to be executed
    by the service (**4**).
  prefs: []
  type: TYPE_NORMAL
- en: Once the video has been generated by a service worker, the service launches
    a new event to the centralized BUS (5). However, it will be taken by a different
    worker this time (6) and the res of workers will ignore this event as earlier.
    The worker to update the event and the worker to send the e-mail will put the
    event into their queues and it will be executed (**7**) doing the corresponding
    action for each service and they will send a new event into the centralized BUS
    if it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a loop of events that improves the HTTP requests method for the communication
    between services. The advantages of using event-driven architecture are as mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are any errors or exceptions on a service, the event does not get lost,
    it stays in the queue and it will be executed later. For example, if the service
    to send e-mails is down, the event to send the e-mail will be kept in the queue
    waiting for the service to go up again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The services do not need to know how to update other services. It means that
    the logic of the service can be isolated in each service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to add more microservices without impact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will scale better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration, continuous delivery, and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A software project cannot be successful without a strategy for code commit or
    a testing/deploying workflow. Having a strategy is even more important when you
    work in a team. There is nothing more annoying than working on a messy project
    where there are no rules or nobody is accountable for the work they have done.
    In this section, we will explain the most common and successful development practices.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration - CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous integration is a software development practice where all the team
    members integrate their work frequently. Every time new code is pushed to the
    shared repository, an automated build will be fired to detect any kind of integration
    errors as fast as possible. The main goal is to avoid long and unpredictable integrations.
  prefs: []
  type: TYPE_NORMAL
- en: What is continous integration?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's explain it better with a brief example of what the CI process is like.
    Imagine that you have our game example ready and working well in production and
    you have a new idea for a small feature that the users of your application will
    love. This new feature can be done in a few hours.
  prefs: []
  type: TYPE_NORMAL
- en: Begin by getting a copy of the current source code on your development machine;
    you will be using a source control system, so you only need to check out a working
    copy from the mainline.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a working copy of the source, you can do whatever you need
    to complete the feature, add new code, create new tests, and so on. The CI practice
    assumes that a high part of your code will be covered by automated tests. A popular
    unit test suite available for PHP is PHPUnit, a simple and powerful tool that
    we will cover in the later chapters. Having our code tested will help us in the
    future steps of the process and will assure high quality in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Now you have ended your new feature and it is time to launch an automated build
    on your development environment. This process will take the source code, check
    for errors, and run the automated tests. Only if the build and all the tests pass
    without errors, we can consider the build as good and it can be added to our repository.
  prefs: []
  type: TYPE_NORMAL
- en: The result of doing this process is that we have a stable piece of software
    that works properly and contains very few bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of CI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main goal of continuous integration is to reduce risk, but this is not
    the only benefit of adopting this development practice. Among others, we can highlight
    the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Reduced integration times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Early bug detection due to the fact that we are pushing small changes and each
    change is tested again and again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant availability of a stable build that we can use, for example, to make
    new tests, use as a demo for our customers, or even to deploy it again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous monitoring of the project quality metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for continuous integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As a developer, you can be worried about how to automate this process. Don''t
    worry, in the market you have multiple ways to create and manage your CI pipeline.
    The best recommendation from us is, before you decide which CI software you will use
    in your projects, spend some time testing all your options. Some of the CI software
    available with an easy integration with PHP are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jenkins**: This is an open source project that is very easy to install and
    manage. Its versatility makes this software perhaps one of the most widely used
    for CI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bamboo**: This is a subscription-based software. Atlassian is well known
    in the development world for its productivity and development support tools. It is
    a nice option if you need deep integration with other Atlassian tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Travis**: This is another subscription based software with a free plan for
    open source projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PHP CI**: This new open source tool was built on PHP and is available to
    installed on your server or as a cloud-based tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our sample project, we will use Jenkins and spin up a Docker container.
    In the meantime, you can start testing Jenkins with this simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a container with the official Docker image for Jenkins
    and map the 8080 and 50000 from your local environment to the container. If you
    open your browser on `http://localhost:8080`, you will have access to the Jenkins
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous delivery is the continuation of the continuous integration and the
    main goal is to be able to deploy any version of your software at any point, without a
    point of failure. We can achieve this by ensuring that our code is always available
    to be deployed and by following a continuous integration practice, we can ensure
    the quality and level of integration of our source.
  prefs: []
  type: TYPE_NORMAL
- en: With continuous delivery, every time we make a change to our code, this change
    is built, tested, and then released to a stage environment. The following diagram shows
    the basic workflow on a CD pipeline. As you can see, if any testing step fails,
    we need to start again until our code passes the tests. Working this way, we can
    always ensure that our project meets the highest quality standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the diagram for continuous delivery workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Continuous delivery ](graphics/B06142_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Benefits of continuous delivery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuous delivery has numerous benefits; among them, we highlight the following
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced deployment risk**: We will be deploying smaller changes, so there
    is less space for something to go wrong and it will be easier to fix any problems.
    Even if we apply a deploy pattern, such as blue-green deployments, our deployment
    will be undetectable to our users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Progress tracking**: Since not all developers and managers track the work
    progress in the same way, we are now deploying small releases very quickly; there
    is no doubt when a task is done--if it is on production, the task is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher quality**: With continuous delivery, we work in small batches; this
    allows us to get feedback from users throughout the delivery life cycle. We can
    even use A/B testing to test ideas before building the full feature. Having automatic
    testing tools in our pipeline allows the developers to discover regressions quickly
    and avoid the release of unstable software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster time to market**: The integration and test phase of the traditional
    software life cycle can take weeks, but if we manage to automate the build and
    deployment, and environment provisioning and testing processes, we can reduce
    the times to the minimum and incorporate them in the developer''s daily work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower costs**: If we invest in build, test, deployment, and environment automation,
    we reduce the cost of software by eliminating many fixed associated costs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools for a continuous delivery pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned before, continuous delivery is a continuation of continuous integration,
    so we can use most of the CI tools we mentioned earlier and expand our pipeline
    with our favorite testing framework. In PHP, we have a great number of testing
    frameworks available, but the most well known are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**phpUnit**: This is the most well-known framework used to create unit tests.
    Every PHP developer needs to know this framework as it will be the foundation
    of their tests. It is a standard in the industry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codeception**: This is one of the complete testing suites available for PHP.
    With Codeception, you can build unit, functional, and acceptance tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behat**: This is the most popular behavior-driven PHP testing framework.
    Instead of writing code, you write stories and the framework will transform and
    test them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PHPSec**: This is another important framework that follows the behavior-driven
    testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selenium**: This is one of the most sophisticated testing frameworks used
    to automate browsers. With this framework, it is possible to write user acceptance
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the subsequent chapters, we will use some of these testing frameworks. In
    the meantime, give each of them a go and select your favorite frameworks. Remember
    that you can mix them without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about the different ways of designing and developing
    an application. We covered some patterns and strategies that you can easily integrate
    in your development workflow and we even talked about the most common development
    practices. In the subsequent chapters, we will apply all these concepts in our
    development workflow.
  prefs: []
  type: TYPE_NORMAL
