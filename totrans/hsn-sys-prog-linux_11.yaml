- en: Signaling - Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals are a crucial mechanism for the Linux system developer to understand
    and exploit. We cover this rather large topic over two chapters in this book,
    this chapter and the next one.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the reader is introduced to what signals are, why they are
    useful to the systems developer, and, most importantly of course, how exactly
    the developer is to handle and thus exploit the signalling mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue this exploration in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the reader will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What exactly signals are.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why they are useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The available signals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How exactly you can handle signals in an application, which really involves
    many things—blocking or unblocking signals, writing safe handlers, getting rid
    of pesky zombies once and for all, working with apps where the signal volume is
    high, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why signals?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, the systems programmer requires the OS to provide an asynchronous
    facility—some way of letting you know that a certain event or condition has occurred. Signals provide
    that very feature on the Unix/Linux OSes. A process can trap or subscribe to a
    signal; when this occurs, the process will asynchronously be notified of the fact
    by the OS, and will then run the code of a function in response: a signal handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A CPU-intensive process is busy working on a scientific or mathematical calculation
    (for easy understanding, let's say it's generating primes); recall (from [Chapter
    3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource Limits*) that there
    is an upper limit on CPU usage and that it's been set to a particular value. What
    if it's breached? The process will be killed by default. Can we prevent this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The developer wants to perform a common task: set up a timer and have it expire
    in, say, 1.5 seconds from now. How will the OS inform the process that the timer
    has expired?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On some Sys V Unixes (typically running on enterprise-class servers), what
    if a sudden power failure occurs? An event is broadcast to all processes (that
    have expressed an interest in, or subscribed to the event) informing them of the
    same: they could flush their buffers, and save their data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A process has an inadvertent defect (a bug); it makes an invalid memory access.
    The memory subsystem (well, technically, the MMU and the OS) determines it must
    be killed. How exactly will it be killed?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux's asynchronous IO (AIO) framework, and many other such scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these example scenarios are serviced by the same mechanism: signals.
  prefs: []
  type: TYPE_NORMAL
- en: The signal mechanism in brief
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A signal can be defined as an asynchronous event that is delivered to a target
    process. Signals are delivered to the target process either by another process
    or the OS (the kernel) itself.
  prefs: []
  type: TYPE_NORMAL
- en: At the code level, a signal is merely an integer value; more correctly, it is
    a bit in a bitmask. It's important to understand that, although the signal may
    seem like an interrupt, it is not an interrupt. An interrupt is a hardware feature;
    a signal is purely a software mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s try a simple exercise: run a process, putting it in an infinite
    loop, and then manually send it a signal via the keyboard. Find the code in (`ch11/sig1.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Why is the `sleep(1);`code typecast to `(void)`? This is our way of informing
    the compiler (and possibly any static analysis tool) that we are not concerned
    about its return value. Well, the fact is we should be; there will be more on
    this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s working is quite obvious: let''s build and run it, and, after the third
    loop iteration, we press the *Ctrl* + *C* key combination on the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Yes, as expected, the process terminates. But how exactly did this happen?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the answer in brief: signalling. More verbosely, this is what occurs
    (it''s still kept simple, though): when the user presses the *Ctrl* + *C* key
    combination (shown as `^C` in the output), the kernel''s `tty`layer code processes
    this input, cooks the input key combination into, and delivers a signal to the
    foreground process on the shell.'
  prefs: []
  type: TYPE_NORMAL
- en: But, hang on a second. Remember, a signal is just an integer value. So, which
    integer? Which signal? The *Ctrl* + *C* key combination is mapped to the the `SIGINT`
    signal, integer value `2`, thus causing it to be delivered to the process. (The
    next section begins to explain the different signals; for now, let's not get too
    stressed out about it).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, OK, the `SIGINT` signal, value `2`, was delivered to our `sig1` process.
    But then what? Here, again, is a key point: every signal is associated with a
    function to run when it is delivered; this function is called the **signal handler**.
    If we do not change it, the default signal function runs. Well, that brings up
    the question: Since we have not written any default (or other) signal-handling
    code, then who has provided this default signal handler function? The short answer
    is this: the OS (the kernel) handles all cases in which a process receives a signal
    for which the app has not installed any handler; in other words, for the default
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The action performed by the signal handler function or the underlying kernel
    code determines what will happen to the target process when the signal arrives.
    So, now we can understand better: the action carried out by the default signal
    handler (kernel code, really) for the `SIGINT` signal is to terminate the process,
    in effect, causing the receiving process to die.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We show this in the form of a diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a2a9522-ca6d-4541-ab47-d3df5ca5f5b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Signal delivered via keyboard, default handler causes process to die
  prefs: []
  type: TYPE_NORMAL
- en: 'From this diagram, we can see the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: A process, **P** comes alive and runs its code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user presses `^C`, in effect causing the `SIGINT` signal to be sent to the
    process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we have not set up any signal handler, the default signal handling action
    for this signal, which is part of the OS, is invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This default signal handling code within the OS causes the process to die.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'FYI, for the default case—that is, all cases where the application developer
    has not installed a specific signal-handling routine (we will learn how exactly
    to install our own signal handlers shortly)—what exactly does the OS code that
    handles these cases do? Depending on the signal being processed, the OS will perform
    one of these five possible actions (see the following table for details):'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue the (previously stopped) process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminate the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminate the process and emit a core dump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The really interesting and powerful thing is this: the programmer has the ability
    to change–to re-vector the signal handling to their own function(s)! In effect,
    we can trap or catch signals by using certain APIs. Once we do so, when the signal
    occurs, control will not go to the default signal- handling (OS) code, but, rather,
    to the function we want it to. In this manner, the programmer can take charge
    and work with the powerful signalling mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there is much more to it: the devil does indeed lie in the details!
    Read on.'
  prefs: []
  type: TYPE_NORMAL
- en: Available signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Unix/Linux OS provides a set of 64 signals in total. They are broadly divided
    into two types: the standard or Unix signals and the real-time signals. We shall
    find that while they do share common attributes, there are some important differences
    as well; here, we shall investigate the Unix (or standard) signals and later,
    the latter.'
  prefs: []
  type: TYPE_NORMAL
- en: The generic communication interface for signalling from userspace, besides the
    keyboard key combinations (such as *Ctrl* + *C*), is the `kill(1)` utility (and,
    consequently, the `kill(2)` system call).
  prefs: []
  type: TYPE_NORMAL
- en: Besides the kill, there are several other APIs that deliver a signal; we shall
    flesh out more on this in a later section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `kill(1)` utility with the `-l` or list option lists the available
    signals on the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps the moniker `kill(1) `is a misnomer: the kill utility just sends a
    signal to a given process (or job). Thus (per your author at least), the name `sendsig` might
    have been a better choice for the utility.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An FAQ: where are the signals numbered `32` and `33`?'
  prefs: []
  type: TYPE_NORMAL
- en: They are internally used by the Linux Pthreads implementation (called NPTL),
    and are hence unavailable to app developers.
  prefs: []
  type: TYPE_NORMAL
- en: The standard or Unix signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As can be seen from the output of kill, all supported signals on the platform
    are shown; the first 31 of these (on your typical Linux box) are called the standard
    or Unix signals. Unlike the real-time signals that follow, each standard/Unix
    signal has a very specific name, and, as you might guess, purpose.
  prefs: []
  type: TYPE_NORMAL
- en: (Worry not; we shall discuss the real-time signals, numbers 34 to 64, in the
    next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'The table you will see shortly, essentially reproduced from the man page on signal(7),
    summarizes the standard (Unix) signals in the following column order: the signal''s
    symbolic name, integer value(s), the default action taken upon delivery to a process,
    and a comment describing the signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default action column has the following types: the default action of the
    signal handler is to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terminate**: Terminate the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Term&Core**: Terminate the process and emit a core dump. (A core dump is,
    essentially, a snapshot of the process''s dynamic segments, the data and stack
    segments, at the time when the (fatal) signal was delivered). This terminate and
    core dump action occurs when the kernel sends a fatal signal to a process. The
    implication is that the process has done something illegal (buggy); an exception
    is the `SIGQUIT` signal: we get a core dump when `SIGQUIT` is delivered to a process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ignore**: Ignore the signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop**: Process enters the stopped (frozen/suspended) state (represented
    by `T` in the output of `ps -l)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continue**: Continue execution of a previously stopped process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to the table Standard or Unix signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signal** | **Integer****value** | **Default****action** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGHUP` | `1` | Terminate | Hang up detected on controlling terminal or
    death of controlling process​ |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGINT` | `2` | Terminate | Interrupt from keyboard : `**^**C` |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGQUIT` | `3` | Term&Core | Quit from keyboard : `**^\**` |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGILL` | `4` | Term&Core | Illegal Instruction |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGABRT` | `6` | Term&Core | Abort signal from abort(3)​ |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGFPE` | `8` | Term&Core | Floating-point exception​ |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGKILL` | `9` | Terminate | (Hard) kill signal |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGSEGV` | `11` | Term&Core | Invalid memory reference |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGPIPE` | `13` | Terminate | Broken pipe: write to pipe with no readers;
    see pipe(7) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGALRM` | `14` | Terminate | Timer signal from alarm(2) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTERM` | `15` | Terminate | Termination signal (soft kill) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGUSR1` | `30,10,16` | Terminate | User-defined signal 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGUSR2` | `31,12,17` | Terminate | User-defined signal 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGCHLD` | `20,17,18` | Ignore | Child stopped or terminated |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGCONT` | `19,18,25` | Continue | Continue if stopped |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGSTOP` | `17,19,23` | Stop | Stop process |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTSTP` | `18,20,24` | Stop | Stop typed at terminal : `^Z` |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTTIN` | `21,21,26` | Stop | Terminal input for background process |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTTOU` | `22,22,27` | Stop | Terminal output for background process |'
  prefs: []
  type: TYPE_TB
- en: 'At times, the second column, the signal''s integer value, has three numbers.
    Well, it''s like this: the numbers are architecture-(meaning CPU) dependent; the
    middle column represents the value for the x86 architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Always use the symbolic name of the signal in code (such as `SIGSEGV`), including
    scripts, and never the number (such as `11`). You can see that the numeric value
    changes with the CPU, which could lead to non-portable buggy code!
  prefs: []
  type: TYPE_NORMAL
- en: What if the system admin needs to urgently kill a process? Yes, its quite possible
    that, while logged into an interactive shell, time is very precious and an extra
    couple of seconds may make a difference. In such cases, typing kill `-9` is better
    than kill `-SIGKILL`, or even kill `-KILL`. (The previous point is with regard
    to writing source code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing the signal number to kill `-l` causes it to print the signal''s symbolic
    name (albeit in a shorthand notation). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ kill -l 11`'
  prefs: []
  type: TYPE_NORMAL
- en: '`SEGV`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ `'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding table (and, as a matter of fact the following table as well) reveal
    that, with two exceptions, all the signals have a special purpose. Scanning the
    comment column reveals it. The exceptions are `SIGUSR1` and `SIGUSR2` these are
    general purpose signals; their use is left entirely to the imagination of the
    application designers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, the man page informs us that the following signals (shown in this
    table) are newer and included in the `SUSv2` and `POSIX.1-2001` standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signal** | **Integer** **Value** | **Default** **Action** | **Comment**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGBUS` | `10,7,10` | Term&Core | Bus error (bad memory access) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGPOLL` |  | Terminate | Pollable event (Sys V). Synonym for SIGIO |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGPROF` | `27,27,29` | Terminate | Profiling timer expired |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGSYS` | `12,31,12` | Term&Core | Bad system call (SVr4); see also seccomp(2)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGTRAP` | `5` | Term&Core | Trace/breakpoint trap |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGURG` | `16,23,21` | Ignore | Urgent condition on socket (4.2BSD) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGVTALRM` | `26,26,28` | Terminate | Virtual alarm clock (4.2BSD) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGXCPU` | `24,24,30` | Term&Core | CPU time limit exceeded (4.2BSD); see
    prlimit(2) |'
  prefs: []
  type: TYPE_TB
- en: '| `SIGXFSZ` | `25,25,31` | Term&Core | File size limit exceeded (4.2BSD); see
    prlimit(2) |'
  prefs: []
  type: TYPE_TB
- en: Newer standard or Unix signals
  prefs: []
  type: TYPE_NORMAL
- en: A few remaining (not so common) signals are further mentioned by the same man
    page (`signal(7)`). Take a look if you are interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to note that, out of all the signals mentioned, only two of
    them cannot be caught, ignored or blocked: the `SIGKILL` and the `SIGSTOP`. This
    is because the OS must guarantee a way to kill and/or stop a process.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we shall discuss in detail how exactly signals are handled
    by the application developer programmatically (using C code, of course).
  prefs: []
  type: TYPE_NORMAL
- en: Glance back at *Figure 1*.You can see how the OSperforms default signal handling,
    which runs when an uncaught signal is delivered to the process. This seems good,
    until we realize that, pretty often, the default action is to simply kill (or
    terminate) the process. What if the application demands we do something else?
    Or, what if, realistically, the application doescrash, instead of just abruptly
    dying (and perhaps leaving important files and other metadata in an inconsistent
    state). Perhaps we can put the program into a sane state by performing some required
    cleanup, flushing buffers, closing open files, logging the state/debug information,
    and so on, informing the user of the sorry state of affairs (with a nice dialog
    box perhaps), and *then *have the process die, gracefully and peacefully, if you
    will.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to catch or trap a signal is the key to achieving these goals. As
    mentioned earlier, to re-vector the flow of control such that it's not the default
    signal-handling kernel code, but our custom signal handling code that executes
    when the signal arrives.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we achieve this? By using APIs to register interest in and thus
    handle signals. Broadly, there are three available APIs to catch or trap a signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sigaction(2)` system call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signal(2)` system call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sigvec(3)` library API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, of these three APIs, the `sigvec` is nowadays considered deprecated. Also,
    unless the work is really simplistic, you are urged to forgo the `signal(2)` API
    in favor of the `sigaction` API. Effectively, the powerful way to handle signals
    is via the `sigaction(2)` system call; it is the one we shall discuss in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Using the sigaction system call to trap signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sigaction(2)` system call is the right way to trap or catch signals; it's
    powerful, POSIX compliant, and can be used to hone your application's signal-handling
    superbly.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, the `sigaction` system call is used to register a signal handler
    for a given signal. If the signal''s handler function was `foo`, we can use `sigaction` to
    change its signal handler to `bar`. As usual, there is a lot more we can specify
    as well, which has a powerful impact upon signal handling, and we shall come to
    all that shortly. Here is the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Feature Test Macro Requirements for `glibc` (see `feature_test_macros(7)`):
    `sigaction()`:  `_POSIX_C_SOURCE`'
  prefs: []
  type: TYPE_NORMAL
- en: '`siginfo_t`:  `_POSIX_C_SOURCE >= 199309L`'
  prefs: []
  type: TYPE_NORMAL
- en: The man page on `sigaction(2)` informs us (via the Feature Test Macro Requirements
    section; see further on for a few details) that using `sigaction` requires the
    definition of the `_POSIX_C_SOURCE` macro; this is almost always the case with
    modern code on Linux. Further, usage of the `siginfo_t` data structure (explained
    later in this chapter) requires you to have `POSIX` version `199309L` or later.
    (The format is `YYYYMM`; hence, that's the `POSIX` standard draft as of September
    1993; again, this would certainly be the case on any reasonably modern Linux platform).
  prefs: []
  type: TYPE_NORMAL
- en: Sidebar – the feature test macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A quick digression: feature test macros are a `glibc` feature; they allow a
    developer to specify, at compile time, the exact feature set by defining these
    macros in the source. The manual (man) pages always specify (as required), the
    feature test macros required to be present to support a certain API or feature.'
  prefs: []
  type: TYPE_NORMAL
- en: With regard to these feature test macros, on both the Ubuntu (17.10) and Fedora
    (27) Linux distributions, we have tested the source code of this book upon, the
    value of `_POSIX_C_SOURCE` is `200809L`. The macro is defined in the header file
    `<features.h>`, which is itself included in the header `<unistd.h>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple test program to print a few feature test macros is provided within
    the book''s GitHub source tree here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/tree/master/misc](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/tree/master/misc).
    Why not give it a try on your Linux platform?'
  prefs: []
  type: TYPE_NORMAL
- en: More on feature test macros from the `glibc` documentation: [http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html](http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html).
  prefs: []
  type: TYPE_NORMAL
- en: The sigaction structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sigaction(2)` system call takes three parameters, of which the second and
    third are of the same data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first parameter `int signum` is the signal to trap. This straight away
    reveals an important point: signals are meant to be trapped one at a time—you
    can only trap one signal with a single call to `sigaction`. Do not attempt to
    be overly clever and do things such as pass a bitmask of signals (bitwise-ORed)
    together; that''s a bug. Of course, you can always call `sigaction` multiple times
    or in a loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data type of the second and third parameters is a pointer to a structure
    called, again, `sigaction`. The `sigaction` structure definition is as follows
    (from the header `/usr/include/bits/sigaction.h`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first member, a function pointer, refers to the signal handler function itself.
    On modern Linux distributions, the `__USE_POSIX199309`  macro will indeed be defined;
    hence, as can be seen, the signal handler value is a union of two elements, implying
    that at runtime, exactly one of them will be used. The previous comments make
    it clear: by default, the `sa_handler` prototype function is used; however, if
    the flag `SA_SIGINFO` is passed along (in the third member `sa_flags`), then the
    `sa_sigaction` styled function is used. We shall make this clear with sample code
    soon.'
  prefs: []
  type: TYPE_NORMAL
- en: The C library specifies `__sighandler_t` as: `typedef void (*__sighandler_t)
    (int);`
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, it''s a pointer to a function that will receive one
    parameter: an integer value (yes, you guessed it: the signal that is delivered).'
  prefs: []
  type: TYPE_NORMAL
- en: Before going deeper into the data structure, it would be instructive to write
    and try out a simple C program that handles a couple of signals, using defaults
    for most of the previously mentioned `sigaction` structure members.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code of the `main()` function of `ch11/sig2.c` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We deliberately `memset(3)` the `sigaction` structure to all zeros, to initialize
    it (initializing is always good coding practice in any case!). Then, we initialize
    the signal handler to our own signal-handling function `siggy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how, to trap two signals, we require two `sigaction(2)` system calls.
    The second parameter, the pointer to struct `sigaction`, is to be populated by
    the programmer and is considered to be the new settings for the signal. The third
    parameter is, again, a pointer to struct `sigaction`; it, however, is a value-result type:
    if non-NULL and allocated, the kernel will populate it with the previous settings
    of the signal. This is a useful feature: what if the design requires you to perform
    a save and restore of some signal dispositions. Here, as a simple case, we just
    set the third parameter to `NULL`, implying that we are not interested in the
    previous signal state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then enter the same (as `sig1.c`) infinite loop... Our simple signal handler
    function `siggy` is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The signal handler receives one integer value as its parameter: the signal
    that caused control to reach here. Hence, we can multiplex on multiple signals:
    set up a common signal handler and perform a simple switch-case to handle each
    specific signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The signal handling function''s return type is `void`, of course. Ask yourself:
    Where will it return? It''s an unknown. Remember, signals can arrive asynchronously; we
    have no idea when exactly the handler will run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this time, the `SIGINT` (via keyboard `^C`) and the `SIGQUIT`
    (via keyboard `**^\**` key combination) signals are being handled by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do we terminate the app? Well, one way is to open another terminal
    window and kill the app via the `kill` utility. For now, though, we use another
    method: we send the `SIGTSTP` signal to the process (via keyboard `**^Z**` key
    combination) to put it into the stopped state; we get back the shell. Now, we
    simply kill it via `kill(1)`.(`[1]` is the process''s job number; you can use
    the `jobs` command to see all current jobs on the session).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We show this in the form of a diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/871c65ca-8d1e-4ef9-8d22-0ced84f61f91.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Handling a Signal'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, as demonstrated by our simple `sig2` application and *Figure 2*, once
    a signal is trapped (via the `sigaction(2)` (or the signal) system call), when
    it is delivered to the process, control is now re-vectored to the new application-specific
    signal handler function, and not to the default OS signal-handling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the program `sig2`, all looks good, except that you, the careful reader,
    may have noticed a bit of a puzzle: in the siggy signal handler function''s code, why
    not just use a simple `printf(3)` to emit a message. Why  the `write(2)` system
    call? Actually, there''s a really good reason behind this. This, and more, is
    coming up.'
  prefs: []
  type: TYPE_NORMAL
- en: Trap all required signals as early as possible, in the application's initialization.
    This is because signals can arrive at any moment; the sooner we are ready to handle
    them, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Masking signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While a process is running, what if it wants to block (or mask) certain signals?
    This is indeed possible via the API interface; in fact, the second member of the `sigaction(2)` structure
    is the signal mask, the mask of signals to block from delivery to the process while
    the signal handler function is running. A mask typically implies a bitwise-or
    of signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do notice the previous comment; it implies some signal is already being blocked.
    Yes, indeed; let's say a process traps a signal `n` via the `sigaction` system
    call. At some later point that signal n is delivered to it; while our process
    handles the signal—that is, runs the code of its signal handler—that signal n
    is blocked from delivery to the process. For how long is it blocked? Until we
    return from the signal handler. In other words, the OS auto-blocks the signal
    currently being handled. This usually is precisely what we want, and it works
    to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: Signal masking with the sigprocmask API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if we want to block (or mask) some other signals during execution. For
    example, while processing a critical region of code? The system call `sigprocmask(2)` is
    designed for this purpose:  `int sigprocmask(int how, const sigset_t *set, sigset_t
    *oldset);`
  prefs: []
  type: TYPE_NORMAL
- en: 'The signal sets are essentially bitmasks of the signals in question. The set is
    the new set of signals to mask, while `oldset` is actually a return value (the value-result
    type of parameter), or the previous (or current)  value of the signal mask. The `how` parameter
    determines the behavior and can take these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIG_BLOCK` : Additionally, block (mask) the signals specified in the signal
    set set (along with the signals already masked)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIG_UNBLOCK` : Unblock (unmask) the signals specified in the signal set set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIG_SETMASK` : The signals specified in the signal set set are masked, overwriting
    the previous values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying the signal mask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we understand that you can set the process's signal mask at the time of `sigaction(2)`
    (via the ` sa_mask` member), or via the `*s*igprocmask(2)` system call (as mentioned
    previously). But how exactly can you query the state of the process signal mask
    at any arbitrary point in time?
  prefs: []
  type: TYPE_NORMAL
- en: Well, again, via the `sigprocmask(2)` system call. But, logically, this API sets a
    mask, right? This is the trick: if the first parameter set is set to `NULL`, then
    the second parameter is effectively ignored, while in the third parameter `oldset`, the
    current signal mask value is populated, and thus we can query the signal mask
    without altering it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ch11/query_mask` program demonstrates this, the code is built upon our
    previous example `sig2.c`. Hence, we do not need to show the entire source; we
    just show the relevant code, in `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this time we use the `sigfillset(3)` (one of the useful `POSIX`
    signal set operations or `sigsetops(3)` operators) to populate the signal mask
    with all 1's, implying that, while the signal handler code is running, all signals
    will be masked (blocked).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the relevant portion of the signal handler code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah! Here, the intelligence is within the `show_blocked_signals` function; we
    have this function in our common code source file: `../common.c`. Here''s the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The key here is this: the `sigprocmask(2)` is used with a NULL second parameter
    (the mask to set); hence, as stated earlier, the how parameter is ignored and
    the value-result third parameter `oldset` will hold the current process signal
    mask.'
  prefs: []
  type: TYPE_NORMAL
- en: We can query each signal bit in the bitmask using, again, the `sigsetops:` `sigismember(3)` convenience
    method. Now all that's left to do is iterate over each bit in the mask and print
    the signal number, if the bit is set, or ignore it if it is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output of a test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the blocked signals are printed out. Hey, can you spot the missing signals?
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGKILL(#9)` and `SIGSTOP(#19)` cannot be masked; also, signals 32 and 33
    are internally reserved for and used by the `Pthreads` implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Sidebar – signal handling within the OS – polling not interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we do not intend to delve deep into the Linux kernel internal details
    of signal handling; rather, we''d like to make clear a common misconception hinted
    at earlier: handling signals is not at all like hardware interrupt handling. Signals
    are not interrupts, nor faults or exceptions; all of these— interrupts, traps,
    exceptions, faults—are raised by the PIC/MMU/CPU hardware on a computer. Signals
    are purely a software feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Delivering a signal to a process implies setting some members in the task structure of
    the task (in kernel memory), the so-called `TIF_SIGPENDING` bit, and the particular
    bit(s) representing the signal(s) in the task's `sigpending` set; this way, the
    kernel knows whether, and which, signals are pending delivery to the process.
  prefs: []
  type: TYPE_NORMAL
- en: The reality is that at opportune points in time (which occur regularly), the
    kernel code checks whether a signal(s) is pending delivery, and, if so, delivers
    it, running or consuming the signal handler(s) of the process (in userland context).
    Signal handling is thus considered to be more of a polling mechanism rather than
    an interrupt one.
  prefs: []
  type: TYPE_NORMAL
- en: Reentrant safety and signalling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an important-to-understand issue during signal handling, when working
    with reentrant-unsafe (also called async-signal-unsafe) functions within a signal
    handler.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, to understand this issue, you must first understand what exactly
    a reentrant function is, and, subsequently, what is meant by reentrant-safe or
    async-signal-safe functions.
  prefs: []
  type: TYPE_NORMAL
- en: Reentrant functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A reentrant function is one that can be reentered while an ongoing invocation
    is still running. It''s simpler than it sounds; check out this pseudo-code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now imagine this sequence of activity:'
  prefs: []
  type: TYPE_NORMAL
- en: The function `my_foo()` is invoked by the business logic function `do_the_work_mate()`;
    it operates on the local buffer `mybuf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this is still running, a signal is dispatched to this process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signal handler code preempts whatever was executing at the moment it occurred
    and runs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reinvokes the function `my_foo()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, there we see it: the function `my_foo()` is reentered. By itself, that''s
    OK; the important question here is: is it safe?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall (from our coverage in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*) that the process stack is used to hold function call frames
    and, hence, any local variables. Here, the reentrant function `my_foo()` only
    uses a local variable. It''s been invoked twice; each invocation will be a separate
    call frame on the process stack. The key point: each invocation of `my_foo()`
    works on a copy of the local variable `mybuf`; thus, it is safe. Hence, it''s
    documented as being `reentrant-safe`. In the signal-handling context, it''s called
    being `async-signal-safe`: invoking the function from within a signal handler
    while a previous invocation is still running is safe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s add a twist to the previous pseudo-code: change the function `my_foo()`''s
    local variable `mybuf` to become a global (or static) variable. Now think about
    what happens when it''s reentered; this time, distinct stack call frames cannot
    save us. As `mybuf` is global, there exists only one copy of it, which will be
    in an inconsistent state from the first function invocation (by `do_the_work_mate()`
    ). When the second invocation of `my_foo()` occurs, we will work on this inconsistent
    global `mybuf`, thus corrupting it. Hence, clearly, this is unsafe.'
  prefs: []
  type: TYPE_NORMAL
- en: Async-signal-safe functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a general rule, functions that use only local variables are reentrant-safe;
    any usage of a global or a static data renders them unsafe. This is a key point:
    you can only call those functions in a signal handler that are documented as being
    reentrant-safe or signal-async-safe.'
  prefs: []
  type: TYPE_NORMAL
- en: The man page on `signal-safety(7)` [http://man7.org/linux/man-pages/man7/signal-safety.7.html](http://man7.org/linux/man-pages/man7/signal-safety.7.html)
    provides details for this.
  prefs: []
  type: TYPE_NORMAL
- en: On Ubuntu, the man page with this name (`signal-safety(7)`) was installed in
    recent versions only; it does work on Ubuntu 18.04.
  prefs: []
  type: TYPE_NORMAL
- en: Among them, it publishes a list of (alphabetically ordered) functions that the
    `POSIX.1` standard requires an implementation to guarantee are implemented as
    being async-signal-safe, (See man page version 4.12, dated 2017-03-13)
  prefs: []
  type: TYPE_NORMAL
- en: 'So the bottom line is this: from within a signal handler, you can only invoke
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: C library functions or system calls that are in the signal-safety(7) man page
    (do look it up)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within a third-party library, functions explicitly documented as being async-signal-safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your own library or other functions that have been explicitly written to be async-signal-safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, don't forget that your signal handler function itself must be reentrant-safe.
    Do not access application global or static variables within it.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate ways to be safe within a signal handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we must access some global state within our signal handler routine?
    There do exist some alternate ways of making it signal-safe:'
  prefs: []
  type: TYPE_NORMAL
- en: At the point you must access these variables, ensure that all signals are blocked
    (or masked), and, once done, restore the signal state (unmask).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform some kind of locking on shared data while accessing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In multiprocess applications (the case we are talking about here), (binary) semaphores can
    be used as a locking mechanism to protect shared data across processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In multithreaded applications, the use of an appropriate locking mechanism (mutex
    locks, perhaps; we shall, of course, cover this in a later chapter in detail).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your requirement is to just operate upon global integers (a common case for
    signal handling!), use a special data type (the `sig_atomic_t`). Seen later on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reality is that the first approach, blocking signals when required, is difficult
    to achieve in practice on complex projects (although you certainly can arrange
    for all signals to be masked while handling a signal by setting the signal mask
    to all 1s, as demonstrated in the previous section, *Querying the signal mask*).
  prefs: []
  type: TYPE_NORMAL
- en: The second approach, locking, is realistic though performance-sensitive for
    multiprocess and multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: Here and now, while discussing signalling, we shall cover the third approach.
    Another reason for this is because working on (querying and/or setting) an integer
    within a signal handler is a very common case.
  prefs: []
  type: TYPE_NORMAL
- en: Within the code we show in this book, there is the occasional use of async-signal-
    unsafe functions being used within a signal handler (usually one of the `[f|s|v]printf(3)`
    family). We stress that this has been done purely for demonstration purposes only;
    please do not give into temptation and use async-signal-unsafe functions in production
    code!
  prefs: []
  type: TYPE_NORMAL
- en: Signal-safe atomic integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visualize a multiprocess application. A process, A, must complete a certain
    quantum of work (let's say it must complete running a function `foo()`) and let
    another process, B, know that it has done so (in other words, we want synchronization between
    the two processes; see the next info box as well).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to achieve this is as follows: have process `A` send a signal
    (say `SIGUSR1`)  to process `B` when it has reached the required point. In turn,
    process B traps `SIGUSR1`, and when it does arrive, in its signal handler, it
    sets a global buffer to an appropriate message string to let the rest of the application
    know that we have reached this point.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following tables, visualize the timeline going vertically (*y* axis)
    downward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pseudo-code—the wrong way:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Process A** | **Process B** |'
  prefs: []
  type: TYPE_TB
- en: '| Do work | Set up signal handler for `SIGUSR1` |'
  prefs: []
  type: TYPE_TB
- en: '| Work on `foo()` | `char gMsg[32];   // global` Do work |'
  prefs: []
  type: TYPE_TB
- en: '| `foo()` done; send `SIGUSR1` to process `B` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `signal_handler()`function entered asynchronously |'
  prefs: []
  type: TYPE_TB
- en: '|  | `strncpy(gMsg, "chkpointA", 32);` |'
  prefs: []
  type: TYPE_TB
- en: '| [...] | [...] |'
  prefs: []
  type: TYPE_TB
- en: This looks fine, except that, please notice that, this global update on the
    message buffer `gMsg` is not guaranteed to be atomic. It's entirely possible that
    attempting to do so will result in a race—a condition in which we cannot predict
    with any certainty what the final result of the global variable will be. It's
    exactly this kind of data race that is the perfect breeding ground for a class
    of difficult-to-see-and-solve racy bugs. You must avoid them by using proper programming
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution: Switch from using a global buffer to a global integer-like variable
    of data type **`sig_atomic_t`**, and, importantly, mark it as `volatile` (so that
    the compiler disables optimizations around it).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pseudo-code – the right way:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Process A** | **Process B** |'
  prefs: []
  type: TYPE_TB
- en: '| Do work | Set up signal handler for `SIGUSR1` |'
  prefs: []
  type: TYPE_TB
- en: '| Work on `foo()` | **`volatile sig_atomic_t gFlag=0;`** Do work |'
  prefs: []
  type: TYPE_TB
- en: '| `foo()` done; send `SIGUSR1` to process `B` |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | `signal_handler()`function entered asynchronously |'
  prefs: []
  type: TYPE_TB
- en: '|  | **`gFlag = 1;`** |'
  prefs: []
  type: TYPE_TB
- en: '| [...] | [...] |'
  prefs: []
  type: TYPE_TB
- en: This time it will work just fine, without any race. (Writing the complete working
    code of the previous program is suggested as an exercise to readers).
  prefs: []
  type: TYPE_NORMAL
- en: It's important to realize that the usage of `sig_atomic_t` makes an (integer)
    variable only async-signal safe, not thread-safe. (Thread safety will be covered
    in detail in later [Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml), *Multithreading
    with Pthreads Part I - Essentials*).
  prefs: []
  type: TYPE_NORMAL
- en: True process synchronization should be performed using an IPC mechanism appropriate
    for the purpose. Signals do serve as a primitive IPC mechanism; depending on your
    project,  other IPC mechanisms (sockets, message queues, shared memory, pipes,
    and semaphores)  might well be a better way to do so, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Carnegie Mellon University''s Software Engineering Institute (CMU
    SEI) CERT C Coding Standard:'
  prefs: []
  type: TYPE_NORMAL
- en: SIG31-C:Do not access shared objects in signal handlers *(*[https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers](https://wiki.sei.cmu.edu/confluence/display/c/SIG31-C.+Do+not+access+shared+objects+in+signal+handlers))
  prefs: []
  type: TYPE_NORMAL
- en: The type `sig_atomic_t` is the integer type of an object that can be accessed
    as an atomic entity even in the presence of asynchronous interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional note:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth checking out the code examples provided within the last link as
    well. Also, within the same context, the CMU SEI''s CERT C Coding Standard*, *the
    following points are noted, regarding the correct way to perform signal handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIG30-C`. Call only asynchronous-safe functions within signal handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIG31-C`: Do not access shared objects in signal handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIG34-C`. Do not call `signal()` from within interruptible signal handlers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIG35-C`. Do not return from a computational exception signal handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last bullet point is perhaps better phrased by the `POSIX.1` committee:'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of a process is undefined after it returns normally from a signal-catching
    function for a SIGBUS, SIGFPE, SIGILL, or SIGSEGV signal that was not generated
    by `kill(2)`, `sigqueue(3)`, or `raise(2)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, once your process receives any of the previously mentioned
    fatal signals from the OS, it can perform cleanup within it''s signal handler,
    but then it must terminate. (Allow us this joke: the hero exclaiming "Not today,
    Death!" , is all well and good in the movies, but when SIGBUS, SIGFPE, SIGILL,
    or SIGSEGV come calling, it''s time to clean up and gracefully die!). As a matter
    of fact, we delve into this aspect in a lot of detail within the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Powerful sigaction flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the previous section The `sigaction` structure, recall that one of the
    members of the `sigaction` structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These special flags are very powerful. With them, the developer can precisely
    specify signal semantics that would otherwise be hard or impossible to obtain.
    The default value of zero implies no special behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall first enumerate the `sa_flags` possible values in this table and then
    proceed to work with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `sa_flag` | Behavior or semantic it provides (from the man page on `sigaction(2)`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SA_NOCLDSTOP` | If `signum` is `SIGCHLD`, do not generate `SIGCHLD` when
    children stop or stopped children continue. |'
  prefs: []
  type: TYPE_TB
- en: '| `SA_NOCLDWAIT` | (Linux 2.6 and later) If `signum` is `SIGCHLD`, do not transform
    children into zombies when they terminate. |'
  prefs: []
  type: TYPE_TB
- en: '| `SA_RESTART` | Provide behavior compatible with BSD signal semantics by making
    certain system calls restartable across signals. |'
  prefs: []
  type: TYPE_TB
- en: '| `SA_RESETHAND` | Restore the signal action to the default upon entry to the
    signal handler. |'
  prefs: []
  type: TYPE_TB
- en: '| `SA_NODEFER` | Do not prevent the signal from being received from within
    its own signal handler. |'
  prefs: []
  type: TYPE_TB
- en: '| `SA_ONSTACK` | Call the signal handler on an alternate signal stack provided
    by `sigaltstack(2)`. If an alternate stack is not available, the default (process)
    stack will be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `SA_SIGINFO` | The signal handler takes three arguments, not one. In this
    case, `sa_sigaction` should be set instead of `sa_handler`. |'
  prefs: []
  type: TYPE_TB
- en: Keep in mind that `sa_flags` is an integer value interpreted by the OS as a bitmask; bitwise-ORing
    several flags together to imply their combined behavior is indeed common practice.
  prefs: []
  type: TYPE_NORMAL
- en: Zombies not invited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with the flag `SA_NOCLDWAIT`. First, a quick digression:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),
    *Process Creation*, a process can fork, resulting in an act of creation: a new
    child process is born! From that chapter, it is now relevant to recall our Fork
    **Rule #7**: The parent process must wait (block) upon the termination (death)
    of every child, directly or indirectly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent process can wait (block) upon the child''s termination via the waitsystem
    call API set. As we learned earlier, this is essential: if the child dies and
    the parent has not waited upon it, the child becomes a zombie—an undesirable state
    to be in, at best. At worst, it can terribly clog system resources.'
  prefs: []
  type: TYPE_NORMAL
- en: However, blocking upon the death of the child (or children) via the wait API(s)
    causes the parent to become synchronous; it blocks, and thus, in a sense, it defeats
    the whole purpose of multiprocessing, to be parallelized. Can we not be asynchronously notified
    when our children die? This way, the parent can continue to perform processing,
    running in parallel with its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ah! Signals to the rescue: the OS will deliver the  `SIGCHLD` signal to the
    parent process whenever any of its children terminate or enter the stopped state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay attention to the last detail: the `SIGCHLD` will be delivered even if a
    child process stops (and is thus not dead). What if we do not want that? In other
    words, we only want the signal sent to us when our children die. That is precisely
    what the `SA_NOCLDSTOP` flag performs: no child death on stop. So, if you do not
    want to get spoofed by the stopping of the children into thinking they''re dead,
    use this flag. (This also applies when a stopped child is subsequently continued,
    via the `SIGCONT`).'
  prefs: []
  type: TYPE_NORMAL
- en: No zombies! – the classic way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous discussion should also make you realize that, hey, we now have
    a neat asynchronous way in which to get rid of any pesky zombies: trap the `SIGCHLD`,
    and in its signal handler, issue the wait call (using any of the wait APIs covered
    in [Chapter 9](3b2340aa-4ab7-46e3-93c0-7f7c210f834b.xhtml), *Process Execution*),
    preferably with the `WNOHANG` option parameter such that we perform a non-blocking
    wait; thus, we do not block upon any live children and just succeed in clearing
    any zombies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the classic Unix way to clear zombies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Delving into depth here would be of academic interest only on modern Linux (modern
    Linux, in your author's opinion, being the 2.6.0 Linux kernel and beyond, which,
    by the way, was released on December 18, 2003).
  prefs: []
  type: TYPE_NORMAL
- en: No zombies! – the modern way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, with modern Linux, avoiding zombies became vastly easier: just trap the
    `SIGCHLD` signal using `sigaction(2)`, specifying the `SA_NOCLDWAIT` bit in the
    signal flags bitmask. That''s it: zombie worries banished forever! On the Linux
    platform, the `SIGCHLD` signal is still delivered to the parent process—you can
    use it to keep track of children, or whatever accounting purposes you may dream
    up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, the `POSIX.1` standard also specifies another way to get rid of
    the pesky zombie: just ignore the `SIGCHLD` signal (with the `SIG_IGN`). Well,
    you can use this approach, with the caveat that then you will never know when
    a child does indeed die (or stop).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, useful stuff: let''s put our new knowledge to the test: we rig up a small multiprocess
    application that generates zombies, but also clears them in the modern way as
    follows (`ch11/zombies_clear_linux26.c`):'
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only the relevant parts of the code are displayed; to view
    and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '(For now, ignore the `SA_RESTART` flag in the code; we shall explain it shortly). Here
    is the signal handler for `SIGCHLD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we only emit a `printf(3)` within the signal handler when in debug
    mode (as it's async-signal unsafe).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, first we try it with option `1`; that is, using the `SA_NOCLDWAIT` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Importantly, checking with `ps(1)` reveals there is no zombie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run it with option `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `*** Child dies! ***` message (that we did get in the previous
    run) does not appear, proving that we never enter the signal handler for `SIGCHLD`.
    Of course not; we ignored the signal. While that does prevent the zombie, it also
    prevents us from knowing that a child has died.
  prefs: []
  type: TYPE_NORMAL
- en: The SA_NOCLDSTOP flag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regarding the `SIGCHLD` signal, there is an important point to realize: The
    default behavior is that, whether a process dies or stops, or a stopped child
    continues execution (typically via the `SIGCONT` signal being sent to it), the
    kernel posts the `SIGCHLD` signal to its parent.'
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps this is useful. The parent is informed of all these events—the child's
    death, stop-page, or continuation. On the other hand, perhaps we do not want to
    be spoofed into thinking that our child process has died, when in reality it has
    just been stopped (or continued).
  prefs: []
  type: TYPE_NORMAL
- en: For such cases, use the `SA_NOCLDSTOP` flag; it literally means no `SIGCHLD`
    on child stop (or resume). Now you will only get the `SIGCHLD` upon child death.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupted system calls and how to fix them with the SA_RESTART
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Traditional (older) Unix OSes suffered from an issue regarding the handling
    of signals while processing blocking system calls.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking APIs
  prefs: []
  type: TYPE_NORMAL
- en: An API is said to be blocking when, on issuing the API, the calling process
    (or thread) is put into a sleep state. Why is this? This is because the underlying
    OS or device driver understands that the event that the caller needs to wait upon
    has not yet occurred; thus, it must wait for it. Once the event (or condition)
    arises, the OS or driver wakes up the process; the process now continues to execute
    its code path.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of blocking APIs are common: read, write, select, wait (and its variants), accept, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a moment to visualize this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: A process traps a signal (say, `SIGCHLD`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process, at some later point, issues a blocking system call (say, the `accept(2)`
    system call).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it's in the sleep state, the signal is delivered to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following pseudo code illustrates the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By the way, the `accept(2)` system call is how a network server process blocks
    (waits) upon a client connecting to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'What should happen, now that the signal is delivered? The correct behavior
    is this: the process should wake up, handle the signal (run the code of its signal
    handler), and go to sleep once again, continuing to block upon the event it was
    waiting upon.'
  prefs: []
  type: TYPE_NORMAL
- en: On older Unixes (your author has come across this on an old SunOS 4.x), the
    signal is delivered, the signal handler code runs, but after that the blocking
    system call fails, returning -1\. The `errno` variable is set to **`EINTR`** ,
    which translates to an interrupted system call.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is considered a bug, of course. The poor Unix application developer had
    to resort to some temporary fixes, often resorting to wrapping each and every
    system call (foo in this example) in a loop, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is not easily maintainable*.*
  prefs: []
  type: TYPE_NORMAL
- en: The `POSIX` committee subsequently fixed this, requiring an implementation to
    provide a signal flag`SA_RESTART`. When this flag is used, the kernel will auto-restart
    any blocking system calls that happen to get interrupted by a signal or signals.
  prefs: []
  type: TYPE_NORMAL
- en: So, just use the useful `SA_RESTART` flag within your `sigaction(2)` when registering
    your signal handler(s), and this issue will disappear.
  prefs: []
  type: TYPE_NORMAL
- en: In general, using the `SA_RESTART` flag when programming the `sigaction(2)` would
    be a good idea. Not always, though; the [Chapter 13](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml), 
    *Timers*, shows us use cases in which we deliberately keep away from this flag.
  prefs: []
  type: TYPE_NORMAL
- en: The once only SA_RESETHAND flag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SA_RESETHAND` signal flag is a bit peculiar. On older Unix platforms,
    there existed a bug that went like this: a signal is trapped (via the `signal(2)`
    function), the signal is dispatched, and then the process handles the signal.
    But, immediately on entering the signal handler, the kernel now resets the signal
    action to the original OS default handling code. So, the second time the signal
    arrives, the default handler code runs, often killing the process in the bargain.
    (Again, Unix developers sometimes had to resort to some bad racy code to try to
    fix this).'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the signal would effectively be delivered only once. On today's modern
    Linux systems, a signal handler remains as it is; it is not reset by default to
    the original handler. Unless, of course, you want this once-only behavior, in
    this case, use the `SA_RESETHAND` flag (you would imagine that it's not terribly
    popular). Also, `SA_ONESHOT` is an older deprecated name for the same flag.
  prefs: []
  type: TYPE_NORMAL
- en: To defer or not? Working with SA_NODEFER
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets recall how signals are handled by default:'
  prefs: []
  type: TYPE_NORMAL
- en: A process traps a signal n.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal n is delivered to the process (either by another process or the OS).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signal handler is dispatched; that is, it runs in response to the signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal n is now auto-masked; that is, blocked from delivery to the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal handling is completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal n is now auto-unmasked, that is, enabled for delivery to the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is reasonable: while handling a particular signal, that signal is masked. This
    is the default behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: However, what if you are writing, say, an embedded real-time application, where
    the signal delivery implies some real-world event has occurred and the application must respond
    to this immediately (as soon as possible). In cases such as this, we would perhaps
    want to disable the auto-masking of signals, thus allowing the signal handler
    to be reentered the moment it arrives. Precisely this can be achieved by using
    the `SA_NODEFER` signal flag.
  prefs: []
  type: TYPE_NORMAL
- en: The English word defer means to delay or postpone; to put off until later.
  prefs: []
  type: TYPE_NORMAL
- en: This is the default behavior, which you can change when the flag is specified.
  prefs: []
  type: TYPE_NORMAL
- en: Signal behavior when masked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand this better, let''s take a fictional example: say we trap a signal
    n, and the execution time for our signal handler for signal n is 55 ms (milliseconds).
    Also, visualize a scenario in which, via a timer (for a while at least), signal
    n is delivered to the process continually at 10-ms intervals. Now let''s examine
    what would happen in the default case and the case in which we use the `SA_NODEFER`
    flag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Case 1 : Default : SA_NODEFER bit cleared'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we are *not* using the `SA_NODEFER` signal flag. So, when the first instance
    of signal n arrives, our process jumps into the signal-handling code (which will
    take 55 ms to complete). However, the second signal will arrive just 10 ms into
    the signal handling code. But, hang on, it''s auto-masked! Hence, we will not
    process it. In fact, a simple calculation will show that up to five instances
    of signal n will reach our process in the 55-ms signal handling time frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a470eda4-bde5-496d-84ad-81922157ac9d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Default behavior: SA_NODEFER bit cleared: no queue, one signal instance
    pending delivery, no real impact on stack'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what exactly happens? Will these five signals be queued up for delivery
    once the handler completes? Ah! This is an important point: standard or Unix signals are not
    queued. However, the kernel does understand that one or more signals are pending
    delivery to the process; hence, once signal handling is done, exactly one instance
    of the pending signal is delivered (and the pending signal mask is subsequently
    cleared).'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in our example, even though five signals were pending delivery, the signal
    handler will get invoked only once. In other words, no signals were queued, but
    one signal instance was served. This is how signalling works by default.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3* shows this situation: the dashed signal arrows represent signals
    that were delivered after entering the signal handler; hence, just one instance
    is kept pending. Notice the process stack: the signal instance #1 of signal n
    (obviously) gets a call frame on the stack when the signal handler is invoked,
    nothing more.'
  prefs: []
  type: TYPE_NORMAL
- en: Question: What if the situation is as shown, but another signal, signal `m`,
    is delivered?
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: If signal m has been caught and is currently unmasked, it will be processed
    immediately; in other words, it will preempt everything, and its handler will
    run. Of course, the context is saved by the OS such that whatever got preempted
    can be later continued once context is restored. This has us conclude the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Signals are peers; they have no priority associated with them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For standard signals, if several instances of the same integer value are delivered,
    and that signal is currently masked (blocked), then only one instance is kept
    pending; there is no queuing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case 2 : SA_NODEFER bit set'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s reconsider the very same scenario, only this time we use the `SA_NODEFER`
    signal flag. So, when the first instance of signal n arrives, our process jumps
    into the signal-handling code (which will take 55 ms to complete). As before, the
    second signal will arrive just 10 ms into the signal-handling code, but hang on,
    this time it is not masked; it is not deferred. Thus, we will reenter the signal
    handler function immediately. Then, 20 ms later (after the signal handler was
    first entered by signal n instance #1), the third signal instance arrives. Again,
    we will reenter the signal handler function. Yes, this will happen five times.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4 shows us this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4cd933d7-71b6-42b2-9062-a782900cbb23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: SA_NODEFER bit set: no queue; all signal instances processed upon
    delivery, stack intensive'
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks good, but please realize the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The signal handler code itself must be written to be reentrant-safe (no global
    or static variable usage; only call async-signal safe functions within it), as
    it is being continually reentered in this scenario.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stack usage: every time the signal handler is reentered, do realize that an
    additional call frame has been allocated (pushed) on to the process stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second point bears thinking about: what if so many signals arrive (while
    handling previous invocations) that we overload and, indeed, overflow the stack?
    Well, disaster. Stack overflow is a bad bug; no exception handling is practically
    possible (we cannot, with any degree of confidence, catch  or trap into a stack
    overflow issue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A interesting code example `ch11/defer_or_not.c` follows to demonstrate both
    of these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: For readability, only key parts of the code are displayed; to view the complete
    source code, build and run it; the entire tree is available for cloning from the
    book's GitHub repo here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the signal handler function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We deliberately let the signal-handling code take a fairly long time (via our
    use of the `DELAY_LOOP` macro) so that we can simulate the case in which the same
    signal is delivered multiple times while it is being handled. In a real-world
    application, always strive to keep your signal handling as brief as is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inline-assembly stack() function is an interesting way to get a register''s
    value. Read the following comment to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The processor ABI - Application Binary Interface—documentation is an important
    area for the serious systems developer to be conversant with; check out more on
    this in the *Further reading* section on the GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly test this application, we write a small shell script `bombard_sig.sh`,
    which literally bombards the given process with the (same) signal (we use SIGUSR1
    here). The user is expected to pass the process PID and the number of signal instances
    to send as parameters; if the second parameter is given as `-1`, the script continually
    bombards the process. Here is the key code of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Running of case 1 – SA_NODEFER bit cleared [default]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we execute the test case wherein the `SA_NODEFER` flag is cleared; this
    is the default behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in another terminal window, we run the shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pgrep `figures out the PID of the `defer_or_not` process: useful! Just
    ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: (a) Only one instance of the process you are sending signals to is alive, or `pgrep `returns
    multiple PIDs and the script fails.
  prefs: []
  type: TYPE_NORMAL
- en: (b) The name passed to pgrep is 15 characters or less.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the script runs, firing off (12) signals to the process, this output
    appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Studying the preceding output, we notice as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGUSR1` is caught and its signal handler runs; it emits a stream of numbers
    (incremented on each signal instance).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do so correctly, we use a couple of  `volatile sig_atomic_t` globals (one
    for the value to print in the `DELAY_LOOP` macro and one to keep track of the
    total number of signals delivered to the process).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asterisk character `*` at the end of the digits implies that, by the time
    you see it, the signal handler has completed execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though 12 instances of the `SIGUSR1` signal were delivered, the process was
    handling the first signal instance when the remaining 11 signals arrived; hence, only one
    was kept pending and processed after the handler completed. Of course, on different
    systems, it can always happen that you see more than one signal instance being
    handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, notice that we print the stack pointer value at every signal handler
    invocation; it's a user-space virtual address, of course (recall our discussions
    in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*);
    more importantly, it's identical, implying that the very same stack frame was
    reused for the signal handler function (this often happens).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running of case 2 – SA_NODEFER bit set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we execute the test case, wherein the `SA_NODEFER` flag is set (first
    ensure you have killed off any old instances of the `defer_or_not` process):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in another Terminal window, we run the shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as the script runs, firing off (12) signals to the process, the output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, notice these things:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGUSR1` is caught and its signal handler runs; it emits a stream of numbers
    (incremented on each signal instance).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do so correctly, we use a `volatile sig_atomic_t` global (one for the value
    to print in the `DELAY_LOOP` and one to keep track of the total number of signals
    delivered to the process).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The asterisk character `*`at the end of the digits implies that, by the time
    you see it, the signal handler has completed execution; notice that this time,
    the * does not appear until much later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Twelve instances of the signal `SIGUSR1` are delivered one after the other:
    this time, each instance preempts the previous one (setting up a new call frame
    on the process stack; notice the unique stack pointer addresses).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice how, after all signal instances have been handled, control is restored
    to the original context; we literally can see the stack unwind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, look carefully at the stack pointer values; they are progressively decreasing.
    This, of course, is because on the `x86[_64]` CPU (as is the case on most modern
    CPUs), a downward-growing stack is the way it works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do try out the program for yourself and see. It is interesting and powerful,
    but, remember, this is at the cost of being very stack intensive!
  prefs: []
  type: TYPE_NORMAL
- en: 'How expensive is it (in terms of stack memory usage)? We can actually calculate
    the size of each stack (call) frame; take any two differing instances and subtract
    the lower from the higher. For example, let''s take the preceding case `s=6` and
    `s=5` : `s=5: 0x7ffe9e1784b0`      `s=6: 0x7ffe9e177db0`'
  prefs: []
  type: TYPE_NORMAL
- en: So, call frame `size =  0x7ffe9e1784b0 - 0x7ffe9e177db0 = 0x700 = 1792` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Here, for this particular application use case, each signal-handling call frame
    takes up to 1,792 bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a worst-case scenario now: With an embedded real-time application,
    what if we receive, say, 5,000 signals very rapidly, while a previous instance
    is running (and of course the `SA_NODEFER` flag is set): We shall then end up
    creating 5,000 additional call frames on the process stack, which will cost approximately
    5,000 x 1,792 = 8,960,000 = ~ 8.5 MB!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not actually test this case? (The value of being empirical - trying things
    out rather than just assuming them, is critical. See [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, as well). We do so as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In another Terminal window, run the `bombard_sig.sh` script, asking it to generate
    5,000 signal instances. Refer to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output in the first Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It crashes, of course, when it runs out of stack space.(Again, the results may
    vary on different systems; if you do not experience a crash, via stack overflow,
    with these numbers, try increasing the number of signals sent via the script and
    see...).
  prefs: []
  type: TYPE_NORMAL
- en: As we learned in [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource
    Limits*, the typical process stack resource limit is 8 MB; thus, here we are in
    real danger of overflowing the stack, which will result in a fatal and sudden
    crash, of course. So, be careful! If you intend to use the `SA_NODEFER` flag,
    take the trouble to stress test your application under heavy workloads and see
    if more of the stack is being used than is safe.
  prefs: []
  type: TYPE_NORMAL
- en: Using an alternate signal stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice how our previous test case, sending 5,000 `SIGUSR1` signals to the `defer_or_not` application
    running with `SA_NODEFER` set, caused it to crash with a segmentation fault (often
    abbreviated as segfault). The OS sent the signal `SIGSEGV` (segmentation violation)
    to the process when it made an invalid memory reference; in other words, a bug
    related to a memory access. Trapping the `SIGSEGV` could be very valuable; we
    can gain information concerning how and why the application crashed (in fact,
    we shall do precisely this in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, think carefully: in the last test case (the 5,000 signals... one),
    the reason the process crashed is that its stack overflowed. Thus, the OS delivered
    the signal `SIGSEGV`; we want to trap this signal and handle it. But there''s
    no space on the stack, so how can the signal handler function itself get invoked?
    This is a problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting solution exists: we can allocate (virtual) memory space for,
    and set up a separate alternate stack to be used for signal handling only. How?
    Via the `sigaltstack(2)` system call. It''s used for these kind of circumstances:
    you need to handle a `SIGSEGV`, but you''re out of stack space. Think about our
    previous real-time high-volume signal-handling application: we could perhaps redesign
    it such that we allocate a lot more space for a separate signal stack, so that
    it works in practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation to handle high-volume signals with an alternate signal stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an attempt at precisely that: the code for `ch11/altstack.c` and a
    run-time test. Also, we have added a neat feature (to the previous version: the
    `defer_or_not` program): sending the process `SIGUSR2` signal will have it print
    out the first and the most recent stack pointer address. It will also calculate
    and display the delta—in effect, the amount of stack memory used so far by the
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changes from `ch11/defer_or_not.c`:'
  prefs: []
  type: TYPE_NORMAL
- en: We also trap the signals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGUSR2`: to display the first and the most-recent stack pointer addresses
    and the delta between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGSEGV` : this is important in real-world applications. Trapping the `segfault`
    allows us to take control if the process crashes (here, probably due to stack
    overflow here) and perhaps display (or in real apps, write to a log) relevant
    information, perform cleanup, and then call `abort(3)` to exit. Realize that,
    after all, we must exit: the process is in an undefined state once this signal
    arrives from the OS. (Note that more detail on handling the `SIGSEGV` is covered
    in the next chapter).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid too much noise in the output, we replace the `DELAY_LOOP` macro with
    a silent version of the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For readability, only key parts of the code are displayed; to view the complete
    source code, build, and then run it, the entire tree is available for cloning
    from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `ch11/altstack.c:main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setup_altsigstack()` functions code is as follows :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The signal handling code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's perform some tests and run them considering the following cases.
  prefs: []
  type: TYPE_NORMAL
- en: Case 1 – very small (100 KB) alternate signal stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We deliberately allocate a very small amount of space for the alternate signal
    stack—just 100 kilobytes. Needless to say, it overflows quickly and segfaults;
    our handler for `SIGSEGV` runs, printing out some stats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In another Terminal window, run the shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output in the original window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, according to our metrics, the total alternate signal stack usage
    was 91,392 bytes, close to 100 KB, at the time it was overflowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell script terminates with the expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Case 2 : A large (16 MB) alternate signal stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This time, we deliberately allocate a generous amount of space for the alternate
    signal stack—16 megabytes. It can now handle a few thousand continuous signals.
    But, of course, at some point it will also overflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In another Terminal window, run the shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output in the original window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell script terminates with the expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This time, it managed to process around nine thousand signals before it ran
    out of stack. The total alternate signal stack usage was a huge 16,764,160 bytes,
    or close to 16 MB, at the time it was overflowed.
  prefs: []
  type: TYPE_NORMAL
- en: Different approaches to handling signals at high volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In conclusion, if you have a scenario in which a high volume of multiple signals
    of the same type (as well as other signals) are delivered at a rapid pace to the
    process, we run the risk of losing (or dropping) signals if we use the usual methods.
    As we have seen, we can successfully handle all signals in several ways, each
    with their own approaches to signal-handling at high volume—pros and cons as shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Pros** | **Cons/Limitations** |'
  prefs: []
  type: TYPE_TB
- en: '| Use `sigfillset(3)` just prior to calling `sigaction(2)` to ensure that while
    the signal is being handled, all other signals are blocked. | Simple and straightforward
    approach. | Can lead to significant (unacceptable) delays in handling and/or dropping
    of  signals. |'
  prefs: []
  type: TYPE_TB
- en: '| Setting the `SA_NODEFER` signal flag and handling all signals as they arrive.
    | Simple and straightforward approach. | On load, heavy stack usage, danger of
    stack overflow. |'
  prefs: []
  type: TYPE_TB
- en: '| Use an alternate signal stack, set the `SA_NODEFER` signal flag, and handle
    all signals as they arrive. | Can specify alternate stack size as required. |
    More work to setup; must carefully test under load to determine (max) stack size
    to use. |'
  prefs: []
  type: TYPE_TB
- en: '| Use real-time signals (covered in the following chapter). | The OS queues
    pending signals automatically, low stack usage, signal prioritization possible.
    | System-wide limit on the maximum number that can be queued (can be tuned as
    root). |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader has initially been introduced to the notion of signalling on
    the Linux OS, what signals are, why they are useful, and, then, in a lot of detail,
    how to effectively handle signals within your application.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there being even more to it, the following chapter continues this
    important discussion. See you there.
  prefs: []
  type: TYPE_NORMAL
