- en: Chapter 3. Data Structures in Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using more advanced data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using linked lists to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using stacks to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using queues to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using trees to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using graphs to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using STL lists to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using STL maps to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using STL hash tables to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures are used in the video games industry to organize code into more
    cleaner and more manageable. An average video game will have about 20,000 lines
    of code at least. If we do not use an effective storage system and structure to
    manage that code, it will become very difficult to debug. Also, we may end up
    writing the same code multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures are also very useful for searching elements if we have a large
    data set. Let us consider that we are making a MMO. From the thousands of players
    online playing the game, we need to isolate a player who has the most points on
    a certain day. If we have not organized the user data into some meaningful data
    structure, this might take a long time. On the other hand, using a suitable data
    structure can help us achieve this within seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Using more advanced data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to use advanced data structures. The main task
    of a programmer is to choose the correct data structure based on the need, so
    that the time taken to store and parse the data is minimized. Sometimes the choice
    of a correct data structure is more important than selecting a suitable algorithm
    to solve a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will see how easy it is to use advanced data structures and
    why we should use them. If we organize data into suitable structures, it becomes
    faster to access data and easier to apply complex algorithms to it.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add source files called `Source.cpp`, `LinkedList.h`/ `LinkedList.cpp` and `HashTables.h`/
    `HashTables.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `Source.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `LinkedList.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `LinkedList.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `HashTable.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `HashTables.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created this class to store different enemies using a hash table and
    then search for a particular enemy from the hash table using a key. The hash table
    in turn is created using a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: In the `LINKEDLIST` file, we have defined a struct to store a key and a pointer
    to the next value in the hash table. The main class contains a pointer reference
    of the struct called `ITEM`. Apart from that, the class contains length of the
    data and member functions to insert an item, remove an item, find an element,
    display the entire list, and find the length of the list.
  prefs: []
  type: TYPE_NORMAL
- en: In the `HASHTABLE` file, a hash table is created using a linked list. A reference
    of the linked list is created along with the length of the hash table array and
    a private function to return an array location of a particular item in the hash
    table array. Apart from that, the hash table has similar functionalities to the
    linked list, such as inserting an item, removing an item, and displaying the hash
    table.
  prefs: []
  type: TYPE_NORMAL
- en: From the driver program, an object of the struct is created to initialize the
    items to be pushed into the hash table. Then an object of the hash table is created
    and the items are pushed to the table and displayed. An item is also deleted from
    the table. Finally, a particular item called `Enemy4` is searched and the next
    key is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Using linked lists to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can use linked lists to store and organize
    data. The main advantage of a linked list in the games industry is that it is
    a dynamic data structure. However, it is bad for searching and inserting elements,
    as you need to find the information. The search is *O(n)*. This means we can assign
    memory to this data structure at runtime. In games, most things are created, destroyed,
    and updated at runtime, so using a linked list is very suitable. Linked lists
    can also be used to create linear data structures such as stacks and queues, which
    are equally important in game programming.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to use linked lists. Linked lists
    are a great way to store data and are used as base mechanics for other data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A linked list is used to create a data structure that stores data, and a field
    that contains the address of the next node. A linked list is made up of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04929_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our example, we have created a linked list using struct and used an iteration
    to populate the linked list. The main concept of a linked list, as explained before,
    is that it contains data of some kind and contains the address information of
    the next node. In our example, we have created a linked list to store the current
    level number and the address of the next level to be loaded. This kind of structure
    is really important in order to store the levels we want to load. Just by traversing
    the linked list, we can load the levels in the correct order. Even checkpoints
    in the game can be programmed in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using stacks to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stacks are an example of a linear data structure in C++. In this type of data
    structure, the order in which the data is entered into the data structure is very
    important. The last piece of data to be entered is the first piece of data to
    be deleted. That is why this is sometimes also referred to as the **last in first
    out** (**LIFO**) data structure. The process for entering data into a stack is
    called **push**, and the process of deleting data is called **pop**. Sometimes
    we just want to print the value at the top of the stack, without deleting or popping.
    The stack is used in a variety of areas in the games industry, but especially
    when creating a UI system for a game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working copy of Visual Studio installed on your Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to use the stack data structure.
    A stack is one of the easiest data structures to implement and is used in multiple
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we have used the `STACK` data structure to push the various
    UI elements into the stack. The `STACK` itself is created with the help of an
    array. While pushing an element, we need to check whether the stack is empty or
    already has some elements present. While popping elements, we need to delete the
    element that is at the top of the stack and change the pointer address accordingly.
    While printing the UI elements of the stack, we traverse the entire stack and
    display them from the top. Let us consider a game with the following levels: Main
    Menu, Chapter Select, Level Select, and Play Game. When we want to quit the game,
    we want the user to select the levels in reverse order. So the first level should
    be Play Game (Pause State), followed by Level Select, Chapter Select, and finally
    Main Menu. This can be easily achieved with a stack as explained in the previous
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: Using queues to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A queue is an example of a dynamic data structure. This means the size of the
    queue can be changed at runtime. This is a huge advantage when it comes to programming
    in games. Queues are enqeued/inserted from the rear of the data structure and
    dequeued/deleted/pushed out from the front of the data structure. This makes it
    a **first in first out** (**FIFO**) data structure. Imagine, in a game, we have
    an inventory but we want to make the player use the first item he has picked up
    unless he manually changes to a different item. This can be easily achieved by
    a queue. If we want to design it so that the current item switches to the most
    powerful item in the inventory, we can use a priority queue for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement the queue data structure using a linked list.
    It is very easy to implement a queue and it is a very robust data structure to
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used an STL queue to create the queue structure, or rather use the queue
    structure. The queue structure, as we know, is important when we need to use the
    FIFO data structure. As in a First Person Shooter, we may want the user to use
    the first gun he picks up and the remaining guns be put in the inventory. This
    is an ideal case for a queue, as explained in the example. The front of the queue
    structure holds the first gun picked up, or the current gun, and the remaining
    guns are stored in the inventory in the order in which they were picked up. Sometimes,
    we do want in our game that if we pick up a gun that is more powerful than the
    one we are using, it should automatically swap to that. In such a case, we can
    use a more specialized form of queue called a priority queue, where we need to
    use the same queue structure but just specify by what parameters the queue is
    to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Using trees to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tree is an example of a non-linear data structure, unlike arrays and linked
    lists which are linear. A tree is often used in games that require hierarchy.
    Imagine a car with many parts and all the parts are functional, upgradable, and
    can be interacted with. In this case, we will create the entire class for the
    car using a tree data structure. A tree uses a parent-child relationship to traverse
    between all the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will be implementing a binary tree. There are many variations
    of the binary tree. We will be creating the most basic binary tree. It is very
    easy to add new logic to a binary tree to implement a balanced binary, or AVL
    tree, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `CTree.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use a struct to store the value and a pointer to the left child and the right
    child. There is no particular rule as to which elements should be your left child
    and which elements should be the right child. We can decide, if we want, that
    all elements lower than the root element should be on the left and all elements
    greater that the root are on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04929_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Both insertion and deletion in the tree data structure are done in a recursive
    way. To insert elements, we traverse the tree and check if it is empty. If it
    is empty, we create a new node and add all the corresponding nodes recursively,
    by checking whether the new node's value is greater than or less than the root
    node. Searching for an element is done in a similar way. If the element to be
    searched has a value lower than the root node, we can ignore the entire right-hand
    section of the tree, as we can see in our `search` function, and keep searching
    recursively. This reduces the search space considerably and optimizes our algorithm.
    This means searching for an item at runtime will be faster. Let us say we are
    creating a game where we need to implement procedural terrain. After the scene
    is loaded, we can use a binary tree to divide the entire level into sections based
    on whether they appear on the left or the right. If this information is correctly
    stored in the tree, then the game camera can use this information to decide which
    section is rendered and which is not. This also creates a great level of culling
    optimization. If the parent does not get rendered, we can neglect checking the
    remainder of the tree for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Using graphs to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how easy it is to store data using the graph data
    structure. The graph data structure is extremely useful if we have to create a
    system like Facebook to sell and share our game with friends, and friends of friends.
    A graph can be implemented in a few ways. The most commonly used method is by
    using edges and nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows. You also
    need to have a working copy of Visual Studio installed on your Windows machine.
    No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how we can implement graphs. Graphs are a very
    good data structure for interconnecting various states and data together with
    edge conditions. Any social networking algorithm uses the graph data structure
    in one way or another:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Win32 Console Application**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `CGraph.h`/`CGraph.cpp` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to `CGraph.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines of code to `CGraph.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A graph comprises of edges and nodes. So, the first thing to do while implementing
    a graph data structure is to create a struct to store the node and vertex information.
    The following diagram has six nodes and seven edges. To implement a graph, we
    need to understand the cost of each edge to go from one node to another. These
    are called adjacency costs. To insert a node, we create a node. To add an edge
    to the node, we need to supply the information about the two nodes that need to
    be connected and the cost of the edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we get that information, we create a pair using the cost of the edge
    and one of the nodes and push that edge information to the other node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04929_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using STL lists to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STL is a standard template library that contains a lot of implementations of
    the basic data structures, which means we can directly use them for our purpose.
    The list is internally implemented as a doubly linked list, which means insertion
    and deletion can happen at both ends.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how we can easily use the inbuilt template library
    provided for us by C++ to create complex data structures. After the complex data
    structure has been created, we can easily use it to store data and access it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the list to push back the values of possible path costs for a certain
    AI player to reach a destination. We have used an STL list, which comes with a
    few functions built in that we can apply on the container. We use the `sort` function
    to sort the list in ascending order. We also have the `unique` function to delete
    all duplicate values from the list. After sorting the list, we have the least
    path cost, and accordingly we can apply that path to the AI player. Although the
    code size is reduced immensely and it is much easier to write, we should use STL
    with caution as we are never sure about the algorithm behind the inbuilt functions.
    For example, the `sort` function most likely uses QuickSort but we don't know.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL maps to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A map is one of the associative containers of STL and stores elements formed
    by a combination of a key value and a mapped value, following a specific order.
    Maps are a part of the STL provided for us by C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how we can easily use the inbuilt template library
    provided by C++ to create complex data structures. After the complex data structure
    is created, we can easily use it to store data and access it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have used the STL map to create a key/value pair to store the names of the
    players playing our game, along with their high scores. We can use any data type
    in a map. In our example, we have used a string and an int. After creating the
    data structure, it is very easy to find whether a player exists in the database,
    and we can also sort the map and display the score associated with the player.
    The second field gives us the values, whereas the first field gives us the key.
  prefs: []
  type: TYPE_NORMAL
- en: Using STL hash tables to store data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The biggest difference between a map and a hash table is that while the map
    data structure is ordered, a hash table is unordered. Both use the same principle
    of key/value pairs. The worst case search complexity for an unordered map is *O(N)*,
    as it is not ordered like a map, which has a complexity of *O(log N)*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine with a working copy of Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how we can easily use the inbuilt template library
    provided for us by C++ to create complex data structures. After the complex data
    structure has been created, we can easily use it to store data and access it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new C++ project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a source file called `Source.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following lines of code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program calculates the ping time of all players who are currently playing
    our game on the server. We create a hash table and store all their names and ping
    times using the `emplace` keyword. We can also insert a new player later with
    their ping time by using the `make_pair` keyword. After the hash table has been
    created, we can easily display the ping time of a particular player, or the ping
    time of all players in the server. We use an iterator to iterate through the hash
    table. The first parameter gives us the key and the second parameter gives us
    the value.
  prefs: []
  type: TYPE_NORMAL
