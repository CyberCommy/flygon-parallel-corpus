- en: Guitar Tuner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native covers most of the components and APIs that are available in iOS
    and Android. Points such as UI components, navigation, or networking can be fully
    set up within our JavaScript code using React Native components, but not all the
    platform's capabilities have been mapped from the native world to the JavaScript
    world. Nonetheless, React Native offers a way to write real native code and have
    access to the full power of the platform. If React Native doesn't support a native
    feature that you need, you should be able to build it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to use React Native's ability to enable our JavaScript
    code to communicate with custom native code; specifically, we will write a native
    module to detect frequencies coming from the device's microphone. These capabilities
    shouldn't be part of the day-to-day tasks for a React Native developer but, eventually,
    we may need to use modules or SDKs, which are only available on Objective-C, Swift,
    or Java.
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we will focus on iOS, as we need to write native code which
    is outside the scope of this book. Porting this app to Android should be fairly
    simple as we can fully reuse the UI, but we will keep that out of this chapter
    to reduce the amount of native code written. Since we are focusing only on iOS,
    we will cover all the aspects of building the app, adding a splash screen and
    an icon, so it is ready to be submitted to the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: We will need a Mac and XCode to add and compile native code for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of how a guitar is tuned should be simple to understand: each of
    the six strings of a guitar emits a sound at a specific frequency when played
    open (that is when no fret is pushed). Tuning a guitar means tightening the string
    until a specific frequency is emitted. This is the list of frequencies each string
    should emit to be standard tuned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1b31ca6f-97f7-4c10-966f-b8b470bdc6a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The digital process of tuning a guitar will follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Record a live sample of the frequencies captured through the device's microphone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the most prominent frequency in that sample.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate what is the closest frequency in the preceding table to detect what
    string is being played.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the difference between the frequency emitted and the standard tuned
    frequency for that string, so we can let the user correct the string tension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are also some pitfalls we need to overcome, like ignoring low volumes
    so that we don't confuse the user by detecting frequencies from sounds which are
    not coming from the strings.
  prefs: []
  type: TYPE_NORMAL
- en: For much of this process, we will use native code not only because we need to
    deal with features not available in React Native's API (for example, recording
    through the microphone), but also because we can perform complex calculations
    in a more effectual way. The algorithm we will be using here to detect the predominant
    frequency from the samples we take from the microphone is called the **Fast Fourier
    Transform** (**FFT**). We won't go into much detail here, but we will use a native
    library to perform these calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The user interface for this app should be really simple as we only have one
    screen to show the user. The complexity will reside in the logic, rather than
    in displaying a beautiful interface, although we will use some images and animations
    to make it more appealing. It's important to keep in mind that the interface is
    what makes an app appealing in the App Store, so we won't neglect this aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our app will look like once it is finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16b23a5e-a1dc-4f05-bc79-fc4c5a4ac11c.png)'
  prefs: []
  type: TYPE_IMG
- en: At the top of the screen, our app displays an "analog" tuner displaying the
    frequency the guitar string is emitting. A red indicator will move inside the
    tuner to show if the guitar string is close to the tuned frequency. If the indicator
    is on the left side, it means the guitar string is at a lower frequency and needs
    to be tightened. Therefore, a user should try to make the indicator go to the
    middle of the tuner to ensure the string is tuned. This is a very intuitive way
    of showing how well a string is tuned.
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to let the user know what string she is trying to tune. We
    can guess this by detecting what the closest tuned frequency is. Once we know
    what string was pushed, we will display it to the user in the bottom part of the
    screen where there is a representation of each of the strings plus the notes which
    should be played once the guitar is tuned. We will change the border color of
    the corresponding note to green to notify the user that the app detected a specific
    note.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the list of topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Running native code from JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<StatusBar />`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`propTypes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a splash screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an icon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `guitarTuner` and will be exclusively available for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is a single-screen app, we won''t need a state management library such
    as Redux or MobX, so, we will use a simple folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7e89eb67-4d3d-4a0d-85e3-83a06350ba56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have three images to support our custom interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`indicator.jpg`: The red bar indicating how tuned a string is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tuner.jpg`: The background in which the indicator will move'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string.jpg`: A representation of a guitar string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `src/` folder contains two subfolders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`components/`: This stores the `<Strings/>` component and the `<Tuner/>` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utils/`: This holds a list of functions and constants which will be used in
    several parts of our app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the entry point of our app will be `index.ios.js`, as we will be building
    our app exclusively for the iOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at our `package.json` to identify what dependencies we will
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, there are no dependencies other than `react` and `react-native`,
    which are created by React Native's CLI when running the `init` script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain permission to record from the microphone, we also need to modify
    our `ios/guitarTuner/Info.plist` to add a *Microphone Usage Description*, which
    is a message to be displayed to the user to request access to the microphone on
    her device. We need to add these lines right before the last `</dict></plist>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this last step, we should have the JavaScript part of our app ready to
    start coding. However, we still need to set up the native modules we will be using
    for recording and frequency detecting.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the native module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need XCode to write the native module, which will use the microphone to record
    samples and to analyze those samples to calculate the main frequency. As we are
    not interested in how these calculations are made, we will use an open source
    library to delegate most of the recording and FFT calculations. The library is
    named `SCListener` and a fork of it can be found at [https://github.com/emilioicai/sc_listener](https://github.com/emilioicai/sc_listener).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to download the library and add its files to the project following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the folder where our iOS project is: `<project_folder>/ios/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on `guitarTuner.xcodeproj`, which should open XCode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the `guitarTuner` folder and click on Add Files to "guitarTuner"...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/26810fae-4e6f-4c4c-976f-c5d605f2d75b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select all the files from the downloaded `SCListener` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/07f1b66c-4963-41ee-ac32-695895d0e59a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Accept. You should end up with a file structure in XCode similar to
    this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/78683d6d-fdf2-4100-b7b0-1252a051f8b9.png)'
  prefs: []
  type: TYPE_IMG
- en: '`SCListener` needs the AudioToolbox framework to be installed. Let''s do this
    by clicking on the root of the project in XCode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Build Phases tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/7dd608bd-8cfb-46cb-8a99-0aae7f1b9bd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to Link Binary with Libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the + icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select AudioToolbox.framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/eef7db93-952a-45c8-88c6-7db97c63eb08.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's add our module which will use `SCListener` and will send the data
    to React Native. Right-click on the `guitarTuner` folder and click on New File.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a header file named `FrequencyDetector.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/3fcd3014-4554-4c19-a97d-77e261f99732.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's repeat the process to add an implementation file for our module: right-click
    on the `guitarTuner` folder and click on New File.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an Objective-C file named `FrequencyDetector.m`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/73cc358f-ed17-446b-971a-bcf177a31955.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our module `FrequencyDetector` is now ready to be implemented. Let''s take
    a look at what `FrequencyDetector.h` should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It just imports two modules: `Accelerate` which is used to make the Fourier
    Transform calculations and `RCTBridgeModule`, which enables our native module
    to interact with our app''s JavaScript code. Now, let''s move to the implementation
    of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Even for non-Objective-C developers, this code should be easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import `SCListener`, the module which exposes methods to record from
    the device's microphone, and calculate the FFT from the recorded sample
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we expose two methods: `getFrequency` and `initialise`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation of `getFrequency` is also quite simple. We only need to read
    the volume we detect on the microphone by calling `averagePower` on our SCListener
    shared instance. If the volume is strong enough, we decide a guitar string has
    been pushed so we update a variable named `freq`, which will be passed into a
    callback supplied from our JavaScript code. Note that sending data back to JavaScript
    can only be done through callbacks (or promises) due to the nature of the bridge
    between the native and the JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we expose methods from the native world into the JavaScript world is
    by using `RCT_EXPORT_METHOD`, a macro provided by `RCTBridgeModule`. We also need
    to let React Native know this module can be used from our JavaScript code. We
    do it by calling another macro: `RCT_EXPORT_MODULE`. That''s all we need; from
    this moment on, we can access this module''s methods with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we pass a callback to `getFrequency` in which the current recorded
    frequency will be received. We can now use this value to calculate what string
    was pressed and how tuned it is. Let's take a look at how we are going to use
    this module in our app's JavaScript components.
  prefs: []
  type: TYPE_NORMAL
- en: index.ios.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already saw how we can access the method we exposed from the native module
    `FrequencyDetector`. Let''s now see how we can use it within our components tree
    to update the state of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Most of the logic will be placed in the `componentWillMount` method of our entry
    file. We need to initialize the `FrequencyDetector` module to start listening
    from the device's microphone and right after that, we call `setInterval` to repeatedly
    (every 0.5 seconds) invoke the `getFrequency` method of `FrequencyDetector` to
    get the updated prominent frequency. Every time we get a new frequency, we will
    check the guitar string which was most likely pressed by calling a support function
    named `getClosestString` and save the returned data in our component state. We
    will store this function in our `utils` file.
  prefs: []
  type: TYPE_NORMAL
- en: utils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before continuing with `index.ios.js`, let''s take a look at our `utils` file
    located in `src/utils/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`getClosestString` is a function which, based on a provided frequency, will
    return a JavaScript object containing two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number`: This is the number from the guitar string which was most likely pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delta`: This is the difference between the frequency provided and the tuned
    frequency for the guitar string which was most likely pressed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also export a list of colors and their hex representation which will
    be used by some user interface components to keep consistency throughout the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'After invoking `getClosestString`, we have enough information to build the
    state in our app. Of course, we need to provide this data to the tuner (to show
    how well-tuned the guitar string is) and to the string''s representation (to show
    what guitar string was pressed). Let''s take a look at the entire root component
    to see how this data is spread among components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will use two components to render the current pressed string (`<Strings/>`)
    and how tuned the pressed string is (`<Tuner/>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, we are using a React Native component named `<StatusBar/>`.
    `<StatusBar/>` allows the developer to choose the colors the app will show in
    the top bar where the carrier, time, battery level, and so on, are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0566a8ca-a023-47d3-a9f9-2d2b6aed1ffb.png)'
  prefs: []
  type: TYPE_IMG
- en: As we want our app to have a black background, we decided to use a `light-content` bar
    style. This component allows us to hide the bar completely, change its background
    color (Android only), or hide network activity, among other options.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move now to the components displaying all the visual components. We will
    start with `<Tuner/>`.
  prefs: []
  type: TYPE_NORMAL
- en: Tuner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `<Tuner/>` component comprises two elements: a background image dividing
    the screen into segments and an indicator which will move according to how well
    tuned the guitar string played is. To make it user-friendly, we will use animations
    to move the indicator, similar to the way analog tuners behave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will use a component's `state` variable for the animation named `xIndicator`,
    which will store the value (in an animated way) of the position where the indicator
    should be. Remember, the closer to the center, the better tuned the string will
    be. We will update this value every time we receive a new `delta` prop from its
    parent using the `componentWillReceiveProps` method and the `Animated.timing`
    function to ensure the image is animated. To make it more realistic, we also added
    an easing function which will make the indicator bounce, a bit like a real analog
    indicator.
  prefs: []
  type: TYPE_NORMAL
- en: We also added a `propTypes` static attribute to our class for type checking.
    We will make sure this way our component receives a delta in the proper format.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, remember how we exported a list of colors and their hex value in the
    `utils` file? We are using it here to show what color the background of this component
    will be.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last component is a representation of the six strings of a guitar. When
    our `FrequencyDetector` native module detects which frequency is played, we will
    display which string has the ability to emit the closest frequency by changing
    the note''s container border to green here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e630770d-b6c7-4104-a222-bf0cc2a38363.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Therefore, we need to accept one prop from its parent: the number of the active
    guitar string. Let''s take a look at the code for this simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We are rendering six images, one per guitar string, and justifying them using `space-around`
    to distribute them across the entire device screen, leaving two small spaces on
    both sides. We use a constant array containing the notes for each of the strings
    in a guitar to map them into the string representation. We will also use the prop `activeString`
    received from its parent to decide if we should show a yellow or a green border
    for each note.
  prefs: []
  type: TYPE_NORMAL
- en: We are again using `propTypes` to check the type of the provided prop (a number
    in this case).
  prefs: []
  type: TYPE_NORMAL
- en: This is all the code we need to build our guitar tuner. Let's add an icon and
    a splash screen now to make the app ready for submission to the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an icon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have our icon designed and saved as a large image, we need to resize
    it to all the formats Apple requires. In general, these are the sizes required:'
  prefs: []
  type: TYPE_NORMAL
- en: 20 x 20 px (iPhone Notification 2x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 60 x 60 px (iPhone Notification 3x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 58 x 58 px (iPhone Spotlight - iOS 5,6 2x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 67 x 67 px (iPhone Spotlight - iOS 5,6 3x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 80 x 80 px (iPhone Spotlight - iOS 7-10 2x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 120 x 120 px (iPhone Spotlight - iOS 7-10 3x && iPhone App ios 7-10 2x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 180 x 180 px (iPhone App ios 7-10 3x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this is a very tedious process, we can use one of the online tools which
    automate all the resizing tasks by providing an image large enough. One of the
    most popular tools can be found at [https://resizeappicon.com/](https://resizeappicon.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our icon in the proper sizes, we need to add them to our XCode
    project. We will do this by clicking on `Images.xcassets` in XCode and adding
    each image with its corresponding size to each asset in this window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fa33b930-7d57-4042-bc25-51dd05c758d4.png)'
  prefs: []
  type: TYPE_IMG
- en: The next time we compile our app, we will see our new icon in the simulator
    (use *command* + *Shift* + *H* to show the home screen).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a launch screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The launch screen is an image iOS displays while your app is loading. There
    are several techniques to make this introduction pleasant for the user, like showing
    a preview of the user interface the user will see once the app is loaded. However,
    we will take a simpler approach: we will display the app logo with its title.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest and more flexible way to do this is to use the interface builder
    in XCode by clicking on `LaunchScreen.xib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8f92cf49-3334-4d35-9aaa-5c82395e214e.png)'
  prefs: []
  type: TYPE_IMG
- en: An interface builder is a WYSIWYG tool, which helps developers building responsive
    screens by dragging and dropping components into a container. We kept it simple
    and just added a label with the name of the app and the same logo we used on the
    app icon.
  prefs: []
  type: TYPE_NORMAL
- en: Another option could be to upload images as launch screens and remove the `LaunchScreen.xib` file,
    but then we would run the risk of stretching the images depending on which device
    the app is run, so the recommended approach is always to use the interface builder
    for launch screens.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the landscape mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When testing our app, we need to test both landscape and portrait modes as
    both will be enabled by default. In the case of this app, we don''t really need
    to have a landscape mode as it doesn''t add any extra value to the portrait mode.
    Having decided this point, we need to disable the landscape mode to ensure we
    don''t have any odd behavior in our user interface if the user orients the device
    as though for landscape mode. We will do this in XCode through the General tab
    when selecting the root of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/55e8eaaa-b928-41b9-9a97-e2eefc21cf09.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to uncheck both Landscape Left and Landscape Right options to allow
    only portrait mode in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main challenge of this app was accessing a native module written in Objective-C
    from our JavaScript code. Fortunately, React Native has the means to ease the
    communication between those two worlds with relatively few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: We focused only on iOS for this app, but the reality is that building the same
    app in Android should follow a very similar process taking into account that we
    should build our native module in Java instead of Objective-C. Besides, we learned
    the process of including an icon and a launch screen in our app to complete the
    development cycle prior to release.
  prefs: []
  type: TYPE_NORMAL
- en: As we only had one screen in our app, we opted not to use any routing or state
    management libraries, which enabled us to keep the focus on the communication
    between our JavaScript code and the native module we implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We also created some animations to emulate an analog tuner which gives an attractive
    and fun look to this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the icon and the launch screen, we also took care of another visual
    element, which is important in many apps: the status bar. We saw how easy it is
    to change its content colors depending on what our app looks like. In this case,
    we opted for a dark background, so we needed light content in the status bar,
    although some apps (like games) may look better with no status bar at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will move to a different kind of app in the next chapter: a messaging app.'
  prefs: []
  type: TYPE_NORMAL
