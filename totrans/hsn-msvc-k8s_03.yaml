- en: Delinkcious - the Sample Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Delinkcious is a Delicious ([https://en.wikipedia.org/wiki/Delicious_(website)](https://en.wikipedia.org/wiki/Delicious_(website))) wannabe.
    Delicious used to be an internet hit that managed links for users. It was acquired
    by Yahoo, was bounced around, and sold multiple times. It was eventually purchased
    by Pinboard, which runs a similar service and intends to shut down Delicious soon.
  prefs: []
  type: TYPE_NORMAL
- en: Delinkcious allows users store URLs in cool places on the web, tag them, and
    query them in various ways. Throughout this book, Delinkcious will serve as a
    live lab to demonstrate many microservices and Kubernetes concepts, as well as
    features in the context of a real-world application. The focus will be on the
    backend, so there will be no snazzy frontend web application or mobile app. I'll
    leave those as the dreaded exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will understand why I chose Go as the programming language
    of Delinkcious, and then look at **Go kit** – an excellent Go microservice toolkit
    that I'll use to build Delinkcious. Then, we will dissect the different aspects
    of Delinkcious itself using the social graph service as a running example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Delinkcious microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Delinkcious data storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Delinkcious API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Delinkcious client libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have followed along with this book so far, you will have already installed
    Go. I recommend installing a good Go IDE to follow the code in this chapter since
    there will be a lot to go through. Let's go through a couple of good options.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Visual Studio Code**, also known as **VS Code** ([https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)),
    is an open source IDE from Microsoft. It isn''t Go-specific but has deep integration
    with Go via a dedicated and sophisticated Go extension. It is considered the best
    free Go IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: GoLand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JetBrains' GoLand ([https://www.jetbrains.com/go/](https://www.jetbrains.com/go/))
    is my personal favorite. It follows the great tradition of IntelliJ IDEA, PyCharm,
    and other great IDEs. This is a paid version with a 30-day free trial. There is
    no Community Edition, unfortunately. If you can afford it, I highly recommend
    it. If you can't or don't want to pay for an IDE (totally reasonable), check out
    the other options.
  prefs: []
  type: TYPE_NORMAL
- en: LiteIDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LiteIDE or LiteIDE X ([https://github.com/visualfc/liteide](https://github.com/visualfc/liteide))
    is a very interesting open source project. It is one of the earliest Go IDEs and
    it predates both GoLand and the Go extension for VS Code. I used it in the early
    days and was surprised by its quality. I eventually dropped it due to difficulties
    with interactive debugging via the **GNU Project Debugger** (**GDB**). It is actively
    developed, has a lot of contributors, and supports all the latest and greatest
    Go features, including Go 1.1 and the Go modules. You can now debug using Delve,
    which is the best of class Go debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Other options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're a die-hard command-line person and don't like IDEs at all, you have
    options available. Most programming and text editors have some form of Go support.
    The Go wiki ([https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins](https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins))
    has a big list of IDEs and text editor plugins, so go and check that out.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, there are no code files since you''ll just be getting to know
    the Delinkcious application:'
  prefs: []
  type: TYPE_NORMAL
- en: It is hosted in its own GitHub repository, which can be found at: [https://github.com/the-gigi/delinkcious](https://github.com/the-gigi/delinkcious).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the **v0.1** Tags | Releases: [https://github.com/the-gigi/delinkcious/releases/tag/v0.1](https://github.com/the-gigi/delinkcious/releases/tag/v0.1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone it and use your favorite IDE or text editor to follow up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that the general code examples for this book are in another GitHub
    repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing Go for Delinkcious
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I wrote and shipped production backend code in many fine languages such as
    C/C++, Python, C#, and, of course, Go. I also used a few not-so-fine languages,
    but let''s leave those out of the discussion. I decided to use Go as the programming
    language for Delinkcious because it is a superb language for microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Go compiles to a single binary with no external dependencies (awesome for simple
    Dockerfiles).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go is very readable and easy to learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go has excellent support for network programming and concurrency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go is the implementation language of many cloud-native data stores, queues,
    and frameworks (including Docker and Kubernetes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may argue that microservices are supposed to be language agnostic and that
    I shouldn't focus on one language. This is true, but my goal is to be very hands-on
    in this book and dive deep into all the fine details of building microservices
    on Kubernetes. To do that, I had to make specific choices and stick to them. Trying
    to get the same level of depth in multiple languages would have been futile. That
    being said, the microservice boundaries are very clear (one of the advantages
    of microservices) and you can see how implementing a microservice in another language
    will present a few issues to the rest of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Go kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can write your microservices from scratch (in Go or any other language)
    and they will interact with each other just fine through their APIs. However,
    in a real-world system, there will be a large number of shared and/or cross-cutting
    concerns that you want to be consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Central logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, microservices in most large production systems will need to comply
    with certain policies for those concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Enter Go kit ([https://gokit.io/](https://gokit.io/)). Go kit takes a very modular
    approach to the microservices space. It provides a high degree of separation of
    concerns, a recommended approach for structuring your microservice, and a lot
    of flexibility. As the website says, *Few opinions, lightly held*.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring microservices with Go kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go kit is all about best practices. Your business logic is implemented as pure
    Go libraries that only deal with interfaces and Go structs. All the complex aspects
    involved in APIs, serialization, routing, and networking will be relegated to
    clearly separate layers that are taking advantage of Go kit concepts and infrastructures
    such as transports, endpoints, and services. This makes for a great development
    experience, where you can evolve and test your application code in the simplest
    environment possible. Here is the interface for one of Delinkcious'' services
    – the social graph. Note that it is in plain Go. There is no notion of API, microservice,
    or even Go kit imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this interface resides in a Go package that is still
    completely agnostic of Go kit or even the fact it is being used in a microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A good way to think of a Go kit service is as an onion with different layers.
    At the core is your business logic and layered on top are various concerns such
    as routing, rate limiting, logging, and metrics, which are eventually exposed
    to other services or the world over transports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/59dd4e46-c710-425f-a3b3-a15375980cc8.png)'
  prefs: []
  type: TYPE_IMG
- en: Go kit primarily supports RPC-style communication by using a request-response
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding transports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest concerns about microservices is that they interact with each
    other and clients over a network; that is, at least an order of magnitude more
    complicated than calling methods inside the same process. Go kit provides explicit
    support for the networking aspect of microservices through the transport concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Go kit transport encapsulates all the complexity and integrates with other
    Go kit constructs such as requests, responses, and endpoints. Go kit officially
    supports the following transports out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thrift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: net/rpc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there are several more transports in its GitHub repository, including
    AMQP and NATS transports for message queuing and pub/sub. One cool thing about
    Go kit transports is that you can expose the same service through multiple transports
    without changing your code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Go kit microservice is really just a set of endpoints. Each endpoint corresponds
    to one method in your service interface. An endpoint is always associated with
    at least one transport and a handler that you implement to service the request.
    The Go kit endpoints support the RPC style of communication and have request and
    response structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the factory function for the `Follow()` method endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I will explain what's going on here soon. For now, just note that it accepts
    an `svc` argument of the `om.SocialGraphManager` type, which is an interface,
    and it invokes its `Follow()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is where your code plugs into the system. When the endpoint is called,
    it invokes the corresponding method in your service implementation to do all the
    work. All the hard work of encoding and decoding requests and responses is done
    by the endpoint wrapper. You can focus on your application logic using the best
    abstractions that make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of the `SocialGraphManager` function''s `Follow()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Understanding middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go kit is composable, as demonstrated in the preceding onion diagram. In addition
    to the mandatory transports, endpoints, and services, Go kit uses the decorator
    pattern to optionally wrap services and endpoints with cross-cutting concerns,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Resiliency (for example, retries with exponential backoff)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metrics collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach of a solid core with a small number of abstractions, such as transports,
    endpoints, and services, that can be extended using a uniform mechanism of middleware
    is easy to comprehend and work with. Go kit strikes the right balance between
    providing enough built-in functionality for middleware and leaving the floor open
    to your needs. For example, when running on Kubernetes, service discovery is taken
    care of for you. It's great that you don't have to work around Go kit in this
    case. Features and capabilities that you don't absolutely need are optional.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](d4214218-a4e9-4df8-813c-e00df71da935.xhtml),* Getting Started
    with Microservices*, we discussed the client library principle of microservices.
    A microservice that talks to another microservice ideally utilizes a client library
    that's exposed through an interface. Go kit provides excellent support and guidelines
    for writing such client libraries. The using microservice simply receives an interface.
    It is actually totally agnostic to the fact it is talking to another service.
    For (almost) all intents and purposes, the remote service could be running in
    the same process. This is excellent for testing or for refactoring services and
    breaking a slightly too large service into two separate services.
  prefs: []
  type: TYPE_NORMAL
- en: Go kit has client endpoints that are similar to service endpoints but work in
    the opposite direction. Service endpoints decode requests, delegate work to the
    service, and encode responses. Client endpoints encode requests, invoke the remote
    service over the network, and decode the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `Follow()` method of the client looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Generating the boilerplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The clean separation of concerns and neat architectural layering of Go kit has
    a price. The price is a lot of boring, mind-numbing, and error-prone boilerplate
    code for translating requests and responses between different structs and method
    signatures. It is useful to see and understand how Go kit can support strongly-typed
    interfaces in a generic way, but for large-scale projects, the preferred solution
    is to generate all the boilerplate from the Go interfaces and data types. There
    are several projects for this task, including one under development by Go kit
    itself called **kitgen** ([https://github.com/go-kit/kit/tree/master/cmd/kitgen](https://github.com/go-kit/kit/tree/master/cmd/kitgen)).
  prefs: []
  type: TYPE_NORMAL
- en: It is considered experimental at the moment. I'm a big fan of code generation
    and highly recommend it. However, in the following sections, we will look at a
    lot of manual boilerplate code to make it clear what's going on and avoid any
    magic.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Delinkcious directory structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Delinkcious system at this stage of initial development consists of three
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: Link service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social graph service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The high-level directory structure includes the following sub directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cmd`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pkg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`svc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `root` directory also includes some common files such as `README.md` and
    the important `go.mod` and `go.sum` files to support the Go modules. I use the
    monorepo approach here, so the entire Delinkcious system will live in this directory
    structure and is considered a single Go module, albeit with many packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The cmd subdirectory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cmd` subdirectory contains various tools and commands to support development
    and operations, as well as end-to-end tests that involve multiple actors, services,
    or external dependencies; for example, testing a microservice via its client library.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, it only contains a single end-to-end test for the social graph
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The pkg subdirectory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pkg` subdirectory is where all the packages live. It includes the implementation
    of the microservices, the client libraries, the abstract object model, other support
    packages, and unit tests. The bulk of the code is in the form of Go packages that
    are simple to develop and test before they are bundled into actual microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The svc subdirectory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `svc` subdirectory is where the Delinkcious microservices live. Each microservice
    is a separate binary with its own main package. `delinkcious_service` is a public
    umbrella service that follows the API gateway ([https://microservices.io/patterns/apigateway.html](https://microservices.io/patterns/apigateway.html))
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the Delinkcious microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine the Delinkcious services in detail and peel the onion. We'll actually
    work our way from the inside out, starting with the service layer and going through
    the endpoints all the way to the transports.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different services:'
  prefs: []
  type: TYPE_NORMAL
- en: Link service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social graph service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, they collaborate to provide the functionality of Delinkcious, which
    is to manage links for users and keep track of their social graph (followed/follower
    relationships).
  prefs: []
  type: TYPE_NORMAL
- en: The object model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The object model is the collection of all the interfaces and related data types
    that are implemented by the services. I chose to put all of them in a single package:
    `github.com/the-gigi/delinkcious/pkg/object_model`. It contains two files: `interfaces.go`
    and `types.go`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `interfaces.go` file contains the interfaces for the three Delinkcious
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `types.go` file contains the structs that are used in the signatures of
    the various interface methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `object_model` package is just using basic Go types, standard library types
    (`time.Time`), and user-defined types for the Delinkcious domain. It is all pure
    Go. At this level, there is no dependency or awareness of networking, APIs, microservices,
    or Go kit.
  prefs: []
  type: TYPE_NORMAL
- en: The service implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next layer is implementing the service interfaces as simple Go packages.
    At this point, each service has its own package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`github.com/the-gigi/delinkcious/pkg/link_manager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github.com/the-gigi/delinkcious/pkg/user_manager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`github.com/the-gigi/delinkcious/pkg/social_graph_manager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that these are Go package names and not URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the `social_graph_manager` package. It imports the `object_model`
    package as `om` because it needs to implement the `om.SocialGraphManager` interface.
    It defines a `struct` called `SocialGraphManager` that has a field called `store`
    of the `om.SocialGraphManager` type. So, the interface of the `store` field is
    identical to the interface of the manager in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This may be a little confusing. The idea is that the `store` field implements
    the same interface so that the top-level manager can implement some validation
    logic and delegate the heavy lifting to the store. You will see this in action
    soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, the fact that the `store` field is an interface allows us to use
    different stores that implement the same interface. This is very useful. The `NewSocialGraphManager()`
    function accepts a `store` field that must not be `nil`, and then returns a new
    instance of `SocialGraphManager` with the provided store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SocialGraphManager` struct itself is pretty simple. It performs some validity
    checks and then delegates the work to its `store`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The social graph manager is a pretty simple library. Let's continue peeling
    the onion and look at the service itself, which lives under the `svc` subdirectory: [https://github.com/the-gigi/delinkcious/tree/master/svc/social_graph_service](https://github.com/the-gigi/delinkcious/tree/master/svc/social_graph_service).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `social_graph_service.go` file. We''ll go over the main
    parts that are similar for most services. The file lives in the `service` package,
    which is a convention I use. It imports several important packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The Go kit `http` transport package is necessary for services that use the HTTP
    transport. The `gorilla/mux` package provides top-notch routing capabilities.
    `social_graph_manager` is the implementation of the service that does all the
    heavy lifting. The `log` package is for logging, and the `net/http` package is
    for serving HTTP since it's an HTTP service.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is just one function called `Run()`. It starts by creating a data store
    for the social graph manager and then creates the social graph manager itself,
    passing it the `store` field. So, the functionality of `social_graph_manager`
    is implemented in the package, but the `service` is responsible for making the
    policy decisions and passing a configured data store. If anything goes wrong at
    this point, the service just exits with a `log.Fatal()` call because there is
    no way to recover at this early stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is constructing the handler for each endpoint. This is done by
    calling the `NewServer()` function of the HTTP transport for each endpoint. The
    parameters are the `Endpoint` factory function, which we will review soon, a request
    decoder function, and the `response` encoder function. For HTTP services, it is
    common for requests and responses to be encoded as JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have `SocialGraphManager` properly initialized and the handlers
    for all the endpoints. It''s time to expose them to the world via the `gorilla`
    router. Each endpoint is associated with a route and a method. In this case, the
    `follow` and `unfollow` operations use the POST method and the `following` and
    `followers` operations use the GET method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part is just passing the configured router to the `ListenAndServe()`
    method of the standard HTTP package. This service is hardcoded to listen on port
    `9090`. Later on in this book, we will see how to configure things in a flexible
    and more industrial-strength way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the support functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may recall, the social graph implementation in the `pkg/social_graph_manager`
    package is completely transport agnostic. It implements the `SocialGraphManager`
    interface in terms of Go and couldn't care less whether the payload is JSON or
    protobuf and coming over the wire through HTTP, gRPC, Thrift, or any other method.
    The service is responsible for translation, encoding, and decoding. These support
    functions are implemented in the `transport.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each endpoint, there are three functions, which are the input to the HTTP
    transport''s `NewServer()` function of Go kit:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Endpoint` factory function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `request` decoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `response` encoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the `Endpoint` factory function, which is the most interesting.
    Let''s use the `GetFollowing()` operation as an example. The `makeGetFollowingEndpoint()`
    function takes a `SocialGraphManager` interface as input (as you saw earlier,
    in practice, it will be the implementation in `pkg/social_graph_manager`). It
    returns a generic `endpoint.Endpoint` function, which a function that takes a
    `Context` and a generic `request` and returns a generic `response` and `error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The job of the `makeGetFollowingEndpoint()` method is to return a function
    that complies with this signature. It returns such a function that, in its implementation,
    takes the generic request (the empty interface) and type before asserting it to
    a concrete request, that is, `getByUsernameRequest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a key concept. We cross the boundary from a generic object, which could
    be from anything to a strongly typed struct. This ensures that, even though the
    Go kit endpoints operate in terms of empty interfaces, the implementation of our
    microservice is type checked. If the request doesn''t contain the right fields,
    it panics. I could also check whether it''s possible to do the type assert and
    return an error instead of panicking, which might be more appropriate in some
    contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the request itself. It is simply a struct with a single
    string field called `Username`. It has the JSON struct tag, which is optional
    in this case because the JSON package can automatically work with field names
    that differ from the actual JSON just by case like (`Username` versus `username`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the request type is `getByUsernameRequest` and not `getFollowingRequest`,
    as you may expect in order to be consistent with the operation it is supporting.
    The reason for this is that I actually use the same request for multiple endpoints.
    The `GetFollowers()` operation also requires a `username`, and `getByUsernameRequest`
    serves both `GetFollowing()` and `GetFollowers()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have the username from the request and we can invoke the
    `GetFollowing()` method of the underlying implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a map of the users that the requested user is following and the
    standard error. However, this is an HTTP endpoint, so the next step is to package
    this information into the `getFollowingResponse` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following map can be translated into a JSON map of `string->bool`. However,
    there is no direct equivalent to the Go error interface. The solution is to encode
    the error as a string (via `err.Error()`), where an empty string represents no
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the entire function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the `decodeGetFollowingRequest()` function. It accepts
    the standard `http.Request` object. It needs to extract the username from the
    request and return a `getByUsernameRequest` struct that the endpoint can use later.
    At the HTTP request level, the username will be a part of the request path. The
    function will parse the path, extract the username, prepare the request, and return
    it or an error if anything goes wrong (for example, no username is provided):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The last support function is the `encodeResonse()` function. In theory, each
    endpoint can have its own custom `response` encoding function. However, in this
    case, I am using a single generic function that knows how to encode all the responses
    into JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This requires all the response structs to be JSON serializable, which was taken
    care of by translating the Go error interface into a string by the endpoint implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the API via a client library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The social graph manager is now accessible through an HTTP REST API. Here is
    a quick local demo. First, I will launch the Postgres DB (I have a Docker image
    called `postgres`), which is used as the data store, and then I will run the service
    itself in the `service` directory, that is, `delinkcious/svc/social_graph_service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a couple of follower/following relationships by invoking the `/follow`
    endpoint. I will use the excellent HTTPie ([https://httpie.org/](https://httpie.org/)),
    which is a better `curl` in my honest opinion. However, you can use `curl` if
    you prefer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'These two calls made the `gigi` user follow the `liat` and `guy` users. Let''s
    use the `/following` endpoint to verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The JSON response has an empty error, and the `following` map contains the `guy` and
    `liat` users, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: While a REST API is cool, we can do better. Instead of forcing the caller to
    understand the URL schema of our service and decode and encode JSON payloads,
    why not provide a client library that does all of that? This is especially true
    for internal microservices that all talk to each other using a small number of
    languages, and in many cases, just one language. The service and client can share
    the same interface and, maybe even some common types. In addition, Go kit provides
    support for client-side endpoints that are pretty similar to service-side endpoints.
    This translates directly into a very streamlined end-to-end developer experience,
    where you just stay in the programming language space. All the endpoints, transports,
    encoding, and decoding can remain hidden as an implementation detail for the most
    part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The social graph service provides a client library that lives in the `pkg/social_graph_client`
    package. The `client.go` file is similar to the `social_graph_service.go` file
    and is responsible for creating a set of endpoints in the `NewClient()` function
    and returning the `SocialGraphManager` interface. The `NewClient()` function takes
    the base URL as an argument and then constructs a set of client endpoints using
    Go kit''s `NewClient()` function of the HTTP transport. Each endpoint requires
    a URL, a method (`GET` or `POST`, in this case), a `request` encoder, and a `response`
    decoder. It''s like a mirror image of the service. Then, it assigns the client
    endpoints to the `EndpointSet` struct, which can expose them through the `SocialGraphManager`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EndpointSet` struct is defined in the `endpoints.go` file. It contains
    the endpoints themselves, which are functions, and it implements the `SocialGraphManager`
    method, where it delegates the work to the endpoint''s functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the `EndpointSet` struct''s `GetFollowing()` method. It accepts
    the username as a string, and then it calls the endpoint with a `getByUserNameRequest`
    that''s populated with the input username. If calling the endpoint function returned
    an error, it just bails out. Otherwise, it does type assertion to convert the
    generic response into a `getFollowingResponse` struct. If its error string wasn''t
    empty, it creates a Go error from it. Eventually, it returns the following users
    from the response as a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Storing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen how Go kit and our own code take an HTTP request with a JSON payload,
    translate it into a Go struct, invoke the service implementation, and encode the
    response as a JSON to return to the caller. Now, let''s take a deeper look at
    the persistent storage of the data. The social graph manager is responsible for
    maintaining the followed/follower relationships between users. There are many
    options for storing such data, including relational databases, key-value stores,
    and, of course, graph databases, which may be the most natural. I chose to use
    a relational database at this stage because it is familiar, reliable, and can
    support the following necessary operations well:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfollow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get followers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get following
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, if we later discover that we prefer a different data store or extend
    the relational DB with some caching mechanism, it will be very easy to do so because
    the data store of the social graph manager is hidden behind an interface. It is
    actually using the very same interface, that is, `SocialGraphManager`. As you
    may remember, the social graph manager package accepts a store argument of the `SocialGraphManager` type
    in its factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Since the social graph manager interacts with its data store through this interface,
    changing implementations can be done without any code changes to the social graph
    manager itself.
  prefs: []
  type: TYPE_NORMAL
- en: I will take advantage of this for unit testing, where I use an in-memory data
    store that is easy to set up, can be quickly populated with test data, and allows
    me to run tests locally.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the in-memory social graph data store, which can be found at [https://github.com/the-gigi/delinkcious/blob/master/pkg/social_graph_manager/in_memory_social_graph_store.go](https://github.com/the-gigi/delinkcious/blob/master/pkg/social_graph_manager/in_memory_social_graph_store.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'It has very few dependencies – just the `SocialGraphManager` interface and
    the standard errors package. It defines a `SocialUser` struct, which contains
    a username and the names of the users it is following, as well as the names of
    the users that they are followed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The data store itself is a struct called `InMemorySocialGraphStore` that contains
    a map between usernames and the corresponding `SocialUser` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all pretty pedestrian. The `InMemorySocialGraphStore` struct implements
    the `SocialGraphManager` interface methods. For example, here is the `Follow()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At this point, there is no need to focus on how it works too much. The main
    point I want to get across is that by using interfaces as abstractions, you can
    get a lot of flexibility and clean separation of concerns that helps a lot when
    you want to develop specific parts of the system or a service during testing.
    If you want to make significant changes, such as changing your underlying data
    stores or using multiple data stores interchangeably, then having an interface
    in place is a life saver.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you got a close look at the Go kit toolkit, the overall Delinkcious
    system and its microservices, and got to drill down into the social graph component
    of Delinkcious. The main theme of this chapter is that Go kit provides clean abstractions,
    such as services, endpoints and transports, and generic functionality for breaking
    microservices into layers. Then, you add your code for a consistent system of
    loosely-coupled yet cohesive microservices. You also followed the path of a request
    from the client, all the way to the service and back through all the layers. At
    this point, you should have a general grasp of how Go kit helps shape the Delinkcious
    architecture and how it would benefit any other system. You may be a little overwhelmed
    by all of this information, but remember that the complexity it neatly packaged
    and that you can ignore it most of the time, focus on your application, and just
    reap the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll address a very critical part of any modern microservices-based
    system – the CI/CD pipeline. We'll create a Kubernetes cluster, configure CircleCI,
    deploy the Argo CD continuous delivery solution, and see how to deploy Delinkcious
    on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s refer to the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Go kit, check out [https://gokit.io/](https://gokit.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To better understand the SOLID design principles that Delinkcious utilizes,
    check out [https://en.wikipedia.org/wiki/SOLID](https://en.wikipedia.org/wiki/SOLID).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
