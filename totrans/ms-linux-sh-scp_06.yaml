- en: Chapter 6. Iterating with Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, scripts are for lazy people. We are the folk of the world who have
    better things to do than repeat a task 100 times or more; loops are our friends.
  prefs: []
  type: TYPE_NORMAL
- en: Looping structures are the life-blood of scripts. These loops are the workhorse
    engine that can iterate many times, repeating the same task reliably and consistently.
    Imagine having 100,000 lines of text within a CSV file that has to be checked
    for incorrect entries. A script can do this easily and accurately once developed
    but in the case of a human, the reliability factor and accuracy will fail very
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s see how we can save our time and sanity by covering the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While and until
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read from file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All our looping controls can be simple and we will begin by looking at `for`
    loops. The word `for` is a keyword in bash and in working it is similar to `if`.
    We can use the command type to verify this, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As a reserved shell keyword, we can use a `for` loop both in scripts and directly
    at the command line. In this way, we can utilize loops within and without the
    scripts optimizing the use of the command line. A simple `for` loop is shown in
    the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Within a `for` loop, we read from the list on the right to populate the variable
    parameter on the left, in this case we will read from the list containing `bob`
    and `joe` into the parameter variable `u`. Each item from the list is inserted
    into the variable, one item at a time. In this way, as long as there are items
    to be processed in the list, the loop will execute until the list is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practically, for us the execution of this loop means that we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the user `bob`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the password for `bob`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expire the password so it will need to be reset on the first login for the user
    `bob`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then loop back and repeat the process for the user `joe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can view the previous example in the following screenshot; after having
    gained root access via `sudo -i`, we proceeded to run the loop and create the
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![For loops](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The list that is read in the `for` loop can be generated dynamically or statically,
    as shown in the last example. To create dynamic lists, we could use various globbing
    techniques to populate the list. As an example, to work with all files in a directory
    we could use `*`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a list is generated, such as with file globbing, we should quote the expansion
    of the variable parameter. Without the quotes, it is possible that a space will
    get included that will cause the command to fail. This is what we have seen here
    in the `stat` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, we isolate the filenames that begin with `ba*`.
    We then use the `stat` command to print the inode metadata. The code and output
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![For loops](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This list can also be generated from the output of another command or a pipeline
    of commands. For example, if we need to print the current working directory of
    all logged in users, we could try something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we can see that the choice of name for the parameter
    is down to you; we are not limited to a single character and we can use the `$user`name
    in this example. Using lowercase we will not overwrite the system variable `$USER`.
    The following screenshot demonstrates the loop and the subsequent output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![For loops](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `lsof` command will list open files, we can search for the files opened
    by each user in turn and with the `bash` command as the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with the scripts that we have created so far, we can create a new script
    called `hello9.sh`. If we copy the `$HOME/bin/hello2.sh` script to the new script,
    we can edit it to make use of a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop is used to iterate through each command-line argument supplied and
    greet each user individually. When we execute the script, we can see that we can
    now display the hello message for each user. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![For loops](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Although, what we have seen here is still relatively trivial, we should now
    realize a little of what we can do with scripts and loops. The arguments of this
    script can be the usernames that we have already used or anything else. If we
    stick with the usernames, then it will be very easy to create user accounts and
    set passwords, as we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having entered our loop, we may need to either exit the loop prematurely or
    perhaps exclude certain items from processing. If we want to process only directories
    in a listing, rather than every file of any type, then to implement this, we have
    loop control keywords, such as `break` and `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` keyword is used to exit the loop processing no more entries, whereas
    the `continue` keyword is used to stop the processing of the current entry in
    the loop and resume the processing with the next entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we only want to process directories, we could implement a test within
    the loop and determine the file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Within the loop we want to set permissions including the SGID and Sticky bits,
    but for the directories only. The `*` search will return all files, the first
    statement within the loop will ensure that we only process directories. If the
    test is done for the current loop, the target fails the test and is not a directory;
    the `continue` keyword retrieves the next loop-list item. If the test returns
    true and we are working with a directory then we will process the subsequent statements
    and execute the `chmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need to run the loop until we found a directory and then exit the loop
    we can adjust the code so that we can iterate though each file. If the file is
    a directory then we exit the loop with the `break` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the following screenshot, we can see the code that I just wrote in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the loop](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By working with the same theme, we can print each directory found in the listing
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve a result by processing the loop item only if it is a directory
    and within the loop. We can work with regular files only using the `if` test.
    In this example, we append the directory name to the `dir_name` variable. Once
    we exit the loop, we print he complete list of directories. We can see this in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the loop](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using these examples and your own ideas, you should now be able to see how you
    can control loops using the `continue` and `break` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: While loops and until loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the `for` loop we iterate through a list, it's either the one that
    we create or the one that is dynamically generated. Using the `while` or `until`
    loops, we loop based on the fact that the condition becomes either true or false.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `while` loop loops while the condition is true and conversely an `until`
    loop will loop while the condition is false. The following command will count
    from 10 through to zero. Each iteration of the loop printing the variable and
    then reducing the value by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the output of this command in the following screenshot; thus, confirming
    the countdown to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![While loops and until loops](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the `\c` escape sequence used here allows the suppression of the
    line-feed normally used with `echo`. In this way, we can keep the countdown on
    the single-line of output. I think you will agree that its a nice effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionality of this loop can be gained using the `until` loop; just a
    quick rethink of the logic is required, as we will want to loop until the condition
    becomes true. Generally, it is a personal choice and the way the logic works best
    for you about which loop to use. The following example shows the loop written
    with the `until` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Reading input from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it may seem that these loops can do a little more than just count down
    numbers. We may want to read data in from a text file and process each line. The
    shell built-in `read` command that we saw earlier in this book can be used to
    read a file line by line. In this way, we can use a loop to process each line
    of a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate some of these functionalities, we will use a file that contains
    the server addresses. These could be hostnames or IP addresses. In the following
    example, we will make use of the IP addresses of Google DNS Servers. The following
    command shows the contents of the `servers.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `read` command in the condition of the `while` loop, we can loop
    as long as we have more lines to read from the file. We specify the input file
    directly after the `done` keyword. For each line that we read from the file, we
    can test if the server is up with the command `ping` and if the server is responding,
    we append it to a list of available servers. This list is printed once the loop
    closes. In the following example, we can see that we begin to add in as many elements
    of scripting as we have covered in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the operation in the following screenshot, which captures the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading input from files](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using this kind of loop, we can start to build extremely practical scripts
    to process information either fed from the command line or from scripts. It will
    be very easy to replace the filename that we read with `$1` representing a positional
    parameter passed into the script. Let''s return to the `ping_server.sh` script
    and adjust it to accept the input parameter. We can copy the script to the new
    `$HOME/bin/ping_server_from_file.sh` file. Within the script we first test if
    the input parameter is a file. We then create an output file with a tile that
    includes the date. As we enter the loop, we append available servers to this file
    and list the file at the end of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute the script now in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the script execution should be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reading input from files](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating operator menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can provide a menu to the Linux operators who need limited functionality
    from the shell and do not want to learn the details of command line use. We can
    use their login script to launch a menu for them. This menu will provide a list
    of command selections to choose from. The menu will loop until the user chooses
    to exit from the menu. We can create a new `$HOME/bin/menu.sh` script, the basis
    of the menu loop will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The loop we have created here is infinite. The `true` command will always return
    true and loop continuously; however, we can provide a loop control mechanism to
    allow the user to leave the menu. To start building the structure of the menu,
    we will need to echo some text within the loop asking the user for their choice
    of command. We will clear the screen before the menu is loaded each time and an
    additional read prompt will appear after the execution of the desired command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows the user to read the output from the command before the screen
    is cleared and the menu is reloaded. The script will look like the following code
    at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the script at this stage, there will be no mechanism to leave
    the script. We have not added any code to the menu selections; however, you can
    test functionality and exit using the *Ctrl* + *c* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage the menu should look similar to the output shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating operator menus](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To build the code behind the menu selection, we will implement a `case` statement.
    This will be added in between the two `read` commands, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the three options that we have added to the `case` statement, `a`,
    `b`, and `c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Option a**: This runs the `tar` command to back-up the scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option b**: This runs the `cal` command to display the current month'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Option c**: This exits the script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To ensure that the user is logged out when exiting from their login script,
    we will run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exec` command is used to ensure that the shell is left after the `menu.sh`
    file is complete. In this way, the user never needs to experience the Linux shell.
    The complete script is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating operator menus](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have begun to make progress within this chapter. We have been able to join
    many of the elements that we have previously used into cohesive and functional
    scripts. Although the focus of this chapter has been on loops, we have used command-line
    lists, `if` statements, `case` statements, and arithmetic calculations.
  prefs: []
  type: TYPE_NORMAL
- en: We opened this chapter describing loops as the workhorse of our scripts and
    we have been able to demonstrate this with `for`, `while`, and `until` loops.
    The `for` loop is used to iterate through elements of a list. The list can be
    either static or dynamic, with an emphasis on dynamic lists we showed how simply
    these are created via file globbing or command expansion.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` and `until` loops are controlled using conditions. The `while` loop
    will loop whilst the supplied condition is true. The `until` loop will loop until
    the supplied condition returns true or whilst it returns false. The `continue`
    and `break` keywords are specific to loops and along with `exit`, we can control
    the loop flow.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at modulizing scripts using functions.
  prefs: []
  type: TYPE_NORMAL
