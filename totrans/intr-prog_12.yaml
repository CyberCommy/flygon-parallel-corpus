- en: JVM Processes and Garbage Collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter allows readers to look under the hood of JVM and learn about its
    processes. The structure and behavior of JVM is more complex than just an executor
    of a sequence of instructions according to the coded logic. JVM finds and loads
    into the memory the `.class` files requested by the application, verifies them,
    interprets the bytecodes (translates them into platform-specific binary code),
    and passes the resulting machine code to the central processor (or processors)
    for execution, using several service threads in addition to the application threads.
    One of the service threads, called garbage collection, performs the important
    mission of releasing the memory from unused objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are JVM processes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JVM architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Monitoring JVM while running an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are JVM processes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have established already in [Chapter 1](40b2d539-5f9c-4923-87ac-803c281a5ba7.xhtml),
    *Java Virtual Machine (JVM) on Your Computer*, JVM does not know anything about
    the Java language and source code. It only knows how to read Byte Code. It reads
    the bytecodes and other information from `.class` files, interprets it (transforms
    it into the sequence of binary code instructions specific to a particular microprocessor,
    where JVM is running), and passes the result to the computer that executes it.
  prefs: []
  type: TYPE_NORMAL
- en: While talking about it, programmers often refer to JVM as *JVM instance* or
    *process*. This is because every time a `java` command is executed, a new *instance*
    of JVM is launched, dedicated to running the particular application in a separate
    process with the allocated memory size (default or passed in as the command option).
    Inside this JVM process, multiple threads are running, each with their own allocated
    memory; some are service threads created by the JVM, while others are application
    threads created and controlled by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Threads are lightweight processes that require less resource allocation than
    the JVM execution process.
  prefs: []
  type: TYPE_NORMAL
- en: That is the big picture of JVM executing the compiled code. But if you look
    closer and read the JVM Specification, you will discover that the word process
    in relation to JVM is overloaded many times. The JVM Specification identifies
    several other processes running inside the JVM that are usually not mentioned
    by programmers, except maybe the class loading process.
  prefs: []
  type: TYPE_NORMAL
- en: That is so because, most of the time, one can successfully write and execute
    Java programs without knowing more than that about JVM. But once in a while, some
    general understanding of JVM's internal workings helps to identify the root cause
    of certain related issues. That is why, in this section, we will provide a short
    overview of all the processes that happen inside JVM. Then, in the following sections,
    we will discuss JVM's memory structure and some other aspects of JVM functionality
    that may be useful to a programmer in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two subsystems that run all the JVM internal processes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Classloader, which reads `.class` files and populates method areas in JVM memory
    with the class-related data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method bytecodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class metadata that describes the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execution engine, which executes the bytecodes using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap area for object instantiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java and native method stacks for keeping track of the methods called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A garbage collection process to reclaim the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The list of the processes that run inside the main JVM process includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processes performed by the classloader:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processes performed by the execution engine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class instantiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JVM architecture can be described as having two subsystems—the classloader
    and the execution engine—that run the service processes and application threads
    using runtime data memory areas: method area, heap, and application thread stacks.'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding list may give you the impression that these processes are executed
    sequentially. To some degree, this is true, if we talk about one class only. It
    is not possible to do anything with a class before loading. Аn execution of a
    method can begin only after all the previous processes are completed. However,
    the garbage collection, for example, doesn't happen immediately after the object
    stops being used (see the following section, *Garbage collection*). Also, an application
    can exit any time when an unhandled exception or some other error happens.
  prefs: []
  type: TYPE_NORMAL
- en: Only the classloader processes are regulated by the JVM specification. The execution
    engine's implementation is largely at the discretion of each vendor. It is based
    on the language semantics and the performance goals set by the implementation
    authors.
  prefs: []
  type: TYPE_NORMAL
- en: The processes of the execution engine are not regulated by the JVM Specification.
    There is common sense, tradition, known and proven solutions, and the Java language
    specification that can guide a JVM vendor's implementation decisions, but there
    is no single regulatory document. The good news is that the most popular JVMs
    use similar solutions or, at least, that's how it looks from a high level of an
    introductory course. For vendor-specific details, see *Comparison of Java virtual
    machines* on Wikipedia ([https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines](https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines))
    and other sources available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let's describe each of the seven processes listed previously
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to JVM Specification, the loading phase encompasses finding the `.class`
    file by its name and creating its representation in the memory.
  prefs: []
  type: TYPE_NORMAL
- en: The first class to be loaded is the one passed in the command line, with the
    method `main(String[])` in it. We previously described it in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project*. The classloader reads the `.class` file, parses it according
    to the internal data structure, and populates the method area with static fields
    and method bytecodes. It also creates an instance of `java.lang.Class` that describes
    the class. Then, the classloader links (see section *Linking*) and initializes
    (see section *Initialization*) the class and passes it to the execution engine
    for running its bytecodes.
  prefs: []
  type: TYPE_NORMAL
- en: In the first project in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml), *Your
    First Java Project*, the `main(String[])` method did not use any other methods
    or classes. But in a real-life application, the `main(String[])` method is an
    entrance door into the application. If it calls a method of another class, that
    class has to be found on the classpath and read, parsed, and initialized; only
    then can its method be executed too. And so on. That is how a Java application
    starts and gets going.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, *How to execute the main(String[]) method*, we will
    show several ways a Java application can be started, including using an executable
    `.jar` file with a manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Every class is allowed to have a `main(String[])` method and often does. Such
    a method is used to run the class independently as a standalone application for
    testing or demo purposes. The presence of such a method does not make the class
    main. The class becomes main only if it's identified as such in the `java` command
    line or in a `.jar` file manifest.
  prefs: []
  type: TYPE_NORMAL
- en: That said, let's continue with the discussion of the loading process.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the API of `java.lang.Class`, you will not see a public constructor
    there. The classloader creates its instance automatically and, by the way, is
    the same instance that is returned by the `getClass()` method that you can invoke
    on any object. It does not carry the class static data (that is maintained in
    the method area) or the state (they are in an object, created during the execution).
    It does not contain method bytecodes either (that is stored in the method area,
    too). Instead, the `Class` instance provides metadata that describes the class—its
    name, package, fields, constructors, method signatures, and so on. That is why
    it can be useful not only for JVM but also for application code, as we have seen
    in some examples already.
  prefs: []
  type: TYPE_NORMAL
- en: All the data created by the classloader in the memory and maintained by the
    execution engine is called a binary representation of the type.
  prefs: []
  type: TYPE_NORMAL
- en: If the `.class` file has errors or does not adhere to a certain format, the
    process is terminated. This means that some validation of the loaded class format
    and its bytecodes is performed by the loading process. But more verification follows
    at the beginning of the next process, called **linking**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the high-level description of the loading process.  It performs three
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Finds and reads the `.class` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parses it according to the internal data structure into the method area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates an instance of `java.lang.Class` that carries the class metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the JVM Specification, the linking is resolving the references
    of the loaded class, so the methods of the class can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although JVM can reasonably expect that the `.class` file was produced by 
    the Java compiler and all the instructions satisfy the constraints and requirements
    of the language, there is no guarantee that the loaded file was produced by the
    known compiler implementation or a compiler at all. That is why the first step
    of the linking process is *verification*, which makes sure that the binary representation
    of the class is structurally correct: that the arguments of each method invocation
    are compatible with the method descriptor, that the return instruction matches
    its method''s return type, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: After verification is successfully completed, the next step—*preparation—*follows. The
    interface or class (static) variables are created in the method area and initialized
    to the default values of their types. The other kinds of initializations – the
    explicit assignments specified by a programmer and static initialization blocks
    – are deferred to the process called **initialization** (see the next section, *Initialization*).
  prefs: []
  type: TYPE_NORMAL
- en: If the loaded bytecodes refer other methods, interfaces, or classes, the symbolic
    references are resolved into concrete references that point to the method area,
    which is done by the *resolution* process. If the referred interfaces and classes
    are not loaded yet, the classloader finds them and loads them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the high-level description of the linking process.  It performs three
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Verification of the binary representation of a class or an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparation of static fields in the method area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolution of symbolic references into concrete references that point to the
    method area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to JVM Specification, the initialization is accomplished by executing
    the class initialization methods.
  prefs: []
  type: TYPE_NORMAL
- en: That is when the programmer-defined initialization (in static blocks and static
    assignments) is performed, unless the class was already initialized at the request
    of another class.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this statement is an important one because the class may be
    requested several times by different (already loaded) methods, and also because
    JVM processes are executed by different threads (see the definition of threads
    in the section *Threads*) and may access the same class concurrently. So, coordination
    (also called synchronization) between different threads is required, which substantially
    complicates JVM implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Technically, an instantiation process, triggered by the operator `new`, is
    the first step of the execution, and this section might not exist. But if the
    `main(String[])` method (which is static) uses only static methods of other classes,
    the instantiation never happens.  That''s why it is reasonable to identify this
    process as separate from the execution. Besides, this activity has very specific
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocating memory for the object (its state) in the heap area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialization of the instance fields to the default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating thread stacks for Java and native methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution starts when the first method—not a constructor—is ready to be executed. For
    every application thread, a dedicated runtime stack is created, where every method
    call is captured in a stack frame. If an exception happens, we get data from the
    current stack frames when we call the method `printStackTrace()`.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first application thread (called the *main* thread) is created when the `main(String[])`
    method starts executing. It can create other application threads. The execution
    engine reads the bytecodes, interprets them, and sends the binary code to the
    microprocessor for execution. It also maintains a count of how many times and
    how often each method was called. If the count exceeds a certain threshold, the
    execution engine uses a compiler, called JIT compiler, which compiles the method
    bytecodes into a native code. The next time the method is called, it will be ready
    without an interpretation. It substantially improves code performance.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction currently being executed and the address of the next instruction
    are maintained in the **P****rogram Counter** (**PC**) registers. Each thread
    has its own dedicated PC registers. It also improves performance and keeps track
    of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **garbage collector** (**GC**) runs the process that identifies the objects
    that are not referenced anymore and so can be removed from the memory. There is
    a Java static method, `System.gc()`, that can be used programmatically to trigger
    the garbage collection, but the immediate execution is not guaranteed. Every GC
    cycle affects the application performance, so the JVM has to maintain a balance
    between the memory availability and the ability to execute the bytecodes quickly
    enough.
  prefs: []
  type: TYPE_NORMAL
- en: Application termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways an application can be terminated (and the JVM stopped)
    programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: Normal termination without an error status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abnormal termination because of an unhandled exception or a forced programmatic
    exit with or without an error status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no exceptions and infinite loops, the `main(String[])` method completes
    with a `return` statement or after its last statement is executed. As soon as
    it happens, the main application thread returns the control flow to the JVM and
    the JVM stops executing, too.
  prefs: []
  type: TYPE_NORMAL
- en: That is the happy ending, and many applications enjoy it in real-life. Most
    of our examples, except those when we have demonstrated exceptions or infinite
    loops, have ended successfully, too.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are other ways a Java application can exit, some of them quite
    graceful too. Others – not as much.
  prefs: []
  type: TYPE_NORMAL
- en: If the main application thread created child threads or, in other words, a programmer
    has written code that generates other threads, even the graceful exit may not
    be as easy. It all depends on the kind of the child threads created. If any of
    them is a `user` thread (the default), then the JVM instance continues to run
    even after the main thread exits.
  prefs: []
  type: TYPE_NORMAL
- en: Only after all `user` threads are completed does the JVM instance stop. It is
    possible for the main thread to request that the child `user` thread complete
    (we will talk about this in the following section, *Threads*). But until it exits,
    the JVM continues running, and this means that the application is still running
    too.
  prefs: []
  type: TYPE_NORMAL
- en: But if all child threads are `daemon` threads (see the following section, *Threads*)
    or there are no child threads running, the JVM instance stops running as soon
    as the main application thread exits.
  prefs: []
  type: TYPE_NORMAL
- en: Without forced termination, the JVM instance continues running until the main
    application thread and all child `user` threads are completed. In the absence
    of child `user` threads or in the case where all the child threads are `daemon`,
    the JVM stops running as soon as the main application thread exits.
  prefs: []
  type: TYPE_NORMAL
- en: How the application exits in the case of an exception depends on the code design.
    We touched on it in the previous chapter while discussing the best practices of
    exception handling. If the thread captures all the exceptions in a `try...catch`
    block in `main(String[])` or a similarly high-level method, then the control flow
    is returned back to the application code and it is up to the application (and
    the programmer who wrote the code) how to proceed – to try to recover, to log
    the error and continue, or to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, the exception remains unhandled and propagates into
    the JVM code, the thread (where the exception happened) stops executing and exits.
    Then, one of the following will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are no other threads, the JVM stops executing and returns an error
    code and the stack trace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the thread with an unhandled exception was not the main one, other threads
    (if present) continue running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the main thread has thrown an unhandled exception and the child threads (if
    present) are daemon, they exit too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is at least one user child thread, the JVM continues running until
    all user threads exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also ways to programmatically force the application to stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.exit(0);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runtime.getRuntime().exit(0);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runtime.getRuntime().halt(0);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of the preceding methods force the JVM to stop executing any thread and
    exit with a status code passed in as the parameter (0, in our examples):'
  prefs: []
  type: TYPE_NORMAL
- en: Zero indicates normal termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nonzero value indicates abnormal termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Java command was launched by some script or another system, the value
    of the status code can be used for the automation of the decision making about
    the next step. But that is already outside the application and Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two methods have identical functionality, because here is how `System.exit()`
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static void exit(int status) {
  prefs: []
  type: TYPE_NORMAL
- en: Runtime.getRuntime().exit(status);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: To see the source code in IDE, just click on the method.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Virtual Machine exits when some thread invokes the `exit()` method
    of the `Runtime` or `System` class, or the `halt()` method of the `Runtime` class,
    and the exit or halt operation is permitted by the security manager.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `exit()` and `halt()` is that `halt()` forces JVM to
    exit immediately, while `exit()` performs additional actions that can be set using
    the `Runtime.addShutdownHook()` method.
  prefs: []
  type: TYPE_NORMAL
- en: But all these options are rarely used in mainstream programming, so we are already
    stepping way beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: JVM architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JVM architecture can be described in terms of the runtime data structure in
    the memory and in terms of the two subsystems that use the runtime data – the
    classloader and execution engine.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime data areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the runtime data areas of JVM memory belong to one of two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shared areas, which include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method area**: Class metadata, static fields, methods bytecodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap area**: Objects (state)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not shared areas, dedicated to each application thread, which include the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java stack**: Current and caller frames, each frame keeping the state of
    Java (not native) method invocation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method parameters values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of operands for intermediate calculations (operand stack)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method return value (if any)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Program Counter (PC) register**: Next instruction to execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native method stack**: The state of native method invocations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already discussed that a programmer has to be careful while using reference
    types to not modify the object itself unless it needs to be done. In a multithreaded
    application, if a reference to an object can be passed between threads, one has
    to be extra careful because of the possibility of the concurrent modification
    of the same data.
  prefs: []
  type: TYPE_NORMAL
- en: On the bright side, such a shared area can be and often is used as the means
    of communication between threads. We will talk about this in the upcoming *Threads* section.
  prefs: []
  type: TYPE_NORMAL
- en: Classloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classloader performs the following three functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads the `.class` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populates the method area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes static fields not initialized by a programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The execution engine does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiates objects in the heap area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializes static and instance fields, using initializers written by programmers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds/removes frames to/from Java stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates the PC register with the next instruction to execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintains the native method stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeps counts of method calls and compiles popular ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizes objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminates the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have mentioned already, the main application thread can create other -
    child - threads and let them run in parallel, either sharing the same core via
    time slicing or having a dedicated CPU for each thread. It can be done using the
    class `java.lang.Thread`, which implements the functional interface `Runnable`.
    The interface is called functional if it has only one abstract method (we will
    discuss functional interfaces in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*). The `Runnable` interface contains one
    method, `run()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to create a new thread:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the `Thread` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `Runnable` interface and pass the object of the implementation
    into the constructor of the class `Thread`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the Thread class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whatever method is used, we end up with a `Thread` class object that has the
    method `start()`. This method call starts the thread execution. Let''s look at
    an example. Let''s create a class called `AThread` that extends `Thread` and overrides
    its `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class AThread extends Thread {
  prefs: []
  type: TYPE_NORMAL
- en: int i1, i2;
  prefs: []
  type: TYPE_NORMAL
- en: public AThread(int i1, int i2) {
  prefs: []
  type: TYPE_NORMAL
- en: this.i1 = i1;
  prefs: []
  type: TYPE_NORMAL
- en: this.i2 = i2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void run() {
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = i1; i <= i2; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println("child thread " + (isDaemon() ? "daemon" : "user") + " "
    + i);'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.SECONDS.sleep(1);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (InterruptedException e) {'
  prefs: []
  type: TYPE_NORMAL
- en: e.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overriding the `run()` method is important because otherwise, the thread will
    do nothing. The `Thread` class implements the `Runnable` interface and has the `run()` method''s
    implementation, but it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public void run() {
  prefs: []
  type: TYPE_NORMAL
- en: if (target != null) {
  prefs: []
  type: TYPE_NORMAL
- en: target.run();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The variable `target` holds the value passed in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public Thread(Runnable target) {
  prefs: []
  type: TYPE_NORMAL
- en: init(null, target, "Thread-" + nextThreadNum(), 0);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But our `AThread` class does not pass any value to the parent class `Target`;
    the variable target is `null`, so the `run()` method in the `Thread` class does
    not do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's use our newly created thread. We expect it to increment variable `i`
    from `i1` to `i2` (these are parameters passed via the constructor) and print
    its value along with the Boolean value returned by the `isDaemon()` method, then
    wait (sleep) for 1 second and increment variable `i` again.
  prefs: []
  type: TYPE_NORMAL
- en: What is daemon?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The word daemon has an ancient Greek origin, meaning a divinity or supernatural
    being of a nature between gods and humans and an inner or attendant spirit or
    inspiring force. But in computer science, this term has more mundane usage and
    is applied to a computer program that runs as a background process, rather than
    being under the direct control of an interactive user. That is why there are two
    types of threads in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: User thread (default), initiated by an application (the main thread is one such
    example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Daemon threads that work in the background in support of user thread activity
    (garbage collection is an example of a daemon thread)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why all daemon threads exit immediately after the last user thread exits
    or is terminated by JVM after an unhandled exception.
  prefs: []
  type: TYPE_NORMAL
- en: Running threads extending Thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use our new class, `AThread`, to demonstrate the behavior we have described.
    Here is the code we are going to run first:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Thread thr1 = new AThread(1, 4);
  prefs: []
  type: TYPE_NORMAL
- en: thr1.start();
  prefs: []
  type: TYPE_NORMAL
- en: Thread thr2 = new AThread(11, 14);
  prefs: []
  type: TYPE_NORMAL
- en: thr2.setDaemon(true);
  prefs: []
  type: TYPE_NORMAL
- en: thr2.start();
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.SECONDS.sleep(1);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (InterruptedException e) {'
  prefs: []
  type: TYPE_NORMAL
- en: e.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Main thread exists");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding code, we create and immediately start two threads – a user
    thread, `thr1`, and a daemon thread, `thr2`. Actually, there is a user thread
    called `main` too, so we run two user threads and one daemon thread. Each of the
    child threads is going to print the incremented number four times, pausing for
    1 second after each print. This means that each thread will be running for 4 seconds.
    The main thread will pause for 1 second too, but one time only, so it will run
    for approximately 1 second. Then, it prints `Main thread exists` and exists. If
    we run this code, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42afcacb-82d0-414b-afd4-e5d36be0c2d5.png)'
  prefs: []
  type: TYPE_IMG
- en: We execute this code on one shared CPU, so, although all three threads are running
    concurrently, they can only use CPU sequentially. Therefore, they cannot be run
    in parallel. On a multicore computer, each thread may be executed on a different
    CPU and the output may be slightly different, but not by much. In any case, you
    would see that the main thread exits first (after approximately 1 second) and
    the child threads run until completion, each for approximately 4 seconds in total.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make user thread run for only 2 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Thread thr1 = new AThread(1, 2);
  prefs: []
  type: TYPE_NORMAL
- en: thr1.start();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab8a6642-440f-4a0b-af2e-1589b74c8613.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the daemon thread did not run the full course. It managed to
    print 13, probably only because it had sent the message to the output device before
    the JVM responded to the last user thread exit.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Runnable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second way to create a thread is to use a class that implements `Runnable`.
    Here is an example of such a class that has almost exactly the same functionality
    as class `AThread`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class ARunnable implements Runnable {
  prefs: []
  type: TYPE_NORMAL
- en: int i1, i2;
  prefs: []
  type: TYPE_NORMAL
- en: public ARunnable(int i1, int i2) {
  prefs: []
  type: TYPE_NORMAL
- en: this.i1 = i1;
  prefs: []
  type: TYPE_NORMAL
- en: this.i2 = i2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void run() {
  prefs: []
  type: TYPE_NORMAL
- en: for (int i = i1; i <= i2; i++) {
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("child thread "  + i);
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.SECONDS.sleep(1);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (InterruptedException e) {'
  prefs: []
  type: TYPE_NORMAL
- en: e.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference is that there is no `isDaemon()` method in the `Runnable` interface,
    so we cannot print whether the thread is daemon or not.
  prefs: []
  type: TYPE_NORMAL
- en: Runing threads implementing Runnable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And here is how this class can be used to create two child threads—one user
    thread and another a daemon thread—exactly as we have done before:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Thread thr1 = new Thread(new ARunnable(1, 4));
  prefs: []
  type: TYPE_NORMAL
- en: thr1.start();
  prefs: []
  type: TYPE_NORMAL
- en: Thread thr2 = new Thread(new ARunnable(11, 14));
  prefs: []
  type: TYPE_NORMAL
- en: thr2.setDaemon(true);
  prefs: []
  type: TYPE_NORMAL
- en: thr2.start();
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: TimeUnit.SECONDS.sleep(1);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (InterruptedException e) {'
  prefs: []
  type: TYPE_NORMAL
- en: e.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("Main thread exists");
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding code, the result will be the same as running threads
    based on a class that extends `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending Thread vs implementing Runnable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing `Runnable` has the advantage (and in some cases, the only possible
    option) of allowing the implementation to extend another class. It is particularly
    helpful when you would like to add thread-like behavior to an existing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class BRunnable extends SomeClass implements Runnable {
  prefs: []
  type: TYPE_NORMAL
- en: int i;
  prefs: []
  type: TYPE_NORMAL
- en: BRunnable(int i, String s) {
  prefs: []
  type: TYPE_NORMAL
- en: super(s);
  prefs: []
  type: TYPE_NORMAL
- en: this.i = i;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public int calculateSomething(double x) {
  prefs: []
  type: TYPE_NORMAL
- en: //calculate result
  prefs: []
  type: TYPE_NORMAL
- en: return result;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void run() {
  prefs: []
  type: TYPE_NORMAL
- en: //any code you need goes here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even invoke the method `run()` directly, without passing the object
    into the Thread constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: BRunnable obj = new BRunnable(2, "whatever");
  prefs: []
  type: TYPE_NORMAL
- en: int i = obj.calculateSomething(42d);
  prefs: []
  type: TYPE_NORMAL
- en: obj.run();
  prefs: []
  type: TYPE_NORMAL
- en: Thread thr = new Thread (obj);
  prefs: []
  type: TYPE_NORMAL
- en: thr.start();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, we have shown many different ways to execute
    the methods of the class that implements `Runnable`. So, implementing `Runnable`
    allows more flexibility in usage. But otherwise, there is no difference in functionality
    comparing to the extending of `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread` class has several constructors that allow setting the thread name
    and the group it belongs to. Grouping of threads helps to manage them in the case
    of many threads running in parallel. The `Thread` class also has several methods
    that provide information about the thread's status and properties and allow us
    to control its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Threads—and any objects for that matter—can also talk to each other using the
    methods `wait()`, `notify()`, and `notifyAll()` of the base class `java.lang.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: But all that is already outside the scope of the introductory course.
  prefs: []
  type: TYPE_NORMAL
- en: How to execute the main(String[]) method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before diving into the garbage collection process, we would like to review
    and summarize how to run an application from a command line. In Java, the following
    statements are used as synonyms:'
  prefs: []
  type: TYPE_NORMAL
- en: Run/execute main class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start main method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run/execute/start/launch JVM or Java process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reason for that is that each of the listed actions happens every time you
    execute one of them. There are also several ways to do it. We have already shown
    you how to run the `main(String[])` method using IntelliJ IDEA and the `java`
    command line. Now, we will just repeat some of what has been said already and
    add other variations that might be helpful for you.
  prefs: []
  type: TYPE_NORMAL
- en: Using IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any IDE allows running the main method. In IntelliJ IDEA, it can be done in
    three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By clicking on the green arrow next to the method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By selecting the class name from the drop-down menu (at the top line, to the
    left of the green arrow) and clicking the green arrow to the right of the menu:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/47ecc693-bded-4567-b5f6-2fea2f282d4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By using the Run menu and selecting the name of the class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/90dbb360-a4a9-435d-82de-6f2c4d56b72c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can also see the option Edit configurations.
    We have used it already to set the parameters that can be passed to the main method
    at the start. But there are more settings possible there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a7dc463-e2f3-4594-9549-0f64f3460763.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, it is possible to also set:'
  prefs: []
  type: TYPE_NORMAL
- en: 'VM options: The Java command options (we will do this in the next section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Environment variables: The way to set some parameters that can be read not
    only in the main method but anywhere in the application, using the `System.getenv()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e093c7a-d9fd-49ef-9bff-c3a8dd3b08fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have set the `java` command option `-Xlog:gc` and the environment variable
    `myprop1=whatever`. The IDE will use these settings to form the following `java`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: java -Xlog:gc -Dmyprop1=whatever com.packt.javapath.ch04demo.MyApplication 2
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The option `-Xlog:gc` tells JVM to display log messages from the garbage collection
    process. We will use this option in the next section to demonstrate how garbage
    collection works. The value of the variable `myprop1` can be retrieved anywhere
    in the application using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: 'String myprop = System.getenv("myprop1");     //returns: "whatever"'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And we have already seen how parameter 2 can be read in the main method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: 'String p1 = args[0];          //returns: "2"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Command line with classes on classpath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use the first program we created in [Chapter 4](64574f55-0e95-4eda-9ddb-b05da6c41747.xhtml),
    *Your First Java Project*, to demonstrate how to use the command line. Here is
    the program we wrote then:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: package com.packt.javapath.ch04demo;
  prefs: []
  type: TYPE_NORMAL
- en: import com.packt.javapath.ch04demo.math.SimpleMath;
  prefs: []
  type: TYPE_NORMAL
- en: public class MyApplication {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: int i = Integer.parseInt(args[0]);
  prefs: []
  type: TYPE_NORMAL
- en: SimpleMath simpleMath = new SimpleMath();
  prefs: []
  type: TYPE_NORMAL
- en: int result = simpleMath.multiplyByTwo(i);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(i + " * 2 = " + result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run it from a command line, it has to be compiled first using the `javac`
    command. An IDE that uses Maven places the `.class` file in the directory `target/classes`.
    If you go into the root directory of your project or just click Terminal (bottom
    left corner in IntelliJ IDEA), you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: java -cp target/classes com.packt.javapath.ch04demo.MyApplication 2
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The result should be displayed as `2 * 2 = 4`.
  prefs: []
  type: TYPE_NORMAL
- en: Command line with a .jar file on classpath
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a `.jar` file with the compiled application code, go to the project
    root directory and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: cd target/classes
  prefs: []
  type: TYPE_NORMAL
- en: jar -cf myapp.jar com/packt/javapath/ch04demo/**
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `.jar` file with the classes `MyApplication` and `SimpleMath` is created.
    Now we can put it on the classpath and run the application again:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: java -cp myapp.jar com.packt.javapath.ch04demo.MyApplication 2
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The result will be displayed the same; `2 * 2 = 4`.
  prefs: []
  type: TYPE_NORMAL
- en: Command line with an executable .jar file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to avoid specifying the main class in the command line. Instead,
    one can create an "executable" `.jar` file. It can be accomplished by placing
    the name of the main class—the one you need to run and that contains the main
    method—into the manifest file. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a text file, `manifest.txt` (the name actually does not matter, but
    it makes the intent clear) that contains the following one line: `Main-Class:
    com.packt.javapath.ch04demo.MyApplication`. There has to be a space after the
    colon (`:`) and there has to be an invisible new line symbol at the end, so make
    sure you have pressed the *Enter* key and the cursor has jumped to the beginning
    of the next line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the command `cd target/classes` and go into the directory `classes`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute the following command: `jar -cfm myapp.jar  manifest.txt  com/packt/javapath/ch04demo/**`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice the sequence of `jar` command options `fm` and the sequence of the following
    files; `myapp.jar  manifest.txt`. They have to be the same, because `f` stands
    for the file the `jar` command is going to create and `m` stands for the manifest
    source. If you put the options as `mf`, then the files have to be listed as `manifest.txt
    myapp.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: java -jar  myapp.jar  2
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The result will be `2 * 2 = 4` again.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with the knowledge of how to run an application, we can now continue
    to the next section, where it is going to be needed.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automatic memory management is an important aspect of JVM that relieves the
    programmer from the need to do it programmatically. In Java, the process that
    cleans up memory and allows you to reuse it is called **Garbage Collection** (**GC**).
  prefs: []
  type: TYPE_NORMAL
- en: Responsiveness, throughput, and stop-the-world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The effectiveness of GC affects two major application characteristics – responsiveness
    and throughput. Responsiveness is measured by how quickly an application responds
    (brings necessary data) to the request. For example, how quickly a website returns
    a page, or how quickly a desktop application responds to an event. The smaller
    the response time, the better the user experience. Throughput, on the other hand,
    indicates the amount of work an application can do in a unit of time. For example,
    how many requests a web application can serve, or how many transactions a database
    can support. The bigger the number, the more value the application can potentially
    generate and the more user requests it can support.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, GC needs to move data around, which is impossible to accomplish while
    allowing data processing because the references are going to change. That's why
    GC needs to stop application threads from executing once in a while for a period
    of time called stop-the-world. The longer these periods are, the quicker GC does
    its job, and the longer an application freeze lasts, which can eventually grow
    big enough to affect both the application's responsiveness and throughput. Fortunately,
    it is possible to tune the GC behavior using `java` command options, but that
    is outside the scope of this book, which is more about introduction than solving
    complex problems. So, we will concentrate on a high-level view of the main activity
    of a GC; inspecting objects in the heap and removing those that don't have references
    in any thread stack.
  prefs: []
  type: TYPE_NORMAL
- en: Object age and generations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The basic GC algorithm determines how old each object is. The term age refers
    to the number of collection cycles the object has survived. When JVM starts, the
    heap is empty and is divided into three sections: young generation, old or tenured
    generation, and humongous regions for holding the objects that are 50% the size
    of a standard region or larger.'
  prefs: []
  type: TYPE_NORMAL
- en: The young generation has three areas, an Eden space and two survivor spaces,
    such as Survivor 0 (*S0*) and Survivor 1 (*S1*).  The newly created objects are
    placed in Eden. When it is filling up, a minor GC process starts. It removes the
    un-referred and circular referred objects and moves others to the *S1* area. At
    the next minor collection, *S0* and *S1* switch roles. The referenced objects
    are moved from Eden and *S1* to *S0*.
  prefs: []
  type: TYPE_NORMAL
- en: At each of the minor collections, the objects that have reached a certain age
    are moved to the old generation. As the result of this algorithm, the old generation
    contains objects that are older than a certain age. This area is bigger than the
    young generation, and, because of that, the garbage collection here is more expensive
    and doesn't happen as often as in the young generation. But it is checked eventually
    (after several minor collections); the un-referenced objects are removed from
    there and the memory is defragmented. This cleaning of the old generation is considered
    a major collection.
  prefs: []
  type: TYPE_NORMAL
- en: When stop-the-world is unavoidable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some collections of objects in the old generation are done concurrently and
    some are done using stop-the-world pauses. The steps include:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial marking of survivor regions (root regions) that may have references
    to objects in the old generation, done using stop-the-world pause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning of survivor regions for references into the old generation, done concurrently,
    while the application continues to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent marking of live objects over the entire heap, done concurrently,
    while the application continues to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remark – completes the marking of live objects, done using stop-the-world pause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleanup – calculates the age of live objects and frees regions (using stop-the-world)
    and returns them to the free list (concurrently)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding sequence might be interspersed with the young generation evacuations
    because most of the objects are short-lived and it is easier to free a lot of
    memory by scanning the young generation more often. There is also a mixed phase
    (when G1 collects the regions already marked as mostly garbage in both the young
    and the old generations) and humongous allocation (where large objects are moved
    to or evacuated from humongous regions).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how GC works, let''s create a program that produces more garbage
    than our usual examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class GarbageCollectionDemo {
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String... args) {
  prefs: []
  type: TYPE_NORMAL
- en: int max = 99888999;
  prefs: []
  type: TYPE_NORMAL
- en: List<Integer> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: for(int i = 1; i < max; i++){
  prefs: []
  type: TYPE_NORMAL
- en: list.add(Integer.valueOf(i));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This program generates close to 100,000,000 objects that take a chunk of heap
    and force GC to move them around from Eden, to S0, S1, and so on. As we have mentioned
    already, to see the log messages from GC, the option `-Xlog:gc` has to be included
    in the `java` command. We chose to use IDE for that, as we described in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c73265ab-f907-43e7-855d-8e04e98394a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we had run the program `GarbageCollectionDemo` and got the following
    output (we show only its beginning):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/173896b1-0e47-4fc2-ac88-4e8e33db9032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the GC process goes through cycles and moves the objects as
    needed, pausing for a short time. We hope you got an idea of how GC works. The
    only thing we would like to mention is that there are a few occasions when full
    GC is performed, using stop-the-world pause:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concurrent failure**: If during the marking phase the old generation gets
    full.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promotion failure**: If during the mixed phase the old generation runs out
    of space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evacuation failure**: When the collector cannot promote objects to the survivor
    space and the old generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Humongous allocation**: When an application tries to allocate a very big
    object. If tuned properly, your applications should avoid full GC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To help with GC tuning, the JVM provides platform-dependent default selections
    for the garbage collector, heap size, and runtime compiler.  But fortunately,
    the JVM vendors improve and tune GC process all the time, so most of the applications
    work just fine with the default GC behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Monitoring JVM while running an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the Java official documentation and name a few tools that come with JDK
    installation that can be used to monitor JVM and the Java application.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jcmd, Java VisualVM, and JConsole, for example. Jcmd is particularly helpful
    as it is easy to remember and gives you the list of all Java processes that are
    currently running. Just type `jcmd` in the terminal window. That is an indispensable
    tool in case you are experimenting with several Java applications and some of
    them may not exit, whether because of a defect or because of such an intended
    design. Jcmd displays a **Process ID** (**PID**) for each running Java process,
    which you can use to stop it if need be by typing the command `kill -9 <PID>`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned about the main Java processes that support
    any application's execution, the steps of a program's execution, and the main
    components of JVM architecture that compose the execution environment; runtime
    data areas, classloader, and execution engine. You have also learned about the
    lightweight processes called threads and how they can be used for concurrent processing.
    The summary of ways to run a Java application and the main features of the garbage
    collection process concluded the discussion about JVM.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will walk through several often used libraries – both
    standard (that come with JDK) and external open-source libraries. Pretty soon,
    you will know most of them very well, but to get there you need to start, and
    we will help you with our comments and examples.
  prefs: []
  type: TYPE_NORMAL
