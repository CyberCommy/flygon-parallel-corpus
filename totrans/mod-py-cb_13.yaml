- en: Chapter 13. Application Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using YAML for configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python for configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using class-as-namespace for configuration values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing scripts for composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using logging for control and audit output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining two applications into one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining many applications using the Command design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing arguments and configuration in composite applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping and combining CLI applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping a program and checking the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling complex sequences of steps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python's extensible library gives us rich access to numerous computing resources.
    This makes Python programs particularly strong at integrating components to create
    sophisticated composite processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Using argparse to get command line input* , *Using cmd for creating
    command-line applications* , and *Using the OS environment settings* recipes in [Chapter
    5](text00063.html#page "Chapter 5. User Inputs and Outputs") , *User Inputs and
    Outputs* , specific techniques for creating top-level (main) application scripts
    were shown. In [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical
    Format, and Logical Layout") , *Input/Output, Physical Format, Logical Layout*
    , we looked at file-system input and output. In [Chapter 12](text00129.html#page
    "Chapter 12. Web Services") , *Web Services* , we looked at creating servers,
    which are main applications that receive requests from clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these examples show some aspects of application programming in Python.
    There are some additional techniques that are helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing configuration from files. In the  *Using argparse to get command
    line input*  recipe in [chapter 5](text00063.html#page "Chapter 5. User Inputs
    and Outputs") , *User Inputs and Outputs* , we showed techniques for parsing command
    line arguments. In the  *Using the OS environment settings* recipe, we touched
    on other kinds of configuration details. In this chapter, we''ll look at a number
    of ways to handle configuration files. There are many file formats that can be
    used to store long-term configuration information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The INI file format as processed by the `configparser` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The YAML file format is very easy to work with, but requires an add-on module
    that's not currently part of the Python distribution. We'll look at this in the
    *Using YAML for configuration files* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Properties file format is typical of Java programming, and can be handled
    in Python without writing too much code. The syntax overlaps with Python scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Python scripts, a file with assignment statements looks a lot like a properties
    file, and is very easy to process using `compile()` and `exec()` methods. We'll
    look at this in the *Using Python for configuration files* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python modules with class definitions is a variation that uses Python syntax,
    but isolates the settings into separate classes. This can be processed with the
    `import` statement. We'll look at this in the *Using class-as-namespace for configuration*
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll look at ways that we can design applications that can
    be composed to create larger, more sophisticated composite applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at the complications that can arise from composite applications and
    the need to centralize some features like command line parsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll extend some of the concepts from [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , and [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* , and
    apply the idea of the Command design pattern to Python programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications will have a hierarchy of configuration options. There could
    be defaults that are built in to a particular release. There might be server-wide
    (or cluster-wide) values. There might be user-specific values, or perhaps even
    configuration files that are local to a specific invocation of a program.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, these configuration parameters will be written in files so that
    they are easy to change. The common tradition in Linux is to put system-wide configuration
    in the `/etc` directory. A user's personal changes would be in their home directory,
    often named `~username` .
  prefs: []
  type: TYPE_NORMAL
- en: How can we support a rich hierarchy of locations for configuration files?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example will be a web service that provides hands of cards to users. The
    service is shown in several recipes throughout [Chapter 12](text00129.html#page
    "Chapter 12. Web Services") , *Web Services* . We'll gloss over some details of
    the service so that we can focus on fetching configuration parameters from a variety
    of file-system locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll follow the design pattern of the **bash** shell, which looks for configuration
    files in several places:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts with the `/etc/profile` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After reading that file, it looks for one of these files, in this order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/.bash_profile` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/.bash_login` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`~/.profile` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a POSIX-compliant operating system, the shell expands the `~` to be the home
    directory for the logged-in user. This is defined as the value of the `HOME` environment
    variable. In general, the Python `pathlib` module can handle this automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to keep configuration parameters for a program:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a class definition has the advantage of tremendous flexibility and a relatively
    simply Python syntax. It can use ordinary inheritance to include default values.
    It doesn't work as well when there are multiple sources of parameters because
    there's no trivial way to mutate a class definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a mapping parameter, we can then use the `ChainMap` collection to search
    multiple dictionaries, each from a different source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `SimpleNamespace` instance, the `types` module offers this class, which
    is mutable and can be updated from multiple sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Namespace` instance from the `argparse` module can be handy because it mirrors
    the options that come from the command-line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design pattern from the bash shell uses two separate files. When we include
    application-wide defaults, there are actually three levels of configuration. This
    can be done elegantly with a mapping and the `ChainMap` class from the `collections`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In later recipes, we''ll look at ways to parse and process a configuration
    file. For the purposes of this recipe, we''ll assume that a function, `load_config_file()`
    , has been defined that will load a configuration map from the contents of the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We'll look at ways to implement this function separately. Variations on the
    implementation are covered in the  *Using YAML for configuration files*  and 
    *Using Python for configuration files*  recipes of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `pathlib` module can help with this processing. This module provides the
    `Path` class definition that provides a great deal of sophisticated information
    about the OS's files. For more information, see the *Using pathlib to work with
    filenames* recipe in [Chapter 9](text00099.html#page "Chapter 9. Input/Output,
    Physical Format, and Logical Layout") , *Input/Output, Physical Format, Logical
    Layout* .
  prefs: []
  type: TYPE_NORMAL
- en: Why so many choices?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's a side-bar topic that sometimes arises when discussing this kind of
    design—Why have so many choices? Why not specify exactly two places?
  prefs: []
  type: TYPE_NORMAL
- en: The answer depends on the context for the design. When creating an entirely
    new application, the choices can be limited to exactly two. However, when replacing
    legacy applications, it's common to have a new location that's better in some
    ways than the legacy location, but the legacy location still needs to be supported.
    After several such evolutionary changes, it's common to see a number of alternative
    locations for files.
  prefs: []
  type: TYPE_NORMAL
- en: Also, because of variations among Linux distributions, it's common to see variations
    that are typical for one distribution, but atypical for another. And, of course,
    when dealing with Windows, there will be variant file paths that are unique to
    that platform too.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `Path` class and the `ChainMap` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Define an overall function to get the configuration files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Create paths for the various locations. These are called pure paths because
    there''s no relationship with the file-system. They start as names of *potential*
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the application''s built-in defaults:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each individual configuration file is a mapping from key to value. The various
    mapping objects will form a list; this becomes the final `ChainMap` configuration
    mapping. We'll assemble the list of maps by appending items, and then reverse
    the order after the files are loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a system-wide configuration file exists, load this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate through other locations looking for a file to load. This loads the
    first of the files that it finds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've included the **if-break** pattern to stop after the first file is found.
    This modifies the loop from the default semantics of For All to mean There Exists.
    See the Avoiding a potential problem with break statements recipe for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reverse the list and create the final `ChainMap` . The list needs to be reversed
    so that the local file is searched first, then the system settings, and finally
    the application default settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the final configuration mapping:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once we've built the `configuration` object, we can use the final configuration
    like a simple mapping. This object supports all of the expected dictionary operations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most elegant features of any object-oriented language is being able
    to create simple collections of objects. In this case, the objects are filesystem
    `Path` objects.
  prefs: []
  type: TYPE_NORMAL
- en: As noted in the *Using pathlib to work with file names* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, Logical Layout* , the `Path` object has a `resolve()` method
    that can return a concrete `Path` built from a pure `Path` . In this recipe, we
    used the `exists()` method to determine if a concrete path could be built. The
    `open()` method, when used to read a file, will resolve the pure `Path` and open
    the associated file.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating dictionaries – inserting and updating* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , we looked at the basics of using a dictionary. Here we've
    combined several dictionaries into a chain. When a key is not located in the first
    dictionary of the chain, then later dictionaries in the chain are checked. This
    is a handy way to provide default values for each key in the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of creating a `ChainMap` manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `config` object is built from three separate mappings. The first might be
    details from a local file such as `~/.bash_login` . The second might be system-wide
    settings from the `/etc/profile` file. The third contains application-wide defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we see when we query this object''s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The value for any given key is taken from the first instance of that key in
    the chain of maps. This allows a very simple way to have local values that override
    system-wide values that override the built-in defaults.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the *Mocking External Resources* recipe in [Chapter 11](text00120.html#page
    "Chapter 11. Testing") , *Testing* , we looked at ways to mock external resources
    so that we could write a unit test that wouldn''t accidentally delete files. A
    test for the code in this recipe needs to mock the filesystem resources by mocking
    the `Path` class. Here''s how the unit test would look, starting with a high-level
    outline of the test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a boilerplate structure for a unit test. Mocking a `Path` becomes
    rather complex because of the number of distinct objects involved. Here''s a summary
    of what kinds of object creations occur:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to the `Path` class creates a `Path` object. The test process will create
    two `Path` objects, so we can use the `side_effect` feature to return each of
    these. We need to be sure that the values are in the correct order based on the
    code in the unit to be tested:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For the value of `system_path` , there will be a call to a `Path` object `exists()`
    method; this will determine if the concrete file exists. There will then be calls
    to open the file and read the content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For the value of `home_path` , there will be a call to the `expanduser()` method
    to change the `~` to a proper home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The expanded `home_path` is then used with the `/` operator to create the three
    alternative directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purposes of unit testing, we''ve decided that the first path to search
    doesn''t exist. The other two do exist, but we expect that only one of these will
    be read. The second will be ignored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For mock paths that don''t exist, we can use this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the mock paths that exist, we''ll have something more complex:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have to also handle the processing of the file via the `mock_open()` function
    in the mock module. This can handle all of the various details of files being
    used as context managers, something that becomes rather complex. The `with` statement
    requires `__enter__()` and `__exit__()` methods, which is handled by `mock_open()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to assemble each of these mock objects in reverse order. This assures
    that each variable is created before it''s used. Here''s the entire `setUp()`
    method showing the objects in the proper order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the mocks for `Path` manipulation, we've added one more mock
    module. The `mock_load` object is a stand-in for the undefined `load_config_file()`
    . We want to separate this test from the path processing, so the mock object uses
    the `side_effect` attribute to return two separate values, expecting that it will
    be invoked exactly twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the tests that will confirm that the path search works as
    advertised. Each test starts by applying two patches to create a modified context
    for testing the `get_config()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first use of `patch()` replaces the `Path` class with `self.mock_path` .
    The second use of `patch()` replaces the `load_config_file()` function with the
    `self.mock_load` function; this function will return two small configuration documents.
    In both cases, the context being patched is the current module, with the `__name__`
    value of `"__main__"` . In the cases where the unit test is in a separate module,
    then the module under test will be imported, and that module's name will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check to see that the `load_config_file()` was called properly by examining
    the calls to `self.mock_load` . In this case, there should be one for each of
    the configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've made sure that the `self.mock_system_path` file is checked first. Note
    the chain of calls—`Path()` returns a `Path` object. That object's `open()` must
    return a value that will be used as a context. The `__enter__()` method of a context
    is an object that will be used by the `load_config_file()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve made sure that the other path is one for which the `exists()` method
    returns `True` . Here''s the check for the filenames that are built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/` operator is implemented by the `__truediv__()` method. Each of the
    calls builds a separate the `Path` instance. We can confirm that overall, the `Path`
    object is used just twice. Once for the literal `''/etc/profile''` and once for
    the literal `''~''` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that two files answer `True` to the `exists()` method. We expect, however,
    that only one of those two will be checked. Once this is found, the second file
    will be ignored. Here''s a test that confirms that there''s only one check for
    existence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to be complete, we''ve also checked that the file that exists will go
    through the entire context management sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first call is for the `self.exist` object's `open()` method. The return
    value from this is a context that will have the `__enter__()` method executed
    as well as the `__exit__()` method. In the preceding code, we checked that the
    return value from `__enter__()` is read to get the configuration file content.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the  *Using YAML for configuration files*  and *Using Python for configuration
    files*  recipes we'll look at ways to implement the `load_config_file()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Mocking external resources* recipe in [Chapter 11](text00120.html#page
    "Chapter 11. Testing") , *Testing* , we looked at ways to test functions such
    as this, which interact with external resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using YAML for configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a variety of ways to package application inputs and configuration
    files. We'll look at writing files in YAML notation because it's elegant and simple.
  prefs: []
  type: TYPE_NORMAL
- en: How can we represent configuration details in YAML notation?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python doesn''t have a YAML parser built in. We''ll need to add the `pyyaml`
    project to our library using the `pip` package management system. Here''s how
    the installation looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The elegance of the YAML syntax is that simple indentation is used to show
    the structure of the document. Here''s an example of some settings that we might
    encode in YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This document can be seen as a specification for a number of related URLs that
    are all similar to [http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532)
    . The document contains information about building the URL from a scheme, net
    location, base path, and several query strings. The `yaml.load()` function can
    load this YAML document; it will create the following Python structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This *dict-of-dict* structure can be used by an application to tailor its operations.
    In this case, it specifies a sequence of URLs to be queried to assemble a larger
    weather briefing.
  prefs: []
  type: TYPE_NORMAL
- en: We'll often use the *Finding configuration files*  recipe to check a variety
    of locations for finding a given configuration file. This flexibility is often
    essential for creating an application that's easily used on a variety of platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll build the missing part of the previous example, the
    `load_config_file()` function. Here''s the template that needs to be filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `yaml` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `yaml.load()` function to load the YAML-syntax document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The YAML syntax rules are defined at [http://yaml.org](http://yaml.org) . The
    idea of YAML is to provide JSON-like data structures with more flexible, human-friendly
    syntax. JSON is a special case of the more general YAML syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off here is that some spaces and line breaks in JSON don't matter—there
    is visible punctuation to show the structure of the document. In some of the YAML
    variants, line breaks and indentation determine the structure of the document;
    the use of white-space means that line breaks will matter with YAML documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle data structures available in JSON syntax are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequence** : `[item, item, ...]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mapping** : `{key: value, key: value, ...}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalar** :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String: `"value"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Number: `3.1415926`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Literal: `true` , `false` , and `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON syntax is one style of YAML; it's a called flow style. In this style, the
    document structure is marked by explicit indicators. The syntax requires `{…}`
    and `[…]` to show the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternative that YAML offers is block style. The document structure is
    defined by line breaks and indentation. Furthermore, long string scalar values
    can use plain, quoted, and folded styles of syntax. Here is how the alternative
    YAML syntax works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block sequence** : We preface each line of a sequence with a -. This looks
    like a bullet list, and is easy to read. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When loaded, this will create a dictionary with a list of strings in Python:
    `{zoneid: [''ANZ532'', ''AMZ117'', ''AMZ080'']}` .'
  prefs: []
  type: TYPE_NORMAL
- en: '**Block mapping** : We can use simple `key: value` syntax to associate a key
    with a simple scalar. We can use `key:` on a line by itself; the value is indented
    on the following lines. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a nested dictionary that looks like this in Python: `{''url'':
    {''scheme'': ''http'', ''netloc'': ''marine.weather.gov''}}` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use explicit key and value markers, `?` and `:` . This can help
    when the keys are particularly long strings or more complex objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Some more advanced features of YAML will make use of this explicit separation
    between key and value:'
  prefs: []
  type: TYPE_NORMAL
- en: For short string scalar values, we can leave them plain, and the YAML rules
    will simply use all the characters with leading and trailing white-space stripped
    away. The examples all use this kind of assumption for string values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quotes can be used for strings, exactly as they are in JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For longer strings, YAML introduces the `|` prefix; the lines after this are
    preserved with all of the spacing and newlines intact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also introduces the `>` prefix, which preserves the words as a long string
    of text—any newlines are treated as single white-space characters. This is common
    for running text.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the indentation determines how much of the document is part of
    the text.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the value may be ambiguous. For example, a US ZIP code is all
    digits—`22102` . This should be understood as a string, even though the YAML rules
    will interpret it as a number. Quotes, of course, can be helpful. To be more explicit,
    a local tag of `!!str` in front of the value will force a specific data type.
    `!!str 22102` , for example, assures that the digits will be treated as a string
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of additional features in YAML that are not present in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: The comments, which begin with `#` and continue to the end of the line. They
    can go almost anywhere. JSON doesn't tolerate comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The document start, which is indicated by the `---` line at the start of a new
    document. This allows a YAML file to contain many individual objects. JSON is
    limited to a single document per file. The alternative to one document-per-file
    is somewhat a more complex parsing algorithm. YAML provides an explicit document
    separator and a very simple parsing interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The YAML file with two separate documents:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `yaml_text` value contains two YAML documents, each of which starts with
    `---` . The `load_all()` function is an iterator that loads the documents one
    at a time. An application must iterate over the results of this to process each
    of the documents in the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document end. A `...` line is the end of a document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex keys for mappings; JSON mapping keys are limited to the available scalar
    types—string, number, `true` , `false` , and `null` . YAML allows mapping keys
    to be considerably more complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What''s important is that Python requires a hash able, immutable object for
    a mapping key. This means that a complex key must be transformed into an immutable
    Python object, generally a `tuple` . In order to create a Python-specific object,
    we need to use a more complex local tag. Here''s an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This example uses `?` and `:` to mark the key and value of a mapping. We've
    done this because the key is a complex object. The key `value` uses a local tag,
    `!!python/tuple` , to create a tuple instead of the default, which would have
    been a `list` . The text of the key uses a flow-type YAML value, `["a", "b"]`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON has no provision for a set. YAML allows us to use the `!!set` tag to create
    a set instead of a simple sequence. The items in the set are identified by a `?`
    prefix because they are considered keys of a mapping for which there are no values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the `!!set` tag is at the same level of indentation as the values
    within the set collection. It''s indented inside the dictionary key of `data_values`
    :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `!!set` local tag modifies the following sequence to become a `set` object
    instead of the default list object. The resulting set is equal to the expected
    Python set object, `{'some', 'more', 'words'}` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python mutable object rules will have to be applied to the contents of a set.
    It's impossible to build a set of `list` objects because list instances don't
    have hash values. The `!!python/tuple` local tag will have to be used to build
    a set of tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create a Python list-of-two-tuples sequence, as well which implements
    ordered mapping. The `yaml` module doesn''t readily create an `OrderedDict` for
    us:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that it's difficult to take the next step and create an `OrderedDict` from
    this without specifying a large number of details. Here's the YAML to create an
    instance of `OrderedDict` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `args` keyword is required to support the `!!python/object/apply` tag. There's
    only one positional argument, and it's a YAML `!!omap` built from a sequence of
    keys and values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python objects of almost any class can be built using YAML local tags. Any class
    with a simple `__init__()` method can be built from a YAML serialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a simple class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined a class with two positional attributes. Here''s the YAML description
    of this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `kwds` key to provide two keyword-based argument values to the
    `Card` constructor function. The Unicode `♣` character works well because YAML
    files are text written using UTF-8 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to local tags, which start with `!!` , YAML also supports tags that
    are URIs using the `tag:` scheme. This allows URI-based type specifications that
    are globally unique. This can make YAML documents easier to process in a variety
    of contexts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tag includes an authority name, a date, and specific details in the form of
    a `/` -delimited path. For example, a tag might look like this—`!<tag:www.someapp.com,2016:rules/rule1>`
    .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Finding configuration files* recipe to see how to search multiple file-system
    locations for a configuration file. We can easily have application defaults, system-wide
    settings, and personal settings built into separate files and combined by an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Python for configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a variety of ways that we can package application inputs and configuration
    files. We'll look at writing files in Python notation because it's elegant and
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: A number of packages use assignment statements in a separate module for providing
    configuration parameters. The Flask project in particular, can do this. We looked
    at Flask in the *Using the Flask framework for RESTful APIs* recipe and a number
    of related recipes in [Chapter 12](text00129.html#page "Chapter 12. Web Services")
    , *Web Services* .
  prefs: []
  type: TYPE_NORMAL
- en: How can we represent configuration details in Python module notation?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python assignment statement notation is particularly elegant. It's quite simple,
    easy to read, and extremely flexible. If we use assignment statements, we can
    import the configuration details from a separate module. This could have a name
    like `settings.py` to shows that it's focused on configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Because Python treats each imported module as a global **Singleton** object,
    we can have several parts of an application all use the `import settings` statement
    to get a consistent view of the current, global application configuration parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, however, we might want to choose one of several alternative settings
    files. In this case, we want to load a file using a technique that's more flexible
    than the `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like to be able to provide definitions in a text file that look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is Python syntax. The parameters include two variables, `query` and `url.`
    The value of the `query` variable is a dictionary with a single key, `mz` , and
    a sequence of values.
  prefs: []
  type: TYPE_NORMAL
- en: This can be seen as a specification for a number of related URLs that are all
    similar to [http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532)
    .
  prefs: []
  type: TYPE_NORMAL
- en: We'll often use the *Finding configuration files* recipe to check a variety
    of locations for finding a given configuration file. This flexibility is often
    essential for creating an application that's easily used on a variety of platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll build the missing part of the previous example, the
    `load_config_file()` function. Here''s the template that needs to be filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code replaces the `# Details omitted.` line in the `load_config_file()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the code in the configuration file using the built-in `compile()` function.
    This function requires the source text as well as a filename from which the text
    was read. The filename is essential for creating trace-back messages that are
    useful and correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In rare cases where the code doesn't come from a file, the general practice
    is to provide a name such as `<string>`  instead of a filename.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the code object created by the `compile()` function. This requires
    two contexts. The global context provides any previously imported modules, plus
    the `__builtins__` module. The local context is where new variables will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When code is executed at the very top level of a script file—often inside the
    `if __name__ == "__main__"` condition—it executes in a context where globals and
    locals are the same. When code is executed inside a function, method, or class
    definition, the locals for that context are separate from the globals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By creating a separate `locals` object, we've made sure that the imported statements
    don't make unexpected changes to any other global variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The details of the Python language; syntax and semantics are embodied in the
    `compile()` and `exec()` functions. When we launch a script, the process is essentially
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the text. Compile it with the `compile()` function to create a code object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `exec()` function to execute that code object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `__pycache__` directory holds code objects, and saves recompiling text files
    that haven't changed. It doesn't have a material impact on the processing.
  prefs: []
  type: TYPE_NORMAL
- en: The `exec()` function reflects the way Python handles global and local variables.
    There are two namespaces provided to this function. These are visible to a script
    that's running via the `globals()` and `locals()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We provided two distinct dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary of global objects. These variables can be accessed via the `global`
    statement. The most common use is to provide access to the imported modules, which
    are always global. The `__builtins__` module, for example, is often provided.
    In some cases, other modules should be added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dictionary provided for the locals is updated by each assignment statement.
    This local dictionary allows us to capture the variables created within the `settings`
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe builds a configuration file that can be entirely a sequence of `name
    = value` assignments. This statement is supported directly by the Python assignment
    statement syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the full spectrum of Python programming is available. There are
    a number of engineering trade-offs that must be made.
  prefs: []
  type: TYPE_NORMAL
- en: Any statement can be used in the configuration file. However, this can lead
    to complexity. If the processing becomes too complex, the file ceases to be configuration,
    and becomes a first-class part of the application. Very complex features should
    be done by modifying the application programming, not hacking around with the
    configuration settings. Since Python applications include the source, this is
    relatively easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the simple assignment statement, it can be sensible to use `if`
    statements to handle alternatives. A file might provide a section for unique features
    of a specific run-time environment. For example, the `platform` package can be
    used to isolate features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something like this might be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For this to work, the globals should include `platform` and `Path` . This a
    reasonable extension above and beyond `__builtins__` .
  prefs: []
  type: TYPE_NORMAL
- en: 'It can also be sensible to do some processing simply to make a number of related
    settings easier to organize. For example, an application might have a number of
    related files. It can be helpful to write a configuration file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The values of `log` and `out` are used by the application. The value of `base`
    is only used to assure that the other two locations are placed in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the following variation on the `load_config_file()` function
    shown earlier. This version includes some additional modules and global classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Including `Path` and `platform` means that a configuration file can be written
    without the overhead of `import` statements. This can make the settings simpler
    to prepare and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Finding configuration files* recipe to learn how to search multiple
    file-system locations for a configuration file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using class-as-namespace for configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python offers a variety of ways for packaging application inputs and configuration
    files. We'll look at writing files in Python notation because it's elegant and
    simple.
  prefs: []
  type: TYPE_NORMAL
- en: A number of projects allow the use of a class definition for providing configuration
    parameters. The use of a class hierarchy means that inheritance techniques can
    be used to simplify organization of parameters. The Flask package in particular,
    can do this. We looked at Flask in the recipe,  *Using the Flask framework for
    RESTful APIs* , and a number of related recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How can we represent configuration details in Python class notation?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python notation for defining the attributes of a class is particularly elegant.
    It's quite simple, easy to read, and reasonably flexible. We can, with little
    work, define a sophisticated configuration language that allows someone to change
    configuration parameters for a Python application quickly and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: We can base this language on class definitions. This allows us to package a
    number of configuration alternatives in a single module. An application can load
    the module and pick the relevant class definition from the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like to be able to provide definitions that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create this `Configuration` class in a single `settings` module. To
    use the configuration, the main application will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses a fixed file with a fixed class name. In spite of the apparent lack
    of flexibility, this can often be more useful than other alternatives. We have
    two additional ways to support complex configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `PYTHONPATH` environment variable to list a number of locations
    for a configuration module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use multiple inheritance and mix ins to combine defaults, system-wide settings,
    and localized settings into a configuration class definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques can be helpful because the configuration file locations simply
    follow Python's rules for finding modules. We don't need to implement our own
    search for the configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll build the missing part of the previous example, the
    `load_config_file()` function. Here''s the template that needs to be filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This code replaces the `# Details omitted.` line in the `load_config_file()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile the code in the given file using the built-in `compile()` function.
    This function requires the source text as well as a filename from which the text
    was read. The filename is essential for creating trace-back messages that are
    useful and correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code object created by the `compile()`  method. We need to provide
    two contexts. The global context can provide the `__builtins__` module, plus the
    `Path` class and the `platform` module. The local context is where new variables
    will be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This returns only the defined `Configuration` class from the locals which are
    set by the executed module. Any other variables will be ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The details of the Python language—syntax and semantics—are embodied in the
    `compile()` and `exec()` functions. The `exec()` function reflects the way Python
    handles global and local variables. There are two namespaces provided to this
    function. The global `namespace` instance includes `__builtins__` plus a class
    and module that might be used in the file.
  prefs: []
  type: TYPE_NORMAL
- en: The local variable namespace will have the new class created in it. This namespace
    has a `__dict__` attribute that makes it accessible via dictionary methods. Because
    of this, we can then extract the class by name. The function returns the class
    object for use throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: We can put any kind of object into the attributes of a class. Our example showed
    mapping objects. There's no limitation on what can be done when creating attributes
    at the class level.
  prefs: []
  type: TYPE_NORMAL
- en: We can have complex calculations within the `class` statement. We can use this
    to create attributes which are derived from other attributes. We can execute any
    kind of statement, including `if` statements and `for` statements to create attribute
    values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a class definition means that we can leverage inheritance to organize
    the configuration values. We can easily create multiple subclasses of `Configuration`
    , one of which will be selected for use in the application. The configuration
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that our application must choose an appropriate class from the available
    classes in the `settings` module. We might use an OS environment variable or a
    command-line option to specify the class name to use. The idea is that our program
    is executed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This would locate the `Chesapeake` class in the `settings` module. Processing
    would then be based on the details in that particular configuration class. This
    idea leads to an extension to the `load_config_file()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pick one of the available classes, we''ll provide an additional
    parameter with the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Rather than manually compile and execute the module, we've used the higher-level
    `importlib` module. This module implements the `import` statement semantics. The
    requested module is imported; compiled and executed—and the resulting module object
    assigned to the variable name `settings_module` .
  prefs: []
  type: TYPE_NORMAL
- en: We can then look inside the module's variables and pick out the class that was
    requested. The `vars()` built-in function will extract the internal dictionary
    from a module, class, or even the local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We've located the `Chesapeake` configuration class in the `settings` module.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration representation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One consequence of using a class like this is that the default display for
    a class isn''t too informative. When we try to print the configuration, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This is nearly useless. It provides one nugget of information, but that's not
    nearly enough for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `vars()` function to see more details. However, this shows local
    variables, not inherited variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is better, but still incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: In order to see all of the settings, we need something a little more sophisticated.
    Interestingly, we can't simply define `__repr__()` for this class. A method defined
    in a class will apply to the instances of this class, not the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Each class object we create is an instance of the built-in `type` class. We
    can, using a meta-class, tweak the way the `type` class behaves, and implement
    a slightly nicer `__repr__()` method, which looks through all parent classes for
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll extend the built-in type with a `__repr__` that does a somewhat better
    job at displaying the working configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The class name is available from the superclass, `type` , as the `__name__`
    attribute. The names of the base classes are included as well, to show the inheritance
    hierarchy for this configuration class.
  prefs: []
  type: TYPE_NORMAL
- en: The `base_values` are built from the attributes of all of the base classes.
    Each class is examined in reverse order of the **Method Resolution Order** ( **MRO**
    ). Loading all of the attribute values in reverse MRO means that all of the defaults
    are loaded first, then overridden with subclass values.
  prefs: []
  type: TYPE_NORMAL
- en: The names that lack the `_` prefix are included. Names with the `_` prefix are
    quietly ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting values are used to create a text representation that resembles
    a class definition. It's not the original class source code; it's the net effect
    of the original class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a `Configuration` class hierarchy that uses this meta-class. The base
    class, `Configuration` , incorporates the meta-class, and provides default definitions.
    The subclass extends those definitions with values that are unique to a particular
    environment or context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can leverage all of the power of Python's multiple inheritance to build `Configuration`
    class definitions. This can provide the ability to combine details on separate
    features into a single configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll look at class definitions in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , and [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing scripts for composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many large applications are actually amalgamations of multiple, smaller applications.
    In enterprise terminology, they are often called application systems comprising
    individual command-line application programs.
  prefs: []
  type: TYPE_NORMAL
- en: Some large, complex applications include a number of commands. For example,
    the Git application has numerous individual commands, such as `git pull` , `git
    commit` , and `git push` . These can also be seen as separate applications that
    are part of the overall Git system of applications.
  prefs: []
  type: TYPE_NORMAL
- en: An application might start as a collection of separate Python script files.
    At some point during its evolution, it can become necessary to refactor the scripts
    to combine features and create new, composite scripts from older disjoint scripts.
    The other path is also possible, a large application might be decomposed and refactored
    into a new organization.
  prefs: []
  type: TYPE_NORMAL
- en: How can we design a script so that future combinations and refactoring is made
    as simple as possible?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to distinguish between several design features of a Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen several aspects of gathering input:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting highly dynamic input from a command-line interface and environment variables.
    See the *Using argparse to get command-line input* recipe in [Chapter 5](text00063.html#page
    "Chapter 5. User Inputs and Outputs") , *User Inputs and Outputs* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting slow for changing configuration options from files. See the recipes, 
    *Finding configuration files* , *Using YAML for configuration files* , and *Using
    Python for configuration files* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For reading any input files, see the  *Reading delimited files with the CSV module*
    , *Reading complex formats using regular expressions* , *Reading JSON documents*
    , *Reading XML documents* , and *Reading HTML documents*  recipes in [Chapter
    9](text00099.html#page "Chapter 9. Input/Output, Physical Format, and Logical
    Layout") , *Input/Output, Physical Format, and Logical Layout* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several aspects to producing output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating logs and offering other features that support audit, control, and monitoring.
    We'll look at some of this in the *Using logging for control and audit output*
    recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the principle output of the application. This might be printed or written
    to an output file, using the same library modules used to parse inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real work of the application. These are the essential features, disentangled
    from the various input parsing and output formatting considerations. This algorithm
    works exclusively with Python data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This *separation of concerns* suggests that any application, no matter how simple,
    should be designed as several separate functions. These should be combined into
    a complete script. This lets us separate the input and output from the core processing.
    The processing is the part we'll often want to reuse. The input and output formats
    should be something that can easily be changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, we''ll look at a simple application that creates sequences
    of dice rolls. Each sequence will follow the rules of the game of craps. Here
    are the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first roll of two dice is the *come out* roll:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A roll of two, three, or twelve is an immediate loss. The sequence has a single
    value, for example, `[(1, 1)]` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A roll of seven or eleven is an immediate win. This sequence also has a single
    value, for example, `[(3, 4)]` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any other number establishes a point. The sequence starts with the point value
    and continues until either a seven or the point value is rolled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A final seven is a loss, for example, `[(3, 1), (3, 2), (1, 1), (5, 6), (4,
    3)]` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A final match of the original point value is a win. There will be a minimum
    of two rolls. There's no upper bound on the length of a game, for example, `[(3,
    1), (3, 2), (1, 1), (5, 6), (1, 3)]` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output is a sequence of items with different structures. Some will be short
    lists. Some will be long lists. This is an ideal place for using YAML format files.
  prefs: []
  type: TYPE_NORMAL
- en: This output can be controlled by two inputs—how many samples to create, and
    whether or not to seed the random number generator. For testing purposes, it can
    help to have a fixed seed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Design all of the output display into two broad areas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions (or classes) that do no processing, but display result objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logging may be for debugging, monitoring, audit, or some other control. This
    is a cross-cutting concern that will be embedded in the rest of the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this example, there are two outputs—the sequence of sequences, and some
    additional information to confirm that processing worked properly. A count of
    each number rolled is a handy way to establish that the simulated dice were fair.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence of rolls needs to be written to a file. This suggests that the
    `write_rolls()` function is given an iterator as a parameter. Here''s a function
    that iterates and dumps values to a file in YAML notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The monitoring and control output should display the input parameters used
    to control the processing. It should also provide the counts that show that the
    dice were fair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Design (or refactor) the essential processing of the application to look like
    a single function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All inputs are parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All outputs are produced by `return` or `yield` . Use `return` to create the
    single result. Use `yield` to generate an sequence iterate for multiple results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we can easily make the core feature a function that emits
    an sequence iterate of values. The output function can use this iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This function relies on a `craps_game()` function to generate the requested
    number of samples. Each sample is a full game, showing all of the dice rolls.
    This function provides the `face_count` counter to this lower-level function to
    accumulate some totals to confirm that everything worked properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `craps_game()` function implements the craps game rules to emit a single
    sequence of one or more rolls. This comprises all the rolls in a single game.
    We'll look at this `craps_game()` function later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor all of the input gathering into a function (or class) that gathers
    the various input sources. This can include environment variables, command-line
    arguments, and configuration files. It may also include the names of multiple
    input files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This function gathers command-line arguments. It also checks the `os.environ`
    collection of environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: The argument parser will handle the details of parsing the `--samples` and `--output`
    options. We can leverage additional features of `argparse` to better validate
    the argument values.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `output_path` is created from the the value of the `--output` option.
    Similarly, the value of the `RANDOMSEED` environment variable is validated and
    placed into the `options` namespace. This use of the `options` object keeps all
    of the various arguments in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the final `main()` function, which incorporates the three previous elements,
    to create the final, overall script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This brings the various aspects of the application together. It parses the command-line
    and environment options. It creates a control total counter.
  prefs: []
  type: TYPE_NORMAL
- en: The `roll_iter()` function is the core processing. It takes the various options,
    and it emits a sequence of rolls.
  prefs: []
  type: TYPE_NORMAL
- en: The primary output from `roll_iter()`  method is collected by `write_rolls()`
    and written to the given output path. The control output is written by a separate
    function, so that we can change the summary without an impact on the primary output.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The command line requested ten samples, and specified an output file of `x.yaml`
    . The control output is a simple dump of the options. It shows the values for
    the parameters plus the additional values set in the `options` object.
  prefs: []
  type: TYPE_NORMAL
- en: The control output includes the counts from ten samples. This provides some
    confidence that values such as six, seven, and eight occur more often. It shows
    that values such as three and twelve occur less frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The central premise here is the separation of concerns. There are three distinct
    aspects to the processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inputs** : The parameters from the command line, and environment variables
    are gathered by a single function, `get_options()` . This function can grab inputs
    from a variety of sources, including configuration files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outputs** : The primary output was handled by the `write_rolls()` function.
    The other control output was handled by accumulating totals in a `Counter` object
    and then dumping this output at the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process** : The application''s essential processing is factored into the
    `roll_iter()` function. This function can be reused in a variety of contexts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of this design is to separate the `roll_iter()` function from the surrounding
    application details. Another application might have different command-line arguments,
    or different output formats, but reuse the essential algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there may be a second application that performs some statistical
    analyses on the sequences of rolls. This might include a count of rolls, and the
    final outcome of win or lose. We can assume that these two applications are `generator.py`
    (shown previously) and `overview_stats.py` .
  prefs: []
  type: TYPE_NORMAL
- en: 'After using these two applications to create rolls, and summarize them, the
    users may determine that it would be advantageous to combine the roll creation
    and the statistical overview into a single application. Because the various aspects
    of each application have been separated, it becomes relatively easy to rearrange
    the features and create a new application. We can now build a new application
    that will start with the following two imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This new application can be built without any changes to the other two applications.
    This leaves the original applications untouched by the introduction of new features.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, the new application did not involve any copying or pasting
    of code. The new application imports working software—changes made to fix one
    application will also fix latent bugs in other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reuse via copy and paste creates technical debt. Avoid copying and pasting the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: When we try to copy code from one application to make a new application, we
    create a confusing situation. Any changes made to one copy won't magically fix
    latent bugs in the other copy. When changes are made to one copy, and the other
    copy is not kept up-to-date, this is one kind of *code rot* .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we skipped over the details of the `craps_rules()`
    function. This function creates a sequence of dice rolls that comprise a single
    game of *Craps* . It can vary from a single roll to a sequence of indefinite length.
    About 98% of the games will be thirteen or fewer throws of the dice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules depend on the total of two dice. The data captured include the two
    separate faces of the dice. In order to support these details, it''s helpful to
    have a `namedtuple` instance that has these two related properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This `roll()` function creates a `namedtuple` instance with a sequence that
    shows the faces of the dice, as well as the total of the dice. The `craps_game()`
    function will generate enough rules to return one complete game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `craps_game()` function implements the rules for craps. If the first roll
    is two, three, or twelve, the sequence only has a single value, and the game is
    a loss. If the first roll is seven or eleven, the sequence also has only a single
    value, and the game is a win. The remaining values establish a point. The sequence
    of rolls starts with the point value. The sequence continues until it's ended
    by seven or the point value.
  prefs: []
  type: TYPE_NORMAL
- en: Designing as a class hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The close relationship between `roll_iter()` , `roll()` , and `craps_game()`
     methods suggests that it might be better to encapsulate these functions into
    a single class definition. Here''s a class that has all of these features bundled
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This class includes an initialization of the simulator to include its own random
    number generator. It will either use the given seed value, or the internal algorithm
    will pick seed value. The `roll()` method will set the `self.total` and `self.faces`
    instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: The `craps_game()` generates one sequence of rolls for one game of craps. It
    uses the `roll()` method and the two instance variables, `self.total` and `self.faces`
    , to track the state of the dice.
  prefs: []
  type: TYPE_NORMAL
- en: The `roll_iter()` method generates the sequence of games. Note that the signature
    of this method is not exactly like the preceding `roll_iter()` function. This
    class separates random number seeding from the game creation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting `main()` to use the `CrapsSimulator` class is left as an exercise
    for the reader. Since the method names are similar to the original function names,
    the refactoring should not be terribly complex.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the  *Using argparse to get command-line input* recipe in [Chapter 5](text00063.html#page
    "Chapter 5. User Inputs and Outputs") , *User Inputs and Outputs* , for background
    on using `argparse` to get inputs from a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Finding configuration files* recipe for a way to track down configuration
    files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using logging for control and audit output* recipe looks at logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Combining two applications into one* recipe, we'll look at ways to combine
    applications that follow this design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using logging for control and audit output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Designing scripts for composition* recipe, we examined three aspects
    of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential processing that connects input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several different kinds of output that applications produce:'
  prefs: []
  type: TYPE_NORMAL
- en: The principle output that helps a user make a decision or take action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control information that confirms that the program worked completely and correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audit summaries that are used to track the history of state changes in persistent
    databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any error messages that indicate why the application didn't work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's less than optimal to lump all of these various aspects into `print()` requests
    that write to standard output. Indeed, it can lead to confusion because too many
    different outputs are conflated into a single stream.
  prefs: []
  type: TYPE_NORMAL
- en: The OS provides two output files, standard output and standard error. These
    are visible in Python through the `sys` module with the names `sys.stdout` and
    `sys.stderr` . By default, the `print()`  method writes to the `sys.stdout` file.
    We can change this and write the control, audit, and error messages to `sys.stderr`
    . This is an important step in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: Python offers the `logging` package, which can be used to direct the ancillary
    output to a separate file. It can also be used to format and filter that additional
    output.
  prefs: []
  type: TYPE_NORMAL
- en: How can we use logging properly?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition* recipe, we looked at an application
    that produced a YAML file with the raw output of a simulation in it. In this recipe,
    we'll look at an application that consumes that raw data and produces some statistical
    summaries. We'll call this application `overview_stats.py` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the design pattern of separating the input, output, and processing,
    we''ll have an application `main()` that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This function will get the options from various sources. If an output file is
    named, it will create the output file using a `with` statement context. This function
    will then process all of the command-line argument files as input from which statistics
    are gathered.
  prefs: []
  type: TYPE_NORMAL
- en: If no output file name is provided, this function will write to the `sys.stdout`
    file. This will display output that can be redirected using the OS shell's `>`
    operator to create a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function relies on a `process_all_files()` function. The `process_all_files()`
    function will iterate through each of the argument files, and gather statistics
    from that file. Here''s what that function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `process_all_files()` function applies `gather_stats()` to each file in
    the `file_names` iterable. The resulting collection is written to the given `result_file`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function shown here conflates processing and output in a design that is
    not ideal. We'll address this design flaw in the *Combining two applications into
    one* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential processing is in the `gather_stats()` function. Given a path
    to a file, this will read and summarize the games in that file. The resulting
    summary object can then be written as part of the overall display or, in this
    case, appended to a sequence of YAML-format summaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This function determines which of the four game termination rules were applied
    to the sequence of dice rolls. It starts by opening the given source file, and
    using the `load_all()` function to iterate through all of the YAML documents.
    Each document is a single game, represented as a sequence of dice pairs.
  prefs: []
  type: TYPE_NORMAL
- en: This function uses the first (and last) rolls to determine the overall outcome
    of the game. There are four rules, which should enumerate all possible logical
    combinations of events. In the event, if there is some error in our reasoning,
    an exception will get raised to alert us to a special case that didn't fit the
    design in some way.
  prefs: []
  type: TYPE_NORMAL
- en: The game is reduced to a single event with an outcome and a length. These are
    accumulated into a `Counter` object. The outcome and length of a game are the
    two values we're computing. These are a stand-in for more complex or sophisticated
    statistical analyses that are possible.
  prefs: []
  type: TYPE_NORMAL
- en: We've carefully segregated almost all file-related considerations from this
    function. The `gather_stats()` function will work with any iterable source of
    game data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output from this application. It''s not very pretty; it''s a YAML
    document that can be used for further processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We'll need to insert logging features into all of these functions to show which
    file is being read, and any errors or problems with processing the file.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we're going to create two logs. One will have details, and the
    other will have a minimal summary of files that are created. The first log can
    go to `sys.stderr` , which will be displayed at the console when the program runs.
    The other log will be appended to a long-term `log` file to cover all uses of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: One approach to having separate needs is to create two loggers, each with a
    different intent. The two loggers will also have dramatically different configurations.
    Another approach is to create a single logger, and use a `Filter` object to distinguish
    content intended for each logger. We'll focus on creating separate loggers because
    it's easier to develop and easier to unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each logger has a variety of methods reflecting the severity of the message.
    The severity levels defined in the `logging` package include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEBUG** : These messages are not generally shown, since their intent is to
    support debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INFO** : These messages provide information on the normal, happy-path processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WARNING** : These messages indicate that processing may be compromised in
    some way. The most sensible use case for a warning is when functions or classes
    have been deprecated: they work, but they should be replaced. These messages are
    often displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ERROR** : Processing is invalid and the output is incorrect or incomplete.
    In the cases of a long-running server, an individual request may have problems,
    but the server, as a whole, can continue to operate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CRITICAL** : A more severe level of error. Generally, this is used by long-running
    servers where the server itself can no longer operate, and is about to crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method names are similar to the severity levels. We use `logging.info()`
    to write an INFO-level message.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by implementing basic logging features into the existing functions.
    This means that we''ll need the `logging` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the application will use a number of other packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We'll create two logger objects as module globals. The creating functions can
    go anywhere in the script that creates global variables. One location is to put
    these early, after the `import` statements. Another common choice is near the
    end, but outside any `__name__ == "__main__"` script processing. These variables
    must always be created, even if the module is imported as a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loggers have hierarchical names. We''ll name the loggers using the application
    name and a suffix with the content. The `overview_stats.detail` logger will have
    processing details. The `overview_stats.write` logger will identify the files
    read and the files written; this parallels the idea of an audit log because the
    file writes track state changes in the collection of output files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to configure these loggers at this time. If we do nothing more,
    the two logger objects will silently accept individual log entries, but won't
    do anything further with the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll rewrite the `main()` function to summarize the two aspects of the processing.
    This will use the `write_log` logger object to show when a new file is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We've added the `write_log.info("wrote {}".format(result_path))` line to put
    an information message into the log for files that have been written.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll rewrite the `process_all_files()` function to provide a note when a
    file is read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We've added the `detail_log.info("read {}".format(source_path))` line to put
    information messages in the detail log for every file that's read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gather_stats()` function can have a log line added to it to track normal
    operations. Additionally, we''ve added a log entry for the logic error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `detail_log` logger is used to collect debugging information. If we set
    the overall logging level to include debug messages, we'll see this additional
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_options()` function will also have a debugging line written. This
    can help diagnose problems by displaying the options into the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a simple configuration to see the log entries. This works as a first
    step to simply confirm that there are two loggers and they''re being used properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This logging configuration builds the default handler object. This object simply
    prints all of the log messages on the given stream. This handler is assigned to
    the root logger; it will apply to all children of this logger. Therefore, both
    of the loggers created in the preceding code will go to the same stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of running this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: There are two lines in the log. Both have a severity of INFO. The first line
    is from the `overview_stats.detail` logger. The second line is from the `overview_stats.write`
    logger. The default configuration sends all loggers to `sys.stdout` .
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to route the different loggers to different destinations, we''ll need
    a more sophisticated configuration than the `basicConfig()` function. We''ll use
    the `logging.config` module. The `dictConfig()` method can provide a complete
    set of configuration options. The easiest way to do this is to write the configuration
    in YAML and then convert this to an internal `dict` object using the `yaml.load()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML document is enclosed in a triple-apostrophe string. This allows us
    to write as much text as necessary. We''ve defined five things in the big block
    of text using YAML notation:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `version` key must be 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The value of the `formatters` key defines the log format. If this is not specified,
    the default format shows only the message body, without any level or logger information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` formatter defined here mirrors the format created by the `basicConfig()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `timestamp` formatter defined here is a more complex format that includes
    the date-time stamp for the record. To make the file easier to parse, a column
    separator of `//` was used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handlers` key defines the two handlers for the two loggers. The `console`
    handler writes to the stream, `sys.stderr` . We specified the formatter this handler
    will use. This definition parallels the configuration created by the `basicConfig()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `file` handler writes to a file. The default mode for opening the file
    is `a` , which will append to the file with no upper limit on the file size. There
    are other handlers that can rotate through multiple files, each of a limited size.
    We''ve provided an explicit filename, and the formatter that will put more detail
    into the file than is shown on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: The `loggers` key provides a configuration for the two loggers that the application
    will create. Any logger name that begins with `overview_stats.detail`  will be
    handled only by the console handler. Any logger name that begins with `overview_stats.write`
     will go to both the file handler and the console handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `root` key defines the top-level logger. It has a name of `''` (the empty
    string) in case we need to refer to it in code. Setting the level on the root
    logger will set the level for all of the children of this logger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the configuration to wrap the `main()` function like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This will start the logging in a known state. It will do the processing of the
    application. It will finalize all of the logging buffers and properly close any
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three parts to introducing logging into an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating logger objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing log requests near important state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the logging system as a whole
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating loggers can be done in a variety of ways. Additionally, it can also
    be ignored. As a default, we can use the `logging` module itself as a logger.
    If we use the `logging.info()` method, for example, this will implicitly use the
    root logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more common approach is to create one logger with the same name as the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: For the top-level, main script, this will have the name `"__main__"` . For imported
    modules, the name will match the module name.
  prefs: []
  type: TYPE_NORMAL
- en: In more complex applications, there will be a variety of loggers serving a variety
    of purposes. In these cases, simply naming a logger after a module may not provide
    the needed level of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two concepts that can be used to assign names to the loggers. It''s
    often best to choose one of these and stick with it throughout a large application:'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the package and module hierarchy. This means that a logger specific to
    a class might have a name like `package.module.class` . Other classes in the same
    module would share a common parent logger name. It's then possible to set the
    logging level for the the whole package, one of the specific modules, or just
    one of the classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow a hierarchy based on the audience or use case. The top-level name will
    distinguish the audience or purpose for the log. We might have top-level loggers
    with names such as `event` , `audit` , and perhaps `debug` . This way, all of
    the audit loggers will have names that start with `"audit."` . This can make it
    easy to route all loggers under a given parent to a specific handler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the recipe, we used the first style of naming. The logger names parallel
    the software architecture. Placing logging requests near all the important state
    changes should be relatively straightforward. There are a variety of interesting
    state changes that belong in a log:'
  prefs: []
  type: TYPE_NORMAL
- en: Any change to a persistent resource might be a good place to include a message
    of level INFO. Any OS change (usually to the file-system) is a candidate for logging.
    Similarly, database updates, and requests that should change the state of a web
    services should be logged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever there's a problem making a persistent state change, there should be
    a message `ERROR` . Any OS-level exceptions can be logged when they are caught
    and handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In long, complex calculations, it may be helpful to log `DEBUG` messages after
    particularly import assignment statements. In some cases, this is a hint that
    the long calculation might need to be decomposed into functions so that they can
    be tested separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change to an internal application resource deserves a `DEBUG` message so
    that object state changes can be tracked through the log.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the application enters an erroneous state. This should generally be due
    to an exception. In some cases, an `assert` statement will be used to detect the
    state of the program and raise an exception when there are problems. Some exceptions
    are logged at the `EXCEPTION` level. Some exceptions, however, only need `DEBUG`
    level messages because the exception is being silenced or transformed. Some exceptions
    may be logged at the `ERROR` or `CRITICAL` level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third aspect of logging is configuring the loggers so that they route the
    requests to the appropriate destination. By default, with no configuration at
    all, the loggers will all quietly create log events, but won't display them.
  prefs: []
  type: TYPE_NORMAL
- en: With a minimal configuration, we can see all of the log events on the console.
    This can be done with the `basicConfig()`  method and covers a large number of
    simple use cases without any real fuss. Instead of a stream, we can use filename
    to provide a named file. Perhaps the most important feature is providing a simple
    way to enable debugging by setting the logging level on the root logger from `basicConfig()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The example configuration in the recipe used two common handlers—the `StreamHandler`
    and `FileHandler` classes. There are over a dozen more handlers, each with unique
    features for gathering and publishing log messages.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Designing scripts for composition* recipe for the complementary part
    of this application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining two applications into one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition* recipe, we looked at a simple application
    that creates a collection of statistics by simulating a process. In the *Using
    logging for control and audit output* recipe, we looked at an application that
    summarizes a collection of statistics. In this recipe, we'll combine those two
    separate applications to create a single, composite application that both creates
    and summarizes the statistical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several common approaches to combining these two applications:'
  prefs: []
  type: TYPE_NORMAL
- en: A shell script can run the simulator and then run the analyzer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python program can stand in for the shell script and use the `runpy` module
    to run each program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can build a composite application from the essential features of each application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the *Designing scripts for composition* recipe, we examined three aspects
    of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Gathering input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Producing output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential processing that connects input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the recipe, we looked at a design pattern that would allow several Python
    language components to be combined into a larger application.
  prefs: []
  type: TYPE_NORMAL
- en: How can we combine applications to create a composite?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition*  and *Using logging for control and
    audit output* recipes, we followed a design pattern that separated the input gathering,
    the essential processing, and the production of output. The objective behind that
    design pattern was gathering the interesting pieces together to combine and recombine
    them into higher-level constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have a tiny mismatch between the two applications. We can borrow
    a phrase from database engineering (and also electrical engineering) and call
    this an impedance mismatch. In electrical engineering, it's a problem with circuit
    design, and it's often solved by using a device called a transformer. This can
    be used to match impedance between circuit components.
  prefs: []
  type: TYPE_NORMAL
- en: In database engineering, this kind of problem surfaces when the database has
    normalized, flat data, but the programming language uses richly structured complex
    objects. For SQL databases, this is a common problem and packages such as **SQLAlchemy**
    are used as an **Object-Relational Management** ( **ORM** ) layer. This layer
    is a transformer between flat database rows (often from multiple tables) and complex
    Python structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building a composite application, the impedance mismatch that surfaces
    in this example is a cardinal problem. The simulator is designed to run more frequently
    than the statistical summarizer. We have several choices for addressing cardinal
    issues such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Total Redesign** : This may not be a sensible alternative because the two
    component applications have an established base of users. In other cases, the
    new use cases are an opportunity to make sweeping fixes and retire some technical
    debt.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Include the Iterator** : This means that when we build the composite application,
    we''ll add a `for` statement to perform many simulation runs and then process
    this into a single summary. This parallels the original design intent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List of One** : This means that the composite application will run one simulation
    and provide this single simulation output to the summarizer. This modifies the
    structure to do more summarization; the summaries may need to be combined into
    the expected single result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice between these depends on the user story that leads to creating the
    composite application in the first place. It may also depend on the established
    base of users. For our purposes, we'll assume that the users have come to realize
    that 1,000 simulation runs of 1,000 samples is standard, and they would like to
    follow the *Include the Iterator* design to create a composite process.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, the reader should pursue the alternative design. Assume instead
    that the users would rather run 1,000,000 samples in a single simulation. For
    this, the users would prefer the summarizer work with a *List of One* design.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at another option. In this case, we'll perform 100 simulation
    runs spread over a number of concurrent worker processes. This will reduce the
    time to create a million samples. This is a variation of the *Include the Iterator*
    composite design.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Follow a design pattern that decomposes a complex process into functions that
    are independent of input or output details. See the *Designing scripts for composition*
    recipe for details on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the essential functions from the working modules. In this case, the
    two modules have the relatively uninteresting names, `ch13_r05` and `ch13_r06`
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Import any other modules required. We''ll use a `Counter`  function to prepare
    the summaries in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function that combines the existing functions from the other applications.
    The output from one function is input to another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In many cases, it makes more sense to explicitly stack the functions, creating
    intermediate results. This is particularly important when there are multiple functions
    creating a kind of map-reduce pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We've broken the processing into steps with intermediate variables. The `game_roll_history`
    variable is the output from the `roll_iter()` function. The output from this generator
    is the iterable input to the `gather_states()` function, which is saved in the
    `game_statistics` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the output-formatting functions that use this composite process. Here,
    for example, is a composite process that exercises the `summarize_games()` function.
    This also writes the output report:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Gathering command-line options can be done using the `argparse` module. There
    are examples of this in recipes including the  *Designing scripts for composition*
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central feature of this design is a separation of the various concerns of
    the application into isolated functions or classes. The two component applications
    started with a design divided up among input, process, and output concerns. Starting
    from this base made it easy to import and reuse the processing. This also left
    the two original applications in place, unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: The objective is to import functions from working modules and avoid copy and
    paste programming. Copying a function from one file and pasting it into another
    means that any change made to one is unlikely to be made to the other. The two
    copies will slowly diverge, leading to a phenomenon sometimes called *code rot*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'When a class or function does several things, the reuse potential is reduced.
    This leads to the observation of **Inverse Power Law of Reuse** —the re-usability
    of a class or function, *R(c)* , is related to the inverse of the number of features
    in that class or function, *F(c)* :'
  prefs: []
  type: TYPE_NORMAL
- en: '*R* ( *c* ) ∝ 1 / *F* ( *c* )'
  prefs: []
  type: TYPE_NORMAL
- en: A single feature aids reuse. Multiple features reduce the opportunities for
    reuse of a component.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at the two original applications from the *Designing scripts for
    composition* and *Using logging for control and audit output* recipes, we can
    see that the essential functions had few features. The `roll_iter()` function
    simulated a game, and yielded results. The `gather_stats()` function gathered
    statistics from any source of data.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of counting features depends, of course, on the level of abstraction.
    From a small-scale view, the functions do many small things. From a very large
    scale view, the functions require several helpers to form a complete application;
    from this viewpoint, an individual function is only a part of a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Our focus here is on technical features of the software. This has nothing to
    do with the agile concept of feature as a unifying concept behind multiple user
    stories. In this context, we're talking about software architecture technical
    features—input, output, processing, OS resources used, dependencies, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatically, the relevant technical features are tied to user stories. This
    puts the scale question into the realm of software properties as perceived by
    users. If the user sees more than one feature, it means that reuse may be a struggle.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, one application created files. The second application summarized
    files. Feedback from users may have revealed that the distinction was not important
    or perhaps confusing. This lead to a redesign to create a one-step operation from
    the two original steps.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at three other architectural features that can be part of the composite
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Refactoring** : The *Combining two applications into one* recipe did not
    properly distinguish between processing and output. When trying to create a composite
    application, we may need to refactor the component modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency** : Running several `roll_iter()` instances in parallel to use
    multiple cores.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging** : When multiple applications are combined, the combined logging
    can become complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, it becomes necessary to rearrange software to extract the useful
    features. In one of the components, the `ch13_r06` module, the following function
    was available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This combines source file iteration, detailed processing, and output creation
    in one place. The `result_file.write()` output processing is a single, complex
    statement that's difficult to extract from this function.
  prefs: []
  type: TYPE_NORMAL
- en: In order to reuse this feature properly between two applications, we'll need
    to refactor the `ch13_r06` application so that the file output is not buried in
    the `process_all_files()` function. In this case, the refactoring isn't too difficult.
    In some cases, the wrong abstractions are chosen, and the refactoring is extremely
    difficult.
  prefs: []
  type: TYPE_NORMAL
- en: One line of code, `result_file.write(...)` , needs to be replaced with a separate
    function. This is a small change. Details are left as an exercise for the reader.
    When defined as a separate function, it is easier to replace.
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring makes the new function available for other composite applications.
    When multiple applications share a common function, then it's much more likely
    that outputs between the applications are actually compatible.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The underlying reason for running many simulations followed by a single summary
    is a kind of map-reduce design. The detailed simulations can be run concurrently,
    using multiple cores and multiple processors. The final summary, however, needs
    to be created from all of the simulations via a statistical reduction.
  prefs: []
  type: TYPE_NORMAL
- en: We often use OS features to run multiple concurrent processes. The POSIX shells
    include the `&` operator which can be used to fork concurrent subprocesses. Windows
    has a `**start**` command, which is similar. We can leverage Python directly to
    spawn a number of concurrent sumulation processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One module for doing this is the `futures` module from the `concurrent` package.
    We can build a parallel simulation processor by creating an instance of `ProcessPoolExecutor`
    . We can submit requests to this executor and then collect the results from those
    concurrent requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve initialized three objects: `start` , `total_stats` , and `worker_list`
    . The `start` object has the time at which processing started; `time.perf_counter()`
    is often the most accurate timer available. `total_stats` is a `Counter` object
    that will collect the final statistical summary. `worker_list` will be a list
    of individual `Future` objects, one for each request that''s made.'
  prefs: []
  type: TYPE_NORMAL
- en: The `ProcessPoolExecutor`  method defines a processing context in which a pool
    of workers are available to handle requests. By default, the pool has as many
    workers as the number of processors. Each worker process is running an executor
    which imports the given module. All functions and classes defined in the module
    are available to the workers.
  prefs: []
  type: TYPE_NORMAL
- en: The `submit()` method of an executor is given a function to execute along with
    arguments to that function. In this example, there will be 100 requests made,
    each of which will simulate 1,000 games and return the sequence of dice rolls
    for those games. `submit()` returns a `Future` object, which is a model for the
    working request.
  prefs: []
  type: TYPE_NORMAL
- en: After submitting all 100 requests, the results are collected. The `result()`
    method of a `Future` object waits for the processing to finish and gathers the
    resulting object. In this example, the result is a statistical summary of 1,000
    games. These are then combined to create the overall `total_stats` summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a comparison between serial and parallel execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The processing time is cut in half. Since there are 100 concurrent requests,
    why isn't the time cut by 1/100th of the original time? The observation is that
    there is considerable overhead in spawning the subprocesses, communicating the
    request data, and communication the result data.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *Using logging for control and audit output* recipe, we looked at how
    to use the `logging` module for control, audit, and error outputs. When we build
    a composite application, we'll have to combine the logging features from each
    of the original applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logging involves a three-part recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating logger objects. This is generally a line such as `logger = logging.get_logger('some_name')`
    . It's generally done once at the class or module level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the logger objects to collect events. This involves lines such as `logger.info('some
    message')` . These lines are scattered throughout an application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configuring the logging system as a whole. There are two possibilities for
    log configuration in an application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As external as possible. In this case, the logging configuration is done only
    at the outermost, global scope of the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This guarantees that there will only be a single configuration of the logging
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhere inside a class, function, or module. In this case, we may have several
    modules that are all attempting to do logging configuration. This is tolerated
    by the logging system. It can, however, be confusing to debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These recipes all follow the first approach. If all applications configure logging
    in the most global scope, then it's easy to understand how to configure a composite
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where there are multiple logging configurations, there are two approaches
    that a composite application can follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The composite application contains a final configuration, which intentionally
    overwrites all previously-defined loggers. This is the default, and can be stated
    explicitly via `incremental: false` in a YAML configuration document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The composite application preserves other application loggers, and merely modifies
    the logger configurations, perhaps by setting the overall level. This is done
    by including `incremental: true` in the YAML configuration document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of incremental configuration is helpful when combining Python applications
    that don't isolate the logging configuration. It can take some time to read and
    understand the code from each application in order to properly configure logging
    for composite applications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition* recipe, we looked at the core design
    pattern for a composable application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining many applications using the Command design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many complex suites of applications follow a design pattern similar to the one
    used by the Git program. There's a base command, `git` , with a number of subcommands.
    For example, `git pull` , `git commit` , and `git push` .
  prefs: []
  type: TYPE_NORMAL
- en: What's central to this design is the idea of a collection of individual commands.
    Each of the various features of git can be thought of as a separate class definition
    that performs a given function.
  prefs: []
  type: TYPE_NORMAL
- en: When we enter a command such as `git pull` , it's as if the program, `git` ,
    is locating a class to implement the command.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create families of closely related commands?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll imagine an application built from three commands. This is based on the
    applications shown in the  *Designing scripts for composition* , *Using logging
    for control and audit output* , and *Combining two applications into one*  recipes.
    We'll have three applications— *simulate* , *summarize* , and a combined application
    called *simsum* .
  prefs: []
  type: TYPE_NORMAL
- en: These features are based on modules with names such as `ch13_r05` , `ch13_r06`
    , and `ch13_r07` . The idea is that we can restructure these separate modules
    into a single class hierarchy following the Command design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two key ingredients to this design:'
  prefs: []
  type: TYPE_NORMAL
- en: The client depends only on the abstract superclass, `Command` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each individual subclass of the `Command` superclass has an identical interface.
    We can substitute any one of them for any other.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we've done this, then an overall application script can create and execute
    any one of the `Command` subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The overall application will have a structure that attempts to separate the
    features into two categories—argument parsing and command execution. Each subcommand
    will include both processing and the output bundled together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the `Command` superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: We're going to rely on the `argparse.Namespace` to provide a very flexible collection
    of options to each subclass. This is not required, but will be helpful in the
    *Managing arguments and configuration in composite applications* recipe. Since
    that recipe will include option parsing, it seems best to focus each class on
    using `argparse.Namespace` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subclass of the `Command` superclass for the `Simulate` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We've wrapped the processing and output from the `ch13_r05` module into the
    `execute()` method of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subclass of the `Command` superclass for the `Summarize` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: For this class, we've wrapped the file creation and the file processing into
    the `execute()` method of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the overall processes can be performed by the following `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: We've created two commands, an instance of `Simulate` class, and an instance
    of the `Summarize` class. These can be executed to provide a combined feature
    that both simulates and summarizes data.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating interchangeable, polymorphic classes for the various subcommands is
    a handy way to provide an extensible design. The `Command` design pattern strongly
    encourages each individual subclass to have an identical signature so that any
    command can be created and executed. Also, new commands can be added that fit
    the framework.
  prefs: []
  type: TYPE_NORMAL
- en: One of the SOLID design principles is the **Liskov Substitution Principle**
    ( **LSP** ). Any of the subclasses of the `Command` abstract class can be used
    in place of the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Command` instance has a simple interface. There are two features:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` method expects a namespace object that's created by the argument
    parser. Each class will pick only the needed values from this namespace, ignoring
    any others. This allows global arguments to be ignored by a subcommand that doesn't
    require it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `execute()` method does the processing and writes any output. This is based
    entirely on the values provided during initialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the Command design pattern makes it easy to be sure that they can
    be interchanged with each other. The overall `main()` script can create instances
    of the `Simulate` or the `Summarize` class. The substitution principle means that
    either instance can be executed because the interfaces are the same. This flexibility
    makes it easy to parse the command-line options and create an instance of either
    of the available classes. We can extend this idea and create sequences of individual
    command instances.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the more common extensions to this design pattern is to provide for
    composite commands. In the *Combining two applications into one* recipe, we showed
    one way to create composites. This is another way, based on defining a new command
    that implements a combination of existing commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: This class will accept other `Command` classes via the `*commands` parameter.
    This sequence will combine all of the positional argument values. From the classes,
    it will build the individual class instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might use this `CommandSequence` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We created an instance of `CommandSequence` using two other classes—`Simulate`
    and `Summarize` . The `__init__()` method will build an internal sequence of the
    two objects. The `execute()` method of the `sim_sum_command` object will then
    perform the two processing steps in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This design, while simple, exposes many implementation details. In particular,
    the two class names, and the intermediate `x.yaml` file are details that can be
    encapsulated into a better class design.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a slightly nicer subclass of `CommandSequence`  argument if we
    focus specifically on the two commands being combined. This will have an `__init__()`
     method that follows the pattern of other `Command` subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: This class definition incorporates two other classes into the already defined
    `CommandSequence` structure. We can continue this idea by also modifying the options
    slightly to eliminate the explicit values for `game_file` output from the `Simulate`
    step, which must also be part of the `game_files` input to the `Summarize` step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to build and use a simpler `Namespace` with options like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that some missing options must be injected by the `execute()` method.
    We''ll add this method to the `SimSum` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This `execute()` method clones the options. It adds two additional values that
    are part of the integration of the commands, but not something that a user should
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: This design avoids updating the stateful set of options. In order to leave the
    original options object intact, a copy was made. The `vars()` function exposes
    the `Namespace` as a simple dict. We can then use the `**` keyword argument technique
    to make the dictionary into the keyword arguments for a new `Namespace` object.
    This will create a shallow copy. If any stateful objects within the namespace
    are updated, it will be clear that both the original `options` and `new_namespace`
     arguments have access to the same underlying value objects.
  prefs: []
  type: TYPE_NORMAL
- en: Since `new_namespace` is a distinct collection, we can add new keys and values
    to this `Namespace` instance. These will only appear in `new_namespace` , leaving
    the original options object alone.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition* , *Using logging for control and
    audit output* , and *Combining two applications into one* recipes, we looked at
    the constituent parts of this composite application. In most cases, we'll need
    to combine elements of all of these recipes to create a useful application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll often need to follow the *Managing arguments and configuration in composite
    applications* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing arguments and configuration in composite applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have a complex suite (or system) of individual applications, it's common
    for several applications to share common features. We can, of course, use ordinary
    inheritance to define a library module that provides the common classes and functions
    to each of the individual applications in a complex suite.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of creating a number of separate applications is that the external
    CLI is tied directly to the software architecture. It becomes awkward to rearrange
    the software components because changes will also alter the visible CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The coordination of common features among many application files can become
    awkward. For example, defining the various, one-letter abbreviated options for
    command-line arguments is difficult. It requires keeping some kind of master list
    of options, outside all of the individual application files. It seems like this
    should be kept in one place in the code somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Is there an alternative to inheritance? How can we assure that a suite of applications
    can be refactored without creating unexpected changes to the CLI or requiring
    complex additional design notes?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many complex suites of applications follow a design pattern similar to the one
    used by Git. There's a base command, `git` , with a number of subcommands. For
    example, `git pull` , `git commit` , and `git push` . The core of the command-line
    interface can be centralized by the `git` command. The subcommands can then be
    organized and reorganized as needed with fewer changes to the visible CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll imagine an application built from three commands. This is based on the
    applications shown in the *Designing scripts for composition* , *Using logging
    for control and audit output* , and *Combining two applications into one*  recipes.
    We''ll have three applications with three commands: `craps simulate` , `craps
    summarize` , and the combined application `craps simsum` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll rely on the subcommand design from the *Combining many applications
    using the Command design pattern* recipe. This will provide a handy hierarchy
    of `Command` subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Command` class is an abstract superclass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Simulate` subclass performs the simulation functions from the *Designing
    scripts for composition* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Summarize` subclass performs summarization functions from the *Using logging
    for control and audit output* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `SimSum` subclass can perform combined simulation and summarization, following
    the ideas of the *Combining two applications into one* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to create a simple command-line application, we'll need appropriate
    argument parsing.
  prefs: []
  type: TYPE_NORMAL
- en: This argument parsing will rely on the subcommand parsing capability of the
    `argparse` module. We can create a common set of command options that apply to
    all subcommands. We can also create unique options for each subcommand.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define the command interface. This is an exercise in **User Experience** ( **UX**
    ) design. While most UX is focused on web and mobile device applications, the
    core principles are appropriate for CLI applications and servers, as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Earlier, we noted that the root application will be `craps` . It will have
    the following three subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Define the root Python application. Consistent with other files in this book,
    we'll call it `ch13_r08.py` . At the OS level, we can provide an alias or a link
    to make the visible interface match the user expectation of `craps` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll import the class definitions from the *Combining many applications using
    the Command design pattern* recipe. This will include the `Command` superclass
    and the `Simulate` , `Summarize` , and `SimSum` subclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the overall argument parser then create a subparser builder. The `subparsers`
    object will be used to create each subcommand''s argument definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: For each command, create a parser and add arguments that are unique to that
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `simulate` command with the two options that are unique to simulation.
    We''ll also provide a special default value that will initialize the resulting
    `Namespace` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `summarize` command, with the arguments unique to this command.
    Provide the default value that will populate the `Namespace` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `simsum` command, and similarly, provide a unique default value
    that makes processing the `Namespace` easier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Parse the command-line values. In this case the overall argument to the `get_options()`
    function is expected to be the value of `sys.argv[1:]` , which includes the arguments
    to the Python command. We can override the argument value for testing purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The overall parser includes three subcommand parsers. One will handle the `craps
    simulate` command, another handles `craps summarize` , and the third handles `craps
    simsum` . Each subcommand has slightly different combinations of options.
  prefs: []
  type: TYPE_NORMAL
- en: The `command` option is set only via the `set_defaults()` method. This sends
    useful, additional information about the command to be executed. In this case,
    we've provided the class that must be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall application is defined by the following `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The options will be parsed. Each distinct subcommand sets a unique class value
    for the `options.command`  argument. This class is used to build an instance of
    a `Command` subclass. This object will have an `execute()` method that does the
    real work of this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the OS wrapper for the root command. We might have a file named `craps`
    . The file would have rx permissions so that it was readable by other users. The
    content of the file could be this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: This small shell script provides a handy way to enter a command of `**craps**`
    and have it properly execute a Python script with a different name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a bash shell alias like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: This can be placed in a `.bashrc` file to define a `**craps**` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two parts to this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Command` design pattern to define a related set of classes that are
    polymorphic. For more information on this, see the *Combining many applications
    using the Command design pattern* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using features of the `argparse` module to handle subcommands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `argparse` module feature that's important here is the `add_subparsers()`
    method of a parser. This method returns an object that is used to build each distinct
    subcommand parser. We assigned this object to the variable `subparsers` .
  prefs: []
  type: TYPE_NORMAL
- en: We also defined a simple `command` argument in the top-level parser. This argument
    can only be filled by the defaults defined for each of the sub-parsers. This provides
    a value that shows which of the subcommands was actually invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Each sub-parser is built using the `add_parser()` method of the sub-parsers
    object. The `parser` object that is returned can then have arguments and defaults
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: When the overall parser is executed, it will parse any arguments defined outside
    the subcommands. If there's a subcommand, this is used to determine how to parse
    the remaining arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will be parsed to create a `Namespace` object that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The `command` attribute in the `Namespace` object is the default value provided
    as part of the subcommand definition. The values for `game_file` and `games` come
    from the `-o` and `-g` options.
  prefs: []
  type: TYPE_NORMAL
- en: The Command design pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating interchangeable, polymorphic classes for the various subcommands creates
    a design that's easily refactored or expanded. The `Command` design pattern strongly
    encourages each individual subclass to have an identical signature so that any
    one of the available command classes can be created and executed.
  prefs: []
  type: TYPE_NORMAL
- en: One of the SOLID design principles is the Liskov Substitution Principle. Any
    of the subclasses of the Command abstract class can be used in place of the parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each `Command` has a consistent interface:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` method expects a namespace object that's created by the argument
    parser. Each class will pick only the needed values from this namespace, ignoring
    any others. This allows global arguments to be ignored by a subcommand that doesn't
    require it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `execute()` method does the processing and writes any output. This is based
    entirely on the values provided during initialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the Command design pattern makes it easy to ensure that they can
    be interchanged with each other. The substitution principle means that the `main()`
    function can simply create an instance and then execute the `execute()` method
    of the object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can consider pushing the subcommand parser details down into each class
    definition. For example, the `Simulate` class defines two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't seem appropriate for the `get_option()` function to define these
    details about the implementation class. It seems like a properly encapsulated
    design would allocate this detail to each `Command` subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would need to add a static method that configures a given parser. The new
    class definitions would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added a `configure()` method to configure a parser. This change makes
    it very easy to see how the `__init__()` arguments will be created by parsing
    the command-line values. This allows us to rewrite the `get_option()` function,
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: This will leverage the static `configure()` method to provide the parameter
    details. The default value for the command argument can be handled by the overall
    `get_options()` because it doesn't involve internal details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the  *Designing scripts for composition* , *Using logging for control and
    audit output* , and *Combining two applications into one*  recipes for background
    on the components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the *Using argparse to get command-line input* recipe in [Chapter 5](text00063.html#page
    "Chapter 5. User Inputs and Outputs") , *User Inputs and Outputs* , for more background
    in argument parsing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping and combining CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common kind of automation involves running several programs, none of which
    are actually Python applications. Since the programs aren't written in Python,
    it's impossible to rewrite each program to create a composite Python application.
    We can't follow the *Combining two applications into one* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of aggregating the functionality, the alternative is to wrap the other
    programs in Python to provide a higher level construct. The use case is very similar
    to the use case for writing a shell script. The difference is that Python is used
    instead of the shell language. Using Python has some advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Python has a rich collection of data structures. The shell only has strings
    and arrays of strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has an outstanding unit test framework. This provides confidence that
    the Python version of a shell script works without the risk of crashing a widely-used
    service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we run other applications from within Python?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition* recipe, we identified an application
    that did some processing leading to the creation of a rather complex result. For
    the purposes of this recipe, we'll assume that the application is not written
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: We'd like to run this program several hundred times, but we don't want to copy
    and paste the necessary commands into a script. Also, because the shell is difficult
    to test and has so few data structures, we'd like to avoid using the shell.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll assume that the `ch13_r05` application is a native binary
    application; it might have been written in C++ or Fortran. This means that we
    can't simply import the Python module that comprises the application. Instead,
    we'll have to process this application by running a separate OS process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `subprocess` module to run an application program at the OS
    level. There are two common use cases for running another binary program from
    within Python:'
  prefs: []
  type: TYPE_NORMAL
- en: There isn't any output, or we don't want to gather it in our Python program.
    The first situation is typical of OS utilities that return a status code when
    they succeed or fail. The second situation is typical where many child programs
    are all writing to the standard error logs; the parent Python program is merely
    starting a child processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to capture and possibly analyze the output to retrieve information or
    ascertain the level of success.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we'll look at the first case—the output isn't something we need
    to capture. In the *Wrapping a program and checking the output* recipe, we'll
    look at the second case, where the output is scrutinized by the Python wrapper
    program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `subprocess` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Design the command line. Generally, this should be tested at the OS prompt
    to be sure that it does the right things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The output filename needs to be flexible, so that we can run the program hundreds
    of times. This means creating files with names such as `game_{n}.yaml` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a statement that iterates through the appropriate commands. Each command
    can be built as a sequence of individual words. Start with the working shell command
    and split that line on the spaces to create a proper sequence of words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This will create the various commands. We can use a `print()` function to show
    each command and confirm that the filenames are defined properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Evaluate the `run()` function from the `subprocess` module. This will execute
    the given command. Provide `check=True` so that if there''s any problem, it will
    raise a `subprocess.CalledProcessError` exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: In order to test this properly, the entire sequence should be transformed into
    a proper function. If there will be more, related commands in the future, it should
    be a method of a subclass in a `Command` class hierarchy. See the *Managing arguments
    and configuration in composite applications* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `subprocess` module is how Python programs run other programs available
    on a given computer. The `run()` function, does a number of things for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a POSIX (such as Linux or Mac OS X) context, the steps are similar to the
    following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the `stdin` , `stdout` , and `stderr` file descriptors for the child
    process. In this case, we've accepted the defaults, which means that the child
    inherits the files being used by the parent. If the child process prints to `stdout`
    , it will appear on the same console being used by the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the `os.fork()` function to split the current process into a parent and
    a child. The parent will be given the process ID of the child; it can then wait
    for the child to finish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the child, execute the `os.execl()` function (or a similar function) to provide
    the command path and arguments that will be executed by the child.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The child process then runs, using the given `stdin` , `stdout` , and `stderr`
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent, meanwhile, uses a function such as `os.wait()` to wait for the child
    to finish and return the final status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we used the `check=True` option, a non-zero status is transformed into
    an exception by the `run()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OS shell, such as bash, conceals these details from application developers.
    The `subprocess.run()` function, similarly, hides the details of creating and
    waiting for a child process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python, with the `subprocess` module, offers many features similar to the shell.
    Most importantly, Python offers several additional sets of features:'
  prefs: []
  type: TYPE_NORMAL
- en: A much richer collection of data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions to identify problems that arise. This is much simpler and more reliable
    than inserting `if` statements throughout a shell script to check status codes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to unit test the script without using OS resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll add a simple cleanup feature to this script. The idea is that all of the
    output files should be created as an atomic operation. We want all of the files,
    or none of the files. We don't want an incomplete collection of data files.
  prefs: []
  type: TYPE_NORMAL
- en: 'This fits with the ACID properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity** : The entire set of data is available or it is not available.
    The collection is a single, indivisible unit of work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency** : The file-system should move from one internally consistent
    state to another consistent state. Any summaries or indices will properly reflect
    the actual files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation** : If we want to process data concurrently, then having multiple,
    parallel processes should work. Concurrent operations should not interfere with
    each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability** : Once the files are written, they should remain on the file-system.
    This property almost goes without saying for files. For more complex databases,
    it becomes necessary to consider transaction data that might be acknowledged by
    a database client, but not actually written yet to a server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these features are relatively simple to achieve using OS processes with
    separate working directories. The atomicity property, however, leads to a need
    for a cleanup operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to clean up, we''ll need to wrap the core processing with a `try:`
     block. The overall function would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The exception-handling block does two things. First, it removes any incomplete
    files from the current working directory. Second, it re-raises the original exception
    so that the failure will propagate to the client application.
  prefs: []
  type: TYPE_NORMAL
- en: Since the processing has failed, it's important to raise an exception. In some
    cases, an application may define a new exception, unique to this application.
    That new exception can be raised instead, re-raising the original `CalledProcessError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to unit test this, we'll need to mock two external objects. We need
    a mock for the `run()` function in the `subprocess` module. We don't want to actually
    run the other process, but we want to be sure that the `run()` function is called
    appropriately from the `make_files()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to mock the `Path` class and the resulting `Path` object. These
    provide the filenames, and will have the `unlink()` method called. We need to
    create mocks for this so that we can be sure only the appropriate files will be
    unlinked by the real application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with mock objects means that we never run the risk of accidentally deleting
    useful files when testing. This is a significant benefit of using Python for this
    kind of automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the setup where we define the various mock objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We've defined `self.mock_subprocess_run` , which will behave somewhat like the
    `run()` function. We've used the `side_effect` attribute to provide multiple return
    values for this function. The first response will be the `None` object. The second
    response, however, will be a `CalledProcessError` exception. This exception requires
    two arguments, a process return code, and the original command.
  prefs: []
  type: TYPE_NORMAL
- en: The `self.mock_path_class` , shown last, responds to calls to the `Path` class
    requests. This will return a mocked instance of the class. The `self.mock_path_instance`
    object is the mock instance of `Path` .
  prefs: []
  type: TYPE_NORMAL
- en: The first path instance that's created will have the `glob()` method evaluated.
    For this, we've used the `return_value` attribute to return a list of `Path` instances
    to be deleted. In this case, the return value will be a single `Path` object that
    we expect to be unlinked.
  prefs: []
  type: TYPE_NORMAL
- en: The `self.mock_path_glob_instance` object is the return from `glob()` . This
    should be unlinked if the algorithm operates correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `runTest()` method for this unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve applied two patches:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `__main__` module, a reference to `subprocess` will have the `run()`
    function replaced with the `self.mock_subprocess_run` object. This will allow
    us to track how many times `run()` is called. It will allow us to confirm that
    `run()` is called with the correct arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `__main__` module, the reference to `Path` will be replaced with the
    `self.mock_path_class` object. This will both return known values, and allow us
    to confirm that only the expected calls were made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.assertRaises`  method is used to confirm that a `CalledProcessError`
    exception is properly raised when `make_files()`  method is called in this particular
    patched context. The mocked version of `run()`  method will raise an exception—we
    expect that exact exception to be the one that stops processing.
  prefs: []
  type: TYPE_NORMAL
- en: The mocked `run()` function be called just two times. The first call will succeed.
    The second call will raise an exception. We can confirm that there are exactly
    two calls to `run()` using the `call_count` attribute of a `Mock` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `self.mock_path_instance`  method is a mock for the `Path('.')` object that's
    created as part of exception handling. This object must have the `glob()` method
    evaluated. The test assertion checks the argument value to be sure that `'game_*.yaml'`
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `self.mock_path_glob_instance` is a mock for the `Path` object
    created by `Path('.').glob('game_*.yaml')` . This object will have the `unlink()`
    method evaluated. This will result in deleting the file.
  prefs: []
  type: TYPE_NORMAL
- en: This unit test provides confidence that the algorithm will work as advertised.
    The testing is done without tying up a lot of compute resources. Most importantly,
    the testing is done without accidentally deleting the wrong files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This kind of automation is often combined with other Python processing. See
    the *Designing scripts for composition* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is often to create a composite application; see the *Managing arguments
    and configuration in composite applications* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a variation on this recipe, see the  *Wrapping a program and checking the
    output* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping a program and checking the output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common kind of automation involves running several programs, none of which
    are actually Python applications. In this case, it's impossible to rewrite each
    program to create a composite Python application. In order to properly aggregate
    the functionality, the other programs must be wrapped as a Python class or module
    to provide a higher level construct.
  prefs: []
  type: TYPE_NORMAL
- en: The use case for this is very similar to the use case for writing a shell script.
    The difference is that Python can be a better programming language than the OS's
    built-in shell languages.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the advantage Python offers is the ability to analyze the output
    files. A Python program might transform, filter, or summarize the output from
    a subprocess.
  prefs: []
  type: TYPE_NORMAL
- en: How do we run other applications from within Python and process their output?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition* recipe, we identified an application
    that did some processing, leading to the creation of a rather complex result.
    We'd like to run this program several hundred times, but we don't want to copy
    and paste the necessary commands into a script. Also, because the shell is difficult
    to test and has so few data structures, we'd like to avoid using the shell.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll assume that the `ch13_r05` application is a native binary
    application written in Fortran or C++. This means that we can't simply import
    the Python module that comprises the application. Instead, we'll have to process
    this application by running a separate OS process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `subprocess` module to run an application program at the OS
    level. There are two common use cases for running another binary program from
    within Python:'
  prefs: []
  type: TYPE_NORMAL
- en: There isn't any output, or we don't want to gather it in our Python program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to capture and possibly analyze the output to retrieve information or
    ascertain the level of success. We might need to transform, filter, or summarize
    the log output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we'll look at the second case—the output must be captured and
    summarized. In the *Wrapping and combining CLI applications* recipe, we'll look
    at the first case, where the output is simply ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of running the `ch13_r05` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: There are two lines of output that are written to the OS standard output file.
    The first has a summary of the options. The second line of output is a `Counter`
    object with a summary of the file. We want to capture the details of these `'Counter'`
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import the `subprocess` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Design the command line. Generally, this should be tested at the OS prompt to
    be sure that it does the right things. We've shown an example of the command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a generator for the various commands to be executed. Each command can
    be built as a sequence of individual words. The original shell command is split
    on spaces to create the sequence of words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: This generator will yield a sequence of command strings. A client can use a
    `for` statement to consume each of the generated commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a function which executes the various commands, collecting the output
    from each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Using the argument value of `stdout=subprocess.PIPE` means that the parent process
    will collect the output from the child. An OS-level pipe is created so that the
    child output can be read by the parent.
  prefs: []
  type: TYPE_NORMAL
- en: This generator will yield a sequence of lists of lines. Each list of lines will
    be the output lines from the `ch13_r05.py` application. There will, generally,
    be two lines in each list. The first line is the argument summary, and the second
    line is the `Counter` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an overall process to combine the two generators so that each command
    that is generated is then executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The `command_sequence` variable is a generator that will produce a number of
    commands. This sequence is built by the `command_iter()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `output_lines_sequence` is a generator that will produce a number of lists
    of output lines. This is is built by the `command_output_iter()` function, which
    will use the given `command_sequence object` , runs a number of commands, collecting
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: Each batch in `output_lines_sequence` will be a list of, ideally, two lines.
    The line that begins with `Counter`  has the representation of a `Counter` object.
  prefs: []
  type: TYPE_NORMAL
- en: We've used the `eval()` function to recreate the original `Counter` object from
    this text representation. We can use these `Counter` objects for analysis or summarization.
  prefs: []
  type: TYPE_NORMAL
- en: Most practical applications will have to use a function that's more complex
    than the built-in `eval()` to interpret output. For information on processing
    complex line formats, see the *String parsing with regular expressions* in [Chapter
    1](text00014.html#page "Chapter 1. Numbers, Strings, and Tuples") , *Numbers,
    Strings, and Tuples* , and *Reading complex formats using regular expressions*
    recipe in [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format,
    and Logical Layout") , *Input/Output, Physical Format, and Logical Layout* .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `subprocess` module is how Python programs run other programs available
    on a given computer. The `run()` function, does a number of things for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a POSIX (such as Linux or Mac OS X) context, the steps are similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the `stdin` , `stdout` , and `stderr` files descriptors for the child
    process. In this case, we've arranged for the parent to collect output from the
    child. The child will produce `stdout`  file to a shared buffer (a pipe in Linux
    parlance) that is consumed by the parent. The `stderr` output, on the other hand,
    is left alone—the child inherits the same connection the parent has, and error
    messages will be displayed on the same console being used by the parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the `os.fork()` and `os.execl()` functions to split the current process
    into parent and child, and then start the child process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The child process then runs, using the given `stdin` , `stdout` , and `stderr`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parent, meanwhile, is reading from the child's pipe while waiting for the
    child process to finish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we used the `check=True` option, a non-zero status is transformed into
    an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll add a simple summarization feature to this script. Each individual batch
    of samples produces two lines of output. The output text is split into a sequence
    of two lines by the expression `list(l.strip() for l in output_bytes.splitlines())`
    . This splits text into lines and also strips leading and trailing spaces from
    each line, leaving text that's slightly easier to process.
  prefs: []
  type: TYPE_NORMAL
- en: The overall script filtered these lines, looking for the line that started with
    `'Counter'` . Each of these lines is a text representation of a `Counter` object.
    Using the `eval()` function on the line will rebuild a copy of that original `Counter`
    . Many Python class definitions work like this—the `repr()` and `eval()` functions
    are inverses of each other. The `repr()` function transforms an object to text,
    and the `eval()` function can convert the text back to an object. This isn't true
    for all classes, but it is true for many.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a summary of the various `Counter` objects. In order to do this,
    it helps to have a generator that will process the batches and yield the final
    summaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This will create the processing commands with the `command_iter()` function.
    The `command_output_iter()` will process each individual command, collecting the
    entire set of output lines.
  prefs: []
  type: TYPE_NORMAL
- en: The nested `for` statements will examine each batch's list of lines. Within
    each list, it will examine each line. The line that starts with `Counter`  will
    be evaluated with the `eval()` function. The resulting sequence of `Counter` objects
    is the output from this generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a process like this to summarize the sequence of `Counter` instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: We'll create `Counter` to hold the grand total, `total_counter` . The `process_batches()`
    will yield individual `Counter` instances from each file that's processed. These
    batch-level objects are used to update the `total_counter` . We can then print
    the grand total to show the aggregate distribution of data in all of the files
    created.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Wrapping and combining CLI applications* recipe for another approach
    to this recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This kind of automation is often combined with other Python processing. See
    the *Designing scripts for composition* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is often to create a composite application; see the *Managing arguments
    and configuration in composite applications* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Controlling complex sequences of steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Combining two applications into one* recipe, we looked at ways to combine
    multiple Python scripts into a single, longer, more complex operation. In the
    *Wrapping and combining CLI applications* and *Wrapping a program and checking
    the output* recipes, we looked at ways to use Python to wrap non-Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: How can we combine these techniques effectively? Can we create longer, more
    complex sequences of operations using Python?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing scripts for composition* recipe, we created application that
    did some processing that lead to the creation of a rather complex result. In the
    *Using logging for control and audit output* recipe, we looked at a second application
    that built on those results to create a sophisticated statistical summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall process looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the `ch13_r05` program 100 times to create 100 intermediate files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `ch13_r06` program to summarize those intermediate files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've kept this simple so that it's easy to focus on the Python programming
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of this recipe, we'll assume that neither of these applications
    is written in Python. We'll pretend that they're written in Fortran or Ada or
    some other language that's not directly compatible with Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Combining two applications into one* recipe, we looked at how we can
    combine Python applications. When the applications are written in Python, this
    is the preferred approach. When applications are not written in Python, some additional
    work is required.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe uses the Command design pattern; this supports the expansion and
    modification of the sequences of commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll define an abstract `Command` class. The other commands will be defined
    as subclasses. We''ll push the subprocess processing into this class definition
    to simplify the subclasses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The `execute()` method works by first creating the OS-level command to execute.
    Each subclass will provide distinct rules for the commands which are wrapped.
    Once the command has been built, then the `run()` function of the `subprocess`
    module will process this command.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_command()` method builds the sequence of words that comprise the
    command to be executed by the OS. The options, generally, will be used to customize
    the command arguments that are created. The superclass implementation of this
    method provides some debugging information. Each subclass must override this method
    to produce useful output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `Command` superclass to define a command to simulate the game
    and create samples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we provided an override for the `execute()` method so that this
    class could change the environment variables. This allows an integration test
    to set a specific random seed and confirm that the results match a fixed set of
    expected values.
  prefs: []
  type: TYPE_NORMAL
- en: The `create_command()` method emits the words for a command-line execution of
    the `ch13_r05` command. This converts the numeric value of `options.samples` to
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `Command` superclass to define a command to summarize the
    various simulation processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we only implemented `create_command()` . This implementation provides
    the arguments for the `ch13_r06` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these two commands, the overall main program can follow the design pattern
    from the *Designing scripts for composition* recipe. We need to gather the options,
    and then use these options to execute the two commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: This demonstration function, `demo()` , creates a `Namespace` instance with
    the parameters that could have come from the command line. It builds the two processing
    steps. Finally, it executes each step.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of function provides a high-level script for executing a sequence
    of applications. It's considerably more flexible than the shell, because we can
    make use of Python's rich collection of data structures. Because we're using Python,
    we can include unit tests as well.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two interlocking design patterns in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Command` class hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping external commands by using the `subprocess.run()` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea behind a `Command` class hierarchy is to make each separate step or
    operation into a subclass of a common, abstract superclass. In this case, we've
    called that superclass `Command` . The two operations are subclasses of the `Command`
    class. This assures that we can provide common features to all of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping external commands has several considerations. One primary question
    is how to build the command-line options that are required. In this case, the
    `run()` function will use a list of individual words, making it very easy to combine
    literal strings, filenames, and numeric values into a valid set of options for
    a program. The other primary question is how to handle the OS-defined standard
    input, standard output, and standard error files. In some cases, these files can
    be displayed on the console. In other cases, the application might capture those
    files for further analysis and processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential idea here is to separate two considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: The overview of the commands to be executed. This includes questions about sequence,
    iteration, conditional processing, and potential changes to the sequence. These
    are higher-level considerations related to the user stories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The details of how to execute each command. This includes command-line options,
    output files used, and other OS-level considerations. These are more technical
    considerations of the implementation details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Separating the two makes it easier to implement or modify the user stories.
    Changes to the OS-level considerations should not alter the user stories; the
    process might be faster or use less memory, but is otherwise identical. Similarly,
    changes to the user stories should not break the OS-level considerations.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A complex sequence of steps can involve iteration of one or more steps. Since
    the high-level script is written in Python, adding iteration is done with the
    `for` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This `process_i()` function will process the `Simulate` step many times. It
    uses the `simulations` option to specify how many simulations to run. Each simulation
    will produce the expected number of samples.
  prefs: []
  type: TYPE_NORMAL
- en: This function will set a distinct value for the `game_file` option for each
    iteration of the processing. Each of the resulting filenames will be unique, leading
    to a number of sample files. The list of files is also collected into the `game_files`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: When the next step, the `Summarize` class, is executed, it will have the proper
    list of files to process. The `Namespace` object, assigned to the `options` variable,
    can be used to track global state changes and provide this information to subsequent
    processing steps.
  prefs: []
  type: TYPE_NORMAL
- en: Building conditional processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the high-level programming is written in Python, it's quite easy to add
    additional processing that isn't based on the two applications that are wrapped.
    One feature might be an optional summarization step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the options do not have a `summary_file` option, then the processing
    can be skipped. This might lead to a version of the `process()` function that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: This `procees_c()` function will process the `Summarize` step conditionally.
    If there is a `summary_file` option, it will execute the second step. Otherwise,
    it will skip the summary step.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, and the previous example, we've used Python programming features
    to augment the two application programs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, these kinds of processing steps are done for larger or more complex
    applications. See the  *Combining two applications into one* and *Managing arguments
    and configuration in composite applications for more* recipes that work with larger
    and more complex composite applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
