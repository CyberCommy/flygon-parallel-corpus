- en: Using Command-Line and GUI Tools to Learn How MQTT Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with command-line and GUI tools to learn how
    MQTT 3.1.1 works in detail. We will learn MQTT basics, the specific vocabulary
    for MQTT, and its working modes. We will use different utilities and diagrams
    to understand the most important concepts related to MQTT. We will understand
    everything we need to know before writing Python code to work with the MQTT protocol.
    We will work with the different Quality of Service (QoS) levels and we will analyze
    and compare their overheads. We will gain an understanding of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to topics with a command-line tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to topics with a GUI tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages with a command-line tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing messages with a GUI tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribing from topics with a GUI tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning best practices for topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding MQTT wildcards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the different quality of service levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with at least once delivery (QoS level 1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with exactly once delivery (QoS level 2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding overheads in the different quality of service levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to topics with a command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A drone is an IoT device that interacts with many sensors and actuators, including
    digital electronic speed controllers linked to engines, propellers, and servomotors.
    A drone is also known as an **unmanned aerial vehicle** (**UAV**), but we will
    definitely refer to it as a drone. Let''s imagine that we have to monitor many
    drones. Specifically, we have to display their altitude and the speed for each
    of their servomotors. Not all of the drones have the same number of engines, propellers,
    and servomotors. We have to monitor the following types of drone:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Number of propellers** |'
  prefs: []
  type: TYPE_TB
- en: '| Quadcopter | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| Hexacopter | `6` |'
  prefs: []
  type: TYPE_TB
- en: '| Octocopter | `8` |'
  prefs: []
  type: TYPE_TB
- en: 'Each drone will publish its altitude every 2 seconds to the following topic:
    `sensors/dronename/altitude`, where `dronename` must be replaced by the name assigned
    to each drone. For example, the drone named `octocopter01` will publish its altitude
    values to the `sensors/octocopter01/altitude` topic and the drone named `quadcopter20`
    will use the `sensors/quadcopter20/altitude` topic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, each drone will publish the speed for each of its rotors every
    2 seconds to the following topic: `sensors/dronename/speed/rotor/rotornumber`,
    where `dronename` must be replaced by the name assigned to each drone and `rotornumber`
    must be replaced by the rotor number for which the speed is going to be published.
    For example, the drone named `octocopter01` will publish its speed values for
    its rotor number `1` to the `sensors/octocopter01/speed/rotor/1` topic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `mosquitto_sub` command-line utility included in Mosquitto
    to generate a simple MQTT client that subscribes to a topic and prints all the
    messages it receives. Open a Terminal in macOS or Linux, or a Command Prompt in
    Windows, go to the directory in which Mosquitto is installed, and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you want to work with Windows PowerShell instead of the Command Prompt, you
    will have to add `.\` as a prefix to `mosquitto_sub`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous command will create an MQTT client that will establish a connection
    with the local MQTT server and then will make the client subscribe to the topic
    specified after the `-t` option: `sensors/octocopter01/altitude`. We specify the
    version of the MQTT protocol that we want to use when the client establishes the
    connection with `-V mqttv311`. This way, we indicate to the MQTT server that we
    want to use MQTT version 3.11\. We specify the `-d` option to enable debug messages
    that will allow us to understand what happens under the hood. We will analyze
    additional options for connection and subscription later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terminal or Command Prompt window will display debug messages similar to
    the following lines. Take into account that the generated `ClientId` will be different
    from the one shown after `Client mosqsub|17040-LAPTOP-5D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The Terminal or Command Prompt window will display messages published to the
    topic to which we subscribed as they arrive from the MQTT server to the MQTT client.
    Keep the window open. You will see that that the client sends `PINGREQ` packets
    to the MQTT server and receives `PINQRESP` packets from the MQTT server. The following
    lines show examples of the messages displayed for these packets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Subscribing to topics with a GUI tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MQTT.fx is a GUI utility implemented with JavaFX that is available for Windows,
    Linux, and macOS. This tool allows us to connect with an MQTT server, subscribe
    to topic filters, see received messages, and publish messages to topics. You can
    download the appropriate version for your operating system from the downloads
    section of the main web page for this utility: [http://www.mqttfx.org](http://www.mqttfx.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will use the MQTT.fx GUI utility to generate another MQTT client that
    subscribes to the same topic, `sensors/octocopter01/altitude`, and displays all
    the messages it receives. We will work with MQTT.fx version 1.6.0\. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch MQTT.fx, select local mosquitto in the dropdown located at the upper-left
    corner, and click on the configuration icon at the right-hand side of this dropdown
    and at the left-hand side of the Connect button. MQTT.fx will display the Edit
    Connection Profiles dialog box with different options for the connection profile
    named local mosquitto. We analyzed many of these options when we learned about
    the data that the MQTT client sends to the MQTT server to establish a connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the General button is pressed and make sure the MQTT Version Use
    Default checkbox is deactivated. Make sure 3.1.1 is selected in the dropdown below
    MQTT Version. This way, we tell the MQTT server that we want to use MQTT version
    3.11\. Notice that the Client ID textbox specifies MQTT_FX_Client. This is the
    `ClientId` value that MQTT.fx will send to the MQTT server (Mosquitto) in the
    `CONNECT` control packet. The following screenshot shows a dialog box with the
    selected options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a4b11c12-4981-4425-9cb3-08a384726ce2.png)'
  prefs: []
  type: TYPE_IMG
- en: Click OK and then click on the Connect button. MQTT.fx will establish a connection
    with the local Mosquitto server. Notice that the Connect button is disabled and
    the Disconnect button is enabled because the client is connected to the MQTT server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click Subscribe and enter `sensors/octocopter01/altitude` in the dropdown at
    the left-hand side of the Subscribe button. Then, click the Subscribe button.
    MQTT.fx will display a new panel at the left-hand side with the topic to which
    we have subscribed, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/21f54e53-245a-4d99-abf6-d0bcd2f5d256.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t want to work with the MQTT.fx utility, you can run another `mosquitto_sub`
    command to generate another MQTT client that subscribes to the topic and print
    all the messages it receives. You just need to open another Terminal in macOS
    or Linux, or another Command Prompt in Windows, go to the directory in which Mosquitto
    is installed, and run the following command again. In this case, it isn''t necessary
    to specify the `-d` option as given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two MQTT clients subscribed to the same topic: `sensors/octocopter01/altitude`.
    Now, we will understand what happens under the hood when a client subscribes to
    a topic.'
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT client sends a `SUBSCRIBE` packet to the MQTT server with a packet
    identifier (`PacketId`) in the header and one or more topic filters with their
    desired quality of service level in the payload.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quality of service** is known as **QoS**.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, a single `SUBSCRIBE` packet can ask the MQTT server to subscribe a client
    to many topics. The `SUBSCRIBE` packet must include at least one topic filter
    and a QoS pair to comply with the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the two cases in which we requested a subscription, we used a specific topic
    name as the value for the topic filter, and therefore we request the MQTT server
    to subscribe to a single topic. We will learn about the use of wildcards in topic
    filters later.
  prefs: []
  type: TYPE_NORMAL
- en: We used the default options, and therefore the quality of service requested
    is the default level of 0\. We will dive deep into QoS levels later. Now, we will
    stay focused on the simplest subscription cases. If the QoS level is equal to
    0, the value for the `PacketId` field will be 0\. If the QoS level is equal to
    1 or 2, the packet identifier will have a number value to identify the packet
    and make it possible to identify the responses related to this packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MQTT server will process a valid `SUBSCRIBE` packet and it will respond
    with a `SUBACK` packet that indicates the subscribe acknowledgment and confirms
    the receipt and processing of the `SUBSCRIBE` packet. The `SUBACK` packet will
    include the same packet identifier (`PacketId`) in the header that was received
    in the `SUBSCRIBE` packet. The `SUBACK` packet will include one return code for
    each pair of a topic filter and the desired QoS level received in the `SUBSCRIBE`
    packet. The number of return codes will match the number of topic filters included
    in the `SUBSCRIBE` packet. The following table shows the possible values for these
    return codes. The first three return codes indicate a successful subscription
    and each value specifies the maximum QoS that can be delivered based on the requested
    QoS and the possibilities that the MQTT server has to grant the requested QoS:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ReturnCode value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Successfully subscribed with a maximum QoS of 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | Successfully subscribed with a maximum QoS of 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | Successfully subscribed with a maximum QoS of 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `128` | Failed to subscribe |'
  prefs: []
  type: TYPE_TB
- en: If the subscription was successful, the MQTT server will start sending every
    published message that matches the topic filters specified in the subscription
    to the MQTT client with the QoS specified in the return code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between an MQTT client and an MQTT
    server to subscribe to one or many topic filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/62ac841c-d673-4f39-9f9e-1e5b93dd0866.png)'
  prefs: []
  type: TYPE_IMG
- en: Publishing messages with a command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `mosquitto_pub` command-line utility included in Mosquitto
    to generate a simple MQTT client that publishes a message to a topic. Open a Terminal
    in macOS or Linux, or a Command Prompt in Windows, go to the directory in which
    Mosquitto is installed, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will create an MQTT client that will establish a connection
    with the local MQTT server and then will make the client publish a message to
    the topic specified after the `-t` option: `sensors/octocopter01/altitude`. We
    specify the payload for the message after the `-m` option: `"25 f"`. We specify
    the version of the MQTT protocol that we want to use when the client establishes
    the connection with `-V mqttv311`. This way, we indicate to the MQTT server that
    we want to use MQTT version 3.11\. We specify the `-d` option to enable debug
    messages that will allow us to understand what happens under the hood. We will
    analyze additional options for connection and publication later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terminal or Command Prompt window will display debug messages similar to
    the following lines. Take into account that the generated `ClientId` will be different
    from the one shown after `Client mosqpub|17912-LAPTOP-5D`. After publishing the
    message, the client disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Publishing messages with a GUI tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will use the MQTT.fx GUI utility to generate another MQTT client that
    publishes another message to the same topic, sensors/octocopter01/altitude. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the MQTT.fx window in which you established a connection and subscribed
    to a topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Publish and enter `sensors/octocopter01/altitude` in the dropdown at the
    left-hand side of the Publish button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following text in the textbox below the Publish button: `32 f`, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/755c6b63-1d41-4e44-baf3-f76cd78e484f.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, click the Publish button. MQTT.fx will publish the entered text to the
    specified topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don''t want to work with the MQTT.fx utility, you can run another `mosquitto_pub`
    command to generate another MQTT client that publishes a message to the topic.
    You just need to open another Terminal in macOS or Linux, or another Command Prompt
    in Windows, go to the directory in which Mosquitto is installed, and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go back to the Terminal or Command Prompt window in which you executed
    the `mosquitto_sub` command and subscribed to the `sensors/octocopter01/atitude`
    topic. You will see lines similar to the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we clean up debug messages that start with the Client prefix, we will see
    just the next two lines. These lines show the payloads for the two messages that
    we received as a result of our subscription to the `sensors/octocopter01/altitude`
    topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the MQTT.fx window and click Subscribe. You will see 2 at the right-hand
    side of the title for the topic filter used to subscribe in the panel located
    at the left-hand side of the window. MQTT.fx is telling you that you have received
    two messages in the `sensors/octocopter01/altitude` topic. Click on this panel
    and MQTT.fx will display all the received messages on the right-hand side of the
    panel. MQTT.fx will display a number at the right-hand side of each message to
    specify the message number since we started the subscription to the topic filter.
    Click on each message and MQTT.fx will display the QoS level for the message (0),
    the date and time it was received, and the payload for the message in the default
    plain string format. The following screenshot shows the payload for the second
    message that has been received by the subscriber generated by MQTT.fx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/041085e3-85c0-4701-9743-929abf57a7f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We created two publishers and each of them published a message to the same
    topic: `sensors/octocopter01/altitude`. The two subscribers for this topic received
    both messages. Now, we will understand what happens under the hood when a client
    publishes a message to a topic.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MQTT client that has already established a connection sends a `PUBLISH`
    packet to the MQTT server with a header that includes the following fields and
    flags. We need to understand the meaning of these fields and flags because we
    will be able to specify some of their values when we work with MQTT tools and
    MQTT client libraries in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PacketId`: If the QoS level is equal to 0, the value for this field will be
    0 or it won''t be present. If the QoS level is equal to 1 or 2, the packet identifier
    will have a number value to identify the packet and make it possible to identify
    the responses related to this packet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Dup`: If the QoS level is equal to 0, the value for this field will be 0\.
    If the QoS level is equal to 1 or 2, the MQTT client library or the MQTT server
    can resend a message that was previously published by the client when the subscribers
    haven''t acknowledged the first message. Whenever there is an attempt to resend
    a message that has already been published, the value for the Dup flag must be
    1 or `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QoS`: Specifies the QoS level for the message. We will dive deep into the
    quality of service level for messages, and their relationship with many other
    flags, later. So far, we have been working with QoS level 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Retain`: If the value for this flag is set to `1` or `True`, the MQTT server
    will store the message with its specified QoS level. Whenever new MQTT clients
    subscribe to a topic filter that matches the topic for the stored or retained
    message, the last stored message for this topic will be sent to the new subscriber.
    If the value for this flag is set to `0` or `False`, the MQTT server won''t store
    the message and won''t replace a retained message with the same topic if there
    is one message retained for this topic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TopicName`: A string with the topic name to which the message must be published.
    Topic names have a hierarchy structure where slashes (`/`) are used as delimiters.
    In our examples, the value for `TopicName` was `"sensors/octocopter01/altitude"`.
    We will analyze best practices for topic names later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The payload contains the actual message that the MQTT client wants the MQTT
    server to publish. MQTT is data-agnostic, and therefore we can send any binary
    data and we don't have restrictions such as those imposed by JSON or XML. Of course,
    we can use these or others to organize payloads if we wish. In our examples, we
    sent a string that included a number that represented the altitude, followed by
    a space, and an `"f"` that indicates the unit of measurement is `feet`.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT server will read a valid `PUBLISH` packet and it will respond with
    a packet only for QoS levels greater than 0\. If the QoS level is 0, the MQTT
    server will not respond. The MQTT server will identify all subscribers whose subscribed
    topic matches the topic name specified for the message and the server will publish
    the message to these clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between an MQTT client and an MQTT
    server to publish a message with a QoS level of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a27b8136-4eda-4a7e-8a36-375ac322adaf.png)'
  prefs: []
  type: TYPE_IMG
- en: The other QoS levels have a different flow with an additional interaction between
    the publisher and the MQTT server, and increased overheads that we will analyze
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing from topics with a GUI tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we don''t want a subscriber to receive more messages whose destination
    topic name matches one or more topic filters, the subscriber can send a request
    to unsubscribe to a list of topic filters to the MQTT server. Obviously, unsubscribing
    from topic filters is the opposite of subscribing to topic filters. We will use
    the MQTT.fx GUI utility to unsubscribe the MQTT client from the `sensors/octocopter01/altitude`
    topic. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the MQTT.fx window in which you established a connection and subscribed
    to a topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Subscribe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the panel that displays the `sensors/octocopter01/altitude` topic
    name on the left-hand side of the window. Then, click on the Unsubscribe button
    located in this panel. The following screenshot shows this button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/53c9f43c-2184-4463-9e55-7f9182472def.png)'
  prefs: []
  type: TYPE_IMG
- en: MQTT.fx will unsubscribe the client from the `sensors/octocopter01/altitude`
    topic, and therefore the client won't receive any new messages published to the
    `sensors/octocopter01/altitude` topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will use the MQTT.fx GUI utility to make the MQTT client publish another
    message to the `sensors/octocopter01/altitude`. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the MQTT.fx window in which you established a connection and subscribed
    to a topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Publish and enter `sensors/octocopter01/altitude` in the dropdown at the
    left-hand side of the Publish button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, click the Publish button. MQTT.fx will publish the entered text to the
    specified topic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following text in the textbox below the Publish button: `37 f`, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/dd889680-10a8-4ad5-a871-1632586b5db3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t want to work with the MQTT.fx utility, you can run a `mosquitto_pub`
    command to generate another MQTT client that publishes a message to the topic.
    You just need to open another Terminal in macOS or Linux, or another Command Prompt
    in Windows, go to the directory in which Mosquitto is installed, and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, go back to the MQTT.fx window and click Subscribe to check the messages
    that have been received. The client has unsubscribed from the `sensors/octocopter01/altitude`
    topic before we published a new message to this topic, and therefore the recently
    published message with a payload of  `"37 f"` isn't displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the Terminal or Command Prompt window in which you executed the
    `mosquitto_sub` command and subscribed to the `sensors/octocopter01/atitude` topic.
    You will see lines similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This client is still subscribed to the `sensors/octocopter01/altitude` topic,
    and therefore it received the message with the payload of `"37 f"`.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT client sends an `UNSUBSCRIBE` packet to the MQTT server with a packet
    identifier (`PacketId`) in the header and one or more topic filters in the payload.
    The main difference with a `SUBSCRIBE` packet is that it isn't necessary to include
    the QoS level for each topic filter because the MQTT client just wants to unsubscribe.
  prefs: []
  type: TYPE_NORMAL
- en: After an MQTT client unsubscribes from one or more topic filters, the MQTT server
    still keeps the connection open; the subscriptions to topic filters that don't
    match the topic filters specified in the `UNSUBSCRIBE` packet payload will continue
    working.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, a single `UNSUBSCRIBE` packet can ask the MQTT server to unsubscribe
    a client from many topics. The `UNSUBSCRIBE` packet must include at least one
    topic filter in the payload to comply with the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, in which we asked the MQTT server to unsubscribe, we
    used a specific topic name as the value for the topic filter, and therefore we
    requested the MQTT server to unsubscribe from a single topic. As previously mentioned,
    we will learn about the use of wildcards in topic filters later.
  prefs: []
  type: TYPE_NORMAL
- en: The packet identifier will have a number value to identify the packet and make
    it possible to identify the response related to this `UNSUBSCRIBE` packet. The
    MQTT server will process a valid `UNSUBSCRIBE` packet and it will respond with
    an `UNSUBACK`  packet, which indicates the unsubscribe acknowledgment and confirms
    the receipt and processing of the `UNSUBSCRIBE` packet. The `UNSUBACK` packet
    will include the same packet identifier (`PacketId`) in the header that was received
    in the `UNSUBSCRIBE` packet.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT server will remove any topic filter that exactly matches any of the
    specified topic filters in the `UNSUBSCRIBE` packet's payload for the specific
    client that sent the packet. The topic filter match must be exact to be deleted.
    After the MQTT server deletes a topic filter from the subscription list for the
    client, the server stops adding new messages to be published to the client. Only
    messages that have already started delivery to the client with QoS levels of 1
    or 2 will be published to the client. In addition, the server might publish existing
    messages that have been buffered for their distribution to the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between an MQTT client and an MQTT
    server in unsubscribing from one or many topic filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5dedc49e-0158-46ca-b64f-07262736f3ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Learning best practices for topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that MQTT allows us to publish messages on topics. A publisher
    always has to specify the topic name to which a message will be published. The
    easiest way to understand topic names in MQTT is to think about them as paths
    in a file system.
  prefs: []
  type: TYPE_NORMAL
- en: If we have to save dozens of files that have information about different types
    of sensor for a diverse number of drones, we can create a hierarchy of directories
    or folders to organize all the files that we will save. We can create a directory
    named `sensors`, then one sub-directory for each drone, such as `octocopter01`,
    and finally a sub-directory with the sensor name, such as `altitude`. The path
    in macOS or Linux will be `sensors/octocopter01/altitude` because these operating
    systems use a forward slash (`/`) as a delimiter. In Windows, the path will be
    `sensors\drone\altitude` because this operating system uses a backslash (`\`)
    as a delimiter.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will save the files that have information about the altitude sensor
    for the drone named `octocopter01` in the created path. Instead of saving files
    in a path, we can think about publishing a message to a path and using the same
    mechanism we use to organize files in paths to arrange messages in topics.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of directories or folders, a topic has topic levels, specifically a
    hierarchy of topic levels, and slashes (`/`) are used as delimiters, that is,
    topic-level separators. If we use `sensors/octocopter01/altitude` as the topic
    name, `sensors` is the first topic level, `octocopter01` is the second topic level,
    and `altitude` is the third topic level.
  prefs: []
  type: TYPE_NORMAL
- en: Topic names are case-sensitive, and therefore `sensors/octocopter01/altitude`
    is different from `sensors/Octocopter01/altitude`, `Sensors/octocopter01/altitude`,
    and `Sensors/Octocopter01/Altitude`. In fact, the four strings will be considered
    as four individual topic names. We must make sure we select a case scheme for
    the topic names and we use it for all topic names and topic filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use any UTF-8 character in topic names, with the exception of the two
    wildcard characters that we will analyze later: the plus sign (`+`) and hash (`#`).
    Hence, we must avoid `+` and `#` in the topic names. However, it is a good practice
    to restrict the character set to avoid unexpected problems with client libraries.
    For example, we can avoid accents and characters that are not common in English,
    as we do whenever we build URLs. It is possible to use these characters but you
    can definitely  face issues when using them.'
  prefs: []
  type: TYPE_NORMAL
- en: We should avoid creating topics starting with the dollar sign (`$`) because
    many MQTT servers publish statistics data related to servers in topics that start
    with `$`. Specifically, the first topic level is `$SYS`.
  prefs: []
  type: TYPE_NORMAL
- en: We must maintain consistency when sending messages to different topic names
    as we do when we save files in different paths. For example, if we want to publish
    the altitude for a drone named `hexacopter20`, we will use `sensors/hexacopter20/altitude`.
    We must use the same topic levels that we used for the same goal for `octocopter01`
    and just change the drone name from `octocopter01` to `hexacopter20`. It would
    be a really bad practice to use a topic with a different structure or an inconsistent
    case, such as `altitude/sensors/hexacopter20` or `Sensors/Hexacopter20/Altitude`.
    We have to take into account that we can subscribe to multiple topics by using
    topic filters, and therefore it is very important to create topic names accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding MQTT wildcards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we analyzed the subscription operation, we learned that an MQTT client
    can subscribe to one or more topic filters. If we specify a topic name as a topic
    filter, we will only subscribe to a single topic. We can take advantage of the
    following two wildcards to create topic filters that subscribe to all the topics
    that match the filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plus sign** (`+`): This is a single-level wildcard that matches any name
    for a specific topic level. We can use this wildcard instead of specifying a name
    for any topic level in the topic filter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hash** (`#`): This is a multilevel wildcard that we can use only at the end
    of a topic filter, as the last level, and it matches any topic whose first levels
    are the same as the topic levels specified at the left-hand side of the `#` symbol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if we want to receive all the messages related to altitude for
    all the drones, we can use the `+` single-level wildcard instead of a specific
    drone name. We can use the following topic filter: `sensors/+/altitude`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we publish messages to the following topics, the subscriber that used the
    `sensors/+/altitude` topic filter will receive all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/hexacopter20/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/superdrone01/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/thegreatestdrone/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The subscriber to the `sensors/+/altitude` topic filter won''t receive messages
    sent to any of the following topics because they won''t match the topic filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/speed/rotor/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/superdrone01/speed/rotor/2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/superdrone01/remainingbattery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to receive all the messages related to all the sensors for the drone
    named `octocopter01`, we can use the `#` multilevel wildcard after the drone name
    and the slash (`/`). We can use the following topic filter: `sensors/octocopter01/#`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we publish messages to the following topics, the subscriber that used the
    `sensors/octocopter01/#` topic filter will receive all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/speed/rotor/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/speed/rotor/2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/speed/rotor/3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/speed/rotor/4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/octocopter01/remainingbattery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used a multilevel wildcard, and therefore, irrespective of the additional
    topic levels after `sensors/octocopter01/`, we will receive all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subscriber to the `sensors/octocopter01/#` topic filter won''t receive
    messages sent to any of the following topics because they won''t match the topic
    filter. None of the following has `sensors/octocopter01/` as a prefix, and therefore
    they don''t match the topic filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sensors/hexacopter02/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/superdrone01/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/thegreatestdrone/altitude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/drone02/speed/rotor/1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/superdrone02/speed/rotor/2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sensors/superdrone02/remainingbattery`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, we must be careful when we use any wildcard because we might be subscribing
    to a huge number of topics with a single topic filter. We have to avoid subscribing
    to topics that aren't of interest for the client to avoid wasting unnecessary
    bandwidth and server resources.
  prefs: []
  type: TYPE_NORMAL
- en: We will use these wildcards in subscriptions later to analyze how different
    QoS levels work with MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the different QoS levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand how connection, subscription, and publication work in
    combination with topic names and topic filters with wildcards, we can dive deep
    into the QoS levels. So far, we have analyzed how both subscription and publication
    work with a QoS level equal to 0\. Now, we will understand what this number means
    and how things work when we use the other available QoS levels for publication
    and subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that publication involves publishing from the MQTT client to the MQTT
    server and then from the server to the subscribed client. It is very important
    to understand that we can publish with a QoS level and subscribe with another
    QoS level. Hence, there is a QoS level for the publish process between the publisher
    and the MQTT server and another QoS level for the publish process between the
    MQTT server and the subscriber. We will use sender and receiver to identify the
    parties involved in message delivery for the different QoS levels. In the publish
    process between the publisher and the MQTT server, the publisher will be the sender
    and the MQTT server the receiver. In the publish process between the MQTT server
    and the subscriber, the sender will be the MQTT server and the receiver will be
    the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the QoS level, we have differences in the meaning of a successfully
    delivered message in the MQTT protocol between the involved parties. The QoS level
    is the agreement between a sender and a receiver of a message about the guarantees
    of actually delivering the message. These warranties might include the number
    of times that a message might arrive and the possibility (or not) of duplicates.
    MQTT supports the following three possible QoS levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0, At most once delivery**: This QoS level offers the same warranty as the
    underlying TCP protocol. The message is not acknowledged by the receiver or destination.
    The sender just sends the message to the destination and nothing else happens.
    The sender neither stores nor schedules new deliveries for any messages that might
    fail to reach the destination. The key advantage of this QoS level is that it
    has the lowest possible overhead, compared to the other QoS levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**1, At least once delivery**: This QoS level adds a confirmation requirement
    to the destination that has to receive the message. This way, QoS level 1 provides
    a warranty that the message will be delivered at least once to the subscriber.
    One of the key disadvantages of this QoS level is that it might generate duplicates,
    that is, the same message might be sent more than once to the same destination.
    The sender stores the message until it receives an acknowledgment from the subscriber.
    If the sender doesn''t receive the acknowledgment within a specific time, the
    sender will publish the message again to the receiver. The final receiver must
    have the necessary logic to detect duplicates if they shouldn''t be processed
    twice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**2, Exactly once delivery**: This QoS level provides a warranty that the message
    is delivered only once to the destination. QoS level 2 has the highest overhead,
    compared to the other QoS levels. This QoS level requires two flows between the
    sender and the receiver. A message published with QoS level 2 is considered successfully
    delivered after the sender is sure that it has been successfully received once
    by the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, we just want messages to be delivered with the least possible bandwidth
    usage, we have a very reliable network, and it doesn't matter if for some reason
    a few messages are lost. In these cases, QoS level 0 is the appropriate choice.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, the messages are extremely important because they represent
    commands to control an IoT device, the network is unreliable, and we must make
    sure that the message reaches the destination. In addition, a duplicate command
    might generate a big problem because we don't want the IoT device to process a
    specific command twice. In these cases, QoS level 2 is going to be the appropriate
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: If a publisher works with a QoS level higher than the QoS level specified by
    the subscriber, the MQTT server will have to downgrade the QoS level to the lowest
    level that the specific subscriber is using when it publishes the message from
    the MQTT server to this subscriber. For example, if we use QoS level 2 to publish
    a message from the publisher to the MQTT server, but one subscriber has requested
    QoS level 1 when making the subscription, the publication from the MQTT server
    to this subscriber will use QoS level 1.
  prefs: []
  type: TYPE_NORMAL
- en: Working with at least once delivery (QoS level 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will use wildcards to subscribe to a topic filter with QoS level 1,
    and then we will publish one message to a topic name that will match the topic
    filter with QoS level 1\. This way, we will analyze how both publishing and subscription
    work with QoS level 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `mosquitto_sub` command-line utility included in Mosquitto
    to generate a simple MQTT client that subscribes to a topic filter with QoS level
    1 and prints all the messages it receives. Open a Terminal in macOS or Linux,
    or a Command Prompt in Windows, go to the directory in which Mosquitto is installed,
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will create an MQTT client that will establish a connection
    with the local MQTT server and then will make the client subscribe to the topic
    filter specified after the `-t` option: `sensors/+/altitude`. We specify that
    we want to use QoS level 1 to subscribe to the topic filter with the `-q 1` option.
    We specify the `-d` option to enable debug messages that will allow us to understand
    what happens under the hood and the differences when compared with publishing
    a message with QoS level 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terminal or Command Prompt window will display debug messages similar to
    the following lines. Take into account that the generated `ClientId` will be different
    from the one shown after `Client mosqsub|16736-LAPTOP-5D`. Notice that `QoS: 1`
    indicates that the subscription is done with QoS level 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `mosquitto_pub` command-line utility included in Mosquitto
    to generate a simple MQTT client that publishes a message to a topic with QoS
    level 1 instead of the QoS level 0 that we used when we published messages before.
    Open a Terminal in macOS or Linux, or a Command Prompt in Windows, go to the directory
    in which Mosquitto is installed, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will create an MQTT client that will establish a connection
    with the local MQTT server and then will make the client publish a message to
    the topic specified after the `-t` option: `sensors/hexacopter02/altitude`. We
    specify the payload for the message after the `-m` option: `"75 f"`. We specify
    that we want to use QoS level 1 to publish the message with the `-q 1` option.
    We specify the X option to enable debug messages that will allow us to understand
    what happens under the hood and the differences when compared with publishing
    a message with QoS level 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terminal or Command Prompt window will display debug messages similar to
    the following lines. Take into account that the generated `ClientId` will be different
    from the one shown after `Client mosqpub|19544-LAPTOP-5D`. After publishing the
    message, the client disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous lines show that the generated MQTT client sends a `PUBLISH` packet
    to the MQTT server and then receives a `PUBACK` package from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the Terminal or Command Prompt window in which you executed
    the `mosquitto_sub` command and subscribed to the `sensors/+/atitude` topic filter.
    You will see lines similar to the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines show that the generated MQTT client, that is, the subscriber,
    received a `PUBLISH` packet from the MQTT server and then sent a `PUBACK` package
    to the server to acknowledge the message. If we clean up the debug messages that
    start with the `Client` prefix, we will see just the last line that shows the
    payloads for the message that we received as a result of our subscription to the
    `sensors/+/altitude` topic filter: `75 f`.'
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT client that has already established a connection, that is, the publisher,
    sends a `PUBLISH` packet to the MQTT server with the header we have already described,
    QoS set to 1, and including a `PacketId` numeric value that will be unique for
    this client. At this time, the publisher will consider the `PUBLISH` packet identified
    with the `PacketId` as an unacknowledged `PUBLISH` packet.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT server reads a valid `PUBLISH` packet and it responds to the publisher
    with a `PUBACK` packet with the same `PacketId` value that has been used for the
    `PUBLISH` packet. Once the publisher receives the `PUBACK` packet, it discards
    the message and the MQTT server is responsible for publishing it to the appropriate
    subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between a publisher and an MQTT
    server to publish a message with a QoS level of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6851968e-ccf4-41d2-bfde-a17bcfce7fbb.png)'
  prefs: []
  type: TYPE_IMG
- en: The MQTT server can start publishing messages to the appropriate subscribers
    before it sends the `PUBACK` packet to the publisher. Hence, when the publisher
    receives the `PUBACK` packet from the MQTT server, it doesn't mean that all the
    subscribers have received the message. It is very important to understand the
    meaning of this `PUBACK` packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each subscriber to which the message has to be published, the MQTT server
    will send a `PUBLISH` packet and the subscriber must acknowledge receipt of the
    message by sending a `PUBACK` packet to the MQTT server. The following diagram
    shows the interaction between an MQTT server and the subscribers when a message
    is published with a QoS level of 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3cef734-2f01-424f-a46a-2d978f06f1b6.png)If the application is able
    to tolerate duplicates and we have to make sure that messages reach the subscribers
    at least once, QoS level 1 is an excellent choice. If there is no way to handle
    duplicates, we have to use QoS level 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with exactly once delivery (QoS level 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will use wildcards to subscribe to a topic filter with QoS level 2,
    and then we will publish one message to a topic that will match the topic filter
    with QoS level 2\. This way, we will analyze how both publishing and subscription
    work with QoS level 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `mosquitto_sub` command-line utility included in Mosquitto
    to generate a simple MQTT client that subscribes to a topic filter with QoS level
    1 and prints all the messages it receives. Open a Terminal in macOS or Linux,
    or a Command Prompt in Windows, go to the directory in which Mosquitto is installed,
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will create an MQTT client that will establish a connection
    with the local MQTT server and then will make the client subscribe to the topic
    filter specified after the `-t` option: `sensors/quadcopter30/#`. We specify that
    we want to use QoS level 2 to subscribe to the topic filter with the `-q 2` option.
    We specify the `-d` option to enable debug messages that will allow us to understand
    what happens under the hood and the differences when compared with publishing
    a message with QoS levels 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terminal or Command Prompt window will display debug messages similar to
    the following lines. Take into account that the generated `ClientId` will be different
    from the one shown after `Client mosqsub|8876-LAPTOP-5DO`. Notice that `QoS: 2`
    indicates that the subscription is done with QoS level 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `mosquitto_pub` command-line utility included in Mosquitto
    to generate a simple MQTT client that publishes a message to a topic with QoS
    level 2 instead of QoS levels 0 and 1 we used when we published messages before.
    Open a Terminal in macOS or Linux, or a Command Prompt in Windows, go to the directory
    in which Mosquitto is installed, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will create an MQTT client that will establish a connection
    with the local MQTT server and then will make the client publish a message to
    the topic specified after the `-t` option: `sensors/quadcopter30/speed/rotor/1`.
    We specify the payload for the message after the `-m` option: `"123 f"`. We specify
    that we want to use QoS level 2 to publish the message with the `-q 2` option.
    We specify the `-d` option to enable debug messages that will allow us to understand
    what happens under the hood and the differences when compared with publishing
    a message with QoS levels 0 and 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Terminal or Command Prompt window will display debug messages similar to
    the following lines. Take into account that the generated `ClientId` will be different
    from the one shown after `Client mosqpub|14652-LAPTOP-5D`. After publishing the
    message, the client disconnects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines show that the generated MQTT client, that is, the publisher,
    had the following packet exchanges with the MQTT server:'
  prefs: []
  type: TYPE_NORMAL
- en: The publisher sent a `PUBLISH` packet to the MQTT server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The publisher received a `PUBREC` packet from the MQTT server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The publisher sent a `PUBREL` packet to the MQTT server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The publisher received a `PUBCOMP` packet from the MQTT server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go back to the Terminal or Command Prompt window in which you executed
    the `mosquitto_sub` command and subscribed to the `sensors/quadcopter30/#` topic
    filter. You will see lines similar to the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous lines show that the generated MQTT client, that is, the subscriber,
    had the following packet exchanges with the MQTT server:'
  prefs: []
  type: TYPE_NORMAL
- en: The subscriber received a `PUBLISH` packet from the MQTT server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subscriber sent a `PUBREC` packet to the MQTT server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subscriber received a `PUBREL` packet from the MQTT server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subscriber sent a `PUBCOMP` packet to the MQTT server after it successfully
    received the message with the payload
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we clean up debug messages that start with the `Client` prefix, we will
    see just the last line, which shows the payloads for the message which we received
    as a result of our subscription to the `sensors/quadcopter30/#` topic filter:
    `123 f`.'
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT client that has already established a connection, that is, the publisher
    sends a `PUBLISH` packet to the MQTT server with the header we have already described,
    QoS set to 2, and including a `PacketId` numeric value that will be unique for
    this client. At this time, the publisher will consider the `PUBLISH` packet identified
    with the `PacketId` as an unacknowledged `PUBLISH` packet.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT server reads a valid `PUBLISH` packet and it will respond to the publisher
    with a `PUBREC` packet with the same `PacketId` value that has been used for the
    `PUBLISH` packet. The `PUBREC` packet indicates that the MQTT server accepted
    the ownership of the message. Once the publisher receives the `PUBREC` packet,
    it discards the message and it stores the `PacketId` related to the message and
    the `PUBREC` packet.
  prefs: []
  type: TYPE_NORMAL
- en: The publisher sends a `PUBREL` packet to the MQTT server as a response to the
    received `PUBREC` packet. This `PUBREL` packet will be considered unacknowledged
    until it receives the `PUBCOMP` packet related to the `PacketId` from the MQTT
    server. Finally, the MQTT server sends a `PUBCOMP` packet with the `PacketId`
    to the publisher and, at this point, both the publisher and the MQTT server are
    sure that the message has been successfully delivered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the interaction between a publisher and an MQTT
    server to publish a message with a QoS level of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ff3b4070-f57c-41b0-b046-625e2c94725b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For each subscriber with QoS level 2 to which the message has to be published,
    the MQTT server will send a `PUBLISH` packet, and the same packet exchange that
    we have analyzed between the publisher and the MQTT server will happen between
    the MQTT server and the subscriber. However, in this case, the MQTT server is
    the one that acts as a publisher and starts the flow. The following diagram shows
    the interaction between an MQTT server and the subscribers when a message is published
    with a QoS level of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0c238fff-d56d-4284-8ace-46b6a5931f12.png)If the application isn''t
    able to tolerate duplicates and we have to make sure that messages reach the subscribers
    only once, QoS level 2 is the appropriate choice. However, magic comes with a
    price: we must take into account that QoS level 2 has the highest overhead compared
    to the other QoS levels.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding overhead in the different Quality of Service levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the different packages that are exchanged
    between an MQTT client and an MQTT server to publish a message with QoS levels
    0, 1, and 2\. This way, we can easily recognize the increased overhead as we increase
    the QoS level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/23bb3359-59a3-41e5-87ef-5521855c37f1.png)It is very important to
    take into account the additional overhead required by QoS level 2 and to use it
    only when it is really necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'QoS level 0 for MQTT means:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exactly once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At most once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At least once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'QoS level 1 for MQTT means:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exactly once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At most once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At least once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'QoS level 2 for MQTT means:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exactly once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At most once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At least once delivery
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the application isn''t able to tolerate duplicates and we have to make sure
    that the messages reach the subscribers only once, the appropriate choice is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QoS level 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QoS level 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QoS level 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which QoS level has the highest overhead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QoS level 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QoS level 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: QoS level 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](d9cf708f-f027-4bfa-a2d2-9fd3653165d9.xhtml), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked with different tools to interact with the Mosquitto
    MQTT 3.1.1 server we installed in [Chapter 1](d20ae00b-2bb7-4d81-b3eb-5c47215bce1f.xhtml),
    *Installing an MQTT 3.1.1 Mosquitto Server*. We worked with an unsecured MQTT
    server to easily understand the interaction between the MQTT clients and the MQTT
    server.
  prefs: []
  type: TYPE_NORMAL
- en: We subscribed to topics via the command-line and GUI tools. Then, we published
    messages with QoS level 0 and we unsubscribed from topics. We learned best practices
    related to topics; and single-level, and multilevel wildcards. We studied in detail
    the different Quality of Service levels supported by MQTT and when it is appropriate
    to use each of them. We analyzed their advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understood how the MQTT 3.1.1 basics work, we will learn how to
    secure an MQTT server and to follow best practices related to security, which
    are the topics that we are going to discuss in [Chapter 3](89bdce8f-72bc-4fda-82a0-5cab33fa4bd8.xhtml),
    *Securing an MQTT 3.1.1 Mosquitto Server*.
  prefs: []
  type: TYPE_NORMAL
