- en: 7\. Kubernetes Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the concept of Kubernetes controllers and explains how
    to use them to create replicated Deployments. We will describe the use of different
    types of controllers, such as ReplicaSets, Deployments, DaemonSets, StatefulSets,
    and Jobs. You will learn how to choose a suitable controller for specific use
    cases. Using hands-on exercises, we will guide you through how to use these controllers
    with the desired configuration to deploy several replicas of Pods for your application.
    You will also learn how to manage them using various commands.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we created different Pods, managed their life cycle manually,
    and added metadata (labels or annotations) to them to help organize and identify
    various Pods. In this chapter, we will take a look at a few Kubernetes objects
    that help you manage several replica Pods declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: When deploying your application in production, there are several reasons why
    you would want to have more than one replica of your Pods. Having more than one
    replica ensures that your application continues to work in cases where one or
    more Pods fail. In addition to handling failures, replication also allows you
    to balance the load across the different replicas so that one Pod is not overloaded
    with a lot of requests, thereby allowing you to easily serve higher traffic than
    what a single Pod can serve.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes supports different controllers that you can use for replication,
    such as ReplicaSets, Deployments, DaemonSets, StatefulSets, and Jobs. A controller
    is an object that ensures that your application runs in the desired state for
    its entire runtime. Each of these controllers is useful for specific use cases.
    In this chapter, we will explore some of the most commonly used controllers one
    by one and understand how and when to use them in real-life scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, having multiple replicas of our application ensures that
    it is still available even if a few replicas fail. This also makes it easy for
    us to scale our application to balance the load to serve more traffic. For example,
    if we are building a web application that's exposed to users, we'd want to have
    at least two replicas of the application in case one of them fails or dies unexpectedly.
    We would also want the failed replica to recover on its own. In addition to that,
    if our traffic starts growing, we would want to increase the number of Pods (replicas)
    running our application. A ReplicaSet is a Kubernetes controller that keeps a
    certain number of Pods running at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSet acts as a supervisor for multiple Pods across the different nodes
    in a Kubernetes cluster. A ReplicaSet will terminate or start new Pods to match
    the configuration specified in the ReplicaSet template. For this reason, it is
    a good idea to use them even if your application only needs one Pod. Even if someone
    deletes the only running Pod, the ReplicaSet will ensure that a new Pod is created
    to replace it, thereby ensuring that one Pod is always running.
  prefs: []
  type: TYPE_NORMAL
- en: A ReplicaSet can be used to reliably run a single Pod indefinitely or to run
    multiple instances of the same Pod.
  prefs: []
  type: TYPE_NORMAL
- en: ReplicaSet Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first look at an example of the configuration of a ReplicaSet, and then
    we will cover what the different fields mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As with Pod configuration, a ReplicaSet also needs fields such as `apiVersion`,
    `kind`, and `metadata`. For a ReplicaSet, the API version, `apps/v1`, is the current
    version and the `kind` field will always be `ReplicaSet`. One field that is different
    from what we have seen in Pod configuration so far is the `spec`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will see what information we need to specify in the `spec` field.
  prefs: []
  type: TYPE_NORMAL
- en: Replicas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `replicas` field under `spec` specifies how many Pods the ReplicaSet should
    keep running concurrently. You can see the following value in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The ReplicaSet will create or delete Pods in order to match this number. The
    default value for this field, if not specified, is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Pod Template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `template` field, we will specify the template of the Pod that we want
    to run using this ReplicaSet. This Pod template will be exactly the same as the
    Pod templates we used in the previous two chapters. As usual, we can add metadata
    in the form of labels and annotations to the Pods. The ReplicaSet will use this
    Pod template to create new Pods whenever there is a need for them. The following
    section from the previous example comprises the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Pod Selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a really important section. In the `selector` field under `spec`, we
    can specify the label selectors that will be used by the ReplicaSet to identify
    which Pods to manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example ensures that our controller will only manage Pods with
    an `environment: production` label.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now proceed to create our first ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.01: Creating a Simple ReplicaSet with nginx Containers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a simple ReplicaSet and examine the Pods created
    by it. To successfully complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `replicaset-nginx.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the highlighted part of the configuration, we have three
    fields: `replicas`, `selector`, and `template`. We have set the number of replicas
    to `2`. The Pod selector has been set in such a way that this ReplicaSet will
    manage the Pods with the `environment: production` label. The Pod template has
    the simple Pod configuration that we used in previous chapters. We have ensured
    that the Pod label selector matches the Pod''s labels in the template exactly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create the ReplicaSet using the preceding configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the ReplicaSet was created by using the `kubectl get` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that `rs` is a short form of `replicaset` in all kubectl commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a ReplicaSet with two desired replicas, as we defined
    in `replicaset-nginx.yaml` in *step 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the Pods were actually created by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the names of the Pods created by the ReplicaSet take the name
    of the ReplicaSet as a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our first ReplicaSet, let''s look at it in more detail
    to understand what actually happened during its creation. To do that, we can describe
    the ReplicaSet we just created by using the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Describing nginx-replicaset'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.1: Describing nginx-replicaset'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will inspect the Pods created by this ReplicaSet and verify that they
    have been created with the correct configuration. Run the following command to
    get a list of the Pods that are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to describe one of the Pods by copying its name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Listing Pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.2: Listing Pods'
  prefs: []
  type: TYPE_NORMAL
- en: In the highlighted sections of the preceding output, we can clearly see that
    the pod has the `environment=production` label and is controlled by `ReplicaSet/nginx-replicaset`.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have created a simple ReplicaSet in this exercise. In the following subtopics,
    we will go through the highlighted sections of the preceding output to understand
    the ReplicaSet that's running.
  prefs: []
  type: TYPE_NORMAL
- en: Labels on the ReplicaSet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following line from the output shown in *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It shows that, as desired, the ReplicaSet was created with a label key called
    `app` with a value of `nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors for the ReplicaSet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, consider the following line from the output shown in *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the ReplicaSet is configured with an `environment=production`
    Pod selector. This means that this ReplicaSet will try to acquire Pods that have
    this label.
  prefs: []
  type: TYPE_NORMAL
- en: Replicas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following line from the output shown in *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the ReplicaSet has the desired count of `2` for the Pods, and
    it also shows that there are currently two replicas present.
  prefs: []
  type: TYPE_NORMAL
- en: Pods Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the `Replicas` field only shows the number of Pods currently present,
    `Pods Status` shows the actual status of those Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there are currently two Pods running under this ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: Pods Template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let's consider the `Pod Template` section of the output shown in *Figure
    7.1*. We can see that the Pod template is the same as was described in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last section of the output shown in *Figure 7.1*, we can see that there
    are two events, which denotes that two pods were created to get to the desired
    count of two Pods for the ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: In the last exercise, we created a ReplicaSet to maintain a number of running
    replicas. Now, let's consider a scenario where some nodes or Pods fail for some
    reason. We will see how the ReplicaSet will behave in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.02: Deleting Pods Managed by a ReplicaSet'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will delete one of the Pods managed by a ReplicaSet to
    see how it responds. This way, we will be simulating a single or multiple Pods
    failing during the runtime of a ReplicaSet:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will assume that you have successfully completed the previous
    exercise as we will be reusing the ReplicaSet created in that exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify that the Pods created by the ReplicaSet are still running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the first Pod to replicate Pod failure during runtime by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the ReplicaSet and check the events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Describing the ReplicaSet'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.3: Describing the ReplicaSet'
  prefs: []
  type: TYPE_NORMAL
- en: As highlighted in the preceding output, we can see that after a Pod is deleted,
    the ReplicaSet creates a new Pod using the Pod configuration in the `Template`
    section of the ReplicaSet configuration. Even if we delete all the Pods managed
    by the ReplicaSet, they will be recreated. So, to delete all the Pods permanently
    and to avoid the recreation of the Pods, we need to delete the ReplicaSet itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to delete the ReplicaSet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding output, the `nginx-replicaset` ReplicaSet was deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to verify that the Pods managed by the ReplicaSet
    were also deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this output, we can verify that the Pods were deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a scenario where you have already deployed a single Pod for testing.
    Now, it is ready to go live. You apply the required label changes from development
    to production, and now you want to control this using a ReplicaSet. We will see
    how to do this in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.03: Creating a ReplicaSet Given That a Matching Pod Already Exists'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a Pod that matches the Pod template in the
    ReplicaSet and then create the ReplicaSet. Our aim is to prove that the newly
    created ReplicaSet will acquire the existing Pod and start managing it as if it
    created that Pod itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to successfully complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `pod-matching-replicaset.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the Pod using the preceding configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `replicaset-nginx.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the ReplicaSet using the preceding configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This output indicates that the Pod has been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check the status of the ReplicaSet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there are currently two Pods managed by the ReplicaSet, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s check what Pods are running by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this output, we can see that the manually created Pod named `pod-matching-replicaset`
    is still running and that there was only one new Pod created by the `nginx-replicaset`
    ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use the `kubectl describe` command to check whether the Pod named
    `pod-matching-replicaset` is being managed by the ReplicaSet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Describing the Pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.4: Describing the Pod'
  prefs: []
  type: TYPE_NORMAL
- en: In the highlighted section of the truncated output, we can see that even though
    this Pod was created manually before the ReplicaSet event existed, this Pod is
    now managed by the ReplicaSet itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will describe the ReplicaSet to see how many Pod creations were triggered
    by it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Describing the ReplicaSet'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.5: Describing the ReplicaSet'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to delete the ReplicaSet for cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, we can see that a ReplicaSet is capable of acquiring existing Pods as long
    as they match the label selector criteria. In cases where there are more matching
    Pods than the desired count, the ReplicaSet will terminate some of the Pods in
    order to maintain the total count of running Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Another common operation is horizontally scaling a ReplicaSet that you previously
    created. Let's say that you create a ReplicaSet with a certain number of replicas
    and later you need to have more or fewer replicas to manage increased or decreased
    demand. Let's see how you can scale the number of replicas in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.04: Scaling a ReplicaSet after It Is Created'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a ReplicaSet with two replicas and then modify
    it to increase the number of replicas. Then, we will reduce the number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to successfully complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `replicaset-nginx.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the ReplicaSet using the `kubectl apply`
    command, as described in the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check all the existing Pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can see that there are two Pods created by the replica set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to scale up the number of replicas for the ReplicaSet to
    `4`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check all the Pods that are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We can see that now there are a total of four Pods. The ReplicaSet created two
    new Pods after we applied the new configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s run the following command to scale down the number of replicas
    to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check all the Pods that are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We can see that this time, the ReplicaSet deleted all the Pods exceeding the
    count from the desired count of `1` and kept only one replica running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to delete the ReplicaSet for cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we have managed to scale the number of replicas up and down.
    This could be particularly useful if the traffic to your application grows or
    decreases for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Deployment is a Kubernetes object that acts as a wrapper around a ReplicaSet
    and makes it easier to use. In general, in order to manage replicated services,
    it's recommended that you use Deployments that, in turn, manage the ReplicaSet
    and the Pods created by the ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major motivation for using a Deployment is that it maintains a history
    of revisions. Every time a change is made to the ReplicaSet or the underlying
    Pods, a new revision of the ReplicaSet is recorded by the Deployment. This way,
    using a Deployment makes it easy to roll back to a previous state or version.
    Keep in mind that every rollback will also create a new revision for the Deployment.
    The following diagram provides an overview of the hierarchy of the different objects
    managing your containerized application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Hierarchy of Deployment, ReplicaSet, Pods, and containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.6: Hierarchy of Deployment, ReplicaSet, Pods, and containers'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration of a Deployment is actually very similar to that of a ReplicaSet.
    Here''s an example of a Deployment configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The value for the `kind` field is `Deployment`. The rest of the configuration
    remains the same as that for ReplicaSets. Deployments also have the `replicas`,
    `selector`, and Pod `template` fields used in the same way as ReplicaSets.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `strategy` field under `spec`, we can specify which strategy the Deployment
    should use when it replaces old pods with new ones. This can either be `RollingUpdate`
    or `Recreate`. The default value is `RollingUpdate`.
  prefs: []
  type: TYPE_NORMAL
- en: '**RollingUpdate**'
  prefs: []
  type: TYPE_NORMAL
- en: This is a strategy used to update a Deployment without having any downtime.
    With the `RollingUpdate` strategy, the controller updates the Pods one by one.
    Hence, at any given time, there will always be some Pods running. This strategy
    is particularly helpful when you want to update the Pod template without incurring
    any downtime for your application. However, be aware that having a rolling update
    means that there may be two different versions of Pods (old and new) running at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: If applications serve static information, this is usually fine because there's
    usually no harm in serving traffic using two different versions of an application,
    so long as the information that is served is the same. So, `RollingUpdate` is
    usually a good strategy for these applications. In general, we can use `RollingUpdate`
    for applications for which the data stored by a new version can be read and handled
    by the old version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example configuration for setting the strategy to `RollingUpdate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '`maxUnavailable` is the maximum number of Pods that can be unavailable during
    the update. This field can be specified as either an integer representing the
    maximum number of unavailable Pods or a string representing the percentage of
    total replicas that can be unavailable. For the preceding example configuration,
    Kubernetes will ensure that no more than one replica becomes unavailable while
    applying an update. The default value for `maxUnavailable` is `25%`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`maxSurge` is the maximum number of Pods that can be scheduled/created above
    the desired number of Pods (as specified in the `replicas` field). This field
    can also be specified as either an integer or a percentage string, as with `maxUnavailable`.
    The default value for `maxSurge` is also `25%`.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, in the preceding example, we are telling the Kubernetes controller to
    update the Pods one at a time, in such a way that no more than one Pod is ever
    unavailable and that no more than four Pods are ever scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two parameters—`maxUnavailable` and `maxSurge`—can be tuned for availability
    and the speed of scaling up or down the Deployment. For example, `maxUnavailable:
    0` and `maxSurge: "30%"` ensure a rapid scale-up while maintaining the desired
    capacity at all times. `maxUnavailable: "15%"` and `maxSurge: 0` ensure that the
    deployment can be performed without using any extra capacity at the cost of having,
    at worst, 15% fewer Pods running.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recreate**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this strategy, all the existing pods are killed before creating the new
    Pods with an updated configuration. This means there will be some downtime during
    the update. This, however, ensures that all the Pods running in the Deployment
    will be on the same version (old or new). This strategy is particularly useful
    when working with application Pods that need to have a shared state and so we
    can''t have two different versions of Pods running at the same time. This strategy
    can be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A good use case for using the `Recreate` update strategy is if we need to run
    some data migration or data processing before the new code can be used. In this
    case, we will need to use the `Recreate` strategy because we can't afford to have
    any new code running along with the old one without running the migration or processing
    first for all the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have studied the different fields in the configuration of a Deployment,
    let's implement them in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.05: Creating a Simple Deployment with Nginx Containers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create our first Deployment Pod using the configuration
    described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `nginx-deployment.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this configuration, we can see that the Deployment will have three replicas
    of Pods running with the `app: nginx` and `environment: production` labels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create the Deployment defined in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check the status of the Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check all the Pods that are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: A list of Pods created by the Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.7: A list of Pods created by the Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the Deployment has created three Pods, as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the names given to the Pods automatically. `nginx-deployment`
    creates a ReplicaSet named `nginx-deployment-588765684f`. The ReplicaSet then
    creates three replicas of Pods, each of which has a name that is prefixed with
    the name of the ReplicaSet followed by a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have created our first Deployment, let''s look at it in more detail
    to understand what actually happened during its creation. To do that, we can describe
    the Deployment we just created using the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Describing nginx-deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.8: Describing nginx-deployment'
  prefs: []
  type: TYPE_NORMAL
- en: This output shows various details about the Deployment we just created. In the
    following subtopics, we will go through the highlighted sections of the preceding
    output to understand the Deployment that's running.
  prefs: []
  type: TYPE_NORMAL
- en: Labels and Annotations on the Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to ReplicaSets, we can see the following line highlighted in the output
    shown in *Figure 7.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This indicates that the Deployment was created with an `app=nginx` label. Now,
    let''s consider the next field in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: There are two annotations added to the Deployment automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Revision annotation**'
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes controller adds an annotation with the `deployment.kubernetes.io/revision`
    key, which contains information about how many revisions have been there for a
    particular Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '**The last-applied-configuration annotation**'
  prefs: []
  type: TYPE_NORMAL
- en: Another annotation added by the controller has the `kubectl.kubernetes.io/last-applied-configuration`
    key, which contains the last configuration (in JSON format) that was applied to
    the Deployment. This annotation is particularly helpful in rolling back a Deployment
    to a previous revision if a new revision doesn't work well.
  prefs: []
  type: TYPE_NORMAL
- en: Selectors for the Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, consider the following line from the output shown in *Figure 7.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This shows which Pod selectors the Deployment is configured with. So, this Deployment
    will try to acquire the Pods that have both of these labels.
  prefs: []
  type: TYPE_NORMAL
- en: Replicas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following line from the output shown in *Figure 7.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Deployment has the desired count of `3` for the Pods, and
    it also shows that there are currently `3` replicas present.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Back a Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a real-life scenario, you may make a mistake when making a change in the
    Deployment configuration. You can easily undo a change and roll back to a previous
    stable revision of the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `kubectl rollout` command to check the revision history and
    rollback. But to make this work, we also need to use the `--record` flag when
    we use any `apply` or `set` commands to modify the Deployment. This flag records
    the rollout history. Then, you can view the rollout history using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can undo any updates by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at how this works in the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.06: Rolling Back a Deployment'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will update the Deployment twice. We will make an intentional
    mistake in the second update and try to roll back to a previous revision:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `app-deployment.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check the rollout history of the newly created Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This output shows that the Deployment has no rollout history as of now.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first update, let''s change the name of the container to `nginx` instead
    of `nginx-container`. Update the content of the `app-deployment.yaml` file with
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only thing that has changed in this template is the container name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the changed configuration using the `kubectl apply` command with the
    `--record` flag. The `--record` flag ensures that the update to the Deployment
    is recorded in the rollout history of the Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note that the rollout history maintained by the `--record` flag is different
    from the past configs stored in the annotations, which we saw in the *Labels and
    Annotations on the Deployment* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for a few seconds to allow the Deployment to recreate the Pods with the
    updated Pod configuration, and then run the following command to check the rollout
    history of the Deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Checking the deployment history'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.9: Checking the deployment history'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see that the second revision of the Deployment was created.
    It also keeps track of what command was used to update the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s update the Deployment and assume that we made a mistake while
    doing so. In this example, we will update the container image to `ngnx` (note
    the intentional spelling error) instead of `nginx` using the `set image` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for a few seconds for Kubernetes to recreate the new containers, and then
    check the status of the Deployment rollout using the `kubectl rollout status`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In this output, we can see that none of the new replicas are ready yet. Press
    *Ctrl* + *C* to exit and proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check the state of the Pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: Checking the status of Pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.10: Checking the status of Pods'
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the output that the newly created Pod has failed with an `ImagePullBackOff`
    error, which means that the Pods aren't able to pull the image. This is expected
    because we have a typo in the name of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check the revision history of the Deployment again by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: Checking the rollout history of the Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.11: Checking the rollout history of the Deployment'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that a third revision of the Deployment was created using the `set
    image` command containing the typo. Now that we have pretended to have made a
    mistake in updating the Deployment, we will see how to undo this and roll back
    to the last stable revision of the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to roll back to the previous revision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in this output, the Deployment has not been rolled back to the
    previous revision. To practice, we may want to roll back to a revision different
    from the previous revision. We can use the `--to-revision` flag to specify the
    revision number to which we want to roll back. For example, in the preceding case,
    we could have used the following command and the result would have been exactly
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check the rollout history of the Deployment again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: The rollout history for the Deployment after rollback'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.12: The rollout history for the Deployment after rollback'
  prefs: []
  type: TYPE_NORMAL
- en: We can see in this output that a new revision was created, which applied the
    revision that was previously revision 2\. We can see that revision 2 is no longer
    present in the list of revisions. This is because rollouts are always done in
    a rolling-forward manner. This means that any time we update a revision, a new
    revision of a higher number is created. Similarly, in the case of a rollback to
    revision 2, revision 2 became revision 4.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we explored a lot of different possible operations relating
    to updating a Deployment, rolling it forward with some changes, tracking the history
    of a Deployment, undoing some changes, and rolling back to a previous revision.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: StatefulSets are used to manage stateful replicas. Similar to a Deployment,
    a StatefulSet creates and manages the specified number of Pod replicas from an
    identical Pod template. However, where StatefulSets differ from Deployments is
    that they maintain a unique identity for each of their Pods. So, even if all the
    Pods are of identical specs, they are not interchangeable. Each of the Pods has
    a sticky identity that can be used by the application code to manage the state
    of the application on a particular Pod. For a StatefulSet with *n* replicas, each
    Pod is assigned a unique integer ordinal between *0* and *n – 1*. The names of
    the Pods reflect the integer identity assigned to them. When a StatefulSet is
    created, all the Pods are created in the order of their integer ordinal.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the Pods managed by a StatefulSet will persist their sticky identity
    (integer ordinal) even if the Pod restarts. For example, if a particular Pod crashes
    or is deleted, a new Pod will be created and assigned the same sticky identity
    as that of the old Pod.
  prefs: []
  type: TYPE_NORMAL
- en: StatefulSet Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration of a StatefulSet is also very similar to that of a ReplicaSet.
    Here''s an example of StatefulSet configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding configuration, `apiVersion` for a StatefulSet
    is `apps/v1` and `kind` is `StatefulSet`. The rest of the fields are used in the
    same way as for ReplicaSets.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to implement StatefulSets on a multi-node cluster in *Chapter
    14*, *Running Stateful Components in Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases for StatefulSets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: StatefulSets are useful if you need persistent storage. Using a StatefulSet,
    you can partition the data and store it in different Pods. In this case, it would
    also be possible for a Pod to go down and a new Pod come up with the same identity
    and have the same partition of data previously stored by the old Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A StatefulSet can also be used if you require ordered updates or scaling. For
    example, if you want to create or update your Pods in the order of the identities
    assigned to them, using a StatefulSet is a good idea.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DaemonSets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DaemonSets are used to manage the creation of a particular Pod on all or a selected
    set of nodes in a cluster. If we configure a DaemonSet to create Pods on all nodes,
    then if new nodes are added to the cluster, new pods will be created to run on
    these new nodes. Similarly, if some nodes are removed from the cluster, the Pods
    running on these nodes will be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases for DaemonSets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logging: One of the most common use cases for a DaemonSet is to manage running
    a log collection Pod on all nodes. These Pods can be used to collect logs from
    all the nodes and then process them in a log processing pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Local data caching: A DaemonSet can also be used to manage caching Pods on
    all the nodes. These Pods can be used by other application Pods to store the cached
    data temporarily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monitoring: Another use case for a DaemonSet is to manage running monitoring
    Pods on all the nodes. This can be used to collect system- or application-level
    metrics for Pods running on a particular node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DaemonSet Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration of a DaemonSet is also very similar to that of a ReplicaSet
    or a Deployment. Here''s an example of DaemonSet configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding configuration, `apiVersion` for a DaemonSet is
    set to `apps/v1` and `kind` is set to `DaemonSet`. The rest of the fields are
    used in the same way as for ReplicaSets.
  prefs: []
  type: TYPE_NORMAL
- en: To limit the scope of this book, we will not cover the details for implementing DaemonSets.
  prefs: []
  type: TYPE_NORMAL
- en: Up until now in this chapter, you have learned about ReplicaSets, which help
    us manage several replicas of Pods running an application, and how a Deployment
    acts as a wrapper on a ReplicaSet to add some features to control rolling out
    updates and maintaining the update history, with the option of rolling back if
    needed. Then, we learned about StatefulSets, which are handy if we need to treat
    each replica as a unique entity. We also learned how DaemonSets allow us to schedule
    a Pod on each of our nodes.
  prefs: []
  type: TYPE_NORMAL
- en: All of these controllers have one common characteristic—they are useful for
    applications or workloads that are to be run continually. However, some workloads
    have a graceful conclusion, and there is no need to keep the Pods running after
    the task is done. For this, Kubernetes has a controller called a Job. Let's take
    a look at this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Job is a supervisor in Kubernetes that can be used to manage Pods that are
    supposed to run a determined task and then terminate gracefully. A Job creates
    the specified number of Pods and ensures that they successfully complete their
    workloads or tasks. When a Job is created, it creates and tracks the Pods that
    were specified in its configuration. When a specified number of Pods complete
    successfully, the Job is considered complete. If a Pod fails because of underlying
    node failures, the Job will create a new Pod to replace it. This also means that
    the application or code running on the Pod should be capable of gracefully handling
    a case where a new Pod comes up during the runtime of the process.
  prefs: []
  type: TYPE_NORMAL
- en: The Pods created by a Job aren't deleted following completion of the job. The
    Pods run to completion and stay in the cluster with a `Completed` status.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Job can be used in several different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest use case is to create a Job that runs only one Pod to completion.
    The Job will only create additional new Pods if the running pod fails. For example,
    a Job can be used for one-off or recurring data analysis work or for the training
    of a machine learning model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jobs can also be used for parallel processing. We can specify more than one
    successful Pod completion to ensure that the Job will complete only when a certain
    number of Pods have terminated successfully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Job Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The configuration of a Job follows a similar pattern to that of a ReplicaSet
    or a Deployment. Here''s an example of Job configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The `apiVersion` field for a Job object is set to `batch/v1`. The `batch` API
    group contains objects relating to batch processing jobs. The `kind` field is
    set to `Job`.
  prefs: []
  type: TYPE_NORMAL
- en: A Use Case for Jobs in Machine Learning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jobs are perfect for batch processes—processes that run for a certain amount
    of time before exiting. This makes Jobs ideal for many types of production machine
    learning tasks, such as feature engineering, cross-validation, model training,
    and batch inference. For instance, you can create a Kubernetes Job that trains
    a machine learning model and persists the model and training metadata to external
    storage. Then, you can create another Job to perform batch inference. This Job
    would create a Pod that fetches the pre-trained model from storage, loads both
    the model and data into memory, performs inference, and stores the predictions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.07: Creating a Simple Job That Finishes in Finite Time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create our first Job, which will run a container that
    simply waits for 10 seconds and then finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To successfully complete this exercise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `one-time-job.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create the Deployment using the `kubectl apply`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check the status of the Job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Job requires one completion and is not yet completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check the Pod running the Job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you should run this before the Job is complete to see the response
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Job has created a Pod named `one-time-job-bzz8l` to run
    the task specified in the Job template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, run the following command to check the logs for the Pod created by the Job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see logs similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Pod printed the date, waited for 20 seconds, and then printed
    `Bye` in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the status of the Job again by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Job has now been completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to verify that the Pod has run to completion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a response similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the Pod has a `Completed` status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to delete the job (as well as the Pod it created)
    for cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we created a one-time Job and verified that the Pod created
    by the Job runs to completion. Implementing Jobs for parallel tasks is a bit more
    complicated, and we will leave that out of this workshop for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's wrap this chapter up with an activity where we will create a Deployment
    and bring together several ideas learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 7.01: Creating a Deployment Running an Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a scenario where the product/application team you''re working with
    is now ready to put their application in production and they need your help to
    deploy it in a replicated and reliable manner. For the scope of this exercise,
    consider the following requirements for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: The default number of replicas should be 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, you can use the `nginx` image for the container running in the Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make sure all the Pods have the following two labels with corresponding values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The update strategy for the Deployment should be `RollingUpdate`. At worst,
    no more than half of the Pods can be down, and similarly, at no point should there
    be more than 150% of the desired count of Pods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should be able to perform the following tasks once the Deployment has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: Scale up the number of replicas to 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale down the number of replicas to 5.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you would want to create this Deployment to be in a different namespace
    to keep it separate from the rest of the stuff that you created during the previous
    exercises. So, feel free to create a namespace and create the Deployment in that
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the high-level steps to perform this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a namespace for this activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the Deployment configuration. Ensure that it meets all the requirements
    that are specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Deployment using the configuration from the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that six Pods were created by the Deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform both of the tasks mentioned previously and verify the number of Pods
    after performing each step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should be able to get the list of Pods to check whether you can scale up
    the number of Pods, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Checking whether the number of Pods is scaled up'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.13: Checking whether the number of Pods is scaled up'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you should also be able to scale down and check the number of Pods,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: Checking whether the number of Pods is scaled down'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B14870_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.14: Checking whether the number of Pods is scaled down'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at the following address: [https://packt.live/304PEoD](https://packt.live/304PEoD).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes treats Pods as ephemeral entities, and ideally you would not deploy
    any application or a microservice in an individual Pod. Kubernetes offers various
    controllers to leverage various benefits, including automatic replication, health
    monitoring, and automatic scaling.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered different kinds of controllers and understood when
    to use each of them. We created ReplicaSets and observed how they manage Pods.
    We learned when to use DaemonSets and StatefulSets. We also created a Deployment
    and learned how we can scale up and down the number of replicas and roll back
    to an earlier version of the Deployment. Finally, we learned how to create Jobs
    for one-time tasks. All of these controllers come into play when you want to deploy
    a production-ready application or workload, as you will see in the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can discover and access the Pods or
    replicas managed by a Deployment or a ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
