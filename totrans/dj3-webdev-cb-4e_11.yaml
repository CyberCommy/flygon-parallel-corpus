- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing views with mock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the user interface with Selenium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing APIs created using Django REST framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure the quality and correctness of your code, you should have automated
    software tests. Django provides tools for you to write test suites for your website.
    Test suites automatically check your website and its components to ensure that
    everything is working correctly. When you modify your code, you can run the tests
    to check whether your changes affected the application's behavior negatively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The world of automated software testing has a wide range of divisions and terminologies.
    For the sake of this book, we will divide testing into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing** refers to tests that are strictly targeted at individual pieces,
    or units, of code. Most commonly, a unit corresponds to a single file or module,
    and unit tests do their best to validate that the logic and behaviors are as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing** goes one step further, dealing with the way that two
    or more units work with one another. Such tests do not get as granular as unit
    tests, and they are generally written under the assumption that all unit tests
    have passed by the time an integration is validated. Hence, integration tests
    only cover the set of behaviors that must be true for the units to work properly
    with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component interface testing** is a higher-order form of integration testing,
    in which a single component is verified from end to end. Such tests are written
    in a way that is ignorant of the underlying logic used to provide the behaviors
    of the component, so that logic can change without modifying the behavior, and
    the tests will still pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System testing** verifies the end-to-end integration of all components that
    make up a system, often corresponding to complete user flows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational acceptance testing** checks that all of the non-functional aspects
    of a system operate correctly. Acceptance tests check the business logic to find
    out whether the project works the way it is supposed to, from an end user''s point
    of view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For working with the code in this chapter, you will need the latest stable version
    of Python, a MySQL or PostgreSQL database, and a Django project with a virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all of the code for this chapter at the `ch11` directory of the
    GitHub repository at: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing views with mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will take a look at how to write unit tests. Unit tests are
    those that check whether individual functions or methods return the correct results.
    We will look at the `likes` app and write tests that check whether posting to
    the `json_set_like()` view returns a failure response for unauthenticated users
    and a successful result for authenticated users. We will use `Mock` objects to
    simulate the `HttpRequest` and `AnonymousUser` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the `locations` and `likes` apps from the *Implementing the
    Like widget* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the `mock` library, which has been available as a built-in
    at `unittest.mock` since Python 3.3.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will test the liking action with `mock` by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `tests` module in your `likes` app
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this module, create a `test_views.py` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests for the `likes` app, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run tests for the `likes` app, at first, a temporary test database
    is created. Then, the `setUpClass()` method is called. Later, the methods whose
    names start with `test` are executed, and, finally, the `tearDownClass()` method
    is called. For each passed test, you will see a dot (.) in the command-line tool,
    for each failed test there will be the letter F, and for each error in the tests,
    you will see the letter E. At the end, you will see hints about the failed and
    erroneous tests. As we currently have only two tests in the suite for the `likes`
    app, you will see two dots in the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `setUpClass()`, we create a location and a superuser. Also, we find out
    the `ContentType` object for the `Location` model. We will need it for the `json_set_like()`
    view that sets or removes likes for different objects. As a reminder, the view
    looks similar to the following, and returns a JSON string as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `test_authenticated_json_set_like()` and `test_anonymous_json_set_like()`
    methods, we use the `Mock` objects. These are objects that can have any attributes
    or methods. Each undefined attribute or method of a `Mock` object is another `Mock`
    object. Therefore, in the shell, you can try to chain attributes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our tests, we use `Mock` objects to simulate the `HttpRequest` object. For
    the anonymous user, `MockUser` is generated as a patch of the standard Django
    `User` object, via the `@mock.patch()` decorator. For the authenticated user,
    we still need the real `User` object because the view uses the user's ID for the `Like` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we call the `json_set_like()` function, and check that the returned
    JSON response is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns `{"success": false}` in the response if the visitor is unauthenticated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns something like `{"action": "add", "count": 1, "success": true}`
    for authenticated users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, the `tearDownClass()` class method is called, deleting the location
    and superuser from the test database.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To test something that uses the `HttpRequest` object, you can also use Django
    Request Factory. You can read how to use it at [https://docs.djangoproject.com/en/3.0/topics/testing/advanced/#the-request-factory](https://docs.djangoproject.com/en/3.0/topics/testing/advanced/#the-request-factory).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing the user interface with Selenium* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing APIs created using Django REST framework* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Ensuring test coverage* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the user interface with Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Operational acceptance tests** check the business logic to know whether the
    project works the way it is supposed to. In this recipe, you will learn how to
    write acceptance tests with **Selenium**, which allows you to simulate activities
    at the frontend such as filling in forms or clicking on specific DOM elements
    in a browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the `locations` and `likes` apps from the *Implementing the
    Like widget* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we''ll be using the Selenium library with the **Chrome** browser
    and **ChromeDriver** to control it. Let''s prepare that:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the Chrome browser from [https://www.google.com/chrome/](https://www.google.com/chrome/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `drivers` directory in your Django project. Download the latest stable
    version of ChromeDriver from [https://sites.google.com/a/chromium.org/chromedriver/](https://sites.google.com/a/chromium.org/chromedriver/),
    unzip it, and place it into the newly created `drivers` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install Selenium in your virtual environment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will test the Ajax-based liking functionality with Selenium by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your project settings, add a `TESTS_SHOW_BROWSER` setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `tests` module in your `locations` app and add a `test_frontend.py`
    file in it with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests for the `locations` app, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run these tests, we will see a Chrome window opened with the administration
    login screen under the URL, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:63807/en/admin/login/?next=/en/locations/176255a9-9c07-4542-8324-83ac0d21b7c3/`.'
  prefs: []
  type: TYPE_NORMAL
- en: The username and password fields will get filled in with admin and you will
    get redirected to the detail page of the Park Güell location, under such a URL
    as
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:63807/en/locations/176255a9-9c07-4542-8324-83ac0d21b7c3/`.
    There you will see the Like button clicked twice, causing liking and unliking
    actions.'
  prefs: []
  type: TYPE_NORMAL
- en: If we change the `TESTS_SHOW_BROWSER` setting to `False` (or remove it all)
    and run the tests again, the testing will happen with minimal waiting time and
    in the background without opening a browser's window.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works in the test suite. We define a class extending `LiveServerTestCase`.
    This creates a test suite that will run a local server under a random unused port
    such as `63807`. By default, `LiveServerTestCase` runs a server in non-DEBUG mode.
    But we switch it to the DEBUG mode using the `override_settings()` decorator to
    make the static files accessible without collecting them and to show error traceback
    if any errors happen on any page. The `setUpClass()` class method will be executed
    at the beginning of all of the tests and the `tearDownClass()` class method will
    be executed after the tests have been run. In the middle, the testing will execute
    all the methods of the suite whose names start with `test`.
  prefs: []
  type: TYPE_NORMAL
- en: When we start testing, a new test database is created. In `setUpClass()`, we
    create a browser object, one location, and one superuser. Then, the `test_login_and_like()`
    method is executed, which opens the administration login page, finds the username
    field, types in the administrator's username, finds the password field, types
    in the administrator's password, finds the submit button, and clicks on it. Then,
    it waits a maximum of 10 seconds until a DOM element with the `.like-button` CSS
    class can be found on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might remember from the *Implementing the Like widget* recipe in [Chapter
    4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*, Templates and JavaScript*, our
    widget consists of two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A Like button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A badge showing the total number of likes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a button is clicked, your `Like` instance is either added or removed from
    the database by an Ajax call. Moreover, the badge count is updated to reflect
    the number of likes in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Further in the test, we check what is the initial state of the button (whether
    it has an `.active` CSS class or not), check the initial number of likes, and
    simulate a click on the button. We wait a maximum of 10 seconds until the count
    in the badge changes. Then, we check whether the count in the badge matches the
    total likes for the location in the database. We will also check how the count
    in the badge has changed (increased). Lastly, we will simulate the click on the
    button again to switch back to the previous state.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `tearDownClass()` method is called, which closes the browser and
    removes the location and the superuser from the test database.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Implementing the Like widget* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing views with mock* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing API created using Django REST framework* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Ensuring test coverage* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing APIs created using Django REST framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should already have an understanding of how to write unit and operational
    acceptance tests. In this recipe, we will go through **component interface testing**
    for the RESTful API that we created earlier in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with what a RESTful API is and how APIs are used, you
    can learn more at [http://www.restapitutorial.com/](http://www.restapitutorial.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the `music` app from the *Using Django REST framework* *to
    create APIs* recipe in [Chapter 9](1979103c-ef2a-44d8-a94d-d18e57688503.xhtml)*,
    Importing and Exporting Data*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test RESTful APIs, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `tests` module in your `music` app. In the `tests` module, create
    a `test_api.py` file with the `SongTests` class. The class will have `setUpClass()`
    and `tearDownClass()` methods, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API test checking the listing songs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API test checking the details of a single song:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an API test checking for the successful creation of a new song:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test that tries to create a song without authentication and failing,
    therefore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test for checking the successful changing of a song:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test checking for failed changes because of missing authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test checking for the failed deletion of a song:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test checking for the successful deletion of a song:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests for the `music` app, as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This RESTful API test suite extends the `APITestCase` class. Once again, we
    have the `setUpClass()` and `tearDownClass()` class methods that will be executed
    before and after the different tests. Also, the test suite has a client attribute
    of the `APIClient` type, which can be used to simulate API calls. The client provides
    methods for all standard HTTP calls: `get()`, `post()`, `put()`, `patch()`, `delete()`,
    `head()`, and `options()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our tests, we are using the `GET`, `POST`, and `DELETE` requests. Also,
    the client has methods to force the authentication of a user based on login credentials,
    a token, or a `User` object. In our tests, we are authenticating the third way:
    passing a user directly to the `force_authenticate()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code is self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using Django REST framework to create APIs* recipe in [Chapter 9](1979103c-ef2a-44d8-a94d-d18e57688503.xhtml)*,
    Importing and Exporting Data*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing views with mock* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing the user interface with Selenium* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Ensuring test coverage* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django allows the rapid prototyping and building of a project from idea to realization
    in a timely manner. But to make sure that your project is stable and production-ready,
    you should have tests for as many functionalities as possible. With test coverage,
    you can check how much of your project code is tested. Let's have a look at how
    you can do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have some tests ready for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `coverage` utility in your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how to check the test coverage of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `setup.cfg` configuration file for the coverage utility with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to have these lines in the `.gitignore` file if you are using Git
    version control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a shell script, `run_tests_with_coverage.sh`, with the commands to run
    tests with coverage and report the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add execution permissions for that script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coverage utility runs the tests and checks how many lines of code are covered
    by tests. In our example, the tests we wrote covered 48% of the code. If project
    stability is important to you, when you have time, seek to get closer to 100%.
  prefs: []
  type: TYPE_NORMAL
- en: In the coverage configuration, we skipped the static assets, templates, and
    other non-Python files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Testing views with mock* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing the user interface with Selenium* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Testing APIs created using Django REST framework* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
