- en: Chapter 9. Demonstrating Functional Reactive Programming in JavaScript with
    a Live Example Part II – A To-do List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be walking through a to-do list. This to-do list will
    illustrate a slightly obscure kind of two-way data binding. ReactJS''s forte is
    via one-way data binding, and most problems, solved in the idiomatic ReactJS fashion,
    will normally follow the von Neumann model with one-way data binding (it is claimed
    that two-way data binding is usually not needed, and articles such as *AngularJS:
    The Bad Parts* suggest that two-way binding carries a heavy price tag by default,
    especially as far as scaling is concerned).'
  prefs: []
  type: TYPE_NORMAL
- en: If we build our to-do list in an obvious way, the checkboxes will be unresponsive.
    We can click on them as much as we want, but they will never be checked because
    one-way data binding uses props—or in our case, the state—to determine whether
    they will be checked. We will make a foray into two-way data binding, which means
    that not only will the checkboxes be live, but also clicking on a checkbox will
    update the state. This means that what is displayed in the user interface, and
    what is behind the scenes as the state are kept in sync with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The to-do list, as a distinctive feature, offers more than **Done** or **Not
    done** as a status. It has checkboxes for **Important**, **In Progress**, **Problems**,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be a walkthrough of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The nuts and bolts of using add-ons as in two-way data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the appropriate initial state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making text inside a `TEXTAREA` editable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `render()` function that does some heavy lifting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inner functions used by `render()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the table to display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering our result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distinguishing the columns visually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a to-do list to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you implemented a `YouPick` placeholder for an application
    of your own to create. Here, we will be commenting it out so as to display only
    our to-do application (we can, and we will, arrange things in different parts
    of the screen, but now we are displaying only one thing at a time). In JSX, the
    way to comment out code is to wrap it in a C-style multiline comment, and then
    wrap that in curly braces, so `<YouPick /> becomes {/* <YouPick /> */}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Including ReactJS add-ons in our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will open the `Todo` class and include the `React.addons.LinkedStateMixin`
    function. Note that we are using an add-on here, and this means that when we include
    ReactJS in our page, we need to include a build containing add-ons. So, consider
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of it, we include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The opening of the `Todo` class reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setting the appropriate initial state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial state is empty; there are no to-do items on the list, and there
    is empty text for any new to-do item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that some initial state setting may involve heavy lifting; here, it is
    quite simple, but this need not always be the case.
  prefs: []
  type: TYPE_NORMAL
- en: Making text editable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a minor housekeeping detail, we want obvious behavior when someone types
    in the box. Hence we define a two-way data binding for the TEXTAREA so that if
    someone types in the TEXTAREA, the change is added to the state, and overflows
    back to the TEXTAREA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If someone submits a new to-do item by hitting the **Submit** button after
    entering some text, we add that item to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Heavy lifting with render()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `render()` function is slightly more involved, containing inner functions
    and much of the heavy lifting of a responsive user interface based on two-way
    data binding. Just inside of it, we use the `var that=this;` pattern, which is
    absent from most ReactJS code. In most of ReactJS, we can just use this and it
    works automagically; here we are defining inner functions that are not as directly
    built as other ReactJS functions, and we retain a reference to the this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inner functions used to render
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `table_rows` array will hold to-do items. Having defined these, we define
    our first inner anonymous function, `handle_change()`. If the user clicks on one
    of the checkboxes for a to-do item, we extract the HTML ID, which tells its to-do
    item''s ID, as well as which field (that is, checkbox identifier) has been toggled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display_item_details()` function is the lowest of a few functions used
    to build up the display. It builds up an individual TD containing a checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `display_item()` uses these building blocks to build the display for
    a to-do item. Besides including the rendered nodes, that is, checkboxes, it applies
    markdown formatting to the text in the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Building the result table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For each item, we add a table row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a JSX expression that includes various values calculated so far is
    returned, and it wraps them in a full-featured table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is left as an exercise for you to hide and display rows of data when checkboxes
    that should hide and display them are checked.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s one brief remark about the use of tables: there has been a shift from
    primarily using tables to primarily using CSS for formatting. However, the exact
    rule concerning the use of tables is not precisely "don''t use tables at all"
    or "only use tables when you really have to," but "use tables for tabular data."
    This means grids, such as what we displayed here. The table with its grid of checkboxes
    is a good example of a situation where tables are perfectly appropriate in the
    current markup.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering our result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our result will render only when we tell it to; this can be seen as a chore,
    or as an added degree of freedom on our end. Before we end the closure, we write
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Differentiating columns visually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At present, our undifferentiated grid of checkboxes runs together. We could
    do several things to differentiate them. A spectrum of colors in the `index.html`
    CSS differentiates them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a walkthrough of a slightly-more-than-minimal to-do
    list. As far as functionality is concerned, we saw an interactive form built in
    a way that includes two-way data binding. ReactJS's usual recommendation is that
    most of the time, you think you need two-way data binding, but you would really
    be better off just using one-way data binding. However, the framework does not
    seem to be intended as a straightjacket, and where ReactJS says, "You usually
    shouldn't do X," there is a way to do X. For both dangerouslySetInnerHTML and
    two-way data binding, you can opt into it on specific points, but every effort
    has been made to opt for better engineering. The `dangerouslySetInnerHTML` function
    is a singularly forceful way to name something, and the clearly expressed opinion
    of the ReactJS team is that the von Neumann model calls for one-way data binding,
    at least in most cases. However, the ReactJS philosophy explicitly allows developers
    to use features they think are best to usually avoid; the final verdict is with
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Join us in our next chapter as we create a calendar application that handles
    recurring appointments gracefully.
  prefs: []
  type: TYPE_NORMAL
