- en: Chapter 1. JShell – A Read-Evaluate-Print-Loop for Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start our journey toward object-oriented programming
    with Java 9\. You will learn how to launch and work with a new utility introduced
    with Java 9 that will allow us to easily run Java 9 code snippets and print their
    results: JShell. This utility will make it easy for you to learn object-oriented
    programming. We will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Get ready for our journey toward **OOP** (**Object-Oriented Programming**) with
    Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the required software on Windows, macOS, or Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the benefits of working with a **REPL** (**Read-Evaluate-Print-Loop**)
    utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check default imports and use auto-complete features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run Java 9 code in JShell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with variables, methods, and sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the source code in our favorite external code editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready for our journey toward OOP with Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, you will learn to take advantage of all the object-oriented features
    included in the Java programming language version 9, known as Java 9\. Some of
    the examples might be compatible with previous Java versions, such as Java 8,
    Java 7, and Java 6, but it is essential to use Java 9 or later because this version
    is not backwards compatible. We won't write code that is backwards compatible
    with previous Java versions because our main goal is to work with Java 9 or later
    and to use its syntax and all of its new features.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, we won't use any **IDE** (**Integrated Development Environment**),
    and we will take advantage of JShell and many other utilities included in the
    JDK. However, you can use any IDE that provides a Java 9 REPL to work with all
    the examples. You will understand the benefits of working with a REPL in the next
    sections. You will definitely benefit from an IDE in the last chapter where you
    will explore the new modularity features introduced with Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You don't need any previous experience with the Java programming language to
    work with the examples in the book and learn how to model and create object-oriented
    code with Java 9\. If you have some experience with C#, C++, Python, Swift, Objective-C,
    Ruby, or JavaScript, you will be able to easily learn Java's syntax and understand
    the examples. Many modern programming languages have been borrowing features from
    Java and vice versa. Therefore, any knowledge of these languages will be extremely
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will install the required software on Windows, macOS, or
    Linux. We will understand the benefits of working with a REPL, specifically, JShell,
    to learn object-oriented programming. We will learn how to run Java 9 code in
    the JShell and how to load the source code samples in the REPL. Finally, we will
    learn how to run Java code on Windows, macOS, and Linux from the command line
    or terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required software on Windows, macOS, or Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We must download and install the latest version of **JDK 9** (**Java Development
    Kit 9**) for our operating system from [https://jdk9.java.net/download/](https://jdk9.java.net/download/).
    We must accept the license agreement for Java to download the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'As happened with previous versions, JDK 9 is available on many different platforms,
    including but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows 32-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 64-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS 64-bit (formerly known as Mac OS X or simply OS X)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux 32-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux 64-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux on ARM 32-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux on ARM 64-bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have completed the installation for the appropriate version of JDK 9
    based on our operating system, we can add the `bin` sub-folder of the folder in
    which JDK 9 has been installed to the `PATH` environment variable. This way, we
    would be able to launch the different utilities from any folder in which we are
    located.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we don't add the `bin` sub-folder of the folder in which JDK 9 has been installed
    to the `PATH` environment variable in our operating system, we will always have
    to use the full path to the `bin` sub-folder when executing the commands. In the
    next instructions to launch the different Java command-line utilities, we will
    assume that we are located in this `bin` sub-folder or that the `PATH` environment
    variable includes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have installed JDK 9, and added the `bin` folder to the `PATH` environment
    variable, we can run the following command in Windows Command Prompt or in macOS
    or Linux Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will display the current version for the primary Java
    compiler included in the JDK that compiles Java source code into Java bytecodes.
    The version number should start with 9, as shown in the next sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If the results of the previous command display a version number that doesn't
    start with 9, we must check whether the installation completed successfully. In
    addition, we have to make sure that the `PATH` environment variable doesn't include
    paths to previous versions of the JDK and that it includes the `bin` folder for
    the recently installed JDK 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to launch JShell. Run the following command in Windows Command
    Prompt or in macOS or Linux Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will launch JShell, display a welcome message that includes
    the JDK version being used, and the prompt will change to `jshell>`. Whenever
    we see this prompt, it means we are still in JShell. The following screenshot
    shows JShell running in a Terminal window on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the required software on Windows, macOS, or Linux](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to leave JShell at any time, we just need to press *Ctrl* + *D* in
    a Mac. Another option is to enter `/exit` and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the benefits of working with a REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Java 9 introduced an interactive REPL command-line environment named JShell.
    This tool allows us to execute Java code snippets and get immediate results. We
    can easily write code and see the results of its execution without having to create
    a solution or project. We don't have to wait for the project to finish the build
    process to check the results of executing many lines of code. JShell, as any other
    REPL, facilitates exploratory programming, that is, we can easily and interactively
    try and debug different algorithms and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have worked with other programming languages that provide a REPL or an
    interactive shell such as Python, Scala, Clojure, F#, Ruby, Smalltalk, and Swift
    among many others, you already know the benefits of working with a REPL.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine that we have to interact with an **IoT** (**Internet of
    Things**) library that provides Java bindings. We have to write Java code to use
    the library to control a drone, also known as a **UAV** (**Unmanned Aerial Vehicle**).
    The drone is an IoT device that interacts with many sensors and actuators, including
    digital electronic speed controllers linked to engines, propellers, and servomotors.
  prefs: []
  type: TYPE_NORMAL
- en: We want to be able to write a few lines of code to retrieve data from sensors
    and control the actuators. We just need to make sure things work as explained
    in the documentation. We want to make sure that the values read from the altimeter
    change when we move the drone. JShell provides us with the appropriate tool to
    start interacting with the library in a few seconds. We just need to launch JShell,
    load the library, and start writing Java 9 code in the REPL. With previous Java
    versions, we would have needed to create a new project from scratch and write
    some boilerplate code before we could start writing the first lines of code that
    interacted with the library. JShell allows us to start working faster and reduces
    the need to create an entire skeleton to start running Java 9 code. JShell allows
    interactive exploration of **APIs** (**Application Programming Interfaces**) from
    a REPL.
  prefs: []
  type: TYPE_NORMAL
- en: We can enter any Java 9 definition in JShell. For example, we can declare methods,
    classes, and variables. We can also enter Java expressions, statements, or imports.
    Once we have entered the code to declare a method, we can enter a statement that
    uses the previously defined method and see the results of the execution.
  prefs: []
  type: TYPE_NORMAL
- en: JShell allows us to load source code from a file, and therefore, you will be
    able to load the source code samples included in this book and evaluate them in
    JShell. Whenever we have to work with source code, you will know the folder and
    the file from which you can load it. In addition, JShell allows us to execute
    JShell commands. We will learn about the most useful commands later, in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: JShell allows us to call the `System.out.printf` method to easily format output
    we want to print. We will take advantage of this method in our sample code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JShell disables some features from Java 9 that aren't useful in the interactive
    REPL. Whenever we have to work with these features in JShell, we will make it
    clear that JShell will disable them and we will explain their effects.
  prefs: []
  type: TYPE_NORMAL
- en: The semicolon (`;`) is optional at the end of a statement in JShell. However,
    we will always use a semicolon at the end of each statement because we don't want
    to forget that we must use semicolons when we write real-life Java 9 code in projects
    and solutions. We will only omit the semicolon at the end of a statement when
    we enter expressions to be evaluated by JShell.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following two lines are equivalent and both of them will print
    `"Object-Oriented Programming rocks with Java 9!"` as a result of their execution
    in JShell. The first line doesn't include a semicolon (`;`) at the end of the
    statement and the second line includes the semicolon (`;`). We will always use
    the semicolon (;) as in the second line, to keep consistency.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the two lines in JShell
    running on Windows 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the benefits of working with a REPL](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In some examples, we will take advantage of the fact that JShell provides us
    networking access. This feature is extremely useful to interact with Web Services.
    However, you have to make sure that you don't have JShell blocked in your firewall
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unluckily, at the time I was writing this book, JShell didn't include syntax
    highlighting features. However, you will learn how to use our favorite editor
    to write and edit code that we can then execute in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: Checking default imports and using auto-complete features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, JShell provides a set of common imports and we can use the `import`
    statement to import the necessary types from any additional package we might need
    to run our code snippets. We can enter the following command in JShell to list
    all the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the results of the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As happens when we write Java code outside of JShell, we don''t need to import
    the types from the `java.lang` package because they are imported by default and
    they aren''t listed when we run the `/imports` command in JShell. Thus, by default,
    JShell provides us access to all the types in the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.lang`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.math`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.net`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.nio.file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.concurrent`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.prefs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.regex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.util.stream`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JShell provides auto-completion features. We just need to press the *Tab* key
    whenever we want to have assistance from the auto-complete feature, as done when
    we work with the Windows Command Prompt or the Terminal in macOS or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, there are too many options that start with the first characters
    we entered. In these cases, JShell provides us with a list of all the available
    options to provide us help. For example, we can enter `S` and press the *Tab*
    key. JShell will list all the types imported from the previously listed packages
    that start with an `S`. The following screenshot shows the results in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking default imports and using auto-complete features](img/00004.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We want to enter `System`. Considering the previous list, we will just enter
    `Sys` to make sure that `System` is the only option that starts with `Sys`. Basically,
    we are cheating to understand how auto-completion works in JShell. Enter `Sys`
    and press the *Tab* key. JShell will display `System`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, enter a dot (`.`) followed by an `o` (you will have `System.o`) and press
    the *Tab* key. JShell will display `System.out`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter a dot (`.`) and press the *Tab* key. JShell will display all the
    public methods declared in `System.out`. After the list, JShell will include `System.out.`
    again to allow us to continue entering our code. The following screenshot shows
    the results in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking default imports and using auto-complete features](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter `printl` and press the *Tab* key. JShell will complete to `System.out.println(`,
    that is, it will add an `n` and open parenthesis (`(`). This way, we just have
    to enter the arguments for the method because there was just one method that started
    with `printl`. Enter `"Auto-complete is helpful in JShell");` and press *Enter*.
    The following line shows the complete statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results in JShell after running the previous
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking default imports and using auto-complete features](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running Java 9 code in JShell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous lines, JShell will display the next message indicating
    it has created a method named `calculateRectangleArea` with two arguments of `float`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that all the messages written by JShell start with a pipe symbol (`|`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command in JShell to list the current active snippets of
    code that we have typed and executed so far in the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to create a new `float` variable named `width`
    and initialize it with `50`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has created a variable named `width` of `float` type and it assigned the value
    `50.0` to this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to create a new `float` variable named `height`
    and initialize it with `25`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has created a variable named `height` of the `float` type and it assigned the
    value `25.0` to this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter `float area = ca` and press the *Tab* key. JShell will complete to `float
    area = calculateRectangleArea(`, that is, it will add `lculateRectangleArea` and
    open parenthesis (`(`). This way, we just have to enter the two arguments for
    the method because there was just one method that started with `ca`. Enter `width,
    height);` and press *Enter*. The following line shows the complete statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After we enter the previous line, JShell will display the next message indicating
    it has created a variable named `area` of the `float` type and it assigned the
    result of calling the `calculateRectangleArea` method with the previously declared
    `width` and `height` variables as arguments. The method returns `1250.0` as a
    result and it is assigned to the `area` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following command in JShell to list the current active snippets of
    code that we have typed and executed so far in the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Enter the following code in JShell to display the values for the `width`, `height`,
    and `area` variables with a call to `System.out.printf`. The first `%.2f` in the
    string we pass as a first argument to `System.out.printf` makes the next argument
    after the string (`width`) to be displayed as a floating point number with two
    decimal places. We repeat `%.2f` twice to display the `height` and `area` variables
    as floating point numbers with two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will format the output with `System.out.printf`
    and will print the next message followed by the name of a scratch variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JShell allows us to evaluate any valid Java 9 expression, as we might do when
    we use an IDE and the typical expression evaluation dialog box. Enter the following
    expression in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will evaluate the expression and it
    will assign the results to a scratch variable whose name starts with `$` and continues
    with a number. JShell displays the scratch variable name, `$6`, the value assigned
    to the variable that indicates the result of evaluating the expression, `1250.0`,
    and the type for the scratch variable, `float`. The next lines show the message
    displayed in JShell after we enter the previous expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will format the output with `System.out.printf`
    and will print the next message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We can also use the previously created scratch variable in another expression.
    Enter the following code in JShell to add `10.5` (`float`) to the value of the
    `$6` variable. Make sure you replace `$6` with the scratch variable name that
    JShell generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will evaluate the expression and it
    will assign the results to a new scratch variable whose name starts with `$` and
    continues with a number. JShell displays the scratch variable name, `$8`, the
    value assigned to the variable that indicates the result of evaluating the expression,
    `1260.5`, and the type for the scratch variable, `float`. The next lines show
    the message displayed in JShell after we enter the previous expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As happened before, the name for the scratch variable might be different. For
    example, instead of `$8`, it might be `$9` or `$10`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with variables, methods, and sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been creating many variables, and JShell created a few scratch
    variables after we entered expressions and they were successfully evaluated. Enter
    the following command in JShell to list the type, name, and value of the current
    active variables that have been created so far in the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to assign `80.25` (`float`) to the previously
    created `width` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has assigned `80.25` (`float`) to the existing variable named `width` of the
    `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to assign `40.5` (`float`) to the previously
    created `height` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has assigned `40.5` (`float`) to the existing variable named `height` of the
    `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following command in JShell again to list the type, name, and value
    of the current active variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the results that reflect the new values we have assigned
    to the `width` and `height` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Enter the following code in JShell to create a new method named `calculateRectanglePerimeter`.
    The method receives a `width` variable and a `height` variable for a rectangle
    and returns the result of the multiplication by `2` of the sum of both values
    of the `float` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous lines, JShell will display the next message indicating
    it has created a method named `calculateRectanglePerimeter` with two arguments
    of the `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following command in JShell to list the name, parameter types, and
    return the type of the current active methods that have been created so far in
    the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to print the results of calling the recently
    created `calculateRectanglePerimeter` with `width` and `height` as the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will call the method and it will assign
    the results to a scratch variable whose name starts with `$` and continues with
    a number. JShell displays the scratch variable name, `$16`, the value assigned
    to the variable that indicates the result returned by the method, `241.5`, and
    the type for the scratch variable, `float`. The next lines show the message displayed
    in JShell after we enter the previous expression that called a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to make changes to the recently created `calculateRectanglePerimeter`
    method. We want to add a line to print the calculated perimeter. Enter the following
    command in JShell to list the source code for the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to overwrite the method named `calculateRectanglePerimeter`
    with a new code that prints the received width and height values and then prints
    the calculated perimeter with calls to the `System.out.printf` method that works
    in the same way as the built-in `printf` method. We can copy and paste the pieces
    from the previously listed source code. The changes are highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous lines, JShell will display the next messages indicating
    it has modified and overwritten the method named `calculateRectanglePerimeter`
    with two arguments of the `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to print out the results of calling the
    recently modified `calculateRectanglePerimeter` with `width` and `height` as the
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: After we enter the previous line, JShell will call the method and it will assign
    the results to a scratch variable whose name starts with `$` and continues with
    a number. The first lines display the output generated by the three calls to `System.out.printf`
    that we added to the method. Finally, JShell displays the scratch variable name,
    `$19`, the value assigned to the variable that indicates the result returned by
    the method, `241.5`, and the type for the scratch variable, `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next lines show the messages displayed in JShell after we enter the previous
    expression that called the new version of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Editing the source code in our favorite external code editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a new version of the `calculateRectanglePerimeter` method. Now, we
    want to make similar changes to the `calculateRectangleArea` method. However,
    this time, we will take advantage of an editor to make it easier to make changes
    to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following command in JShell to launch the default JShell Edit Pad
    editor to edit the source code for the `calculateRectangleArea` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will display a dialog box with JShell Edit Pad and the source code for
    the `calculateRectangleArea` method, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the source code in our favorite external code editor](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: JShell Edit Pad lacks most of the features we enjoy from code editors and we
    cannot even consider it a decent code editor. In fact, it just allows us to easily
    edit the source code without having to copy and paste from the previous listing.
    We will learn how to configure a better editor later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in the JShell Edit Pad to overwrite the method named
    `calculateRectangleArea` with a new code that prints the received width and height
    values and then prints the calculated area with calls to the `Sytem.out.printf`
    method. The changes are highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on **Accept** and then click on **Exit**. JShell will close the JShell
    Edit Pad and display the next messages indicating it has modified and overwritten
    the method named `calculateRectangleArea` with two arguments of the `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the following code in JShell to print the results of calling the recently
    modified `calculateRectangleArea` method with `width` and `height` as the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous line, JShell will call the method and it will assign
    the results to a scratch variable whose name starts with `$` and continues with
    a number. The first lines display the output generated by the three calls to `System.out.printf`
    that we added to the method. Finally, JShell displays the scratch variable name,
    `$24`, the value assigned to the variable that indicates the result returned by
    the method, `3250.125`, and the type for the scratch variable, `float`. The next
    lines show the messages displayed in JShell after we enter the previous expression
    that called the new version of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The good news is that JShell allows us to easily configure any external editor
    to edit the code snippets. We just need to grab the complete path to the editor
    we want to use and run a command in JShell to configure the editor we want to
    launch whenever we use the `/edit` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in Windows, the default installation path for the popular Sublime
    Text 3 code editor is `C:\Program Files\Sublime Text 3\sublime_text.exe`. If we
    want to use this editor to edit code snippets in JShell, we must run the `/set
    editor` command followed by the path enclosed in double quotes. We have to make
    sure that we replace the backslash (`\`) with double backslashes (`\\`) in the
    path string. For the previously explained path, we must run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous command, JShell will display a message indicating
    to us that the editor was set to the specified path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After we change the editor, we can enter the following command in JShell to
    launch the new editor to make changes to the source code for the `calculateRectangleArea`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will launch Sublime Text 3 or any other editor that we might have specified
    and will load a temporary file with the source code for the `calculateRectangleArea`
    method, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the source code in our favorite external code editor](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we save the changes, JShell will automatically overwrite the method as we
    did when we used the default editor: JShell Edit Pad. After we make the necessary
    edits, we must close the editor to continue running Java code or JShell commands
    in JShell.'
  prefs: []
  type: TYPE_NORMAL
- en: In any of the platforms, JShell will create a temporary file with the `.edit`
    extension. Thus, we can configure our favorite editor to use Java syntax highlighting
    whenever we open files with the `.edit` extension.
  prefs: []
  type: TYPE_NORMAL
- en: In macOS or Linux, paths are different than in Windows, and therefore, the necessary
    steps are different. For example, in macOS, in order to launch the popular Sublime
    Text 3 code editor when it is installed in the default path, we must run `/Applications/Sublime
    Text.app/Contents/SharedSupport/bin/subl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to use this editor to edit code snippets in JShell, we must run
    the `/set editor` command followed by the complete path enclosed in double quotes.
    For the previously explained path, we must run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous command, JShell will display a message indicating
    to us that the editor was set to the specified path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'After we change the editor, we can enter the following command in JShell to
    launch the new editor to make changes to the source code for the `calculateRectangleArea`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'JShell will launch Sublime Text 3 on macOS or any other editor that we might
    have specified and will load a temporary file with the source code for the `calculateRectangleArea`
    method, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the source code in our favorite external code editor](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Loading source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, we don't have to enter the source code for each example. Auto-completion
    features are useful, but we will take advantage of a command that allows us to
    load source code from a file in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press *Ctrl* + *D* to exit the current JShell session. Run the following command
    in the Windows Command Prompt or in a macOS or Linux Terminal to launch JShell
    again with a verbose feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show code that declares the latest versions of the `calculateRectanglePerimeter`
    and `calculateRectangleArea` methods. Then, the code declares and initializes
    two variables of the `float` type: `width` and `height`. Finally, the last two
    lines call the previously defined methods with `width` and `height` as their arguments.
    The code file for the sample is included in the `java_9_oop_chapter_01_01` folder,
    in the `example01_01.java` file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If the root folder for the source code in macOS or Linux is `~/Documents/Java9`,
    you can run the following command to load and execute the previously shown source
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'After we enter the previous command followed by the path based on our configuration
    and our operating system, JShell will load and execute the previously shown source
    code and will display the output generated after running the loaded code snippet.
    The following lines show the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter the following command in JShell to list the current, active snippets
    of code, loaded from the source file, that have been executed in the current session
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the results. Notice that JShell prefaces the different
    method definitions and expressions with different snippet ids because the loaded
    source code behaves in the same way as if we were entering one snippet after the
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you use the previously explained `/open` command followed by the path
    and the file name for the code file that you want to load and execute in JShell
    whenever you find source code in the book. This way, you won't have to enter each
    code snippet and you will be able to check the results of executing the code in
    JShell.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JShell is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java 9 REPL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An equivalent of `javac` in previous JDK versions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Java 9 bytecode decompiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'REPL means:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run-Expand-Process-Loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read-Evaluate-Process-Lock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read-Evaluate-Print-Loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following commands lists all the variables created in the current
    JShell session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/variables`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/vars`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/list-all-variables`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following commands lists all the methods created in the current
    JShell session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/methods`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/meth`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/list-all-methods`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following commands lists the source code evaluated so far in the
    current JShell session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/source`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/list`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`/list-source`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started our journey toward object-oriented programming
    with Java 9\. We learned how to launch and work with the new utility introduced
    with Java 9 that allows us to easily run Java 9 code snippets and print its results:
    JShell.'
  prefs: []
  type: TYPE_NORMAL
- en: We learned the necessary steps to install JDK 9 and we understood the benefits
    of working with a REPL. We learned to use JShell to run Java 9 code and evaluate
    expressions. We also learned many of its useful commands and features. We will
    use them in the forthcoming chapters when we will start working with object-oriented
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned to work with JShell, we will learn how to recognize
    real-world elements and translate them into the different components of the object-oriented
    paradigm supported in Java 9, which is what we are going to discuss in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
