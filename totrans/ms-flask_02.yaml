- en: Chapter 2. Creating Models with SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously stated, **models** are a means of abstracting and giving a common
    interface to data. In most web applications, data is stored and retrieved from
    a **Relational Database Management System** (**RDBMS**), which is a database that
    holds data in a tabular format with rows and columns and is able to compare data
    across tables. Some examples include MySQL, Postgres, Oracle, and MSSQL.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create models on top of our database, we will use a Python package
    named **SQLAlchemy**. SQLAlchemy is a database API at its lowest level and performs
    **Object Relational Mapping** (**ORM**) at its highest level. An ORM is a technique
    to pass and convert data between two sources with different types of systems and
    data structures. In this case, it converts data between the large amount of types
    in databases versus the mix of types and objects in Python. Also, a programming
    language such as Python allows you to have different objects that hold references
    to each other, and get and set their attributes. An ORM, such as SQLAlchemy, helps
    translate that into a traditional database.
  prefs: []
  type: TYPE_NORMAL
- en: In order to tie SQLAlchemy into our application context, we will use Flask SQLAlchemy.
    Flask SQLAlchemy is a convenience layer on top of SQLAlchemy that provides useful
    defaults and Flask-specific functions. If you are already familiar with SQLAlchemy,
    then you are free to use it without Flask SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a full database schema of our blogging
    application as well as models interacting with that schema.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along in this chapter, you will need a running database if
    you do not already have one. If you have never installed a database or you do
    not have a preference, SQLite is the best option for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLite** is a SQL that is fast, works without a server, and is entirely contained
    in one file. Also, SQLite is natively supported in python. If you choose to go
    with SQLite, a SQLite database will be created for you in the *Our first model*
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Python packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Flask SQLAlchemy with `pip`, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to install specific packages for the database you chose to
    use that will act as the connector for SQLAlchemy. SQLite users can skip this
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Flask SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can abstract our data, we need to set up Flask SQLAlchemy. SQLAlchemy
    creates its database connection through a special database URI. This is a string
    that looks like a URL that contains all the information that SQLAlchemy needs
    to connect. It takes the general form of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For each driver you installed previously, the URI would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `config.py` file, add the URI to the `DevConfig` file with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our first model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noted that we did not actually create any tables in our database
    to abstract off of. This is because SQLAlchemy allows us to create either models
    from tables or tables from our models. This will be covered after we create the
    first model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main.py` file, SQLAlchemy must first be initialized with our app as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy will read our app''s configuration and automatically connect to
    our database. Let''s create a `User` model to interact with a user table in the
    `main.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What have we accomplished? We now have a model that is based on a user table
    with three columns. When we inherit from `db.Model`, the entire connection and
    communication with the database will be already handled for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each class variable that is the `db.Column` instance represents a column in
    the database. There is an optional first argument in a `db.Column` instance that
    allows us to specify the name of the column in the database. Without it, SQLAlchemy
    assumes that the name of the variable is the same as the name of the column. Using
    this, optional variable would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument to `db.Column` tells SQLAlchemy what type the column should
    be treated as. The main types that we will work with in this book are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Integer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Boolean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.DateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What each type represents is rather simple. The `String` and `Text` types take
    Python strings and translate them to the `varchar` and `text` type columns, respectively.
    The `Integer` and `Float` types take any Python number and translate them into
    the correct type before inserting them into the database. Boolean takes Python
    `True` or `False` statements and if the database has a `boolean` type, inserts
    a Boolean into the database. If there is no `boolean` type in the database, SQLAlchemy
    automatically translates between Python Booleans and a 0 or a 1 in the database.
    The `Date`, `DateTime`, and `Time` types use the Python types of the same name
    from the `datetime` native library and translate them into the database. The `String`,
    `Integer`, and `Float` types take an extra argument that tells SQLAlchemy the
    length limit on our column.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you wish to truly understand how SQLAlchemy translates your code into SQL
    queries, add the following to the `DevConfig` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will print out the created queries to the terminal. You may wish to turn
    this feature off as you get further along in the book, as dozens of queries could
    be printed to the terminal every page load.
  prefs: []
  type: TYPE_NORMAL
- en: The argument `primary_key` tells SQLAlchemy that this column has the **primary
    key index** on it. Each SQLAlchemy model *requires* a primary key to function.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy will assume that the name of your table is the lowercase version
    of your model class name. However, what if we want our table to be called something
    other than *users*? To tell SQLAlchemy what name to use, add the `__tablename__`
    class variable. This is also how you connect to tables that already exist in your
    database. Just place the name of the table in the string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to include the `__init__` or `__repr__` functions. If we don't,
    then SQLAlchemy will automatically create an `__init__` function that accepts
    the names and values of your columns as keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using SQLAlchemy to do the heavy lifting, we will now create the user table
    in our database. Update `manage.py` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From now on, whenever we create a new model, import it and add it to the returned
    `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to work with our models in the shell. Run the shell now
    and use `db.create_all()` to create all of the tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should now see in your database a table called `users` with the columns
    specified. Also, if you are using SQLite, you should now see a file named `database.db`
    in your file structure.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In every storage mechanism for data, there are four basic types of functions:
    **Create, Read, Update, and Delete** (**CRUD**). These allow all the basic ways
    of manipulating and viewing data needed for our web apps. To use these functions,
    we will use an object on the database named the **session**. Sessions will be
    explained later in the chapter, but for now, think of them as a storage location
    for all of our changes to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new row in your database using our models, add the model to the
    `session` and `commit` objects. Adding an object to the session marks its changes
    for saving, and committing is when the session is saved to the database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is simple to add a new row to our table.
  prefs: []
  type: TYPE_NORMAL
- en: Reading models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we have added data to our database, data can be queried using `Model.query`.
    For those who use SQLAlchemy, this is shorthand for `db.session.query(Model)`.
  prefs: []
  type: TYPE_NORMAL
- en: For our first example, use `all()` to get all rows in the database as a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the number of items in the database increases, this query process becomes
    slower. In SQLAlchmey, as in SQL, we have the limit function to specify the total
    number of rows we wish to work with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, SQLAlchemy returns the records ordered by their primary keys. To
    control this, we have the `order_by` function, which is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To return just one model, we use `first()` instead of `all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To return one model by its primary key, use `query.get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: All these functions are chainable, which means that they can be appending on
    to each other to modify the return result. Those of you who are fluent in JavaScript
    will find this syntax familiar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `first()` and `all()` methods return a value and therefore end the chain.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a Flask SQLAlchemy-specific method that is called **pagination**,
    which can be used rather than `first()` or `all()`. This is a convenience method
    designed to enable the pagination feature that most websites use while displaying
    a long list of items. The first parameter defines which page the query should
    return to and the second parameter is the number of items per page. So, if we
    passed 1 and 10 as the parameters, the first 10 objects would be returned. If
    we instead passed 2 and 10, objects 11-20 would be returned, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pagination method is different from the `first()` and `all()` methods because
    it returns a pagination object rather than a list of models. For example, if we
    wanted to get the first 10 items of a fictional `Post` object for the first page
    in our blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This object has several useful properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Filtering queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we get to the actual power of SQL, that is, filtering results by a set
    of rules. To get a list of models that satisfy a set of equalities, we use the
    `query.filter_by` filter. The `query.filter_by` filter takes named arguments that
    represent the values we are looking for in each column in the database. To get
    a list of all users with a username of `fake_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is filtering on one value, but multiple values can be passed to
    the `filter_by` filter. Just like our previous functions, `filter_by` is chainable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`query.filter_by` only works if you know the exact values that you are looking
    for. This is avoided by passing Python comparison statements to the query with
    `query.filter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple example, but `query.filter` accepts any Python comparison.
    With common Python types, such as `integers`, `strings`, and `dates`, the `==`
    operator can be used for equality comparisons. If you had an `integer`, `float`,
    or `date` column, an inequality statement could also be passed with the `>`, `<`,
    `<=`, and `>=` operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also translate complex SQL queries with SQLAlchemy functions. For example,
    to use `IN`, `OR`, or `NOT` SQL comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In SQLAlchemy, comparisons to `None` are translated to comparisons to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update the values of models that already exist, apply the `update` method
    to a query object, that is, before you return the models with a method such as
    `first()` or `all()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Deleting models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we wish to remove a model from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Relationships between models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relationships between models in SQLAlchemy are links between two or more models
    that allow models to reference each other automatically. This allows naturally
    related data, such as *comments to posts*, to be easily retrieved from the database
    with its related data. This is where the *R* in RDBMS comes from, and it gives
    this type of database a large amount of power.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our first relation. Our blogging website is going to need some
    blog posts. Each blog post is going to be written by one user, so it makes sense
    to link posts back to the user that wrote them to easily get all posts by a user.
    This is an example of a **one-to-many** relationship.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a model to represent blog posts on our website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note the column `user_id`. Those who are familiar with RDBMSes will know that
    this represents a **Foreign Key Constraint**. Foreign Key Constraint is a rule
    in the database that forces the value of `user_id` to exist in the `id` column
    in the user table. This is a check in the database to make sure that `Post` will
    always refer to an existing user. The parameter to `db.ForeignKey` is a string
    representation of the `user_id` field. If you have decided to call your user table
    with `__table_name__`, you must change this string. This string is used rather
    than a direct reference with `User.id` because during initialization of SQLAlchemy,
    the `User` object might not exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user_id` column itself is not enough to tell SQLAlchemy that we have a
    relationship. We must modify our `User` model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `db.relationship` function creates a virtual column in SQLAlchemy that connects
    with `db.ForeignKey` in our `Post` model. The first parameter is the name of the
    class that we are referencing. We will cover what `backref` does soon, but what
    is the `lazy` parameter? The `lazy` parameter controls how SQLAlchemy will load
    our related objects. `subquery` would load our relations as soon as our `Post`
    object is loaded. This cuts down the number of queries, but will slow down when
    the number of returned items grows larger. In contrast, with the `dynamic` option,
    the related objects will be loaded on access and can be filtered down before returning.
    This is best if the number of returned objects is or will become large.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may now access the `User.posts` variable that will return a list of all
    the posts whose `user_id` field equals our `User.id`. Let''s try this now in our
    shell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that we were not able to access our post from our relationship without
    committing our changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter `backref` gives us the ability to access and set our `User` class
    via `Post.user`. This is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `user.posts` is a list, we could have also added our `Post` model to
    the list to save it automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `backref` option as dynamic, we can treat our relation column as a
    query as well as a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on to our next relationship type, let''s add another model for
    user comments with a one-to-many relationship, which will be used in the book
    later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Many-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we have two models that can reference each other, but each model needs
    to reference more than one of each type? For example, our blog posts will need
    tags in order for our users to easily group similar posts. Each tag can refer
    to many posts, but each post can have multiple tags. This type of relation is
    called a **many-to-many** relationship. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `db.Table` object is a lower level access to the database than the abstraction
    of `db.Model`. The `db.Model` object rests on top of `db.Table` and provides a
    representation of specific rows in the table. The `db.Table` object is used because
    there is no need to access individual rows of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tags` variable is used to represent the `post_tags` table, which contains
    two rows: one that represents the id of a post, and another that represents the
    id of a tag. To illustrate how this works, if the table had the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy would translate this to:'
  prefs: []
  type: TYPE_NORMAL
- en: A post with an id of `1` has the tags with ids of `1` and `3`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post with an id of `2` has the tags with ids of `3`, `4`, and `5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post with an id of `3` has the tags with ids of `1` and `2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may describe this data as easily as tags being related to posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `db.relationship` function sets up our relationship, but this time
    it has the secondary parameter. The secondary parameter tells SQLAlchemy that
    this relationship is stored in the tags table. Let''s see this in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As given in the one-to-many relationship, the main relationship column is just
    a list. The main difference being that the `backref` option is now also a list.
    Because it''s a list, we may add posts to tags from the `tag` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The convenience of SQLAlchemy sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the power of SQLAlchemy, you can also understand what
    the SQLAlchemy session object is and why web apps should never be made without
    them. As stated before, the session can be simply described as an object that
    tracks the changes in our models and commits them to the database when we tell
    it to. However, there is a bit more to it than this.
  prefs: []
  type: TYPE_NORMAL
- en: First, the session is the handler for **transactions**. Transactions are sets
    of changes that are flushed to the database on commit. Transactions provide a
    lot of hidden functionality. For example, transactions automatically determine
    which objects will be saved first when objects have relations. You might have
    noted this when we were saving tags in the previous section. When we added tags
    to the posts, the session automatically knew to save the tags first despite the
    fact that we did not add it to be committed. If we are working with raw SQL queries
    and a database connection, we would have to keep track of which rows are related
    to which other rows to avoid saving a foreign key reference to an object that
    does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions also automatically mark data as stale when changes to an object
    are saved to the database. When we access the object next, a query is made to
    the database to update the data, but all happens behind the scenes. If we were
    not using SQLAlchemy, we would also need to manually track which rows need to
    updated. If we want to be resource efficient, we only need to query and update
    those rows.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the session makes it impossible for there to be two different references
    to the same row in the database. This is accomplished by all queries going through
    the session (`Model.query` is actually `db.session.query(Model)`), and if the
    row has already been queried in this transaction, then the pointer to that object
    will be returned and not a new object. If this check did not exist, two objects
    that represent the same row could be saved to the database with different changes.
    This creates subtle bugs that might not be caught instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Flask SQLAlchemy creates a new session for every request and
    discards any changes that were not committed at the end of the request, so always
    remember to save your work.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an in-depth look at sessions, the creator of SQLAlchemy, Mike Bayer, gave
    a talk at PyCon Canada 2012\. Refer to *The SQLAlchemy Session - In Depth*, here—[https://www.youtube.com/watch?v=PKAdehPHOMo](https://www.youtube.com/watch?v=PKAdehPHOMo).
  prefs: []
  type: TYPE_NORMAL
- en: Database migrations with Alembic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality of web apps change all the time, and with new functionality,
    we need to change the structure of our database. Whether it's adding or dropping
    new columns, or creation of new tables, our models will change throughout the
    life cycle of our app. However, problems quickly arise when the database changes
    often. When moving our changes from development to production, how can you be
    sure that you carried over every change without manually comparing each model
    and its corresponding table? Let's say that you wish to go back in your Git history
    to see if some earlier version of your app had the same bug that you are now encountering
    in production. How will you change your database back to the correct schema without
    a lot of extra work?
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we hate extra work. Thankfully, there is a tool called **Alembic**,
    which automatically creates and tracks database migrations from the changes in
    our SQLAlchemy models. **Database migrations** are records of all the changes
    of our schema. Alembic allows us to upgrade or downgrade our database to a specific
    saved version. Upgrading or downgrading by several versions will execute all the
    files between the two selected versions. The best part of Alembic is that its
    history files are only Python files. When we create our first migration, we can
    see how simple the Alembic syntax is.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alembic does not capture every possible change. For example, it does not record
    changes on the SQL indexes. After every migration, the reader is encouraged to
    review the migration file and make any necessary corrections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t work directly with Alembic; instead, we will use **Flask-Migrate**,
    which is an extension created specifically for SQLAlchemy and works with Flask
    Script. To install it with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started, we need to add the command to our `manage.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialized the `Migrate` object with our app and our SQLAlchemy instance,
    and we made the migrate command callable through `manage.py db`. To see a list
    of possible commands, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To start tracking our changes, we use the `init` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new folder in our directory named `migrations` that will
    hold all of our history. Now we start with our first migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This command will cause Alembic to scan our SQLAlchemy object and find all the
    tables and columns that did not exist before this commit. As this is our first
    commit, the migration file will be rather long. Be sure to specify the migration
    message with `-m`, as it's the easiest way to identify what each migration is
    doing. Each migration file is stored in the `migrations/versions/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the migration to your database and change your schema, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To return to the previous version, find the version number with the `history`
    command and pass it to the `downgrade` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Like Git, a hash marks each migration. This is the main functionality of Alembic,
    but it is only surface level. Try to align your migrations with your Git commits
    in order to make it easier to downgrade or upgrade when reverting commits.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have data control mastered, we can now move on to displaying our
    data in our application. The next chapter, [Chapter 3](ch03.html "Chapter 3. Creating
    Views with Templates"), *Creating Views with Templates*, will dynamically cover
    creating HTML based on our models and adding models from our web interface.
  prefs: []
  type: TYPE_NORMAL
