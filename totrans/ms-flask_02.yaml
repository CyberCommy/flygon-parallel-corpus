- en: Chapter 2. Creating Models with SQLAlchemy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously stated, **models** are a means of abstracting and giving a common
    interface to data. In most web applications, data is stored and retrieved from
    a **Relational Database Management System** (**RDBMS**), which is a database that
    holds data in a tabular format with rows and columns and is able to compare data
    across tables. Some examples include MySQL, Postgres, Oracle, and MSSQL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In order to create models on top of our database, we will use a Python package
    named **SQLAlchemy**. SQLAlchemy is a database API at its lowest level and performs
    **Object Relational Mapping** (**ORM**) at its highest level. An ORM is a technique
    to pass and convert data between two sources with different types of systems and
    data structures. In this case, it converts data between the large amount of types
    in databases versus the mix of types and objects in Python. Also, a programming
    language such as Python allows you to have different objects that hold references
    to each other, and get and set their attributes. An ORM, such as SQLAlchemy, helps
    translate that into a traditional database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In order to tie SQLAlchemy into our application context, we will use Flask SQLAlchemy.
    Flask SQLAlchemy is a convenience layer on top of SQLAlchemy that provides useful
    defaults and Flask-specific functions. If you are already familiar with SQLAlchemy,
    then you are free to use it without Flask SQLAlchemy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a full database schema of our blogging
    application as well as models interacting with that schema.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLAlchemy
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to follow along in this chapter, you will need a running database if
    you do not already have one. If you have never installed a database or you do
    not have a preference, SQLite is the best option for beginners.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLite** is a SQL that is fast, works without a server, and is entirely contained
    in one file. Also, SQLite is natively supported in python. If you choose to go
    with SQLite, a SQLite database will be created for you in the *Our first model*
    section.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Python packages
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Flask SQLAlchemy with `pip`, run the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also need to install specific packages for the database you chose to
    use that will act as the connector for SQLAlchemy. SQLite users can skip this
    step:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Flask SQLAlchemy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can abstract our data, we need to set up Flask SQLAlchemy. SQLAlchemy
    creates its database connection through a special database URI. This is a string
    that looks like a URL that contains all the information that SQLAlchemy needs
    to connect. It takes the general form of the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For each driver you installed previously, the URI would be:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our `config.py` file, add the URI to the `DevConfig` file with:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our first model
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noted that we did not actually create any tables in our database
    to abstract off of. This is because SQLAlchemy allows us to create either models
    from tables or tables from our models. This will be covered after we create the
    first model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main.py` file, SQLAlchemy must first be initialized with our app as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'SQLAlchemy will read our app''s configuration and automatically connect to
    our database. Let''s create a `User` model to interact with a user table in the
    `main.py` file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What have we accomplished? We now have a model that is based on a user table
    with three columns. When we inherit from `db.Model`, the entire connection and
    communication with the database will be already handled for us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Each class variable that is the `db.Column` instance represents a column in
    the database. There is an optional first argument in a `db.Column` instance that
    allows us to specify the name of the column in the database. Without it, SQLAlchemy
    assumes that the name of the variable is the same as the name of the column. Using
    this, optional variable would look like:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The second argument to `db.Column` tells SQLAlchemy what type the column should
    be treated as. The main types that we will work with in this book are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '`db.String`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Text`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Integer`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Float`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Boolean`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Date`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.DateTime`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Time`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What each type represents is rather simple. The `String` and `Text` types take
    Python strings and translate them to the `varchar` and `text` type columns, respectively.
    The `Integer` and `Float` types take any Python number and translate them into
    the correct type before inserting them into the database. Boolean takes Python
    `True` or `False` statements and if the database has a `boolean` type, inserts
    a Boolean into the database. If there is no `boolean` type in the database, SQLAlchemy
    automatically translates between Python Booleans and a 0 or a 1 in the database.
    The `Date`, `DateTime`, and `Time` types use the Python types of the same name
    from the `datetime` native library and translate them into the database. The `String`,
    `Integer`, and `Float` types take an extra argument that tells SQLAlchemy the
    length limit on our column.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you wish to truly understand how SQLAlchemy translates your code into SQL
    queries, add the following to the `DevConfig` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will print out the created queries to the terminal. You may wish to turn
    this feature off as you get further along in the book, as dozens of queries could
    be printed to the terminal every page load.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The argument `primary_key` tells SQLAlchemy that this column has the **primary
    key index** on it. Each SQLAlchemy model *requires* a primary key to function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy will assume that the name of your table is the lowercase version
    of your model class name. However, what if we want our table to be called something
    other than *users*? To tell SQLAlchemy what name to use, add the `__tablename__`
    class variable. This is also how you connect to tables that already exist in your
    database. Just place the name of the table in the string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We don't have to include the `__init__` or `__repr__` functions. If we don't,
    then SQLAlchemy will automatically create an `__init__` function that accepts
    the names and values of your columns as keyword arguments.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user table
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using SQLAlchemy to do the heavy lifting, we will now create the user table
    in our database. Update `manage.py` to:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From now on, whenever we create a new model, import it and add it to the returned
    `dict`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to work with our models in the shell. Run the shell now
    and use `db.create_all()` to create all of the tables:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should now see in your database a table called `users` with the columns
    specified. Also, if you are using SQLite, you should now see a file named `database.db`
    in your file structure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: CRUD
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In every storage mechanism for data, there are four basic types of functions:
    **Create, Read, Update, and Delete** (**CRUD**). These allow all the basic ways
    of manipulating and viewing data needed for our web apps. To use these functions,
    we will use an object on the database named the **session**. Sessions will be
    explained later in the chapter, but for now, think of them as a storage location
    for all of our changes to the database.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new row in your database using our models, add the model to the
    `session` and `commit` objects. Adding an object to the session marks its changes
    for saving, and committing is when the session is saved to the database as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is simple to add a new row to our table.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Reading models
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we have added data to our database, data can be queried using `Model.query`.
    For those who use SQLAlchemy, this is shorthand for `db.session.query(Model)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: For our first example, use `all()` to get all rows in the database as a list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the number of items in the database increases, this query process becomes
    slower. In SQLAlchmey, as in SQL, we have the limit function to specify the total
    number of rows we wish to work with.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'By default, SQLAlchemy returns the records ordered by their primary keys. To
    control this, we have the `order_by` function, which is given as:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To return just one model, we use `first()` instead of `all()`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To return one model by its primary key, use `query.get()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All these functions are chainable, which means that they can be appending on
    to each other to modify the return result. Those of you who are fluent in JavaScript
    will find this syntax familiar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `first()` and `all()` methods return a value and therefore end the chain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: There is also a Flask SQLAlchemy-specific method that is called **pagination**,
    which can be used rather than `first()` or `all()`. This is a convenience method
    designed to enable the pagination feature that most websites use while displaying
    a long list of items. The first parameter defines which page the query should
    return to and the second parameter is the number of items per page. So, if we
    passed 1 and 10 as the parameters, the first 10 objects would be returned. If
    we instead passed 2 and 10, objects 11-20 would be returned, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The pagination method is different from the `first()` and `all()` methods because
    it returns a pagination object rather than a list of models. For example, if we
    wanted to get the first 10 items of a fictional `Post` object for the first page
    in our blog:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This object has several useful properties:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Filtering queries
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we get to the actual power of SQL, that is, filtering results by a set
    of rules. To get a list of models that satisfy a set of equalities, we use the
    `query.filter_by` filter. The `query.filter_by` filter takes named arguments that
    represent the values we are looking for in each column in the database. To get
    a list of all users with a username of `fake_name`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This example is filtering on one value, but multiple values can be passed to
    the `filter_by` filter. Just like our previous functions, `filter_by` is chainable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`query.filter_by` only works if you know the exact values that you are looking
    for. This is avoided by passing Python comparison statements to the query with
    `query.filter`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a simple example, but `query.filter` accepts any Python comparison.
    With common Python types, such as `integers`, `strings`, and `dates`, the `==`
    operator can be used for equality comparisons. If you had an `integer`, `float`,
    or `date` column, an inequality statement could also be passed with the `>`, `<`,
    `<=`, and `>=` operators.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also translate complex SQL queries with SQLAlchemy functions. For example,
    to use `IN`, `OR`, or `NOT` SQL comparisons:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In SQLAlchemy, comparisons to `None` are translated to comparisons to `NULL`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Updating models
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update the values of models that already exist, apply the `update` method
    to a query object, that is, before you return the models with a method such as
    `first()` or `all()`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deleting models
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we wish to remove a model from the database:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Relationships between models
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relationships between models in SQLAlchemy are links between two or more models
    that allow models to reference each other automatically. This allows naturally
    related data, such as *comments to posts*, to be easily retrieved from the database
    with its related data. This is where the *R* in RDBMS comes from, and it gives
    this type of database a large amount of power.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Let's create our first relation. Our blogging website is going to need some
    blog posts. Each blog post is going to be written by one user, so it makes sense
    to link posts back to the user that wrote them to easily get all posts by a user.
    This is an example of a **one-to-many** relationship.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s add a model to represent blog posts on our website:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note the column `user_id`. Those who are familiar with RDBMSes will know that
    this represents a **Foreign Key Constraint**. Foreign Key Constraint is a rule
    in the database that forces the value of `user_id` to exist in the `id` column
    in the user table. This is a check in the database to make sure that `Post` will
    always refer to an existing user. The parameter to `db.ForeignKey` is a string
    representation of the `user_id` field. If you have decided to call your user table
    with `__table_name__`, you must change this string. This string is used rather
    than a direct reference with `User.id` because during initialization of SQLAlchemy,
    the `User` object might not exist yet.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user_id` column itself is not enough to tell SQLAlchemy that we have a
    relationship. We must modify our `User` model as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `db.relationship` function creates a virtual column in SQLAlchemy that connects
    with `db.ForeignKey` in our `Post` model. The first parameter is the name of the
    class that we are referencing. We will cover what `backref` does soon, but what
    is the `lazy` parameter? The `lazy` parameter controls how SQLAlchemy will load
    our related objects. `subquery` would load our relations as soon as our `Post`
    object is loaded. This cuts down the number of queries, but will slow down when
    the number of returned items grows larger. In contrast, with the `dynamic` option,
    the related objects will be loaded on access and can be filtered down before returning.
    This is best if the number of returned objects is or will become large.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'We may now access the `User.posts` variable that will return a list of all
    the posts whose `user_id` field equals our `User.id`. Let''s try this now in our
    shell as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we were not able to access our post from our relationship without
    committing our changes to the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter `backref` gives us the ability to access and set our `User` class
    via `Post.user`. This is given by:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because `user.posts` is a list, we could have also added our `Post` model to
    the list to save it automatically:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the `backref` option as dynamic, we can treat our relation column as a
    query as well as a list:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before we move on to our next relationship type, let''s add another model for
    user comments with a one-to-many relationship, which will be used in the book
    later on:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Many-to-many
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if we have two models that can reference each other, but each model needs
    to reference more than one of each type? For example, our blog posts will need
    tags in order for our users to easily group similar posts. Each tag can refer
    to many posts, but each post can have multiple tags. This type of relation is
    called a **many-to-many** relationship. Consider the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `db.Table` object is a lower level access to the database than the abstraction
    of `db.Model`. The `db.Model` object rests on top of `db.Table` and provides a
    representation of specific rows in the table. The `db.Table` object is used because
    there is no need to access individual rows of the table.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tags` variable is used to represent the `post_tags` table, which contains
    two rows: one that represents the id of a post, and another that represents the
    id of a tag. To illustrate how this works, if the table had the following data:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'SQLAlchemy would translate this to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: A post with an id of `1` has the tags with ids of `1` and `3`
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post with an id of `2` has the tags with ids of `3`, `4`, and `5`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post with an id of `3` has the tags with ids of `1` and `2`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may describe this data as easily as tags being related to posts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `db.relationship` function sets up our relationship, but this time
    it has the secondary parameter. The secondary parameter tells SQLAlchemy that
    this relationship is stored in the tags table. Let''s see this in the following
    code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As given in the one-to-many relationship, the main relationship column is just
    a list. The main difference being that the `backref` option is now also a list.
    Because it''s a list, we may add posts to tags from the `tag` object as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The convenience of SQLAlchemy sessions
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand the power of SQLAlchemy, you can also understand what
    the SQLAlchemy session object is and why web apps should never be made without
    them. As stated before, the session can be simply described as an object that
    tracks the changes in our models and commits them to the database when we tell
    it to. However, there is a bit more to it than this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: First, the session is the handler for **transactions**. Transactions are sets
    of changes that are flushed to the database on commit. Transactions provide a
    lot of hidden functionality. For example, transactions automatically determine
    which objects will be saved first when objects have relations. You might have
    noted this when we were saving tags in the previous section. When we added tags
    to the posts, the session automatically knew to save the tags first despite the
    fact that we did not add it to be committed. If we are working with raw SQL queries
    and a database connection, we would have to keep track of which rows are related
    to which other rows to avoid saving a foreign key reference to an object that
    does not exist.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Transactions also automatically mark data as stale when changes to an object
    are saved to the database. When we access the object next, a query is made to
    the database to update the data, but all happens behind the scenes. If we were
    not using SQLAlchemy, we would also need to manually track which rows need to
    updated. If we want to be resource efficient, we only need to query and update
    those rows.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Second, the session makes it impossible for there to be two different references
    to the same row in the database. This is accomplished by all queries going through
    the session (`Model.query` is actually `db.session.query(Model)`), and if the
    row has already been queried in this transaction, then the pointer to that object
    will be returned and not a new object. If this check did not exist, two objects
    that represent the same row could be saved to the database with different changes.
    This creates subtle bugs that might not be caught instantly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Flask SQLAlchemy creates a new session for every request and
    discards any changes that were not committed at the end of the request, so always
    remember to save your work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an in-depth look at sessions, the creator of SQLAlchemy, Mike Bayer, gave
    a talk at PyCon Canada 2012\. Refer to *The SQLAlchemy Session - In Depth*, here—[https://www.youtube.com/watch?v=PKAdehPHOMo](https://www.youtube.com/watch?v=PKAdehPHOMo).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Database migrations with Alembic
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality of web apps change all the time, and with new functionality,
    we need to change the structure of our database. Whether it's adding or dropping
    new columns, or creation of new tables, our models will change throughout the
    life cycle of our app. However, problems quickly arise when the database changes
    often. When moving our changes from development to production, how can you be
    sure that you carried over every change without manually comparing each model
    and its corresponding table? Let's say that you wish to go back in your Git history
    to see if some earlier version of your app had the same bug that you are now encountering
    in production. How will you change your database back to the correct schema without
    a lot of extra work?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we hate extra work. Thankfully, there is a tool called **Alembic**,
    which automatically creates and tracks database migrations from the changes in
    our SQLAlchemy models. **Database migrations** are records of all the changes
    of our schema. Alembic allows us to upgrade or downgrade our database to a specific
    saved version. Upgrading or downgrading by several versions will execute all the
    files between the two selected versions. The best part of Alembic is that its
    history files are only Python files. When we create our first migration, we can
    see how simple the Alembic syntax is.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们讨厌额外的工作。幸运的是，有一个名为**Alembic**的工具，它可以根据我们的SQLAlchemy模型的更改自动创建和跟踪数据库迁移。**数据库迁移**是我们模式的所有更改的记录。Alembic允许我们将数据库升级或降级到特定的保存版本。通过几个版本的升级或降级将执行两个选定版本之间的所有文件。Alembic最好的部分是它的历史文件只是Python文件。当我们创建我们的第一个迁移时，我们可以看到Alembic语法是多么简单。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Alembic does not capture every possible change. For example, it does not record
    changes on the SQL indexes. After every migration, the reader is encouraged to
    review the migration file and make any necessary corrections.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Alembic并不捕获每一个可能的变化。例如，它不记录SQL索引的更改。在每次迁移之后，建议读者查看迁移文件并进行任何必要的更正。
- en: 'We won''t work directly with Alembic; instead, we will use **Flask-Migrate**,
    which is an extension created specifically for SQLAlchemy and works with Flask
    Script. To install it with `pip`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会直接使用Alembic；相反，我们将使用**Flask-Migrate**，这是专门为SQLAlchemy创建的扩展，并与Flask Script一起使用。要使用`pip`安装它：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To get started, we need to add the command to our `manage.py` file as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要将命令添加到我们的`manage.py`文件中，如下所示：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We initialized the `Migrate` object with our app and our SQLAlchemy instance,
    and we made the migrate command callable through `manage.py db`. To see a list
    of possible commands, run this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的应用程序和我们的SQLAlchemy实例初始化了`Migrate`对象，并且通过`manage.py db`使迁移命令可调用。要查看可能的命令列表，请运行此命令：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To start tracking our changes, we use the `init` command as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始跟踪我们的更改，我们使用`init`命令如下：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will create a new folder in our directory named `migrations` that will
    hold all of our history. Now we start with our first migration:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的目录中创建一个名为`migrations`的新文件夹，其中将保存我们的所有历史记录。现在我们开始进行我们的第一个迁移：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This command will cause Alembic to scan our SQLAlchemy object and find all the
    tables and columns that did not exist before this commit. As this is our first
    commit, the migration file will be rather long. Be sure to specify the migration
    message with `-m`, as it's the easiest way to identify what each migration is
    doing. Each migration file is stored in the `migrations/versions/` folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将导致Alembic扫描我们的SQLAlchemy对象，并找到所有在此提交之前不存在的表和列。由于这是我们的第一个提交，迁移文件会相当长。一定要使用`-m`指定迁移消息，因为这是识别每个迁移在做什么的最简单方法。每个迁移文件都存储在`migrations/versions/`文件夹中。
- en: 'To apply the migration to your database and change your schema, run the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将迁移应用到您的数据库并更改模式，请运行以下命令：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To return to the previous version, find the version number with the `history`
    command and pass it to the `downgrade` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回到以前的版本，使用`history`命令找到版本号，并将其传递给`downgrade`命令：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Like Git, a hash marks each migration. This is the main functionality of Alembic,
    but it is only surface level. Try to align your migrations with your Git commits
    in order to make it easier to downgrade or upgrade when reverting commits.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Git一样，每个迁移都有一个哈希标记。这是Alembic的主要功能，但这只是表面层次。尝试将您的迁移与Git提交对齐，以便在还原提交时更容易降级或升级。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now that we have data control mastered, we can now move on to displaying our
    data in our application. The next chapter, [Chapter 3](ch03.html "Chapter 3. Creating
    Views with Templates"), *Creating Views with Templates*, will dynamically cover
    creating HTML based on our models and adding models from our web interface.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了数据控制，我们现在可以继续在我们的应用程序中显示我们的数据。下一章，[第3章](ch03.html "第3章。使用模板创建视图") *使用模板创建视图*，将动态地涵盖根据我们的模型创建基于HTML的视图，并从我们的Web界面添加模型。
