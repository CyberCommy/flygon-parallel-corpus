- en: Chapter 2. The Basics of Python Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Python脚本的基础知识
- en: Before diving into writing your first Python script, a few concepts should be
    understood. Learning these items now will help you develop code quicker in the
    future. This will improve your abilities as a penetration tester or in understanding
    what an assessor is doing when they are creating real-time custom code and what
    questions you should be asking. You should also understand how to create the scripts
    and the goal you are trying to achieve. You will often find out that your scripts
    will morph over time and the purpose may change. This may happen because you realize
    that the real need for the script may not be there or that there is an existing
    tool for the particular capability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写你的第一个Python脚本之前，应该先了解一些概念。现在学习这些内容将有助于你将来更快地开发代码。这将提高你作为渗透测试人员的能力，或者理解评估人员在创建实时自定义代码时在做什么以及你应该问什么问题。你还应该了解如何创建脚本以及你试图实现的目标。你会经常发现你的脚本会随着时间而变化，目的可能会改变。这可能是因为你意识到脚本的真正需求可能不存在，或者有一个特定功能的现有工具。
- en: Many scripters find this discouraging, as a project that they may have been
    working on for a great deal of time you may find that the tool has duplicate features
    of more advanced tools. Instead of looking at this as a failed project, look at
    the activity as an experience wherein you learned new concepts and techniques
    that you did not initially know. Additionally, keep it at the back of your mind
    at all times when you are developing code snippets that can be used for other
    projects in the future.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多脚本编写者会觉得沮丧，因为他们可能已经花了很多时间在一个项目上，但最终发现这个工具具有更高级工具的重复功能。不要把这看作是一个失败的项目，而是把这个活动看作是一个经历，在这个过程中你学到了一些最初不知道的新概念和技术。此外，无论何时你在开发代码片段时，都要时刻记在心里，这些代码片段可以在将来的其他项目中使用。
- en: To this end, try and build your code cleanly, comment it with what you are doing,
    and make it modular so that once you learn how to build functions, they can be
    cut and pasted into other scripts in the future. The first step in this journey
    is to describe the computer science glossary at a high level so that you can understand
    future chapters or other tutorials. Without understanding these basic concepts,
    you may misunderstand how to achieve your desired results.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽量编写清晰的代码，用注释说明你在做什么，并使其模块化，这样一旦学会了如何构建函数，它们可以在将来的其他脚本中被剪切和粘贴。这个旅程的第一步是以高层次描述计算机科学词汇表，这样你就可以理解将来的章节或其他教程。如果不理解这些基本概念，你可能会误解如何实现你想要的结果。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before running any of the scripts in this book, I recommend that you run the
    setup script on the git repository, which will configure your Kali instance with
    all the necessary libraries. The script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本书中的任何脚本之前，我建议你在git存储库上运行设置脚本，这将为你的Kali实例配置所有必要的库。该脚本可以在[https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/setup.sh)找到。
- en: Understanding the difference between interpreted and compiled languages
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解解释型语言和编译型语言之间的区别
- en: Python, like Ruby and Perl, is an interpreted language, which means that the
    code is turned into a machine language and run as the script is executed. A language
    that needs to be compiled prior to running, such as Cobol, C, or C++, can be more
    efficient and faster, as it is compiled prior to execution, but it also means
    that the code is typically less portable. As compiled code is generated for specific
    environments, it may not be as useful when you have to move through heterogeneous
    environments.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python、Ruby和Perl等语言都是解释型语言，这意味着代码在执行脚本时会被转换为机器语言并运行。需要在运行之前编译的语言，比如Cobol、C或C++，可能更有效率和更快，因为它在执行之前被编译，但这也意味着代码通常不太可移植。由于编译代码是为特定环境生成的，当你需要在异构环境中移动时，它可能不太有用。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A heterogeneous environment is an environment that has multiple system types
    and different distributions. So, there may be multiple Unix/Linux distributions,
    Mac OS, and Windows systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 异构环境是一个具有多个系统类型和不同发行版的环境。因此，可能会有多个Unix/Linux发行版、Mac OS和Windows系统。
- en: Interpreted code usually has the benefit of being portable to different locations
    as long as the interpreter is available. So for Python scripts, as long as the
    script is not developed for an operating system, the interpreter is installed,
    and the libraries are natively available, the Python script should work. Always
    keep in mind that there will be idiosyncrasies in an environment, and before scripts
    are used, they should be thoroughly tested in similar test beds.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型代码通常具有可移植性的好处，只要解释器可用。因此，对于Python脚本，只要安装了解释器并且库是本地可用的，脚本就应该可以运行。始终记住环境中会有特殊情况，在使用脚本之前，应该在类似的测试环境中进行彻底测试。
- en: So why should you learn Python over other scripting languages? I am not making
    this argument here, and the reason is that the best assessors use the tools available
    in the environment that they are assessing. You will build scripts that are useful
    for assessing environments, and Python is fantastic for doing this, but when you
    gain access to a system, it is best to use what is available to you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么你应该学习Python而不是其他脚本语言呢？我在这里不做这个论点，原因是最好的评估人员使用他们所评估的环境中可用的工具。你将编写对评估环境有用的脚本，Python非常适合这样做，但当你获得对系统的访问权限时，最好使用可用的工具。
- en: Highly secure environments may prevent you from using exploitation frameworks,
    or the assessment rules may do the same. When this happens, you have to look at
    what is available on the system to take advantage of and move forward. Today,
    newer generation Windows systems are compromised with PowerShell. Often in current
    Mac, Linux, Unix, and Windows **Operating System** (**OS**), you can find a version
    of Python, especially in development environments. On web servers, you will find
    Ruby, Python, or Perl. On all forms of operating systems, you will find native
    shell languages. They provide many capabilities, but typically, they have archaic
    language structures that require more lines of code than other scripting languages
    to accomplish the same task. Examples of these shell languages would include **Bourne-again
    Shell** (**BASH**), **Korn Shell** (**KSH**), Windows Command Shell, and equivalents.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 高度安全的环境可能会阻止您使用渗透框架，或者评估规则可能会做同样的事情。当这种情况发生时，您必须查看系统上可用的内容并继续前进。如今，新一代Windows系统使用PowerShell进行攻击。在当前的Mac、Linux、Unix和Windows操作系统中，尤其是在开发环境中，您可以找到Python的版本。在Web服务器上，您会发现Ruby、Python或Perl。在所有形式的操作系统上，您都会找到本机shell语言。它们提供了许多功能，但通常具有过时的语言结构，需要比其他脚本语言更多的代码行来完成相同的任务。这些shell语言的示例包括Bourne-again
    Shell（BASH）、Korn Shell（KSH）、Windows命令Shell和等效物。
- en: In most exploitation systems, you will find all the languages, as most hacking
    laptops, or HackTops, use multiple **Virtual Machines** (**VMs**) with many operating
    systems. Older assessment tools were coded in Perl, as the language provided multiple
    capabilities that other interpreted languages could not provide at that time.
    Newer tools are typically created in Ruby and Python. In fact, many libraries
    that are being created today are for improving the capabilities of these languages,
    specifically for assessing the potential viability an organization has for being
    compromised by a malicious actor.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数渗透系统中，您会发现所有的语言，因为大多数黑客笔记本电脑或HackTops使用多个虚拟机（VMs）和许多操作系统。旧的评估工具是用Perl编写的，因为该语言在当时提供了其他解释语言无法提供的多种功能。新工具通常是用Ruby和Python创建的。事实上，今天正在创建的许多库都是为了改进这些语言的能力，特别是为了评估组织被恶意行为者威胁的潜在可行性。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep in mind that your HackTop has multiple VMs to provide you with not only
    attack tools but also a test bed to test your scripts safely. Reverting to a snapshot
    of a VM on your HackTop is easy, but telling a customer why you damaged their
    business-critical component with an untested script is not.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您的HackTop有多个虚拟机，不仅提供攻击工具，还提供一个安全测试平台来测试您的脚本。在您的HackTop上恢复虚拟机的快照很容易，但是告诉客户为什么您使用未经测试的脚本损坏了他们的业务关键组件却不容易。
- en: Compiled languages are not without value; many tools have been created in C,
    C++, and Java. Examples of these types of tools include Burp Suite, Cain & Abel,
    DirBuster, **Zed Attack Proxy** (**ZAP**), CSRFtester, and so on. You might notice
    that most of these tools were generated originally in the early days of assessing
    environments. As systems have gotten more powerful and interpreters have become
    more efficient, we have seen additional tools move to languages that are interpreted
    as against compiled.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编译语言并非毫无价值；许多工具是用C、C++和Java创建的。这些类型的工具的示例包括Burp Suite、Cain & Abel、DirBuster、Zed
    Attack Proxy（ZAP）、CSRFtester等。您可能会注意到，这些工具中的大多数最初是在评估环境的早期创建的。随着系统变得更加强大和解释器变得更加高效，我们看到其他工具转移到了解释语言而不是编译语言。
- en: So what is the lesson here? Learn as much as you can to operate in as many environments
    as possible. In this way, when you encounter an obstacle, you can return to the
    code and script your way to the level of access necessary.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这里的教训是什么？尽可能多地学习，以在尽可能多的环境中操作。这样，当遇到障碍时，您可以返回到代码并脚本化以获得必要的访问级别。
- en: Python – the good and the bad
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python-优点和缺点
- en: Python is one of the easiest languages for creating a working piece of code
    that accomplishes tangible results. In fact, Python has a native interactive interpreter
    through which you can test code directly by just executing the word `python` at
    the CLI. This will bring up an interface in which concepts of code can be tested
    prior to trying to write a script. Additionally, this interface allows a tester
    to not only test new concepts, but also to import modules or other scripts as
    modules and use them to create powerful tools.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python是创建可实现切实结果的工作代码的最简单的语言之一。事实上，Python具有本地交互式解释器，通过它可以直接测试代码，只需在CLI中执行单词`python`。这将带来一个界面，可以在尝试编写脚本之前测试代码的概念。此外，这个界面不仅允许测试新概念，还允许导入模块或其他脚本作为模块，并使用它们创建强大的工具。
- en: Not only does this testing capability of Python allow assessors to verify concepts,
    but they can also avoid dealing with extensive debuggers and test cases to quickly
    prototype attack code. This is especially important when on an engagement and
    when determining whether a particular exploit train will net useful results in
    a timely manner. Most importantly, the use of Python and the importing of specific
    libraries usually do not break entire tool suites, and uninstalling a specific
    library is very easy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python的这种测试能力不仅允许评估者验证概念，还可以避免处理繁琐的调试器和测试用例，快速原型化攻击代码。当参与项目并确定特定的攻击训练是否能够及时产生有用的结果时，这一点尤为重要。最重要的是，使用Python和导入特定库通常不会破坏整个工具套件，卸载特定库也非常容易。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To maintain the integrity of the customer environment, you should avoid installing
    libraries on client systems. If there is a need to do so, make sure that you work
    with your point of contact, because there may be unintended consequences. It could
    also be considered a violation of the organization's **System Development Life
    cycle** (**SDLC**) and its change control process. The end result is that you
    could be creating more risk for the client than the original assessment's intention.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了维护客户环境的完整性，你应该避免在客户系统上安装库。如果有必要这样做，确保你与你的联系人一起工作，因为可能会产生意想不到的后果。这也可能被视为违反组织的**系统开发生命周期**（**SDLC**）和其变更控制流程。最终结果是，你可能会为客户创造比原始评估意图更多的风险。
- en: The language structure for Python, though different from many other forms of
    coding, is very simple. Reading Python is similar to reading a book, but with
    some slight caveats. There are basically two different forms of Python development
    trees at the time of writing this book—Python 2.X and Python 3.X. Most assessment
    tools run on the 2.X version, which is what we will be focusing on, but improvements
    in the language versions for all intents and purposes has stopped. You can write
    code that works for both versions, but it will take some effort.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python的语言结构虽然与许多其他形式的编码不同，但非常简单。阅读Python类似于阅读一本书，但有一些细微的注意事项。在撰写本书时，基本上有两种不同形式的Python开发树——Python
    2.X和Python 3.X。大多数评估工具在2.X版本上运行，这也是我们将重点关注的，但是语言版本的改进基本上已经停止。你可以编写适用于两个版本的代码，但这需要一些努力。
- en: In essence, Python version 3.X has been developed to be more **Object-oriented**
    (**OO**), which means that coding for it means focusing on OO methods and attributes.
    This is not to say that 2.X is not OO; it's just that it is not as well developed
    as version 3.X. Most importantly, some libraries are not compatible with both
    versions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，Python 3.X版本已经开发成更加**面向对象**（**OO**），这意味着为它编码意味着专注于面向对象的方法和属性。这并不是说2.X不是面向对象的；只是它没有3.X版本发展得那么好。最重要的是，一些库与两个版本都不兼容。
- en: Believe it or not, the most common reason a Python script is not completely
    version compatible is the built-in `print` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，Python脚本不完全兼容的最常见原因是内置的`print`函数。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 2.X, `print` is a statement, and in 3.X, it is a function, as you
    will see next. Throughout this book, the use of the word statement and function
    may be used interchangeably, but understanding the difference is the key to building
    version-agnostic scripts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.X中，`print`是一个语句，在3.X中，它是一个函数，你将在下面看到。在本书中，单词语句和函数的使用可能是可以互换的，但理解它们之间的区别是构建版本无关脚本的关键。
- en: Attempting to print something on the screen with `print` can be done in two
    ways. One is by using wrapped-in parameters, and the other is without using them.
    If it is with wrapped-in parameters, it is compatible with both 2.X and 3.X; if
    not, then it will work with 2.X only.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`print`在屏幕上打印一些东西可以通过两种方式完成。一种是使用包裹在参数中，另一种是不使用它们。如果使用包裹在参数中，它与2.X和3.X兼容；如果不是，那么它只能与2.X一起使用。
- en: 'The following example shows what a 2.X-only `print` function looks like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个仅适用于2.X的`print`函数的样子：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is an example of a `print` function that is compatible with both 2.X and
    3.X Python interpreters:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与2.X和3.X Python解释器兼容的`print`函数的示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After you have started creating scripts, you will notice how often you will
    be using the `print` function in your scripts. As such, large-scale text replacements
    in big scripts can be laborious and error-prone, even with automated methods.
    Examples include the use of `sed`, `awk`, and other data manipulation tools.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始创建脚本之后，你会注意到你在脚本中经常使用`print`函数。因此，在大型脚本中进行大规模的文本替换可能是费力且容易出错的，即使使用自动化方法也是如此。例如，包括`sed`、`awk`和其他数据处理工具。
- en: As you become a better assessor, you should endeavor to write your scripts so
    that they would run in either version. The reason is that if you compromise an
    environment and you need a custom script to complete some post-exploitation activity,
    you would not want to be slowed down because it is version incompatible. The best
    way to start is to make sure that you use `print` functions that are compatible
    with both versions of Python.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你成为一个更好的评估者，你应该努力编写你的脚本，使它们可以在任何一个版本中运行。原因是，如果你妥协了一个环境，你需要一个自定义脚本来完成一些后渗透活动，你不会希望因为版本不兼容而减慢速度。开始的最佳方式是确保你使用与Python两个版本兼容的`print`函数。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OO programming means that the language supports objects that can be created
    and destroyed as necessary to complete tasks. Entire training classes have been
    developed on explaining and expanding on OO concepts. Deep explanations of these
    concepts are beyond the scope of this book, but further study is always recommended.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程意味着语言支持可以根据需要创建和销毁的对象来完成任务。已经开发了整个培训课程来解释和扩展面向对象的概念。这些概念的深入解释超出了本书的范围，但建议进一步学习。
- en: In addition to the OO thought process and construction of OO supported code,
    there is also creating scripts "Pythonically," or "Pythonic scripts". This is
    not made up; instead, it is a way of defining the proper method of creating and
    writing a Python script. There are many ways you can write a Python script, and
    over the years, best practices have evolved. This is called **Pythonic**, and
    as such, we should always endeavor to write in this fashion. The reason is that
    when we, as contributors, provide scripts to the community, they are easier to
    read, maintain, and use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了面向对象的思维过程和支持面向对象的代码的构建之外，还有创建“Python化”或“Pythonic脚本”。这不是虚构的；相反，它是一种定义创建和编写Python脚本的正确方法。你可以以许多方式编写Python脚本，多年来，最佳实践已经发展。这就是所谓的**Pythonic**，因此，我们应该始终努力以这种方式编写。原因是，当我们作为贡献者向社区提供脚本时，它们更容易阅读、维护和使用。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pythonic is a great concept as it deals with some of the biggest things that
    have impacted the adoption of other languages and bad practices among the community.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonic是一个很好的概念，因为它涉及到影响其他语言的采用和社区中不良实践的一些最重要的事情。
- en: A Python interactive interpreter versus a script
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python交互式解释器与脚本
- en: There are two ways in which the Python language can be used. One is through
    an interactive interpreter, that allows quick testing of functions, code snippets,
    and ideas. The other is through a full-fledged script that can be saved and transported
    between systems. If you want to try out an interactive interpreter, just type
    `python` in your command-line shell.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言有两种使用方式。一种是通过交互式解释器，允许快速测试函数、代码片段和想法。另一种是通过一个完整的脚本，可以保存并在不同系统之间传输。如果你想尝试交互式解释器，只需在命令行中输入`python`。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An interactive interpreter will function the same way in different operating
    systems, but the libraries and called functions that interact with a system may
    not. If specific locations are referenced or if commands and/or libraries use
    operating-system-specific capabilities, the functionality will be different. As
    such, referencing these details in a script will impact its portability substantially,
    so it is not considered a leading practice.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式解释器在不同操作系统中的功能方式相同，但与系统交互的库和调用函数可能不同。如果引用了特定位置，或者命令和/或库使用特定于操作系统的功能，功能将不同。因此，在脚本中引用这些细节将大大影响其可移植性，因此不被认为是一种主流做法。
- en: Environmental variables and PATH
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量和PATH
- en: 'These variables are important for executing scripts written in Python, not
    for writing them. If they are not configured, the location of the Python binary
    has to be referenced by its fully qualified path location. As an example, here
    is the execution of a Python script without the environmental variable being declared
    in Windows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量对于执行Python编写的脚本很重要，但不是用于编写脚本。如果它们没有配置，Python二进制文件的位置必须通过其完全限定的路径位置引用。例如，在Windows中，没有声明环境变量的情况下执行Python脚本的示例：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is the equivalent in Linux or Unix if the reference to the proper
    interpreter is not listed at the top of the script and the file is in your current
    directory:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本顶部没有列出对正确解释器的引用，并且文件在当前目录中，则在Linux或Unix中相当于以下内容：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Windows, if the environmental variable is set, you can simply execute the
    script by typing `python` and the script name. In Linux and Unix, we add a line
    at the top of the script to make it more portable. A benefit to us (penetration
    testers) is that this makes the script useful on many different types of systems,
    including Windows. This line is ignored by the Windows operating system natively,
    as it is treated as a comment. The following referenced line should be included
    at the top of all Python scripts:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，如果环境变量已设置，只需输入`python`和脚本名称即可执行脚本。在Linux和Unix中，我们在脚本顶部添加一行以使其更具可移植性。对我们（渗透测试人员）的好处是，这使得脚本在许多不同类型的系统上都很有用，包括Windows。这行在Windows操作系统中被忽略，因为它被视为注释。所有Python脚本的顶部应包含以下引用行：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This line lets the operating system determine the correct interpreter to run
    based on what is set in the `PATH` environmental variable. In many script examples
    on the Internet, you may see a direct reference to an interpreter, such as `/usr/bin/python`.
    This not considered good practice as it makes the code less portable and more
    prone to errors with potential system changes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这行让操作系统根据`PATH`环境变量中设置的内容确定正确的解释器来运行。在互联网上的许多脚本示例中，你可能会看到对解释器的直接引用，比如`/usr/bin/python`。这不被认为是一种良好的做法，因为它会使代码不够可移植，并且更容易出现潜在的系统更改错误。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Setting up and dealing with `PATH` and environmental variables will be different
    for each operating system. Refer to [https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables)
    for Windows. For Unix and Linux platforms, the details can be found at [https://docs.python.org/2/using/unix.html#python-related-paths-and-files](https://docs.python.org/2/using/unix.html#python-related-paths-and-files).
    Additionally, if you need to create specialty environmental variables for a specific
    tool someday, you can find the details at [https://docs.python.org/2/using/cmdline.html](https://docs.python.org/2/using/cmdline.html).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和处理`PATH`和环境变量对每个操作系统都是不同的。有关Windows，请参阅[https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables](https://docs.python.org/2/using/windows.html#excursus-setting-environment-variables)。对于Unix和Linux平台，详细信息可以在[https://docs.python.org/2/using/unix.html#python-related-paths-and-files](https://docs.python.org/2/using/unix.html#python-related-paths-and-files)找到。此外，如果有一天需要为特定工具创建特殊的环境变量，可以在[https://docs.python.org/2/using/cmdline.html](https://docs.python.org/2/using/cmdline.html)找到详细信息。
- en: Understanding dynamically typed languages
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解动态类型语言
- en: Python is a dynamically typed language, which means many things, but the most
    crucial aspect is how variables or objects are handled. Dynamically typed languages
    are usually synonymous with scripting languages, but this is not always the case,
    just to be clear. What this means to you when you write your script is that variables
    are interpreted at runtime, so they do not have to defined in size or by content.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态类型的语言，这意味着很多东西，但最关键的方面是变量或对象的处理方式。动态类型的语言通常与脚本语言等同，但这并不总是如此，需要明确。当你编写脚本时，这对你的意义是变量在运行时被解释，因此它们不必按大小或内容定义。
- en: The first Python script
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个Python脚本
- en: 'Now that you have a basic idea of what Python is, let''s create a script. Instead
    of the famous `Hello World!` introduction, we are going to use a cult film example.
    The scripts will define a function, which will print a famous quote from the 1983
    cult classic *WarGames*. There are two ways of doing this, as mentioned previously;
    the first is through the interactive interpreter, and the second is through a
    script. Open an interactive interpreter and execute the following line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding print statement will show that the code execution worked. To
    exit the interactive interpreter, either type `exit()` or use *Ctrl* + *Z* in
    Windows or *Ctrl* + *D* in Linux. Now, create a script in your preferred editing
    tool, such as vi, vim, emacs, or gedit. Then save the file in `/root/Desktop`
    as `wargames_print.py`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After saving the file, run it with the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will again see the script execute with the same results. Be aware of a
    few items in this example. The `python` script is run by referencing the fully
    qualified path so as to ensure that the correct script is called, no matter what
    the location is. If the script resided in the current location, it could, instead,
    be executed in the following manner:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kali does not natively require `./` to execute these scripts, but it is a good
    habit to be in, as most other Linux and Unix operating systems do. If you are
    out of the habit and slightly sleep deprived on an assessment, you may not realize
    why your script is not executing initially. This technique can save you a little
    embarrassment on multimember team engagements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Developing scripts and identifying errors
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we jump into creating large-scale scripts, you need to understand the
    errors that can be produced. If you start creating scripts and generating a bunch
    of errors, you may get discouraged. Keep in mind that Python does a pretty good
    job at directing you to what you need to look at. Often, however, the producer
    of the error is either right before the line referenced or the function called.
    This in turn can be misleading, so to prevent discouragement, you should understand
    the definitions that Python may reference in the errors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Reserved words, keywords, and built-in functions
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reserved words, keywords, and built-in functions are also known as **prohibited**,
    which means that the name cannot be used as a variable or function. If the word
    or function is reused, an error will be shown. There are set words and built-in
    functions natively within Python, and depending on the version you are using,
    they can change. You should not worry too much about this now, but if you see
    errors related to the definitions of variables or values, consider the fact that
    you may be using a keyword or built-in function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details about keywords and built-in functions can be found at [https://docs.python.org/2/library/keyword.html](https://docs.python.org/2/library/keyword.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of Python keywords and some brief definitions. These
    are described in detail throughout the rest of the chapter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '| Example keyword | Purpose |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| `for` | A type of Python loop used mostly for iterations |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `def` | The definition of a function that will be created in the current
    script |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `if` | A method of evaluating a statement and determining a resulting course
    of action |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| `elif` | A follow-on evaluation for an `if` statement, which allows more
    than two different outcomes |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| `import` | The manner in which libraries are imported |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| `print` | The statement to output data to **Standard Out** (**STDOUT**) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| `try` | A conditional handler test |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: 'If you want to confirm a name as a keyword, fire up the interactive interpreter
    and set a variable to the specific keyword name. Then, run it through the function
    of keyword. If it returns `true`, then you know it is a keyword; if it returns
    `false`, you know it is not. Refer to the following screenshot to better understand
    this concept:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![Reserved words, keywords, and built-in functions](img/B04315_02_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![保留字、关键字和内置函数](img/B04315_02_01.jpg)'
- en: Global and local variables
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局和局部变量
- en: 'Global variables are defined outside of functions, and local variables are
    defined within a specific function. This is important because if the name is reused
    within a function, its value will remain only within that function—typically.
    If you wished to change the value of a global variable, you could call the global
    version with the global keyword and set a new value. This practice should be avoided,
    if at all possible. As an example of local and global variable usage, see this
    code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量是在函数外定义的，局部变量是在特定函数内定义的。这很重要，因为如果在函数内重复使用名称，其值通常只会在该函数内保留。如果你希望改变全局变量的值，你可以使用global关键字调用全局版本并设置一个新值。如果可能的话，应该避免这样做。关于局部和全局变量的使用示例，请参见以下代码：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following output of this script shows the printing of the local variable
    `hacker` within the `local_variable_example` function example. Then, we have the
    printing of the global variable `hacker` after the function has been executed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的输出显示了在`local_variable_example`函数示例中打印局部变量`hacker`，然后在函数执行后打印全局变量`hacker`。
- en: '![Global and local variables](img/B04315_02_02.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![全局和局部变量](img/B04315_02_02.jpg)'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example shows how to insert a value into a string through a variable.
    Further along in this chapter, several methods of doing this are provided.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了如何通过变量将值插入到字符串中。在本章的后面，将提供几种方法来实现这一点。
- en: Understanding a namespace
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解命名空间
- en: 'The basic idea of a variable in Python is a name; these names reside in a bucket.
    Every module or script receives its own global namespace, and the names reside
    in this bucket, which is called the namespace. This means that when a name is
    used, it is reserved for a specific purpose. If you use it again, it is going
    to result in one of two things: either you are going to overwrite the value or
    you are going to see an error.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python中变量的基本概念是一个名称；这些名称驻留在一个桶中。每个模块或脚本都有自己的全局命名空间，这些名称驻留在这个桶中，这个桶被称为命名空间。这意味着当一个名称被使用时，它是为特定目的而保留的。如果你再次使用它，会导致两种情况之一：要么你会覆盖这个值，要么你会看到一个错误。
- en: Modules and imports
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和导入
- en: 'Within Python, a library or module can be imported to execute a specific task
    or supplement functionality. When you have written your own script, you can import
    a script as a module to be used within a new script. There are a couple of ways
    of doing this, and each way has its benefits and disadvantages:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以导入库或模块来执行特定任务或补充功能。当你编写自己的脚本时，你可以将一个脚本作为模块导入到一个新的脚本中使用。有几种方法可以做到这一点，每种方法都有其优点和缺点：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This allows you to import a module and use it and functions by referencing
    them similar to a function. As an example, you could reference the module and
    the function within the module as `module.function()`. This means that your namespace
    is kept simple and you do not have to worry about overwrites and collisions, unlike
    the following method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你导入一个模块并使用它和函数，通过引用它们类似于一个函数。例如，你可以引用模块和模块内的函数为`module.function()`。这意味着你的命名空间保持简单，你不必担心覆盖和冲突，不像以下方法：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is very commonly seen in Python scripts and examples on the Internet. The
    danger is that all functions or functions within the module are brought in directly.
    This means that if you defined a function within your script named `hacker_tool`
    and `hacker_tool` (the imported module contains a module with the same name),
    you could get a namespace collision and produce multiple errors. At runtime, when
    the script is interpreted, it will take up a larger memory footprint because unnecessary
    functions are imported. The benefit, however, is that you will not have to identify
    the necessary function, nor will you have to the method of `module.function()`.
    You can instead just directly call `function()`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Python脚本和互联网上的示例中非常常见。危险在于所有函数或模块内的函数都直接引入。这意味着如果你在脚本中定义了一个名为`hacker_tool`的函数，而`hacker_tool`（被导入的模块包含同名的模块），你可能会遇到命名空间冲突并产生多个错误。在运行时，当脚本被解释时，它将占用更多的内存空间，因为不必要的函数被导入。然而，好处是你不必识别必要的函数，也不必使用`module.function()`的方法。相反，你可以直接调用`function()`。
- en: 'The next two methods are ways of referencing a module or function as a different
    name. This allows you to shorten statements that need reuse and can often improve
    readability. The same namespace conflicts are present, so your imports and references
    should be defined carefully. The first is the declaration of a module as a different
    name:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两种方法是引用模块或函数为不同的名称。这允许你缩短需要重用的语句，并且通常可以提高可读性。相同的命名空间冲突存在，因此你的导入和引用应该谨慎定义。第一种是将模块声明为不同的名称：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The second is the declaration of a function as a different name:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种是将函数声明为不同的名称：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are other methods of executing these tasks, but this is enough to read
    the majority of the scripts produced and create useful tools.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他执行这些任务的方法，但这已经足够阅读大部分生成的脚本并创建有用的工具了。
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you know that Python modules are scripts themselves? You can take a look
    at how these products work by checking out the `Lib` directory within the Python
    installation of Windows, which defaults to `C:\Python27\Lib` for Python 2.7\.
    In Kali Linux, it can be found at `/usr/lib/python2.7`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道Python模块本身就是脚本吗？你可以通过查看Windows Python安装中的`Lib`目录来了解这些产品的工作方式，默认情况下为`C:\Python27\Lib`对于Python
    2.7\. 在Kali Linux中，它可以在`/usr/lib/python2.7`找到。
- en: Python formatting
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python格式化
- en: This language's greatest selling feature for me is its formatting. It takes
    very little work to put a script together, and because of its simplistic formatting
    requirements, you reduce chances of errors. For experienced programmers, the loathsome
    `;` and `{}` signs will no longer impact your development time due to syntax errors.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言对我来说最大的卖点是它的格式。将脚本放在一起需要很少的工作，由于其简单的格式要求，您减少了出错的机会。对于有经验的程序员来说，可恶的`;`和`{}`符号不再会因为语法错误而影响您的开发时间。
- en: Indentation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进
- en: 'The most important thing to remember in Python is indentation. Python uses
    indents to show where logic blocks are changed. So, if you are writing a simple
    `print` script as mentioned earlier, you are not necessarily going to see this,
    but if you are writing an `if` statement, you will. See the following example,
    which prints the statement previously mentioned here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中最重要的是缩进。Python使用缩进来显示逻辑块的更改位置。因此，如果您正在编写一个简单的`print`脚本，就像前面提到的那样，您不一定会看到这一点，但是如果您正在编写一个`if`语句，您会看到。请参见以下示例，它打印了先前在此处提到的语句：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More details on how this script operates and executes can be found in the *Compound
    statements* section of this chapter. The following example prints the statement
    to the screen if execute is not `False`. This indentation signifies that the function
    separates it from the rest of the global code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此脚本的操作和执行的更多详细信息可以在本章的*复合语句*部分找到。以下示例在执行不是`False`时将语句打印到屏幕上。这个缩进表示该函数将其与全局代码分开。
- en: 'There are two ways of creating an indent: either through spaces or through
    tabs. Four spaces are equivalent to one tab; the indentation in the preceding
    code signifies the separation of the codes logic from the rest of the global code.
    The reason for this is that spaces translate better when moved from one system
    type to another, which again makes your code more portable.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种创建缩进的方法：通过空格或制表符。四个空格相当于一个制表符；前面代码中的缩进表示代码逻辑与全局代码的分离。这样做的原因是，当从一个系统类型移动到另一个系统时，空格的转换效果更好，这样可以使您的代码更具可移植性。
- en: Python variables
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python变量
- en: 'The Python scripting language has five types of variables: numbers, strings,
    lists, dictionaries, and tuples. These variables have different intended purposes,
    reasons for use, and methods of declaration. Before seeing how these variable
    types work, you need to understand how to debug your variables and ensure that
    your scripts are working.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python脚本语言有五种变量类型：数字、字符串、列表、字典和元组。这些变量具有不同的预期目的、使用原因和声明方法。在了解这些变量类型的工作方式之前，您需要了解如何调试变量并确保您的脚本正常工作。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lists, tuples, and dictionaries fall under a variable category know as **data
    structures**. This chapter covers enough details to get you off the ground and
    running, but most of the questions you notice about Python in help forums are
    related to proper use and handling of data structures. Keep this in mind when
    you start venturing on your own projects outside of the details given in this
    book. Additional information about data structures and how to use them can be
    found at [https://docs.python.org/2/tutorial/datastructures.html](https://docs.python.org/2/tutorial/datastructures.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、元组和字典属于一个名为**数据结构**的变量类别。本章涵盖了足够的细节来让您起步并运行，但是您在帮助论坛中注意到的关于Python的大部分问题都与数据结构的正确使用和处理有关。在您开始在本书中给出的细节之外进行自己的项目时，请记住这一点。有关数据结构及其使用方法的更多信息可以在[https://docs.python.org/2/tutorial/datastructures.html](https://docs.python.org/2/tutorial/datastructures.html)找到。
- en: Debugging variable values
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试变量值
- en: 'The simple solution for debugging variable values is to make sure that the
    expected data is passed to a variable. This is especially important if you need
    to convert a value in a variable from one type to another, which will be covered
    later in this chapter. So, you need to know what the value in the variable is,
    and often what type it is. This means that you will have to debug your scripts
    as you build them; this is usually done through the use of `print` statements.
    You will often see initial scripts sprinkled with `print` statements throughout
    the code. To help you clean these at a later point in time, I recommend adding
    a comment to them. I typically use a simple `#DEBUG` comment, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 调试变量值的简单解决方案是确保预期的数据传递给变量。如果需要将变量中的值从一种类型转换为另一种类型，这一点尤为重要，这将在本章后面进行介绍。因此，您需要知道变量中的值，通常还需要知道它的类型。这意味着您将不得不在构建脚本时调试它们；这通常是通过使用`print`语句来完成的。您经常会看到初始脚本中散布着`print`语句。为了帮助您在以后的某个时间点清理它们，我建议给它们添加注释。我通常使用一个简单的`#DEBUG`注释，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will allow you to quickly search for and delete the `#DEBUG` line. In
    vi or vim, this is very simple—by first pressing *Esc*, then pressing *:*, and
    then executing the following command, which searches for and deletes the entire
    line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您快速搜索并删除`#DEBUG`行。在vi或vim中，这非常简单——首先按下*Esc*，然后按下*:*，然后执行以下命令，搜索并删除整行：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you wanted to temporarily comment out all of the `#DEBUG` lines and delete
    them later, you can use the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想暂时注释掉所有`#DEBUG`行并稍后删除它们，可以使用以下方法：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: String variables
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串变量
- en: 'Variables that hold strings are basically words, statements, or sentences placed
    in a reference. This item allows easy reuse of values as needed throughout a script.
    Additionally, these variables can be manipulated to produce different values over
    the course of the script. To pass a value to the variable, the equal to sign is
    used after the word has been selected to assign a value. In a string, the value
    is enclosed in either quotes or double quotes. The following example shows how
    to assign a value using double quotes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 保存字符串的变量基本上是放置在引用中的单词、语句或句子。这个项目允许在脚本中需要时轻松重用值。此外，这些变量可以被操纵以在脚本的过程中产生不同的值。要将值传递给变量，需要在选择单词后使用等号来分配一个值。在字符串中，值要么用单引号括起来，要么用双引号括起来。以下示例显示了如何使用双引号分配一个值：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following example shows single quotes assigned to a variable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The reason for allowing both single and double quotes is to grant a programmer
    the means to insert one or the other into a variable as a part of a sentence.
    See the following example to highlight the differences:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In addition to passing strings or printing values in this method, you can use
    the same type of quote to escape the special character. This is done by preceding
    any special character with a `\` sign, which effectively escapes the special capability.
    The following example highlights this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The important thing about declaring strings is to pick a type of quote to use—either
    single or double—and use it consistently through the script. Additionally, as
    you can see in Python, variable sizes do not have to be declared initially. This
    is because they are interpreted at runtime. Now you know how to create variables
    with strings in them. The next step is to create variables with numbers in them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Number variables
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating variables that hold numbers is very straight forward. You define a
    variable name and then assign it a value by placing a number on the right-hand
    side of an equal to sign, as shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once a variable has been defined, it holds a reference to the value it was passed.
    These variables can be overwritten, can have mathematical operations executed
    against them, and can even be changed in the middle of the program. The following
    example shows variables of the same type being added together and printed. First,
    we show the same variable added and printed, and then we show two different variables.
    Finally, the two variables are added together, assigned to a new variable, and
    printed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Number variables](img/B04315_02_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the numerical values passed to the variables do not have quotes.
    If they did, the Python interpreter would consider them as strings, and the results
    would be significantly different. Refer to the following screenshot, which shows
    the same method prescribed to numeric variables with string equivalents:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Number variables](img/B04315_02_05.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the values are—instead—merged into a single string verses adding
    them together. Python has built-in functions that allow us to interpret strings
    as numbers and numbers as strings. Additionally, you can determine what a variable
    is using the `type function`. This screenshot shows the declaration of two variables,
    one as a string and one as an integer:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Number variables](img/B04315_02_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Had the variable been declared with a decimal value in it, it would have been
    declared as a floating-point number or a `float` for short. This is still a numeric
    variable, but it requires a different method of storage, and as you can see, the
    interpreter has determined that for you. The following screenshot shows an example
    of this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Number variables](img/B04315_02_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: Converting string and number variables
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the number variables section, Python has functions that are
    built-in in a manner that allows you to convert one variable type to another.
    As a simple example, we are going to convert a number into a string and string
    into a number. When using the interactive interpreter, the variable value will
    be printed immediately if it is not passed to a new variable; however, in a script,
    it will not. This method of manipulation is extremely useful if data is passed
    by the **Command-line Interface** (**CLI**) and you want to ensure the method
    that the data will be handled.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'This is executed using the following three functions: `int()`, `str()`, and
    `float()`. These functions do exactly what you think they would; `int()` changes
    the applicable variables of other types to integers, `str()` turns other applicable
    variable types to strings, and `float()` turns applicable variables to floating-point
    numbers. It is important to keep in mind that if the variable cannot be converted
    to the desired type, you will receive a `ValueError` exception, as shown in this
    screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting string and number variables](img/B04315_02_08.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_08.jpg)'
- en: 'As an example, let''s take a string and an integer and try to add them together.
    If the two values are not of the same type, you will receive a `TypeError` exception.
    This is demonstrated in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们拿一个字符串和一个整数并尝试将它们加在一起。如果这两个值不是相同类型，你将会收到一个`TypeError`异常。这在以下屏幕截图中得到了证明：
- en: '![Converting string and number variables](img/B04315_02_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_09.jpg)'
- en: 'This is where you will have to determine what type the variable is and choose
    one of them to convert to the same type. Which one you choose to convert will
    depend on the expected outcome. If you want a variable that contains the total
    value of two numbers, then you need to convert string variables into number type
    variables. If you want the values to be combined together, then you would convert
    the non-string variable into a string. This example shows the definition of two
    values: one of a string and one of an integer. The string will be converted into
    an integer to allow the mathematical operation to continue, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你必须确定变量的类型并选择其中一个转换为相同类型的地方。你选择转换哪一个将取决于预期的结果。如果你想要一个包含两个数字总值的变量，那么你需要将字符串变量转换为数字类型变量。如果你想要将值组合在一起，那么你将把非字符串变量转换为字符串。这个例子展示了两个值的定义：一个是字符串，一个是整数。字符串将被转换为整数以允许数学运算继续进行，如下所示：
- en: '![Converting string and number variables](img/B04315_02_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_10.jpg)'
- en: 'Now that you can see how easy this is, consider what would happen if a string
    variable was the representative of a `float` value and was converted to an integer.
    The decimal portion of the number will be lost. This does not round the value
    up or down; it just strips the decimal part and gives a whole number. Refer to
    the following screenshot to understand an example of this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到这是多么容易，考虑一下如果一个字符串变量代表一个`float`值并被转换为整数会发生什么。数字的小数部分将会丢失。这不会将值四舍五入；它只是去掉小数部分并给出一个整数。请参考以下屏幕截图以了解这个例子：
- en: '![Converting string and number variables](img/B04315_02_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![转换字符串和数字变量](img/B04315_02_11.jpg)'
- en: So be sure to change the numeric variable to the appropriate type. Otherwise,
    some data will be lost.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所以一定要将数字变量更改为适当的类型。否则，一些数据将会丢失。
- en: List variables
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表变量
- en: 'Lists are data structures that hold values in a method that can be organized,
    adjusted, and easily manipulated. An easy way to identify a list in Python is
    by `[]`, which denotes where the values will reside. The manipulation of these
    lists is based on adjusting the values by position, typically. To create a list,
    define a variable name, and on the right-hand side of the equal to sign, place
    brackets with comma-separated values. This simple script counts the length of
    a predefined list and iterates and prints the position and value of the list.
    It is important to remember that a list starts at position 0, not 1\. Since a
    list can contain different types of variables in order to include other lists,
    we are going to print the values as strings to be safe:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一种数据结构，以一种可以组织、调整和轻松操作的方式保存值。在Python中识别列表的简单方法是通过`[]`，它表示值将驻留的位置。对这些列表的操作是基于通常通过位置调整值。要创建一个列表，定义一个变量名，并在等号的右侧放置用逗号分隔的值的括号。这个简单的脚本计算预定义列表的长度，并迭代并打印列表的位置和值。重要的是要记住，列表从位置0开始，而不是1。由于列表可以包含不同类型的变量以包含其他列表，我们将打印值作为字符串以确保安全：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following screenshot shows the successful execution of this script:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此脚本的成功执行：
- en: '![List variables](img/B04315_02_12.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![列表变量](img/B04315_02_12.jpg)'
- en: 'As you can see, extracting values from a list and converting them into numerical
    or string values are important concepts. Lists are used to hold multiple values,
    and extracting these values so that they can be represented is often necessary.
    The following code shows you how to do this for a string:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，从列表中提取值并将它们转换为数字或字符串值是重要的概念。列表用于保存多个值，并提取这些值以便它们可以被表示通常是必要的。以下代码向你展示了如何对字符串执行此操作：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is important to note that a list cannot be printed as an integer, so it
    has to be either converted to a string or iterated through and printed. To show
    only the simple differences, the following code demonstrates how to extract an
    integer value from the list and print both it and a string:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，列表不能被打印为整数，所以它必须要么转换为字符串，要么通过迭代打印。为了只显示简单的差异，以下代码演示了如何从列表中提取一个整数值并打印它和一个字符串：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'List values can be manipulated further with list-specific functions. All you
    have to do is call the name of the list and then add `.function(x)` to the list,
    where `function` is the name of the specific activity you want to accomplish and
    `x` is the position or data you want to manipulate. Some common functions used
    include adding values to the end of a list, such as the number 555, which would
    be accomplished like this: `list_example.append(555)`. You can even combine lists;
    this is done using the `extend` function, which adds the relevant items at the
    end of the list. This is accomplished by executing the function as follows: `list_example.extend(list_example2)`.
    If you want to remove the value of 555, you can simply execute `list_example.remove(555)`.
    Values can be inserted in specific locations using the appropriately named `insert`
    function like this: `list_example.insert(0, 555)`. The last function that will
    be described here is the `pop` function, which allows you to either remove the
    value at a specific location by passing a positional value, or remove the last
    entry in the list by specifying no value.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Tuple variables
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tuples are similar to lists, but unlike lists, they are defined using `()`.
    Also, they are immutable; that is, they cannot be changed. The motive behind this
    is to provide a means of controlling data in complex operations that will not
    destroy it during the process. A tuples can be deleted, and a new tuple can be
    created to hold portions of a different tuple''s data and show as if the data
    has changed. The simple rule with tuples is as follows: if you want data to be
    unaltered, use tuples; otherwise, use lists.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary variables
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dictionaries are a means of associating a key with a value. If you see curly
    brackets, it means that you are looking at a dictionary. The key represents a
    reference to a specific value stored in an unsorted data structure. You may be
    asking yourself why you would do this when standard variables already do something
    similar. Dictionaries provide you with the means to store other variables and
    variable types as values. They also allow quick and easy referencing as necessary.
    You will see detailed examples of dictionaries in later chapters; for now, check
    out the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This example will print the numbers related to the `''james''` key, as shown
    in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Dictionary variables](img/B04315_02_13.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Adding data to dictionaries is extremely simple; you just have to assign a
    new key to the dictionary and a value for that key. For example, to add the value
    of `789` to a `''john''` key, you can execute the following: `dictionary_example[''john'']
    = 789`. This will assign the new value and key to the dictionary. More details
    about dictionaries will be covered later, but this is enough to gain an understanding
    of them.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Understanding default values and constructors
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: People who have programmed or scripted previously are probably used to declaring
    a variable with a default value or setting up constructors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In Python, this is not necessary to get started, but it is a good habit to set
    a default value in a variable prior to its use. Besides being good practice, it
    will also mitigate some of the reasons for your scripts to have unexpected errors
    and crashes. This will also add traceability if a value is passed to a variable
    that was unexpected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, constructor methods are handled by `__init__` and `__new__` when
    a new object is instantiated. When creating new classes, however, it is only required
    to use the `__init__` function to act as the constructor for the class. This will
    not be needed until much later, but keep it in mind; it is important if you want
    to develop a multithreaded application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Passing a variable to a string
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say that you want to produce a string with a dynamic value, or include
    a variable in the string as it is printed and interpret the value in real time.
    With Python, you can do it in a number of ways. You can either combine the data
    using arithmetic symbols, such as `+`, or insert values using special character
    combinations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example will use a combination of two strings and a variable joined
    with the statement to create a dynamic statement, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This produces the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing a variable to a string](img/B04315_02_14.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: After creating the first script, you can improve it by inserting a value directly
    into the string. This is done by using the `%` special character and appending
    `s` for a string or `d` for a digit to produce the intended result. The `print`
    statement then has the `%` sign appended to it, with parameters wrapped around
    the requisite variable or variables. This allows you to control data quickly and
    easily and clean up your details as you prototype or create your scripts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables in the parameters are passed to replace the keyed symbol in the
    statement. Here is an example of this type of script:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following image shows the code being executed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing a variable to a string](img/B04315_02_15.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'An added benefit is that you can insert multiple values into this script without
    drastically altering it, as shown in the following example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![Passing a variable to a string](img/B04315_02_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: 'This form of insertion can be done with digits as mentioned in the preceding
    lines and by changing `%s` to `%d`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output can be seen in this screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing a variable to a string](img/B04315_02_17.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Instead of using variables, statements can be passed directly. There is usually
    little reason to do such things, as variables provide you with a means to change
    code and have it applied to the entire script. When possible, variables should
    be used to define statements as necessary. This is very important when you start
    writing statements that will be passed to systems. Use a combination of joined
    variables to create commands that will be executed in your Python scripts. If
    you do so, you can change the content provided to the system by simply changing
    a specific value. More examples on this will be covered later.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators in Python are symbols that represent functional executions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details about this can be found at [https://docs.python.org/2/library/operator.html](https://docs.python.org/2/library/operator.html).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember is that Python has extensive capabilities that
    allow complex mathematical and comparative operations. Only a few of them will
    be covered here to prepare you for more detailed work.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A comparison operator checks whether a condition is true or false based on the
    method of evaluation. In simpler terms, we try to determine whether one value
    equals, does not equal, is greater than, is less than, is greater than or equal
    to, or is less than or equal to another value. Interestingly enough, the Python
    comparison operators are very straightforward.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table will help define the details of operators:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '| Comparison test | Operator |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| Are the two values equal? | == |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| Are the values not equal? | != |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| Is the value on the left greater than the value on the right? | > |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| Is the value on the left less than the value on the right? | < |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| Is the value on the left greater than or equal to the value on the right?
    | >= |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| Is the value on the left less than or equal to the value on the right? |
    <= |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: Assignment operators
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assignment operators confuse most people when they transition from a different
    language. The reason for this is that AND assignment operators are different from
    most languages. People who are used to writing incrementors short hands of `variable
    = variable + 1` from in other languages using the format `variable++`, they are
    often confused to see the exact operation is not done in Python.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The functional equivalent of a variable incrementor in Python is `variable=+1`,
    which is the same as `variable = variable + 1`. You might notice something here,
    however; you can define what is added to the variable in this expression. So,
    instead of the double addition sign, which means, "add 1 to this variable," the
    AND expression allows you to add anything you want to it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important when you write exploits, because you can append multiple
    hexadecimal values to the same string with this operator, as shown in the previous
    string concatenation example, where two strings were added together. [Chapter
    8](ch08.html "Chapter 8. Exploit Development with Python, Metasploit, and Immunity"),
    *Exploit Development with Python, Metasploit, and Immunity*, will cover more of
    this when you develop a **Remote Code Executio**n (**RCE**) exploit. Until then,
    consider this table to see the different assignment operators and what they are
    used for:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '| Assignment action | Operator |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| Set a value to something | = |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| Add a value to the variable on the left, and set the new value to the same
    variable on the left | += |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| Subtract a value from the variable on the left, and set the new value to
    the same variable on the left | -= |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| Multiply a value by the variable on the left, and set the new value to the
    same variable on the left | *= |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| Divide a value by the variable on the left, and set the new value to the
    same variable on the left | /= |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: Arithmetic operators
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arithmetic operators are extremely simple overall and are what you would expect.
    Addition executions use the `+` symbol, subtraction executions use `-`, multiplication
    executions use `*`, and division executions use `/`. There are also additional
    items that can be used, but these four cover the majority of cases you are going
    to see.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Logical and membership operators
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logical and membership operators utilize words instead of symbols. Generally,
    Python's most confusing operators are membership operators, because new script
    writers think of them as logical operators. So let's take a look at what a logical
    operator really is.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'A logical operator helps a statement or a compound statement determine whether
    multiple conditions are met so as to prove a `true` or `false` condition. So what
    does this mean in layman terms? Look at the following script, which helps determine
    whether two variables contain the values required to continue the execution:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Logical operators include `and`, `or`, and `not`, which can be combined with
    more complex statements. The `not` operator here can be confused with `not in`,
    which is part of a membership operator. A `not` test reverses the combined condition
    test. The following example highlights this specifically; if both values or `False`
    or not equal to each other, then the condition is met; otherwise, the test fails.
    The reason for this is that the test checks whether it is both. Examples similar
    to this do surface, but they are not common, and this type of code can be avoided
    if you are not feeling comfortable with the logic flow yet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Membership operators, instead, test for the value being part of a variable.
    There are two of these types of operators, `in` and `not in`. Here is an example
    of their usage:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The logic of this code will cause the statement to return as `True` and the
    first conditional message will be printed to screen.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Compound statements
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compound statements contain other statements. This means a test or execution
    while `true` or `false` executes the statements within itself. The trick is to
    write statements so that they are efficient and effective. Examples of this include
    `if then` statements, loops, and exception handling.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The if statements
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `if` statement tests for a specific condition, and if that condition is
    met (or not met), then the statement is executed. The `if` statement can include
    a simple check to see whether a variable is `true` or `false`, and then print
    the details, as shown in the following example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `if` statement can even be used to check for multiple conditions at the
    same time. Keep in mind that it will execute the first portion of the compound
    statement that meets the condition and skip the rest. Here is an example that
    builds on the previous one, using `else` and `elif` statements. The **else** statement
    is a catch all if none of the `if` or `elif` statements are met. An `elif` test
    is a follow-on `if` test. Its condition can be tested after `if` and before `else`.
    Refer to the following example to understand this better:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see from these statements, the second `elif` statement will process
    the results. Change the value of `x` to something else and see how the script
    flow really works.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep one thing in mind: testing for conditions requires thinking through the
    results of your test. The following is an example of an `if` test that may not
    provide the expected results depending on the variable value:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This script sets the `execute` variable to `True`. Then, `if` is the script
    with the `print` statement. If the variable had not been set to `True` and had
    not been set to `False` either, the statement would have still been printed. The
    reason for this is that we are simply testing for the `execute` variable not being
    equal to `False`. Only if `execute` had been set to `False` would nothing be printed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Python loops
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A loop is a statement that is executed over and over until a condition is either
    met or not met. If a loop is created within another loop, it is known as an embedded
    loop. In penetration testing, having multiple loops within each other is typically
    not considered best practice. This is because it can create situations of memory
    exhaustion if they are not properly controlled. There are two primary forms of
    loops: `while` loops and `for` loops.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `while` loops are useful when a situation is true or false and you want
    the test to be executed as long as the condition is valid. As an example, this
    `while` loop checks whether the value of `x` is greater than `0`, and if it is,
    the loop continues to process the data:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The for loop
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` loop is executed with the idea that a defined situation has been
    established and it is going to be tested. As a simple example, you can create
    a script that counts a range of numbers between 1 and 15, one number at a time,
    and then prints the results. The following example of a `for` loop statement does
    this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The break condition
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `break` condition is used to exit a loop and continue processing the script
    from the next statement. Breaks are used to control loops when a specific situation
    occurs within the loop instead of the next iteration of a loop. Even though breaks
    can be used to control loops, you should consider writing your code in such a
    way that you don''t need breaks. The following loop with a `break` condition will
    stop executing if the variable value equals `5`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of this script is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![The break condition](img/B04315_02_18.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'Though this works, the same results can be achieved with a better designed
    script, as shown in the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As you can see here, the same results are produced with cleaner and more manageable
    code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![The break condition](img/B04315_02_19.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: Conditional handlers
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python, like many other languages, has the ability to handle situations where
    exceptions or relatively unexpected things occur. In such situations, a catch
    will occur and capture the error and the follow-on activity. This is completed
    with the `try` and `except` clauses, which handle the condition. As an example,
    I often use conditional handlers to determine whether the necessary library is
    installed, and if it is not, it tells you how and where to get it. This is a simple,
    but effective, example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Functions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python functions allow a scripter to create a repeatable task and have it called
    frequently throughout the script. When a function is part of a class or module,
    it means that a certain portion of the script can be called specifically from
    another script, also known as a module, once imported to execute a task. An additional
    benefit in using Python functions is the reduction of script size. An often unexpected
    benefit is the ability to copy functions from one script to another, speeding
    up development.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The impact of dynamically typed languages on functions on functions
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that variables hold references to objects, so as the script is written,
    you are executing tests with variables that reference the value. One fact about
    this is that the variable can change and can still point to the original value.
    When a variable is passed to a function through a parameter, it is done as an
    alias of the original object. So, when you are writing a function, the variable
    name within the function will often be different—and it should be. This allows
    easier troubleshooting, cleaner scripts, and more accurate error control.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Curly brackets
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have ever written in another language, the one thing that will surprise
    you is that there are no curly brackets like these: `{}`. This is usually done
    to delineate where the code for a logic test or compound statement stops and begins,
    such as a loop, an `if` statement, a function, or even an entire class. Instead,
    Python uses the aforementioned indentation method, and the deeper the indent,
    the more nested the statement.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A nested statement or function means that within a logic test or compound statement,
    another an additional logic test is being performed. An example would be an `if`
    statement within another `if` statement. More examples of this type will be seen
    later in this chapter.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: To see a difference between logic tests in Python and other languages, an example
    of a Perl function known as a subroutine will be shown. An equivalent Python function
    will also be demonstrated to showcase the differences. This will highlight how
    Python controls logic flows throughout a script. Feel free to try both of these
    scripts and see how they work.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following Python script is slightly longer than the Perl one due to the
    fact that a `return` statement was included. This is not necessary for this script,
    but it is a habit many scripters get into. Additionally, the `print` statement
    has been modified, as you can see, to support both version 2.X and version 3.X
    of Python.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the `Perl` function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following function is the equivalent in Python:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of both of these scripts can be seen in this screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Curly brackets](img/B04315_02_03.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: Instead, in Python, curly brackets are used for dictionaries, as previously
    described in the *Python variable* section of this chapter.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: How to comment your code
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a scripting language, a comment is useful for blocking code and/or describing
    what it is trying to achieve. There are two types of comments in Python: single-line
    and multiline. Single-line comments make everything from the `#` sign to the end
    of the line a comment; it will not be interpreted. If you place code on the line
    and then follow it up with a comment at the end of the line, the code will still
    be processed. Here is an example of effective single-line comment usage:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This works, but it may be easier to do the same thing using a multiline comment,
    as there are two lines within the preceding code are comments. Multiline comments
    are created by placing three quotes in each line that begins and ends the comment
    block. The following code shows an example of this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The Python style guide
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing your scripts, there are a few naming conventions to observe that
    are common to scripting and programming. These conventions are more of guidelines
    and best practices than hard rules, which means that you will hear opinions on
    both sides. As scripting is a form of art, you will see examples that rebut these
    suggestions, but following them will improve readability.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most of the suggestions here were borrowed from the style guide for Python,
    which can be found at [http://legacy.python.org/dev/peps/pep-0008/](http://legacy.python.org/dev/peps/pep-0008/),
    and follow-on style guides.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: If you see specifics here that do not directly match this guide, keep in mind
    that all assessors develop habits and styles that differ. The trick is to incorporate
    as many of the best practices as possible while not impacting the speed and quality
    of development.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes typically begin with an uppercase letter, and the rest of the first
    word is lowercase. Each word after that starts with an uppercase letter as well.
    As such, if you see a defined reference being used and it begins with an uppercase
    letter, it is likely a class or module name. No spaces or underscores should be
    used between the words used to define a class, though people typically forget
    or break this rule.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are developing functions, remember that the words should be lowercase
    and separated by underscores.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Variables and instance names
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables and instances should be lowercase with underscores separating the
    words, and if they are private, they must lead with two underscores. `Public`
    and `Private` variables are common in major programming languages, but in Python,
    they are not truly necessary. If you would like to emulate the functionality of
    a `private` variable in Python, you can lead the variable with `__` to define
    it as private. A private member's major benefit in Python is the prevention of
    namespace clashing.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Arguments and options
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways in which arguments can be passed to scripts; we will
    cover more on this in future chapters, as they are applicable to specific scripts.
    The simplest way to take arguments is to pass them without options. Arguments
    are the values passed to scripts to give them some dynamic capability.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Options are flags that represent specific calls to the script, stating the arguments
    that are going to be provided. In other words, if you want to get the help or
    usage instructions for a script, you typically pass the `-h` option. If you write
    a script that accepts both IP addresses and MAC addresses, you could configure
    it to use different options to signify the data that is about to be presented
    to it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Writing scripts to take options is significantly more detailed, but it is not
    as hard as people make it out to be. For now, let's just look at basic argument
    passing. Arguments can be made natively with the `sys` library and the `argv`
    function. When arguments are passed, a list containing them is created in `sys.argv`,
    which starts at position 0.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The first argument provided to `argv` is the name of the script run, and each
    argument provided thereafter represents the other argument values:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output of this script produces the following result:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Arguments and options](img/B04315_02_20.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: Your first assessor script
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have understood the basics of creating scripts in Python, let's
    create a script that will actually be useful to you. In later chapters, you will
    need to know your local and public IP addresses for each interface, hostname,
    **Media Access Control** (**MAC**) addresses, and **Fully Qualified Domain Name**
    (**FQDN**). The script that follows here demonstrates how to execute all of these.
    A few of the concepts here may still seem foreign, especially how IP and MAC addresses
    are extracted from interfaces. Do not worry about that; this is not the script
    you are going to write. You can use this script if you like, but it is here to
    show you that you can salvage components of scripts—even seemingly complex ones—to
    develop your own simple scripts.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script uses a technique to extract IP addresses for Linux/Unix systems
    by querying the details based on an interface that has been used in several Python
    modules and examples. The specific recipe for this technique can be found in many
    places, but the best documented reference to this technique can be found at [http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/](http://code.activestate.com/recipes/439094-get-the-ip-address-associated-with-a-network-inter/).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the script into its components. This script uses a few functions
    that make execution cleaner and repeatable. The first function is called `get_ip`.
    It takes an interface name and then tries to identify an IP address for that interface:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The second function, called `get_mac_address`, identifies the MAC address of
    a specific interface:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, these functions rely on the low-level network interface language
    of the socket library. Your concentration should not be on understanding every
    detail about this function, but more on the flow of information, the types of
    variables being used, and how the libraries are integrated. The reason for this
    is that you are going to generate a script later that requires fewer components
    and replicates the activity of grabbing a public IP address later.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The third function gets the details of the host and returns them to the main
    part of the script. It determines whether the host is Windows or not so that the
    correct functions are called. The function accepts two lists, one for Ethernet
    interfaces and the wireless interfaces typical in Linux/Unix. These interfaces
    are processed through the previous functions called in this bigger function. This
    allows the decision-making to be handled by the `get_localhost_details` function,
    and then returns the values for the host that will be represented by the `print`
    statements at the end of the script:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The final function in this script is called `get_public_ip`, which queries
    a known website for the IP address that is connected to it. This IP address is
    returned to the web page in a simple, raw format. There are a number of sites
    against which this can be done, but make sure you know the acceptable use and
    terms of service authorized. The function accepts one input, which is the website
    you are executing the query against:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For Windows systems, this script utilizes the simple `socket.gethostbyname(socket.gethostname())`
    function request. This does work for Linux, but it relies on the `/etc/hosts`
    file to have the correct information for all interfaces. Much of this script can
    be replaced by the `netifaces` library, as pointed out by the previous reference.
    This would greatly simplify the script, and examples of its use will be shown
    in the following Chapter. The `netifaces` library is not installed by default,
    and so you will have to install it on every host on which you want to run this
    script. Since you typically do not want to make any impact on a host's integrity,
    this specific script is designed to avoid that conflict.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final version of this script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/hostdetails.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/hostdetails.py).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the output of running this script. Components
    of this script will be used in later chapters, and they allow the automated development
    of exploit configurations and reconnaissance of networks.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Your first assessor script](img/B04315_02_21.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'So your useful script is going take components of this script and only find
    the public IP address of the system you are on. I recommend that you try doing
    this prior to looking at the following code (which shows what the actual script
    looks like). If you want to skip this step, the solution can be seen here:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of your script should look similar to this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![Your first assessor script](img/B04315_02_22.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script can be found at [https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/publicip.py](https://raw.githubusercontent.com/funkandwagnalls/pythonpentest/master/publicip.py).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on taking you through the basics of how the Python scripting
    language works and developing your own code by example. It also pointed out the
    common pitfalls related to creating scripts for assessments. The final section
    of this chapter focused on how to create useful scripts, even by simply piecing
    together components of already generated examples.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we are going to dive even deeper into this subject
    with a proper reconnaissance of an environment, using `nmap`, `scapy`, and automation
    with Python.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
