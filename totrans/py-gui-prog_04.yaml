- en: Reducing User Error with Validation and Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our form works, and both the director and data entry personnel are thrilled
    with the form design, but we''re not ready for production yet! Our form doesn''t
    yet perform the promised task of preventing or discouraging user errors. Number
    boxes still allow letters, combo boxes aren''t limited to the choices given, and
    dates have to be filled in by hand. In this chapter, we''re going to cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deciding on the best approach for validating user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use Tkinter's validation system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom widgets for our form that validate entered data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating default values where appropriate in our form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Validating user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first glance, Tkinter's selection of the input widgets seems a little disappointing.
    It doesn't give us a true number entry that only allows digits, nor a true drop-down
    selector that only allows items from the drop-down list to be selected. We have
    no date inputs, email inputs, or other specially-formatted input widgets.
  prefs: []
  type: TYPE_NORMAL
- en: But these weaknesses can become strengths. Because these widgets assume nothing,
    we can make them behave in a way that's appropriate to our specific needs, rather
    than some generic way that may or may not work optimally. For example, letters
    may seem inappropriate in a number entry, but are they? In Python, strings such
    as `NaN` and `Infinity` are valid float values; having a box that could increment
    numerals but also handle those string values may be very useful in some applications.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to learn how to shape our widgets to our needs, but before we learn
    how to control this behavior, let's think about what we want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies to prevent data errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no universal answer to how a widget should react to a user trying
    to enter bad data. The validation logic found in various graphics toolkits can
    differ greatly; when bad data is entered, an input widget might validate the user
    input as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Prevent the invalid keystrokes from registering at all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept the input, but return an error or list of errors when the form is submitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show an error when the user leaves the entry field, perhaps disabling form submission
    until it's corrected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock the user in the entry field until valid data is entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Silently correct the bad data using a best-guess algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The correct behavior in a data entry form (which is filled out hundreds of times
    a day by users who may not even be looking at it) may be different from an instrument
    control panel (where values absolutely must be correct to avoid a disaster) or
    an online user registration form (which is filled out once by a user who has never
    seen it before). We need to ask ourselves and our users about which behavior will
    best minimize errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'After discussing this with your users on the data entry staff, you come to
    the following set of guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever possible, meaningless keystrokes should be ignored (for example, letters
    in a number field)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty field should register an error (all fields are required), with the
    exception of `Notes`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields containing bad data should be marked in some visible way with an error
    describing the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form submission should be disabled if there are fields with errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the following requirements to our specification before moving on.
    Under the `Required Features` section, update the hard requirements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, how do we implement this?
  prefs: []
  type: TYPE_NORMAL
- en: Validation in Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tkinter''s validation system is one of those parts of the toolkit that is less
    than intuitive. It relies on the following three configuration options that we
    can pass into any input widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate`: This option determines which type of event will trigger the validation
    callback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validatecommand`: This option takes the command that will determine if the
    data is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalidcommand`: This option takes a command that will run if `validatecommand`
    returns `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This seems pretty straightforward, but there are some unexpected curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values we can pass to `validate` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Validates string** | **Triggers when** |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | It is none that turns off validation |'
  prefs: []
  type: TYPE_TB
- en: '| `focusin` | The user enters or selects the widget |'
  prefs: []
  type: TYPE_TB
- en: '| `unfocus` | The user leaves the widget |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | Either `focusin` or `focusout` |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | The user enters text in the widget |'
  prefs: []
  type: TYPE_TB
- en: '| `all` | `focusin`, `focusout`, and `key` |'
  prefs: []
  type: TYPE_TB
- en: The `validatecommand` argument is where things get tricky. You might think this
    takes the name of a Python function or method, but that's not quite it. Instead,
    we need to give it a tuple containing a reference to a Tcl/`Tk` function, and
    optionally some **substitution codes** that specify information about the triggering
    event that we want to pass into the function.
  prefs: []
  type: TYPE_NORMAL
- en: How do we get a reference to a Tcl/`Tk` function? Fortunately, this isn't too
    hard; we just pass a Python callable to the `.register()` method on any Tkinter
    widget. This returns a string that we can use with `validatecommand`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, validation functions aren't very useful unless we pass in some data
    to be validated. To do this, we add one or more substitution codes to our `validatecommand`
    tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'These codes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Value passed** |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | A code indicating the action being attempted: `0` for `delete`, `1`
    for insert, and `-1` for other events. Note that this is passed as a string, and
    not as an integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `%P` | The proposed value that the field would have after the change (key
    events only). |'
  prefs: []
  type: TYPE_TB
- en: '| `%s` | The value currently in the field (key events only). |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` | The index (from `0`) of the text being inserted or deleted on key
    events, or `-1` on non-key events. Note that this is passed as a string, not as
    an integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | For insertion or deletion, the text that is being inserted or deleted
    (key events only). |'
  prefs: []
  type: TYPE_TB
- en: '| `%v` | The widget''s `validate` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `%V` | The event that triggered validation: `focusin`, `focusout`, `key`,
    or `forced` (indicating the text variable was changed). |'
  prefs: []
  type: TYPE_TB
- en: '| `%W` | The widget''s name in Tcl/`Tk`, as a string. |'
  prefs: []
  type: TYPE_TB
- en: The `invalidcommand` option works exactly the same way, requiring the use of
    the `.register()` method and substitution codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what this looks like together, consider the following code for an `Entry` widget
    that only accepts five characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a function that simply returns whether or not the length
    of a string is less than or equal to five characters. We then register this function
    with `Tk` using the `register()` method, saving its reference string as `wrapped_function`.
    Next, we build our `validatecommand` tuple using the reference string and the
    `'%P'` substitution code, which represents the proposed value (the value that
    the entry would have if the key event was accepted).
  prefs: []
  type: TYPE_NORMAL
- en: You can pass in as many substitution codes as you wish, and in any order, as
    long as your function is written to accept those arguments. Finally, we'll create
    our `Entry` widget, setting the validation type to `key` and passing in our validation
    command tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we did not define an `invalidcommand` method in this case; when validation
    is triggered by a keystroke, returning `False` from the `validate` command will
    cause the keystroke to be ignored. This is not the case when triggering validation
    from a focus or other event type; in that case, there is no default behavior defined
    and an `invalidcommand` method is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following alternate, class-based version of `FiveCharEntry`, which
    allows you to type as much as you want, but truncates your text when you leave
    the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This time, we've implemented validation by subclassing `Entry` and defining
    our validation logic in a method rather than an external function. This simplifies
    access to the widget in our validation methods.
  prefs: []
  type: TYPE_NORMAL
- en: The underscores at the beginning of `_validate()`  and `_on_invalid()` indicate
    that these are internal methods meant to be accessible only within the class.
    While it's not necessary to make this code work correctly, and Python does not
    treat it any differently from a normal method, it lets other programmers know
    that these methods are for internal use and shouldn't be called outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: We've also changed the `validate` argument to `focusout` and added an `_on_invalid()`
    method that truncates the value in `Entry`. Whenever the widget loses focus, the
    `_validate()` method will be called with the entered text. If it fails, `_on_invalid()`
    will be called, causing the contents to be truncated using the `Entry` widget's
    `delete()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a DateEntry widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try creating a validating version of our `Date` field. We''ll make a
    `DateEntry` widget that prevents most erroneous keystrokes, then checks for date
    validity on `focusout`. If the date is invalid, we''ll mark the field in some
    way and display an error. Let''s perform the following steps to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file called `DateEntry.py` and begin with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since we'll need `datetime` for our validation method, we import it here at
    the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We subclass `ttk.Entry`, then start our constructor method with a call to `super().__init__()`
    as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we use `self.config()` to alter the configuration of the widget. You might
    wonder why we don't pass these arguments into the `super().__init__()` call; the
    reason is that the `self.register()` method doesn't exist until the underlying
    `Entry` widget has been initialized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re registering the following two methods: `self._validate` and `self._on_invalid`,
    which we''ll write shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_validate()`: This method will get the inserted text (`%S`), the index of
    insertion (`%i`), the type of event (`%V`), and the action performed (`%d`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_on_invalid()`: This method will only get the event type. Since we want to
    validate on both keystrokes and `focusout`, we''ll set `validate` to `all`. Our
    validation methods can figure out which event is taking place by looking at the
    event type (`%V`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we create `StringVar` to hold our error text; this will be accessed
    outside the class, so we don't use the leading underscore in its name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next method we create is `_toggle_error()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using this method to consolidate the widget''s behavior in the case
    of an error. It starts by setting our `error` variable to the string provided.
    If the string is not blank, we turn on the error marking (in this case, turning
    the text red); if it''s blank, we turn off the error marking. The `_validate()`
    method is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is toggle off our error status and set a `valid` flag
    to `True`. Our input will be `innocent until proven guilty`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we'll look at keystroke events. `if action == '0':` tells us if the user
    is trying to delete characters. We always want to allow this so that the user
    can edit the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The basic format of an ISO date is: four digits, a dash, two digits, a dash,
    and two digits. We can test whether the user is following this format by checking
    whether the inserted characters match our expectation at the inserted `index`.
    For example, `index in (''0'', ''1'', ''2'', ''3'', ''5'', ''6'', ''8'', ''9'')`
    will tell us if the character being inserted is one of the positions that requires
    a digit, and if so we check that the character is a digit. An index of `4` or
    `7` should be a dash. Any other keystroke is invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: Although you might expect them to be integers, Tkinter passes the action codes
    and indexes them as strings. Keep this in mind when writing your comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a hopelessly naive heuristic for a correct date, since it allows
    for complete nonsense dates like `0000-97-46` or right-looking-but-still-wrong
    dates like `2000-02-29`, it at least enforces the basic format and removes a large
    number of invalid keystrokes. A completely accurate partial date analyzer is a
    project unto itself, so for now this will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking our date for correctness on `focusout` is simpler and much more foolproof,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since we have access to the final value the user meant to enter at this point,
    we can use `datetime.strptime()` to try to convert the string to a Python `datetime`
    using the format `%Y-%m-%d`. If this fails, we know the date is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: To end the method, we return our `valid` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Validation methods must always return a Boolean value. If, for some reason,
    your validation method doesn't return a value (or returns `None`), your validation
    will silently break without any error. Be careful to make sure your methods will
    always return a Boolean value, especially if you're using multiple `return` statements.
  prefs: []
  type: TYPE_NORMAL
- en: As you saw previously, for invalid keystrokes, it's sufficient to return `False`
    and prevent the character from being inserted, but for errors on focus events,
    we'll need to respond in some way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the  `_on_invalid()` method in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We pass only the event type into this method, which we'll use to ignore keystroke
    events (they're already adequately handled by the default behavior). For any other
    event type, we'll use our `_toggle_error()` method to display the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our `DateEntry` class, add the following test code to the bottom of
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and run it to try the new `DateEntry` class. Try entering various
    bad dates or invalid keystrokes, and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing validated widgets in our form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to validate your widgets, you have your work cut out for
    you! We have 16 input widgets, and you'll have to write code like that shown in
    the previous section for all of them to get the behavior we need. Along the way,
    you'll need to make sure the widgets respond consistently to errors and present
    a consistent API to the application.
  prefs: []
  type: TYPE_NORMAL
- en: If that sounds like something you'd like to put off indefinitely, I can't blame
    you. Maybe there's a way we can cut down the amount of code we need to write.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the power of multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned that Python allows us to create new classes by subclassing,
    inheriting features from the super class, and only adding or changing what's different
    about our new class. Python also supports **multiple inheritance**, where a subclass
    can inherit from multiple superclasses. We can exploit this feature to our advantage
    by creating what's called a **mixin** class.
  prefs: []
  type: TYPE_NORMAL
- en: Mixin classes contain only a specific set of functionalities that we want to
    be able to mix in with other classes to compose a new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We implement a basic class called `Displayer` with a `display()` method that
    prints a message. Then, we create a mixin class called `LoggerMixin`, which both
    adds a `log()` method to write a message to a text file and overrides the `display()`
    method to add a call to `log()`. Finally, we create a subclass by inheriting from
    both `LoggerMixin` and `Displayer`. The subclass then overrides the `log()` method
    and sets a different filename.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a class using multiple inheritance, the rightmost class we specify
    is called the **base class**, and mixin classes should be specified before it.
    There's no special syntax for a mixin class as opposed to any other class, but
    pay attention to the use of `super()` in the mixin's `display()` method. Technically,
    `LoggerMixin` inherits from Python's built-in `object` class, which has no `display()`
    method. How, then, can we call `super().display()` here?
  prefs: []
  type: TYPE_NORMAL
- en: 'In a multiple inheritance situation, `super()` does something a little more
    complex than just standing in for the superclass. It looks up the chain of inheritance
    using something called the **Method Resolution Order** and determines the nearest
    class that defines the method we''re calling. Thus, when we call `MySubclass.display()`,
    a series of method resolutions occurs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MySubClass.display()` is resolved to `LoggerMixin.display()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoggerMixin.display()` calls `super().display()`, which is resolved to `Displayer.display()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also calls `self.log()`. Since `self`, in this case, is a `MySubClass` instance,
    it resolves to `MySubClass.log()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MySubClass.log()` calls `super().log()`, which is resolved back to `LoggerMixin.log()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this seems confusing, just remember that `self.method()` will look for `method()`
    in the current class first, then follow the list of inherited classes from left
    to right until the method is found. The `super().method()` will do the same, except
    that it skips the current class.
  prefs: []
  type: TYPE_NORMAL
- en: The method resolution order of a class is stored in its `__mro__` property;
    you can inspect this method in a Python shell or debugger if you're having trouble
    with inherited methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `LoggerMixin` is not usable on its own: it only works when combined
    with a class that has a `display()` method. This is why it''s a mixin class because
    it''s meant to be mixed in to enhance other classes.'
  prefs: []
  type: TYPE_NORMAL
- en: A validating mixin class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s apply our knowledge of multiple inheritance to build a mixin that will
    give us some boilerplate validation logic by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `data_entry_app.py` and start the class before your `Application` class
    definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We start this class as usual, though we're not subclassing anything this time.
    The constructor also has an extra argument called `error_var`. This will allow
    us to pass in a variable to use for the error message; if we don't, the class
    creates its own. The call to `super().__init__()` will cause the base class that
    we mix with to execute its constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we set up validation, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We're setting up our `validate` and `invalid` methods here. We'll go ahead and
    pass in all the substitution codes (except `'%w'`, the widget name, since it's
    fairly useless inside a class context). We're running validation on all conditions,
    so we can capture both focus and keystroke events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll define our error condition handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will just change the text color to red if there''s an error, or black
    otherwise. We don''t set the error in this function, since we''ll want to set
    the actual error text in the validate method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our `_validate()` method just handles a few setup chores like toggling off the
    error and clearing the error message. Then, it runs an event-specific validate
    method, depending on the event type passed in. We only care about the `key` and
    `focusout` events right now, so any other event just returns `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we call the individual methods using keywords; when we create our
    subclasses, we'll be overriding these methods. By using keyword arguments, our
    overridden functions can just specify the needed keywords or extract individual
    arguments from `**kwargs`, rather than having to get all the arguments in the
    right order. Also notice that all the arguments are passed into `_key_validate()`,
    but only `event` is passed into `_focusout_validate()`. Focus events don't return
    anything useful for any of the other arguments, so there's no point in passing
    them along.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ultimate idea here is that our subclasses only need to override the validation
    method or methods we care about for that widget. If we don''t override them, they
    just return `True`, so validation passes. Now, we need to handle an invalid event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We take an identical approach to these methods. Unlike the validate methods,
    though, our invalid data handlers don't need to return anything. For invalid keys,
    we do nothing by default, and for invalid data on `focusout`, we toggle our error
    status on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keystroke validation only really makes sense in the context of entering keys,
    but there may be times when we want to manually run the `focusout` checks, since
    it effectively checks a completely entered value. For this reason, we''ll implement
    the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re just duplicating the logic that occurs when a `focusout` event happens:
    run the validation function, and if it fails, run the invalid handler. This is
    all we need for `ValidatedMixin`, so let''s start applying it to some of our widgets
    and see how it works.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building our widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s think through what classes we need to implement with our new `ValidatedMixin`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All our fields except `Notes` are required, so we'll need a basic `Entry` widget
    that registers an error if there's no input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have one `Date` field, so we need an `Entry` widget that enforces a valid
    date string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a number of the `Spinbox` widgets for decimal or integer input. We'll
    need to make sure these only accept valid number strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a few `Combobox` widgets that don't behave quite the way we want them
    to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Requiring data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of our fields are required, so let''s start with a basic `Entry` widget
    that requires data. We can use these for fields: `Technician` and `Seed sample`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code under the `ValidatedMixin` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There's no keystroke validation to do here, so we just need to create `_focusout_validate()`.
    If the entered value is empty, we just set an error string and return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: A Date widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s apply the mixin class to the `DateEntry` class we made before,
    keeping the same validation algorithm as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, pretty simple, all we need to do is specify the validation logic. We've
    added the logic from our `RequiredEntry` class too, since the `Date` value is
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to something a bit more intricate.
  prefs: []
  type: TYPE_NORMAL
- en: A better Combobox widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The drop-down widgets in different toolkits behave fairly consistently when
    it comes to mouse operation, but the response to keystrokes varies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Some do nothing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some require the use of arrow keys to select items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some move to the first entry that begins with any key pressed, and cycle through
    entries beginning with that letter on subsequent presses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some narrow down the list to entries that match what's typed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to think about what behavior our `Combobox` widget should have. Since
    our users are accustomed to doing data entry with the keyboard, and some have
    difficulty with the mouse, the widget needs to work with the keyboard. Making
    them use repeated keystrokes to select options is not very intuitive, either.
    After talking with the data entry staff, you decide on this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: If the proposed text matches no entries, it will be ignored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the proposed text matches a single entry, the widget is set to that value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A delete or backspace clears the entire box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add this code under the `DateEntry` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `_key_validate()` method starts out by setting up a `valid` flag and doing
    a quick check to see if this is a delete action. If it is, we set the value to
    a blank string and return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add the logic to match the proposed text to our values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A copy of the widget's list of values is retrieved using its `.cget()` method.
    Then, we use list comprehension to reduce this list to only the entries that match
    the proposed text, calling `lower()` on both the values in the list item and the
    proposed text so that our match is case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Every Tkinter widget supports the `.cget()` method. It can be used to retrieve
    any of the widget's configuration values by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the length of the matching list is `0`, we reject the keystroke. If it''s
    `1`, we''ve found our match, so we''ll set the variable to that value. If it''s
    anything else, we need to let the user keep typing. As a final touch, we''ll send
    the cursor to the end of the field using the `.icursor()` method if a match is
    found. This isn''t strictly necessary, but it looks better than leaving the cursor
    in the middle of the text. Now, we''ll add the `focusout` validator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to do much here, because the key validation method ensures that
    the only possible values are a blank field or an item in the values list, but
    since all fields are required to have a value, we'll copy the validation from
    `RequiredEntry`.
  prefs: []
  type: TYPE_NORMAL
- en: That takes care of our `Combobox` widget. Next, we'll deal with the `Spinbox` widget.
  prefs: []
  type: TYPE_NORMAL
- en: A range-limited Spinbox widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number entry seems like it shouldn't be too complicated to deal with, but
    there are a number of subtleties to work through to make it bulletproof. In addition
    to limiting the field to valid number values, you'll want to enforce the `from`,
    `to`, and `increment` arguments as the minimum, maximum, and precision of the
    input, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm needs to implement the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Deletion is always allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits are always allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `from` is less than `0`, a minus is allowed as the first character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `increment` has a decimal component, one dot is allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the proposed value is greater than the `to` value, ignore the keystroke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the proposed value requires more precision than `increment`, ignore the keystroke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `focusout`, make sure the value is a valid number string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also on `focusout`, make sure the value is greater than the `from` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we''ll code, regarding the preceding rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We'll start by overriding the `__init__()` method so that we can specify some
    defaults and grab the `increment` value from the constructor arguments for processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Spinbox` arguments can be passed in as floats, integers, or strings. Regardless
    of how you pass them in, Tkinter converts them to floats. Determining the precision
    of a float is problematic, because of floating-point error, so we want to convert
    it to a Python `Decimal` before it becomes a float.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Floats attempt to represent decimal numbers in binary form. Open a Python shell
    and enter `1.2 / .2`. You might be surprised to find the answer is `5.999999999999999`
    rather than `6`. This is known as a **floating-point error**, and it's a source
    of computation error in nearly every programming language. Python offers us the
    `Decimal` class, which takes a numeric string and stores it in a way that makes
    mathematical operations safe from floating-point errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use `Decimal`, we need to import it. Add the following code to
    your imports at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`InvalidOperation` is an exception thrown when `Decimal` is given a string
    it cannot interpret. We''ll be using it later on.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that we cast `increment` to `str` before passing it to `Decimal`. Ideally,
    we should pass `increment` in as a string to ensure it will be interpreted correctly,
    but in case we need to pass in a float for some reason, `str` will do some sensible
    rounding first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also set defaults for `to` and `from_`: `-Infinity` and `Infinity`. Both
    `float` and `Decimal` will happily accept these values and treat them as you''d
    expect them to do. The default `to` and `from_` values for `Tkinter.Spinbox` are
    `0`; if they''re left there, Tkinter treats it as no limit, but this creates a
    problem if we specify one but not the other.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We extract `precision` of the `resolution` value as an exponent of the smallest
    valid decimal place. We'll use this value in the validation class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our constructor is settled, so let''s write the validate methods. The key validate
    method is a bit tricky, so we''ll walk through it chunk by chunk. First, we start
    the method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To begin, we retrieve the `from` and `to` values, then assign flag variables
    to indicate if negatives and decimals should be allowed, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Deletion should always work, so if it's a deletion, return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: We've broken our no multiple returns guideline here, because the same logic
    with only one `return` would be nested quite deeply. When trying to write readable,
    maintainable code, sometimes one has to pick the lesser of two evils.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we test if the keystroke is a valid character, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Valid characters are digits plus `-` and `.`. The minus sign is only valid at
    index `0`, and the dot can only appear once. Anything else returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `any` function takes a list of expressions and returns `True` if
    any one of the expressions in the list are true. There's also an `all` function
    that returns `True` if all the expressions are true. These functions allow you
    to condense a long chain of boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost guaranteed at this point to have a valid `Decimal` string, but
    not quite; we might have just `-`, `.`, or `-.` characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are valid partial entries, so we just return `True` for them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the proposed text can only be a valid `Decimal` string, so we''ll
    make a `Decimal` from it and do some more tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last two tests check to see if the proposed text is either greater than
    our maximum value, or has more precision than the `increment` that we specified
    (the reason we use a `<` operator here is because `precision` is given as a negative
    value for decimal places). In case nothing has been returned yet, we return the
    `valid` value as a safeguard. Our `focusout` validator is much simpler, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the entire intended value, we only need to make sure it's a valid `Decimal`
    string and greater than the minimum value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, our `ValidatedSpinbox` is ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically adjusting the Spinbox range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `ValidatedSpinbox` method seems adequate for most of our fields. But consider
    the `Height` fields for a moment. It would not make any sense for the `Mini height`
    value to be more than the `Max height` value, or for the `Median height` value
    not to be between them. Is there some way we can work this kind of interdependent
    behavior into our class?
  prefs: []
  type: TYPE_NORMAL
- en: We can! To do this, we'll rely on the **tracing** feature of Tkinter variables.
    A trace is essentially a hook into the `.get()` and `.set()` methods of variables
    that allows you to trigger any Python function or method when a variable is read
    or changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first argument to `.trace()` indicates which event we want to trace. Here, `w`
    indicates a write (`.set()`), `r` indicates a read (`.get()`), and `u` indicates
    an undefined variable or deletion of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Our strategy will be to allow optional `min_var` and `max_var` variables into
    the `ValidatedSpinbox` method and set a trace on these variables to update the
    `ValidatedSpinbox` method's min or max value whenever this variable is changed.
    We'll also have a `focus_update_var` variable that will be updated with the `Spinbox` widget
    value at `focusout` time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll update our `ValidatedSpinbox` constructor as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, note that we've added a line to store our variable in `self.variable`,
    and we create one if the program doesn't pass one in explicitly. Some of the code
    we need to write will depend on a text variable existing, so we'll force this,
    just in case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we pass in either a `min_var` or `max_var` argument, the value is stored
    and a trace is configured. The `trace()` method points to an appropriately named
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also store a reference to the `focus_update_var` argument and bind the `<FocusOut>`
    event to a method that will be used to update it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `bind()` method can be called on any Tkinter widget, and it's used to connect
    widget events to a Python callable. Events can be keystrokes, mouse movements
    or clicks, focus events, window management events, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to add the callback methods for our `trace()` and `bind()` commands.
    Start with `_set_focus_update_var()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method simply gets the widget's current value and, if there is a `focus_update_var` argument
    present in the instance, sets it to the same value. Note that we don't set the
    value if there's an error currently present on the widget. It wouldn't make sense
    to update the value to something invalid.
  prefs: []
  type: TYPE_NORMAL
- en: When Tkinter calls a `bind` callback, it passes in an event object that contains
    information about the event that triggered the callback. Even if you aren't going
    to use this information, your function or method needs to be able to take this
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the callback for setting the minimum, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is retrieve the current value. `Tkinter.Spinbox` has the
    slightly annoying behavior of correcting its value when the `to` or `from` values
    are changed, moving too-low values to the `from` value and too-high values to
    the `to` value. This kind of silent auto-correction might slip past the attention
    of our user and cause bad data to be saved. What we want is to leave the value
    out of range and mark it as an error; so to work around Tkinter, we're going to
    save the current value, change the configuration, and then put the original value
    back in the field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the current value saved, we attempt to get the value of the `min_var` and
    set our widget's `from_` value from it. There are several things that could go
    wrong here, such as a blank or invalid value in whatever field controls our minimum
    and maximum variables, all of which should throw either a `tk.TclError` or a `ValueError`.
    In either case, we'll just do nothing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's generally a bad idea to just silence exceptions; however, in this case,
    there's nothing we can reasonably do if the variable is bad except ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we just need to write the current value that we saved back into the field.
    If it's empty, we just delete the field; otherwise, we set the input's variable. 
    The method ends with a call to the `trigger_focusout_validation()` method to re-check
    the value in the field against the new minimum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `_set_maximum()` method will be identical to this method, except that it
    will update the `to` value using `max_var` instead.  You can write it yourself,
    or see the sample code included with the book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is one last change we need to make to our `ValidatedSpinbox` class. Since
    our maximum can potentially change after entry, and we're relying on our `focusout`
    validation to detect that, we'll need to add some conditions to check the maximum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to add this to the  `_focusout_validate()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Add those lines just before the `return` statement to check the maximum value
    and set the error, as appropriate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating our form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our widgets are all made, it''s time to make the form use them by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to the `DataRecordForm` class constructor, and we''ll start updating
    our widgets one row at a time. Line 1 is fairly straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s as simple as swapping out the `input_class` value in each `LabelInput`
    for our new class. Go ahead and run your application and try out the widgets.
    Try some different valid and invalid dates, and see how the `Combobox` widget
    works (`RequiredEntry` won''t do much at this point, since the only visible indication
    is red text, and there''s no text to mark red if it''s empty; we''ll address that
    later on). Now, on to line 2, first add the `Lab` widget, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `Plot` widget, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Fairly straightforward again, but if you run it, you'll find there's a problem
    with `Plot`. It turns out that our `ValidatedComobox` method doesn't work right
    when the values are integers since the characters the user types are always strings
    (even if they're digits); we can't compare strings and integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think about it, `Plot` shouldn''t really be an integer value. Yes, the
    values are technically integers, but as we decided back in Chapter 3, *Creating
    Basic Forms with Tkinter and ttk Widgets,* they could as well be letters or symbols;
    you wouldn''t do maths on a plot number. So, we''ll change `Plot` to use a `StringVar` variable
    and make the values of the widget strings as well. Change the `Plot` widget creation,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're just changing the `input_var` to a `StringVar` and using a list
    comprehension to cast every `values` item to a string. Now, `Plot` works as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue through the form, replacing the default `ttk` widgets with your newly
    validated versions. For the `Spinbox` widget, make sure you''re passing in the
    `to`, `from_`, and `increment` values as strings rather than integers. For instance,
    the `Humidity` widget should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When we get to the `Height` boxes, it''s time to put our `min_var` and `max_var`
    features to the test. First, we need to set up variables to store the minimum
    and maximum height, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We create two new `DoubleVar` objects to hold the current minimum and maximum
    heights, setting them to infinite values to begin with. This ensures there will
    be effectively no minimum or maximum height to start with.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our widgets won't be affected by these values until they actually
    change, so they won't nullify the original `to` and `from_` values passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we create the `Min Height` widget, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use `max_height_var` to set the maximum here, ensuring that our minimum
    will never go above the maximum value, and set the `focus_update_var` to `min_height_var` values
    so that it will be updated whenever this field is changed. Now, the `Max Height`
    widget is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we use our `min_height_var` variable to set the widget''s minimum
    value and update the `max_height_var` from the widget''s current value. Finally,
    the `Median Height` field is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're setting the minimum and maximum values for the field from the `min_height_var`
    and `max_height_var` variables, respectively. We're not updating any variables
    from the `Median Height` field, although we could add additional variables and
    code here to make sure that `Min Height` couldn't go above it or `Max Height`
    below it. In most cases, it won't matter if the user is entering data in order
    since `Median Height` is last.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You might wonder why we don''t just use the `input_var` variables from `Min
    Height` and `Max Height` to hold these values instead. If you try this, you''ll
    discover the reason: the `input_var` updates as you type, which means your partial
    value instantly becomes the new maximum or minimum value. We''d rather wait until
    the user has committed the value to assign this, and thus we created a separate
    variable that is only updated on `focusout`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displaying errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you run the application, you may notice that while fields with the `focusout`
    errors turn red, we don''t get to see the actual error. We need to fix this by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate your `LabelInput` class, and add the following code to the end of the
    constructor method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we check to see if our input has an error variable, and if not, we create
    one. We save a reference to it as `self.error`, then create a `Label` with the
    error as `textvariable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we place this under the input widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you try the application, you should be able to see the field errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preventing form submission on error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step in preventing errors from getting into our CSV file is to stop
    the application from saving if the form has known errors. Let''s perform the following
    steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in implementing this is to provide a way for the `Application`
    object (which handles saving the data) to retrieve the error status from the `DataRecordForm`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the end of the `DataRecordForm` class, add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Similar to how we handled getting the data, we just loop through the `LabelFrame`
    widgets. We look for inputs that have the `trigger_focusout_validation` method
    and call it, just to be sure that all values have been checked. Then, if the widget's
    `error` variable has any value, we add it to an `errors` dictionary. This way,
    we can retrieve a dictionary of field names and the errors on each field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we need to add this behavior to the `Application` class's save logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the beginning of `on_save()`, under `docstring`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This logic is straightforward: get the errors, if we find any, and alert the
    user in the status area and return from the function (thus not saving anything).'
  prefs: []
  type: TYPE_NORMAL
- en: Start the application and try it out by trying to save a blank form. You should
    get error messages in all fields and a message at the bottom telling you which
    fields have errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automating input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preventing users from entering bad data is one way to help users enter better
    data; another approach is to automate. Using our understanding of how the forms
    are likely to be filled out, we can insert values that are very likely to be correct
    for certain fields.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from [Chapter 2](3ec510a4-0919-4f25-9c34-f7bbd4199912.xhtml), *Designing
    GUI Applications with Tkinter,* that the forms are nearly always recorded the
    same day that they're filled out, and that they're filled out one at a time from
    `Plot` 1 to `Plot` 20 in order. Also remember that the `Date`, `Lab`, and `Technician`
    values remain the same for each form which is filled in. Let's automate this for
    our users.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inserting the current date is an easy place to start. The place to do this is
    in the `DataRecordForm.reset()` method, which sets up the form for entering a
    new record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update that method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Just as we do in the `Application.save()` method, we get the current date from
    `datetime.today()` and format it as an ISO date. Then, we set the `Date` widget's
    input to that value.
  prefs: []
  type: TYPE_NORMAL
- en: Automating Lab, Time, and Technician
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Something which is slightly more complex is our handling of `Lab`, `Time`,
    and `Technician`. Let''s review the logic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Before clearing the data, save the `Lab`, `Time`, and `Technician` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `Plot` is less than the last value (`20`), we'll put those values back after
    clearing all the fields, then increment to the next `Plot` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If `Plot` is the last value or no value, leave those fields blank. The code
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Because `Plot` looks like an integer, it might be tempting to increment it like
    one, but it's better to work with it as though it were not. We use the indexes
    of the values list instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last tweak, the focus of the form always starts in the first field, but
    this means the user has to tab through fields that are already filled in. It would
    be nice if the next empty inputs were focused at the start instead. Tkinter inputs
    have a `focus()` method, which gives them keyboard focus. Depending on which fields
    we''ve filled in, this will either be `Time` or `Seed sample`. Under the line
    that sets the `Date` value, add the following code line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And under the line that sets the `Plot` value, inside the conditional block,
    add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our form is now ready for a trial run with our users. It's definitely an improvement
    over the CSV entry at this point, and will help data entry to make quick work
    of those forms.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application has really come a long way. In this chapter, we learned about
    Tkinter validation, created a validation mixin class, and used it to create validated
    versions of the `Entry`, `Combobox`, and `Spinbox` widgets. We validated different
    kinds of data on keystrokes and focus events, and created fields that dynamically
    update their constraints based on the value of related fields.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to prepare our code base for expansion and
    learn how to organize a large application for easier maintenance. More specifically,
    we'll learn about the MVC pattern and how to structure our code in multiple files
    for simpler maintenance. We'll also learn more about RST and and version control
    software.
  prefs: []
  type: TYPE_NORMAL
