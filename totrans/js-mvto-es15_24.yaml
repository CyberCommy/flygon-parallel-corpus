- en: Chapter 11. Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems like no book on programming these days is complete without at least
    some mention of microservices. For fear that this book could be singled out for
    ridicule as a non-conformant publication, a chapter has been included on microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices are billed as the solution to the problems of monolithic applications.
    Likely every application you''ve dealt with has been a monolith: that is, the
    application has a single logical executable and is perhaps split into layers such
    as a user interface, a service or application layer, and a data store. In many
    applications these layers might be a web page, a server side application, and
    a database. Monoliths have their issues as I''m sure you''ve encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a monolithic application quickly becomes an exercise in limiting
    the impact of change. Frequently in such applications a change to one, seemingly
    isolated, corner of the application has an unintended effect on some other part
    of the application. Although there are many patterns and approaches to describe
    well isolated components, these often fall by the wayside inside a monolith. Often
    we take shortcuts which may save time now but will return to make our lives terrible
    down the road.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic applications are also difficult to scale. Because we tend to have
    only three layers, we are limited to scaling each one of those layers. We can
    add more application servers if the middle tier is becoming slow or more web servers
    if the web tier is laggy. If the database is slow then we can increase the power
    of the database server. These scaling approaches are very large operations. If
    the only part of the application which is slow is signing up new users, then we
    really have no way to simply scale that one component. This means that components
    which are not frequently used (one might call these cold or cool components) must
    be able to scale as the whole application scales. This sort of scaling doesn't
    come for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that scaling from a single web server to multiple web servers introduces
    the problem of sharing sessions between many web servers. If we were, instead,
    to divide our application into a number of services, of which each acts as the
    canonical source of truth for a piece of data, then we could scale these sections
    independently. A service for logging users in, another service for saving and
    retrieving their preferences, yet another for sending out reminder e-mails about
    abandoned shopping carts, each one responsible for its own functions and own data.
    Each service stands alone as a separate application and may run on a separate
    machine. In effect we have taken our monolithic application and sharded it into
    many applications. Not only does each service have an isolated function but it
    also has its own datastore and could be implemented using its own technology.
    The difference between a monolith and microservices can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Applications are written more by composing services than by writing singular
    monolithic applications. The UI of an application can even be created by asking
    a number of services to provide visual components to be slotted into a composite
    UI by some form of composing service.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js' lightweight approach to building applications with just the required
    components makes it an ideal platform to build lightweight microservices. Many
    microservice deployments make heavy use of HTTP to communicate between services
    while others rely more heavily on messaging systems such as **RabbitMQ** or **ZeroMQ**.
    These two communication methods may be mixed in deployments. One might split the
    technology used along the lines of using HTTP against services which are query-only,
    and messaging against services which perform some action. This is because messaging
    is more reliable (depending on your messaging system and configuration) than sending
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem that we've introduced a great deal of complexity into the
    system it is a complexity that is easier to manage with modern tooling. Very good
    tooling exists for managing distributed log files and for monitoring the performance
    of applications for performance issues. Isolating and running many applications
    with virtualization is more approachable than ever with containerization technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices may not be the solution to all our maintenance and scalability
    issues but they are certainly an approach that is viable for consideration. In
    this chapter we''ll explore some of the patterns that may assist in using microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message upgrader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service selector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because microservices are a relatively new development, there are likely to
    be many more patterns which emerge as more and more applications are created with
    the microservice approach. There is some similarity between the Microservices
    approach and **Service Oriented** **Architecture** (**SOA**). This means that
    there are likely some patterns from the SOA world which will be applicable in
    the microservices world.
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you feel that you recognize the name of this pattern, then you're correct.
    We discussed this pattern way back in [Chapter 4](part0102_split_000.html#318PC1-015e68c68a464f18a9559f448be84435
    "Chapter 4. Structural Patterns"), *Structural Patterns*. In that application
    of the pattern we created a class which could direct the actions of a number of
    other classes providing a simpler API. Our example was that of an admiral who
    directed a fleet of ships. In the microservices world we can simply replace the
    concept of classes with that of services. After all, the functionality of a service
    is not that different from a microservice – they both perform a single action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might make use of a façade to coordinate the use of a number of other services.
    This pattern is a base pattern for many of the other patterns listed in this chapter.
    Coordinating services can be difficult, but by putting them behind a façade we
    can make the entire application much simpler. Let us consider a service which
    sends e-mails. Sending e-mails is quite a complex process which may involve a
    number of other services: a username to e-mail address translator, an anti-malware
    scanner, a spam checker, a formatter to message the e-mail body for various e-mail
    clients, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most clients who want to send e-mail don''t want to concern themselves with
    all of these other services so a façade e-mail-sending service can be put in place
    which holds the responsibility of coordinating other services. The coordination
    pattern can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Façade](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Service selector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along the same lines as a façade we have the service selector pattern. In this
    pattern we have a service which fronts a number of other services. Depending on
    the message which arrives, a different service could be selected to respond to
    the initial request. This pattern is useful in upgrade scenarios and for experimentation.
    If you''re rolling out a new service and want to ensure that it will function
    correctly under load then you could make use of the service selector pattern to
    direct a small portion of your production traffic to the new service while monitoring
    it closely. Another application might be for directing specific customers or groups
    of customers to a different service. The distinguishing factor could be anything
    from directing people who have paid for your service toward faster end points,
    to directing traffic from certain countries to country-specific services. The
    service selector pattern can be seen in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service selector](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Aggregate services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data in a microservice architecture is owned by a single service, but there
    are many times when we might need to retrieve data from a number of different
    sources at once. Consider, again, a member of the Small Council in the land of
    Westeros. They may have a number of informants from whom they gather information
    about the workings of the kingdom. You can consider each informant to be its own
    microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Informants are a fantastic metaphor for microservices as each one is independent
    and holds its own data. Services may also fail from time to time just as informants
    may be captured and terminated. Messages are passed between informants just as
    they are among a collection of microservices. Each informant should know very
    little about how the rest of the informants work, and even, who they are – an
    abstraction which works for microservices too.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the aggregate service pattern, we ask each one of a collection of nodes
    to perform some action or return some piece of data. This is a fairly common pattern
    even outside the microservice world and is a special case of the façade or even
    adapter pattern. The aggregator requests information from a number of other services
    and then waits for them to return. Once all the data has been returned, then the
    aggregator may perform some additional tasks such as summarizing the data or counting
    records. The information is then passed back to the caller. The aggregator can
    be seen in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Aggregate services](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This pattern may also have some provision for dealing with slow-to-return services
    or failures of services. The aggregator service may return partial results or
    return data from a cache in the event that one of the child services reaches a
    timeout. In certain architectures, the aggregator could return a partial result
    and then return additional data to the caller when it becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipeline is another example of a microservice connecting pattern. If you
    have made use of the shell on a *NIX system, then you have certainly piped the
    output of one command to another command. The programs on a *NIX system such as
    ls, sort, uniq, and grep are designed to perform just one task; their power comes
    from the ability to chain the tools together to build quite complex workflows.
    For instance, this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command will list all the unique file extensions in the current directory.
    It does this by taking the list of files, then cutting them and taking the extension;
    this is then sorted and finally passed to `uniq` which removes duplicates. While
    I wouldn't suggest having a microservice for such trivial actions as sorting or
    deduplicating, you might have a series of services which build up more and more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a query service that returns a collection of company records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This record is returned by our company lookup service. Now we can pass this
    record onto our sales accounting service which will add a sales total to the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that record can be passed onto a sales estimate service, which further
    enhances the record with an estimate of 2017 sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This sort of progressive enhancement could be reversed too by a service that
    stripped out information which shouldn''t be presented to the users. The record
    might now become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have dropped the company identifier because it is an internal identifier.
    A microservice pipeline should be bidirectional so that a quantum of information
    is passed into each step in the pipeline and then passed back out again through
    each step. This affords services the opportunity to act upon the data twice, manipulating
    it as they see fit. This is the same approach used in many web servers where modules
    such as PHP are permitted to act upon the request and the response. A pipeline
    can be seen illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipeline](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Message upgrader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the highest-risk activities with some monolithic applications is upgrading.
    To do so you basically need to upgrade the entire application at once. With even
    a medium-sized application there are far too many aspects to reasonably test.
    Thus at some point you simply need to cut over from the old system to the new
    system. With a microservice approach, the cutover can be done for each individual
    service. Smaller services mean that the risk can be spread out over a long time
    and, should something go wrong, the source of the error can be more quickly pinpointed:
    the singular new component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At issue are the services which are still talking to the old version of the
    upgraded service. How can we continue to serve these services without having to
    update all those services too? If the interface to the service remains unchanged,
    say our service calculates the distance between two points on the earth and we
    change it from using a simple Pythagorean approach to using haversine (a formula
    to find the distance between two spots on a sphere), then there may be no need
    to make changes to the input and output formats. Frequently, however, this approach
    isn''t available to us as the message format must change. Even in the previous
    example there is a possibility of changing the output message. Haversine is more
    accurate than a Pythagorean approach so we could have more significant digits
    requiring a larger data type. There are two good approaches to deal with this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue to use the old version of our service and the new version. We can
    then slowly move the client services over to the new service as time permits.
    There are problems with this approach: we now need to maintain more code. Also,
    if the reason we change the service out was one which would not permit us to continue
    to run it (a security problem, termination of a dependent service, and so on)
    then we are at something of an impasse.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade messages and pass them on. In this approach we take the old message
    format and upgrade it to the new format. This is done by, you guessed it, another
    service. This service's responsibility is to take in the old message format and
    emit the new message format. At the other end you might need an equivalent service
    to downgrade messages back to the expected output format for older services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upgrader services should have a limited lifespan. Ideally we would want to
    make updates to the services which depend on deprecated services as quickly as
    possible. The small code footprint of microservices, coupled with the ability
    to rapidly deploy services, should make these sorts of upgrade much easier than
    those used to a monolithic approach might expect. An example message upgrader
    service can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message upgrader](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Failure patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already touched upon some of the ways of dealing with failures in microservices
    in this chapter. There are, however, a couple of more interesting approaches we
    should consider. The first of these is service degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Service degradation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern could also be called graceful degradation and is related to progressive
    enhancement. Let us hark back to the example of replacing the Pythagorean distance
    function with the haversine equivalent. If the haversine service is down for some
    reason, the less demanding function could be used in its place without a huge
    impact on users. In fact, they may not notice it at all. It isn't ideal that users
    have a worse version of the service but it is certainly more desirable than simply
    showing the user an error message. When the haversine service returns to life
    then we can stop using the less desirable service. We could have multiple levels
    of fallback allowing several different services to fail while we continue to present
    a fully functional application to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Another good application of this form of degradation is to fall back to more
    expensive services. I once had an application that sent SMS messages. It was quite
    important that these messages actually be sent. We used our preferred SMS gateway
    provider the majority of the time but, if our preferred service was unavailable,
    something we monitored closely, then we would fail over to using a different provider.
  prefs: []
  type: TYPE_NORMAL
- en: Message storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already drawn a bit of a distinction between services which are query-only
    and those which actually perform some lasting data change. When one of these updating
    services fails there is still a need to run the data change code at some point
    in the future. Storing these requests in a message queue allows them to be run
    later without risk of losing any of the ever-so important messages. Typically,
    when a message causes an exception it is returned to the processing queue where
    it can be retried.
  prefs: []
  type: TYPE_NORMAL
- en: There is an old saying that insanity is doing the same thing over again and
    expecting a different outcome. However, there are many transient errors which
    can be solved by simply performing the same action over again. Database deadlocks
    are a prime example of this. Your transaction may be killed to resolve a deadlock,
    in which case performing it again is, in fact, the recommended approach. However,
    one cannot retry messages ad infinitum so it is best to choose some relatively
    small number of retry attempts, three or five. Once this number has been reached
    then the message can be sent to a dead letter or poison message queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Poison messages, or dead letters as some call them, are messages which have
    actual legitimate reasons for failing. It is important to keep these messages
    around not only for debugging purposes but because the messages may represent
    a customer order or a change to a medical record: not data you can afford to lose.
    Once the message handler has been corrected these messages can be replayed as
    if the error never happened. A storage queue and message reprocessor can be seen
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Message storage](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Message replay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although not a real production pattern, a side-effect of having a message-based
    architecture around all the services which change data is that you can acquire
    the messages for later replay outside of production. Being able to replay messages
    is very handy for debugging complex interactions between numerous services as
    the messages contain almost all the information to set up a tracing environment
    identical to production. Replay capabilities are also very useful for environments
    where one must be able to audit any data changes to the system. There are other
    methods to address such audit requirements but a very solid message log is simply
    a delight to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Indempotence of message handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final failure pattern we'll discuss is idempotence of message handling.
    As systems grow larger it is almost certain that a microservices architecture
    will span many computers. This is even more certain due to the growing importance
    of containers, which can, ostensibly, be thought of as computers. Communicating
    between computers in a distributed system is unreliable; thus, a message may end
    up being delivered more than once. To handle such an eventuality one might wish
    to make messaging handling idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more about the unreliability of distributed computing, I cannot recommend
    any paper more worth reading than *Falacies of Distributed Computing Explained*
    by Arnon Rotem-Gal-Oz at [http://rgoarchitects.com/Files/fallacies.pdf](http://rgoarchitects.com/Files/fallacies.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Idempotence means that a message can be processed many times without changing
    the outcome. This can be harder to achieve than one might realize, especially
    with services which are inherently non-transactional such as sending e-mails.
    In these cases, one may need to write a record that an e-mail has been sent to
    a database. There are some scenarios in which the e-mail will be sent more than
    once, but a service crashing in the critical section between the e-mail being
    sent and the record of it being written is unlikely. The decision will have to
    be made: is it better to send an e-mail more than once or not send it at all?'
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you think of a microservice as a class and your microservice web as an application,
    then it rapidly becomes apparent that many of the same patterns we've seen elsewhere
    in the module are applicable to microservices. Service discovery could be synonymous
    with dependency injection. Singleton, decorator, proxy; all of them could be applicable
    to the microservice world just as they are within the boundaries of a process.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that many of these patterns are somewhat chatty,
    sending significant data back and forth. Within a process there is no overhead
    to passing around pointers to data. The same is not true of microservices. Communicating
    over the network is likely to incur a performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are a fascinating idea and one which is more likely to be realized
    in the next few years. It is too early to tell if this is simply another false
    turn on the way to properly solving software engineering or a major step in the
    right direction. In this chapter we've explored a few patterns which may be of
    use should you embark upon a journey into the microservices world. Because we're
    only on the cusp of microservices becoming mainstream, it is likely that, more
    than any other chapter of this module, the patterns here will quickly become dated
    and found to be suboptimal. Remaining vigilant with regard to developments and
    being aware of the bigger picture when you're developing is highly advisable.
  prefs: []
  type: TYPE_NORMAL
