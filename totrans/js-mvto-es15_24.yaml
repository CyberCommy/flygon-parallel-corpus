- en: Chapter 11. Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It seems like no book on programming these days is complete without at least
    some mention of microservices. For fear that this book could be singled out for
    ridicule as a non-conformant publication, a chapter has been included on microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices are billed as the solution to the problems of monolithic applications.
    Likely every application you''ve dealt with has been a monolith: that is, the
    application has a single logical executable and is perhaps split into layers such
    as a user interface, a service or application layer, and a data store. In many
    applications these layers might be a web page, a server side application, and
    a database. Monoliths have their issues as I''m sure you''ve encountered.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a monolithic application quickly becomes an exercise in limiting
    the impact of change. Frequently in such applications a change to one, seemingly
    isolated, corner of the application has an unintended effect on some other part
    of the application. Although there are many patterns and approaches to describe
    well isolated components, these often fall by the wayside inside a monolith. Often
    we take shortcuts which may save time now but will return to make our lives terrible
    down the road.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic applications are also difficult to scale. Because we tend to have
    only three layers, we are limited to scaling each one of those layers. We can
    add more application servers if the middle tier is becoming slow or more web servers
    if the web tier is laggy. If the database is slow then we can increase the power
    of the database server. These scaling approaches are very large operations. If
    the only part of the application which is slow is signing up new users, then we
    really have no way to simply scale that one component. This means that components
    which are not frequently used (one might call these cold or cool components) must
    be able to scale as the whole application scales. This sort of scaling doesn't
    come for free.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that scaling from a single web server to multiple web servers introduces
    the problem of sharing sessions between many web servers. If we were, instead,
    to divide our application into a number of services, of which each acts as the
    canonical source of truth for a piece of data, then we could scale these sections
    independently. A service for logging users in, another service for saving and
    retrieving their preferences, yet another for sending out reminder e-mails about
    abandoned shopping carts, each one responsible for its own functions and own data.
    Each service stands alone as a separate application and may run on a separate
    machine. In effect we have taken our monolithic application and sharded it into
    many applications. Not only does each service have an isolated function but it
    also has its own datastore and could be implemented using its own technology.
    The difference between a monolith and microservices can be seen here:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![Microservices](img/00088.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: Applications are written more by composing services than by writing singular
    monolithic applications. The UI of an application can even be created by asking
    a number of services to provide visual components to be slotted into a composite
    UI by some form of composing service.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Node.js' lightweight approach to building applications with just the required
    components makes it an ideal platform to build lightweight microservices. Many
    microservice deployments make heavy use of HTTP to communicate between services
    while others rely more heavily on messaging systems such as **RabbitMQ** or **ZeroMQ**.
    These two communication methods may be mixed in deployments. One might split the
    technology used along the lines of using HTTP against services which are query-only,
    and messaging against services which perform some action. This is because messaging
    is more reliable (depending on your messaging system and configuration) than sending
    HTTP requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: While it may seem that we've introduced a great deal of complexity into the
    system it is a complexity that is easier to manage with modern tooling. Very good
    tooling exists for managing distributed log files and for monitoring the performance
    of applications for performance issues. Isolating and running many applications
    with virtualization is more approachable than ever with containerization technologies.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices may not be the solution to all our maintenance and scalability
    issues but they are certainly an approach that is viable for consideration. In
    this chapter we''ll explore some of the patterns that may assist in using microservices:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregate services
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message upgrader
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service selector
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure patterns
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because microservices are a relatively new development, there are likely to
    be many more patterns which emerge as more and more applications are created with
    the microservice approach. There is some similarity between the Microservices
    approach and **Service Oriented** **Architecture** (**SOA**). This means that
    there are likely some patterns from the SOA world which will be applicable in
    the microservices world.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you feel that you recognize the name of this pattern, then you're correct.
    We discussed this pattern way back in [Chapter 4](part0102_split_000.html#318PC1-015e68c68a464f18a9559f448be84435
    "Chapter 4. Structural Patterns"), *Structural Patterns*. In that application
    of the pattern we created a class which could direct the actions of a number of
    other classes providing a simpler API. Our example was that of an admiral who
    directed a fleet of ships. In the microservices world we can simply replace the
    concept of classes with that of services. After all, the functionality of a service
    is not that different from a microservice – they both perform a single action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'We might make use of a façade to coordinate the use of a number of other services.
    This pattern is a base pattern for many of the other patterns listed in this chapter.
    Coordinating services can be difficult, but by putting them behind a façade we
    can make the entire application much simpler. Let us consider a service which
    sends e-mails. Sending e-mails is quite a complex process which may involve a
    number of other services: a username to e-mail address translator, an anti-malware
    scanner, a spam checker, a formatter to message the e-mail body for various e-mail
    clients, and so forth.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Most clients who want to send e-mail don''t want to concern themselves with
    all of these other services so a façade e-mail-sending service can be put in place
    which holds the responsibility of coordinating other services. The coordination
    pattern can be seen here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Façade](img/00089.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: Service selector
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Along the same lines as a façade we have the service selector pattern. In this
    pattern we have a service which fronts a number of other services. Depending on
    the message which arrives, a different service could be selected to respond to
    the initial request. This pattern is useful in upgrade scenarios and for experimentation.
    If you''re rolling out a new service and want to ensure that it will function
    correctly under load then you could make use of the service selector pattern to
    direct a small portion of your production traffic to the new service while monitoring
    it closely. Another application might be for directing specific customers or groups
    of customers to a different service. The distinguishing factor could be anything
    from directing people who have paid for your service toward faster end points,
    to directing traffic from certain countries to country-specific services. The
    service selector pattern can be seen in this illustration:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Service selector](img/00090.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Aggregate services
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data in a microservice architecture is owned by a single service, but there
    are many times when we might need to retrieve data from a number of different
    sources at once. Consider, again, a member of the Small Council in the land of
    Westeros. They may have a number of informants from whom they gather information
    about the workings of the kingdom. You can consider each informant to be its own
    microservice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Informants are a fantastic metaphor for microservices as each one is independent
    and holds its own data. Services may also fail from time to time just as informants
    may be captured and terminated. Messages are passed between informants just as
    they are among a collection of microservices. Each informant should know very
    little about how the rest of the informants work, and even, who they are – an
    abstraction which works for microservices too.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'With the aggregate service pattern, we ask each one of a collection of nodes
    to perform some action or return some piece of data. This is a fairly common pattern
    even outside the microservice world and is a special case of the façade or even
    adapter pattern. The aggregator requests information from a number of other services
    and then waits for them to return. Once all the data has been returned, then the
    aggregator may perform some additional tasks such as summarizing the data or counting
    records. The information is then passed back to the caller. The aggregator can
    be seen in this illustration:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Aggregate services](img/00091.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: This pattern may also have some provision for dealing with slow-to-return services
    or failures of services. The aggregator service may return partial results or
    return data from a cache in the event that one of the child services reaches a
    timeout. In certain architectures, the aggregator could return a partial result
    and then return additional data to the caller when it becomes available.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipeline is another example of a microservice connecting pattern. If you
    have made use of the shell on a *NIX system, then you have certainly piped the
    output of one command to another command. The programs on a *NIX system such as
    ls, sort, uniq, and grep are designed to perform just one task; their power comes
    from the ability to chain the tools together to build quite complex workflows.
    For instance, this command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will list all the unique file extensions in the current directory.
    It does this by taking the list of files, then cutting them and taking the extension;
    this is then sorted and finally passed to `uniq` which removes duplicates. While
    I wouldn't suggest having a microservice for such trivial actions as sorting or
    deduplicating, you might have a series of services which build up more and more
    information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine a query service that returns a collection of company records:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This record is returned by our company lookup service. Now we can pass this
    record onto our sales accounting service which will add a sales total to the record:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that record can be passed onto a sales estimate service, which further
    enhances the record with an estimate of 2017 sales:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This sort of progressive enhancement could be reversed too by a service that
    stripped out information which shouldn''t be presented to the users. The record
    might now become the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we have dropped the company identifier because it is an internal identifier.
    A microservice pipeline should be bidirectional so that a quantum of information
    is passed into each step in the pipeline and then passed back out again through
    each step. This affords services the opportunity to act upon the data twice, manipulating
    it as they see fit. This is the same approach used in many web servers where modules
    such as PHP are permitted to act upon the request and the response. A pipeline
    can be seen illustrated here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipeline](img/00092.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: Message upgrader
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the highest-risk activities with some monolithic applications is upgrading.
    To do so you basically need to upgrade the entire application at once. With even
    a medium-sized application there are far too many aspects to reasonably test.
    Thus at some point you simply need to cut over from the old system to the new
    system. With a microservice approach, the cutover can be done for each individual
    service. Smaller services mean that the risk can be spread out over a long time
    and, should something go wrong, the source of the error can be more quickly pinpointed:
    the singular new component.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'At issue are the services which are still talking to the old version of the
    upgraded service. How can we continue to serve these services without having to
    update all those services too? If the interface to the service remains unchanged,
    say our service calculates the distance between two points on the earth and we
    change it from using a simple Pythagorean approach to using haversine (a formula
    to find the distance between two spots on a sphere), then there may be no need
    to make changes to the input and output formats. Frequently, however, this approach
    isn''t available to us as the message format must change. Even in the previous
    example there is a possibility of changing the output message. Haversine is more
    accurate than a Pythagorean approach so we could have more significant digits
    requiring a larger data type. There are two good approaches to deal with this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue to use the old version of our service and the new version. We can
    then slowly move the client services over to the new service as time permits.
    There are problems with this approach: we now need to maintain more code. Also,
    if the reason we change the service out was one which would not permit us to continue
    to run it (a security problem, termination of a dependent service, and so on)
    then we are at something of an impasse.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade messages and pass them on. In this approach we take the old message
    format and upgrade it to the new format. This is done by, you guessed it, another
    service. This service's responsibility is to take in the old message format and
    emit the new message format. At the other end you might need an equivalent service
    to downgrade messages back to the expected output format for older services.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upgrader services should have a limited lifespan. Ideally we would want to
    make updates to the services which depend on deprecated services as quickly as
    possible. The small code footprint of microservices, coupled with the ability
    to rapidly deploy services, should make these sorts of upgrade much easier than
    those used to a monolithic approach might expect. An example message upgrader
    service can be seen here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![Message upgrader](img/00093.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Failure patterns
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already touched upon some of the ways of dealing with failures in microservices
    in this chapter. There are, however, a couple of more interesting approaches we
    should consider. The first of these is service degradation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Service degradation
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern could also be called graceful degradation and is related to progressive
    enhancement. Let us hark back to the example of replacing the Pythagorean distance
    function with the haversine equivalent. If the haversine service is down for some
    reason, the less demanding function could be used in its place without a huge
    impact on users. In fact, they may not notice it at all. It isn't ideal that users
    have a worse version of the service but it is certainly more desirable than simply
    showing the user an error message. When the haversine service returns to life
    then we can stop using the less desirable service. We could have multiple levels
    of fallback allowing several different services to fail while we continue to present
    a fully functional application to the end user.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Another good application of this form of degradation is to fall back to more
    expensive services. I once had an application that sent SMS messages. It was quite
    important that these messages actually be sent. We used our preferred SMS gateway
    provider the majority of the time but, if our preferred service was unavailable,
    something we monitored closely, then we would fail over to using a different provider.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种退化形式的另一个很好的应用是退回到更昂贵的服务。我曾经有一个应用程序发送短信。确实很重要这些消息实际上被发送。我们大多数时候使用我们首选的短信网关提供商，但是，如果我们的首选服务不可用，我们会切换到使用另一个提供商。
- en: Message storage
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息存储
- en: We've already drawn a bit of a distinction between services which are query-only
    and those which actually perform some lasting data change. When one of these updating
    services fails there is still a need to run the data change code at some point
    in the future. Storing these requests in a message queue allows them to be run
    later without risk of losing any of the ever-so important messages. Typically,
    when a message causes an exception it is returned to the processing queue where
    it can be retried.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在查询服务和实际执行持久数据更改的服务之间划分了一些区别。当这些更新服务之一失败时，仍然需要在将来的某个时刻运行数据更改代码。将这些请求存储在消息队列中可以在不丢失任何重要消息的风险下稍后运行它们。通常，当消息引发异常时，它会被返回到处理队列，可以进行重试。
- en: There is an old saying that insanity is doing the same thing over again and
    expecting a different outcome. However, there are many transient errors which
    can be solved by simply performing the same action over again. Database deadlocks
    are a prime example of this. Your transaction may be killed to resolve a deadlock,
    in which case performing it again is, in fact, the recommended approach. However,
    one cannot retry messages ad infinitum so it is best to choose some relatively
    small number of retry attempts, three or five. Once this number has been reached
    then the message can be sent to a dead letter or poison message queue.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有句古话说，疯狂就是一再做同样的事情，却期待不同的结果。然而，有许多瞬时错误可以通过简单地再次执行相同的操作来解决。数据库死锁就是一个很好的例子。为了解决死锁，可能会终止您的事务，这种情况下再次执行是推荐的方法。然而，不能无限次重试消息，所以最好选择一些相对较小的重试次数，比如三次或五次。一旦达到这个数字，消息就可以发送到死信或毒消息队列。
- en: 'Poison messages, or dead letters as some call them, are messages which have
    actual legitimate reasons for failing. It is important to keep these messages
    around not only for debugging purposes but because the messages may represent
    a customer order or a change to a medical record: not data you can afford to lose.
    Once the message handler has been corrected these messages can be replayed as
    if the error never happened. A storage queue and message reprocessor can be seen
    illustrated here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 毒消息，或者有些人称之为死信，是有合理失败原因的消息。保留这些消息非常重要，不仅用于调试目的，还因为这些消息可能代表客户订单或医疗记录的更改：这是您无法承受丢失的数据。一旦消息处理程序已经纠正，这些消息可以被重新播放，就好像错误从未发生过一样。存储队列和消息重新处理器的示意图如下所示：
- en: '![Message storage](img/00094.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![消息存储](img/00094.jpeg)'
- en: Message replay
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息重播
- en: Although not a real production pattern, a side-effect of having a message-based
    architecture around all the services which change data is that you can acquire
    the messages for later replay outside of production. Being able to replay messages
    is very handy for debugging complex interactions between numerous services as
    the messages contain almost all the information to set up a tracing environment
    identical to production. Replay capabilities are also very useful for environments
    where one must be able to audit any data changes to the system. There are other
    methods to address such audit requirements but a very solid message log is simply
    a delight to work with.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是真正的生产模式，但围绕所有更改数据的服务构建基于消息的架构的一个副作用是，您可以获取消息以便在生产环境之外进行后续重播。能够重播消息对于调试众多服务之间复杂交互非常方便，因为消息几乎包含了设置与生产环境相同的跟踪环境所需的所有信息。重播功能对于必须能够审计系统中的任何数据更改的环境也非常有用。还有其他方法来满足此类审计要求，但非常可靠的消息日志简直是一种乐趣。
- en: Indempotence of message handling
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息处理的幂等性
- en: The final failure pattern we'll discuss is idempotence of message handling.
    As systems grow larger it is almost certain that a microservices architecture
    will span many computers. This is even more certain due to the growing importance
    of containers, which can, ostensibly, be thought of as computers. Communicating
    between computers in a distributed system is unreliable; thus, a message may end
    up being delivered more than once. To handle such an eventuality one might wish
    to make messaging handling idempotent.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一个故障模式是消息处理的幂等性。随着系统规模的增长，几乎可以肯定微服务架构将跨越许多计算机。由于容器的重要性日益增长，这更是确定无疑的。在分布式系统中，计算机之间的通信是不可靠的；因此，消息可能会被传递多次。为了处理这种可能性，人们可能希望使消息处理具有幂等性。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For more about the unreliability of distributed computing, I cannot recommend
    any paper more worth reading than *Falacies of Distributed Computing Explained*
    by Arnon Rotem-Gal-Oz at [http://rgoarchitects.com/Files/fallacies.pdf](http://rgoarchitects.com/Files/fallacies.pdf).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 关于分布式计算的不可靠性，我推荐阅读的论文是Arnon Rotem-Gal-Oz的《分布式计算谬误解释》，链接在[http://rgoarchitects.com/Files/fallacies.pdf](http://rgoarchitects.com/Files/fallacies.pdf)。
- en: 'Idempotence means that a message can be processed many times without changing
    the outcome. This can be harder to achieve than one might realize, especially
    with services which are inherently non-transactional such as sending e-mails.
    In these cases, one may need to write a record that an e-mail has been sent to
    a database. There are some scenarios in which the e-mail will be sent more than
    once, but a service crashing in the critical section between the e-mail being
    sent and the record of it being written is unlikely. The decision will have to
    be made: is it better to send an e-mail more than once or not send it at all?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性意味着一条消息可以被处理多次而不改变结果。这可能比人们意识到的更难实现，特别是对于那些本质上是非事务性的服务，比如发送电子邮件。在这些情况下，可能需要将已发送电子邮件的记录写入数据库。在某些情况下，电子邮件可能会被发送多次，但在电子邮件发送和记录写入之间的关键部分崩溃的情况是不太可能的。必须做出决定：是更好地多次发送电子邮件，还是根本不发送？
- en: Hints and tips
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和建议
- en: If you think of a microservice as a class and your microservice web as an application,
    then it rapidly becomes apparent that many of the same patterns we've seen elsewhere
    in the module are applicable to microservices. Service discovery could be synonymous
    with dependency injection. Singleton, decorator, proxy; all of them could be applicable
    to the microservice world just as they are within the boundaries of a process.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把微服务看作一个类，把你的微服务网络看作一个应用程序，那么很快就会发现，我们在本模块中看到的许多相同模式也适用于微服务。服务发现可能等同于依赖注入。单例、装饰器、代理；所有这些模式在微服务世界中也同样适用，就像它们在一个进程的边界内一样。
- en: One thing to keep in mind is that many of these patterns are somewhat chatty,
    sending significant data back and forth. Within a process there is no overhead
    to passing around pointers to data. The same is not true of microservices. Communicating
    over the network is likely to incur a performance penalty.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一件事是，许多这些模式都有点啰嗦，来回发送大量数据。在一个进程内，传递数据指针是没有额外开销的。而在微服务中情况并非如此。通过网络通信很可能会产生性能损失。
- en: Summary
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Microservices are a fascinating idea and one which is more likely to be realized
    in the next few years. It is too early to tell if this is simply another false
    turn on the way to properly solving software engineering or a major step in the
    right direction. In this chapter we've explored a few patterns which may be of
    use should you embark upon a journey into the microservices world. Because we're
    only on the cusp of microservices becoming mainstream, it is likely that, more
    than any other chapter of this module, the patterns here will quickly become dated
    and found to be suboptimal. Remaining vigilant with regard to developments and
    being aware of the bigger picture when you're developing is highly advisable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是一个迷人的想法，很可能在未来几年内会实现。现在还为时过早，无法确定这是否只是在正确解决软件工程方面又一个错误的转变，还是朝着正确方向迈出的重要一步。在本章中，我们探讨了一些模式，这些模式可能在你踏上微服务世界的旅程时会有所帮助。因为我们只是处于微服务变得主流的前夕，所以这里的模式很可能会很快过时，并被发现不够优化。在开发过程中保持警惕并了解更大的画面是非常明智的。
