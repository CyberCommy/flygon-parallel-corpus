- en: Standard Language Support and Proposals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've gone through a lot of topics in this book, so now it's time to group them
    all in a handy chapter that you can use to help remember how to use the functional
    programming techniques we covered. We will take this opportunity to look at the
    C++ 20 standard as well, mentioning how we can use these new features in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Supported ways of writing pure functions in C++, and future proposals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported ways of writing lambdas in C++, and future proposals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported ways for currying in C++, and future proposals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported ways for functional composition in C++, and future proposals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17; I used GCC 7.4.0c.
  prefs: []
  type: TYPE_NORMAL
- en: The code is on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter16` folder. It includes and uses `doctest`, which is a single-header
    open source unit testing library. You can find it in the GitHub repository at [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: Standard language support and proposals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've explored several ways of writing code in a functional style in
    C++. Now, we'll take a look at some additional options that are allowed by the
    C++ 17 standard, and at a few options that are enabled by C++ 20\. So, let's start
    by writing pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pure functions** are functions that return the same outputs when receiving
    the same inputs. Their predictability makes them useful for understanding how
    the written code correlates with its runtime performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We discovered in [Chapter 2](79295589-e861-4722-96a5-d131b429aac0.xhtml), *Understanding
    Pure Functions,* that writing pure functions in C++ requires a combination of
    `const` and `static`, depending on whether the function is part of a class or
    is a free function, and on how we pass the parameters to the function. For your
    ease, I will reproduce the conclusions we reached on the syntax for pure functions
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Class functions, pass by value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static int increment(const int value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int increment(const int value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class functions, pass by reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static int increment(const int& value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int increment(const int&value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class functions, pass pointer by value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static const int* increment(const int* value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int* increment(const int* value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Class functions, pass pointer by reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static const int* increment(const int* const& value)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`const int* increment(const int* const& value) const`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone function, pass by value `int increment(const int value)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone function, pass by reference `int increment(const int& value)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone function, pass pointer by value `const int* increment(const int*
    value)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone function, pass pointer by reference `const int* increment(const int*
    const& value)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve also discovered that while the compiler is helpful for reducing side
    effects, it doesn''t always tell us when a function is pure or not. We always
    need to remember to use these three criteria when writing a pure function, and
    be careful to apply them:'
  prefs: []
  type: TYPE_NORMAL
- en: It always returns the same output values for the same input values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has no side effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not change its parameter values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambdas are a fundamental part of functional programming, allowing us to make
    operations with functions. C++ has had lambdas since C++11, but there were some
    recent additions to the syntax. Additionally, we will explore some lambda features
    that we haven't used until now in this book, but which can come in handy for your
    own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with a simple lambda—`increment` has one input and returns the
    incremented value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The square brackets (`[]`) specify the list of captured values, as we''ll see
    in the following code. We can specify the type of the parameter in the same way
    we do for any function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify the return value immediately after the list of parameters
    and a `->` sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If there''s no input value, the list of parameters and the round parentheses, `()`,
    can be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can capture a value by specifying its name, in which case it''s captured
    by copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can capture a value by reference, using the `&` operator
    in the capture specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we capture multiple values, we can either enumerate them or just capture
    all of them. For capture by value, we use the `=` specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To capture all values by reference, we use the `&` specifier without any variable
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While not recommended, we can make the lambda call mutable with the `mutable`
    specifier after the argument list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, starting in C++ 20, we can specify that the function call is
    `consteval` instead of the default `constexpr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this use case is not yet supported in g++8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exceptions specifiers are also possible; that is, if the lambda throws no exception,
    then `noexcept` may come in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the lambda throws an exception, it can be specified as either general or
    specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you want to use generic types? Well, in C++ 11, you can use the
    `function<>` type for this. Starting with C++ 20, all the goodness of type constraints
    is available for your lambdas in a neat syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this is not yet supported in g++8 either.
  prefs: []
  type: TYPE_NORMAL
- en: Partial application and currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Partial application** means obtaining a new function by applying a function
    with *N* arguments on `1` (or more, but fewer than *N*) arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement partial application manually by implementing a function or
    a lambda that passes the arguments along. Here''s an example of partial application
    that uses the `std::plus` function to obtain an `increment` function by setting
    one of its parameters to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this book, we''ve mainly focused on how to use lambdas in these situations;
    it''s worth mentioning, however, that we can use pure functions for the same goal.
    For example, the same increment function can be written as a normal C++ function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Partial application can be done in C++ with the help of the `bind()` function.
    The `bind()` function allows us to bind parameters to values for a function, allowing
    us to derive the `increment` function from `plus`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`bind` takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The function that we want to bind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arguments to bind to; these can either be a value or a placeholder (such
    as `_1`, `_2`, and so on). Placeholders allow arguments to be forwarded to the
    final function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In pure functional programming languages, partial application is linked with
    currying. **Currying** is the decomposition of a function that takes *N* arguments
    into *N* functions that take one argument. There is no standard way to curry a
    function in C++, but we can do it through the use of lambdas. Let''s take a look
    at an example that curries the `pow` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, with the help of currying, we can naturally do a partial application
    by simply calling the curried function with just one parameter instead of two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This mechanism is enabled by default in many pure functional programming languages.
    However, it is more difficult to do in C++. There is no standard support for currying,
    but we can create our own `curry` function that takes an existing function and
    returns its curried form. Here''s an example of a generalized `curry` function
    for functions with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, here''s how we can use it to curry and do partial application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's now look at ways to implement functional composition.
  prefs: []
  type: TYPE_NORMAL
- en: Functional composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional composition means taking two functions, *f* and *g*, and obtaining
    a new function, *h;* for any value, *h(x) = f(g(x))*. We can implement functional
    composition manually, either in a lambda or in a normal function. For example,
    given two functions, `powerOf2`, which computes powers of `2`, and `increment`,
    which increments a value, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compose them by simply encapsulating the call into a lambda called `incrementPowerOf2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could just use a simple function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, an operator that takes two functions and returns the composed function
    is handy, and it''s implemented in many programming languages. The closest thing
    available in C++ to a functional composition operator is the `|` pipe operator
    from the ranges library, which is currently in the C++ 20 standard. However, while
    it implements composition, it does not work for general functions or lambdas.
    Fortunately, C++ is a powerful language and we can write our own compose function,
    as we discovered in [Chapter 4](d361a3f0-acc7-4e77-9387-2b563fac2f09.xhtml), *The
    Idea of Functional Composition*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Going back to the ranges library and the pipe operator, we can use this form
    of functional composition within the context of ranges. We''ve explored this topic
    extensively in [Chapter 14](1edd5963-94e4-48dc-830f-8f201b3a39c7.xhtml), *Lazy
    Evaluation Using the Ranges Library*, and here''s an example of using the pipe
    operator to compute the sum of all numbers that are multiples of both `2` and
    `3` from a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are multiple options for functional programming in standard
    C++, and a few exciting developments coming in C++ 20.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is it! We have gone through a quick overview of the most important operations
    in functional programming and how we can implement them using C++ 17 and C++ 20\.
    I trust that you are now in possession of more tools in your toolkit—including
    pure functions, lambdas, partial application, currying, and functional composition,
    to name only a few.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, it's your choice in terms of how to use them. Pick a few, or combine
    them, or slowly move your code based on mutable state to immutability; mastering
    these tools will enable more choice and flexibility in the way you write code.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you choose to do, I wish you good luck with your projects and your
    programming career. Happy coding!
  prefs: []
  type: TYPE_NORMAL
