- en: Testing Customer Stories with Behavior-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Naming tests that sound like sentences and stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing separate doctest documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a testable story with doctest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a testable novel with doctest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a testable story with Voidspace Mock and nose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a testable story with mockito and nose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a testable story with Lettuce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Should DSL to write succinct assertions with Lettuce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the project-level script to run this chapter's BDD tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**) was created as a response to **test-driven
    development** (**TDD**) by Dan North. It focuses on writing automated tests in
    a natural language that non-programmers can read.'
  prefs: []
  type: TYPE_NORMAL
- en: '"Programmers wanted to know where to start, what to test and what not to test,
    how much to test in one go, what to call their tests, and how to understand why
    a test fails. The deeper I got into TDD, the more I felt that my own journey had
    been less of a wax-on, wax-off process of gradual mastery than a series of blind
    alleys. I remember thinking, ''If only someone had told me that!'' far more often
    than I thought, ''Wow, a door has opened.'' I decided it must be possible to present
    TDD in a way that gets straight to the good stuff and avoids all the pitfalls." – Dan
    North'
  prefs: []
  type: TYPE_NORMAL
- en: 'To discover more about Dan North, please visit: [https://dannorth.net/introducing-bdd/](https://dannorth.net/introducing-bdd/).'
  prefs: []
  type: TYPE_NORMAL
- en: The tests that we have written in prior unit test recipes had a style of `testThis` and
    `testThat`. BDD takes the approach of getting out of speaking programmers and
    instead shifting to a more customer-oriented perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dan North goes on to point out how Chris Stevenson wrote a specialized test
    runner for Java''s JUnit that printed test results in a different way. Let''s
    take a look at the following test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code, when run through AgileDox ([http://agiledox.sourceforge.net/](http://agiledox.sourceforge.net/)),
    will print out in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'AgileDox does several things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It prints out the test name with the test suffix dropped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It strips out the test prefix from each test method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It converts the remainder into a sentence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AgileDox is a Java tool, so we won't be exploring it in this chapter. But there
    are many Python tools available, and we will look at some, including doctest,
    Voidspace Mock, `mockito`, and Lettuce. All of these tools give us the means to
    write tests in a more natural language and empower customers, QA, and test teams
    to develop story-based tests.
  prefs: []
  type: TYPE_NORMAL
- en: All the tools and styles of BDD could easily fill up an entire book. This chapter
    intends to introduce the philosophy of BDD along with some strong, stable tools
    used to effectively test our system's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this chapter, let''s use the same shopping cart application for each recipe.
    Create a file called `cart.py` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following, regarding this shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: It is one-based, meaning the first item and price are at `[1]`, not `[0]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It includes the ability to have multiples of the same item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will calculate total price and then add taxes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This application isn't complex. Instead, it provides us opportunities throughout
    this chapter to test various customer stories and scenarios that aren't necessarily
    confined to simple unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Naming tests that sound like sentences and stories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test methods should read like sentences, and test cases should read like titles
    of chapters. This is part of BDD's philosophy of making tests easy to read for
    non-programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will explore how to write a custom `nose` plugin
    that provides results in a BDD-style report:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `recipe26.py` to contain our test cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a unittest test, where the test case represents a cart with one item,
    and the test methods read like sentences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a unittest test, where the test case represents a cart with two items,
    and the test methods read like sentences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a unittest test, where the test case represents a cart with no items, and
    the test methods read like sentences:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: BDD encourages using very descriptive sentences for method names. Several of
    these method names were shortened to fit the format of this book, and yet some
    were still too long.
  prefs: []
  type: TYPE_NORMAL
- en: Create another file called `recipe26_plugin.py` to contain our customized BDD
    runner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `nose` plugin that can be used as `–with-bdd` to print out results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a handler that prints out either the module or the test method, with
    extraneous information stripped out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a handler for success, failure, and error messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file called `recipe26_plugin.py` to contain a test runner for exercising
    this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a test runner that pulls in the test cases and runs them through `nose`,
    printing out results in an easy-to-read fashion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test runner. Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Introduce a couple of bugs in the test cases, and rerun the test runner to
    see how this alters the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests again. Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test cases are written as nouns, describing the object being tested. `CartWithTwoItems`
    describes a series of test methods centered on a shopping cart that is prepopulated
    with two items.
  prefs: []
  type: TYPE_NORMAL
- en: The test methods are written like sentences. They are strung together with underscores
    instead of spaces. They have to be prefixed with `test_`, so that unittest will
    pick them up. `test_items_should_be_in_the_same_order_as_entered` should represent
    items that should be in the same order as entered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that we should be able to quickly understand what is being tested
    by putting these two together: Given a cart with two items, the items should be
    in the same order as entered.'
  prefs: []
  type: TYPE_NORMAL
- en: While we could read through the test code with this thought process, mentally
    subtracting out the cruft of underscores and the `test` prefix, this can become
    a real cognitive load for us. To make it easier, we coded a quick `nose` plugin
    that split up the camel-case tests and replaced the underscores with spaces. This
    led to the useful report format.
  prefs: []
  type: TYPE_NORMAL
- en: Using this type of quick tool encourages us to write detailed test methods that
    will be easy to read on output. The feedback, not just to us but to our test team
    and customers, can be very effective at fostering communications, confidence in
    software, and help with generating new test stories.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example test methods shown here were deliberately shortened to fit the format
    of the book. Don't try to make them as short as possible. Instead, try to describe
    the expected output.
  prefs: []
  type: TYPE_NORMAL
- en: The plugin isn't installable. This plugin was coded to quickly generate a report.
    To make it reusable, especially with `nosetests`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing separate doctest documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BDD doesn't require that we use any particular tool. Instead, it's more focused
    on the approach to testing. That is why it's possible to use Python `doctest` to
    write BDD test scenarios. `doctest` isn't restricted to the module's code. With
    this recipe, we will explore creating independent text files to run through Python's
    `doctest` library.
  prefs: []
  type: TYPE_NORMAL
- en: If this is `doctest`, why wasn't it included in the previous chapter's recipes?
    Because the context of writing up a set of tests in a separate test document fits
    more naturally into the philosophy of BDD than with testable docstrings that are
    available for introspection when working with a library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will explore capturing various test scenarios
    in `doctest` files and then running them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `recipe27_scenario1.doctest` that contains `doctest`-style
    type tests to exercise the shopping cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that there are no quotes surrounding the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create another scenario in the`recipe27_scenario2.doctest` file that tests
    the boundaries of the shopping cart, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `recipe27.py` and put in the test runner code that finds
    files ending in `.doctest` and runs them through the `testfile` method within
    `doctest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test suite. Take a look at this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the test suite with `-v`, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`doctest` provides the convenient `testfile` function that will exercise a
    block of pure text as if it were contained inside a docstring. This is why no
    quotations are needed compared to when we had multiple `doctest` inside docstrings.
    The text files aren''t docstrings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, if we include triple quotes around the text, the tests won''t work
    correctly. Let''s take the first scenario—put `"""` at the top and bottom of the
    file, and save it as `recipe27_bad_ scenario.txt`. Now, let''s create a file called
    `recipe27.py`, and create an alternate test runner that runs our bad scenario,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It has confused the tail-end triple quotes as part of the expected output. It's
    best to just leave them out.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is so great about moving docstrings into separate files? Isn''t this the
    same thing that we were doing in the *Creating* *testable* *documentation* *with*
    *doctest* recipe discussed in [Chapter 2](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c),
    *Running Automated Test Suites with Nose*? Yes and no. Yes, it''s technically
    the same thing: `doctest` is exercising blocks of code embedded in the test.'
  prefs: []
  type: TYPE_NORMAL
- en: But BDD is more than simply a technical solution. It is driven by the philosophy
    of *customer-readable* *scenarios*. BDD aims to test the behavior of the system.
    The behavior is often defined by customer-oriented scenarios. Getting a hold of
    these scenarios is strongly encouraged when our customer can easily understand
    the scenarios that we have captured. It is further enhanced when the customer
    can see what passes and fails and, in turn, sees a realistic status of what has
    been accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: By decoupling our test scenarios from the code and putting them into separate
    files, we have the key ingredient to making readable tests for our customers using
    `doctest`.
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't this defy the usability of docstrings?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0083.html#2F4UM0-dd965cfd3480473da68e719fadb0727c), *Running
    Automated Test Suites with Nose,* there are several recipes that show how convenient
    it is to embed examples of code usage in docstrings. They are convenient, because
    we can read the docstrings from an interactive Python shell. What do you think
    is different about pulling some of this out of the code into separate scenario
    files? Do you think there are some `doctest` that would be useful in docstrings
    and others that may serve us better in separate scenario files?
  prefs: []
  type: TYPE_NORMAL
- en: Writing a testable story with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Capturing a succinct story in a `doctest` file is the key to BDD. Another aspect
    of BDD is providing a readable report including the results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will see how to write a custom `doctest` runner
    to make our own report:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe28_cart_with_no_items.doctest` to contain our
    `doctest` scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `doctest` scenario that exercises the shopping cart, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file called `recipe28.py` to contain our custom `doctest` runner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a customer `doctest` runner by sub classing `DocTestRunner`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `report_start` function that looks for comments starting with `#` before
    an example, as shown in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `report_success` function that conditionally prints out `ok`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `report_failure` function that conditionally prints out `FAIL`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a runner that replaces `doctest.DocTestRunner` with our customer runner,
    and then looks for `doctest` files to run, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the runner to exercise our scenario. Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the runner to exercise our scenario with `-v`, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Alter the test scenario so that one of the expected outcomes fail by using
    this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice we have changed the expected outcome from `1` to `4668`, to guarantee
    a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the runner with `-v` again, and see the results. Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`doctest` provides a convenient means to write a testable scenario. For starters,
    we wrote up a series of behaviors we wanted the shopping cart application to prove.
    To polish things up, we added lot of detailed comments so that anyone reading
    this document can clearly understand things.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This provides us with a testable scenario. However, it leaves us short of one
    key thing: *a* *succinct* *report*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `doctest` won't print out all these detailed comments for us.
  prefs: []
  type: TYPE_NORMAL
- en: To make this usable from a BDD perspective, we need the ability to embed selective
    comments that get printed out when the test sequence runs. To do that, we will
    subclass `doctest.DocTestRunner` and insert our version of the handling of the
    docstring.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`DocTestRunner` conveniently gives us a handle on the docstring as well as
    the exact line number where the code example starts. We coded our `BddDocTestRunner`
    to look at the line preceding it, and check to see whether it started with `#`,
    our custom marker for a piece of text to print out during a test run.'
  prefs: []
  type: TYPE_NORMAL
- en: A `#when` comment is considered a cause. In other words, a `when` causes one
    or more *effects*. While `doctest` will still verify the code involved with a
    `when`; for BDD purposes, we don't really care about the outcome, so we silently
    ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Any other `#` comments are considered effects. For each of these, we strip out
    the `#` and then print the sentence indented, so we can easily see which `when`
    it is tied to. Finally, we print out either `ok` or `FAIL` to indicate the results.
  prefs: []
  type: TYPE_NORMAL
- en: This means we can add all the detail we want to the documentation. But for blocks
    of tests, we can add statements that will be printed as either *causes* (`#when`)
    or effects (`#anything else`).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a testable novel with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running a series of story tests showcases your code's expected behavior. We
    have previously seen in the *Writing* *a* *testable* *story* *with* *doctest*
    recipe how to build a testable story and have it generate a useful report.
  prefs: []
  type: TYPE_NORMAL
- en: With this recipe, we will see how to use this tactic to string together multiple
    testable stories to form a testable novel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will also reuse the `BddDocTestRunner` defined in this chapter's *Writing*
    *a* *testable* *story* *with* *doctest* recipe. But we will slightly alter it
    by implementing the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new file called `recipe29.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the code containing the `BddDocTestRunner` from the *Writing* *a* *testable*
    *story* *with* *doctest* recipe into `recipe29.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter the `__main__` runnable to only search for this recipe''s `doctest` scenarios,
    as shown in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file called `recipe29_cart_we_will_load_with_identical_items.doctest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a scenario to it that tests the cart by adding two instances of the same
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Create another file called `recipe29_cart_we_will_load_with_two_different_items.docstest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that file, create another scenario that tests the cart by adding two different
    instances, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file called `recipe29_cart_that_we_intend_to_keep_empty.doctest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that file, create a third scenario that tests the cart by adding nothing
    and yet tries to access values outside the range, as shown in this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the runner to execute our scenarios. Take a look at this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We reuse the test runner developed in the previous recipe. The key is extending
    the scenarios to ensure that we have complete coverage of the expected scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be sure that we can handle the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A cart with two identical items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cart with two different items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The degenerate situation of an empty shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A valuable part of writing tests is picking useful names. In our situation,
    each testable story started with an empty cart. However, if we named each scenario
    *given an empty cart*, it would cause an overlap and not result in a very effective
    report.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead, we named them based on our story''s intention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads to:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a cart we will load with identical items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a cart we will load with two different items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given a cart that we intend to keep empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of these scenarios is much clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Naming scenarios are much like certain aspects of software development that
    are more a craft than a science. Tuning the performance tends to be more scientific,
    because it involves an iterative process of measurement and adjustment. But naming
    scenarios along with their causes and effects tends to be more of a craft. It
    involves communicating with all the stakeholders including QA and customers, so
    everyone can read and understand the stories.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be intimidated. Be ready to embrace change
  prefs: []
  type: TYPE_NORMAL
- en: Start writing your stories. Make them work. Then share them with your stakeholders.
    Feedback is important, and that is the purpose of using story-based testing. Be
    ready for criticism and suggested changes.
  prefs: []
  type: TYPE_NORMAL
- en: Be ready for more story requests. In fact, don't be surprised if some of your
    customers or QA want to write their own stories. That is a positive sign.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to this type of customer interaction, don't worry. You will develop
    valuable communication skills and build a solid professional relationship with
    your stakeholders. And at the same time, your code quality will certainly improve.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a testable story with Voidspace Mock and nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our code interacts with other classes through methods and attributes, these
    are referred to as collaborators. Mocking out collaborators using Voidspace Mock
    ([http://www.voidspace.org.uk/python/mock/](http://www.voidspace.org.uk/python/mock/)),
    created by Michael Foord, provides a key tool for BDD. Mocks provide canned behavior
    compared to stubs, which provide canned states. While mocks by themselves don't
    define BDD, their usage keenly overlaps the ideas of BDD.
  prefs: []
  type: TYPE_NORMAL
- en: To further demonstrate the behavioral nature of the tests, we will also use
    the `spec` plugin found in the `pinocchio` project ([http://darcs.idyll.org/~t/projects/pinocchio/doc](http://darcs.idyll.org/~t/projects/pinocchio/doc)).
  prefs: []
  type: TYPE_NORMAL
- en: As stated on the project's website, Voidspace Mock is experimental. This book
    was written using version 0.7.0 beta 3\. There is the risk that more API changes
    will occur before reaching a stable 1.0 version. Given this project's high quality,
    excellent documentation, and many articles in the blogosphere, I strongly feel
    it deserves a place in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter with some slight modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe30_cart.py`, and copy all the code from `cart.py`
    created in the introduction of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter `__init__` to add an extra `storer` attribute used for persistence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `store` method that uses the `storer` to save the cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `retrieve` method that updates the internal `items` by using the `storer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The specifics of the API of the `storer` will be given further down in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to activate our virtual environment and then install Voidspace Mock
    for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a virtual environment, activate it, and verify the tools are working.
    Take a look at the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Install Voidspace Mock by typing `pip install mock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the latest version of Pinocchio by typing `pip install http://darcs.idyll.org/~t/projects/pinocchio-latest.tar.gz`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This version of Pinocchio raises some warnings. To prevent them, we also need
    to install `figleaf` by typing `pip install figleaf`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will explore how to use mock to write a testable
    story:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `recipe30_cart.py`, create a `DataAccess` class with empty methods for storing
    and retrieving shopping carts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file called `recipe30.py` to write the test code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an automated unittest that exercises the cart by mocking out the methods
    of `DataAccess`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test using `nosetests` with the `spec` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocks are test doubles that confirm method calls, which is the *behavior*. This
    is different from stubs, which provide canned data, allowing us to confirm states.
  prefs: []
  type: TYPE_NORMAL
- en: Many mocking libraries are based on the *record*/*replay* pattern. They first
    require the test case to *record* every behavior the mock will be subjected to
    when used. Then we plug the mock into our code, allowing our code to invoke calls
    against it. Finally, we execute *replay*, and the Mock library compares the method
    calls we expected with the ones that actually happened.
  prefs: []
  type: TYPE_NORMAL
- en: A common issue with record/replay mocking is that, if we miss a single method
    call, our test fails. Capturing all the method calls can become very challenging
    when trying to mock out third-party systems, or dealing with variable calls that
    may be tied to complex system states.
  prefs: []
  type: TYPE_NORMAL
- en: The Voidspace Mock library differs by using the *action*/*assert* pattern. We
    first generate a mock and define how we want it to react to certain *actions*.
    Then, we plug it into our code, allowing our code to operate against it. Finally,
    we *assert* what happened to the mock, only picking the operations we care about.
    There is no requirement to assert every behavior experienced by the mock.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important? Record/replay requires that we record the method calls
    that are made by our code, third-party system, and all the other layers in the
    call chain. Frankly, we may not need this level of confirmation of behavior. Often,
    we are primarily interested in the top layer of interaction. Action/assert lets
    us cut back on the behavior calls we care about. We can set up our mock to generate
    the necessary top level actions and essentially ignore the lower level calls,
    which a record/replay mock would force us to record.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we mocked the `DataAccess` operations `store_cart` and `retrieve_cart`.
    We defined their `return_value`, and at the end of the test we asserted that they
    were called the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`cart.storer` was the internal attribute that we injected with our mock.'
  prefs: []
  type: TYPE_NORMAL
- en: Mocking a method means replacing a call to a real method with one to a mock
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Stubbing a method means replacing a call to a real method with one to a stub.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because this test case focuses on storing and retrieving from the cart's perspective,
    we didn't have to define the real `DataAccess` calls. That is why we simply put
    `pass` in their method definitions.
  prefs: []
  type: TYPE_NORMAL
- en: This conveniently lets us work on the behavior of persistence without forcing
    us to choose whether the cart would be stored in a relational database, a NoSQL
    database, a flat file, or any other file format. This shows that our shopping
    cart and data persistence are nicely decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: Tell me more about the spec nose plugin!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We quickly skimmed over the useful `spec` plugin for `nose`. It provides the
    same essential functionality that we coded by hand in the *Naming* *tests* *so*
    *they* *sound* *like* *sentences* *and* *stories* section. It converts test case
    names and test method names into readable results. It gives us a runnable `spec`.
    This plugin works with unittest and doesn't care whether or not we were using
    Voidspace Mock.
  prefs: []
  type: TYPE_NORMAL
- en: Why didn't we reuse the plugin from the recipe "Naming tests so they sound like
    sentences and stories"?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to phrase this question is *Why did we write that recipe's plugin
    in the first place?* An important point of using test tools is to understand how
    they work, and how to write our own extensions. The *Naming* *tests* *so* *they*
    *sound* *like* *sentences* *and* *stories* section not only discussed the philosophy
    of naming tests, but also explored ways to write `nose` plugins to support this
    need. In this recipe, our focus was on using Voidspace Mock to verify certain
    behaviors, and not on coding `nose` plugins. Producing a nice BDD report was easily
    served by the existing `spec` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing a testable story with mockito and nose.*'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a testable story with mockito and nose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our code interacts with other classes through methods and attributes, these
    are referred to as collaborators. Mocking out collaborators using `mockito` ([http://code.google.com/p/mockito](http://code.google.com/p/mockito)
    and [http://code.google.com/p/mockito-python](http://code.google.com/p/mockito-python))
    provides a key tool for BDD. Mocks provide canned behavior, whereas stubs,  provide
    canned states. While mocks by themselves don't define BDD, their usage keenly
    overlaps the ideas of BDD.
  prefs: []
  type: TYPE_NORMAL
- en: To further demonstrate the behavioral nature of the tests, we will also use
    the `spec` plugin found in the `pinocchio` project ([http://darcs.idyll.org/~t/projects/
    pinocchio/doc](http://darcs.idyll.org/~t/projects/)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter with some slight modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe31_cart.py` and copy all the code from `cart.py`
    created in the introduction of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alter `__init__` to add an extra `storer` attribute used for persistence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `store` method that uses the `storer` to save the cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `retrieve` method that updates the internal `items` by using the `storer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The specifics of the API of the storer will be given further down in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to activate our virtual environment and then install `mockito` for
    this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a virtual environment, activate it, and verify the tools are working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Install `mockito` by typing `pip install mockito`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install `pinocchio` and `figleaf` using the same steps from the *Writing a testable
    story with Voidspace Mock and nose* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will explore how to use mocking to write a testable
    story:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `recipe31_cart.py`, create a `DataAccess` class with empty methods for storing
    and retrieving shopping carts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file called `recipe31.py` for writing the test code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an automated unit test that exercises the cart by mocking out the methods
    of `DataAccess`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test using `nosetests` with the `spec` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is very similar to the earlier recipe, *Writing* *a* *testable*
    *story* *with* *Voidspace* M*ock* *and* *nose*. For details about mocking and
    the benefits with regards to BDD, it is very useful to read that recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the syntax of Voidspace Mock with `mockito` to get a feel for
    the differences. Look at the following Voidspace Mock block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows the function `store_cart` being mocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`mockito` approaches this by mocking out the entire `storer` object. `mockito`
    originated as a Java mocking tool, which explains its Java-ish APIs like `thenReturn`,
    compared to Voidspace Mock''s Pythonic style of `return_value`.'
  prefs: []
  type: TYPE_NORMAL
- en: Some find this influence from Java on Python's implementation of `mockito` distasteful.
    Frankly, I believe that is insufficient reason to discard a library. In the previous
    example, `mockito` records the desired behavior in a more succinct fashion, something
    that would definitely offset the Java-like API.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing a testable story with Voidspace Mock and nose.*'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a testable story with Lettuce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lettuce** ([http://lettuce.it](http://lettuce.it)) is a Cucumber-like BDD
    tool built for Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber ([http://cukes.info](http://cukes.info)) was developed by the Ruby
    community and provides a way to write scenarios in a textual style. By letting
    our stakeholders read the stories, they can easily discern what the software is
    expected to do.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to install Lettuce, write a test story, and then wire
    it into our shopping cart application to exercise our code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter. We also need to install Lettuce and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Install Lettuce by typing `pip install lettuce`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will explore creating some testable stories with
    Lettuce, and wiring them to runnable Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `recipe32` to contain all the files in this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `recipe32.feature` to capture our story. Write the top-level
    description of our new feature, based on our shopping cart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s first create a scenario that captures the behavior of the cart when
    it''s empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add another scenario that shows what happens when we add cartons of milk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a third scenario that shows what happens when we combine a carton of milk
    and a frozen pizza:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the story through Lettuce to see what the outcome is, considering
    we haven''t linked this story to any Python code. In the following screenshot,
    it''s impossible to discern the color of the outputs. The feature and scenario
    declarations are white. `Given`, `When`, and `Then` are undefined and colored
    yellow. This shows that we haven''t tied the steps to any code yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new file in `recipe32` called `steps.py` to implement the steps needed
    to support `Given`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add some code to `steps.py` to implement the first `Given`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: To run the steps, we need to make sure the current path that contains the `cart.py`
    module is part of our `PYTHONPATH`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Linux and Mac OSX systems, type `export PYTHONPATH=/path/to/ cart.py`.
  prefs: []
  type: TYPE_NORMAL
- en: For Windows, go to Control Panel | System | Advanced, click Environment Variables,
    and either edit the existing `PYTHONPATH` variable or add a new one, pointing
    to the folder that contains `cart.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the stories again. It''s hard to see in the following screenshot, but `Given
    an empty cart` is now green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: While this screenshot only focuses on the first scenario, all three scenarios
    have the same `Given`. The code we wrote satisfied all three `Given.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Add code to `steps.py` that implements support for the first scenario''s `Then`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the stories again and notice how the first scenario is completely passing,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now add code to `steps.py` to implement the steps needed for the second scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add code to `steps.py` to implement the steps needed for the last
    scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the story by typing `lettuce recipe32` and see how they are all now passing.
    In the next screenshot, we have all the tests passing and everything is green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lettuce uses the popular `Given`/`When`/`Then` style of BDD story telling.
  prefs: []
  type: TYPE_NORMAL
- en: '**Givens**: This involves setting up a scenario. This often includes creating
    objects. For each of our scenarios, we created an instance of the `ShoppingCart`.
    This is very similar to unittest''s setup method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thens**: This acts on `Given`. These are the operations we want to exercise
    in a scenario. We can exercise more than one `Then`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Whens**: This involves testing the final results of `Then`. In our code,
    we mostly used Python asserts. In a couple of cases, where we needed to detect
    an exception, we wrapped the call with a `try-catch` block with a `throw` if the
    expected exception didn''t occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't matter in what order we put the `Given`/`Then`/`When`. Lettuce will
    record everything so that all the Givens are listed first, followed by all the
    `When` conditions, and then all the `Then` conditions. Lettuce puts on the final
    polish by translating successive `Given`/`When`/`Then` conditions into `And` for
    better readability.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look closely at some of the steps, you will notice some wildcards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@step` string lets us dynamically grab parts of the string as variables
    by using pattern matchers:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `(.*)` is a pattern to capture `tax_rate`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `(.*)` is a pattern to capture `total`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method definition shows these two extra variables added in. We can name
    them anything we want. This gives us the ability to actually drive the tests,
    data and all, from `recipe32.feature` and only use `steps.py` to link things together
    in a generalized way.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to point out that actual values stored in `tax_rate` and `total`
    are Unicode strings. Because the test involves floating point numbers, we have
    to convert the variables or the `assert` fails.
  prefs: []
  type: TYPE_NORMAL
- en: How complex should a story be?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we fit everything into a single story. Our story involved all
    the various shopping cart operations. As we write more scenarios, we may expand
    this into multiple stories. This goes back to the concept discussed in the *Breaking*
    *down* *obscure* *tests* *into* *simple* *ones* section of [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c), *Using
    Unittest to Develop Basic Tests*. If we overload a single scenario with too many
    steps, it may get too complex. It is better if we can visualize a single thread
    of execution that is easy to verify at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Don't mix wiring code with application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project's website shows a sample building a factorial function. It has both
    the factorial function as well as the wiring in a single file. For demo purposes
    this is alright. But for actual production use, it is best to decouple the application
    from the Lettuce wiring. This encourages a clean interface and demonstrates usability.
  prefs: []
  type: TYPE_NORMAL
- en: Lettuce works great using folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lettuce, by default, will look for a `features` folder wherever we run it, and
    discover any files ending in `.feature`. That way it can automatically find all
    of our stories and run them.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to override the features directory with `-s` or `–-scenarios`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Breaking* *down* *obscure* *tests* *into* *simple* *ones* section from
    [Chapter 1](part0025.html#NQU20-dd965cfd3480473da68e719fadb0727c), *Using Unittest
    to Develop Basic Tests*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Should DSL to write succinct assertions with Lettuce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lettuce ([http://lettuce.it](http://lettuce.it)) is a BDD tool built for Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**Should DSL** ([http://www.should-dsl.info](http://www.should-dsl.info)) provides
    a simpler way to write assertions for `Then` conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to install Lettuce and Should DSL. Then, we will write
    a test story. Finally, we will wire it into our shopping cart application using
    Should DSL to exercise our code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will be using the shopping cart application shown at the
    beginning of this chapter. We also need to install Lettuce and its dependencies
    by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Lettuce by typing `pip install lettuce`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install Should DSL by typing `pip install should_dsl`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will use Should DSL to write more succinct assertions
    in our test stories:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `recipe33` to contain all the files for this recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in `recipe33` called `recipe33.feature` to contain our test
    scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a story in `recipe33.feature` with several scenarios to exercise our
    shopping cart, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a set of assertions using Should DSL, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the story:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe (*Writing* *a* *testable* *story* *with* *Lettuce*) shows
    more details on how Lettuce works. This recipe demonstrates how to use Should
    DSL to make useful assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we need Should DSL? The simplest checks we write involve testing values
    to confirm the behavior of the shopping cart application. In the previous recipe,
    we mostly used Python assertions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty easy to understand. Should DSL offers a simple alternative,
    which is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Does this look like much of a difference? Some say yes, others say no. It is
    wordier, and for some this is easier to read. For others, it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'So why are we visiting this? Because Should DSL has more than just `equal_to`.
    There are many more commands, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`be`: Checks identity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contain, include, be_into`: Verifies whether an object is contained or contains
    another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`be_kind_of`: Checks types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`be_like`: Checks using a regular expression'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`be_thrown_by,throws`: Checks that an exception is thrown'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close_to`: Checks whether a value is close, given a delta'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end_with`: Checks whether a string ends with a given suffix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equal_to`: Checks value equality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`respond_to`: Checks whether an object has a given attribute or method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start_with`: Checks whether a string starts with a given prefix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other alternatives as well, but this provides a diverse set of comparisons.
    If we imagine the code needed to write assertions that check the same things,
    then things get more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s think about confirming expected exceptions. In the previous
    recipe, we needed to confirm that an `IndexError` is thrown when accessing an
    item outside the boundaries of our cart. A simple Python `assert` didn''t work,
    so instead we coded this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is clunky and ugly. Now, imagine a more complex, more realistic system,
    and the idea of having to use this pattern for lots of test situations where we
    want to verify that a proper exception is thrown. This can quickly become an expensive
    coding task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, Should DSL turns this pattern of exception assertion into a one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is clear and concise. We can instantly understand that invoking this method
    with these arguments should throw a certain exception. If no exception is raised,
    or a different one is raised, it will fail and give us clear feedback.
  prefs: []
  type: TYPE_NORMAL
- en: If you notice, Should DSL requires the method call to be split up into a tuple,
    with the first element of the tuple being the method handle, and the rest being
    the arguments for the method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the sample code listed in this chapter, we used `|should|`. But Should DSL
    also comes with `|should_not|`. Sometimes, the condition we want to express is
    best captured with a `|should_not|`. Combined with all the matchers listed earlier,
    we have a plethora of opportunities to test things, positive or negative.
  prefs: []
  type: TYPE_NORMAL
- en: But, don't forget, we can still use Python's plain old `assert` if it is easier
    to read. The idea is to have plenty of ways to express the same verification of
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Writing a testable story with Lettuce.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the project-level script to run this chapter's BDD tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed several tactics to write and exercise BDD
    tests. This should help us in developing new projects. An invaluable tool for
    any project is having a top-level script used to manage things such as packaging,
    bundling, and testing.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows how to create a command-line project script that will run
    all the tests we created in this chapter using the various runners.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we need to have coded all the recipes from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the following steps, we will create a project-level script that will run
    all the test recipes from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `recipe34.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add code that uses the `getopt` library for parsing command-line arguments,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test function that uses our custom `nose` plugin, `BddPrinter`, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test function that exercises file-based `doctest`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test function that exercises multiple `doctest` using a customized `doctest`
    runner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a test function that exercises Lettuce tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a top-level test function that runs all of our test functions and can be
    wired to the command-line option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Add some extra stub functions that represent packaging, publishing, and registration
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Add code to parse the command-line options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script with no options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Run the script with `–test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script using `--package --publish --register`. Take a look at this
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script uses Python's `getopt` library.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more details about how and why to use `getopt`, reasons to write a project-level
    script, and why we are using `getopt` instead of `optparse`.
  prefs: []
  type: TYPE_NORMAL
