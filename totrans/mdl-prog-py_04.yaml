- en: Chapter 4. Using Modules for Real-World Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to use modular programming techniques to implement
    a useful real-world system. In particular, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and implement a Python package for generating charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how changing requirements can be the downfall of a successful system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover the ways in which modular programming techniques can help you to deal
    with changing requirements in the best possible way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn that changing requirements can be good, because they give you the opportunity
    to re-think your program, resulting in more robust and well-designed code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by looking at the Python chart-generating package we are going to
    implement, which we will call **Charter**.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Charter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Charter will be a Python library for generating charts. Developers will be
    able to use Charter to convert raw numbers into good-looking line and bar charts,
    which can then be saved as image files. The following is an example of the sort
    of chart that the Charter library will be able to generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Charter](graphics/B05012_4_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Charter library will support line and bar charts. While we will keep Charter
    relatively simple by only supporting two types of charts, the package will be
    designed so that you can easily add more chart types and other charting options
    if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Designing Charter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you look at a chart like the one shown in the previous section, you can
    identify a number of standard elements that are used by all types of charts. These
    elements include a title, the *x* and *y* axes, and one or more data series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing Charter](graphics/B05012_4_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To use the Charter package, a programmer would create a new chart and set the
    title, the *x* and *y* axes, and the data series to be displayed. The programmer
    would then ask Charter to generate the chart, saving the result as an image file
    on disk. By combining and configuring the various elements in this way, a programmer
    can create any chart that they may wish to generate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more sophisticated charting library would allow for additional elements, such
    as a *y* axis on the right-hand side, axis labels, a legend, and multiple overlapping
    data series. For Charter, however, we want to keep the code simple, so we will
    ignore these more complicated elements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at how a programmer might interact with the Charter
    library, and then start to think about how it might be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like the programmer to be able to interact with Charter simply by
    importing the `charter` package and then calling various functions to work with
    charts. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the title for the chart, the programmer would call the `set_title()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that our Charter library does not use object-oriented programming techniques.
    Using object-oriented techniques, the chart title would be set using a statement
    such as `chart.set_title("Wild Parrot Deaths per Year")`. However, object-oriented
    techniques are beyond the scope of this book, and so we will use a simpler procedural
    programming style for the Charter library.
  prefs: []
  type: TYPE_NORMAL
- en: To set the *x* and *y* axes for a chart, the programmer would have to supply
    enough information so that Charter can generate the chart and display these axes.
    To understand how this might work, let's think about what an axis looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some charts, an axis might represent a range of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing Charter](graphics/B05012_4_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, a data point would be displayed by calculating the position of
    the point along the axis. For example, a data point with *x = 35* would be displayed
    halfway between the **30** and **40** points on this axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to call this type of axis a **continuous axis**. Notice how, for
    this type of axis, the labels are positioned below the tick marks. Compare this
    with the following axis, which is divided up into a number of discrete "buckets":'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing Charter](graphics/B05012_4_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case, each data point corresponds to a single bucket, and the label
    would appear in the space between the tick marks. This type of axis will be called
    a **discrete axis**.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that for continuous axes, the labels are displayed on the tick marks,
    while for discrete axes the labels are displayed between the tick marks. Also,
    the values for a discrete axis can be anything (in this case, month names), while
    for continuous axes, the values must be numbers.
  prefs: []
  type: TYPE_NORMAL
- en: For the Charter library, we are going to make the *x* axis a discrete axis,
    while the *y* axis will be continuous. In theory, you could use either type of
    axis for both the *x* and *y* axes, but we are keeping this simple to make the
    library easier to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing this, we can now look at how the various axes can be defined when creating
    a chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the x axis, the programmer will call the `set_x_axis()` function
    with a list of labels to use for each bucket within the discrete axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Each entry in the list corresponds to a single bucket within the axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the *y* axis, we need to define both the range of values that will be displayed
    and how these will be labeled. To do this, we''re going to need to supply minimum,
    maximum, and label values to the `set_y_axis()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep things simple, we will assume that the *y* axis uses a linear scale.
    We could potentially support other types of scaling, for example to implement
    a logarithmic axis, but we're going to ignore this as it would make the Charter
    library more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how the axes will be defined, we can look at how the data
    series will be specified. Firstly, we need the programmer to tell Charter what
    type of data series to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, we will support both line and bar charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmer then needs to specify the contents of the data series. Since
    our *x* axis is discrete while the *y* axis is continuous, we can define a data
    series as a list of *y* axis values, one for each discrete *x* axis value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This completes the definition of a chart. Once it has been defined, the programmer
    can ask the Charter library to generate the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting all this together, here is a complete program that generates the bar
    chart shown at the start of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because Charter is a library intended to be used by programmers, this code gives
    a fairly complete specification for the Charter library's API. It's clear from
    this example program what is supposed to happen. Let's now look at how this can
    be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Charter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that the Charter library's public interface will consist of a number
    of functions accessed at the package level, for example `charter.new_chart()`.
    However, using the techniques covered in the previous chapter, we know that we
    don't have to define our library's API in the package initialization file to make
    these functions available at the package level. Instead, we can define the functions
    elsewhere, and import them into the `__init__.py` file so that they are available
    for others to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a directory to hold our `charter` package. Create
    a new directory named `charter`, and create within it an empty package initialization
    file, `__init__.py`. This gives us the basic framework within which to write our
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Charter](graphics/B05012_4_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on our design, we know that the process of generating a chart will involve
    the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new chart by calling the `new_chart()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the contents and appearance of the chart by calling the various `set_XXX()`
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the chart and save it as an image file by calling the `generate_chart()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To keep our code nicely organized, we're going to separate the process of generating
    a chart from the process of creating and defining a chart. To do this, we'll have
    a module named `chart`, which handles the chart creation and definition, and a
    separate module named `generator` which handles the chart generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create these two new empty modules, placing them inside the `charter`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing Charter](graphics/B05012_4_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have an overall structure for our package, let''s create some placeholders
    for the various functions that we know we''re going to have to implement. Edit
    the `chart.py` module, and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, edit the `generator.py` module, and enter the following into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'These are all the functions that we know we''ll need to implement for the Charter
    library. However, they''re not in the correct place yet—we want the user to be
    able to call `charter.new_chart()`, not `charter.chart.new_chart()`. To get around
    this, edit the `__init__.py` file, and enter the following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're using relative imports to load all the functions from
    these modules into the main `charter` package's namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Our Charter library is starting to take shape! Let's now work on each of the
    two modules in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the chart.py module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we're eschewing the use of object-oriented programming techniques in our
    implementation of the Charter library, we can't use an object to store the information
    about a chart. Instead, the `new_chart()` function is going to return a chart
    value, and the various `set_XXX()` functions will take that chart and add information
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to store information about a chart is to use a Python dictionary.
    This makes the implementation of our `new_chart()` function very simple; edit
    the `chart.py` module and replace the placeholder for `new_chart()` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a dictionary that will hold the chart''s data, it''s easy to store
    the various values we want into this dictionary. For example, edit the definition
    for the `set_title()` function so that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, we can implement the rest of the `set_XXX()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This completes the implementation for our `chart.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the generator.py module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unfortunately, the `generate_chart()` function is going to be more difficult
    to implement, which is why we moved this function into a separate module. The
    process of generating a chart will involve the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty image to hold the generated chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the chart's title.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the *x* axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the *y* axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw the data series.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the resulting image file to disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the process of generating a chart requires us to work with images, we're
    going to need to find a library that allows us to generate image files. Let's
    grab one now.
  prefs: []
  type: TYPE_NORMAL
- en: The Pillow library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Python Imaging Library** (**PIL**) is a venerable library used to generate
    images. Unfortunately, PIL is no longer being actively developed. There is, however,
    a newer version of PIL, named **Pillow**, that continues to be supported and will
    allow us to create and save image files.
  prefs: []
  type: TYPE_NORMAL
- en: The main web site for the Pillow library can be found at [http://python-pillow.org/](http://python-pillow.org/),
    and the documentation is available at [http://pillow.readthedocs.org/](http://pillow.readthedocs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and install Pillow. The easiest way to do this is to use `pip
    install pillow`, although the installation guide ([http://pillow.readthedocs.org/en/3.0.x/installation.html](http://pillow.readthedocs.org/en/3.0.x/installation.html))
    gives you a variety of options if this won't work for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking through the Pillow documentation, it appears that we can create an
    empty image using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new RGB (red, green, blue) image with the given width and height,
    filled with the given color.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`#7f00ff` is a hexadecimal color code for purple. Each pair of hexadecimal
    digits represents a color value: `7f` for red, `00` for green, and `ff` for blue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw into this image, we will use the `ImageDraw` module. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the chart has been drawn, we can save the image to disk in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This brief introduction to the Pillow library tells us how to implement steps
    1 and 6 of the chart-generation process we described earlier. It also tells us
    that for steps 2 to 5, we are going to use the `ImageDraw` module to draw the
    various chart elements.
  prefs: []
  type: TYPE_NORMAL
- en: Renderers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we draw the chart, we want to be able to choose the elements to draw.
    For example, we might select between the `"bar"` and `"line"` elements depending
    on the type of data series the user wants to display. A very simple way of doing
    this would be to structure our drawing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, this isn't very expandable and would quickly get hard to read if the
    drawing logic gets complicated, or if we added more charting options to the library.
    To make the Charter library more modular, and to support enhancing it down the
    track, we will make use of renderer modules to do the actual drawing for us.
  prefs: []
  type: TYPE_NORMAL
- en: In computer graphics, a **renderer** is a part of a program that draws something.
    The idea is that you can select the appropriate renderer and ask it to draw the
    element you want without having to worry about the details of how that element
    will be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using renderer modules, our drawing logic would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means that we can leave the actual details of how each element is drawn
    to the renderer module itself and not clutter up our `generate_chart()` function
    with lots of detailed drawing code.
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of our renderer modules, we're going to create a sub-package named
    `renderers`, and place all our renderer modules inside this sub-package. Let's
    create this sub-package now.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `renderers` within the main `charter` directory,
    and create a new file inside it called `__init__.py` to act as the package initialization
    file. This file can be empty as we don't need to do anything special to initialize
    this sub-package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to need a total of five different renderer modules for the Charter
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x_axis.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y_axis.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bar_series.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line_series.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead and create these five files within the `charter.renderers` directory,
    and enter the following placeholder text into each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the overall structure for our renderer modules. Let's now use
    these renderers to implement our `generate_chart()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `generate.py` module, and replace the placeholder definition for the
    `generate_chart()` function with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we create an `Image` object to hold our generated chart, initializing
    it to white using the hex color code `#ffffff`. We then use the `ImageDraw` module
    to define a `drawer` object to draw into the chart and call the various renderer
    modules to do all the work. Finally, we call `image.save()` to save the image
    file to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this function to work, we need to add a few `import` statements to the
    top of our `generator.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one more thing that we haven''t dealt with yet: when we create the
    image, we make use of two constants which tell Pillow the dimensions of the image
    to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We need to define these two constants somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we are going to need to define several more constants and use
    them throughout the Charter library. To allow for this, we'll create a special
    module just to hold our various constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `constants.py` within the top-level `charter` directory.
    Inside this module, add the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following `import` statement to your `generator.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Testing the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While we haven''t implemented any of our renderers, we have enough code in
    place to start testing. To do this, create an empty file named `test_charter.py`,
    and place it in the directory containing the `charter` package. Then, enter the
    following into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a copy of the example code we saw earlier. This script will allow
    you to test the Charter library; open up a terminal or command-line window, `cd`
    into the directory containing the `test_charter.py` file, and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All going well, the program should finish without any errors. You can then look
    at the `chart.png` file, which should be an empty image file filled with a white
    background.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the title
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We next need to implement our various renderer modules, starting with the chart''s
    title. Edit the `renderers/title.py` file, and replace your placeholder definition
    of the `draw()` function with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This renderer starts by obtaining a font to use when drawing the title. It then
    calculates the size (in pixels) of the title text and the position to use for
    the label so that it is nicely centered on the chart. Notice that we use a constant
    named `TITLE_HEIGHT` to specify the amount of space to use for the chart's title.
  prefs: []
  type: TYPE_NORMAL
- en: The final line in this function draws the title onto the chart using the specified
    position and font. The string `#4040a0` is the hexadecimal color code to use for
    the text—this is a dark blue color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this module uses the `ImageFont` module to load the font, as well as
    some constants from our `constants.py` module, we need to add the following `import`
    statements to the top of our module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `..` to import the `constants` module from our parent package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to add the `TITLE_HEIGHT` constant to our `constants.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now run your `test_charter.py` script, you should see the chart''s title
    appear in the generated image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering the title](graphics/B05012_4_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Rendering the x axis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you remember, the *x* axis is a discrete axis with labels displayed between
    each tick mark. To draw this, we are going to have to calculate the width of each
    "bucket" on the axis, and then draw lines to represent the axis and the tick marks,
    as well as drawing the label for each bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by editing the `renderers/x_axis.py` file, and replace your placeholder
    `draw()` function with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to add the following `import` statements at the top of your
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you should add the following definitions to your `constants.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These define the sizes of the fixed elements within the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now run your `test_charter.py` script, you should see the *x* axis displayed
    along the bottom of the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering the x axis](graphics/B05012_4_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The remaining renderers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, the generated image is starting to look more chart-like. Since
    the purpose of this package is to show how to structure your code, rather than
    the details of how these modules are implemented, let's skip ahead and add the
    remaining renderers without further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by editing your `renderers/y_axis.py` file to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit `renderers/bar_series.py` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, edit `renderers.line_series.py` to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This completes our implementation of the Charter library.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Charter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you run the `test_charter.py` script, you should see a complete bar chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing Charter](graphics/B05012_4_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is obviously a lot more that we could do with the Charter library, but
    even in its current state, it works well. If you want, you can use it to generate
    line and bar charts for all sorts of data. For our purposes, we can declare the
    Charter library to be complete, and start using it as part of our production system.
  prefs: []
  type: TYPE_NORMAL
- en: The fly in the ointment – changing requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, nothing is ever really finished. Let's pretend that you wrote the
    Charter library and have been busily extending it for several months, adding more
    data series types and lots of options. The library is being used in several big
    projects for your company, the output looks fantastic, and everyone seems to be
    very happy with it—until the day that your boss comes in and says, "It's too fuzzy.
    Can you take the fuzziness away?"
  prefs: []
  type: TYPE_NORMAL
- en: 'You ask what he means, and he says that he''s been printing the charts out
    on a high-resolution laser printer. The results aren''t good enough for him to
    use in his company reports. He takes a printout and points to the heading. Looking
    closely, you can see what he means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The fly in the ointment – changing requirements](graphics/B05012_4_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sure enough, the text is pixelated, and even the lines look a bit jagged when
    printed at high resolution. You try increasing the size of the generated chart,
    but it still doesn't look good enough—and when you try increasing the size to
    match the 1,200 dots per inch of the company's high-resolution laser printer,
    your program crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '"But the program was never designed for that," you complain. "We wrote it to
    show charts on-screen."'
  prefs: []
  type: TYPE_NORMAL
- en: '"I don''t care," says your boss. "I want you to generate the output in vector
    format. That always prints fine, and isn''t fuzzy at all."'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just in case you haven''t encountered this before, there are two fundamentally
    different ways of storing image data: bitmapped images, which are made up of pixels,
    and vector images, where the individual drawing instructions (for example, "write
    some text", "draw a line," "fill a rectangle," and so on) are saved, and then
    these instructions are followed each time the image is to be displayed. Bitmapped
    images suffer from pixelation or "fuzziness," while vector images look great even
    when enlarged or printed at a high resolution.'
  prefs: []
  type: TYPE_NORMAL
- en: You do a quick Google search, and confirm that the Pillow library can't save
    vector-format images; it only works with bitmapped data. Your boss isn't sympathetic,
    "Just make it work in vector format, saving to PDF as well as PNG for those people
    already using it."
  prefs: []
  type: TYPE_NORMAL
- en: With a sinking heart, you wonder how you could possibly meet these new requirements.
    The whole Charter library has been built from the ground up to generate bitmapped
    PNG images. Won't you have to rewrite the whole thing from scratch?
  prefs: []
  type: TYPE_NORMAL
- en: Redesigning Charter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the Charter library now needs to optionally save the chart as a vector-format
    PDF file, we need to find an alternative to the Python Imaging Library that supports
    writing to PDF files. There is one obvious candidate for this: **ReportLab**.'
  prefs: []
  type: TYPE_NORMAL
- en: ReportLab is a commercial PDF generator, which is also released under an open
    source license. You can find out more about the ReportLab toolkit at [http://www.reportlab.com/opensource/](http://www.reportlab.com/opensource/).
    The easiest way to install ReportLab is to use `pip install reportlab`. If this
    doesn't work for you, check out the installation instructions at [https://bitbucket.org/rptlab/reportlab](https://bitbucket.org/rptlab/reportlab)
    for more details. Documentation for the ReportLab toolkit can be found at [http://www.reportlab.com/docs/reportlab-userguide.pdf](http://www.reportlab.com/docs/reportlab-userguide.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'In many ways, ReportLab works in the same way as the Python Imaging Library:
    you initialize a document (called a **canvas** in ReportLab), call various methods
    to draw the elements onto the canvas, and then use the `save()` method to save
    the PDF file to disk.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one additional step, however: because the PDF file format supports
    multiple pages, you need to call the `showPage()` function to render the current
    page before saving the document. While we don''t need multiple pages for the Charter
    library, we could create multi-page PDF documents by calling `showPage()` after
    drawing each page, and then call `save()` to save the file to disk when we are
    finished.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a tool that allows us to generate PDF files, let's take a look
    at how we can restructure the Charter package to support rendering in either PNG
    or PDF file format.
  prefs: []
  type: TYPE_NORMAL
- en: The `generate_chart()` function seems to be the logical point at which the user
    should be able to choose the output format. In fact, we can detect the format
    automatically based on the file name—if the `filename` parameter ends with `.pdf`,
    then we should generate the chart in PDF format, while if the `filename` ends
    with `.png`, then we should generate the file in PNG format.
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, though, we have a problem with our renderers: they''re all
    designed to work with the Python Imaging Library, and use the `ImageDraw` module
    to draw each chart as a bitmapped image.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, and the complexity of the code inside each renderer module,
    it makes sense to leave these renderers alone and write new renderers that use
    ReportLab to generate the chart's elements in PDF format. To do this, we are going
    to need to **refactor** our rendering code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we leap in and start making changes, let''s think about what we want
    to achieve. We''ll need to have two separate versions of each renderer—one to
    generate the element in PNG format and the other to generate the same element
    in PDF format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Redesigning Charter](graphics/B05012_4_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since all of these modules do the same thing—draw an element onto the chart—it
    would be good to have a single function that calls the appropriate renderer module's
    `draw()` function to draw a given chart element in the desired output format.
    This way, the rest of our code will only need to call one function, rather than
    choose between ten different `draw()` functions depending on the desired element
    and format.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll add a new module called `renderer.py` within the `renderers`
    package, and leave calling the individual renderers to that module. This will
    simplify our design immensely.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our `generate_chart()` function is going to have to create a ReportLab
    canvas to generate the chart in PDF format, and then save this canvas when the
    chart has been generated, just like it does at the moment for the bitmapped image.
  prefs: []
  type: TYPE_NORMAL
- en: All this means that, while we have some work to do implementing new versions
    of our renderer modules, creating a new `renderer.py` module and updating the
    `generate_chart()` function, the rest of the system will remain exactly the same.
    We don't need to rewrite everything from scratch, and the rest of our modules—in
    particular, the existing renderers—don't have to be changed at all. Whew!
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll start our refactoring by moving the existing PNG renderers into a new
    sub-package called `renderers.png`. Create a new directory named `png` within
    the `renderers` directory, and move the `title.py`, `x_axis.py`, `y_axis.py`,
    `bar_series.py` and `line_series.py` modules into this directory. Then, create
    an empty package initialization file, `__init__.py`, inside the `png` directory
    so that Python will recognize it as a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one minor change we are going to have to make to our existing PNG
    renderers: because each renderer module imports the `constants.py` module using
    a relative import, we will need to update these modules so that they can still
    find the `constants` module from their new position. To do this, edit each PNG
    renderer module in turn, and find the line that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an extra `.` to each of these lines so that they look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our next task is to create a package to hold our PDF-format renderers. Create
    a sub-directory named `pdf` in the `renderers` directory, and create an empty
    package initialization file in that directory to make it a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next want to implement the `renderer.py` module we talked about earlier
    so that our `generate_chart()` function can concentrate on drawing chart elements
    rather than worrying about which module each element is defined in. Create a new
    file named `renderer.py` inside the `renderers` directory, and add the following
    code to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This module is doing something tricky, which you may not have encountered before:
    after importing each PNG-format renderer module using `import...as`, we then treat
    the imported modules as if they were Python variables, storing a reference to
    each module in the `renderers` dictionary. Our `draw()` function then selects
    the appropriate module from that dictionary using `renderers[format][element]`,
    and calls the `draw()` function within that module to do the actual drawing.'
  prefs: []
  type: TYPE_NORMAL
- en: This Python trick saves us a lot of coding—without it, we would have had to
    write a whole series of `if...then` statements to call the appropriate module's
    `draw()` function based on the desired element and format. Using a dictionary
    in this way saves us a lot of typing and makes the code much easier to read and
    debug.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have also used the Python Standard Library's `importlib` module to
    load a renderer module by name. This would have made our `renderer` module even
    shorter but would have made it harder to understand the code. Using `import...as`
    and a dictionary to select the desired module is a good trade-off between complexity
    and comprehensibility.
  prefs: []
  type: TYPE_NORMAL
- en: We next need to update our `generate_report()` function. As discussed in the
    previous section, we want to choose the output format based on the file extension
    for the file being generated. We also need to update this function to use our
    new `renderer.draw()` function, rather than importing and calling the renderer
    modules directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `generator.py` module, and replace the contents of this module with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's a lot of code in this module, but the comments should help to explain
    what is going on. As you can see, we use the supplied file name to set the `format`
    variable to `"pdf"` or `"png"` as appropriate. We then prepare the `output` variable
    to hold the generated image or PDF file. Next, we call `renderer.draw()` to draw
    each chart element in turn, passing in the `format` and `output` variables so
    that the renderer can do its job. Finally, we save the output to disk so that
    the chart will be saved to the appropriate PDF or PNG format file.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes in place, you should be able to use the updated Charter package
    to generate a PNG-format file. PDF files won't work yet because we haven't written
    the PDF renderers, but PNG format output should be working. Go ahead and test
    this by running the `test_charter.py` script, just to make sure you haven't made
    any typos entering the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished refactoring our existing code, let's add our PDF renderers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the PDF renderer modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will work through the various renderer modules one at a time. Start by creating
    the `titles.py` module inside the `pdf` directory, and enter the following code
    into this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In some ways, this code is quite similar to the PNG version of this renderer:
    we calculate the width and height of the text and use this to calculate the position
    on the chart where the title should be drawn. We then draw the title in 24-point
    Helvetica font, in a dark blue color.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, some important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The way we calculate the width and the height of the text is different. For
    the width, we call the canvas's `stringWidth()` function, while for the height,
    we multiply the font size of the text by 1.2\. By default, ReportLab leaves a
    gap of 20% of the font size between lines of text, so multiplying the font size
    by 1.2 is an accurate way of calculating the height of a line of text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The units used to calculate the position of elements on the page are different.
    ReportLab measures all positions and sizes using **points** rather than pixels.
    A point is roughly 1/72nd of an inch. Fortunately, one point is fairly close to
    the size of a pixel on a typical computer screen; this allows us to ignore the
    different measurement systems and have the PDF output still look good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PDF files use a different coordinate system to PNG files. In a PNG-format file,
    the top of the image has a *y* value of zero, while for PDF files *y=0* is at
    the bottom of the image. This means that all our positions on the page have to
    be calculated relative to the bottom of the page, rather than the top of the image
    as was done with the PNG renderers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The colors are specified using RGB color values, where each component of the
    color is given as a number between zero and one. For example, a color value of
    `(0.25,0.25,0.625)` is equivalent to the hex color code `#4040a0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without further ado, let''s implement the remaining PDF renderer modules. The
    `x_axis.py` module should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `y_axis.py` module should be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `bar_series.py` module, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `line_series.py` module should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these modules look very similar to their PNG versions. Anything
    we can do with the Python Imaging Library can also be done with ReportLab, as
    long as we allow for the differences in the ways these two libraries work.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with just one more change we have to make to complete our new
    implementation of the Charter library: we need to update the `renderer.py` module
    to make these new PDF renderer modules available. To do this, add the following
    `import` statements to the top of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the part of this module where we define the `renderers` dictionary,
    create a new `pdf` entry to the dictionary by adding the following highlighted
    lines to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, you've finished refactoring and reimplementing the Charter
    module. Assuming you haven't made any mistakes, your library should now be able
    to generate charts in both PNG and PDF format.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make sure your program works, edit your `test_charter.py` program and change
    the name of the output file from `chart.png` to `chart.pdf`. If you then run this
    program, you should end up with a PDF file that contains a high-quality version
    of your chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the code](graphics/B05012_4_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the chart appears at the bottom of the page, rather than the top.
    This is because PDF files have their `y=0` position at the bottom of the page.
    You could easily move the chart to the top of the page by calculating the height
    of the page (in points) and adding an appropriate offset. Feel free to implement
    this if you want, but for now our task is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you zoom in, you''ll see that the chart''s text still looks good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the code](graphics/B05012_4_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is because we're now generating a vector-format PDF file rather than a
    bitmapped image. This file can be printed on a high-quality laser printer without
    any pixelation. Even better, existing users of your library will still be able
    to request PNG versions of the charts and they won't notice any changes at all.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations—you did it!
  prefs: []
  type: TYPE_NORMAL
- en: Lessons learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the Charter library is just an example of modular Python programming,
    and you don''t really have a boss who insists you generate charts in PDF format,
    these examples were selected because the problem is anything but trivial, and
    the changes you needed to make were also very challenging. Looking back over what
    we have achieved, there are several things you may notice:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When faced with a major change in requirements, our first reaction is usually
    a negative one: "Oh no! How could I possibly do that?,"a "It''ll never work,"
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than jumping in and starting to tinker with the code, it is generally
    better to step back and think about the structure of the existing code base and
    what might need to be changed to meet the new requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the new requirement involves a library or tool you haven't used before,
    it is worth spending some time researching the possible options, and possibly
    writing a simple example program to check that the library will do what you want,
    before you start updating your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the judicious use of modules and packages, the changes needed to your
    existing code can be kept to a minimum. In Charter, we could make use of all our
    existing renderer modules, with only a minor change to the source code. We only
    had to rewrite one function (the `generate_chart()` function), and add a new `renderer`
    module to simplify access to our renderers, before writing a new PDF version of
    each renderer. In this way, the use of modular programming techniques helped to
    isolate the changes to just the affected parts of the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As often happens, the resulting system is better than the one we started with.
    Rather than turning our program into spaghetti code, the requirement to support
    PDF generation resulted in a more modular and better structured library. In particular,
    the `renderer` module dealt with the complexity of rendering the various chart
    elements in various formats, allowing the rest of the system to simply call `renderer.draw()`
    to do the work rather than having to import and use lots of modules directly.
    Because of this change, we can easily add more chart elements, or more output
    formats, with minimal further changes to our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The overall lesson here is clear: rather than resist changes to your requirements,
    embrace them. The end result is a better system—more robust, more expandable,
    and often better organized. Provided, of course, that you do it right.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used modular programming techniques to implement a hypothetical
    chart-generation package called Charter. We saw how charts are made up of standard
    elements, and how this organization can be translated into program code. After
    successfully creating a working chart-generation library that renders charts as
    bitmapped images, we saw how a fundamental change in requirements can seem to
    be a problem at first, but is actually an opportunity to refactor and improve
    your code.
  prefs: []
  type: TYPE_NORMAL
- en: Following through with this hypothetical example, we refactored the Charter
    library to handle PDF formatted charts. In doing so, we learned that using modular
    techniques to respond to a major change in requirements can help to isolate the
    changes that need to be made, and that refactoring our code often results in a
    system that is better organized, more expandable and more robust than what we
    started with.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use standard modular programming "patterns"
    to deal with a range of programming challenges.
  prefs: []
  type: TYPE_NORMAL
