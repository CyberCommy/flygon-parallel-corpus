- en: Chapter 7. Testing – Time to Test What We Have Done So Far!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to use and create Vue plugins. We used
    the existing `resource` plugin for Vue and created our own `NoiseGenerator` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will ensure the quality of both the Pomodoro and shopping
    list applications. We will test these applications applying different testing
    techniques. First, we will perform a classic unit test on Vue components and on
    Vuex-related code such as actions, mutations, and getters. After that, we will
    learn how to perform end-to-end testing using Nightwatch. So, in this chapter,
    we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Talk about the importance of unit and end-to-end tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement unit tests for the Pomodoro and shopping list applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to mock server responses in unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement end-to-end tests for both applications using Nightwatch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why unit tests?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing unit tests, let's try to understand what we're trying
    to achieve by writing them. Why is unit testing so important? Sometimes when I
    write my tests, the only thing I can think about is my code coverage; I want to
    achieve a level of 100%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code coverage is a very important metric and helps a lot to understand the
    code flow and what needs to be tested. But it is not a metric of unit test quality.
    This is not a metric of a good code quality. You can have your code 100% covered
    just because you call all your functions in your testing code, but if your assertions
    are wrong, the code might be wrong as well. Writing good unit tests is an art
    that requires time and patience. But when your unit tests are good enough and
    when you are concentrating on making good assertions, with regard to corner cases
    and branch coverage, they provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Help us to identify failures in algorithms and logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help us to improve the code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make us write code that is easy to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent future changes from breaking the functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help us to have more predictable deadlines and estimations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that is easy to cover with unit tests is at the same time code that is
    easy to read. Code that is easy to read is less error-prone and more maintainable.
    Maintainability is one of the main pillars of an application's quality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check more about unit testing in the presentation at [https://chudaol.github.io/presentation-unit-testing](https://chudaol.github.io/presentation-unit-testing)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Let's write some unit tests for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Karma test runner, Mocha test framework, Chai expectations library,
    and Sinon for mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about these tools, refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Karma**: [http://karma-runner.github.io/](http://karma-runner.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocha**: [https://mochajs.org](https://mochajs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaijs**: [http://chaijs.com/](http://chaijs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sinon**: [http://sinonjs.org/](http://sinonjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we hadn''t bootstrapped our application using `vue-cli webpack` scaffolding,
    we would have to install all these tools via `npm`. But in our case, we don''t
    need this installation. Check your `package.json` file and you can see that all
    these things are already there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You certainly know how simple it is to write unit tests for simple functions.
    It's almost like speaking human language. It (this function) should return *X*
    if the input is *Y*. I expect it to be *X*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we have a module that exports, let''s say, a function that returns the
    sum of two arguments, the unit test for this function must call the function with
    different arguments and expect some output. So, let''s assume we have a function
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our unit test might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We should never be shy when we think about the possible inputs to functions
    that are being unit tested. Empty inputs, negative inputs, string inputs, everything
    counts! Have you seen this famous tweet ( [https://twitter.com/sempf/status/514473420277694465](https://twitter.com/sempf/status/514473420277694465)
    )?
  prefs: []
  type: TYPE_NORMAL
- en: '![Why unit tests?](../Images/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Viral tweet about QA Engineer's mindset
  prefs: []
  type: TYPE_NORMAL
- en: Think about all the possible inputs and adequate outputs. Express this in expectations
    and assertions. Run the tests. See what is failing. Fix your code.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests for Vue application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s check on some particularities of unit testing our Vue application
    and its components. In order to be able to write tests for the component instance,
    first of all, it should be instantiated! Quite logical, right? The thing is, how
    do we instantiate the Vue component so that its methods become accessible and
    easily testable? To test basic assertions of the initial state of the component,
    you must just import them and assert their properties. If you want to test dynamic
    properties—things that change once the component is bound to DOM—you must do just
    the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Import a component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate it by passing it to the `Vue` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the instance is bound to the physical DOM, once instantiated, the compilation
    is started immediately. In our case, we are not binding the instance to any real
    physical DOM element, and thus we have to explicitly make it compile it by invoking
    manually the mount method (`$mount`).
  prefs: []
  type: TYPE_NORMAL
- en: Now you can use the created instance and access its methods. In pseudo-code,
    it looks something like the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we can access all `vm` instance methods and test them. The rest of the things,
    such as `data`, `props`, and so on we can just fake. There is no problem with
    faking things because it offers us the possibility of trying all sorts of input
    easily and testing all the viable outputs for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to have a more real scenario while testing components that use
    `props`, which come bound to the component by its parent, or access to the `vuex`
    store, and so on, you can use the `ref` attribute to bind the component to the
    `Vue` instance. This `Vue` instance, in its turn, instantiates the store and data
    and binds the data items to the component in a usual way. After that, you access
    the component instance by using the `$refs` Vue property. This kind of binding
    will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now you can test all the methods of `myComponent` without being worried about
    overriding its `props`, `methods`, and other instance-related things. This is
    a good part of this approach; however, as you can see, it is not the easiest setup
    and you should think about everything. For example, if your component calls some
    store's action that calls some API's methods, you should be ready to have to fake
    the server responses.
  prefs: []
  type: TYPE_NORMAL
- en: I personally like to keep things as simple as possible, fake all the data inputs,
    and concentrate on testing the functions' possible outputs and all the possible
    edge cases. But it is just my personal point of view, and also, we should try
    everything in our lives, so in this chapter, we will try different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for the shopping list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting the actual writing of our unit tests, let''s establish some
    rules. For each of our `.js` or `.vue` files, there will exist a corresponding
    test spec file, which will have the same name and a `.spec.js` extension. The
    structure of these specs will follow this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: It will describe the file we are testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a `describe` method for each of the methods that is being tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have an `it` method for each of the cases we are describing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if we had a `myBeautifulThing.js` file and spec for it, it might look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's start by covering with unit tests all the things that are inside the `vuex`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Testing actions, getters, and mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this section, use the code inside the [chapter7/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter7/shopping-list)
    folder. Do not forget to run the `npm install` command. Note that there are two
    new mutations: `ADD_SHOPPING_LIST` and `DELETE_SHOPPING_LIST`. These mutations
    add new shopping list to the list and remove the list by its ID. They are used
    inside the `createShoppingList` and `deleteShoppingList` actions inside the promise
    failure handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Thus, even if our backend server is down, we still are not losing this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: If you check your project's structure, you will see that there is already an
    existing directory named `test`. Inside this directory, there are two directories,
    `unit` and `e2e`. For now, we should go to the `unit` folder. Here, you will see
    another directory called `specs`. This is where all our unit test specifications
    will reside. Let's start by creating a directory called `vuex` inside `specs`.
    Here is where all our specs for Vuex-related JavaScript files will live.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by testing the `mutations.js` method.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `mutations.spec.js` file. In this file, we should import `mutations.js`
    and mutation types so that we can easily invoke mutations. Have a look at mutations
    declared in `mutations.js`. All of them receive `state` and some other parameters.
    Let's also create a fake `state` object with the `shoppinglist` array inside it
    so we can use it in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also reset it before each test to an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, after all the preparations, the bootstrapped spec for `mutations.js` looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's now add tests for the `ADD_SHOPPING_LIST` mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check again what it is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This mutation just pushes the received object to the `shoppinglists` array.
    Pretty straightforward and easy to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `describe` statement with the name of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside this `describe` callback, we can add `it` statements with the needed
    assertions. Let''s think what should happen when we add a new shopping list to
    the `shoppinglists` array. First of all, the array''s length will increase, and
    it will also contain the newly added shopping list object. This is the most basic
    thing to test. Our `it` function with the needed assertions will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating this function, the whole spec''s code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the tests! Open the console in the project''s directory and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing actions, getters, and mutations](../Images/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The output of running our test
  prefs: []
  type: TYPE_NORMAL
- en: Remember the joke about a QA engineer? We can test the `add_shopping_list` function
    for all possible inputs. What should happen, for example, if we call it without
    passing any object? In theory, it should not add it to the shopping list array,
    right? Let's test it. Create a new `it` statement and try to call the function
    without the second parameter. Assert for an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This test will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests with the `npm run unit` command. Oh, snap! It failed! The error
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Why? Have a look at the corresponding mutation. It just pushes the received
    parameter to the array without any checks. That''s why we are able to add any
    garbage, any undefined, and any other inappropriate value! Do you remember when
    I said that writing good unit tests helps us to create less error-prone code?
    This is the case. Now we realize that we should probably run some checks before
    pushing the new item to the array. Let''s add the check that the received item
    is an object. Open the `ADD_SHOPPING_LIST` mutation in the `mutations.js` file
    and rewrite it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests now. They are all passing!
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could be even more precise. We could check and test for empty
    objects and we could also run some validations for this object to contain properties
    such as `id`, `items`, and `title`. I will leave it to you as a small exercise.
    Try to think about all possible inputs and all possible outputs, write all the
    possible assertions, and make the code to correspond to them.
  prefs: []
  type: TYPE_NORMAL
- en: Good test criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A good unit test is one that would fail when you change your code. Imagine,
    for example, that we decide to assign a default title to the new shopping list
    before pushing it to the array. So, the mutation would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the tests, they will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Good test criteria](../Images/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unit test fails when the code changes
  prefs: []
  type: TYPE_NORMAL
- en: And this is very good. When your tests fail after the changes in the code, the
    possible outcome is that you fix the test because the code is performing the intended
    behavior, or you fix your code.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I am sure that you have noticed some test statistics in the console output
    after running the tests. These statistics display different types of coverage
    that our tests achieved at the time of running. Right now, it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](../Images/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Code coverage of mutations.js after writing two tests for the ADD_SHOPPING_LIST
    mutation
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember when I said that good code coverage doesn't mean that our tests
    and code are perfect? We actually have somewhat nice statements, branches, and
    lines coverage, but we still just tested only one function of only one file, and
    we haven't even covered all possible inputs of this function. But numbers do not
    lie. We have almost 100% branches coverage because we almost do not have branches
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see a more detailed report, just open the `index.html` file
    from the `test/unit/coverage/lcov-report` directory in your browser. It will give
    you a complete and full picture of your code and what exactly is covered and how.
    Currently, it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](../Images/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The whole picture of our codebase coverage
  prefs: []
  type: TYPE_NORMAL
- en: 'You can drill down to the folders, open the files, and check how exactly our
    code is covered. Let''s check `mutations.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](../Images/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Coverage report for actions.js show exactly which code was covered and which
    was not
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you see what still has to be tested. Do you want to see how it reports
    the `if…else` missing branch coverage? Just skip our second test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests and refresh the report for `actions.js`. You will see an **`E`**
    icon on the left of the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](../Images/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The E icon near the if statement indicates that the else branch was not covered
    by tests
  prefs: []
  type: TYPE_NORMAL
- en: 'This indicates that we haven''t covered the `else` branch. If you skip the
    first test and leave the one with the empty object, you will see the **`I`** icon
    that is indicating that we have skipped the `if` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](../Images/image00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The I icon near the if statement indicates that the if branch was not covered
    by tests
  prefs: []
  type: TYPE_NORMAL
- en: 'Write tests for the rest of the mutations. Perform at least the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `DELETE_SHOPPING_LIST` mutation, check that the list with the ID we
    pass is actually deleted if it existed before in the list, and that calling the
    mutation with the ID that doesn't exist in the list will not cause any change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `POPULATE_SHOPPING_LISTS` mutation, check that the `shoppinglist` array
    is overridden with the array we pass when call this mutation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `CHANGE_TITLE` mutation, check that when we pass the new title and the
    ID, exactly this object's title is changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, your `mutation.spec.js` file will probably look like the gist at
    [https://gist.github.com/chudaol/befd9fc5701ff72dff7fb68ef1c7f06a](https://gist.github.com/chudaol/befd9fc5701ff72dff7fb68ef1c7f06a)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'After these tests, the coverage of `mutation.js` looks pretty nice, actually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](../Images/image00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 100% coverage for mutations.js after writing unit tests for all the mutations
  prefs: []
  type: TYPE_NORMAL
- en: In the exact same way, we can test our `getters.js`. Create a `getters.spec.js`
    file and fill it with tests to test our two getters functions. In the end, it
    might look like the gist at [https://gist.github.com/chudaol/e89dd0f77b1563366d5eec16bd6ae4a9](https://gist.github.com/chudaol/e89dd0f77b1563366d5eec16bd6ae4a9)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The only important store component that is missing in unit testing is `actions.js`.
    But our `actions.js` uses extensively the API that, in turn, performs HTTP requests.
    Its functions are also asynchronous. Can this kind of thing be unit tested in
    the same flexible and easy way as we just tested getters and actions? Yes, it
    can! Let's see how can we fake server responses using `sinon.js` and how can we
    write asynchronous tests with `mocha.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Faking server responses and writing asynchronous tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `actions.js` file and check the very first action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, let''s add a `return` statement to this function to make it return
    a promise. We do it to enable us to call the `.then` method once the promise resolves
    so that we can test everything that happens in the meantime. So, our function
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check what is happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: This function receives `store` with its `dispatch` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It performs a call to the API. The API, in turn, calls the resource `get` method
    that just performs an HTTP request to our server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the API''s `fetchShoppingLists` promise is resolved, our method is calling
    the store''s `commit` method with two parameters: a `POPULATE_SHOPPING_LISTS`
    string and the data that came in response.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How can we unit test this workflow? If we were able to catch the request and
    mock the response, we could check if the `commit` method (passed by us, which
    means that it can also be mocked) is called with the response that we provide
    in our server''s mock. Sounds confusing? Not at all! The steps are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a mock for the `store` and its `commit` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a mock for the hypothetical server response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a fake server that will intercept the GET request and return the mocked
    response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the `commit` method is called with our mocked response and the `POPULATE_SHOPPING_LISTS`
    string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It means that our test could look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that our tests are synchronous, meaning the code will never
    reach what is inside our `.then` callback. Luckily for us, `mocha.js` provides
    support for asynchronous testing. Check it out at [https://mochajs.org/#asynchronous-code](https://mochajs.org/#asynchronous-code)
    . The only thing you have to do is to pass `done` callback to `it()` and call
    it when the test is complete. In this way, our pseudo-code for this test would
    look the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s code now! Create a test spec and call it `actions.spec.js`, and write
    all the needed bootstrapping code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s follow our steps. First of all, let''s mock the server response.
    Just create the `lists` variable and initialize it in the `beforeEach` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s mock the store''s `commit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to spy on this `commit` method in order to be able to assert that
    it was called with the required parameters. We will use the `sinon.stub` method
    for this. Check the documentation on `sinon.js` on this matter at [http://sinonjs.org/docs/#stubs](http://sinonjs.org/docs/#stubs)
    . Creating a stub on a given function is very easy. Just call the `sinon.stub`
    method and pass to it the object and its method that we want to spy on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our `beforeEach` function will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s very important that after each method, we *restore* the stub so that
    each testing method runs in a clean environment that is not affected by other
    tests. For this, create an `afterEach` method and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the only thing we need to do is fake our server response with our mocked
    data. Let''s use Sinon''s `fakeServer` for this purpose. Check sinon''s documentation
    at [http://sinonjs.org/docs/#fakeServer](http://sinonjs.org/docs/#fakeServer)
    . We just need to create `fakeServer` and tell it to respond with our mocked response
    to the GET request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After these preparations, each test that will somehow perform a request should
    call the server's `respond` method in order to invoke the server's functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can simplify this by just telling the server to auto-respond each
    caught request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our code for mocking the server will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very important that after each test, we restore our fake server so that
    no other test is affected by our mocks in this test. So add the following line
    to the `afterEach` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have mocked everything that it was possible to mock, we can finally
    write our test case! So, you remember, we create an `it()` statement with `done`
    callback, call our `populateShoppingLists` method, and check that the resolved
    response is the same as our mocked `list` object. Step into the `describe` method
    and just translate into the code what we''ve just described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Our whole test spec now looks like the gist at [https://gist.github.com/chudaol/addb6657095406234bc6f659970f3eb8](https://gist.github.com/chudaol/addb6657095406234bc6f659970f3eb8).
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests with `npm run unit`. It works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just have to mock the server''s responses for the PUT, POST, and DELETE
    methods. These methods do not return any data; however, in order to be able to
    test the responses, let''s return faked success messages, and in each test, check
    that the returned data corresponds to these responses. Add the following variables
    on top of the spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the following fake responses methods to our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how it''ll work, for example, for the `changeTitle` method. In this
    test, we want to test that the `commit` method will be called with the given ID and
    title. Our test, therefore will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work properly, we should also mock the store''s `dispatch` method
    since it''s being used inside the `changeTitle` action. Just add the `dispatch`
    property to our store''s mock and return a resolved promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Check the final code for unit tests at this moment at [https://gist.github.com/chudaol/1405dff6a46b84c284b0eae731974050](https://gist.github.com/chudaol/1405dff6a46b84c284b0eae731974050)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Finish the testing for `actions.js` by adding unit tests for the `updateList`,
    `createShoppingList`, and `deleteShoppingList` methods. Check the whole code for
    unit tests until now in the [chapter7/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter7/shopping-list2)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Testing components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that all our Vuex-related functions are unit tested, it is time to apply
    specific Vue components testing techniques to test components of our shopping
    list application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You remember from the first section of this chapter that in order to prepare
    the `Vue` instance to be unit tested, we must import, initiate (passing it to
    new `Vue` instance), and mount it. Let''s do it! Create a `components` folder
    inside the `test/unit/specs` directory. Let''s start by testing the `AddItemComponent`
    component. Create an `AddItemComponent.spec.js` file and import `Vue` and `AddItemComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `AddItemComponent` can be used to access directly all the component''s
    initial data. So we can assert, for example, that the component data is initialized
    with a `newItem` property that equals to empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Let's now check which methods of this component we can cover with unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This component has only one method, which is `addItem` method. Let''s check
    what this method does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This method access to the store, so, we have to use another strategy of initializing
    the component rather than just directly using the imported value. In this case,
    we should initialize Vue main component with `AddItemComponent` as a child, pass
    all the necessary attributes to it, and access it using the `$refs` attribute.
    So, the component''s initialization inside the test method will look like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Back to the method's functionality. So, the `addItem` method grabs the instance's
    `newItem` property, trims it, checks if it's not falsy and, if not, emits the
    custom event `add`, resets the `newItem` property, and dispatches the `updateList`
    action on store. We can test this method by assigning different values `component.newItem`,
    `component.id` and checking if the output corresponds to what we are expecting
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Positive testing** means testing a system by giving it valid data. **Negative
    testing** means testing a system by giving it invalid data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our positive test, we should initialize the `component.newItem` property
    with a valid string. After calling the method, we should ensure various things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$emit` method of the component has been called with `add` and the text
    we assigned to the `newItem` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component.newItem` was reset to the empty string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The store's `dispatch` method has been called with the `id` property of the
    component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go! Let''s start by adding the describe method for the `addItem` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the `it()` method where we will assign a value to `component.newItem`,
    call the `addItem` method, and check everything we need to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests and check that they are passing and everything is okay. Check
    the final code for `AddItemComponent` in the [chapter7/shopping-list3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter7/shopping-list3)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Try to write unit tests for the rest of the components of the shopping list
    application. Remember to write unit tests to cover your code so that it breaks
    if you change it.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests for our Pomodoro application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ok! Let's move to our Pomodoro application! By the way, when was the last time
    you took a break? Probably, it is time to open the application in your browser,
    wait a few minutes of the Pomodoro working period timer, and check for some kittens.
  prefs: []
  type: TYPE_NORMAL
- en: 'I just did it and it made me feel really nice and cute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing unit tests for our Pomodoro application](../Images/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I'm not your clothes... please have some rest
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with mutations. Open the code in the [chapter7/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter7/pomodoro)
    folder. Open the `mutations.js` file and check what is happening out there. There
    are four mutations happening: `START`, `STOP`, `PAUSE`, and `TOGGLE_SOUND`. Guess
    which one we will start with. Yes, you are right, we will start with the `start`
    method. Create a `vuex` subfolder inside the `test/unit/specs` folder and add
    the `mutations.spec.js` file. Let''s bootstrap it to be ready for tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that I mocked all the methods of the noise generator plugin. This is because
    in this spec, we don't need to test the plugin's functionality (in fact, we must
    do it in the scope of the plugin itself before publishing it). For the scope of
    this test, we should test that the plugin's methods are called when they need
    to be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to test the `start` method, let''s think what should happen.
    After the start button is clicked, we know that the application''s `started`,
    `paused`, and `stopped` states must gain some specific values (actually, `true`,
    `false`, and `false`, respectively). We also know the application''s interval
    should be started. We also know that if the Pomodoro''s state is `working` and
    if the sound is enabled, the `start` method of the noise generator plugin should
    be called. In fact, this is what our method is actually doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But even if it didn''t do all these things and we have written the test to
    test it, we would immediately understand that something is missing in our code
    and fix it. Let''s then write our test. Let''s start by defining the `it()` method
    that tests that all the properties were correctly set. In order to be sure that
    they are not already set before calling the method, let''s also assert that all
    these properties are not defined at the start of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now check on the `Vue.noise.start` method. We know that it should only
    be called if `state.isWorking` is `true` and `state.soundEnabled` is `true`. Let''s
    write a positive test. In this test, we would initialize both Boolean states to
    `true` and check that the `noise.start` method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add two negative tests for each of the states, with `isWorking` and
    `soundEnabled` being `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our `start` mutation is nicely tested! Check the final state of the code in
    the [chapter7/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter7/pomodoro2)
    folder. I suggest that you now write the rest of the unit tests not only for the
    mutations, but also for all the store-related functions that reside in getters
    and actions. After that, apply the techniques to test Vue components that we just
    learned and test some of the components of our Pomodoro application.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are done with unit testing!
  prefs: []
  type: TYPE_NORMAL
- en: What is end- to-end testing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**End-to-end** (**e2e**) testing is a technique in which the whole flow of
    the application is being tested. In this kind of testing, neither mocks nor stubs
    are used, and the real system is being under the test. Performing e2e testing
    allows us to test all the aspects of the application—APIs, frontend, backend,
    databases, server load, assuring thus the quality of the system integration.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of web applications, these tests are performed via UI testing. Each
    test describes all the steps from opening the browser until closing it. All the
    steps needed to perform in order to achieve some system's functionality must be
    described. In fact, this is the same as you clicking and doing some operations
    on your application's page, but is automated and fast. In this section, we will
    see what a Selenium webdriver is, and what Nightwatch is, and how they can be
    used to create e2e tests for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Nightwatch for e2e
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have already worked with test automation or if you have worked with someone
    who has worked with test automation, for sure, you have already heard the magic
    word Selenium—Selenium opens the browser, clicks, writes, does everything like
    a human, in a parallel, nicely distributed, multiplatform, and cross-browser way.
    In fact, Selenium is just a JAR file that contains an API to perform different
    operations on a browser (click, type, scroll, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out Selenium's documentation at [http://www.seleniumhq.org/](http://www.seleniumhq.org/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: When this JAR file is executed, it connects to the specified browser, opens
    the API, and waits for the commands to be performed on the browser. The commands
    sent to the Selenium server can be performed in tons of different ways and languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of existing implementations and frameworks that allow you to
    call selenium commands with couple lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the native Selenium's framework for Java ( [http://seleniumhq.github.io/selenium/docs/api/java/](http://seleniumhq.github.io/selenium/docs/api/java/)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the Firefox plugin for browsers ( [https://addons.mozilla.org/en-us/firefox/addon/selenium-ide/](https://addons.mozilla.org/en-us/firefox/addon/selenium-ide/)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use **Selenide**, which is yet another implementation for Java but a
    lot easier to use than Selenium's framework ( [http://selenide.org/](http://selenide.org/)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are an AngularJS developer, you can use Protractor, which is a very nice
    e2e test framework for AngularJS applications that also uses the Selenium webdriver
    ( [http://www.protractortest.org/](http://www.protractortest.org/) )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we will use Nightwatch, which is a nice and very easy-to-use testing
    framework to call Selenium's commands using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Check Nightwatch's documentation at [http://nightwatchjs.org/](http://nightwatchjs.org/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue applications, when bootstrapped using the `vue-cli webpack` method, already
    contains support for writing Nightwatch tests right away without the need to install
    anything. Basically, each test spec will look somewhat like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is nice and easy to understand. Each of the highlighted methods is
    a Nightwatch command that behind the scenes is transformed into the Selenium command
    and invoked as such. Check the full list of the Nightwatch commands in the official
    documentation page at [http://nightwatchjs.org/api#commands](http://nightwatchjs.org/api#commands)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Writing e2e tests for the Pomodoro application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now that we know all the theory behind the UI testing, we can create our
    first end-to-end test for our Pomodoro application. Let's define the steps that
    we will perform and the things that we should test. So, first of all, we should
    open the browser. Then, we should probably check that our container (that has
    the `#app` ID ) is on the page.
  prefs: []
  type: TYPE_NORMAL
- en: We can also try to check that the pause and stop buttons are disabled and that
    the sound toggle button does not exist on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can click on the start button and check that the sound toggle button
    has appeared, the start button has become disabled, and the pause and stop buttons
    have become enabled. There is an innumerous number of possibilities of further
    clicking and checking, but let''s perform at least the described steps. Let''s
    just write them in the form of bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the browser at `http://localhost:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the `#app` element is on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the `.toggle-volume` icon is not visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the `'[title=pause]'` and `'[title=stop]'` buttons are disabled and
    the `'[title=start]'` button is enabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `'[title=start]'` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the `'[title=pause]'` and `'[title=stop]'` buttons are now enabled
    and the `'[title=start]'` button is disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check that the `.toggle-volume` icon is now visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s do it! Just open the `test.js` file inside the `tests/e2e/specs` folder,
    delete its content, and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see how super human-friendly this language is? Let''s now perform a
    check to see whether, after the period of working time, the kitten element appears
    on the screen. In order to make the test shorter and not wait for a long time
    for test to pass, let''s establish the working period as 6 seconds. Change this
    value in our `config.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The element that contains the cat images has a `''div.well.kittens''` selector,
    so we will check whether it is visible. Let''s also check in this test that after
    the kitten element appears, the source of the image contains the `''thecatapi''`
    string. This test will be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests. In order to do that, invoke the `e2e` npm command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You will see how the browser opens and performs all the operations by itself.
  prefs: []
  type: TYPE_NORMAL
- en: '*It''s a kind of magic!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'All our tests have passed and all expectations are fulfilled; check out the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing e2e tests for the Pomodoro application](../Images/image00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All tests are passing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! You''ve just learned how to use Nightwatch to write e2e tests.
    Check the code in the [chapter7/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter7/pomodoro3)
    folder. Write more test cases for our Pomodoro application. Do not forget about
    our shopping list application, which might have even more scenarios for UI tests.
    Write them all and check how Selenium does the work for you. If you decide to
    enhance the code, not only is your code quality protected by unit tests, but it
    also now has regression testing applied to it. Each time you change the code,
    run both types of tests just with one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you certainly deserve some rest. Take a cup of coffee or tea, open your
    browser on the Pomodoro application page, wait for 6 seconds, and appreciate our
    little fluffy friends:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing e2e tests for the Pomodoro application](../Images/image00314.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Actually, this is not a kitten from thecatapi. This is my cat Patuscas wishing
    you all to have a good rest time!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've tested both of our applications. We have written unit
    tests for Vuex methods and Vue components. We have used simple unit tests and
    asynchronous unit tests and we got familiar with Sinon mocking techniques such
    as spying on methods and faking server responses. We also learned how to create
    UI tests using Nightwatch. Our applications are now tested and prepared to be
    deployed to production! We will discover how to deploy them in the next chapter,
    which will be devoted to deploying applications using the Heroku cloud application
    platform.
  prefs: []
  type: TYPE_NORMAL
