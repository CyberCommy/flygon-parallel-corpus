- en: Chapter 6. Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we spent some time developing our example application.
    Now it is time to start with more advanced topics. In this chapter, we will show
    you how to monitor your microservices application. Keeping a track of everything
    that is happening in your application will help you know the overall performance
    at any time, and you can even find issues and bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and profiling is very necessary in the development of a complex and
    large application, so let’s explain what they are and how we can take advantage
    of these kinds of tools.
  prefs: []
  type: TYPE_NORMAL
- en: What is debugging?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging is the process of identifying and fixing errors in programming. It
    is mainly a manual task in which developers need to use their imagination, intuition,
    and have a lot of patience.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, it is necessary to include new instructions in the code to
    read the value of variables at a concrete point of execution or code to stop the
    execution in order to know whether it is passing through a function.
  prefs: []
  type: TYPE_NORMAL
- en: However, this process can be managed by the debugger. This is a tool or application
    that allows us to control the execution of our application in order to follow
    each executed instruction and find the bugs or errors, avoiding having to add
    code instructions in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The debugger uses an instruction called breakpoint. A **breakpoint** is, as
    its name suggests, a point at which the application stops in order to be driven
    by the developer to decide what to do. At that point, the debugger gives different
    information about the current status of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We will see more about the debugger and breakpoint later on.
  prefs: []
  type: TYPE_NORMAL
- en: What is profiling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like debugging, profiling is a process to identify if our application is working
    properly in terms of performance. Profiling investigates the application’s behavior
    in order to know the dedicated time to execute different parts of code to find
    bottlenecks or optimize them in terms of speed or consumed resources.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling is usually used during the development process as part of debugging,
    and it is necessary to measure it in proper environments by specialists to get
    real data from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four different kinds of profilers: based on events, statistics, tools
    to support code, and simulation.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging and profiling in PHP with Xdebug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will install and set up Xdebug in our project. This must be installed
    on our IDE, so depending on which one you use, this process will be different,
    but the steps to follow are quite similar. In our case, we will install it on PHPStorm.
    Even if you use a different IDE, after installing Xdebug, the workflow for debugging
    your code in any IDE will largely be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install Xdebug on our Docker, we should modify the proper `Dockerfile` file.
    We will install it on the user microservices, so open the `docker/microservices/user/php-fpm/Dockerfile`
    file and add the following highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first highlighted block is necessary to `install xdebug`. The `&& pecl install
    xdebug` line is used to install Xdebug using PECL, and the rest of the lines set
    the parameters on the `xdebug.ini` file. The second one is to copy the `php.ini` file
    from our local machine to Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also necessary to set some values on the `php.ini` file, so open it,
    it is located on `docker/microservices/user/php-fpm/config/php.ini`, and add the
    following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should enter your local IP address instead of `YOUR_LOCAL_IP_ADDRESS` in
    order to be visible in Docker, so Xdebug will be able to read our code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your local IP address is your IP inside your network, not the public one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can make the build in order to install everything necessary to debug
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This can take a few minutes. Xdebug will be installed once this is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it is time to set up Xdebug on our favorite IDE. As we said before, we will use
    PHPStorm, but feel free to use any other IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We have to create a server on the IDE, in PHPStorm this is done by navigating to **Preferences** |
    **Languages & Frameworks** | **PHP**. So, add a new one and set the `name` to
    `users`, for example, `host` to `localhost`, `port` to `8084`, and `debugger` to `xdebug`.
    It is also necessary to enable **Use path mappings** in order to map our routes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to navigate to **Tools** | **DBGp proxy- configuration** and ensure
    that the IDE key field is set to `PHPSTORM`, `Host` to `users` (this name must
    be the same one you entered on the servers section), and `Port` to `9000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop and start Docker by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Set PHPStorm to be able to listen to the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging setup](graphics/B06142_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Xdebug button to listen to connections in PHPStorm
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you are ready to view the debugger results. You just have to set the breakpoints
    in your code and the execution will stop at that point, giving you all the data
    values. To do this, go to your code, for example, on the `UserController.php`
    file, and click on the left side of a line. It will create a red point; this is
    a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the output](graphics/B06142_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Breakpoint in PHPStorm
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have the breakpoint set and the debugger running, so it is time to
    make a call with Postman to try the debugger. Give the breakpoint a try by executing
    a POST call to `http://localhost:8084/api/v1/user` with the `api_key = RSAy430_a3eGR and XDEBUG_SESSION_START
    = PHPSTORM` parameters. The execution will stop at the breakpoint and, from there,
    you have the execution control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the output](graphics/B06142_06_03-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugger console in PHPStorm
  prefs: []
  type: TYPE_NORMAL
- en: Note that you have all the current values for the parameters on the variables
    side. In this case, you can see the `test` parameter set to `"this is a test"`;
    we assigned this value two lines before the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we said, now we have control of the execution; the three basic functions
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step over:** This continues the execution with the following line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step into:** This continues the execution inside a function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step out:** This continues the execution outside a function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All these basic functions are executed step by step, so it will stop in the
    next line, it does not need any other breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is very useful to find errors in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have Xdebug installed, we just need to add the following lines on the
    `docker/microservices/user/php-fpm/Dockerfile` file to enable the profiling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With `profiler_enable`, we enable the profiler and the output directory is set
    by `profiler_output_dir`. This directory should exist on our user microservice
    in order to get the profiler output files. So, if it is not yet created, do it
    now on `/source/user/tmp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can make the build in order to install everything necessary to debug
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This can take a few minutes. Xdebug will be installed once this is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It does not need to be set up, so just stop and start Docker by executing the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Set PHPStorm to be able to listen to the debugger as we did with the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the output file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To generate the profiling file, we need to execute a call as we did before with
    Postman, so feel free to execute the method you want. It will generate a file
    located on the folder we made before with name `cachegrind.out.XX`.
  prefs: []
  type: TYPE_NORMAL
- en: If you open this file, you will note that it is difficult to understand, but
    there are some tools to read this type of content. PHPStorm has a tool located
    on **Tools** |  ****Analyze** Xdebug Profiler Snapshot**. Once you open it, you
    can select the file to analyze and then the tool will show you a detailed analysis
    of all the files and functions executed in the call. Displaying the time spent,
    times called, and other interesting things are very useful to optimize your code
    and find bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error handling is the way we manage the errors and exceptions in our application.
    This is very important in order to have all the possible errors that can happen
    in our development detected and organized.
  prefs: []
  type: TYPE_NORMAL
- en: What is error handling?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The term *error handling* is used in development to refer to the process of
    responding to the occurrence of an exception during the execution.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the appearance of exceptions breaks the normal workflow of an application
    execution and executes a registered exception handler, giving us more information
    about what is happening and, sometimes, how we can avoid the exception.
  prefs: []
  type: TYPE_NORMAL
- en: The way that PHP handles the errors is very basic. A default error message is
    composed of the filename, line, and a little description about the error that
    the browser receives. In this chapter, we will see three different ways to handle
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Why is error handling important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The majority of applications are very complex and large, and they are also developed
    by different people or even different teams if we are working on an application
    based on microservices as we are doing here. Can you imagine all the potential
    bugs that would appear in a project if we mix all these things? It is impossible
    to be aware of all the possible issues that an application can have or the users
    will find in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, error handling helps in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Users or consumers**: In microservices, error handling is very useful because
    it allows the consumers to know the possible problems that an API has and maybe
    they can figure out if it is a problem related to the introduced parameters in
    the API call, or the file size of an image. Also, in microservices, it is very
    useful to use different status codes for the errors in order to let the consumer
    know what is happening. You can find these codes in the [Chapter 11](ch11.html
    "Chapter 11. Best Practices and Conventions"), *Best Practices and Conventions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On a commercial website, the error handling avoids showing strange messages
    like `PHP Fatal error: Cannot access empty property` to the users or customers.
    Instead of this, it can say something simple, such as `There is an error. Please
    contact us`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Developers or yourself**: It allows the rest of the team and even yourself
    to be aware of any errors in your application, helping you to debug possible issues.
    There are many tools to get these kinds of bugs and send them to you by e-mail,
    written in a log file, or put on an event log, detailing the error tracking, function
    parameters, database calls, and more interesting things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges when managing error handling with microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, we will explain three different ways to handle errors.
    When we are working with microservices, we have to monitor all the possible errors
    in order to let the microservices know what the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: Basic die() function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In PHP, the basic way to handle errors is using the die() command. Let’s look
    at an example. Imagine that we want to open a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When the execution arrives at that point and tries to open the file called
    `test.txt`, if the file does not exist PHP will throw an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid the error message, we can use the `die()` function with the reason
    written in it so that the execution does not continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is just an example of the basic error handling on PHP. Obviously, there
    are better ways to manage this, but this is the minimum required to manage errors.
    In other words, avoiding the automatic error message from the PHP application
    is more efficient than stopping the execution manually and giving a human-language
    reason to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an alternate way to manage this.
  prefs: []
  type: TYPE_NORMAL
- en: Custom error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a system to manage the errors in your application is a better practice
    than using the `die()` function. Lumen provides us with this system and it is
    already configured when it is installed.
  prefs: []
  type: TYPE_NORMAL
- en: We can configure it by setting other parameters. The first thing is the error
    detail. It is possible to get more information about the errors by setting it
    to `true`. To do this, it is necessary to add the `APP_DEBUG` value on your `.env`
    file and set it to `true`. This is the recommended way to work on the development
    environment so that the developers can know more about the issues of the application,
    but once the application is on the production server, this value should be set
    to `false` in order to avoid giving more information to the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'This system manages all the exceptions through the `AppExceptionsHandler` class.
    This class contains two methods: `report` and `render`. Let’s explain them.'
  prefs: []
  type: TYPE_NORMAL
- en: Report method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Report` method is used to log the exceptions that happen in your microservice
    or it is even possible to send them to an external tool, such as Sentry. We will go
    through this in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, this method only logs the problem on the base class, but you
    can manage the different exceptions however you want. Check how you can do this
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The way to manage the different errors is `instanceof`. As you can see, in the
    preceding example, you can have different responses for each exception type.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to ignore some exception types by adding a variable to the
    `$dontReport` class. It is an array of different exceptions that you do not want
    to report. If we do not use this variable on the `Handle` class, only the `404`
    errors will be ignored by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Render method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the `report` method is used to help developers or yourself, the render method
    is to help users or consumers. This method gives an exception in an HTTP response
    that will be sent back to the user if it is a website and to a consumer if it
    is an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the exception is sent to the base class to generate a response,
    but it can be modified. Take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `render` method receives two parameters: the request and
    the exception. With these parameters, you can make a proper response for your
    users or consumers, giving the information you want to give for each exception.
    For example, by giving an error code to the consumers of your API, they can check
    it on the API documentation. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The consumer will receive an error message with the `code 44`; this should be
    on our API documentation, and the proper status code. Obviously, this can be different
    in order to match your consumer's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling with Sentry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is even better having a system to monitor the errors. There are a lot of
    error-tracking systems on the market but one that stands out is Sentry, a real-time
    cross-platform error tracking system that provides us with clues to understand
    what is happening in our microservices. An interesting feature is its support
    of notifications by e-mail or other medium.
  prefs: []
  type: TYPE_NORMAL
- en: Using a well-known system benefits your application, you are using a trusted
    and well-known tool, which in our case has an easy integration with our framework,
    Lumen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is install Sentry in our Docker environment;
    so, as always, stop all your containers with `docker-compose stop`. Once all the
    containers are stopped, open the `docker-compose.yml` file and add the following
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we firstly created a specific `redis` and `postgresql`
    container that will be used by Sentry. Once we had the required data storage containers,
    we added and linked the different containers that are the core of Sentry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will spin up the minimum containers we need for the Sentry
    setup. Once we have them up for the first time, we need to configure and fill
    the database and users. We can do it by running just one command on the container
    we have available for Sentry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will do all the setup needed for Sentry to run and will
    ask you to create an account to have access to the UI as admin; do this to save
    it and use it later. As soon as it finishes and returns you to the command path,
    you can spin up the remaining containers of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as everything is up, you can open `http://localhost:9876` in your browser
    and you will see a screen similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error handling with Sentry](graphics/B06142_06_03-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sentry login page
  prefs: []
  type: TYPE_NORMAL
- en: Log in with the user you created in the previous step and create a new project
    to start tracking our errors/logs.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using a single Sentry project to store all your debug information,
    it is better if you split them into logical groups, for example, one for the user
    microservice API, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your project, you will need the DSN assigned to this
    project; open your project settings and select the **Client Keys** option. In
    this section, you can find the **DSN** keys assigned to the project; you will
    be using these keys in your code so that the library knows where it needs to send
    all the debug information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error handling with Sentry](graphics/B06142_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sentry DSN keys
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! At this point, you have Sentry ready to be used in your project.
    Now it is time to install the `sentry/sentry-laravel` package using composer.
    To install this library, you can edit your `composer.json` file or enter your
    user microservice container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are inside the container, give the following command to use composer
    to update your `composer.json` and install it for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it is installed, we need to configure it on our microservice, so open
    the `bootstrap/app.php` file and add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to configure the report method as we saw earlier, so go to the
    `app/Exceptions/Handler.php` file and add the following lines in the report function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines will report the exception to Sentry, so let’s create the `config/sentry.php`
    file with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Application logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A log is a record of debug information that can be important in the future to
    see the performance of your application or to see how your application is doing
    or even to get some stats. Practically, all known applications produce some kind
    of log information. For example, by default, all the requests to NGINX are recorded
    in the `/var/log/nginx/error.log` and `/var/log/nginx/access.log`. The first one, `error.log`,
    stores any errors generated by your application, for example, PHP exceptions.
    The second one, `access.log`, is created by each request that hits your NGINX
    server.
  prefs: []
  type: TYPE_NORMAL
- en: As an experienced developer, you already know that keeping some logs in your
    application is very important and you are not alone in this task, you can find
    a lot of libraries that can make your life easier. You may be wondering where
    the important places are and where you can place log calls and the information
    you need to save. There is no rule of thumb you can always follow, you only need
    to think about the future, and about what information you will need in the worst
    case scenario (a broken app).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s focus on our example application; in the user service, we will be dealing
    with user registrations. An interesting point where you can place a log call is
    just before you save a new user registration. By doing this, you can keep track
    of your logs and know which information we are trying to save and when. Now, imagine
    that there is a bug in the registration process and it breaks with special characters
    but you were not aware of this, the only thing you know is that there are some
    users reporting issues with the registration. What will you do now? Check the
    logs! You can easily check which information the users are trying to store and
    detect that users with special characters are not being registered.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you are not using a log system, you can use `error_log()` to
    store messages in the default log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `0` parameter indicates that we want to store our message in the default
    log file. This function allows us to send the message by e-mail, changing the
    `0` parameter with `1` and adding an extra parameter with the e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the log systems allow you to define different levels; the most common ones
    are (note that they can be named differently in different log systems, but the
    concept is the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '**INFO**: This refers to non-critical information. You usually store debug
    information with this level, for example, you can store a new record each time
    a specific page is rendered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WARNING**: These are errors that are not very important or where the system
    can recover itself. For example, the lack of some information that can generate
    an inconsistent state of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ERROR**: This is critical information and, of course, all of these are errors
    that take place in your application. This is the first level you will check every
    time you find an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Challenges in microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are working with a monolithic application, your logs will be stored
    in the same location by default or at least in only a few servers. If you have
    any problems and you need to check your logs, you can get all the information
    in a few minutes. The challenge is when you are dealing with a microservice architecture
    where each microservice generates log information. It is even worse if you have
    multiple instances of a microservice, each instance creating its own log data.
  prefs: []
  type: TYPE_NORMAL
- en: What will you do in this case? The answer is to store all the log records in
    the same place using log systems like Sentry. Having a log service allows you
    to scale your infrastructure without worrying about your logs. They will all be
    stored in the same place, allowing you to easily find information about different
    microservices/instances.
  prefs: []
  type: TYPE_NORMAL
- en: Logs in Lumen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lumen comes out of the box with **Monolog** (PSR-3 interface) integrated; this
    log library allows you to use different log handlers.
  prefs: []
  type: TYPE_NORMAL
- en: In the Lumen framework, you can set up the amount of error detail of your application
    in the `.env` file. The `APP_DEBUG` setting defines how much debug information
    will be generated. The main recommendation is to set this flag to `true` in development
    environments but always to `false` in production.
  prefs: []
  type: TYPE_NORMAL
- en: To use logging facilities in your code, you only need to ensure that you have
    uncommented the `$app->withFacades();` line of your `bootstrap/app.php` file.
    Once you have the facades enabled, you can start using the Log class in any place
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, without any extra configuration, Lumen will store the logs in the
    `storage/logs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our logger provides the eight logging levels defined in RFC 5424:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Log::emergency($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log::alert($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log::critical($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log::error($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log::warning($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log::notice($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log::info($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Log::debug($error);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interesting feature is the option where you have to add an array of contextual
    data. Imagine that you want to log a record of a failed user login. You can do
    something similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding piece of code, we are adding extra information to our log message--the
    ID of the user who had problems trying to log into our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup of Monolog with a custom handler like Sentry (we explained how to
    install it in your project earlier) is very easy, you only need to add the following
    piece to the `bootstrap/app.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code changes how Monolog will work; in our case, instead of storing
    all our debug information in the `storage/logs` folder, it will use our Sentry
    installation and the `WARNING` level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We showed you two different ways of storing your logs in Lumen: in local files
    like a monolithic application or with an external service. Both of them are fine
    but our recommendation for microservices development is to use an external tool
    like Sentry.'
  prefs: []
  type: TYPE_NORMAL
- en: Application monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, application monitoring can be defined as the process
    which ensures that our application performs in an expected manner. This process
    allows us to measure and evaluate the performance of our application and can be
    helpful to find bottlenecks or hidden issues.
  prefs: []
  type: TYPE_NORMAL
- en: Application monitoring is usually made through a specialized software that gathers
    metrics from the application or the infrastructure that runs your software. These
    metrics can include CPU load, transaction times, or average response times among
    others. Anything you can measure can be stored in your telemetry system so you
    can analyze it later.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring a monolithic application is easy; you have everything in one place,
    all logs are stored in the same place, all metrics can be gathered from the same
    host, you can know if your PHP thread is killing your server. The main difficulty
    you may find is finding the part of your application that is underperforming,
    for example, which part of your PHP code is wasting your resources.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with microservices, you have your code split into logical parts,
    allowing you to know which part of the application is underperforming, but at
    a big cost. You have all your metrics segregated between different containers
    or servers, making it difficult to have a big picture of the overall performance.
    By having a telemetry system in place, you can send all your metrics to the same
    location, making it easier to check and debug your application.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring by levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a developer, you need to know how your application is performing at all the
    levels, from the top level that is your application to the bottom that is the
    hardware or hypervisor level. In an ideal world, we will have control over all
    the levels, but the most probable scenario is that you will only be able to monitor
    up to the infrastructure level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows you the different layers and the relation with the
    server stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring by levels](graphics/B06142_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Monitoring layers
  prefs: []
  type: TYPE_NORMAL
- en: Application level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application level lives inside your application; all the metrics are generated
    by your code, in our case by PHP. Unfortunately, you can’t find free or open source
    tools for **Application Performance Monitoring** (**APM**) exclusively for PHP.
    In any case, you can find interesting third-party services with free plans to
    give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Two of the most well-known APM services for PHP are New Relic and Datadog. In
    both the cases, the installation follows the same path--you install an agent (or
    library) on your container/host and this small piece of software will start sending
    the metrics to its service, giving you a dashboard where you can manipulate your
    data. The main disadvantage of using third-party services is that you don’t have
    any control over this agent or metric system, but this disadvantage can be transformed
    into a plus point--you will have a reliable system that you don’t need to manage,
    you only need to worry about your application.
  prefs: []
  type: TYPE_NORMAL
- en: Datadog
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The installation of the Datadog client could not be easier. Open the `composer.json`
    of one of your microservices and drop the following line inside the `required` definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you save your changes and make a composer update, you will be able
    to use the `Datadogstatsd` class in your code and start sending metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you want to monitor the time your secret microservice spends getting
    all the servers you have in your database. Open the `app/Http/Controllers/SecretController.php`
    file of your secret microservice and modify your class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding piece of code defines your app and API keys of your Datadog account
    and we used them to set up our `Datadogstatsd` interface. The example logs the
    time spent retrieving all our secret records. The `Datadogstatsd::timing()` method
    will send the metric to our external telemetry service. Doing the monitoring inside
    your application allows you to decide the places of your code you want to generate
    metrics in. There is no rule of thumb when you are monitoring this level, but
    you need to remember that it is important to know where your application spends
    most of its time, so add metrics in each place of your code that you think could
    be a bottleneck (like getting data from another service or from a database).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this library, you can even increment and decrement custom metric points
    with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The three of them increase a point: the first increments `another.data.point`
    in one unit, the second one increments our point by `0.5`, and the third one increments
    the point and also adds a custom tag to the metric record.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also decrement points with `Datadogstatsd::decrement()`, which has the
    same syntax as `::increment()`.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This level controls everything between the OS and your application. Adding a
    monitoring system to this layer allows you to know if your container is using
    too much memory, or if the load of a specific container is too high. You can even
    track some basic metrics of your application.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple options to monitor this layer in the high street, but we
    will give you a sneak peek at two interesting projects. Both of them are open
    source and even though they use different approaches, you can combine them.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Prometheus** is an open source monitoring and alerting toolkit that was created
    at SoundCloud and is under the umbrella of the **Cloud Native Computing Foundation**.
    Being the new kid on the block doesn''t mean that it doesn''t have powerful features.
    Among others, we can highlight the following main features:'
  prefs: []
  type: TYPE_NORMAL
- en: Time series collection through pull over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target discovery via service discovery (kubernetes, consul, and so on) or static
    config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web UI with simple graphing support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful query language that allows you to extract all the information you need
    from your data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Installing Prometheus is very easy with Docker, we only need to add a new container
    for our telemetry system and link it with our autodiscovery service (Consul).
    Add the following lines to the `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we only tell Docker where the `Dockerfile` is located,
    link the container without autodiscovery container, and expose and map some ports.
    Now, it''s time to create the `telemetry/Dockerfile` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it does not take a lot to create our telemetry container; we
    are using the official image and adding our Prometheus configuration. Create the
    `etc/prometheus.yml` configuration with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Again, the setup is very easy as we are defining some global scrapping intervals
    and one job called `containerpilot-telemetry` that will use our autodiscovery
    container and monitor all the services stored in consul announced under the `containerpilot`
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prometheus has a simple and powerful web UI. Open your `localhost:9090` and
    you have access to all the metrics gathered by this tool. Creating a graph is
    very easy, choose a metric and Prometheus will do all the work for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prometheus](graphics/B06142_06_07-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prometheus graph UI
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you will probably be wondering how you can declare metrics.
    In the earlier chapters, we introduced `containerpilot`, a tool we will use as
    a PID in our containers to manage our autodiscovery. The `containerpilot` has
    the ability to declare metrics to be available for the supported telemetry systems,
    in our case Prometheus. If you open, for example, the `docker/microservices/battle/nginx/config/containerpilot.json`
    file, you can find something similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding piece of code, we are declaring two metrics: `"nginx_connections_unhandled_total"` and
    `"nginx_connections_load"`. `ContainerPilot` will run the command defined in the
    `"check"` parameter inside the container and the result will be scrapped by Prometheus.'
  prefs: []
  type: TYPE_NORMAL
- en: You can monitor anything in your infrastructure with Prometheus, even Prometheus
    itself. Feel free to change our basic installation and setup and adapt it to use
    the autopilot pattern. If the Prometheus’ web UI is not enough for your graphics
    and you need more power and control, you can easily link our telemetry system
    with Grafana, one of the most powerful tools out there to create dashboards with
    all kinds of metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Weave Scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Weave Scope** is a tool used for monitoring your containers, it works well
    with Docker and Kubernetes and has some interesting features that will make your
    life easier. Scope gives you a deep top-down view of your app and your entire
    infrastructure. With this tool, you can diagnose any problems in your distributed
    containerized application, and everything in real time.'
  prefs: []
  type: TYPE_NORMAL
- en: Forget about complex configurations, Scope automatically detects and starts
    monitoring every host, Docker container, and any process running in your infrastructure.
    As soon as it gets all this information, it creates a nice map showing the inter-communications
    between all your containers in real time. You can use this tool to find memory
    issues, bottlenecks, or any other problems. You can even check different metrics
    of a process, container, service, or host. A hidden feature you can find in Scope
    is the ability to manage containers, view logs, or attach a terminal, all from
    the browser UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two options to deploy Weave Scope: in a standalone mode where all
    the components run locally or as a paid cloud service where you don''t need to
    worry about anything. The standalone mode runs as a privileged container inside
    each one of your infrastructure servers and has the ability to correlate all the
    information from your cluster or servers and display it in the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation is very easy--you only need to run the following commands
    on each one of your infrastructure servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you have Scope launched, open the IP address of your server (localhost
    if you are working locally like us) `http://localhost:4040`, and you will see
    something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Weave Scope](graphics/B06142_06_08-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Weave Scope containers graph visualization
  prefs: []
  type: TYPE_NORMAL
- en: The preceding image is a snapshot of the application we are building; here,
    you can see all our containers and the connections between them in a specific
    moment in time. Give it a try and while you make some calls to our different API
    endpoints, you will be able to see the connections between containers changing.
  prefs: []
  type: TYPE_NORMAL
- en: Can you find any problems in our microservices infrastructure? If so, you are
    correct. As you can see, we didn't connect some of our containers to the autodiscovery
    service. Scope helped us find a possible future problem, now feel free to fix
    it.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can use Scope to monitor your app from a browser. You only
    need to be careful with who has access to the privileged Scope container; if you
    have plans to use Scope in production, ensure that you limit the access to this
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware/hypervisor monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This layer matches our hardware or hypervisor level and is the lowest place
    where you can place your metrics. The maintenance and monitoring of this layer
    is usually done by sysadmins and they can use very well-known tools, such as **Zabbix**
    or **Nagios**. As a developer, you will probably not be worried about this layer.
    If you deploy the application in a cloud environment, you will not have any kind
    of access to the metrics generated by this layer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained how you can debug and do a profiling of a microservice
    application, an important process in any software development. On a day-to-day
    basis, you will not spend all your time debugging or profiling your application;
    in some scenarios, you will spend a lot of time trying to fix bugs. For this reason,
    it is important to have a place where you can store all your errors and debug
    information, this information will give you a deeper understanding of what is
    happening with your app. Finally, as a full-stack developer, we showed you how
    to monitor the top two layers of your application stack.
  prefs: []
  type: TYPE_NORMAL
