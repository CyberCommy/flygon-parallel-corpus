- en: Security in Code and Deployment
  prefs: []
  type: TYPE_NORMAL
- en: After establishing the proper tests, it is necessary to perform a security audit
    to make sure our application will not be used for malicious purposes. This chapter
    describes how to assess the security of the code base, including both the internally
    developed software as well as third-party modules. It will also show how to improve
    existing software both at the code level and at the operating system level.
  prefs: []
  type: TYPE_NORMAL
- en: You'll learn how to design applications with a focus on security at each level,
    starting with code, through to dependencies, architecture, and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking the code security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the dependencies are secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the examples used in this chapter require the compilers with the minimal
    versions of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GCC 10+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clang 3.1+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code present in the chapter has been placed on GitHub at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter10](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Checking the code security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provide information on how to check your code, your dependencies,
    and your environment for potential threats. Keep in mind, though, that following
    every step outlined within this chapter won't necessarily protect you against
    all possible problems. Our aim is to show you some possible dangers and the ways
    to deal with them. Given this, you should always be conscious of the security
    of your system and make audits a routine event.
  prefs: []
  type: TYPE_NORMAL
- en: Before the internet became ubiquitous, software authors weren't too concerned
    about the security of their designs. After all, if the user presented malformed
    data, the user could crash their own computer at most. In order to use software
    vulnerabilities to access protected data, the attacker had to obtain physical
    access to the machines holding the data.
  prefs: []
  type: TYPE_NORMAL
- en: Even in software that was designed to be used within networks, security was
    often an afterthought. Take the **Hypertext Transfer Protocol** (**HTTP**) as
    an example. Even though it allows the password protection of some assets, all
    of the data is transferred in plain text. This means everyone on the same network
    can eavesdrop on the data being transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we should embrace security right from the first stages of design and
    keep it in mind at every stage of software development, operations, and maintenance.
    Most of the software we produce every day is meant to, in one way or another,
    connect with other existing systems.
  prefs: []
  type: TYPE_NORMAL
- en: By omitting security measures, we open up not only ourselves but also our partners
    to potential attacks, data leaks, and, eventually, lawsuits. Keep in mind that
    failure to protect personal data can result in a fine of several million US dollars.
  prefs: []
  type: TYPE_NORMAL
- en: Security-conscious design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we design an architecture for security? The best way to do this is to
    think like a potential attacker. There are many ways in which you can break a
    box open but usually, you will look for the cracks where different elements connect.
    (In the case of a box, this may be between the lid and the bottom of the box.)
  prefs: []
  type: TYPE_NORMAL
- en: In software architecture, connections between elements are called interfaces.
    Since their main role is to interact with the external world, they are the most
    vulnerable part of the entire system. Making sure your interfaces are protected,
    intuitive, and robust will solve the most obvious ways in which your software
    can be broken.
  prefs: []
  type: TYPE_NORMAL
- en: Making interfaces easy to use and hard to misuse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To design interfaces in a way that would be both easy to use and hard to misuse,
    consider the following exercise. Imagine you are a customer of your interface.
    You want to implement an e-commerce store that uses your payment gateway, or maybe
    you want to implement a VR application that connects with the Customer API of
    the example system we've used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule regarding interface design, avoid the following traits:'
  prefs: []
  type: TYPE_NORMAL
- en: Too many parameters passed to the function/method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambiguous names of parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using output parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters depending on other parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why are these traits considered problematic?
  prefs: []
  type: TYPE_NORMAL
- en: The first one makes it hard to memorize not only the meaning but also the order
    of the parameters. This can lead to errors in usage, which, in turn, may lead
    to crashes and security issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second trait has similar consequences to the first one. By making it less
    intuitive to use your interface, you make it easier for the user to make mistakes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third trait is a variant of the second one but with an added twist. Not
    only does the user have to remember which parameters are input and which are output,
    but it is also necessary for the user to remember how the output should be treated.
    Who manages the creation and deletion of the resources? How is this achieved?
    What is the memory management model behind it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With modern C++, it's easier than ever to return a value that contains all of
    the necessary data. With pairs, tuples, and vectors, there is no excuse to use
    the output parameters. Besides all of this, returning the value helps embrace
    the practice of not modifying the state of an object. This, in turn, reduces concurrency-related
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last trait introduces unnecessary cognitive load, which, as in
    the previous examples, can result in mistakes and eventually failures. Such code
    is also harder to test and maintain as each change introduced has to take into
    account all the possible combinations already available. Failure to properly handle
    any combination is a potential threat to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding rules apply to the external part of the interfaces. You should
    also apply similar measures to the internal part by validating the inputs, making
    sure the values are correct and sensible and preventing unwanted use of the services
    the interface provides.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling automatic resource management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: System instability may also result from memory leaks, data races, and deadlocks.
    All of these symptoms are manifestations of poor resource management. Even though
    resource management is a hard topic, there is a mechanism that can help you reduce
    the number of problems. One such mechanism is automatic resource management.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, a resource is something you gain access to via the operating
    system and you have to make sure you use it correctly. This may mean using dynamically
    allocated memory, open files, sockets, processes, or threads. All of these require
    specific actions to be taken when you acquire them and when you release them.
    Some of them also require specific actions during their lifetime. Failure to release
    such resources at the right time leads to leaks. Since the resources are usually
    finite, in the long run, leaks will turn to unexpected behavior when no new resources
    can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Resource management is so important in C++ because, unlike many other high-level
    languages, there is no garbage collection in C++ and the software developers are
    responsible for the life cycle of the resources. Understanding this life cycle
    helps create secure and stable systems.
  prefs: []
  type: TYPE_NORMAL
- en: The most common idiom of resource management is **Resource Acquisition Is Initialization**
    (**RAII**). Although it originated in C++, it has also been used in other languages,
    such as Vala and Rust. This idiom uses the object's constructor and destructor
    to allocate and free up resources, respectively. This way, we can guarantee that
    the resource in use will be properly freed when the object that holds it goes
    out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of using this idiom in the standard library are the `std::unique_ptr`
    and `std::shared_ptr` smart pointer types. Other examples include mutexes – `std::lock_guard`,
    `std::unique_lock`, and `std:shared_lock` – or files – `std::ifstream` and `std::ofstream`.
  prefs: []
  type: TYPE_NORMAL
- en: The **Guidelines Support Library** (**GSL**), which we'll discuss at length
    shortly, also implements a particularly useful guideline for automated resource
    management. By using the `gsl::finally()` function in our code, we create a `gsl::final_action()`
    object with some code attached to it. This code will be executed when the object's
    destructor is called. This means the code will be executed both upon a successful
    return from the function as well as when the stack unwinding happens during an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: This approach shouldn't be used too often as it is generally a better idea to
    design your classes with RAII in mind. But if you're interfacing with a third-party
    module and you want to ensure the safety of your wrapper, `finally()` can help
    you get there.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider that we have a payment operator that allows only a
    single concurrent login per account. If we don''t want to block the user from
    making future payments, we should always log out as soon as we finish processing
    the transaction. This is not a problem when we are on a happy path and everything
    goes according to our design. But in the event of an exception, we also want to
    be safe and release the resource. Here''s how we could do it using `gsl::finally()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of what happens during the call to `payment::process()`, we can at
    least guarantee that we log the user out as soon as we go out of `processTransaction()`'s
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: In short, using RAII makes you think more about the resource management during
    the class design phase while you have full control of the code and think less
    about when you (or other parties) use the interface when your intentions may no
    longer be as clear.
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of concurrency and how to deal with it
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While concurrency improves performance and resource utilization, it also makes
    your code much harder to design and debug. This is because, unlike in a single-threaded
    flow, the timing of operations cannot be determined upfront. In single-threaded
    code, you either write to the resource or read from it, but you always know the
    order of the operations and can, therefore, predict the state of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With concurrency, several threads or processes can be either reading from an
    object or modifying it at the same time. If the modifications aren''t atomic,
    we can reach one of the variants of the common update problem. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When calling the `chargeTheAccount` function from a non-concurrent code, everything
    will end up well. Our program will check the account balance and charge it if
    possible. The concurrent execution, however, can lead to a negative balance. This
    is because two threads can one after another call `getAccountBalance()`, which
    will return the same amount, such as `20`. After performing that call, both threads
    check whether the current balance is higher than the available amount. Finally,
    after the check, they modify the account balance. Supposing both transactions
    are for the amount of `10`, each thread will set the balance to be 20 – 10 = 10\.
    After *both* operations, the account has a balance of 10, even though it should
    be 0!
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate a similar class of problems, we can use solutions such as mutexes
    and critical sections, atomic operations provided by CPU, or concurrency-safe
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes, critical sections, and other similar concurrency design patterns prevent
    more than one thread from modifying (or reading) the data. Even though they are
    useful when designing concurrent applications, there is a trade-off associated
    with them. They effectively make parts of your code single-threaded. This is because
    code guarded by mutexes allows only a single thread to execute it; all of the
    others have to wait until the mutex is released. And since we introduce waiting,
    we can make our code less performant even though our original aim was to make
    it more performant.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic operations mean using a single CPU instruction to get the desired effect.
    The term can mean any high-level operation that transforms into a single CPU instruction.
    They are particularly interesting when that single instruction achieves *more*
    than would be normally possible. For example, **compare-and-swap** (**CAS**) is
    an instruction that compares the memory location with a given value and modifies
    the contents of this location to the new value only if the comparison proved successful.
    Since C++11, there's a `<std::atomic>` header available that contains several
    atomic data types and operations. CAS, for instance, is implemented as a `compare_and_exchange_*`
    set of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, concurrency-safe data structures (also known as concurrent data structures)
    provide safe abstractions for data structures that would otherwise require some
    sort of synchronization. For example, the Boost.Lockfree ([https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html](https://www.boost.org/doc/libs/1_66_0/doc/html/lockfree.html))
    library provides concurrent queues and stacks for use with multiple producers
    and multiple consumers. libcds ([https://github.com/khizmax/libcds](https://github.com/khizmax/libcds))
    also offers ordered lists, sets, and maps, but it hasn't been updated in a few
    years as of the time of writing this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Useful rules to keep in mind when designing concurrent processing are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider whether you need concurrency in the first place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass data by value rather than by pointer or reference. This prevents modifications
    of the value when other threads are reading it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the size of the data makes it impractical to share by value, use `shared_ptr`.
    This way, it's easier to avoid resource leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure coding, the guidelines, and GSL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Standard C++ Foundation released a set of guidelines to document the best
    practices for building C++ systems. It is a Markdown document released on GitHub
    under [https://github.com/isocpp/CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines).
    It is an evolving document without a release schedule (unlike the C++ standard
    itself). The guidelines are aimed at modern C++, which basically means code bases
    that implement at least C++11 features.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the rules presented in the guidelines cover the topics that we present
    in this chapter. For example, there are rules related to interface design, resource
    management, and concurrency. The editors of the guidelines are Bjarne Stroustrup
    and Herb Sutter, both respected members of the C++ community.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into detail describing the guidelines. We encourage you to read
    them yourself. This book is inspired by many of the rules presented there and
    we follow them in our examples.
  prefs: []
  type: TYPE_NORMAL
- en: To ease the use of these rules in various code bases, Microsoft released the
    **Guidelines Support Library** (**GSL**) as an open source project hosted on [https://github.com/microsoft/GSL](https://github.com/microsoft/GSL).
    It is a header-only library that you can include in your project to use the defined
    types. You can either include the whole GSL or selectively use only some of the
    types you plan on using.
  prefs: []
  type: TYPE_NORMAL
- en: What's also interesting about the library is the fact that it uses CMake for
    building, Travis for continuous integration, and Catch for unit testing. It is,
    therefore, a good example of the topics we've covered in [Chapter 7](7f997c01-2634-4584-be95-0b068f448312.xhtml),
    *Building and Packaging*, and [Chapter 8](160259bc-b601-4854-9aa9-cabe2c4fd691.xhtml),
    *Writing Testable Code*, and [Chapter 9](dba66494-c6a0-40f7-a6e8-c9612e996daf.xhtml),
    *Continuous Integration and Continuous Deployment*.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive coding, validating everything
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a previous chapter on testability, we mentioned the method of defensive programming.
    Even though this method is not strictly a security feature, it happens to help
    with creating a robust interface. Such interfaces, in turn, increase the overall
    security of your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a good heuristic, you can treat all the external data as unsafe. What we
    mean by external data is every input coming to the system via some interface (either
    a programming interface or user interface). To denote this, you can go as far
    as prefixing the appropriate types as `Unsafe`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you have already read the guidelines, you will know that you should generally
    avoid using the C API directly. Some of the functions in the C API can be used
    in an unsafe way and require special care to use them defensively. It is much
    better to instead use respective concepts from C++ that ensure better type safety
    as well as protection (for example, against buffer overflow).
  prefs: []
  type: TYPE_NORMAL
- en: Another facet of defensive programming is the intelligent reuse of the existing
    code. Each time you try to implement some technique, ensure nobody else has implemented
    it before you. Writing a sorting algorithm yourself may be a fun challenge to
    do when you're learning a new programming language, but for production code, it's
    much better to use the sorting algorithms available in the standard library. The
    same goes for password hashing. No doubt you can find some clever way to calculate
    the password hashes and store them in a database but it is generally wiser to
    go with the tried and true (and don't forget peer-reviewed!) `bcrypt`. Keep in
    mind that intelligent code reuse assumes you check and audit the third-party solutions
    with the same due diligence as you would your own code. We will dive deeper into
    this topic in the next section, *Are my dependencies secure?*.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that defensive programming shouldn't turn into paranoid programming.
    Checking user input is a sane thing to do, while asserting whether an initialized
    variable is still equal to the original value just after the initialization is
    going too far. You want to control the integrity of your data and algorithms and
    the integrity of third-party solutions. You don't want to verify the correctness
    of your compiler by embracing language features.
  prefs: []
  type: TYPE_NORMAL
- en: In short, it's a good idea from both a security and readability point of view
    to use `Expects()` and `Ensures()` as presented in C++ Core Guidelines and to
    distinguish between unsafe and safe data through typing and conversions.
  prefs: []
  type: TYPE_NORMAL
- en: The most common vulnerabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check whether your code is safe against the most common vulnerabilities,
    you should first learn about the said vulnerabilities. After all, a defense is
    only possible when you know what the offense looks like. The **Open Web Application
    Security Project** (**OWASP**) has cataloged the most common vulnerabilities and
    has published them at [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project).
    At the moment of writing this book, those vulnerabilities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Injection**: Commonly known as SQL injection. It is not limited to SQL; this
    vulnerability occurs when untrusted data is passed directly to an interpreter
    (such as a SQL database, NoSQL database, shell, or eval function). The attacker
    may this way gain access to parts of the system that should be protected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broken Authentication**: If authentication is improperly implemented, attackers
    may use flaws to either compromise secret data or impersonate other users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensitive Data Exposure**: The lack of encryption and proper access rights
    may lead to sensitive data being exposed publicly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XML External Entities** (**XXE**): Some XML processors may disclose the contents
    of the server''s filesystem or allow remote code execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broken Access Control**: When access control is not enforced properly, attackers
    may gain access to files or data that should be restricted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Misconfiguration**: Using insecure defaults and improper care with
    configuration are the most common sources of vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-Site Scripting** (**XSS**): Including and executing untrusted external
    data, especially with JavaScript, that allows control of the user''s web browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insecure Deserialization**: Some flawed parsers may fall prey to denial of
    services attacks or remote code execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Components with Known Vulnerabilities**: A lot of the code in modern
    applications comes as third-party components. These components should be regularly
    audited and updated as known security flaws in a single dependency can result
    in your entire application and data being compromised. Fortunately, there are
    tools that help automate this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insufficient Logging & Monitoring**: If your system is under attack and your
    logging and monitoring is not very thorough, the attacker may obtain deeper access
    and still become unnoticed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't go into detail regarding each of the mentioned vulnerabilities. What
    we want to highlight here is that you can prevent injection, XML external entities,
    and insecure deserialization by following the defensive programing techniques
    we mentioned before. By treating all external data as unsafe, you can first sanitize
    it by removing all the unsafe content before you start the actual processing.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to insufficient logging and monitoring, we will go into detail
    in [Chapter 15](27377621-3532-4513-8045-caa00285fdda.xhtml), *Cloud-Native Design*.
    There we will present some possible approaches to observability, including logging,
    monitoring, and distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the dependencies are secure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the early days of computers, all programs were monoliths without any external
    dependencies. Ever since the dawn of operating systems, any non-trivial software
    is rarely free from dependencies. Those dependencies can come in two forms: external
    dependencies and internal ones:'
  prefs: []
  type: TYPE_NORMAL
- en: External dependencies are those that should be present in the environment that
    we run our application. Examples can include the aforementioned operating systems,
    dynamically linked libraries, and other applications (such as a database).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal dependencies are modules we want to reuse, so this will usually mean
    static libraries or header-only libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both kinds of dependencies provide potential security risks. As each line of
    code increases the risk of vulnerability, the more components you have, the higher
    the chance your system may be susceptible to attack. In the following sections,
    we'll see how to check whether your software is indeed susceptible to known vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Common Vulnerabilities and Exposures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first place to check for known security issues within software is the **Common
    Vulnerabilities and Exposures** (**CVE**) list available at [https://cve.mitre.org/](https://cve.mitre.org/).
    The list is constantly updated by several institutions known as **CVE Numbering
    Authorities** (**CNAs**). These institutions include vendors and projects, vulnerability
    researchers, national and industry CERTs, and bug bounty programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The website also presents a search engine. With this, you can use several methods
    to learn about the vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: You can enter the vulnerability number. These are prefixed by `CVE` with examples
    including CVE-2014-6271, the infamous ShellShock, or CVE-2017-5715, also known
    as Spectre).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can enter the vulnerability common name, such as the previously mentioned
    ShellShock or Spectre.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can enter the name of the software you want to audit, such as Bash or Boost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each search result, you can see the description as well as a list of references
    to other bug trackers and related resources. The description usually lists versions
    affected by the vulnerability, so you can check whether the dependency you are
    planning to use has been already patched.
  prefs: []
  type: TYPE_NORMAL
- en: Automated scanners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are tools that can help you to audit your list of dependencies. One such
    tool is OWASP Dependency-Check ([https://www.owasp.org/index.php/OWASP_Dependency_Check](https://www.owasp.org/index.php/OWASP_Dependency_Check)).
    Although it only supports Java and .NET officially, it has experimental support
    for Python, Ruby, Node.js, and C++ (when used with CMake or `autoconf`). Besides
    working as a standalone tool, it has integrations for **Continuous Integration/Continuous**
    **Deployment** (**CI/CD**) software such as Jenkins, SonarQube, and CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that allows checking dependencies for known vulnerabilities is
    Snyk. This is a commercial product with several levels of support. It also does
    more than the OWASP Dependency-Check as Snyk can also audit container images and
    license compliance issues. It also offers more integrations with third-party solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Automated dependency upgrade management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monitoring your dependencies for vulnerabilities is only the first step in making
    sure your project is secure. After that, you need to take action and update the
    compromised dependencies manually. As you might have expected, there are also
    automated solutions just for that. One of them is Dependabot, which scans your
    source code repository and issues a pull request whenever there's a security-related
    update available. At the moment of writing this book, Dependabot does not support
    C++ yet. It can, however, be used with other languages that your application may
    use. Other than that, it can scan Docker containers for vulnerabilities found
    in base images.
  prefs: []
  type: TYPE_NORMAL
- en: Automated dependency management requires mature test support. Switching dependency
    versions without tests may lead to instabilities and bugs. One protection against
    problems related to dependency upgrades is using wrappers to interface with third-party
    code. Such wrappers may have their own suite of tests that instantly tells us
    when an interface is broken during an upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can reduce the number of common security vulnerabilities in your own code
    by using modern C++ constructions as opposed to older C equivalents. Yet, there
    are always cases when even more secure abstractions prove to be vulnerable as
    well. It is not enough to choose the more secure implementation and decide you've
    done your best. Most of the time, there are ways to further harden your code.
  prefs: []
  type: TYPE_NORMAL
- en: But what is code hardening? According to the definition, it is the process of
    reducing the system's surface of vulnerability. Often, this means turning off
    the features you won't be using and aiming for a simpler system over a complicated
    one. It may also mean using tools to increase the robustness of the already-available
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Such tools may mean kernel patches, firewalls, and **Intrusion Detection Systems**
    (**IDSes**) when applied at the operating system level. At the application level,
    it may mean various buffer overrun and underflow protection mechanisms, using
    containers and **Virtual Machines** (**VMs**) for privilege separation and process
    isolation, or enforcing encrypted communication and storage.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll focus on some examples from the application level, while
    the next section will focus on the operating system level.
  prefs: []
  type: TYPE_NORMAL
- en: Security-oriented memory allocator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are serious about protecting your application from heap-related attacks,
    such as heap overflow, use-after-free, or double free, you may consider replacing
    your standard memory allocator with a security-oriented version. Two projects
    that may be of interest are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: FreeGuard, available at [https://github.com/UTSASRG/FreeGuard](https://github.com/UTSASRG/FreeGuard)
    and described in a paper at [https://arxiv.org/abs/1709.02746](https://arxiv.org/abs/1709.02746)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hardened_malloc` from the GrapheneOS project, available at [https://github.com/GrapheneOS/hardened_malloc](https://github.com/GrapheneOS/hardened_malloc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeGuard was released in 2017 and it hasn't seen much change since then other
    than sporadic bug fixes. `hardened_malloc`, on the other hand, is actively developed.
    Both allocators are designed to act as drop-in replacements for the standard `malloc()`.
    You can use them without modifying your application simply by setting the `LD_PRELOAD`
    environment variable or adding the library to the `/etc/preload.so` configuration
    file. While FreeGuard targets Linux with the Clang compiler on 64-bit x86 systems,
    `hardened_malloc` aims at broader compatibility, though at the moment supports
    mostly Android's Bionic, `musl`, and `glibc`. `hardened_malloc` is also based
    on OpenBSD's `alloc`, with OpenBSD being the security-focused project itself.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of replacing the memory allocator, you can replace the collections you
    use for their safer equivalents. The SaferCPlusPlus ([https://duneroadrunner.github.io/SaferCPlusPlus/](https://duneroadrunner.github.io/SaferCPlusPlus/))
    project provides substitutes for `std::vector<>`, `std::array<>`, and `std::string`
    that can be used as drop-in replacements in the existing code. The project also
    includes substitutes for basic types that guard against uninitialized use or sign
    mismatch, concurrent data types, and replacements for pointers and references.
  prefs: []
  type: TYPE_NORMAL
- en: Automated checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are tools that can be especially helpful to ensure the security of the
    system you are building. We will cover them in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler warnings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While not necessarily a tool in itself, compiler warnings can be used and tweaked
    to achieve even better output from the one tool every C++ developer will be using:
    the C++ compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the compiler can already do some deeper checks than those required by
    the standard, it is advised to take advantage of this possibility. When using
    a compiler such as GCC or Clang, the recommended setting involves `-Wall -Wextra`
    flags. This will generate much more diagnostics and result in warnings when your
    code doesn't follow the diagnostics. If you want to be really strict, you can
    also enable `-Werror`, which will turn all the warnings into errors and prevent
    the compilation of code that doesn't pass the enhanced diagnostics. If you want
    to keep strictly to the standards, there are the `-pedantic` and `-pedantic-errors`
    flags that will look for conformance against the standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using CMake for building, you can use the following function to enable
    these flags during compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This way, the compilation will fail unless you fix all the warnings (turned
    errors) reported by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find suggested settings for toolchain hardening in these articles
    from OWASP ([https://www.owasp.org/index.php/C-Based_Toolchain_Hardening](https://www.owasp.org/index.php/C-Based_Toolchain_Hardening))
    and Red Hat ([https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/](https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/)).
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One class of tools that can help with making your code more secure is the so-called
    **Static Application Security Testing** (**SAST**) tools. They are a variant of
    static analysis tools only focused on security aspects.
  prefs: []
  type: TYPE_NORMAL
- en: SAST tools integrate well into CI/CD pipelines as they are simply reading your
    source code. The output is usually suitable for CI/CD as well since it highlights
    problems found in particular places in the source code. On the other hand, static
    analysis may omit many types of problems that cannot be found automatically or
    cannot be found solely with static analysis. These tools are also oblivious to
    issues related to configuration, as configuration files aren't represented in
    the source code itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of C++ SAST tools include the following open source solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Cppcheck ([http://cppcheck.sourceforge.net/](http://cppcheck.sourceforge.net/)),
    which is a general-purpose static analysis tool focused on the low number of false
    positives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flawfinder ([https://dwheeler.com/flawfinder/](https://dwheeler.com/flawfinder/)),
    which doesn't seem to be actively maintained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LGTM ([https://lgtm.com/help/lgtm/about-lgtm](https://lgtm.com/help/lgtm/about-lgtm)),
    supporting several different languages and featuring automated analysis of pull
    requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SonarQube ([https://www.sonarqube.org/](https://www.sonarqube.org/)), which
    has great CI/CD integration and language coverage, and offers a commercial version
    as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also commercial solutions available:'
  prefs: []
  type: TYPE_NORMAL
- en: Checkmarx CxSAST ([https://www.checkmarx.com/products/static-application-security-testing/](https://www.checkmarx.com/products/static-application-security-testing/)),
    which promises zero configuration and road language coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeSonar ([https://www.grammatech.com/products/codesonar](https://www.grammatech.com/products/codesonar)),
    which focuses on in-depth analysis and finding the most flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Klocwork ([https://www.perforce.com/products/klocwork](https://www.perforce.com/products/klocwork)),
    which focuses on accuracy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Micro Focus Fortify ([https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview](https://www.microfocus.com/en-us/products/static-code-analysis-sast/overview)),
    with broad language support and integration of other tools by the same manufacturer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parasoft C/C++test ([https://www.parasoft.com/products/ctest](https://www.parasoft.com/products/ctest)),
    which is an integrated solution for static and dynamic analysis, unit testing,
    tracing, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polyspace Bug Finder from MathWorks ([https://www.mathworks.com/products/polyspace-bug-finder.html](https://www.mathworks.com/products/polyspace-bug-finder.html)),
    with the integration of Simulink models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Veracode Static Analysis ([https://www.veracode.com/products/binary-static-analysis-sast](https://www.veracode.com/products/binary-static-analysis-sast)),
    which is a SaaS solution for static analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WhiteHat Sentinel Source ([https://www.whitehatsec.com/platform/static-application-security-testing/](https://www.whitehatsec.com/platform/static-application-security-testing/)),
    which also focuses on eliminating false positives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just like static analysis is performed on the source code, dynamic analysis
    is performed on the resulting binaries. The "dynamic" in the name refers to the
    observation of the code in action processing the actual data. When focused on
    security, this class of tools can also be called **Dynamic Application Security
    Testing** (**DAST**).
  prefs: []
  type: TYPE_NORMAL
- en: Their main advantage over their SAST counterparts is that they can find many
    flows that cannot be seen from the source code analysis point of view. This, of
    course, introduces the drawback that you have to run your application in order
    to perform the analysis. And as we know, running an application can be both time-
    and memory-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: DAST tools usually focus on web-related vulnerabilities such as XSS, SQL (and
    other) injection, or disclosed sensitive information. We will focus more on one
    of the more general-purpose dynamic analysis tools, Valgrind, in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind and Application Verifier
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Valgrind is mostly known as a memory leak debugging tool. It is, in fact, an
    instrumentation framework that helps to build dynamic analysis tools not necessarily
    related to memory problems. Besides the memory error detector, the suite of tools
    currently consists of a thread error detector, a cache and branch prediction profiler,
    and a heap profiler. It's supported on various platforms on Unix-like operating
    systems (including Android).
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, Valgrind acts as a VM, first translating the binary into a simpler
    form called intermediate representation. Instead of running the program on an
    actual processor, it gets executed under this VM so each call can be can be analyzed
    and validated.
  prefs: []
  type: TYPE_NORMAL
- en: If you're developing on Windows, you can use **Application Verifier** (**AppVerifier**)
    instead of Valgrind. AppVerifier can help you detect stability and security issues.
    It can monitor running applications and user-mode drivers to look for memory issues
    such as leaks and heap corruption, threading and locking issues, invalid use of
    handles, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Sanitizers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sanitizers are dynamic testing tools that are based on compile-time instrumentation
    of code. They can help with the overall stability and security of the system,
    as well as avoiding undefined behavior. At [https://github.com/google/sanitizers](https://github.com/google/sanitizers),
    you can find implementations for LLVM (which Clang is based on) and GCC. They
    address problems with memory access, memory leaks, data races and deadlocks, uninitialized
    memory use, and undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**AddressSanitizer** (**ASan**) protects your code against issues related to
    memory addressing, such as global-buffer-overflow, use-after-free, or stack-use-after-return.
    Even though it''s one of the fastest solutions of its kind, it still slows down
    the process about two times. It''s best to use it when running tests and doing
    development but turn it off in production builds. You can turn it on for your
    builds by adding the `-fsanitize=address` flag to Clang.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AddressSanitizerLeakSanitizer** (**LSan**) integrates with ASan to find memory
    leaks. It is enabled by default on x86_64 Linux and x86_64 macOS. It requires
    setting an environment variable, `ASAN_OPTIONS=detect_leaks=1`. LSan performs
    leak detection at the end of the process. LSan can also be used as a standalone
    library without AddressSanitizer, but this mode is much less tested.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ThreadSanitizer** (**TSan**), as we previously mentioned, detects problems
    with concurrency such as data races and deadlocks. You can enable it with the
    `-fsanitize=thread` flag to Clang.'
  prefs: []
  type: TYPE_NORMAL
- en: '**MemorySanitizer** (**MSan**) focuses on bugs related to access to uninitialized
    memory. It implements some of the features of Valgrind that we covered in the
    previous subsection. MSan supports 64-bit x86, ARM, PowerPC, and MIPS platforms.
    You can enable it with the `-fsanitize=memory -fPIE -pie` flag to Clang (which
    also turns on position-independent executables, a concept we''ll discuss later
    on).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware-Assisted Address Sanitizer** (**HWASAN**) is similar to the regular
    ASan. The main difference is the use of hardware assistance when possible. This
    feature is, for now, available only on 64-bit ARM architectures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**UndefinedBehaviorSanitizer** (**UBSan**) looks for other possible causes
    of undefined behavior, such as integer overflow, division by zero, or improper
    bit shift operations. You can enable it with the `-fsanitize=undefined` flag to
    Clang.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though sanitizers can help you uncover many potential problems, they are
    only as good as the tests that you run them against. When using the sanitizers,
    keep in mind to keep the code coverage of your tests high because otherwise, you
    may get a false sense of security.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzz-testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A subcategory of DAST tools, fuzz-testing checks the behavior of your application
    when confronted with invalid, unexpected, random, or maliciously formed data.
    Such checks can be especially useful when used against the interfaces that cross
    the trust boundary (such as end user file upload forms or inputs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some interesting tools from this category include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Peach Fuzzer: [https://www.peach.tech/products/peach-fuzzer/](https://www.peach.tech/products/peach-fuzzer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PortSwigger Burp: [https://portswigger.net/burp](https://portswigger.net/burp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The OWASP Zed Attack Proxy project: [https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project](https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google''s ClusterFuzz: [https://github.com/google/clusterfuzz](https://github.com/google/clusterfuzz)
    (and OSS-Fuzz: [https://github.com/google/oss-fuzz](https://github.com/google/oss-fuzz))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process isolation and sandboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to run unverified software in your own environment, you may want
    to isolate it from the rest of your system. Some ways to sandbox the executed
    code is via VMs, containers, or micro VMs such as Firecracker ([https://firecracker-microvm.github.io/](https://firecracker-microvm.github.io/))
    used by AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the crashes, leaks, and security problems of one application won't
    propagate to the entire system, rendering it either useless or compromised. As
    each process will have its own sandbox, the worst-case scenario would be the loss
    of only this one service.
  prefs: []
  type: TYPE_NORMAL
- en: For C and C++ code, there is also **Sandboxed API** (**SAPI**; [https://githu](https://github.com/google/sandboxed-api)[b.com/google/sandboxed-api](https://github.com/google/sandboxed-api)[)
    an open source project led by Google. It allows building sandboxes not for entire
    processes but for libraries. It is used by Google's own Chrome and Chromium web
    browsers, among others.](https://github.com/google/sandboxed-api)
  prefs: []
  type: TYPE_NORMAL
- en: Even though VMs and containers can be a part of the process isolation strategy,
    don't confuse them with microservices, which often use similar building blocks.
    Microservices are an architectural design pattern and they don't automatically
    equal better security.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if you take the necessary precautions to ensure that your dependencies
    and code are free from known vulnerabilities, there still exists an area that
    can compromise your security strategy. All applications need an execution environment
    and this can mean either a container, VMs, or an operating system. Sometimes,
    this can also mean the underlying infrastructure as well.
  prefs: []
  type: TYPE_NORMAL
- en: It's not enough to make your application hardened to the maximum when the operating
    system it runs on has open access. This way, instead of targeting your application,
    the attacker can gain unauthorized access to the data directly from the system
    or infrastructure level.
  prefs: []
  type: TYPE_NORMAL
- en: This section will focus on some techniques of hardening that you can apply at
    this lowest level of execution.
  prefs: []
  type: TYPE_NORMAL
- en: Static versus dynamic linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linking is the process that occurs after compilation when the code you've written
    is brought together with its various dependencies (such as the standard library).
    Linking can occur at build time, at load time (when the operating system executes
    the binary), or at runtime, as is the case with plugins and other dynamic dependencies.
    The last two use cases are only possible with dynamic linking.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the difference between dynamic and static linking? With static linking,
    the contents of all the dependencies are copied to the resulting binary. When
    the program is loaded, the operating system places this single binary in the memory
    and executes it. Static linking is performed by programs called linkers as the
    last step of the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Because each executable has to contain all the dependencies, statically linked
    programs tend to be big. This has its upside as well; since everything needed
    to execute the problem is already available in a single place, the execution can
    be faster and it always takes the same amount of time to load the program into
    memory. Any changes in the dependencies require recompilation and relinking; there
    is no way to upgrade one dependency without changing the resulting binary.
  prefs: []
  type: TYPE_NORMAL
- en: In dynamic linking, the resulting binary contains the code you've written, but
    instead of the contents of the dependencies, there are only references to the
    actual libraries that need to be loaded separately. During load time, it is the
    task of the dynamic loader to find the appropriate libraries and load them to
    memory alongside your binary. When several applications are running simultaneously
    and each of them is using similar dependencies (such as a JSON parsing library
    or JPEG processing library), the dynamically liked binaries will result in lower
    memory usage. This is due to the fact that only a single copy of a given library
    can be loaded into memory. In contrast, with statically linked binaries, the same
    libraries would be loaded over and over again as part of the resulting binaries.
    When you need to upgrade one of your dependencies, you can do so without touching
    any other component of your system. The next time your application is loaded into
    memory, it will reference the newly upgraded component automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic linking also have security implications. It is easier to
    gain unauthorized access to dynamically linked applications. This can be achieved
    by substituting a compromised dynamic library in place of a regular one or by
    preloading certain libraries into each newly executed process.
  prefs: []
  type: TYPE_NORMAL
- en: When you combine static linking with containers (explained in detail in a later
    chapter), you get small, secure, sandboxed execution environments. You may even
    go further and use such containers with microkernel-based VMs that reduce the
    attack surface considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Address space layout randomization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Address Space Layout Randomization** (**ASLR**) is a technique used to prevent
    memory-based exploits. It works by replacing the standard memory layout of the
    program and data with a randomized one. This means an attacker cannot reliably
    jump to a particular function that would otherwise be present on a system without
    ASLR.'
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be made even more effective when combined with **no-execute**
    (**NX**) bit support. The NX bit marks certain pages in the memory, such as the
    heap and stack, as containing only data that cannot be executed. NX bit support
    has been implemented in most mainstream operating systems and can be used whenever
    hardware supports it.
  prefs: []
  type: TYPE_NORMAL
- en: DevSecOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deliver software increments on a predictable basis, it is best to embrace
    the DevOps philosophy. In short, DevOps means breaking the traditional model by
    encouraging communication between business, software development, software operations,
    quality assurance, and clients. DevSecOps is a form of DevOps that also emphasizes
    the need to design with security in mind at each step of the process.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the application you are building has observability built-in
    from the beginning, leverages CI/CD pipelines, and is scanned for vulnerabilities
    on a regular basis. DevSecOps gives developers a voice in the design of the underlying
    infrastructure, and it gives operations experts a voice in the design of the software
    packages that make up the application. Since every increment represents a working
    system (albeit not fully functional), security audits are performed regularly
    and therefore take less time than normal. This results in faster and more secure
    releases and allows for quicker reactions to security incidents.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed different aspects of a secure system. Since security
    is a complex topic, you cannot approach it only from the angle of your own application.
    All applications nowadays function in some environment and it is important to
    either control this environment and shape it according to your requirements or
    to shield yourself from the environment by sandboxing and isolating the code.
  prefs: []
  type: TYPE_NORMAL
- en: Having read this chapter, you are now ready to search for the vulnerabilities
    in your dependencies and in your own code. You know how to design systems for
    increased security and what tools to use in order to find possible flaws. Maintaining
    security is a constant process but a good design can reduce the work further down
    the road.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will deal with scalability and the various challenges that
    we may face when growing our system.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why is security important in modern systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some challenges of concurrency?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the C++ Core Guidelines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between secure coding and defensive coding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you check whether your software contains known vulnerabilities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between static and dynamic analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between static and dynamic linking?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How you can use the compiler to fix security problems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you implement security awareness in your CI pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cybersecurity in general**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/eu/networking-and-servers/hands-cybersecurity-architects](https://www.packtpub.com/eu/networking-and-servers/hands-cybersecurity-architects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/eu/networking-and-servers/information-security-handbook](https://www.packtpub.com/eu/networking-and-servers/information-security-handbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.owasp.org/index.php/Main_Page](https://www.owasp.org/index.php/Main_Page)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/eu/networking-and-servers/practical-security-automation-and-testing](https://www.packtpub.com/eu/networking-and-servers/practical-security-automation-and-testing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/eu/application-development/concurrent-patterns-and-best-practices](https://www.packtpub.com/eu/application-development/concurrent-patterns-and-best-practices)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/eu/application-development/mastering-c-multithreading](https://www.packtpub.com/eu/application-development/mastering-c-multithreading)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system hardening**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/eu/networking-and-servers/mastering-linux-security-and-hardening](https://www.packtpub.com/eu/networking-and-servers/mastering-linux-security-and-hardening)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
