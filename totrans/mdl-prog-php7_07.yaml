- en: Chapter 7. Building the Catalog Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The catalog module is an essential part of every web shop application. At the
    very basic level, it is responsible for the management and display of categories
    and products. It is a foundation for later modules, such as checkout, that add
    the actual sales capabilities to our web shop application.
  prefs: []
  type: TYPE_NORMAL
- en: The more robust catalog features might include mass product imports, product
    exports, multi-warehouse inventory management, private members categories, and
    so on. These however, are out of the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the high level application requirements, defined in [Chapter 4](ch04.html
    "Chapter 4. Requirement Specification for a Modular Web Shop App"), *Requirement
    Specification for Modular Web Shop App*, our module will have several entities
    and other specific features implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is a list of required module entities:'
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Category entity includes the following properties and their data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: integer, auto-increment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url_key`: string, unique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Product entity includes the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: integer, auto-increment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`category_id`: integer, foreign key that references the category table ID column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price`: decimal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sku`: string, unique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url_key`: string, unique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qty`: integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`: string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onsale`: boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from just adding these entities and their CRUD pages, we also need to
    override the core module services responsible for building the category menu and
    on sale items.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The module has no firm dependencies on any other module. The Symfony framework
    service layer enables us to code modules in such a way that, most of the time,
    there is no need for a dependency between them. While the module does override
    a service defined in the core module, the module itself is not dependent on it,
    as nothing will break if the overriding service is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start off by creating a new module called `Foggyline\CatalogBundle`. We
    do so with the help of the console, by running the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The command triggers an interactive process that asks us several questions
    along the way, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, the following structure is generated for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](graphics/B05460_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now take a look at the `app/AppKernel.php` file, we would see the following
    line under the `registerBundles` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the `app/config/routing.yml` has the following route definition
    added to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we need to change `prefix: /` into `prefix: /catalog/`, so we don''t collide
    with core module routes. Leaving it as `prefix: /` would simply overrun our core
    `AppBundle` and output `Hello World!` from the `src/Foggyline/CatalogBundle/Resources/views/Default/index.html.twig`
    template to the browser at this point. We want to keep things nice and separated.
    What this means is that the module does not define the root route for itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create a `Category` entity. We do so by using the console,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Creating entities](graphics/B05460_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This creates the `Entity/Category.php` and `Repository/CategoryRepository.php`
    files within the `src/Foggyline/CatalogBundle/` directory. After this, we need
    to update the database, so it pulls in the `Category` entity, as shown in the
    following command line instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a screen that looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating entities](graphics/B05460_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With entity in place, we are ready to generate its CRUD. We do so by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This results with interactive output as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating entities](graphics/B05460_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This results in `src/Foggyline/CatalogBundle/Controller/CategoryController.php`
    being created. It also adds an entry to our `app/config/routing.yml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, the view files are created under the `app/Resources/views/category/`
    directory, which is not what we might expect. We want them under our module `src/Foggyline/CatalogBundle/Resources/views/Default/category/`
    directory, so we need to copy them over. Additionally, we need to modify all of
    the `$this->render` calls within our `CategoryController` by appending the `FoggylineCatalogBundle:default:
    string` to each of the template paths.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we go ahead and create the `Product` entity by using the interactive
    generator as discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We follow the interactive generator, respecting the minimum of the following
    attributes: `title`, `price`, `sku`, `url_key`, `description`, `qty`, `category`,
    and `image`. Aside from `price` and `qty`, which are of types decimal and integer,
    all other attributes are of type string. Furthermore, `sku` and `url_key` are
    flagged as unique. This creates the `Entity/Product.php` and `Repository/ProductRepository.php`
    files within the `src/Foggyline/CatalogBundle/` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what we have done for the `Category view` templates, we need to
    do for the `Product view` templates. That is, copy them over from the `app/Resources/views/product/`
    directory to `src/Foggyline/CatalogBundle/Resources/views/Default/product/` and
    update all of the `$this->render` calls within our `ProductController` by appending
    the `FoggylineCatalogBundle:default: string` to each of the template paths.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we won''t rush updating the schema, as we want to add proper
    relations to our code. Each product should be able to have a relation to a single
    `Category` entity. To achieve this, we need to edit `Category.php` and `Product.php`
    from within the `src/Foggyline/CatalogBundle/Entity/` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We further need to edit the `Category.php` file by adding the `__toString`
    method implementation to it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we are doing so is that, later on, our Product-editing form would
    know what labels to list under the Category selection, otherwise the system would
    throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above changes in place, we can now run the schema update, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now take a look at our database, the `CREATE` command syntax for our
    `product` table looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see two unique keys and one foreign key restraint defined, as per the
    entries provided to our interactive entity generator. Now we are ready to generate
    the CRUD for our `Product` entity. To do so, we run the `generate:doctrine:crud`
    command and follow the interactive generator as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating entities](graphics/B05460_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Managing image uploads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, if we access either `/category/new/` or `/product/new/` URL,
    the image field is just a simple input text field, not the actual image upload
    we would like. To make it into an image upload field, we need to edit the `$image`
    property of `Category.php` and `Product.php` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we do so, the input fields turn into the file upload fields, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing image uploads](graphics/B05460_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will go ahead and implement the upload functionality into the forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do so by first defining the service that will handle the actual upload.
    Service is defined by adding the following entry into the `src/Foggyline/CatalogBundle/Resources/config/services.xml`
    file, under the `services` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `%foggyline_catalog_images_directory%` argument value is the name of a parameter
    the we will soon define.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create the `src/Foggyline/CatalogBundle/Service/ImageUploader.php`
    file with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create our own `parameters.yml` file within the `src/Foggyline/CatalogBundle/Resources/config`
    directory with content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the parameter our service expects to find. It can easily be overridden
    with the same entry under `app/config/parameters.yml` if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for our bundle to see the `parameters.yml` file, we still need to
    edit the `FoggylineCatalogExtension.php` file within the `src/Foggyline/CatalogBundle/DependencyInjection/
    directory`, by adding the following `loader` to the end of the `load` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our Symfony module is able to read its `parameters.yml`, thus
    making it possible for the defined service to pickup the proper value for its
    argument. All that is left is to adjust the code for our `new` and `edit` forms,
    attaching the upload functionality to them. Since both forms are the same, the
    following is a `Category` example that equally applies to the `Product` form as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Both the `new` and `edit` forms should now be able to handle file uploads.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding core module services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's go ahead and address the category menu and the on-sale items. Back
    when we were building the core module, we defined the global variables under the
    `twig:global` section of the `app/config/config.yml` file. These variables were
    pointing to services defined in the `app/config/services.yml` file. In order for
    us to change the content of the category menu and the on sale items, we need to
    override those services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by adding the following two service definitions under the `src/Foggyline/CatalogBundle/Resources/config/services.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both of the services accept the Doctrine ORM entity manager and router service
    arguments, as we will need to use those internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create the actual `Category` and `OnSale` service classes within the
    `src/Foggyline/CatalogBundle/Service/Menu/` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This alone won''t trigger the override of the core module services. Within
    the `src/Foggyline/CatalogBundle/DependencyInjection/Compiler/` directory we need
    to create an `OverrideServiceCompilerPass` class that implements the `CompilerPassInterface`.
    Within its process method, we can then change the definition of the service, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to edit the `build` method of the `src/Foggyline/CatalogBundle/FoggylineCatalogBundle.php`
    file in order to add this compiler pass as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now our `Category` and `OnSale` services should override the ones defined in
    the core module, thus providing the right values for the header **Category** menu
    and **On Sale** section of the homepage.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Category page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The auto-generated CRUD made a Category page for us with the layout as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Category page](graphics/B05460_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is significantly different from the Category page defined under [Chapter
    4](ch04.html "Chapter 4. Requirement Specification for a Modular Web Shop App"),
    *Requirement Specification for Modular Web Shop App*. We therefore need to make
    amends to our Category Show page, by modifying the `show.html.twig` file within
    the `src/Foggyline/CatalogBundle/Resources/views/Default/category/` directory.
    We do so by replacing the entire content of `body` block with code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The body is now sectioned into three areas. First, we are addressing the category
    title and description output. We are then fetching and looping through the list
    of products assigned to category, rendering each individual product. Finally,
    we are using the `is_granted` Twig extension to check if the current user role
    is `ROLE_ADMIN`, in which case we show the `Edit` and `Delete` links for the category.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Product page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The auto-generated CRUD made a Product page for us with the layout as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up a Product page](graphics/B05460_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This differs from the Product page defined under [Chapter 4](ch04.html "Chapter 4. Requirement
    Specification for a Modular Web Shop App"), *Requirement Specification for Modular
    Web Shop App*. To rectify the problem, we need to make amends to our Product Show
    page, by modifying the `show.html.twig` file within the `src/Foggyline/CatalogBundle/Resources/views/Default/product/`
    directory. We do so by replacing entire content of `body` block with code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The body is now sectioned into two main areas. First, we are addressing the
    product image, title, stock status, and add to cart output. The add to cart form
    uses the `add_to_cart_url` service to provide the right link. This service is
    defined under the core module and, at this point, only provides a dummy link.
    Later on, when we get to the checkout module, we will implement an override for
    this service and inject the right add to cart link. We then output the description
    section. Finally, we use the `is_granted` Twig extension, like we did on the Category
    example, to determine if the user can access the `Edit` and `Delete` links for
    a product.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have several class files that are not related to the controllers, meaning
    we can run unit tests against them. Still, we won't be going after a full code
    coverage as part of this book, rather focus on some of the little-big things,
    like using containers within our test classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start of by adding the following line under the `testsuites` element of
    our `phpunit.xml.dist` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, running the `phpunit` command from the root of our shop
    should pick up any test we have defined under the `src/Foggyline/CatalogBundle/Tests/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s go ahead and create a test for our Category service menu. We do
    so by creating an `src/Foggyline/CatalogBundle/Tests/Service/Menu/CategoryTest.php`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows the usage of the `setUp` and `tearDown` method calls,
    which are analogous in behavior to the PHP's `__construct` and `__destruct` methods.
    We use the `setUp` method to set the entity manager and router service that we
    can use through out the rest of the class. The `tearDown` method is merely a clean
    up. Now if we run the `phpunit` command, we should see our test being picked up
    and executed alongside other tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even target this class specifically by executing a `phpunit` command
    with the full class path, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Similarly to what we did for `CategoryTest`, we can go ahead and create `OnSaleTest`;
    the only difference between the two being the class name.
  prefs: []
  type: TYPE_NORMAL
- en: Functional testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The great thing about the auto-generate CRUD tool is that it generates even
    the functional tests for us. More specifically, in this case, it generated the
    `CategoryControllerTest.php` and `ProductControllerTest.php` files within the
    `src/Foggyline/CatalogBundle/Tests/Controller/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Auto-generated functional tests have a commented out methods within class body.
    This throws an error during the `phpunit` run. We need to at least define a dummy
    `test` method in them to allow `phpunit` to overlook them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look into these two files, we can see that they both have a single `testCompleteScenario`
    method defined, which is entirely commented out. Let''s go ahead and change the
    `CategoryControllerTest.php` content as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We started off by setting `PHP_AUTH_USER` and `PHP_AUTH_PW` as parameters for
    the `createClient` method. This is because our `/new` and `/edit` routes are protected
    by the core module security. These settings allow us to pass the basic HTTP authentication
    along the request. We then tested if the category listing page can be accessed
    and if its Create a new entry link can be clicked. Furthermore, both the `create`
    and `edit` forms were tested, along with their results.
  prefs: []
  type: TYPE_NORMAL
- en: All that remains is to repeat the approach we just used for `CategoryControllerTest.php`
    with `ProductControllerTest.php`. We simply need to change a few labels within
    the `ProductControllerTest` class file to match the `product` routes and expected
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Running the `phpunit` command now should successfully execute our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter we have built a miniature, but functional, catalog module.
    It allowed us to create, edit, and delete categories and products. By adding a
    few custom lines of code on top of the auto-generated CRUD, we were able to achieve
    image upload functionality for both categories and products. We also saw how to
    override the core module service, by simply removing the existing service definition
    and providing a new one. In regard to tests, we saw how we can pass the authentication
    along our requests to test for protected routes.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, in the next chapter, we will build a customer module.
  prefs: []
  type: TYPE_NORMAL
