- en: Chapter 10\. Routing and request handling in Nest.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Routing and request handling in Nest.js is handled by the controllers layer.
    Nest.js routes requests to handler methods, which are defined inside controller
    classes. Adding a routing decorator such as `@Get()` to a method in a controller
    tells Nest.js to create an endpoint for this route path and route every corresponding
    request to this handler.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll go over the various aspects of routing and request handling
    in Nest.js using the EntryController from our blog application as a basis for
    some examples. We’ll be looking at different approaches that you can use to write
    request handlers, so not all examples shown will match code from our blog application.
  prefs: []
  type: TYPE_NORMAL
- en: Request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A basic GET request handler for the `/entries` route registered in the EntryController
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Controller(''entries'')` decorator tells Nest.js to add an `entries`
    prefix to all routes registered in the class. This prefix is optional. An equivalent
    way to setup this route would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we don’t specify a prefix in the `@Controller()` decorator, but instead
    use the full route path in the `@Get('entries')` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, Nest.js will route all GET requests to `/entries` to the `index()`
    method in this controller. The array of entries returned from the handler will
    be **automatically** serialized to JSON and sent as the response body, and the
    response status code will be 200\. This is the standard approach of generating
    a response in Nest.js.
  prefs: []
  type: TYPE_NORMAL
- en: Nest.js also provides the `@Put()`, `@Delete()`, `@Patch()`, `@Options()`, and
    `@Head()` decorators to create handlers for other HTTP methods. The `@All()` decorator
    tells Nest.js to route all HTTP methods for a given route path to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Generating responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nest.js provides two approaches for generating responses.
  prefs: []
  type: TYPE_NORMAL
- en: Standard approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the standard and recommended approach, which has been available since
    Nest.js 4, Nest.js will **automatically** serialize the JavaScript object or array
    returned from the handler method to JSON and send it in the response body. If
    a string is returned, Nest.js will just send the string without serializing it
    to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default response status code is 200, expect for POST requests, which uses
    201\. The response code for can easily be changed for a handler method by using
    the `@HttpCode(...)` decorator. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Express approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternate approach to generating responses in Nest.js is to use a response
    object directly. You can ask Nest.js to inject a response object into a handler
    method using the `@Res()` decorator. Nest.js uses [express response objects](http://expressjs.com/en/api.html#res)].
  prefs: []
  type: TYPE_NORMAL
- en: You can rewrite the response handler seen earlier using a response object as
    shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The express response object is used directly to serialize the entries array
    to JSON and send a 200 status code response.
  prefs: []
  type: TYPE_NORMAL
- en: The typings for the `Response` object come from express. Add the `@types/express`
    package to your `devDependencies` in `package.json` to use these typings.
  prefs: []
  type: TYPE_NORMAL
- en: Route parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nest.js makes it easy to accept parameters from the route path. To do so, you
    simply specify route parameters in the path of the route as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The route path for the above handler method above is `/entries/:entryId`, with
    the `entries` portion coming from the controller router prefix and the `:entryId`
    parameter denoted by a colon. The `@Param()` decorator is used to inject the params
    object, which contains the parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: Alternately, you can inject individual param values using the `@Param()` decorator
    with the parameter named specified as shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Request body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access the body of a request, use the `@Body()` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Request object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To access the client request details, you can ask Nest.js to inject the request
    object into a handler using the `@Req()` decorator. Nest.js uses [express request
    objects](http://expressjs.com/en/api.html#req).
  prefs: []
  type: TYPE_NORMAL
- en: For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The typings for the `Request` object come from express. Add the `@types/express`
    package to your `devDependencies` in `package.json` to use these typings.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the examples shown so far in this chapter assume that handlers are synchronous.
    In a real application, many handlers will need to be asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: Nest.js provides a number of approaches to write asynchronous request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Async/await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nest.js has support for async request handler functions.
  prefs: []
  type: TYPE_NORMAL
- en: In our example application, the `entriesService.findAll()` function actually
    returns a `Promise<Entry[]>`. Using async and await, this function could be written
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Async functions have to return promises, but using the async/await pattern in
    modern JavaScript, the handler function can appear to be synchronous. Next, we’ll
    resolve the returned promise and generate the response.
  prefs: []
  type: TYPE_NORMAL
- en: Promise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similarly, you can also just return a promise from a handler function directly
    without using async/await.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nest.js request handlers can also return RxJS Observables.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if `entryService.findAll()` were to return an Observable of entries
    instead of a Promise, the following would be completely valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There is no recommended way to write asynchronous request handlers. Use whichever
    method you are most comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: Error responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nest.js has an exception layer, which is responsible for catching unhandled
    exceptions from request handlers and returning an appropriate response to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: A global exception filter handles all exception thrown from request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: HttpException
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an exception thrown from a request handler is a `HttpException`, the global
    exception filter will transform it to the a JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can throw an `HttpException` from the `create()` handler function
    if the body is not valid as shown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If this exception is thrown, the response would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can also completely override the response body by passing an object to the
    `HttpException` constructor as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If this exception is thrown, the response would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unrecognized exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the exception is not recognized, meaning it is not `HttpException` or a class
    that inherits from `HttpException`, then the client will receive the JSON response
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the help of using the EntryController from our example blog application,
    this chapter has covered aspects of routing and request handling in Nest.js. You
    should now understand various approaches that you can use to write request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we detail the OpenAPI specification, which is a JSON schema
    that can be used to construct a JSON or YAML definition of a set of restful APIs.
  prefs: []
  type: TYPE_NORMAL
