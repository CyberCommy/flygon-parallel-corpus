- en: Bash Parameter Substitution and Expansion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is dedicated to a special feature of Bash: parameter expansion.
    Parameter expansion allows us to do many interesting things with variables, which
    we will cover extensively.'
  prefs: []
  type: TYPE_NORMAL
- en: We will first discuss default values of variables, input checking, and variable
    length. In the second part of this chapter, we will look more closely at how we
    can manipulate variables. This includes replacing and removing patterns from text,
    modifying the case of variables, and using substrings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `export` and `dirname`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter expansion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter16](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter16).
    For this last regular chapter, your Ubuntu virtual machine should see you through
    once again.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter expansion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this second-to-last chapter, with the final chapter being tips and tricks,
    we will deal with a very cool feature of Bash: *parameter expansion*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin with a few notes on terminology. First of all, what''s considered
    *parameter expansion* in Bash deals with more than just parameters/arguments supplied
    to a script: all special operations we''ll be discussing in this chapter are applicable
    to Bash *variables*. In the official Bash manual page (`man bash`), these are
    all referred to as parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: For positional arguments to scripts, or even options with arguments, this makes
    sense. However, once we enter the territory of constants defined by the script
    creator, the distinction between a constant/variable and a parameter gets a bit
    muddy. This is of no further consequence; just remember that when you see the
    word *parameter* in a `man page`, it might be referring to variables in general.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, people tend to be a bit confused about the terms *parameter expansion*
    and *parameter substitution*, and you'll see these terms used interchangeably
    on the internet. In the official documentation, the word *substitution* is only
    used in *command substitution* and *process* *substitution*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command substitution is something we''ve discussed: it''s the `$(...)` syntax.
    Process substitution is pretty advanced and has not been described: if you ever
    come across `<(...)` syntax, you''re dealing with process substitution. We''ve
    included an article on process substitution in the *Further reading* section of
    this chapter, so be sure to give it a look.'
  prefs: []
  type: TYPE_NORMAL
- en: The confusion, we think, stems from the fact that *parameter substitution*,
    that is, the replacing of the variable name with its value at runtime, is considered
    only a small part of the greater *parameter expansion* in Bash. That is why you
    will see some articles or sources refer to all the great features of parameter
    expansion (default values, case manipulation, and pattern removal, to name a few)
    as parameter substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, just remember that these terms are often interchanged, and people are
    (probably) talking about the same thing. If you are ever in doubt yourself, we
    would advise opening up the Bash `man page` on any of your machines, and sticking
    with the official designation: *parameter expansion*.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter substitutions – recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it probably isn't necessary at this point for you, we'd like to quickly
    recap parameter substitutions so that we can place it within the greater context
    of parameter expansion.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we stated in the introduction, and as you''ve seen throughout this book,
    parameter substitution is nothing more than replacing a variable with its value
    at runtime. On the command line, this looks a little like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally in a recap you don''t learn any new things, but because we''re using
    this just for context we''ve managed to sneak some new stuff in here: the `export`
    command. `export` is a shell builtin (as found with `type -a export`), which we
    can read about using `help export` (which is the way to get information for all
    shell builtins).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t always need to use `export` when setting a variable value: in this
    instance, we could have also just used `word=Script`. Normally, when we set a
    variable, it is only available in our current shell. Any processes that run in
    a fork of our shell do not have that piece of the environment forked with them:
    they cannot see the value we have assigned to the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: While it is not always necessary, you might encounter the use of `export` when
    looking for answers online, so it is good to know what it does!
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the example should speak for itself. We assign a value to a variable,
    and we use parameter substitution at runtime (in this case, with an `echo`) to
    replace the variable name with the actual value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, will we show you why we advise you to *always* include the curly
    braces around your variable: it makes sure Bash knows where the name of the variable
    starts and ends. In the last `echo`, where we can forget to do this, we see that
    the variable is resolved incorrectly, and the text does not get printed correctly.
    While not necessary for all scripts, we think it looks better and is a good practice
    that you should always follow.'
  prefs: []
  type: TYPE_NORMAL
- en: As far as we're concerned, only what we've covered here falls under *parameter
    substitution*. All other features in this chapter are *parameter expansion*, and
    we will refer to them accordingly!
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On to parameter expansion! As we've hinted, Bash allows us to do many cool things
    directly with variables. We'll start with the seemingly simple example of defining
    a default value for your variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with user input, this makes both your life and the script user''s
    life much easier: as long as there is a reasonable default value, we can make
    sure that we use that instead of throwing an error when the user does not supply
    the information we want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will reuse one of our earliest scripts, `interactive.sh`, from [Chapter
    8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml), *Variables and User Input*. It
    was a very simple script that did not verify user input, and was thus prone to
    all sorts of problems. Let''s get it up-to-date and include our new default values
    for our parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just grabbing user input with `$1`, `$2` and `$3`, we will now create
    a more complicated syntax, defined by `man bash`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter:-word}
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Default Values.** If parameter is unset or null, the expansion of word
    is substituted. Otherwise, the value of parameter is substituted.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, you should read the word *parameter* as *variable* in this context (even
    though, when user-supplied, it is actually an argument to a parameter, but it
    could very well be a constant as well). With this syntax, if the variable is either
    not set or null (empty), the value supplied after the dash (called *word* in the
    `man page`) will be inserted instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve done this for all three parameters, so let''s check out how this works
    in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we do not supply any values to the script, all the defaults are inserted.
    If we supply three arguments, of which two are just empty strings (`''`), we can
    see that Bash will still substitute the defaults for us for the empty string.
    However, the actual string, `Amsterdam`, is correctly entered into the text, instead
    of **`Utrecht`.**
  prefs: []
  type: TYPE_NORMAL
- en: 'While dealing with empty strings in this manner is often desirable behavior,
    you can also write your scripts to allow for empty strings as a variable default.
    That looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a temporary copy to illustrate this functionality. When you
    remove the colon from the default declaration (`${1-word}` instead of `${1:-word}`),
    it no longer inserts the default for empty strings. It does, however, for values
    that are not set at all, as can be seen when we call it with `'' Amsterdam` instead
    of `'' Amsterdam ''`.
  prefs: []
  type: TYPE_NORMAL
- en: In our experience, in most cases, the default should ignore empty strings, so
    the syntax as presented in the `man page` is more desirable. If you have a niche
    case, though, you are now aware of this possibility!
  prefs: []
  type: TYPE_NORMAL
- en: 'For some of your scripts, you might find that just substituting a default is
    not enough: you''d rather have the variable set to a value that can then be evaluated
    with more granularity. This is also possible with parameter expansion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter:=word}
  prefs: []
  type: TYPE_NORMAL
- en: '**Assign Default Values.** If parameter is unset or null, the expansion of
    word is assigned to parameter. The value of parameter is then substituted. Positional
    parameters and special parameters may not be assigned to in this way.'
  prefs: []
  type: TYPE_NORMAL
- en: We've never seen the need to use this function, especially since it is not compatible
    with positional parameters (and as such, we only mention it here and do not go
    into detail). But, as with all things, it is good to be aware of the possibilities
    parameter expansion provides in this area.
  prefs: []
  type: TYPE_NORMAL
- en: Input checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Closely related to setting default values with parameter expansion, we can also
    use parameter expansion to display an error if a variable is null or empty. Up
    until now, we've done this by implementing if-then logic within our scripts. While
    this is an excellent and flexible solution, it is a little verbose—especially
    if the only thing you're interested in is the user supplying the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new version of our previous example: this one does not supply
    default values, but will alert the user if positional arguments are missing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter:?word}
  prefs: []
  type: TYPE_NORMAL
- en: '**Display Error if Null or Unset.** If parameter is null or unset, the expansion
    of word (or a message to that effect if word is not present) is written to the
    standard error and the shell, if it is not interactive, exits. Otherwise, the
    value of parameter is substituted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use this in our script, it might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note the colon again. In the same way the colon worked in the previous example,
    it also forces this parameter expansion to consider an empty string as a null/unset
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this script, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While this works like a charm, it doesn't really look that great, does it? The
    script name and line numbers are printed, which seems like a bit too much in-depth
    information for a user of the script.
  prefs: []
  type: TYPE_NORMAL
- en: It is up to you to decide if you think these are acceptable looking feedback
    messages to your users; personally, we think a nice if-then is often better, but
    with regards to concise scripting, this cannot be beaten.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another parameter expansion closely related to these: `${parameter:+word}`.
    This allows you to use *word* only if the parameter is NOT null or empty. In our
    experience, this isn''t a common occurrence, but for your scripting needs it might
    be; look for the words `Use Alternate Value` in `man bash` to get more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameter length
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve done a lot of checks in the book so far. One we haven''t carried out,
    however, is on the length of the supplied parameter. What will probably not surprise
    you at this point is how we can achieve this: with parameter expansion, of course.
    The syntax is really simple, too:'
  prefs: []
  type: TYPE_NORMAL
- en: ${#parameter}
  prefs: []
  type: TYPE_NORMAL
- en: Parameter length. The length in characters of the value of parameter is substituted.
    If parameter is * or @, the value substituted is the number of positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of printing `${variable}`, which will substitute the value at runtime,
    we will use `${#variable}`, which will give us a number: the number of characters
    in our value. This might be a little tricky, as things such as whitespaces can
    also be considered characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the word `hello` is identified as five characters; so far,
    so good. When we look at the sentence `hello there`, we can see two words of five
    letters each. While you might expect the parameter expansion to return `10`, it
    actually returns `11`. Since the words are separated by a space, you should not
    be surprised: this space is the 11th character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look back at the syntax definition from the `man bash` page, we''ll
    see the following interesting tidbit:'
  prefs: []
  type: TYPE_NORMAL
- en: If parameter is * or @, the value substituted is the number of positional parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Remember how we used `$#` to determine how many arguments are passed to the
    script in the rest of this book? This is actually Bash parameter expansion at
    work, as `${#*}` is equal to `$#!`
  prefs: []
  type: TYPE_NORMAL
- en: 'To drive these points home, let''s create a quick script that deals with three-letter
    acronyms (our personal favorite type of acronym). For now, the functionality of
    this script will be limited to verifying and printing the user input, but when
    we get to the end of this chapter, we''ll amend it a bit to make it even cooler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We did two interesting things in this script: we used the full syntax of `${#*}`
    to determine the number of arguments passed to our script, and we checked the
    acronym length with `${#acronym}`. Because we used two different checks, we used
    two different exit codes: `exit 1` for the wrong number of arguments, and `exit
    2` for incorrect acronym length.'
  prefs: []
  type: TYPE_NORMAL
- en: In larger, more complex scripts, using different exit codes might save you a
    significant amount of troubleshooting, so we've included it here for information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now run our script with different incorrect and correct input, we can
    see it works as planned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'No arguments, too many arguments, arguments of incorrect length: we''re equipped
    to handle everything the user might throw at us. As always, never expect the user
    to do what you hope, just ensure your script will only execute if the input is
    correct!'
  prefs: []
  type: TYPE_NORMAL
- en: Variable manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameter expansion in Bash deals with more than just default values, input
    checking, and parameter length. It actually also allows us to manipulate the variables
    before we use them. In this second part of this chapter, we'll explore the capabilities
    within parameter expansion that deal with *variable manipulation* (our terminology;
    as far as Bash is concerned, these are just normal parameter expansions).
  prefs: []
  type: TYPE_NORMAL
- en: We'll kick this off with *pattern substitution*, something you should be familiar
    with after our explanation of `sed` in [Chapter 10](d3b18cbd-f152-498a-b7b8-79da604e66b4.xhtml),
    *Regular Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Simply said, pattern substitution allows us to substitute a pattern with something
    else (who would have thought!). This is what we could already do with `sed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Initially, our `echo` contains the word `Hi`. We then pipe it through `sed`,
    in which we look for the *pattern* `Hi`, which we will *substitute* with `Bye`.
    The `s` at the front of the instruction to `sed` signals that we're searching
    and replacing.
  prefs: []
  type: TYPE_NORMAL
- en: Behold, after `sed` is done parsing the stream, we end up with `Bye` on our
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to do the same when using a variable, we have two options: we''ll
    either parse it through `sed` as we did previously, or we''ll turn to our new
    best friend for another great parameter expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter/pattern/string}
  prefs: []
  type: TYPE_NORMAL
- en: '**Pattern substitution.** The pattern is expanded to produce a pattern just
    as in pathname expansion. Parameter is expanded and the longest match of pattern
    against its value is replaced with string. If pattern begins with /, all matches
    of pattern are replaced with string.'
  prefs: []
  type: TYPE_NORMAL
- en: So, for the `${sentence}` variable, we could replace the first instance of a
    pattern with `${sentence/pattern/string}`, or all instances of the pattern with `${sentence//pattern/string}`
    (notice the extra forward slash).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the command line, it might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this is pretty self-explanatory and simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing to realize is that this parameter expansion doesn''t actually
    edit the value of the variable: it only affects the current substitution. If you
    wanted to do a permanent manipulation of the variable, you''d need to write the
    result to a variable again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if you''d prefer to keep the variable name after the mutation, you can
    assign the mutated value back to the variable in one go, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It should not be too difficult to imagine using this syntax in a script. As
    a simple example, we''ve created a little interactive quiz in which we''ll *help*
    the user if they happen to give the wrong answer to our very non-opinionated question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this script, if the user is temporarily *confused* and does not give the
    wanted answer, we'll simply replace their *wrong* answer (`zsh`) with the *correct*
    answer, `bash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All jokes aside, other shells such as `zsh`, `ksh`, and even the newer fish
    have their own unique selling points and strengths that makes some users prefer
    them over Bash for daily work. This is obviously great, and a big part of the
    mentality of using Linux: you have the freedom to choose whichever software you
    prefer!'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to scripting, however, we are (obviously) of the opinion that
    Bash is still the king of shells, if only for the very simple reason that it has
    become the de facto shell for most distributions. This is very helpful when it
    comes to portability and interoperability, qualities that are often beneficial
    for scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern removal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A topic closely related to pattern substitution is *pattern removal*. Let's
    face it, pattern removal is basically the same as replacing a pattern with nothing.
  prefs: []
  type: TYPE_NORMAL
- en: If pattern removal had exactly the same functionality as pattern substitution,
    we would not need it. However, pattern removal has a few cool tricks that would
    be difficult or even impossible to do with pattern substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern removal has two options: removing matched pattern *prefixes* or *suffixes*.
    In simpler words, it allows you to remove stuff either from the beginning or the
    end. It also has an option to stop after the first matched pattern, or to continue
    up until the last.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without a good example, this might be a bit too abstract (it definitely was
    for us the first time we encountered this). However, there is an excellent example
    here: it all has to do with files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created a variable that contains a reference to a file. If we wanted
    the directory, or the file without the directory, we could use either `basename`
    or `dirname`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also achieve this with parameter expansions. The syntax for prefix
    and suffix removal is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter#word}
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter##word}
  prefs: []
  type: TYPE_NORMAL
- en: '**Remove matching prefix pattern.** ${parameter%word}${parameter%%word} **Remove
    matching suffix pattern.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `${file}` variable, we can use parameter expansion to remove all directories
    and only keep the filename, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between the first and second command is minimal: we''re using
    the asterisk wildcard that can match on anything, zero or more times. In this
    case, since the value of the variable starts with a forward slash, it does not
    match. However, as soon as we get to the third command, we see the need to include
    it: we need to match *everything we want to delete*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `*/` pattern matches on `/tmp/`, whereas the `/` pattern only
    matches on the first forward slash (as the result of the third command clearly
    shows).
  prefs: []
  type: TYPE_NORMAL
- en: It is good to remember that in this instance, we're merely using parameter expansion
    to replace the functionality of the `basename` command. However, if we were not
    dealing with file references, but (for example) underscore delimited files, we
    could not achieve this with `basename`, and parameter expansion would come in
    quite handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen what we can do with prefixes, let''s look at suffixes.
    The functionality is of the same order, but instead of parsing from the start
    of a value, we''re now looking at the end of the value first. We could use this,
    for example, to remove the extension from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to grab the filename, without the extension. This might be desirable
    if there is some logic in your script that can be applied to this part of the
    file. In our experience, this is more common than you think!
  prefs: []
  type: TYPE_NORMAL
- en: For example, you might imagine backups that have a date in the filename that
    you'd like to compare to today's date, to ensure a backup was successful. A little
    bit of parameter expansion can get you to your desired format, so the comparison
    of dates is then trivial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we were able to replace the `basename` command, we can do the reverse
    with suffix pattern removal to find the `dirname`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, these examples mostly serve for educational purposes. There are many
    situations in which this could be useful; since these are very diverse, it is
    hard to give an example that is interesting for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation we introduced regarding backups, however, might be relevant for
    you. As a basic script, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To illustrate this, we're touching dummy backup files. For a real situation,
    you'd be more likely to pick up the newest file in a directory (with `ls -ltr
    /backups/ | awk '{print $9}' | tail -1`, for example) and compare that to the
    current date.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with most things in Bash scripting, there are other ways to accomplish this
    date checking. You could argue that we could leave the extension in the file variable
    and use a regular expression that parses the date: that would work just as well,
    with pretty much the same amount of work.'
  prefs: []
  type: TYPE_NORMAL
- en: The takeaway from this example (and the whole book, really) should be to use
    something *that works for you and your organization*, as long as you've built
    it in a robust manner and added the necessary comments for everyone to understand
    what you did!
  prefs: []
  type: TYPE_NORMAL
- en: Case modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up is another parameter expansion we''ve already briefly seen: *case modification.*
    In this instance, case refers to lowercase and uppercase letters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `yes-no-optimized.sh` script we originally created in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml),
    *Error Checking and Handling*, we had the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, the `,,` and `^^` found within the curly braces of the
    variable are the parameter expansions we're talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax, as found on `man bash`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter^pattern}
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter^^pattern}
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter,pattern}
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter,,pattern}
  prefs: []
  type: TYPE_NORMAL
- en: '**Case modification.** This expansion modifies the case of alphabetic characters
    in parameter. The pattern is expanded to produce a pattern just as in pathname
    expansion. Each character in the expanded value of parameter is tested against
    pattern, and, if it matches the pattern, its case is converted. The pattern should
    not attempt to match more than one character.'
  prefs: []
  type: TYPE_NORMAL
- en: In our first script, we haven't used a pattern. When not using a pattern, it
    is implied that the pattern is a wildcard (in this case, the `?`), which means
    everything matches.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick command-line example of both lowercase and uppercase modification should
    clear this up. First, let''s take a look at how we can uppercase a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If we use a single caret (`^`), we can see that the first letter of our variables'
    value will be uppercased. If we use a double caret, `^^`, we now have the full
    value in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, commas do the same thing for lowercasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we can choose to uppercase or lowercase the entire value, we can now
    much more easily compare user input to a predefined value. Regardless of whether
    the user inputs `YES`, `Yes`, or `yes`, we can verify all these situations with
    a single check: `${input,,} == ''yes''`.'
  prefs: []
  type: TYPE_NORMAL
- en: This gives the user fewer headaches, and a happy user is what we want (remember,
    you are often the user of your own scripts, and you deserve happiness!).
  prefs: []
  type: TYPE_NORMAL
- en: Now, for the *pattern*, as the `man page` specifies it. In our personal experience,
    we have not had to use this option yet, but it is powerful and flexible, so it
    never hurts to get a little bit more explanation on this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, the case modification will only be performed if the pattern matches.
    It can get a little tricky, but you can see how it works here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command we run, `${animal^a}`, only uppercases the first letter if
    it matches the pattern: `a`. Since the first letter is actually an `s`, the entire
    word is printed as lowercase.'
  prefs: []
  type: TYPE_NORMAL
- en: For the next command, `${animal^^a}`, *all matching letters* are uppercased.
    So, all three instances of `a` in the word `salamander` are given in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the third command, we try to add an extra letter to the pattern. Since this
    is not the correct way of doing this, the parameter expansion is (likely) trying
    to find a single letter to match two letters in the pattern. Spoiler alert: this
    is very much impossible. As soon as we bring some of our regular expression expertise
    in the mix, we can do what we want: by using `[ae]`, we''re specifying that both
    `a` and `e` are valid targets for the case modification operation.'
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the animal returned is now `sAlAmAndEr`, with all vowels uppercased
    using a custom pattern in combination with the case modification parameter expansion!
  prefs: []
  type: TYPE_NORMAL
- en: As a little bonus, we'd like to share a case modification that is not even present
    on the `man bash` page! It is not that complicated, either. If you replace either
    `,` or `^` with a tilde, `~`, you will get a *case reversal*. As you might expect,
    a single tilde will operate only on the first letter (if it matches the pattern,
    if specified), while a double tilde will match on all instances of the pattern
    (or everything, if no pattern is specified and the default `?` is used).
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This should be a sufficient explanation of case modification, as all syntaxes
    are similar and predictable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to lowercase, uppercase, and even reverse the case of
    your variables, you should be able to mutate them in any way you like, especially
    if you add a pattern into the mix, this parameter expansion provides many possibilities!
  prefs: []
  type: TYPE_NORMAL
- en: Substring expansion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Only a single topic with regards to parameter expansion remains: substring
    expansion. While you might have heard of a substring, it could also be a very
    complex-sounding term.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, it is actually *really really* simple. If we take a string, such
    as *Today is a great day*, then any part of that sentence that is in the correct
    order but not the full sentence can be considered a substring of the full string.
    Examples of this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Today is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a great day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: day is a gre
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Today is a great da
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: o
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (<- there is a space here, you just can't see it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see from these examples, we''re not looking at the semantic meaning
    of the sentence, but simply at the characters: any number of characters in the
    correct order can be considered a substring. This includes the entire sentence
    minus one letter, but also includes just a single letter, or even a single space
    character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s look at the syntax for this parameter expansion one last time:'
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter:offset}
  prefs: []
  type: TYPE_NORMAL
- en: ${parameter:offset:length}
  prefs: []
  type: TYPE_NORMAL
- en: '**Substring Expansion.** Expands to up to length characters of the value of
    parameter starting at the character specified by offset.'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we specify where we should start our substring, and what length (in
    characters) it should have. As with most things computers, the first character
    will be considered a `0` (and not a `1`, as any non-technical person might expect).
    If we omit the length, we will get everything after the offset; if we do specify
    it, we get exactly that number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this would work for our sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In our command-line example, we first create the `${sentence}` variable containing
    our previously-given text. First, we `echo` it fully, before we use `${sentence:0:5}`
    to only print the first five characters (remember, strings start at 0!).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we print the first six characters, starting from the second character
    (as denoted by the `:1:6` notation). In the final command, `echo ${sentence:11}`
    shows that we can also use substring expansion without specifying a length. In
    this case, Bash will simply print everything from the offset until it reaches
    the end of the variable's value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like to end this chapter with a promise we made earlier: our three-letter
    acronym script. Now that we know how to easily extract separate letters from the
    user input, it would be fun to create a chant!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revise the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We threw in a few case modifications in there for good measure. After we split
    the letters using substring expansion, we cannot be sure of the casing the user
    has presented us with. Since this is a chant, we'll assume that uppercase is a
    not a bad idea, and we'll uppercase everything.
  prefs: []
  type: TYPE_NORMAL
- en: For the single letter, a single caret will do the trick. For the full acronym,
    we use double carets so that all three characters are uppercase. Using the substring
    expansions of `${acronym:0:1}`, `${acronym:1:1}` and `${acronym:2:1}`, we are
    able to get single letters (because the *length* is always 1, but the offset is
    different).
  prefs: []
  type: TYPE_NORMAL
- en: For the ever-important readability, we assign these letters to their own variables
    before using them. We could have also used `${acronym:0:1}` directly in the `echo`,
    but since this script isn't too long, we have chosen the more verbose option of
    extra variables, in which the names give away what we achieve with the substring
    expansion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s run this last script and enjoy our personal chant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Mixed-case, lowercase, uppercase, it does not matter: whatever the user inputs,
    as long as it is three characters, our chant will work just fine. Good stuff!
    Who knew substring expansion could be so convenient?'
  prefs: []
  type: TYPE_NORMAL
- en: One very advanced parameter expansion feature is so-called *parameter transformation*.
    Its syntax, `${parameter@operator}`, allows some complex operators to be performed
    on the parameter. To get an idea of what this can do, head over to `man bash`
    and look for Parameter transformation. You'll probably never need it, but the
    functionality is really cool, so it is definitely worth a look!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed everything parameter expansion in Bash. We
    started by recapping how we've used parameter substitution throughout most of
    this book, and how parameter substitution is only a small part of Bash parameter
    expansion.
  prefs: []
  type: TYPE_NORMAL
- en: We moved on to show you how we can use parameter expansion to include default
    values for variables, in case the user does not supply their own. This functionality
    also allows us to present the user with an error message if input is missing,
    although not in the cleanest way.
  prefs: []
  type: TYPE_NORMAL
- en: We ended this introduction to parameter expansion by showing you how we could
    use this to determine the length of variable values, and we showed you how we've
    actually used that extensively in the book already, in the form of the `$#` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We continued with describing parameter expansions under the heading of *Variable
    manipulation*. This includes the functionality of *pattern substitution*, which
    allows us to replace a part of the variable's value (the *pattern*) with another
    string. In very similar functionality, *pattern removal* allows us to remove some
    of the value that matches a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we showed you how we can manipulate characters from lowercase to uppercase,
    and vice versa. This functionality was already mentioned earlier in this book,
    but we have now explained it in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter with *substring expansion*, which allows us to take parts
    of variables from an *offset* and/or with a specified *length.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `export` and `dirname`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is parameter substitution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we include default values for our defined variables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use parameter expansion to handle missing parameter values?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does `${#*}` do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does pattern substitution work when talking about parameter expansions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is pattern removal related to pattern substitution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What types of case modifications can we perform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which two things can we use to get a substring from a variable's value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links for more information on the topics in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TLDP on process substitution**: [http://www.tldp.org/LDP/abs/html/process-sub.html](http://www.tldp.org/LDP/abs/html/process-sub.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TLDP on parameter substitution**: [https://www.tldp.org/LDP/abs/html/parameter-substitution.html](https://www.tldp.org/LDP/abs/html/parameter-substitution.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU on parameter expansion**: [https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
