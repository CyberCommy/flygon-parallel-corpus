- en: Reverse Engineering Linux Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reverse engineering, as we already know, is the process of taking an executable
    program and obtaining its source or machine-level code to see how the tool was
    built and to potentially exploit vulnerabilities. The vulnerabilities in the context
    of reverse engineering are typically software bugs that the programmers deal with
    when they are found by development and security researchers. In this chapter,
    we will look at how we can perform reverse engineering with Linux applications.
    We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing Linux applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux and assembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux and stack buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux and heap buffer overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting string bugs in Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The usual approach to understanding the behavior of an executable program is
    to attach it to a debugger and to set break points at various locations to interpret
    the code flow of the software under test. A **debugger**, as the name suggests,
    is a software utility or a computer program that can be used by programmers to
    debug their programs or software. It also lets programmers see the assembly of
    the code that is being executed. A debugger is capable of displaying the exact
    stack on which the code is executed. A debugger is capable of displaying the assembly
    level equivalent of the high-level programming language code written. Thus, a
    debugger shows the execution flow of the program in terms of execution stack for
    function calls, registers, and their addresses/values for program variables, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the debuggers that we are going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Evans Linux debugger: This is a native Linux debugger, and we don''t need
    wine to run it; it comes in a `tar.gz` file. Download the source code, extract
    it, and copy it to your computer. The installation steps required are shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Either add this to the environment variable path or go to the installation
    directory and run `./edb` to launch the debugger. This will give us the following
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f9d37c5-cd50-4c93-ab78-5890ac2a424c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s open the `edb exe/linux` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95d1fae1-ceb2-49cd-9d86-b87d6fd0d2b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'GDB/GNU debugger: This is a very old debugger and is commonly found by default
    in Ubuntu. It is a nice debugger but doesn''t have many features. To run it, simply
    type `gdb` and its prompt will open. It is, by default, a CLI tool:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/6d8fb033-ae3f-40f8-9e03-484bf219ae27.png)'
  prefs: []
  type: TYPE_IMG
- en: Another good tool is idea-pro, but this is a commercial tool and is not free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing Linux applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fuzzing** is a technique used to discover bugs in an application that make
    the application crash when presented with input that was not anticipated by the
    application. Fuzzing typically involves the use of automated tools or scripts
    that send large strings to an application that would cause an application to break. The
    idea behind fuzzing is to discover vulnerabilities or bugs that, if found, could
    lead to catastrophic consequences. These vulnerabilities could belong to either
    the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Buffer overflow vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String format vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing is the technique of sending randomly generated code to our test program
    with the intention of crashing it or seeing how it might behave on different inputs. Fuzzing
    is an automated way of sending payloads of different lengths to the program that
    is being tested, to see whether the program behaves strangely or unexpectedly
    at any point. If any exception conditions are observed during fuzzing, the payload
    length that caused the program to behave unexpectedly is marked. This helps the
    tester to further evaluate whether there is a possibility of exploitation. Put
    simply, fuzzing forms the first step of detecting whether there is a potential
    vulnerability of type overflow in the application being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'An effective fuzzer generates semi-valid inputs that are **valid enough** in
    that they are not directly rejected by the parser, but that create unexpected
    behaviors deeper in the program and are **invalid enough** to expose corner cases
    that have not been properly dealt with. One tool that we can use for fuzzing is
    **Zzuf**. This is a very nice fuzzing tool that can be used with Linux-based systems.
    The installation steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download Zzuf from the GitHub source and install it manually using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, however, we will focus on carrying out fuzzing with our native Python
    code. To understand how fuzzing can be done, let's take an example of a sample
    C code, which takes an input from the user, but does not perform the necessary
    checks on the input passed.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a basic code written in C, that takes a user input and displays
    it on the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table explains the fields used in the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `int fildes` | The file descriptor of where to read the input. You can either
    use a file descriptor obtained from the open ([http://codewiki.wikidot.com/c:system-calls:open](http://codewiki.wikidot.com/c:system-calls:open))
    system call, or you can use 0, 1, or 2, to refer to standard input, standard output,
    or standard error, respectively. |'
  prefs: []
  type: TYPE_TB
- en: '| `const void *buf` | A character array where the read content is stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `size_t nbytes` | The number of bytes to read before truncating the data.
    If the data to be read is smaller than *n* bytes, all data is saved in the buffer.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `return value` | Returns the number of bytes that were read. If the value
    is negative, then the system call returns an error. |'
  prefs: []
  type: TYPE_TB
- en: We can see that this simple program attempts to read from the console (specified
    by the 0 value of the file descriptor), and whatever it reads from the console
    window, it attempts to place in the locally created array variable called `arr`.
    Now `arr` acts as a buffer in this code with a maximum size of 400\. We know that
    a character datatype in C can hold 1 byte, which means that as long as our input
    is <=400 characters, the code should work fine, but if the input given is more
    than 400 characters, we may encounter an overflow or a segmentation fault, as
    we would be attempting to save more than the buffer `arr` can potentially hold.
    Looking at the preceding code, we can see straight away that more than 400 bytes
    of input will break the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we didn''t have access to the source code of the application. Then,
    for us to figure out the size of the buffer, we have the following three options:'
  prefs: []
  type: TYPE_NORMAL
- en: The first option is to reverse engineer it to see the mnemonics or assembly
    level code of the application. Who wants to do that!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many modern day decompilers also give us a source code equivalent of the original
    application. For a small example like ours, this would be a good choice, but if
    the executable in question is thousands of lines of code, we might want to avoid
    this option as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third and generally preferred approach is to take the application as a black
    box and identify the places where it expects the user to specify an input. These
    would be our injection points in which we would specify strings of varying lengths
    to see if the program crashes and, if it does, where this would happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's compile our source code to generate the object file of C that we shall
    run and fuzz as a black box.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Linux systems are safe and they come with all sort of protection
    against buffer overflows. For this reason, while compiling the source code, we
    will disable the inbuilt protections as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command would produce the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9887237f-aa44-4959-956c-e0e9c9992f3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run our object file in a single line by piping the output of `echo`
    command to it. This will be automated using Python and fuzzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df6c9fe1-2555-487b-89bc-9d25ce8f7319.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that `./buff` is our out-file that can be executed as an executable.
    Let''s assume that we know the actual source code of the file to see how we can
    use Python to fuzz the file. Let''s create a basic Python-fuzzing script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea636bd1-bfa9-453c-8eae-f8bdae7babb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s run the preceding Python code to see how and what effects fuzzing has
    and how would it break the application to get us close to the crash point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8abd591b-7729-4753-8373-a1c64d3f3219.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen from the previous output, the point where the application crashes
    is somewhere between 400 and 500 bytes, which is where the actual crash lies.
    To be more precise, we can use a smaller step size for `i` and arrive at the following
    with a `step size=10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df3931d1-4420-4f51-8cc8-709bfb63a3bd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot gives us more granular information and tells us that
    the application crashes at an input length between `411` and `421`.
  prefs: []
  type: TYPE_NORMAL
- en: Linux and assembly code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will read about the assembly language. The objective is
    to take a C code, translate it to an assembly, and see the proceedings. The sample
    C code that we will be loading and using is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6254c14b-e991-49da-a77d-7377d3038bfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now run this program from the command line as `./buff` and try to attach
    this executable program to the Evans debugger as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54679166-b600-4abd-b641-2a132e7c9e66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We now attach our running code to the launched Evans debugger from the GUI
    by going to the **File** | **Attach** option. We attach the executable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a4876cf-56d3-4cfe-b014-f18903173f8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click on **OK**, the object file will be attached to the debugger and
    we will be able to see the associated assembly level code with it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90514aff-7754-4012-9722-f5048cc18342.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The top-right section of the window displays the assembly code of the application
    under test. The top-left section represents the registers and their corresponding
    contents. The section just below the assembly code displays the method that will
    be invoked when the user inputs the data on the console, which is our read-system
    call. The section at the bottom of the screen represents the memory dump, wherein
    the contents of the memory is displayed both in Hexadecimal and ASCII format.
    Let''s see how the application cleanly exists when we specify a value that is
    less than 400 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2baf991-ee01-4e9a-acf0-7b30a77e9089.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s input a value that is greater than 400 bytes and see what happens
    to our registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2d73e0d-8a0e-4cb2-aae5-75e1680fe732.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we pass this input, we arrive at the following state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6fdf4144-5758-4963-99e7-a355341bac30.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be seen in the preceding screenshot that the value we passed gets written
    in the register RSP. For a 64-bit architecture, the register RSP holds the address
    of the next instruction to be executed and, as the value overflowed from the `arr` buffer,
    some was written to the register RSP. The program fetched the contents of RSP
    to go to the next instruction that it was meant to execute and since it arrived
    to `aaaaaaaaaa`, it crashed, as this is an invalid address. It should be noted
    that `0X6161616161`, as shown in the previous screenshot, is the hexadecimal equivalent
    of `aaaaaaaaaa`.
  prefs: []
  type: TYPE_NORMAL
- en: Stack buffer overflow in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most vulnerabilities are flaws that arise due to conditions that the developer
    hasn't thought of. The most common vulnerability is a stack buffer overflow. This
    means that we define some sort of buffer that is not large enough for the storage
    we require. This is more of a problem when the input is controlled by the end-level
    user because this means it can be exploited.
  prefs: []
  type: TYPE_NORMAL
- en: In software, a stack buffer overflow or stack buffer overrun occurs when a program
    writes to a memory address on the program's call stack (as we know, every function
    has its own execution stack or is allocated a stack memory where it is executed)
    outside the intended data structure, which is usually a fixed-length buffer. A
    stack buffer overflow almost always results in the corruption of the adjacent
    data on the stack, and in cases where the overflow was triggered by mistake, this
    will often cause the program to crash or operate incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we have a memory cell `a` that can hold two bytes of data
    and that next to this memory cell `a` we have another memory cell `b` that can
    also hold two bytes of data. Let's also assume that both of these memory cells
    are placed on a stack adjacent to each other. If `a` is given more than two bytes
    of data, the data will actually spill over and it will be written to `b` instead,
    which was not expected by the programmer. Buffer overflow exploits capitalize
    on this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instruction stack pointer is the pointer that points toward the address
    of the next instruction to be executed. Thus, whenever any instruction is executed,
    the contents of the IP gets updated. When a method is called and the activation
    record for that method is created, the following steps are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: An activation record or stack frame is created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Current Instruction Pointer** (**CIP**) and the **Current Environment
    Pointer** (**CEP**) (from the caller) are saved on the stack frame as a return
    point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CEP is assigned the address of the stack frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CIP is assigned the address of the first instruction in the code segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The execution continues from the address in the CIP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a stack has finished its execution and there are no more instructions
    or commands left in the stack to get executed, the following steps are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: The old values of the CIP and the CEP are retrieved from the return point location
    of the stack frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the value of CEP, we jump back to the caller function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the value of CIP, we resume processing from the last instruction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the stack looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f01fc8c9-2445-4fb3-b2d7-eb1e16643d52.png)'
  prefs: []
  type: TYPE_IMG
- en: It can now be seen that the return address lies at the bottom of the stack and
    that it actually contains the value of the old CEP. We call it a stack frame pointer.
    In technical terms, when the value of a buffer is overwritten and spilled, it
    completely fills up all the memory associated to a local variable space of the
    stack and then gets written to the return address portion of the stack and causes
    a buffer overflow. When all the memory space is occupied on the buffer, by convention,
    the contents of the return point is fetched to make the jump back to the caller.
    Since the address is overwritten by the data passed on from the user, however,
    this results in an invalid memory location, therefore causing a segmentation fault.
  prefs: []
  type: TYPE_NORMAL
- en: This is where things get interesting. It should be noted that the data that
    the user passes and the local variables of the stack are actually implemented
    as registers, and thus the value we would pass would get stored in certain registers
    on the stack. Now, since whatever input the user is passing is getting written
    to certain registers and finally to the return point, what if we are able to inject
    shell code in a register `X` at a location `12345`? Since we are able to write
    to the return point of the stack, what if we write `12345` at the return point?
    This will result in the control being transferred to location `12345`, which would
    in turn result in the execution of our shell code. This is how buffer overflows
    can be exploited to grant us the shell of the victim's machine. Now that we have
    a better understanding of buffer overflow, let's see it in action in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting a buffer overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take the following piece of code, which is vulnerable to buffer-overflow. Let's
    see how we can fuzz and exploit the vulnerability to get shell access to the system.
    We studied how to use Evans debugger in the earlier section. In this section,
    we will see how can we use `gdb` to exploit buffer overflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is given a simple code snippet written in C that asks the user
    for their name. Based upon the supplied value from the Terminal, it greets the
    user with the greeting message `Hey <username>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c973b3c-d6bf-4ece-b71c-c83fa4fc9cd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s compile the application by disabling the stack protection using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create an object file called `bufferoverflow`, which can be run as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f051243-424d-40ca-929f-a277d0f85b06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the next step for us is to generate a payload that will cause the application
    to break. We can use Python to do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create a text file with 500 *A*s in it. Let''s give
    this as an input to our code and see whether it breaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/babc924e-32f8-42d2-b7fc-32a886226d94.png)'
  prefs: []
  type: TYPE_IMG
- en: As we learned earlier, the computer manages the stack through *registers*. Registers
    act as a dedicated place in memory, where data is stored while its worked on.
    Most registers temporarily store values for processing. In a 64-bit architecture,
    the **Register Stack Pointer** (**RSP**) and the **Register Base Pointer** (**RBP**) are
    especially important.
  prefs: []
  type: TYPE_NORMAL
- en: The program remembers its place in the stack with the RSP register. The RSP
    register will move up or down, depending on whether tasks are added or removed
    from the stack. The RBP register is used to remember where the end of the stack
    resides.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the RSP register will instruct the program from where to continue
    the execution. This includes jumping into a function, out of a function, and so
    on. This is why an attacker's goal is to obtain control of where the RSP directs
    a program’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try to run the same code with `gdb` to find the value of the register
    RSP when the crash happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b41f48fb-c6ac-4169-8461-b1e1925510c9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen, we simply issue the `run` command and pass it in the created
    input file, which results in the program crashing. Let''s try to understand the
    status of all the registers at the time of the crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c3414f4-c4ca-4a55-9655-41395fb3f479.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The two columns displayed by the info registers tell us about the addresses
    of the registers in hex and decimal format. We know that the register of interest
    here is RSP as RSP will hold the address of the next instruction to be executred,and
    since it got corrupted and was over written by string of A''s it caused the crash.
    Let''s check the contents of the RSP at the time of the crash. Let''s also check
    the contents of other registers to see where all our input string of `aaaaa` is
    written. The reason we are checking the other registers is to determine the register
    in which we can place our payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9f906cf-df0d-4eee-945b-21c20484d401.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the preceding screenshot, we can validate that the input string aaaa,
    whose hexadecimal equivalent is `0x414141` is placed in the RSP, causing a crash.
    Interestingly, we also see that the string is placed inside registers `r9` and
    `r11`, making them potential candidates for our exploit code. But before getting
    there, we need to figure out at what point in our input of 500 characters was
    the buffer RSP overwritten. If we get the exact location of that offset, we will
    devise our payload to put a jump instruction at that offset, and we will try to
    make a jump to either register `r9` or `r11`, where we will place our shell code.
    For us to figure out the exact offset, we will generate a unique combination of
    characters with the help of a Metasploit Ruby module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0d20d71-f944-4adb-a3a0-d7eb0a34181b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, since we placed this uniquely generated string in a file called `unique`,
    lets re-run the application, this time passing this `unique` file contents to
    the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be6e3c5f-0ba1-4c2e-b860-065a20121d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, at this point, the contents of the register RSP is`0x6f41316f`, which is
    in hex. The ASCII equivalent is `o1Ao`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the contents of the register RSP is in little endian format, we actually
    need to convert `0x6f31416f` to its ASCII equivalent.It must be noted that IBM's
    370 mainframes, most [RISC](https://search400.techtarget.com/definition/RISC)-based
    computers, and Motorola microprocessors use the big-endian approach.On the other
    hand, Intel [processor](https://whatis.techtarget.com/definition/processor)s (CPUs)
    and DEC Alphas and at least some programs that run on them are little-endian
  prefs: []
  type: TYPE_NORMAL
- en: 'We will again use a Metasploit Ruby module to get the offset of this unique
    value to find the exact location of our payload. After this, we should have the
    jump instruction placed to make the RSP jump to the location of our choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a1b3edf-db63-4d94-a537-46e7e3849b43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, we know that the next eight bytes of whatever we write after address
    `424` are going to be written to our rsp register. Let''s try to write `bbbb` and
    see if this is the case. The payload we generate will be as follows: `424*a +
    4*b + 72*c`. The exact command to use is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, given that we have verified that we can control the register RSP, let''s
    try to attack the r9 register, to hold our shell code. But before doing that,
    it''s important for us to know the location of the r9 register. In the following
    screenshot, we can see that the r9 register has a memory location of `0x7fffffffded0`,
    but this keeps changing every time the program reloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/858efe7d-0f3e-47f7-8aae-6487e4ed1e46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two ways to get around this. The first method is to avoid dynamic
    address change by disabling it at the OS level, which can be seen in the following
    screenshot. The other way is to find the address of any instruction that has the `jmp
    r9` command**. **We can search for `jmp r9` throughout the assembly code of our
    program and then place the address of the location inside our register RSP, thus
    avoiding dynamic address change. I will leave that as an exercise for you to figure
    out and do by yourself. For this section, let''s disable dynamic address loading
    by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f236b2f1-2a66-4009-8a3b-4b4158a2a706.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, since we are working on a Kali machine, let''s generate a reverse shell
    payload that will be placed in our final exploit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In order to figure out the common bad characters for the underlying software
    being tested, the most successful method is trial and error. What i usually do
    to figure out the common bad characters , is to send all unique characters to
    the application, and then using the debugger, we check what characters are changed
    at register level. The ones that get changed can be encoded and avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command would produce the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb23632-599f-497d-8950-83e4e61d739f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a Python file called `exp_buf.py` and place the obtained shell
    code in that file. It must be noted that since we are encoding the payload, we
    will also need a few bytes in the beginning for it to get decoded, so we will
    specify a few `nop` characters in the beginning. We will also set up a netcat
    listener on port `4444` to see whether we get a reverse shell from the application.
    Remember the address of the r9 register; we will be using that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7977e329-ec66-4112-a0ff-edd3d041a37b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding Python code prints the payload that will be required to get us
    the reverse shell by penetrating through the vulnerable buffer overflow code we
    created. Let''s go and input this payload in a file called `buf_exp`, which we
    will be using with `edb` to exploit the code. Type in the following command to
    run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now set up a netcat listener on port 4444 that will listen to the reverse
    payload, which will in turn give us the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the application with `gdb` and try to exploit it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f4d655a-e0ea-4c19-975d-a0b0206014c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Bingo! The code has successfully spawned a new shell process. Let''s check
    what our netcat listener has obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1832b93-bb79-428e-9643-6972f73c6c24.png)'
  prefs: []
  type: TYPE_IMG
- en: It can therefore be verified that we were able to successfully create a reverse
    shell using Python and `gdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Heap buffer overflow in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be noted that the scope of the variable, buffer, or storage that caused
    stack buffer overflow is confined to the function where it is declared (the local
    variable) and its scope is within the function. Since we know that functions are
    executed over a stack, this flaw causes the stack buffer to overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a heap buffer overflow, the impact is a little greater, as the
    variable that we are trying to exploit does not live on a stack but instead on
    a heap. All the program variables that are declared within the same method are
    given memory within the stack. The variables that are dynamically allocated memory
    during run time, however, can''t be placed in the stack and are placed instead
    in a heap. Thus, when a program assigns memory to a variable at run time through
    `malloc` or `calloc` calls, it actually assigns them memory over the heap, and
    in a heap buffer overflow situation, this memory is caused to overflow or exploit.
    Let''s take a look at how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1add16a5-8404-440a-8a38-665749741721.png)'
  prefs: []
  type: TYPE_IMG
- en: Now go ahead and compile the code by disabling the inbuilt protection as shown.
    Note `-fno-stack-protector` and `-z execstack` are the commands that aid in disabling
    the stack protection an making it executable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have compiled the application, let''s run it with input types that
    will break and execute the code as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0447202-627a-4a40-8dad-10a2f0204e34.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot gives a starting point of heap buffer overflows. We
    will leave it to the reader to discover how to exploit it further and get a reverse
    shell out of it. The methodology employed is very similar to that we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: String format vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uncontrolled format string exploits can be used to crash a program or to execute
    harmful code. The problem stems from the use of unchecked user input as a string
    parameter in certain C functions that perform formatting, such as `printf()`.
    A malicious user may use the `%s` and `%x` format tokens, among others, to print
    data from the call stack or possibly other locations in the memory. We could also
    write arbitrary data to arbitrary locations using the `%n` format token, which
    commands `printf()` and similar functions to write the number of bytes formatted
    to an address stored on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand this further with the following piece of sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb027593-7b28-4072-b6e3-c994015f757d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go ahead and compile the code, disabling the inbuilt protection as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the print function takes the first parameter as the format string
    (`%s`, `%c`, `%d` and so on ). In the previous case, `argv[1]` can be used as
    a format string and print the content of any memory location. The preceding code
    is vulnerable. If it had been written as shown, however, the vulnerability would
    not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d910a09a-0984-4100-81eb-55f558ac0eec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have compiled the application, let''s run it with input types that
    will break and execute the code shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f30ddab8-5855-4219-acfc-bbffd7c57925.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s break the code with the format string vulnerability as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc965f14-8d38-4216-83f7-fa7246204955.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot gives a starting point; again, we will leave it to
    the reader to explore how to exploit this further. It is recommended that you
    try the same methodology that we discussed in detail previously.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed reverse engineering in Linux. We also studied
    fuzzing using Python. We looked at assembly language and mnemonics within the
    context of Linux debuggers (`edb` and `gdb`). We discussed stack buffer overflows
    in great detail, and we learned about the concepts of Heap buffer overflow and
    string format vulnerabilities. I would highly recommend spending a good amount
    of time on these ideas and exploring them on different operating system versions
    and vulnerable applications. By the end of this chapter, you should have a fair
    understanding of buffer overflow vulnerabilities and reversing in a Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss reverse engineering and buffer overflow
    vulnerabilities in the Windows environment. We will demonstrate exploitation using
    a real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we automate the process of exploiting buffer overflow vulnerabilities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we do to avoid advance protections being imposed by operating systems
    such as disabling code execution on a stack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we deal with address randomization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stack Buffer overflow crossfire: [https://www.doyler.net/security-not-included/crossfire-buffer-overflow-linux-exploit](https://www.doyler.net/security-not-included/crossfire-buffer-overflow-linux-exploit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack Buffer overflow crossfire: [https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html](https://www.whitelist1.com/2016/11/stack-overflow-8-exploiting-crossfire.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Heap Buffer overflow: [https://www.win.tue.nl/~aeb/linux/hh/hh-11.html](https://www.win.tue.nl/~aeb/linux/hh/hh-11.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String format vulnerabilities: [https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/](https://null-byte.wonderhowto.com/how-to/security-oriented-c-tutorial-0x14-format-string-vulnerability-part-i-buffer-overflows-nasty-little-brother-0167254/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
