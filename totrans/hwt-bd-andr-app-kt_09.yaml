- en: 9\. Unit Tests and Integration Tests with JUnit, Mockito, and Espresso
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about testing on the Android platform and how
    to create unit tests, integration tests, and UI tests. You will see how to create
    each of these types of tests, analyze how it runs, and work with frameworks such
    as JUnit, Mockito, Robolectric, and Espresso. You will also learn about test-driven
    development, a software development practice that prioritizes tests over implementation.
    By the end of this chapter, you will be able to combine your new testing skills
    to work on a realistic project.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, you learned about how to load background data and display
    it in the UI and how to set up API calls to retrieve data. But how can you be
    sure that things work well? What if you're in a situation where you have to fix
    a bug in a project that you haven't interacted much with in the past? How can
    you know that the fix you are applying won't trigger another bug? The answer to
    these questions is through tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will analyze the types of tests developers can write and
    we will look at available testing tools to ease the testing experience. The first
    issue that arises is the fact that desktops or laptops, which have different operating
    systems, are used to develop mobile applications. This implies that the tests
    also have to be run on the device or emulator, which will slow the tests down.
    In order to solve this issue, we are presented with two types of tests: `test`
    folder and will run on your machine, and `androidTest` folder and will run on
    the device or emulator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these tests rely on the Java **JUnit** library, which helps developers
    set up their tests and group them in different categories. It also provides different
    configuration options, as well as extensions that other libraries can build upon.
    We will also look into the testing pyramid, which helps guide developers as to
    how to structure their tests. We will start at the bottom of the pyramid, which
    is represented by **unit tests**, move upward through **integration tests**, and
    finally reach the top, which is represented by **end-to-end tests** (UI tests).
    You''ll have the opportunity to learn about the tools that aid in writing each
    of these types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mockito** and **mockito-kotlin**, which help mainly in unit tests and are
    useful for creating mocks or test double in which we can manipulate inputs so
    that we can assert different scenarios. (A mock or test double is an object that
    mimics the implementation of another object. Every time a test interacts with
    mocks, you can specify the behavior of these interactions.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Robolectric**, an open source library that brings the Android framework onto
    your machine, allowing you to test activities and fragments locally and not on
    the emulator. This can be used for both unit tests and integration tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditText` components, and so on) and assertions (verifying that views display
    certain text, are currently being displayed to the user, are enabled, and so on)
    on an app''s UI in an instrumented test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will also take a look at **test-driven development** (**TDD**).
    This is a software development process where tests take priority. A simple way
    of describing it is as writing the test first. We will analyze how this approach
    is taken when developing features for Android applications. One of the things
    to keep in mind is that in order for an application to be properly tested, its
    classes must be properly written. One way to do this is by clearly defining the
    boundaries between your classes and splitting them based on the tasks you want
    them to accomplish. Once you have achieved this, you can also rely on the **dependency
    inversion** and **dependency injection** principles when writing your classes.
    When these principles are applied properly, you should be able to inject fake
    objects into the subjects of your tests and manipulate the inputs to suit your
    testing scenario. Dependency injection also helps when writing instrumented tests
    to help you swap modules that make network calls with local data in order to make
    your tests independent of external factors, such as networks. Instrumented tests
    are tests that run on a device or an emulator. The "instrument" keyword comes
    from the instrumentation framework, which assembles these tests and then executes
    them on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, each application should have three types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These are local tests that validate individual classes and
    methods. They should represent the majority of your tests and they should be fast,
    easy to debug, and easy to maintain. They are also known as small tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: These are either local tests with Robolectric, or instrumented
    tests that validate interactions between your app''s modules and components. These
    are slower and more complex than unit tests. The increase in complexity is due
    to the interaction between the components. These are also known as medium tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI tests (end-to-end tests)**: These are instrumented tests that verify complete
    user journeys and scenarios. This makes them more complex and harder to maintain;
    they should represent the smallest number of your total test number. These are
    also known as large tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can observe the **testing pyramid**. The recommendation
    from Google is to keep a ratio of 70:20:10 (unit tests: integration tests: UI
    tests) for your tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Testing pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Testing pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous section, a unit test is a test that verifies a
    small portion of your code, and the majority of your tests should be unit tests
    that should cover all sorts of scenarios (success, errors, limits, and more).
    Ideally, these tests should be local, but there are a few exceptions where you
    can make them instrumented. Those cases are rare and should be limited to when
    you want to interact with specific hardware of the device.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JUnit is a framework for writing unit tests both in Java and in Android. It
    is responsible for how tests are executed, allowing developers to configure their
    tests. It offers a multitude of features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Before` and `@After` annotations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertions**: These are used to verify the result of an operation against
    an expected value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rules**: These allow developers to set up inputs that are common for multiple tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runners**: Using these, you can specify how the tests can be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: These allow a test method to be executed with multiple inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orderings**: These specify in which order the tests should be executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Matchers**: These allow you to define patterns that can then be used to validate
    the results of the subject of your tests, or help you control the behavior of mocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Android Studio, when a new project is created, the `app` module comes with
    the JUnit library in Gradle. This should be visible in `app/build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the following class that we need to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This method should return the factorial of the number `n`. We can start with
    a simple test that checks the value. In order to create a new unit test, you will
    need to create a new class in the `test` directory of your project. The typical
    convention most developers follow is to add the `Test` suffix to your class name
    and place it under the same package in the `test` directory. For example, `com.mypackage.ClassA`
    will have the test in `com.mypackage.ClassATest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, you can see that we initialize the class under test, and the
    test method itself is annotated with the `@Test` annotation. The test method itself
    will assert that `(3!)==6`. The assertion is done using the `assertEquals` method
    from the JUnit library. A common practice in development is to split the test
    into three areas, also known as AAA (Arrange-Act-Assert):'
  prefs: []
  type: TYPE_NORMAL
- en: Arrange - Where the inputs are initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Act - Where the method under test is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assert - Where the verification is done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can write another test to make sure that the value is correct, but that would
    mean that we end up duplicating the code. We can now attempt to write a parameterized
    test. In order to do this, we will need to use the parameterized test runner.
    The preceding test has its own built-in runner provided by JUnit. The parameterized
    runner will run the test repeatedly for different values that we provide, and
    it will look like the following. (Please note that import statements have been
    removed for brevity.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will actually run six tests. The usage of the `@Parameterized` annotation
    tells JUnit that this is a test with multiple parameters, and also allows us to
    add a constructor for the test that will represent the input value for our factorial
    function and the output. We then defined a collection of parameters with the use
    of the `@Parameterized.Parameters` annotation. Each parameter for this test is
    a separate list containing the input and the expected output. When JUnit runs
    this test, it will run a new instance for each parameter and then execute the
    test method. This will produce five successes and one failure for when we test
    *0!*, meaning that we have found a bug. We never accounted for a situation when
    *n = 0*. Now, we can go back to our code to fix the failure. We can do this by
    replacing the `reduce` function, which doesn''t allow us to specify an initial
    value with a `fold` function, which allows us to give the initial value of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the tests now, they will all pass. But that doesn''t mean we are done
    here. There are many things that can go wrong. What happens if `n` is a negative
    number? Since we are dealing with factorials, we may get really large numbers.
    We are working with integers in our examples, which means that the integer will
    overflow after *12!*. Normally, we would create new test methods in the `MyClassTest`
    class, but since the parametrized runner is used, all of our new methods will
    be run multiple times, which will cost us time, so we will create a new test class
    to check our errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This would lead to the following change in the class that was tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s solve the issue with very large factorials. We can use the `BigInteger`
    class, which is capable of holding large numbers. We can update the test as follows
    (import statements not shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The class under test now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have implemented the factorial with the help of
    `IntArray`. This implementation is based more on Kotlin''s ability to chain methods
    together, but it has one drawback: the fact that it uses memory for the array
    when it doesn''t need to. We only care about the factorial and not storing all
    the numbers from 1 to *n*. We can change the implementation to a simple `for`
    loop and use the tests to guide us during the refactoring process. We can observe
    here two benefits of having tests in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: They serve as updated documentation of how the features should be implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They guide us when refactoring code by maintaining the same assertion and detecting
    whether new changes to the code broke it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s update the code to get rid of `IntArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we modify the `factorial` function, as in the preceding example, and run
    the tests, we should see them all passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In certain situations, your tests will use a resource that is common to the
    test or the application (databases, files, and so on). Ideally, this shouldn''t
    happen for unit tests, but there can always be exceptions to this. Let''s analyze
    that scenario and see how JUnit can aid us with it. We will add a `companion`
    object, which will store the result, in order to simulate this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the tests for the preceding code, we will start seeing that some
    will fail. That''s because after the first tests execute the `factorial` function,
    the result will have the value of the executed tests, and when a new test is executed,
    the result of the factorial will be multiplied by the previous value of the result.
    Normally, this would be good because the tests tell us that we are doing something
    wrong and we should remedy this, but for this example, we will address the issue
    directly in the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the tests, we''ve added two methods with the `@Before` and `@After` annotations.
    When these methods are introduced, JUnit will change the execution flow as follows:
    all methods with the `@Before` annotation will be executed, a method with the
    `@Test` annotation will be executed, and then all methods with the `@After` annotation
    will be executed. This process will repeat for every `@Test` method in your class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find yourself repeating the same statements in your `@Before` method,
    you can consider using `@Rule` in order to remove the repetition. We can set up
    a test rule for the preceding example. Test rules should be in the `test` or `androidTest`
    packages, because their usage is only limited to testing. They tend to be used
    in multiple tests, so you can place your rules in a `rules` package (import statements
    not shown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we can see that the rule will implement `TestRule`,
    which in turn comes with the `apply()` method. We then create a new `Statement`
    object that will execute the base statement (the test itself) and reset the value
    of the result before and after the statement. We can now modify the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In order to add the rule to the test, we use the `@Rule` annotation. Since the
    test is written in Kotlin, we are using `@JvmField` to avoid generating getters
    and setters because `@Rule` requires a public field and not a method.
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio Testing Tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android Studio comes with a good set of shortcuts and visual tools to help
    with testing. If you want to create a new test for your class or go to existing
    tests for your class, you can use the *Ctrl* + *Shift* + *T* (Windows) or *Command*
    + *Shift* + *T* (Mac) shortcut. In order to run tests, there are multiple options:
    right-click your file or the package and select the `Run Tests in...` option,
    or if you want to run a test independently, you can go to the particular test
    method and select the green icon either to the top of the class, which will execute
    all the tests in the class; or, for an individual test, you can click the green
    icon next to the `@Test` annotated methods. This will trigger the test execution,
    which will be displayed in the `Run` tab, as shown in the following screenshot.
    When the tests are completed, they will become either red or green, depending
    on their success state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Test output in Android Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Test output in Android Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Another important feature that can be found in tests is the debug one. This
    is important because you can debug both the test and the method under test, so
    if you find problems in fixing an issue, you can use this to view what the test
    was using as input and how your code handles the input. The third feature you
    can find in the green icon next to a test is the `Run With Coverage` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'This helps developers identify what lines of code are covered by the test and
    which ones are skipped. The higher the coverage, the higher the chances of finding
    crashes and bugs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Test coverage in Android Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Test coverage in Android Studio'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see the coverage of our class broken down into
    the number of classes under test, the number of methods under test, and the number
    of lines under test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to run tests for your Android app is through the command line.
    This is usually handy in situations where your project has `Terminal` tab in Android
    Studio to emulate that behavior. The `Terminal` tab is usually located in the
    bottom bar in Android Studio near the `Logcat` tab. In every Android Studio project,
    a file called `gradlew` is present. This is an executable file that allows developers
    to execute Gradle commands. In order to run your local unit tests, you can use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gradlew.bat test` (for Windows)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./gradlew test` (for Mac and Linux)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once that command is executed, the app will be built and tested. You can find
    a variety of commands that you can input in `Terminal` in the `Gradle` tab located
    on the right-hand side in Android Studio. The outputs of the tests, when executed
    from either `Terminal` or the `Gradle` tab, can be found in the `app/build/reports`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Gradle commands in Android Studio'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B15216_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: Gradle commands in Android Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, we looked at how to set up a unit test and how to
    use assertions to verify the result of an operation. What if we want to verify
    whether a certain method was called? Or what if we want to manipulate the test
    input in order to test a specific scenario? In these types of situations, we can
    use **Mockito**. This is a library that helps developers set up dummy objects
    that can be injected into the objects under test and allows them to verify method
    calls, set up inputs, and even monitor the test objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library should be added to your `test` Gradle setup, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the following code example (please note that, for brevity,
    import statements have been removed from the following code snippets):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `Context` object, which normally cannot be unit tested because
    it's part of the Android framework. We can use `mockito` to create a test double
    and inject it into the `StringConcatenator` object. Then, we can manipulate the
    call to `getString()` to return whatever input we chose. This process is referred
    to as mocking.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'class SpecificStringConcatenator(private val stringConcatenator:   StringConcatenator)
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun concatenateSpecificStrings(): String {'
  prefs: []
  type: TYPE_NORMAL
- en: return stringConcatenator.concatenate(R.string.string_1,           R.string.string_2)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: class SpecificStringConcatenatorTest {
  prefs: []
  type: TYPE_NORMAL
- en: private val stringConcatenator = Mockito
  prefs: []
  type: TYPE_NORMAL
- en: .mock(StringConcatenator::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: private val specificStringConcatenator =
  prefs: []
  type: TYPE_NORMAL
- en: SpecificStringConcatenator(stringConcatenator)
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun concatenateSpecificStrings() {
  prefs: []
  type: TYPE_NORMAL
- en: val expected = "expected"
  prefs: []
  type: TYPE_NORMAL
- en: Mockito.'when'(stringConcatenator.concatenate(R.string.string_1,
  prefs: []
  type: TYPE_NORMAL
- en: R.string.string_2))
  prefs: []
  type: TYPE_NORMAL
- en: .thenReturn(expected)
  prefs: []
  type: TYPE_NORMAL
- en: val result = specificStringConcatenator
  prefs: []
  type: TYPE_NORMAL
- en: .concatenateSpecificStrings()
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(expected, result)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: mock-maker-inline
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'class SpecificStringConcatenator(private val stringConcatenator:   StringConcatenator)
    {'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun concatenateSpecificStrings(): String {'
  prefs: []
  type: TYPE_NORMAL
- en: return stringConcatenator.concatenate(R.string.string_1,           R.string.string_2)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun concatenateWithCallback(callback: Callback) {'
  prefs: []
  type: TYPE_NORMAL
- en: callback.onStringReady(concatenateSpecificStrings())
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: interface Callback {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun onStringReady(input: String)'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun concatenateWithCallback() {
  prefs: []
  type: TYPE_NORMAL
- en: val expected = "expected"
  prefs: []
  type: TYPE_NORMAL
- en: Mockito.`when`(stringConcatenator.concatenate(R.string.string_1,           R.string.string_2))
  prefs: []
  type: TYPE_NORMAL
- en: .thenReturn(expected)
  prefs: []
  type: TYPE_NORMAL
- en: val callback =           Mockito.mock(SpecificStringConcatenator.Callback::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: specificStringConcatenator.concatenateWithCallback(callback)
  prefs: []
  type: TYPE_NORMAL
- en: Mockito.verify(callback).onStringReady(expected)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun concatenateWithCallback() {
  prefs: []
  type: TYPE_NORMAL
- en: val expected = "expected"
  prefs: []
  type: TYPE_NORMAL
- en: val spy = Mockito.spy(specificStringConcatenator)
  prefs: []
  type: TYPE_NORMAL
- en: Mockito.`when`(spy.concatenateSpecificStrings())          .thenReturn(expected)
  prefs: []
  type: TYPE_NORMAL
- en: val callback           = Mockito.mock(SpecificStringConcatenator.Callback::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: specificStringConcatenator.concatenateWithCallback(callback)
  prefs: []
  type: TYPE_NORMAL
- en: Mockito.verify(callback).onStringReady(expected)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(MockitoJUnitRunner::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class SpecificStringConcatenatorTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Mock'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var stringConcatenator: StringConcatenator'
  prefs: []
  type: TYPE_NORMAL
- en: '@InjectMocks'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var specificStringConcatenator: SpecificStringConcatenator'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24] character. This, along with some other minor issues, causes some inconvenience
    when using Mockito in Kotlin. A few libraries were introduced to wrap Mockito
    and provide a nicer experience when using it. One of those is `mockito-kotlin`.
    You can add this library to your module using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A big visible change this library adds is replacing the `when` method with `whenever`.
    Another useful change is replacing the `mock` method to rely on generics, rather
    than class objects. The rest of the syntax is similar to the Mockito syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now update the previous tests with the new library, starting with `StringConcatenatorTest`
    (import statements have been removed for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can observe, the [PRE27]
  prefs: []
  type: TYPE_NORMAL
- en: '@RunWith(MockitoJUnitRunner::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class SpecificStringConcatenatorTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Mock'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var stringConcatenator: StringConcatenator'
  prefs: []
  type: TYPE_NORMAL
- en: '@InjectMocks'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var specificStringConcatenator: SpecificStringConcatenator'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun concatenateSpecificStrings() {
  prefs: []
  type: TYPE_NORMAL
- en: val expected = "expected"
  prefs: []
  type: TYPE_NORMAL
- en: whenever(stringConcatenator.concatenate(R.string.string_1,           R.string.string_2))
  prefs: []
  type: TYPE_NORMAL
- en: .thenReturn(expected)
  prefs: []
  type: TYPE_NORMAL
- en: val result =           specificStringConcatenator.concatenateSpecificStrings()
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(expected, result)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun concatenateWithCallback() {
  prefs: []
  type: TYPE_NORMAL
- en: val expected = "expected"
  prefs: []
  type: TYPE_NORMAL
- en: val spy = spy(specificStringConcatenator)
  prefs: []
  type: TYPE_NORMAL
- en: whenever(spy.concatenateSpecificStrings()).thenReturn(expected)
  prefs: []
  type: TYPE_NORMAL
- en: val callback = mock<SpecificStringConcatenator.Callback>()
  prefs: []
  type: TYPE_NORMAL
- en: specificStringConcatenator.concatenateWithCallback(callback)
  prefs: []
  type: TYPE_NORMAL
- en: verify(callback).onStringReady(expected)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: class NumberAdder {
  prefs: []
  type: TYPE_NORMAL
- en: '@Throws(InvalidNumberException::class)'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun sum(n: Int, callback: (BigInteger) -> Unit) {'
  prefs: []
  type: TYPE_NORMAL
- en: if (n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: throw InvalidNumberException
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: var result = BigInteger.ZERO
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1..n){
  prefs: []
  type: TYPE_NORMAL
- en: result = result.plus(i.toBigInteger())
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: callback(result)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'object InvalidNumberException : Throwable()'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: testImplementation 'junit:junit:4.13.1'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'org.mockito:mockito-core:3.6.0'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(Parameterized::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class NumberAdderParameterTest(
  prefs: []
  type: TYPE_NORMAL
- en: 'private val input: Int,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private val expected: BigInteger'
  prefs: []
  type: TYPE_NORMAL
- en: ) {
  prefs: []
  type: TYPE_NORMAL
- en: companion object {
  prefs: []
  type: TYPE_NORMAL
- en: '@Parameterized.Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '@JvmStatic'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun getData(): List<Array<out Any>> = listOf('
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(0, BigInteger.ZERO),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(1, BigInteger.ONE),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(5, 15.toBigInteger()),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(20, 210.toBigInteger()),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(Int.MAX_VALUE, BigInteger("2305843008139952128"))
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private val numberAdder = NumberAdder()
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun sum() {
  prefs: []
  type: TYPE_NORMAL
- en: val callback = mock<(BigInteger) -> Unit>()
  prefs: []
  type: TYPE_NORMAL
- en: numberAdder.sum(input, callback)
  prefs: []
  type: TYPE_NORMAL
- en: verify(callback).invoke(expected)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(MockitoJUnitRunner::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class NumberAdderErrorHandlingTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@InjectMocks'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var numberAdder: NumberAdder'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test(expected = NumberAdder.InvalidNumberException::class)'
  prefs: []
  type: TYPE_NORMAL
- en: fun sum() {
  prefs: []
  type: TYPE_NORMAL
- en: val input = -1
  prefs: []
  type: TYPE_NORMAL
- en: val callback = mock<(BigInteger) -> Unit>()
  prefs: []
  type: TYPE_NORMAL
- en: numberAdder.sum(input, callback)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: class NumberAdder {
  prefs: []
  type: TYPE_NORMAL
- en: '@Throws(InvalidNumberException::class)'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun sum(n: Int, callback: (BigInteger) -> Unit) {'
  prefs: []
  type: TYPE_NORMAL
- en: if (n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: throw InvalidNumberException
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: callback(n.toBigInteger().times((n.toBigInteger() +            1.toBigInteger())).divide(2.toBigInteger()))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'object InvalidNumberException : Throwable()'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Given I am not logged in
  prefs: []
  type: TYPE_NORMAL
- en: And I open the application
  prefs: []
  type: TYPE_NORMAL
- en: When I enter my credentials
  prefs: []
  type: TYPE_NORMAL
- en: And click Login
  prefs: []
  type: TYPE_NORMAL
- en: Then I see the Main screen
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: testImplementation 'org.robolectric:robolectric:4.3'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'androidx.test.ext:junit:1.1.1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: class FactorialGenerator {
  prefs: []
  type: TYPE_NORMAL
- en: '@Throws(FactorialNotFoundException::class)'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun factorial(n: Int): BigInteger {'
  prefs: []
  type: TYPE_NORMAL
- en: if (n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: throw FactorialNotFoundException
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: var result = BigInteger.ONE
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1..n) {
  prefs: []
  type: TYPE_NORMAL
- en: result = result.times(i.toBigInteger())
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'object FactorialNotFoundException : Throwable()'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: class TextFormatter(
  prefs: []
  type: TYPE_NORMAL
- en: 'private val factorialGenerator: FactorialGenerator,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private val context: Context'
  prefs: []
  type: TYPE_NORMAL
- en: ) {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun getFactorialResult(n: Int): String {'
  prefs: []
  type: TYPE_NORMAL
- en: return try {
  prefs: []
  type: TYPE_NORMAL
- en: context.getString(R.string.result,               factorialGenerator.factorial(n).toString())
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (e: FactorialGenerator.FactorialNotFoundException) {'
  prefs: []
  type: TYPE_NORMAL
- en: context.getString(R.string.error)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'class MainActivity : AppCompatActivity() {'
  prefs: []
  type: TYPE_NORMAL
- en: 'private lateinit var textFormatter: TextFormatter'
  prefs: []
  type: TYPE_NORMAL
- en: 'override fun onCreate(savedInstanceState: Bundle?) {'
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate(savedInstanceState)
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.activity_main)
  prefs: []
  type: TYPE_NORMAL
- en: ttextFormatter = TextFormatter(FactorialGenerator(),
  prefs: []
  type: TYPE_NORMAL
- en: applicationContext)
  prefs: []
  type: TYPE_NORMAL
- en: findViewById<Button>(R.id.button).setOnClickListener {
  prefs: []
  type: TYPE_NORMAL
- en: findViewById<TextView>(R.id.text_view).text               = textFormatter.getFactorialResult(findViewById<EditText>                (R.id.edit_text).text.toString().toInt())
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class MainActivityTest {
  prefs: []
  type: TYPE_NORMAL
- en: private val context = getApplicationContext<Application>()
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun `show factorial result in text view`() {
  prefs: []
  type: TYPE_NORMAL
- en: val scenario = launch<MainActivity>(MainActivity::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.moveToState(Lifecycle.State.RESUMED)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.onActivity { activity ->
  prefs: []
  type: TYPE_NORMAL
- en: activity.edit_text.setText(5.toString())
  prefs: []
  type: TYPE_NORMAL
- en: activity.button.performClick()
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(context.getString(R.string.result,               "120"),activity.text_view.text)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '@Config('
  prefs: []
  type: TYPE_NORMAL
- en: sdk = [Build.VERSION_CODES.P],
  prefs: []
  type: TYPE_NORMAL
- en: minSdk = Build.VERSION_CODES.KITKAT,
  prefs: []
  type: TYPE_NORMAL
- en: maxSdk = Build.VERSION_CODES.Q,
  prefs: []
  type: TYPE_NORMAL
- en: application = Application::class,
  prefs: []
  type: TYPE_NORMAL
- en: assetDir = "/assetDir/"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class MainActivityTest
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: sdk=28
  prefs: []
  type: TYPE_NORMAL
- en: minSdk = 14
  prefs: []
  type: TYPE_NORMAL
- en: maxSdk = 29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: testImplementation 'androidx.fragment:fragment-testing:1.1.0'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'androidx.test.espresso:espresso-core:3.2.0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: val scenario = launchFragmentInContainer<MainFragment>()
  prefs: []
  type: TYPE_NORMAL
- en: scenario.moveToState(Lifecycle.State.CREATED)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: onView(Matcher<View>).perform(ViewAction)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: onView(Matcher<View>).check(ViewAssertion)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: onView(allOf(withId(R.id.edit_text), withParent(withId(R.id.root))))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: onView(withId(R.id.text_view)).check(matches(withText("My text"))))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class MainActivityTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun `show factorial result in text view`() {
  prefs: []
  type: TYPE_NORMAL
- en: val scenario = launch<MainActivity>(MainActivity::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.moveToState(Lifecycle.State.RESUMED)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.onActivity { activity ->
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.edit_text)).perform(typeText("5"))
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.text_view))
  prefs: []
  type: TYPE_NORMAL
- en: .check(matches(withText(activity                 .getString(R.string.result,
    "120"))))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Given I open the application
  prefs: []
  type: TYPE_NORMAL
- en: And I insert the number n
  prefs: []
  type: TYPE_NORMAL
- en: When I press the Calculate button
  prefs: []
  type: TYPE_NORMAL
- en: Then I should see the text "The sum of numbers from 1 to n is [result]"
  prefs: []
  type: TYPE_NORMAL
- en: Given I open the application
  prefs: []
  type: TYPE_NORMAL
- en: And I insert the number -n
  prefs: []
  type: TYPE_NORMAL
- en: When I press the Calculate button
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I should see the text "Error: Invalid number"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: testImplementation 'junit:junit:4.13.1'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'org.mockito:mockito-core:3.6.0'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'com.nhaarman.mockitokotlin2
  prefs: []
  type: TYPE_NORMAL
- en: :mockito-kotlin:2.2.0'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'org.robolectric:robolectric:4.4'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'androidx.test.ext:junit:1.1.2'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'androidx.test.espresso:espresso-core:3.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: androidTestImplementation 'androidx.test.ext:junit:1.1.2'
  prefs: []
  type: TYPE_NORMAL
- en: androidTestImplementation 'androidx.test
  prefs: []
  type: TYPE_NORMAL
- en: .espresso:espresso-core:3.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: androidTestImplementation 'androidx.test:rules:1.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: testOptions.unitTests.includeAndroidResources = true
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: sdk=28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: mock-maker-inline
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: import java.math.BigInteger
  prefs: []
  type: TYPE_NORMAL
- en: class NumberAdder {
  prefs: []
  type: TYPE_NORMAL
- en: '@Throws(InvalidNumberException::class)'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun sum(n: Int, callback: (BigInteger) -> Unit) {'
  prefs: []
  type: TYPE_NORMAL
- en: if (n < 0) {
  prefs: []
  type: TYPE_NORMAL
- en: throw InvalidNumberException
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: callback(n.toBigInteger().times((n.toLong()           + 1).toBigInteger()).divide(2.toBigInteger()))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'object InvalidNumberException : Throwable()'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(Parameterized::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class NumberAdderParameterTest(
  prefs: []
  type: TYPE_NORMAL
- en: 'private val input: Int,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private val expected: BigInteger'
  prefs: []
  type: TYPE_NORMAL
- en: ) {
  prefs: []
  type: TYPE_NORMAL
- en: companion object {
  prefs: []
  type: TYPE_NORMAL
- en: '@Parameterized.Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '@JvmStatic'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun getData(): List<Array<out Any>> = listOf('
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(0, BigInteger.ZERO),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(1, BigInteger.ONE),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(5, 15.toBigInteger()),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(20, 210.toBigInteger()),
  prefs: []
  type: TYPE_NORMAL
- en: arrayOf(Int.MAX_VALUE, BigInteger("2305843008139952128"))
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: private val numberAdder = NumberAdder()
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun sum() {
  prefs: []
  type: TYPE_NORMAL
- en: val callback = mock<(BigInteger) -> Unit>()
  prefs: []
  type: TYPE_NORMAL
- en: numberAdder.sum(input, callback)
  prefs: []
  type: TYPE_NORMAL
- en: verify(callback).invoke(expected)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(MockitoJUnitRunner::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class NumberAdderErrorHandlingTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@InjectMocks'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var numberAdder: NumberAdder'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test(expected = NumberAdder.InvalidNumberException::class)'
  prefs: []
  type: TYPE_NORMAL
- en: fun sum() {
  prefs: []
  type: TYPE_NORMAL
- en: val input = -1
  prefs: []
  type: TYPE_NORMAL
- en: val callback = mock<(BigInteger) -> Unit>()
  prefs: []
  type: TYPE_NORMAL
- en: numberAdder.sum(input, callback)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: class TextFormatter(
  prefs: []
  type: TYPE_NORMAL
- en: 'private val numberAdder: NumberAdder,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private val context: Context'
  prefs: []
  type: TYPE_NORMAL
- en: ) {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun getSumResult(n: Int, callback: (String) -> Unit) {'
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: numberAdder.sum(n) {
  prefs: []
  type: TYPE_NORMAL
- en: callback(
  prefs: []
  type: TYPE_NORMAL
- en: context.getString(
  prefs: []
  type: TYPE_NORMAL
- en: R.string.the_sum_of_numbers_from_1_to_is,
  prefs: []
  type: TYPE_NORMAL
- en: n,
  prefs: []
  type: TYPE_NORMAL
- en: it.toString()
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (e: NumberAdder.InvalidNumberException) {'
  prefs: []
  type: TYPE_NORMAL
- en: callback(context.getString
  prefs: []
  type: TYPE_NORMAL
- en: (R.string.error_invalid_number))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(MockitoJUnitRunner::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class TextFormatterTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@InjectMocks'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var textFormatter: TextFormatter'
  prefs: []
  type: TYPE_NORMAL
- en: '@Mock'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var numberAdder: NumberAdder'
  prefs: []
  type: TYPE_NORMAL
- en: '@Mock'
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var context: Context'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun getSumResult_success() {
  prefs: []
  type: TYPE_NORMAL
- en: val n = 10
  prefs: []
  type: TYPE_NORMAL
- en: val sumResult = BigInteger.TEN
  prefs: []
  type: TYPE_NORMAL
- en: val expected = "expected"
  prefs: []
  type: TYPE_NORMAL
- en: whenever(numberAdder.sum(eq(n), any())).thenAnswer {
  prefs: []
  type: TYPE_NORMAL
- en: (it.arguments[1] as (BigInteger)->Unit)
  prefs: []
  type: TYPE_NORMAL
- en: .invoke(sumResult)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: whenever(context.getString
  prefs: []
  type: TYPE_NORMAL
- en: (R.string.the_sum_of_numbers_from_1_to_is, n,
  prefs: []
  type: TYPE_NORMAL
- en: sumResult.toString())).thenReturn(expected)
  prefs: []
  type: TYPE_NORMAL
- en: val callback = mock<(String)->Unit>()
  prefs: []
  type: TYPE_NORMAL
- en: textFormatter.getSumResult(n, callback)
  prefs: []
  type: TYPE_NORMAL
- en: verify(callback).invoke(expected)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun getSumResult_error() {
  prefs: []
  type: TYPE_NORMAL
- en: val n = 10
  prefs: []
  type: TYPE_NORMAL
- en: val expected = "expected"
  prefs: []
  type: TYPE_NORMAL
- en: whenever(numberAdder.sum(eq(n),           any())).thenThrow(NumberAdder.InvalidNumberException)
  prefs: []
  type: TYPE_NORMAL
- en: whenever(context.getString(R.string.error_invalid_number))          .thenReturn(expected)
  prefs: []
  type: TYPE_NORMAL
- en: val callback = mock<(String)->Unit>()
  prefs: []
  type: TYPE_NORMAL
- en: textFormatter.getSumResult(n, callback)
  prefs: []
  type: TYPE_NORMAL
- en: verify(callback).invoke(expected)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: <?xml version="1.0" encoding="utf-8"?>
  prefs: []
  type: TYPE_NORMAL
- en: <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  prefs: []
  type: TYPE_NORMAL
- en: android:id="@+id/root"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="match_parent"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="match_parent"
  prefs: []
  type: TYPE_NORMAL
- en: android:orientation="vertical">
  prefs: []
  type: TYPE_NORMAL
- en: <EditText
  prefs: []
  type: TYPE_NORMAL
- en: android:id="@+id/edit_text"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="match_parent"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:inputType="number" />
  prefs: []
  type: TYPE_NORMAL
- en: <Button
  prefs: []
  type: TYPE_NORMAL
- en: android:id="@+id/button"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_gravity="center_horizontal"
  prefs: []
  type: TYPE_NORMAL
- en: android:text="@string/calculate" />
  prefs: []
  type: TYPE_NORMAL
- en: <TextView
  prefs: []
  type: TYPE_NORMAL
- en: android:id="@+id/text_view"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_gravity="center_horizontal" />
  prefs: []
  type: TYPE_NORMAL
- en: </LinearLayout>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'class MainActivity : AppCompatActivity() {'
  prefs: []
  type: TYPE_NORMAL
- en: 'private lateinit var textFormatter: TextFormatter'
  prefs: []
  type: TYPE_NORMAL
- en: 'override fun onCreate(savedInstanceState: Bundle?) {'
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate(savedInstanceState)
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.activity_main)
  prefs: []
  type: TYPE_NORMAL
- en: textFormatter = TextFormatter(NumberAdder(), applicationContext)
  prefs: []
  type: TYPE_NORMAL
- en: findViewById<Button>(R.id.button).setOnClickListener {
  prefs: []
  type: TYPE_NORMAL
- en: 'textFormatter.getSumResult(findViewById<EditText>              (R.id.edit_text).text.toString().toIntOrNull()
    ?: 0) {'
  prefs: []
  type: TYPE_NORMAL
- en: findViewById<TextView>(R.id.text_view).text = it
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class MainActivityTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun `show sum result in text view`() {
  prefs: []
  type: TYPE_NORMAL
- en: val scenario = launch<MainActivity>(MainActivity::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.moveToState(Lifecycle.State.RESUMED)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.onActivity { activity ->
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.edit_text)).perform(replaceText("5"))
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.text_view)).check(matches(withText
  prefs: []
  type: TYPE_NORMAL
- en: (activity.getString
  prefs: []
  type: TYPE_NORMAL
- en: (R.string.the_sum_of_numbers_from_1_to_is, 5, "15"))))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun `show error in text view`() {
  prefs: []
  type: TYPE_NORMAL
- en: val scenario = launch<MainActivity>(MainActivity::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.moveToState(Lifecycle.State.RESUMED)
  prefs: []
  type: TYPE_NORMAL
- en: scenario.onActivity { activity ->
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.edit_text))
  prefs: []
  type: TYPE_NORMAL
- en: .perform(replaceText("-5"))
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.text_view)).check(
  prefs: []
  type: TYPE_NORMAL
- en: matches(withText(activity.getString(
  prefs: []
  type: TYPE_NORMAL
- en: R.string.error_invalid_number))))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class MainActivityUiTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@JvmField'
  prefs: []
  type: TYPE_NORMAL
- en: '@Rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'var activityRule: ActivityTestRule<MainActivity> ='
  prefs: []
  type: TYPE_NORMAL
- en: ActivityTestRule(MainActivity::class.java)
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun showSumResultInTextView() {
  prefs: []
  type: TYPE_NORMAL
- en: activityRule.activity.let { activity ->
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.edit_text)).perform(replaceText("5"))
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.text_view)).check(matches
  prefs: []
  type: TYPE_NORMAL
- en: (withText(activity.getString
  prefs: []
  type: TYPE_NORMAL
- en: (R.string.the_sum_of_numbers_from_1_to_is, 5, "15"))))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun showErrorInTextView() {
  prefs: []
  type: TYPE_NORMAL
- en: activityRule.activity.let { activity ->
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.edit_text)).perform(replaceText("-5"))
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.text_view)).check(matches               (withText(activity.getString                 (R.string.error_invalid_number))))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: android {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: defaultConfig {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: testInstrumentationRunner           "androidx.test.runner.AndroidJUnitRunner"
  prefs: []
  type: TYPE_NORMAL
- en: 'testInstrumentationRunnerArguments clearPackageData: ''true'''
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: testOptions {
  prefs: []
  type: TYPE_NORMAL
- en: execution 'ANDROIDX_TEST_ORCHESTRATOR'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: dependencies {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: androidTestUtil 'androidx.test:orchestrator:1.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: testInstrumentationRunner "com.android.CustomTestRunner"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'class CustomTestRunner: AndroidJUnitRunner() {'
  prefs: []
  type: TYPE_NORMAL
- en: '@Throws(Exception::class)'
  prefs: []
  type: TYPE_NORMAL
- en: override fun newApplication(
  prefs: []
  type: TYPE_NORMAL
- en: 'cl: ClassLoader?,'
  prefs: []
  type: TYPE_NORMAL
- en: 'className: String?,'
  prefs: []
  type: TYPE_NORMAL
- en: 'context: Context?'
  prefs: []
  type: TYPE_NORMAL
- en: '): Application? {'
  prefs: []
  type: TYPE_NORMAL
- en: return super.newApplication(cl,           MyApplication::class.java.name, context)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class MainActivityUiTest {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '@JvmField'
  prefs: []
  type: TYPE_NORMAL
- en: '@Rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'var activityRule: ActivityTestRule<MainActivity>       = ActivityTestRule(MainActivity::class.java)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '@JvmField'
  prefs: []
  type: TYPE_NORMAL
- en: '@Rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'var activityRule: ActivityTestRule<MainActivity> =       ActivityTestRule(MainActivity::class.java,
    false ,false)'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun myTestMethod() {
  prefs: []
  type: TYPE_NORMAL
- en: val myIntent = Intent()
  prefs: []
  type: TYPE_NORMAL
- en: activityRule.launchActivity(myIntent)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun myTest() {
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.edit_text)).perform(replaceText("5"))
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.text_view))          .check(matches(withText("my test")))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: class MyScreenRobot {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun setText(): MyScreenRobot {'
  prefs: []
  type: TYPE_NORMAL
- en: onView(ViewMatchers.withId(R.id.edit_text))          .perform(ViewActions.replaceText("5"))
  prefs: []
  type: TYPE_NORMAL
- en: return this
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun pressButton(): MyScreenRobot {'
  prefs: []
  type: TYPE_NORMAL
- en: onView(ViewMatchers.withId(R.id.button))          .perform(ViewActions.click())
  prefs: []
  type: TYPE_NORMAL
- en: return this
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun assertText(): MyScreenRobot {'
  prefs: []
  type: TYPE_NORMAL
- en: onView(ViewMatchers.withId(R.id.text_view))          .check(ViewAssertions.matches(ViewMatchers           .withText("my
    test")))
  prefs: []
  type: TYPE_NORMAL
- en: return this
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun myTest() {
  prefs: []
  type: TYPE_NORMAL
- en: MyScreenRobot()
  prefs: []
  type: TYPE_NORMAL
- en: .setText()
  prefs: []
  type: TYPE_NORMAL
- en: .pressButton()
  prefs: []
  type: TYPE_NORMAL
- en: .assertText()
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: class MyHeavyliftingComponent(private val   countingIdlingResource:CountingIdlingResource)
    {
  prefs: []
  type: TYPE_NORMAL
- en: fun doHeavyWork() {
  prefs: []
  type: TYPE_NORMAL
- en: countingIdlingResource.increment()
  prefs: []
  type: TYPE_NORMAL
- en: // do work
  prefs: []
  type: TYPE_NORMAL
- en: countingIdlingResource.decrement()
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'class MyApplication : Application(){'
  prefs: []
  type: TYPE_NORMAL
- en: val countingIdlingResource = CountingIdlingResource("My heavy work")
  prefs: []
  type: TYPE_NORMAL
- en: val myHeavyliftingComponent =       MyHeavyliftingComponent(countingIdlingResource)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: class MyTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@Before'
  prefs: []
  type: TYPE_NORMAL
- en: fun setUp() {
  prefs: []
  type: TYPE_NORMAL
- en: val myApplication = getApplicationContext<MyApplication>()
  prefs: []
  type: TYPE_NORMAL
- en: IdlingRegistry.getInstance()          .register(myApplication.countingIdlingResource)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: androidTestImplementation 'androidx.test.espresso:espresso-intents:3.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '@JvmField'
  prefs: []
  type: TYPE_NORMAL
- en: '@Rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'var intentsRule: IntentsTestRule<MainActivity>       = IntentsTestRule(MainActivity::class.java)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: onView(withId(R.id.button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: intended(allOf(
  prefs: []
  type: TYPE_NORMAL
- en: hasComponent(hasShortClassName(".MainActivity")),
  prefs: []
  type: TYPE_NORMAL
- en: hasExtra(MainActivity.MY_EXTRA, "myExtraValue")))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: androidTestImplementation   'com.android.support.test.espresso:espresso-contrib:3.0.2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: onView(withId(R.id.recycler_view))  .perform(RecyclerViewActions.actionOnItemAtPosition(0,
    click()))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: onView(withId(R.id.recycler_view)).perform(RecyclerViewActions   .scrollToPosition<RecyclerView.ViewHolder>(10))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: onView(withText("myText")).check(matches(isDisplayed()))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: implementation 'androidx.test.espresso:espresso-core:3.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: testImplementation 'junit:junit:4.13.1'
  prefs: []
  type: TYPE_NORMAL
- en: androidTestImplementation 'androidx.test.ext:junit:1.1.2'
  prefs: []
  type: TYPE_NORMAL
- en: androidTestImplementation 'androidx.test:rules:1.3.0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'class Randomizer(private val random: Random) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'fun getTimeToWait(): Int {'
  prefs: []
  type: TYPE_NORMAL
- en: return random.nextInt(5) + 1
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: class Synchronizer(
  prefs: []
  type: TYPE_NORMAL
- en: 'private val randomizer: Randomizer,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private val timer: Timer,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private val countingIdlingResource: CountingIdlingResource'
  prefs: []
  type: TYPE_NORMAL
- en: ) {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun executeAfterDelay(callback: (Int) -> Unit) {'
  prefs: []
  type: TYPE_NORMAL
- en: val timeToWait = randomizer.getTimeToWait()
  prefs: []
  type: TYPE_NORMAL
- en: countingIdlingResource.increment()
  prefs: []
  type: TYPE_NORMAL
- en: timer.schedule(CallbackTask(callback, timeToWait),           timeToWait * 1000L)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: inner class CallbackTask(
  prefs: []
  type: TYPE_NORMAL
- en: 'private val callback: (Int) -> Unit,'
  prefs: []
  type: TYPE_NORMAL
- en: 'private val time: Int'
  prefs: []
  type: TYPE_NORMAL
- en: ') : TimerTask() {'
  prefs: []
  type: TYPE_NORMAL
- en: override fun run() {
  prefs: []
  type: TYPE_NORMAL
- en: callback(time)
  prefs: []
  type: TYPE_NORMAL
- en: countingIdlingResource.decrement()
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'class MyApplication : Application() {'
  prefs: []
  type: TYPE_NORMAL
- en: val countingIdlingResource =       CountingIdlingResource("Timer resource")
  prefs: []
  type: TYPE_NORMAL
- en: val randomizer = Randomizer(Random())
  prefs: []
  type: TYPE_NORMAL
- en: val synchronizer = Synchronizer(randomizer, Timer(),       countingIdlingResource)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: <?xml version="1.0" encoding="utf-8"?>
  prefs: []
  type: TYPE_NORMAL
- en: <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="match_parent"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="match_parent"
  prefs: []
  type: TYPE_NORMAL
- en: android:orientation="vertical">
  prefs: []
  type: TYPE_NORMAL
- en: <Button
  prefs: []
  type: TYPE_NORMAL
- en: android:id="@+id/activity_1_button"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_gravity="center"
  prefs: []
  type: TYPE_NORMAL
- en: android:text="@string/press_me" />
  prefs: []
  type: TYPE_NORMAL
- en: </LinearLayout>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: <?xml version="1.0" encoding="utf-8"?>
  prefs: []
  type: TYPE_NORMAL
- en: <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="match_parent"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="match_parent"
  prefs: []
  type: TYPE_NORMAL
- en: android:orientation="vertical">
  prefs: []
  type: TYPE_NORMAL
- en: <TextView
  prefs: []
  type: TYPE_NORMAL
- en: android:id="@+id/activity_2_text_view"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_width="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_height="wrap_content"
  prefs: []
  type: TYPE_NORMAL
- en: android:layout_gravity="center" />
  prefs: []
  type: TYPE_NORMAL
- en: </LinearLayout>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'class Activity1 : AppCompatActivity() {'
  prefs: []
  type: TYPE_NORMAL
- en: 'override fun onCreate(savedInstanceState: Bundle?) {'
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate(savedInstanceState)
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.activity_1)
  prefs: []
  type: TYPE_NORMAL
- en: findViewById<Button>(R.id.activity_1_button)
  prefs: []
  type: TYPE_NORMAL
- en: .setOnClickListener {
  prefs: []
  type: TYPE_NORMAL
- en: (application as MyApplication).synchronizer
  prefs: []
  type: TYPE_NORMAL
- en: .executeAfterDelay {
  prefs: []
  type: TYPE_NORMAL
- en: startActivity(Activity2.newIntent(this, it))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'class Activity2 : AppCompatActivity() {'
  prefs: []
  type: TYPE_NORMAL
- en: companion object {
  prefs: []
  type: TYPE_NORMAL
- en: private const val EXTRA_SECONDS = "extra_seconds"
  prefs: []
  type: TYPE_NORMAL
- en: 'fun newIntent(context: Context, seconds: Int) ='
  prefs: []
  type: TYPE_NORMAL
- en: Intent(context, Activity2::class.java).putExtra(
  prefs: []
  type: TYPE_NORMAL
- en: EXTRA_SECONDS, seconds
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'override fun onCreate(savedInstanceState: Bundle?) {'
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate(savedInstanceState)
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.activity_2)
  prefs: []
  type: TYPE_NORMAL
- en: findViewById<TextView>(R.id.activity_2_text_view).text =
  prefs: []
  type: TYPE_NORMAL
- en: getString(R.string.opened_after_x_seconds,               intent.getIntExtra(EXTRA_SECONDS,
    0))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '@RunWith(AndroidJUnit4::class)'
  prefs: []
  type: TYPE_NORMAL
- en: '@LargeTest'
  prefs: []
  type: TYPE_NORMAL
- en: class FlowTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@JvmField'
  prefs: []
  type: TYPE_NORMAL
- en: '@Rule'
  prefs: []
  type: TYPE_NORMAL
- en: 'var activityRule: ActivityTestRule<Activity1> =       ActivityTestRule(Activity1::class.java)'
  prefs: []
  type: TYPE_NORMAL
- en: private val myApplication = getApplicationContext<MyApplication>()
  prefs: []
  type: TYPE_NORMAL
- en: '@Before'
  prefs: []
  type: TYPE_NORMAL
- en: fun setUp() {
  prefs: []
  type: TYPE_NORMAL
- en: IdlingRegistry.getInstance().register(myApplication           .countingIdlingResource)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun verifyFlow() {
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.activity_1_button)).perform(click())
  prefs: []
  type: TYPE_NORMAL
- en: onView(withId(R.id.activity_2_text_view))          .check(matches(withText(myApplication             .getString(R.string.opened_after_x_seconds,
    1))))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'class TestRandomizer(random: Random) : Randomizer(random) {'
  prefs: []
  type: TYPE_NORMAL
- en: 'override fun getTimeToWait(): Int {'
  prefs: []
  type: TYPE_NORMAL
- en: return 1
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'open class MyApplication : Application() {'
  prefs: []
  type: TYPE_NORMAL
- en: val countingIdlingResource =       CountingIdlingResource("Timer resource")
  prefs: []
  type: TYPE_NORMAL
- en: 'lateinit var synchronizer: Synchronizer'
  prefs: []
  type: TYPE_NORMAL
- en: override fun onCreate() {
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate()
  prefs: []
  type: TYPE_NORMAL
- en: synchronizer = Synchronizer(createRandomizer(), Timer(),           countingIdlingResource)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: open fun createRandomizer() = Randomizer(Random())
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'class TestMyApplication : MyApplication() {'
  prefs: []
  type: TYPE_NORMAL
- en: 'override fun createRandomizer(): Randomizer {'
  prefs: []
  type: TYPE_NORMAL
- en: return TestRandomizer(Random())
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'class MyApplicationTestRunner : AndroidJUnitRunner() {'
  prefs: []
  type: TYPE_NORMAL
- en: '@Throws(Exception::class)'
  prefs: []
  type: TYPE_NORMAL
- en: override fun newApplication(
  prefs: []
  type: TYPE_NORMAL
- en: 'cl: ClassLoader?,'
  prefs: []
  type: TYPE_NORMAL
- en: 'className: String?,'
  prefs: []
  type: TYPE_NORMAL
- en: 'context: Context?'
  prefs: []
  type: TYPE_NORMAL
- en: '): Application? {'
  prefs: []
  type: TYPE_NORMAL
- en: return super.newApplication(cl,           TestMyApplication::class.java.name,
    context)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: android {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: defaultConfig {
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: testInstrumentationRunner            "com.android.testable.myapplication            .MyApplicationTestRunner"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: testImplementation 'junit:junit:4.13.1'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: class Adder {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun sum(n: Int): Int = 0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: class AdderTest {
  prefs: []
  type: TYPE_NORMAL
- en: private val adder = Adder()
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun sumSuccess() {
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(1, adder.sum(1))
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(3, adder.sum(2))
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(55, adder.sum(10))
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(210, adder.sum(20))
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(2305843008139952128L, adder.sum(Int.MAX_VALUE))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: fun sumError(){
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(-1, adder.sum(0))
  prefs: []
  type: TYPE_NORMAL
- en: assertEquals(-1, adder.sum(-1))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: class Adder {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun sum(n: Int): Long {'
  prefs: []
  type: TYPE_NORMAL
- en: var result = 0L
  prefs: []
  type: TYPE_NORMAL
- en: for (i in 1..n) {
  prefs: []
  type: TYPE_NORMAL
- en: result += i
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return result
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: class Adder {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun sum(n: Int): Long {'
  prefs: []
  type: TYPE_NORMAL
- en: return (n * (n.toLong() + 1)) / 2
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: class Adder {
  prefs: []
  type: TYPE_NORMAL
- en: 'fun sum(n: Int): Long {'
  prefs: []
  type: TYPE_NORMAL
- en: return if (n > 0) (n * (n.toLong() + 1)) / 2 else -1
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the tests now, we should see them all passing, similar to the following figure:![Figure
    9.12: Passing tests for Exercise 9.04'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B15216_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: Passing tests for Exercise 9.04'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have applied the concept of TDD to a very small example
    to demonstrate how the technique can be used. We have observed how starting from
    skeleton code, we can create a suite of tests to verify our conditions, and how
    by constantly running tests, we improved the code until a point where all the
    tests pass. As you have probably noticed, the concept isn't an intuitive one.
    Some developers find it hard to define how big skeleton code should be in order
    to start creating the test cases, while others, out of habit, focus on writing
    the code first and then developing the test. In either case, developers will need
    a lot of practice with the technique until it's properly mastered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Developing with TDD'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the TDD approach, develop an application that contains three activities
    and works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In activity 1, you will display a numeric `EditText` element and a button. When
    the button is clicked, the number in `EditText` will be passed to activity 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity 2 will generate a list of items asynchronously. The number of items
    will be represented by the number passed from activity 1\. You can use the `Timer`
    class with a delay of 1 second. Each item in the list will display the text `Item
    x`. `x` is the position in the list. When an item is clicked, you should pass
    the clicked item to activity 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity 3 will display the text `You clicked y`. `y` is the text of the item
    the user has clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tests the app will have will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests with Mockito and `mockito-kotlin` annotated with `@SmallTest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests with Robolectric and Espresso annotated with `@MediumTest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI tests with Espresso annotated with `@LargeTest` and using the Robot pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the test commands from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to complete this activity, you need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need Android Studio 4.1.1 or higher with Kotlin 1.4.21 or higher for
    the Parcelize Kotlin plugin
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the three activities and the UI for each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `androidTest` folder, create three robots, one for each activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Robot 1 will contain the interaction with `EditText` and the button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robot 2 will assert the number of items on the screen and interaction with an
    item in the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robot 3 will assert the text displayed in `TextView`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an instrumented test class that will have one test method using the preceding
    robots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `Application` class that will hold instances to all the classes that
    will be unit tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three classes representing integration tests, one for each of the activities.
    Each of these classes will contain one test method for the interactions and data
    loading. Each integration test will assert the intents passed between the activities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that will provide the text required for the UI. It will have
    a reference to a `Context` object and will contain two methods that will provide
    the text for the UI, which will return an empty string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the test for the preceding class in which the two methods are tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the class in order for the preceding tests to pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that will be responsible for loading the list in `Activity2`
    and provide an empty method for loading. The class will have a reference to the
    timer and the idling resource. Here, you should also create a data class that
    will represent the model for `RecyclerView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a unit test for the preceding class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the implementation for the preceding class and run the unit tests until
    they pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Application` class, instantiate the classes that were unit tested and
    start using them in your activities. Do this until your integration tests pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide `IntegrationTestApplication`, which will return a new implementation
    of the class responsible for loading. This is to avoid making your integration
    test for activity 2 wait until loading is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide `UiTestApplication`, which will again reduce the loading time of your
    models and connect the idling resource to Espresso. Implement the remaining work
    in order for the UI test to pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the different types of testing and the frameworks
    available for implementing these tests. We also took a look at the testing environment
    and how to structure it for each environment, as well as structuring your code
    in multiple components that can be individually unit tested. We analyzed different
    ways to test code, how we should approach testing, and how, by looking at different
    test results, we can improve our code. With TDD, we learned that by starting with
    testing, we can write our code faster and ensure it is less error-prone. The activity
    is where all these concepts came together into building a simple Android application,
    and we can observe how, by adding tests, the development time increases, but this
    pays off in the long term by eliminating possible bugs that appear when the code
    is modified.
  prefs: []
  type: TYPE_NORMAL
- en: The frameworks we have studied are some of the most common ones, but there are
    others that build on top of these and are used by developers in their projects,
    including mockk (a mocking library designed for Kotlin that takes advantage of
    a lot of the features of the language), Barista (written on top of Espresso and
    simplifies the syntax of UI tests), screenshot tests (which take screenshots of
    your UI tests and compare them to verify no bugs were introduced), UIAutomator,
    and monkeyrunner (which executes UI tests without requiring access to the application's
    code, but are written on top of it), Spoon (allows UI tests to be executed in
    parallel on multiple emulators to reduce time on testing), and Firebase Test Lab
    (allows tests to be executed in the cloud).
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of all the concepts presented here as building blocks that fit into two
    processes present in the software engineering world: Automation and continuous
    integration. Automation takes redundant and repetitive work out of the hands of
    developers and puts it into the hands of machines. Instead of having a team of
    quality assurance people testing your application to make sure the requirements
    are met, you can instruct a machine through a variety of tests and test cases
    to test the application instead and just have one person reviewing the results
    of the tests. Continuous integration builds on the concept of automation in order
    to verify your code the moment you submit it for review from other developers.
    A project with continuous integration would have a setup along the following lines:
    A developer submits work for review in a source control repository such as GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: A machine in the cloud would then start executing the tests for the entire project,
    making sure that nothing was broken and the developer can move on to a new task.
    If the tests pass, then the rest of the developers can review the code, and when
    it is correct, it can be merged and a new build can be created in the cloud and
    distributed to the rest of the team and the testers. All of this takes place while
    the initial developer can safely work on something else. If anything fails in
    the process, then they can pause the new task and go and address any issues in
    their work. The continuous integration process can then be expanded into continuous
    delivery, where similar automation can be set up when preparing a submission into
    Google Play that can be handled almost entirely by machines with minor involvement
    from developers. In the chapters that follow, you will learn about how to organize
    your code when building more complex applications that use the storage capabilities
    of the device and connect to the cloud to request data. Each of those components
    can be individually unit tested and you can apply integration tests to assert
    a successful integration of multiple components.
  prefs: []
  type: TYPE_NORMAL
