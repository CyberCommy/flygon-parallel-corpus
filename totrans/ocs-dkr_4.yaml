- en: Chapter 4. Automation and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we now know how to set up Docker in our development environments,
    are comfortable with the Docker commands, and have a good idea about the kind
    of situations Docker is suitable for. We also have an idea on how to configure
    Docker and its containers to suit all our needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the various usage patterns that will help
    us deploy our web applications in production environments. We will begin with
    Docker's remote API because logging in to a production server and running commands
    is always considered dangerous. So, it is best to run an application that monitors
    and orchestrates the containers in a host. There are a host of orchestration tools
    available for Docker today, and with the announcement of v1.0, Docker also announced
    a new project, **libswarm**, which gives a standard interface to manage and orchestrate
    distributed systems, which will be another topic we will be delving into.
  prefs: []
  type: TYPE_NORMAL
- en: Docker developers recommend running only one process per container. This is
    difficult if you want to inspect an already running container. We will look at
    a command that allows us to inject a process into an already running container.
  prefs: []
  type: TYPE_NORMAL
- en: As your organization grows, so does the load, and you will need to start thinking
    about scaling. Docker in itself is meant to be used in a single host, but by using
    a host of tools such as `etcd` and `coreos`, you can easily run a bunch of Docker
    hosts in a cluster and discover every other container in that cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every organization that has a web application running in production knows the
    importance of security. In this chapter, we are going to talk about the security
    aspects with respect to not only the `docker` daemon, but also the various Linux
    features used by Docker. To summarize, in this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker remote API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting processes into containers with the Docker exec command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker remote API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker binary can run both as a client and as a daemon. When Docker is run
    as a daemon, it attaches itself to a Unix socket at `unix:///var/run/docker.sock`
    by default (this can be changed when starting docker, of course) and accepts commands
    over REST. The same Docker binary can then be used to run all the other commands
    (which is nothing but the client making REST calls to the `docker` daemon).
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram of the `docker` daemon is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker remote API](graphics/4787OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This section will mainly be explained with examples as we have already encountered
    the working of these operations when we looked at the Docker commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test these APIs, run the `docker` daemon at a TCP port like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is not going to be a reference guide, since we have already covered the
    features available with Docker when we disussed Docker commands in [Chapter 2](ch02.html
    "Chapter 2. Docker CLI and Dockerfile"), *Docker CLI and Dockerfile*. Instead,
    we will be covering a select few APIs and you can look up the rest at [docs.docker.com/reference/api/docker_remote_api](http://docs.docker.com/reference/api/docker_remote_api).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let''s ensure that the `docker` daemon is responding to our
    requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Alright, everything is fine. Let's get going.
  prefs: []
  type: TYPE_NORMAL
- en: Remote API for containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's first look at the a few endpoints available that help create and manage
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: The create command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `create` command creates a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `curl` utility is a simple Unix utility that can be used to construct HTTP
    requests and analyze responses.
  prefs: []
  type: TYPE_NORMAL
- en: Here we make a `POST` request to the `/containers/create` endpoint and pass
    a `JSON` object containing the details of the image we want the container to be
    based upon and the command we expect the container to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type of request: POST'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JSON` data sent along with the `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Type | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| `JSON` | Describes the configuration of the container to start |'
  prefs: []
  type: TYPE_TB
- en: 'Query parameters for the POST request:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Type | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| `String` | This assigns a name to the container. It must match the `/?[a-zA-Z0-9_-]+`
    regular expression. |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows the status code of the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Status code | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| No error |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| No such container |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Impossible to attach (container not running) |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| Internal server error |'
  prefs: []
  type: TYPE_TB
- en: The list command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `list` command gets a list of containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a `GET` request API. A request to `/containers/json` will return a `JSON`
    response containing a list of containers that fulfill the criteria. Here, passing
    the `all` query parameter will list containers that are not running as well. The
    `limit` parameter is the number of containers that will be listed in the response.
  prefs: []
  type: TYPE_NORMAL
- en: There are query parameters that you can provide with these API calls, which
    can fine-tune the responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type of Request: GET'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Type | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| 1/`True`/`true` or 0/`False`/`false` | This tells whether all containers
    should be shown. Only running containers are shown by default. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| `Integer` | This shows the last [*n*] containers, including non running containers.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '| `Container` `ID` | This only shows containers started since [x], including
    non running ones. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| `Container` `ID` | This only shows containers started before [x], including
    non running ones. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| 1/`True`/`true` or 0/`False`/`false` | This tells whether container sizes
    should be shown in the responses or not. |'
  prefs: []
  type: TYPE_TB
- en: 'Status codes of the response follow relevant **Request** **For** **Comments**
    (**RFC**) 2616:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Status code | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| No error |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| Bad parameter and client error |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| Server error |'
  prefs: []
  type: TYPE_TB
- en: Other endpoints for containers can be read about at [docs.docker.com/reference/api/docker_remote_api_v1.13/#21-containers](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#21-containers).
  prefs: []
  type: TYPE_NORMAL
- en: Remote API for images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to containers, there are APIs to build and manage images as well.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the local Docker images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command lists the local images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a `GET` request API. A request to `/images/json` will return a `JSON`
    response containing a list that contains details of the images that fulfill the
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type of request: GET'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Type | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| 1/`True`/`true` or 0/`False`/`false` | This tells whether even intermediary
    containers should be shown. False by default. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '| `JSON` | These are used to provide a filtered list of images. |'
  prefs: []
  type: TYPE_TB
- en: Other endpoints for images can be read about at [docs.docker.com/reference/api/docker_remote_api_v1.13/#22-images](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#22-images).
  prefs: []
  type: TYPE_NORMAL
- en: Other operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are other APIs too, such as the ping API we checked at the beginning of
    this section. Some of them are explored in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting system-wide information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command gets the system-wide information on Docker. This is the
    endpoint that handles the `docker info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Committing an image from a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command commits an image from a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Commit is a `POST` request to the `/commit` parameter with data about the image
    it's based on and the command associated with the image that will be created on
    commit. Key pieces of information include the `container` `ID` parameter to commit,
    the commit message, and the repository it belongs to, all of which are passed
    as query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type of request: POST'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JSON` data sent along with the `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Type | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| `JSON` | This describes the configuration of the container to commit |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows query parameters for the `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Type | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| `Container ID` | The `ID` of the container you intend to commit |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| `String` | The repository to create the image in |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| `String` | The tag for the new image |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| `String` | Commit message |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| `String` | Author information |'
  prefs: []
  type: TYPE_TB
- en: 'The following table shows the status code of the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Status code | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| No error |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '| No such container |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '| Internal server error |'
  prefs: []
  type: TYPE_TB
- en: Saving the image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Get a tarball backup of all the images and metadata of a repository from the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will take some time, as the image has to be first compressed into a tarball
    and then streamed, but then it will be saved in the tar archive.
  prefs: []
  type: TYPE_NORMAL
- en: Other endpoints can be read about at [docs.docker.com/reference/api/docker_remote_api_v1.13/#23-misc](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#23-misc).
  prefs: []
  type: TYPE_NORMAL
- en: How docker run works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have realized that every Docker command that we run is nothing
    but a series of RESTful operations carried out by the client, let''s enhance our
    understanding of what happens when you run a `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: To create an API, `/containers/``create` parameter is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the status code of the response is 404, it means the image doesn't exist.
    Try to pull the image using `/images/create` parameter and go back to step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the `ID` of the created container and start it using `/containers/(id)/start`
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The query parameters to these API calls will depend on the flags and arguments
    passed to the `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting processes into containers with the Docker execute command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of your explorations of Docker, you may have wondered whether
    the single command per container rule enforced by Docker is limiting its capabilities.
    In fact, you might be forgiven for assuming that a Docker container runs only
    a single process. But no! A container can run any number of processes, but can
    only start with one command and the container lives as long as the process associated
    with the command does. This restriction has been enforced because Docker believes
    in the philosophy of one app per container. Instead of loading everything in a
    single container, a typical Docker-reliant application architecture will consist
    of multiple containers, each running a specialized service, all linked together.
    This helps keep the container light, makes debugging easier, reduces the attack
    vectors, and ensures that if one service goes down, others aren't affected.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, however, you might need to look into the container while it is running.
    Over time, a number of approaches have been taken by the Docker community to debug
    running containers. Some members loaded SSH into the container and ran a process
    management solution such as **supervisor** to run the SSH + application server.
    Then came tools such as **nsinit** and **nsenter** that helped spawn a shell in
    the namespace the container was running in. However, all of these solutions were
    hacks. So with v1.3, Docker decided to provide the `docker exec` command, a safe
    alternative that could debug running containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker exec` command, allows a user to spawn a process inside their Docker
    container via the Docker API and CLI, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first command starts a simple file server container. The container is sent
    to the background with the `-d` option. In the second command, with `docker` `exec`,
    we log in to the container by creating a bash process inside it. Now we will be
    able to inspect the container, read the log (if we have logged in to a file),
    run diagnostics (if the need to inspect arises because of a bug), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker still hasn't moved from its one-app-per-container philosophy. The `docker
    exec` command exists just to provide us with a way to inspect containers, which
    otherwise would've required workarounds or hacks.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker assigns an IP to a container dynamically from a pool of available addresses.
    While this is good in some ways, it creates a problem when you are running containers
    that need to communicate with each other. You just cannot know when building an
    image what its IP address is going to be. Your first instinct might be to start
    the containers, then log in to them (via `docker` `exec`), and set the IP addresses
    of the other containers manually. But remember, this IP address can change when
    a container restarts, so then you would have to manually log in to each container
    and enter the new IP address. Could there be a better way? Yes, there is.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery is a collection of everything that needs to be done to let
    services know how to find and communicate with other services. Under service discovery,
    containers do not know their peers when they are just started. Instead, they discover
    them dynamically. This should work both when the containers are in the same host
    as well as when they are in a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two techniques to achieve service discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: Using default Docker features such as names and links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a dedicated service such as `Etcd` or `Consul`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker names, links, and ambassador containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to link conatiners in the section titled *Linking Containers*
    in [Chapter 3](ch03.html "Chapter 3. Configuring Docker Containers"), *Configuring
    Docker Containers*. To refresh your memory, this is how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Using links to make containers visible to each other
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The use of links is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using links to make containers visible to each other](graphics/4787OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Link allows a container to connect to another container without any need to
    hardcode its IP address. It is achieved by inserting the first container's IP
    address in `/etc/hosts` when starting the second container.
  prefs: []
  type: TYPE_NORMAL
- en: 'A link can be specified when starting the container using the `--link` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can find out more about linking in [Chapter 3](ch03.html "Chapter 3. Configuring
    Docker Containers"), *Configuring Docker Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-host linking using ambassador containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following diagram represents cross-host linking using ambassador containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-host linking using ambassador containers](graphics/4787OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ambassador containers are used to link containers across hosts. In this architecture,
    you can restart/replace the database container without needing to restart the
    application container.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about ambassador containers in [Chapter 3](ch03.html "Chapter 3. Configuring
    Docker Containers"), *Configuring Docker Containers*.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery using etcd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why do we need specialized solutions for service discovery? While ambassador
    containers and links solve the problem of finding containers without needing to
    know their IP addresses, they do have one fatal flaw. You still need to manually
    monitor the health of the containers.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where you have a cluster of backend servers and frontend
    servers linked to them via ambassador containers. If one of the servers goes down,
    the frontend servers still keep trying to connect to the backend server, because
    as far as they are concerned, that is the only available backend server, which
    is of course wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Modern service discovery solutions such as `etcd`, `Consul`, and `doozerd` do
    more than merely providing the right IP addresses and ports. They are, in effect,
    distributed key-value stores, but are fault tolerant and consistent and handle
    master election in the event of failure. They can even act as lock servers.
  prefs: []
  type: TYPE_NORMAL
- en: The `etcd` service is an open source, distributed key-value store developed
    by **CoreOS**. In a cluster, the `etcd` client runs on each machine in the cluster.
    The `etcd` service gracefully handles master election during network partitions
    and the loss of the current master.
  prefs: []
  type: TYPE_NORMAL
- en: Your applications can read and write data to the `etcd` service. Common examples
    for `etcd` services are storing database connection details, cache settings, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Features of the `etcd` service are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple, curlable API (HTTP + JSON)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional **Secure** **Sockets** **Layer** (**SSL**) client certificate authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys support **Time** **To** **Live** (**TTL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Consul` service is a great alternative to the `etcd` service. There is
    no reason why one should be chosen over the other. This section is just meant
    to introduce you to the concept of service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `etcd` service in two stages as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We register our services with the `etcd` service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do a lookup to find services thus registered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following diagram shows the `etcd` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Service discovery using etcd](graphics/4787OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This seems like a simple task to do, but building a solution that is fault tolerant
    and consistent is not simple. You will also need to be notified in case of failure
    of a service. If you run the service discovery solution itself in a naive centralized
    manner, it might become a single point of failure. So, all instances in a cluster
    of service discovery servers need to be synchronized with the right answer, which
    makes for interesting approaches. The team at CoreOS developed a consensus algorithm
    called **Raft** to solve this problem. You can read more about it at [http://raftconsensus.github.io](http://raftconsensus.github.io).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example to get a lay of the land. In this example, we will
    run the `etcd` server in a container and see how easy it is to register a service
    and discover it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Run the `etcd` server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Once the image is downloaded and the server starts, run the following
    command to register a message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is nothing but a `PUT` request to the server at the `/v2/keys/message`
    path (`message` being the key here).
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Get the key back with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can go ahead and experiment by changing the value, trying an invalid key,
    and so on. You will find that the responses are in `JSON`, which means you can
    easily integrate it with your application without needing to use any libraries.
  prefs: []
  type: TYPE_NORMAL
- en: But how would I use it in my application? If your application needs to run multiple
    services, they can be connected together with links and ambassador containers,
    but if one of them becomes unavailable or needs to be redeployed, a lot of work
    needs to be done to restore the links.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine that your services use the `etcd` service. Every service registers
    its IP address and port number against its name and discovers other services by
    their names (that are constant). Now, if a container restarts because of a crash/redeployment,
    the new container will register against the modified IP address. This will update
    the value that the `etcd` service returns for subsequent discovery requests. However,
    this means that a single `etcd` server can also be a single point of failure.
    The solution for this is to run a cluster of `etcd` servers. This is where the
    Raft consensus algorithm, developed by CoreOS (the team that created `etcd` service),
    comes in. A complete example of an application service being deployed with the
    `etcd` service can be found at [http://jasonwilder.com/blog/2014/07/15/docker-service-discovery/](http://jasonwilder.com/blog/2014/07/15/docker-service-discovery/)
  prefs: []
  type: TYPE_NORMAL
- en: Docker Orchestration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as you go beyond simple applications to complex architectures, you will
    start using tools and services such as `etcd`, `consul`, and `serf`, and you will
    notice that all of them come with their own set of APIs, even though they have
    overlapping features. If you set up your infrastructure to one set of tooling
    and find a need to switch, it takes considerable effort, sometimes even changes
    in the code, to switch vendors. Such situations can lead to vendor lock-in, which
    would ruin a promising ecosystem that Docker has managed to create. To provide
    a standard interface to these service providers so that they can almost be used
    as plug-and-play solutions, Docker has released a suite of orchestration services.
    In this section, we will take a look at them. Note, however, that at the time
    of writing this book, these projects (Machine, Swarm, and Compose) are still in
    Alpha and in active development.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Machine aims to provide a single command to take you from zero-to-Docker
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Before Docker Machine, if you intended to start working with Docker on a new
    host, be it a virtual machine or a remote host in an infrastructure provider such
    as **Amazon** **Web** **Services** (**AWS**) or Digital Ocean, you would have
    to log in to the instance, and run the setup and configuration commands specific
    to the operating system running in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Docker Machine, whether provisioning the `docker` daemon on a new laptop,
    on virtual machines in the data center, or on a public cloud instance, the same,
    single command gets the target host ready to run Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Then you can manage multiple Docker hosts from the same interface regardless
    of their location and run any Docker command on them.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from this, the machine also has pluggable backends, which makes adding
    support to infrastructure providers easy, while retaining the common user-facing
    API. Machine ships by default with drivers to provision Docker locally with Virtualbox
    as well as remotely on Digital Ocean instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Docker Machine is a separate project from the Docker Engine. You can
    find the updated details about this project on its Github page at [https://github.com/docker/machine](https://github.com/docker/machine).
  prefs: []
  type: TYPE_NORMAL
- en: Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Swarm** is a native clustering solution provided by Docker. It takes Docker
    Engine and extends it to enable you to work on a cluster of containers. With Swarm,
    you can manage a resource pool of Docker hosts and schedule containers to run
    transparently on top, automatically managing workload and providing failover services.'
  prefs: []
  type: TYPE_NORMAL
- en: To schedule, it takes the container's resource requirements, looks at the available
    resources in the hosts, and tries to optimize placement of workloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you wanted to schedule a Redis container requiring 1 GB of
    memory, here is how you would schedule it with Swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from resource scheduling, Swarm also supports policy-based scheduling
    with standard and custom constraints. For instance, if you want to run your **MySQL**
    container on an SSD-backed host (in order to ensure better write and read performance),
    you can specify that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In addition to all of this, Swarm provides high-availability and failover. It
    continuously monitors the health of the containers, and if one were to suffer
    an outage, automatically rebalances by moving and restarting the Docker containers
    from the failed host to a new one. The best part is that regardless of whether
    you are just starting with one instance or have scaled up to 100 instances, the
    interface remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Docker Machine, Docker Swarm is in Alpha and is continuously evolving.
    Head over to its repository on Github to know more about it: [https://github.com/docker/swarm/](https://github.com/docker/swarm/).'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Compose** is the last piece of the puzzle. With Docker Machine, we have provisioned
    the Docker daemons. With Docker Swarm, we can rest assured that we''ll be able
    to control our containers from anywhere and that they''ll remain available if
    there are any failures. Compose helps us compose our distributed applications
    on top of this cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing this to something we already know might help us understand how all
    of this works together. Docker Machine acts just as an operating system acts with
    respect to a program. It provides a place for containers to run. Docker Swarm
    acts like a programming language runtime to a program. It manages resources, provides
    exception handling, and so on for containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose is more like an IDE, or a language syntax, that provides a way
    to express what the program needs to do. With Compose, we specify how our distributed
    apps must run in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use Docker Compose by writing a `YAML` file to declare the configurations
    and states of our multi-container app. For example, let''s assume we have a Python
    app that uses a Redis DB. Here is how we would write the `YAML` file for Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we defined two applications. One is a Python application
    that needs to be built from the Dockerfile in the current directory. It has a
    port (`5000`) exposed and has either a volume or a piece of code bind mounted
    to the current working directory. It also has an environment variable defined
    and is linked to the second application container, `redis`. The second container
    uses the `redis` container from the Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the configuration defined, we can start both the containers with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With this single command, the Python container gets built using the Dockerfile,
    and the `redis` image gets pulled from the registry. However, the `redis` container
    is started first, because of the links directive in the Python container's specification
    and because the Python container depends on it.
  prefs: []
  type: TYPE_NORMAL
- en: As with Docker Machine and Docker Swarm, Docker Compose is a "work in progress"
    and its development can be tracked at [https://github.com/docker/docker/issues/9459](https://github.com/docker/docker/issues/9459).
  prefs: []
  type: TYPE_NORMAL
- en: More information about swarm can be found at [http://blog.docker.com/2014/12/announcing-docker-machine-swarm-and-compose-for-orchestrating-distributed-apps/](http://blog.docker.com/2014/12/announcing-docker-machine-swarm-and-compose-for-orchestrating-distributed-apps/).
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is of prime importance when it comes to deciding whether to invest
    in a technology, especially when that technology has implications on the infrastructure
    and workflow. Docker containers are mostly secure, and since Docker doesn't interfere
    with other systems, you can use additional security measures to harden the security
    around the `docker` daemon. It is better to run the `docker` daemon in a dedicated
    host and run other services as containers (except services such as `ssh`, `cron`,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss Kernel features used in Docker that are pertinent
    to security. We will also consider the `docker` daemon itself as a possible attack
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: Image credit [http://xkcd.com/424/](http://xkcd.com/424/)
  prefs: []
  type: TYPE_NORMAL
- en: '![Security](graphics/4787OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Kernel namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces provide sandboxing to containers. When a container is started, Docker
    creates a set of namespaces and cgroups for the container. Thus, a container that
    belongs to a particular namespace cannot see or affect the behavior of another
    container that belongs to other namespaces or the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains containers in Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Kernel namespaces](graphics/4787OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The kernel namespace also creates a network stack for the container, which can
    be configured to the last detail. The default Docker network setup resembles a
    simple network, with the host acting as the router and the `docker0` bridge acting
    as an Ethernet switch.
  prefs: []
  type: TYPE_NORMAL
- en: The namespace feature is modeled after OpenVZ, which is an operating system
    level virtualization technology based on the Linux kernel and operating system.
    OpenVZ is what is used in most of the cheap VPSes available in market today. It
    has been around since 2005, and the namespace feature was added to the kernel
    in 2008\. It has been subjected to production use since then, so it can be called
    "battle hardened."
  prefs: []
  type: TYPE_NORMAL
- en: Control groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Control groups provide resource management features. Although this has nothing
    to do with privileges, it is relevant to security because of its potential to
    act as the first line of defence against denial-of-service attacks. Control groups
    have been around for quite some time as well, so can be considered safe for production
    use.
  prefs: []
  type: TYPE_NORMAL
- en: For further reading for control groups, refer to [https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt).
  prefs: []
  type: TYPE_NORMAL
- en: The root in a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `root` command in a container is stripped of many privileges. For instance,
    you cannot mount a device using the `mount` command by default. On the other end
    of the spectrum, running a container with the `--privileged flag` flag will give
    the `root` user in the container complete access to all the privileges that the
    root user in the host does. How does docker achieve this?
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the standard `root` user as someone having a wide range of
    capabilities. One of them, is the `net_bind_service` service that binds to any
    port (even below 1024). Another, the `cap_sys_admin` service, is what is needed
    to mount physical drives. These are called capabilities, tokens used by a process
    to prove that it is allowed to perform an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker containers are started with a reduced capability set. Hence, you will
    find that you can perform some root operations but not others. Specifically, it
    is not possible for a `root` user in an unprivileged container to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mount/unmount devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing raw sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem operations such as creating device nodes and changing file ownerships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before v1.2, if you needed to use any capability that was blacklisted, the only
    solution was to run the container with the `--privileged` flag. But v1.2 introduced
    three new flags, `--cap-add`, `--cap-drop`, and `--device`, to aid us to run a
    container that needed specific capabilities without compromising on the security
    of the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--cap-add` flag adds a capability to the container. For example, let''s
    change the status of a container''s interface (which requires the `NET_ADMIN`
    service capability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--cap-drop` flag blacklists a capability in a container. For example,
    let''s blacklist all but the `chown` command in a container, and then try to add
    a user. This will fail as it needs the `CAP_CHOWN` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `--devices` flag is used to mount an external/virtual device directly on
    the container. Before v1.2, we had to mount it on the host and bind mount with
    the `-v` flag in a `--privileged` container. With the `--device` flag, you can
    now use a device in a container without needing to use the `--privileged` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to mount the DVD-RW device of your laptop on the container, run
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: More information about the flags can be found at [http://blog.docker.com/tag/docker-1-2/](http://blog.docker.com/tag/docker-1-2/).
  prefs: []
  type: TYPE_NORMAL
- en: 'There were additional improvements introduced with the Docker 1.3 release.
    A `--security-opts` flag was added to the CLI, which allows you to set custom
    **SELinux** and **AppArmor** labels and profiles. For example, suppose you had
    a policy that allowed a container process to listen only to Apache ports. Assuming
    you had defined this policy in `svirt_apache`, you can apply it to the container
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: One of benefits of this feature is that users will be able to run Docker in
    Docker without having to use the `docker run --privileged` container on the kernels
    supporting SELinux or AppArmor. Not giving the running container all the host
    access rights as the `--privileged` container significantly reduces the surface
    area of potential threats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/](http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/).'
  prefs: []
  type: TYPE_NORMAL
- en: You can see the complete list of enabled capabilities at [https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template.go](https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template.go).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the inquisitive mind, the complete list of all available capabilities can
    be found in the Linux manual page for capabilities. It can also be found online
    at [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: Docker daemon attack surface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker` daemon takes care of creating and managing containers, which includes
    creating filesystems, assigning IP addresses, routing packets, managing processes,
    and many more tasks that require root privileges. So it is imperative to start
    the daemon as a `sudo` user. This is the reason the `docker` daemon binds itself
    to a Unix socket by default, instead of a TCP socket, which it used until v5.2.
  prefs: []
  type: TYPE_NORMAL
- en: One of the end goals of Docker is to be able to run even the daemon as a non-root
    user, without affecting its functionalities, and delegate operations that do require
    root (such as filesystem operations and networking) to a dedicated subprocess
    with elevated privileges.
  prefs: []
  type: TYPE_NORMAL
- en: If you do want to expose Docker's port to the outside world (to make use of
    the remote API), it is advised to ensure that only trusted clients are allowed
    access. One straightforward way is to secure Docker with SSL. You can find ways
    of setting this up at [https://docs.docker.com/articles/https](https://docs.docker.com/articles/https).
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s summarize some key security best practices when running Docker in
    your infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: Always run the `docker` daemon in a dedicated server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless you have a multiple-instance setup, run the `docker` daemon on a Unix
    socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take special care about bind mounting host directories as volumes as it is possible
    for a container to gain complete read-write access and perform irreversible operations
    in these directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have to bind to a TCP port, secure it with SSL-based authentication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid running processes with root privileges in your containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is absolutely no sane reason why you will ever need to run a privileged
    container in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider enabling AppArmor/SELinux profiles in the host. This enables you to
    add an additional layer of security to the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike virtual machines, all containers share the host's kernel. So it is important
    to keep the kernel updated with the latest security patches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the various tools, APIs, and practices that
    help us deploy our application in a Docker-based environment. Initially, we looked
    at the Remote API and realized that all Docker commands are nothing but a result
    of REST-based calls to the `docker` daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Then we saw how to inject processes to help debug running containers.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at various methods to achieve service discovery, both using native
    Docker features such as links, and with the help of specialized `config` stores
    such as the `etcd` services.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed various aspects of security when using Docker, the various
    kernel features it relies on, their reliability, and their implications on the
    security of the host the containers run on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking the approach of this chapter further,
    and checking out various open source projects. We will learn how to integrate
    or use them to fully realize the potential of Docker.
  prefs: []
  type: TYPE_NORMAL
