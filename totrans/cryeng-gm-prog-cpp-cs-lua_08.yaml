- en: Chapter 8. Multiplayer and Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the CryENGINE networking system, we can move on from single player games
    and create living worlds with large numbers of human players.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn the basics of the network system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize Remote Method Invocations (RMIs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialize flowing data over the network using aspects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The networking system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CryENGINE networking implementation is a flexible setup used to communicate
    with game servers and other clients.
  prefs: []
  type: TYPE_NORMAL
- en: All network messages are sent from an **independent networking thread** in order
    to avoid network updates being crippled by the game frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Network identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Locally, each entity is represented by an entity identifier (`entityId`). However,
    for network contexts, it is not viable to transmit these over the network as they
    are not guaranteed to point to the same entity on the remote client or server.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this, each game object is assigned a net object identifier represented
    by the `SNetObjectID` struct, which contains a simple wrapper for the identifier
    and its salt.
  prefs: []
  type: TYPE_NORMAL
- en: When writing game code that serializes entities and entity IDs across the network,
    we don't have to deal with `SNetObjectID` structs directly as the process of converting
    `entityId` to `SNetObjectID` (and back to `entityId` on the remote machine) is
    automatic.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure that your entity ID maps to the same entity on the remote machine,
    use the `eid` compression policy when serializing. Read more about policies and
    how to use them in the *Compression policies* section, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Net channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CryENGINE provides the `INetChannel` interface to represent an ongoing connection
    between two machines. For example, if client A and client B need to communicate
    with each other, a net channel is created on both machines to manage sent and
    received messages.
  prefs: []
  type: TYPE_NORMAL
- en: Each channel is referred to by using a channel identifier, which often proves
    useful to determine which client belongs to what machine. For example, to retrieve
    the player actor connected on a specific channel, we use `IActorSystem::GetActorByChannelId`.
  prefs: []
  type: TYPE_NORMAL
- en: Net nubs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All net channels are handled by the `INetNub` interface, which consists of one
    or more ports for packet-based communication.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a multiplayer game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To set up a multiplayer game, we'll need two computers running the same build
    of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two methods to create a server that remote clients can connect to.
    These are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dedicated server exists for the purpose of having a client that does not
    render or play back audio, to allow full focus on supporting a server without
    a local client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a dedicated server, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start `Bin32/DedicatedServer.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `map` followed by the name of the level you want to load, and then press
    *Enter*.![Dedicated server](img/5909_08_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launcher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to start a server via the Launcher, effectively allowing
    you to play with friends without having to launch a separate server application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a server via the Launcher, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start your Launcher application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `map <level name> s`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Appending `s` to the `map` command will tell the CryENGINE to load the level
    in a multiplayer context as the server. Leaving out `s` will still load the level,
    but in a single player state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Launcher](img/5909_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting to a server via the console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To connect to a server using the console, use the `connect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connect <ip> <port>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default connection port is 64089.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to set the IP address via the `cl_serveraddr` console variable,
    the port via `cl_serverport`, and then simply calling `connect`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that you can have multiple Launchers running simultaneously, which
    can be very useful when debugging multiplayer games.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging networked games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very useful console variable to use when debugging networked games is `netlog
    1`, which will result in the network system logging a lot more information about
    network issues and events in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Networking using game object extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Game objects have two methods of communicating over the network: RMIs and network
    serialization via `Aspects`. Essentially, RMIs allow for event-based data transmission
    over the network, whereas an aspect continuously synchronizes data as it is invalidated.'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to being able to communicate over the network, each game object has to
    be bound to the network by using the `IGameObject::BindToNetwork` function. This
    can be called from your `Init` implementation by `IGameObjectExtension`.
  prefs: []
  type: TYPE_NORMAL
- en: Remote Method Invocation (RMI)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Remote Method Invocation** (**RMI**) is used to invoke functions on a remote
    client or server. This is very useful for synchronizing a state over the network,
    for example, to let all clients know that the player named "Dude" just spawned,
    and should be moved to a specific location and orientation.'
  prefs: []
  type: TYPE_NORMAL
- en: RMI structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare an RMI, we can make use of the macros listed as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DECLARE_SERVER_RMI_NOATTACH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECLARE_CLIENT_RMI_NOATTACH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECLARE_SERVER_RMI_PREATTACH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECLARE_CLIENT_RMI_PREATTACH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECLARE_SERVER_RMI_POSTATTACH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DECLARE_CLIENT_RMI_POSTATTACH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last parameter specifies packet reliability, but is largely deprecated in
    the latest version of CryENGINE.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind which type of RMI you are exposing when it is created. For example,
    `DECLARE_CLIENT` is only used for functions that will be called on remote clients,
    whereas `DECLARE_SERVER` defines functions that will be called on the server,
    after being requested on a client.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The RMI declaration macros require three parameters to be supplied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function name**: This is the first parameter that determines the name of
    the method, and is what will be used for the function declaration and when invoking
    the RMI itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RMI parameters**: The RMI has to specify a struct containing all members
    that will be serialized along with the method. The struct must contain a function
    named `SerializeWith` which accepts one `TSerialize` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packet delivery reliability enum**: This is the last parameter that defines
    reliability of the packet delivery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three types of differences between the macros that we just saw:'
  prefs: []
  type: TYPE_NORMAL
- en: Attach type
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The attachment type defines when the RMI is attached during the network serialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOATTACH`: This is used when the RMI doesn''t rely on game object data, and
    can therefore be attached either prior to or after game object data serialization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PREATTACH`: In this type, the RMI will be attached before the game object
    data is serialized. It is used when the RMI needs to prepare for incoming data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTATTACH`: In this type, the RMI is attached after the game object''s data
    is serialized. It is used when the newly-received data is relevant to the RMI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server/client separation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you may have noticed from looking at the RMI declaration macros, an RMI cannot
    target both clients and servers at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we'll either have to decide which target should be able to
    run our function, or create one macro for each target.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very useful feature when dealing with server-authoritative game contexts,
    due to the continuous distinction between functions that can be remotely triggered
    on the server and clients.
  prefs: []
  type: TYPE_NORMAL
- en: Function definition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To define the RMI function, we can use the `IMPLEMENT_RMI` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro defines a function called when the RMI is invoked, with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`params`: This contains the deserialized data sent from the remote machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pNetChannel`: This is an `INetChannel` instance which describes the connection
    established between the source and target machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RMI example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate how to create a basic RMI, we're going to create an RMI to allow
    clients to request that an entity is repositioned. This will result in the server
    sending a `ClMoveEntity` RMI to all clients, notifying them of the new entity.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need to open our header file. This is where we'll define the RMI
    and our parameters. Start by creating a new struct called `SMoveEntityParams`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll then add three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EntityID entityId**: This is the identifier of the entity that we want to
    move'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vec3 position**: This determines which position the entity should be moved
    to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quat orientation**: This is used to set the rotation of the entity on spawn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After adding the parameters, we need to define the `SerializeWith` function
    inside our `SMoveEntityParams` struct. This will be called when sending data to
    the network, and again to receive the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The usage of the `eid` compression policy, is to be taken care of which makes
    sure that `entityId` points to the same entity. Refer to the *Network identifiers*
    section in this chapter for more information on why the policy is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined our RMI parameters, we''ll need to declare two RMIs:
    one for the client and one for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left now is for us to create the function implementations, which
    we can do in our CPP file by using the `IMPLEMENT_RMI` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines our `SvRequestMoveEntity` function, which will be called
    when a client does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Try to implement the `ClMoveEntity` function on your own. It should set the
    world transformation (`IEntity::SetWorldTM`) of the entity in the same manner
    as we did in `SvRequestMoveEntity`.
  prefs: []
  type: TYPE_NORMAL
- en: Network aspect serialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Game object extensions can implement the `IGameObjectExtension::NetSerialize`
    function, which is called to serialize data relevant to the extension across the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Aspects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To allow separation of data relevant to specific mechanics, the net serialization
    process exposes **Aspects**. When an aspect is declared as "dirty" (changed) on
    the server or a client, the network will trigger this for serialization and call
    the `NetSerialize` function with the specific aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark your aspect as dirty, call `IGameObject::ChangedNetworkState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will trigger `NetSerialize` to serialize your aspect, and send its data
    to the remote machine(s) which will then be deserialized in the same function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An aspect is considered "dirty" when its value has changed from what was last
    sent to remote client or server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to serialize a set of flags relevant to player input,
    we''ll create a new aspect and mark it as dirty whenever the input flags changes
    on the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TSerialize::EnumValue` is a specialized form of `TSerialize::Value` which
    calculates the minimum and maximum value of the enum, effectively functioning
    as a dynamic compression policy.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EnumValue` and compression policies should be used wherever possible, in order
    to reduce bandwidth usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the `eEA_GameClientF` aspect is marked as dirty on the client, the
    `NetSerialize` function will be called and will write the `m_inputFlags` variable
    value to the network.
  prefs: []
  type: TYPE_NORMAL
- en: When the data arrives on the remote client or server, the `NetSerialize` function
    will once again be called, but this time writes the value to the `m_inputFlags`
    variable so that the server is aware of the new input flags provided by the client.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aspects cannot support conditional serialization, and therefore each aspect
    has to serialize the same variables on each run. For example, if you serialized
    four floats during the first aspect serialization, you will always have to serialize
    four floats.
  prefs: []
  type: TYPE_NORMAL
- en: It's still possible to serialize complex objects, for example, we could write
    the length of an array and then iterate over it to read/write each object contained
    within the array.
  prefs: []
  type: TYPE_NORMAL
- en: Compression policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`TSerialize::Value` enables the ability to pass an additional parameter, the
    compression policy. This policy is used to determine what compression mechanics
    can be used to optimize network bandwidth when synchronizing the data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compression policies are defined in `Scripts/Network/CompressionPolicy.xml`.
    Examples of existing policies can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eid`: This is used when serializing the `entityId` identifiers across the
    network, and compares the game object''s `SNetObjectID` to obtain the correct
    `entityId` on the remote client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wrld`: This is used when serializing a `Vec3` struct that represents world
    coordinates. This may have to be tweaked for bigger levels, due to being capped
    at 4095 by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`colr`: This is used to serialize a `ColorF` struct across the network, allowing
    a floating point variable to represent values between 0 and 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: This is a specific implementation for Boolean, and cuts down on a lot
    of bloat data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ori1`: This is used to serialize the `Quat` structs over the network, for
    player orientation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new compression policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding new compression policies is as easy as modifying `CompressionPolicy.xml`.
    For example, if we want to create a new Vec3 policy in which the X and Y axes
    can only reach up to 2048 m, while the Z axis is limited to 1024 m:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Exposing Lua entities to the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to handle network communication in C++, let's have a look
    at how we can expose Lua entities to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Net.Expose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to define RMIs and server properties, we''ll need to call `Net.Expose`
    from within the global scope of your `.lua` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous function will define the `ClRevive` and `SvRequestRevive` RMIs,
    which can be called by using three subtables that are automatically created for
    your entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allClients`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`otherClients`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The remote functions are defined within either the `Client` or `Server` subtables
    of your entity script, so that the networking system can quickly find them while
    avoiding name conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, see the following `SvRequestRevive` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Invoking RMIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the server, we can trigger the `ClRevive` function on all remote clients,
    along with the parameter that we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: On the server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To invoke our `SvRequestRevive` function on the server, simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On all clients
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want all clients to receive a `ClRevive` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On all other clients
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To send the `ClRevive` call to all clients except the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Binding our entity to the network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to being able to send and receive RMI''s, we''ll have to bind our entity
    to the network. This is done by creating a game object for our entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our entity will now have a functional game object, but it''s not yet set up
    for networked usage. To enable this, call the `CryAction.BindGameObjectToNetwork`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Done! Our entity is now bound to the network, and can send and receive RMI's.
    Note that this should be immediately after the entity is spawned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how CryENGINE instances can communicate with
    each other remotely over networks, and have also created our own RMI function.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be aware of network aspects and compression policies function,
    and have basic knowledge of how you can expose entities to the network.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to proceed with multiplayer games and networking before moving
    on to the next chapter, why not create a basic multiplayer sample in which players
    can send a spawn request to the server that results in the player spawning on
    all remote clients?
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be covering the physics system and how it can be
    used to your advantage.
  prefs: []
  type: TYPE_NORMAL
