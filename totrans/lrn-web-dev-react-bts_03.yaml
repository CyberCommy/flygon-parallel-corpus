- en: Chapter 3. ReactJS-JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we went through the process of building responsive
    themes with the help of React-Bootstrap and React. We saw examples for it and
    the difference between Twitter Bootstrap and React-Bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: I'm very excited now as we are going to look into the core of ReactJS, which
    is JSX. So, are you ready folks? Let's dive deep into learning about ReactJS-JSX.
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX is an extension of JavaScript syntax, and if you observe the syntax or structure
    of JSX, you will find it similar to XML coding.
  prefs: []
  type: TYPE_NORMAL
- en: With JSX, you can carry out preprocessor footsteps that add XML syntax to JavaScript.
    Though you can certainly use React without JSX, JSX makes React a lot more neat
    and elegant. Similar to XML, JSX tags have tag names, attributes, and children,
    and in that, if an attribute value is enclosed in quotes, that value becomes a
    string.
  prefs: []
  type: TYPE_NORMAL
- en: XML works with balanced opening and closing tags. JSX works similarly, and it
    also helps to read and understand a huge amount of structures easily than JavaScript
    functions and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of using JSX in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a list of a few advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: JSX is very simple to understand and think about, as compared to JavaScript
    functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markup of JSX would be more familiar to non-programmers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using JSX, your markup becomes more semantic, organized, and significant
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make your code neat and clean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I said earlier, the structure/syntax is so easy to visualize/notice, which
    is intended for more clean and understandable code in JSX format when we compare
    it with JavaScript syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are simple code snippets that will give you a clear idea. Let''s
    see the code snippets in the following example of JavaScript syntax while rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the following JSX syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I'm assuming that it is clear now that JSX is really easy to understand for
    programmers who are generally not used to dealing with coding, and they can learn
    and execute it as if they are executing HTML language.
  prefs: []
  type: TYPE_NORMAL
- en: Acquaintance or understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the development region, UI developers, user experience designers, and quality
    assurance people are not very familiar with any programming language, but JSX
    makes their life easy by providing a simple syntax structure, which is visually
    similar to a HTML structure.
  prefs: []
  type: TYPE_NORMAL
- en: JSX shows a path to indicate and see through your mind's eye, the structure
    in a solid and concise way.
  prefs: []
  type: TYPE_NORMAL
- en: Semantics/structured syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have seen how JSX syntax is easy to understand and visualize,
    the reason being the semantic syntax structure.
  prefs: []
  type: TYPE_NORMAL
- en: JSX converts your JavaScript code into a more standard solution, which gives
    clarity to set your semantic syntax and significant component. With the help of
    JSX syntax, you can declare the structure of your custom component with information,
    the way you do in HTML syntax, and that will provide the magic to transform your
    syntax to JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `React.DOM` namespace helps us to use all HTML elements with the help of
    ReactJS: Isn''t it an amazing feature! Moreover, the good part is that you can
    write your own named components with the help of the `React.DOM` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please check out the following simple HTML markup and how JSX components help
    you to have semantic markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding example, we have wrapped `<h2>Questions</h2><hr
    />` with the `<div>` tag, which has a `className="divider"`. So, in the React
    composite component, you can create a similar structure and it is as easy as when
    working with HTML coding with semantic syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's see in detail what the composite component is and how we can build it.
  prefs: []
  type: TYPE_NORMAL
- en: The composite component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, you can create your custom component with JSX markup and JSX syntax,
    and transform your component to a JavaScript syntax component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the following files in your HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Add this HTML in your `<body>` section.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are all set to define the custom component using JSX as we have the
    JSX file ready to be worked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom component, we have to express the following mentioned HTML
    markup as a React custom component. You have to just follow the given example
    to execute your wrapped syntax/code, and in return after rendering, it will give
    you the expected markup result. The `Divider.js` file would contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you want to append the child node to your component then it's possible in
    React-JSX. In the preceding code, you can see that we have created one variable
    named `divider` and, with the help of React-JSX, we can use it as a HTML tag as
    we are using defined HTML tags like `<div>`, `<span>`, and so on. Do you remember
    that we have used the following markup in our earlier example? If not, then please
    refer to the previous topic again, as it will clear up your doubts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As in the HTML syntax, here the child nodes are captured between the open and
    close tags in an array, which you can set in your component's `props` (properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will use `this.props.children` = `["Questions"]` where
    `this.props.children` is React''s method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen in the preceding example, we can create components with open
    and close tags the way we do in any HTML coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will get the expected output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Namespace components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A namespace component is another feature request that is available in React
    JSX. I know you''ll have a question: what is a namespace component? OK, let me
    explain.'
  prefs: []
  type: TYPE_NORMAL
- en: We know that JSX is just an extension of JavaScript syntax and it also provides
    the ability to use namespace so React is using JSX namespace pattern rather than
    XML namespacing. By using the standard JavaScript syntax approach, which is object
    property access, this feature is useful for assigning components directly as `<Namespace.Component/>`,
    rather than assigning variables to access components that are stored in an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at the following show/hide example to have a clear
    idea about namespace components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'From the following example, we will see how we can compose a `MessagePanel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A `MessagePanel` is a component that consents to rendering a message in your
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'It primarily has two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MessagePanelHeading`: This displays the heading/title of the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MessagePanelContent`: This is the content of the message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a healthier way to compose `MessagePanel` by *namespacing* the children.
    This can be achieved by making child components as attributes on the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, in the preceding snippets, you can see how we have extended `MessagePanel`
    by just adding new React components, `Heading` and `Content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how the composition changes when we bring the namespace notation
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will see practical examples of namespace component code after integrating
    in React with Bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me explain the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `State` property contains the state set by `setState` and `getInitialState`
    of our component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setState(changes)` method applies the given changes to this state and re-renders
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handleToggle` function handles the state of our component and returns the
    Boolean values `true` or `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have also used some Bootstrap classes to give a look and feel to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.collapse`: This is for hiding the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.collapse.in`: This is for showing the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.well`: This is for background, border, and spacing around the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.btn .btn-primary`: This is for the button look and feel. Bootstrap has also
    provided you some different classes with different color styles that help readers
    to provide a visual indication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.btn-default`, `.btn-success`, `.btn-info`, `.btn-warning`, `.btn-danger`,
    and `.btn-link`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `<a>`, `<button>`, or the `<input>`element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.col-sm-12`: This is to make your component responsive on small screens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s open your HTML in a browser and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Namespace components](graphics/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now resize the screen and see how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Namespace components](graphics/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It looks amazing!
  prefs: []
  type: TYPE_NORMAL
- en: JSXTransformer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JSXTransformer** is another tool to compile JSX in a browser. While reading
    code, the browser will read `attribute type="text/jsx"` in your mentioned `<script>`
    tag and it will only transform those scripts that have a mentioned `type` attribute
    and then it will execute your script or written function in that file. The code
    will be executed in the same manner as `react-tools` executes on the server. Visit
    [https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html](https://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html)
    for more.'
  prefs: []
  type: TYPE_NORMAL
- en: JSXTransformer is deprecating in the current version of React, but you can find
    the current version on any provided CDNs and Bower. As per my opinion, it would
    be great to use the **Babel REPL** ([https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&code=](https://babeljs.io/repl/#?babili=false&evaluate=true&lineWrap=false&presets=es2015%2Creact%2Cstage-2&code=))
    tool to compile JavaScript. It has already been adopted by React and the broader
    JavaScript community.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example will not work with the latest version of React. Use an older version
    such as 0.13, as JSXTransformer is deprecated and it's replaced by Babel to transform
    and run the JSX code in the browser. The browser will only understand your `<script>`
    tags when it has the `type="text/babel"` type attribute, which we have used previously
    in examples from [Chapter 1,](ch01.html "Chapter 1. Getting Started with React
    and Bootstrap") *Getting Started with React and Bootstrap* and [Chapter 2,](ch02.html
    "Chapter 2. Lets Build a Responsive Theme with React-Bootstrap and React") *Lets
    Build a Responsive Theme with React-Bootstrap and React*.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at the preceding show/hide example, you can see that we have used
    attribute expressions to show the message panel and hide it. In React, there is
    a small change in writing an attribute value, in JavaScript expressions we write
    attributes in quotes (`""`), but in React we have to provide a pair of curly braces
    (`{}`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Boolean attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boolean attributes have two values, they can either be `true` or `false`, and
    if we neglect the value in JSX while declaring attributes, then by default it
    takes the value as `true`. If we want to have a `false` attribute value, then
    we have to use an attribute expression. This scenario can occur regularly when
    we use HTML form elements, for example, the `disabled` attribute, the `required`
    attribute, the `checked` attribute, and the `readOnly` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Bootstrap example `aria-haspopup="true"aria-expanded="true"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the preceding example, you can embed JavaScript expressions in JSX
    using syntax that will be accustomed to any handlebars user, for example, `style
    = { displayStyle }` allocates the value of the `displayStyle` JavaScript variable
    to the element's `style` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The same as expressions, you can set styles by assigning an ordinary JavaScript
    object to the `style` attribute. How interesting. If someone tells you not to
    write CSS syntax, you can still write JavaScript code to achieve this, with no
    extra effort. Isn't that superb! Yes, it is.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a set of event handlers that you can bind in a way that should look
    familiar to anybody who knows HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some names of React event handlers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Clipboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Form events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wheel events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Media events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transition events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some defined `PropTypes` of JSX are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`React.PropTypes.array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.func`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React.PropTypes.symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are aware of all the properties well in advance, then it will be helpful
    when creating your component in JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Changing `props` is bad practice, let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, as per our practice, we set properties on to the object that is
    non-recommended standard in attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, you can see the anti-pattern, which is not
    best practice. If you don't know about properties of JSX attributes then `propTypes`
    won't be set and it will throw errors that would be difficult for you to trace.
  prefs: []
  type: TYPE_NORMAL
- en: '`props` are a very sensitive part of attributes, so you should not change them,
    as each prop has a predefined method and you should use it as it is meant to be
    used, like when we use other JavaScript methods or HTML tags. This doesn''t mean
    that it is impossible to change `props`. It is possible, but it is against the
    standard defined by React. Even in React, it will throw an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Spread attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s check out the JSX feature--spread attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, the properties that you have declared
    have become part of your component's `props` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reusability of attributes is also possible here and you can also map it with
    other attributes. But you have to be very careful in ordering your attributes
    while you declare it, as it will override the previous declared attribute with
    the last declared one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you now have a clear idea about JSX, JSX expressions, and attributes.
    So, let's check out how we can build simple forms with the help of JSX dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a dynamic form with JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting on a dynamic form with JSX, we must be aware of JSX form libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, HTML form element inputs take their value as display text/values,
    but in React JSX, they take property values of respective elements and display
    it. As we have already visually perceived that we can't change `props` values
    directly, so the input value won't have that transmuted value as an exhibit value.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss this in detail. To change the value of a form input you will use
    the `value` attribute and then you will see no change. That doesn't mean that
    we cannot change the form input value, but for that we need to listen to the input
    events and you will see that the value changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following exceptions are self-explanatory, but very important:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Textarea` content will be considered as a `value` prop in React'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As `For` is a reserved keyword of JavaScript, the HTML for the attribute should
    be bounded like the `htmlFor` prop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now it's time to learn that to have form elements in the output, we need to
    use the following script, and we also need to replace it with the previously written
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's start on building an Add Ticket form for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `React-JSXform.html` file in the root. The following code snippet is
    just a base HTML page that includes Bootstrap and React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the markup of our HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is always good practice to load all your scripts at the bottom of the page
    before your `<body>` tag closes, which loads the component successfully in your
    DOM, because when the script is executed in the `<head>` section, the document
    element is not available because the script itself is in the `<head>` section.
    The best solution to resolve this problem is to keep scripts at the bottom of
    your page before your `<body>` tag closes, and it will be executed after loading
    all your DOM elements, which will not throw any JavaScript error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create `<form>` elements with Bootstrap and JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have used `class` as `className` and `for` as `htmlFor`,
    since JSX is similar to JavaScript and `for` and `class` are identifiers in JavaScript.
    We should use `className` and `htmlFor` as property names in the `ReactDOM` component.
  prefs: []
  type: TYPE_NORMAL
- en: All the form elements `<input>`, `<select>`, and `<textarea>` will get the global
    styling with the `.form-control` class, and will apply the `width:100%` by default.
    So when we are using a label with inputs, we need to wrap it with a `.form-group`
    class for optimum spacing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our Add Ticket form, we need these following form fields along with the
    label:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Email: <input>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Issue type: <select>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assign department: <select>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Comments: <textarea>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button: <button>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make it a responsive form, we will use `*col-*` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at our form component code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply a style or call an `onSubmit` function in the attribute value, rather
    than using quotes (`""`), we have to use a pair of curly braces (`{}`) in the
    JavaScript expression. Now, create one `component` folder and save this file as
    a `form.js` in that folder, and then include it in your HTML page. This is what
    our page will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a quick look at our component''s output in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a dynamic form with JSX](graphics/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oh, cool! This is looking awesome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the form component''s responsive behavior while resizing the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Example of a dynamic form with JSX](graphics/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first character should always be a capital when you create a component in
    React. For example, `AddTicket`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how JSX plays an important role in making custom
    components, as well as making them very simple to visualize, understand, and write.
  prefs: []
  type: TYPE_NORMAL
- en: The key examples shown in this chapter will help you to understand JSX syntax
    and its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The last example in this chapter covered the responsive Add Ticket form with
    JSX along with Bootstrap, which gave you an idea about JSX syntax execution and
    how to create your custom component. You can use it and instrument it easily as
    you play with HTML.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still not sure about JSX and its behavior, then I recommend that
    you go through this chapter again, as it will also help you when looking at future
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: If you fully understand this chapter, then let's move on to [Chapter 4](ch04.html
    "Chapter 4. DOM Interaction with ReactJS"), *DOM Interaction with ReactJS* which
    is all about DOM interacting with React, and where we will see DOM's interaction
    with ReactJS. It's an interesting chapter as when we talk about interactivity
    between inputs and outputs, we have to consider backend code and DOM elements.
    You will see some very interesting topics like, props and state, controlled component,
    uncontrolled component, non-DOM attributes keys and references, and many more
    with examples.
  prefs: []
  type: TYPE_NORMAL
