- en: '*Chapter 6*: Designing Solutions and Solution Processes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will design **solutions** to multiple problems, using previously
    learned content, such as **analysis** of the problem and the **computational thinking
    process**. We will incorporate **logical processing** to create visual representations
    of the decision process that will guide our algorithm design. Visual representations
    discussed include **diagrams**, **flow charts**, and other helpful processes.
    In this chapter, we will learn about the key elements of solution design; how
    to create, use, and apply diagrams in our solution processing and design; and
    we will look at applying the solution design process to various problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diagramming solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to further our knowledge of algorithms and solution design, we need
    to look more closely at the frontend of problems. We will begin by discussing
    the process of designing solutions in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: Designing solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are designing solutions, we often use a **design thinking model**, even
    if we don't always realize it. Design thinking is described by different models,
    but we'll be looking at the five-step model that is most commonly seen when using
    design thinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conjunction with computational thinking, the design thinking process can
    help us evolve our ideas before we start diagramming solutions. It should be noted
    that we don''t go through the design thinking process linearly, much like in computational
    thinking. Think about the steps in computational thinking:'
  prefs: []
  type: TYPE_NORMAL
- en: Problem decomposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern recognition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithm design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have defined all these steps in previous chapters, most recently in the introduction
    to [*Chapter 5*](B15413_05_Final_SK_ePub.xhtml#_idTextAnchor082), *Exploring Problem
    Analysis*. Looking at them again, we know that we can go back to the decomposition
    as we're writing and designing the algorithm. That's what we mean by non-linear
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design thinking model works the same way. It was designed by the Hasso-Plattner
    Institute of Design at Stanford University. The main steps of the model include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Empathize**: Understand the problem from the audience or stakeholder perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define**: Identify the objectives, the decisions that need to be made, any
    biases introduced, and any details pertaining to the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ideate**: Brainstorm ideas, which go with the diagramming we''ll be doing
    in the next section of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype**: Design the algorithm solution and check it often.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test**: Check your algorithm often throughout the process and go back to
    previous steps as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see, I''ve adapted the design thinking model to align more with
    a computational thinking process. The main goal when we''re using these models
    and combining them is to break down the harder problems into simpler chunks so
    we can solve and design the best algorithms. This does not take the place of computational
    thinking. It simply provides a better idea of how we can address the process.
    The following diagram can help demonstrate how the process may work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Design thinking model'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.1_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Design thinking model
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, rather than using the linear model most frequently shown, the
    preceding model shows the process as *cyclical*. That said, going back to *empathize*
    can happen from any point, so going back and forth between these steps is the
    best way to use the design thinking model.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a scenario where we are using design thinking in conjunction
    with computational thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 1 - A marketing survey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say you''re working with a marketing firm and they ask you to put together
    a survey to gather feedback about a website. Here are some of the steps you may
    go through:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying stakeholders**: This includes the people you''ll survey as well
    as the people who will use the information after the survey, for example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identifying questions**: This is where you define what information you hope
    to find from the survey.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Designing the survey**: This includes not only the questions you identified
    but the aesthetics of what the survey will look like.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Information gathering**: This is where you decide how you will communicate
    with the people who will fill out the survey, such as email, a link on a website,
    or similar.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data analysis**: You can write a Python algorithm to help you with data analysis,
    including creating tables and graphs based on the data collected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data sharing**: This is where you will plan the visuals, reports, and data
    presentation to the original stakeholders.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s be clear: this is an oversimplification of the process. But let''s say
    you realize you need to include another group for the survey. Say you were only
    initially getting feedback from students at a school but realized you wanted to
    add teachers and parents. Well, then you would go back to *step 1* and identify
    in which ways the rest of your information would be affected. You may want to
    change the look of the survey or add a different one for adults versus children.
    You may need to add questions that are for only one group, which affects your
    decision-making in the algorithm for the survey.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at these steps within the *design thinking* process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our problem, identifying the stakeholders and questions are part of *steps
    1*, *2*, and *3* of the design thinking model: *empathize*, *define*, and *ideate*.
    Building the algorithm is both part of *prototype* and *test*, which are *steps
    4* and *5*. Adding people to the survey takes us back to *steps 1–3*. And the
    cycle repeats until we have a working algorithm for our scenarios. Throughout
    the computational thinking model and using its elements, you''ll use the design
    thinking process embedded within. It''s a natural part of the decision-making
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at the design thinking model, let's take a look at how
    to visually represent the decision-making using diagramming solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Diagramming solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are designing algorithms, we often use diagrams and flowcharts to help
    us analyze the process and visually see where our decisions are made. These diagrams
    allow us to create better algorithms. You'll remember that we created a flowchart
    in [*Chapter 5*](B15413_05_Final_SK_ePub.xhtml#_idTextAnchor082), *Exploring Problem
    Analysis*, when we were building a store (*Figure 5.1* and *Figure 5.2*).
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating these diagrams varies by developer or coder. For example,
    I usually create a brainstorm for the problem, then a flowchart from that information.
    To look at that process, let's go back to our survey problem from earlier in this
    chapter. Look at the following brainstorm. It is not complete, as you can add
    a lot of sub-topics. This brainstorm assumes we are surveying stakeholders to
    evaluate and share feedback on a school website.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Brainstorm diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.02_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Brainstorm diagram
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the diagram, there are many considerations to be made. The
    actual survey design may be provided to us as programmers or we may take part
    in designing the survey. If we have the survey, our brainstorm may look different,
    as we navigate through the questions and decide how to best place them within
    the algorithm. This is part of the empathizing process. We are looking at our
    information from multiple angles, from multiple stakeholders' perspectives, and
    deciding how we'll write an algorithm to help us get to where we need. The purpose
    of an informal diagram such as the brainstorm is that it allows us to begin organizing
    ideas before trying to create a more detailed and organized flowchart. When we
    work on the diagram, we are defining and ideating our algorithm. That's why it's
    important to sketch out our plans before beginning to code directly.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to flowcharts, we saw a few in the last chapter when discussing
    the creation of a store in Python. Now let's take a look at a flowchart for decision-making
    based on some decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that surveys can be difficult to create from scratch.
    Part of the reason is that there may be questions that depend on each other. For
    example, let''s say you ask the user to state whether they approve of the color
    choices or not. If they do, you can move on. But if they don''t, you may want
    to provide other color schemes for review. That question would only appear for
    those who choose the **No** option. Our flowchart could be rather complicated
    if we were to tackle all the information for our brainstorm, so we''ll focus on
    a few questions within the *Look* category of the brainstorm. Take a look at the
    following flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Flowchart for one element of the survey'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.3_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – Flowchart for one element of the survey
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the flowchart, some things are not clearly visible, such
    as what happens when you complete one question, where you go after each decision,
    and so on. When I create flowcharts, I sometimes add arrows to help me see what
    happens after each step. The following flowchart shows some of the arrows added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Flowchart with arrows'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.4_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – Flowchart with arrows
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the preceding flowchart, not all arrows are added, but look
    closely at **Color Scheme**. If a user approves of the color scheme, then they
    go directly to the **Fonts** section. If they don't, they are shown options. Assuming
    one option is shown at a time, then the user would go to **Fonts** after they
    choose one they like. It is also possible to add a prompt that asks the user if
    they'd like to see the options again, which would bring them back to the **Alt
    option 1**. Arrows can be added to show those details.
  prefs: []
  type: TYPE_NORMAL
- en: It all depends on what is easiest for you as a developer and programmer to understand
    yourself. Think of these as your journal notes if you were a writer. The way you
    organize your ideas can be personal, just make sure your end result and algorithm
    can be easily used by the people it is intended for.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's take a look at how to put everything together and create solutions
    to some problems.
  prefs: []
  type: TYPE_NORMAL
- en: Creating solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are presented with problems, we want to create solutions that address
    the information we have been provided, with an algorithm that provides everything
    needed and that is easily understood by the user. In this section, we'll take
    the content we've been learning in this chapter in order to design solutions to
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we create these solutions using our brainstorms and flowcharts, we should
    be considering the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Does the solution we have planned address the problem?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Does the solution design show a clear path for the algorithm to be successful?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And if the answers to those questions are yes, then we can start coding the
    solution. Remember, we need to test the algorithm as often as we can. Here are
    some things to keep in mind when writing the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: Add comments to identify sections you may need to go back to and that clearly
    help to identify and define your variables, dictionaries, functions, and any key
    components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that you don't have any errors, such as those discussed in [*Chapter 5*](B15413_05_Final_SK_ePub.xhtml#_idTextAnchor082)*,
    Exploring Problem Analysis*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run your program as often as possible to test for errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the solution process, we're going to use a slightly different problem than
    the survey we were working on earlier in the chapter. We will tackle components
    you can use for that problem as we go through this book, such as adding images,
    showing graphics, and more. But for now, let's stick with some more basic Python
    in order to practice the process of creating a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 2 - Pizza order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I know – food. But it''s one of the best ways to demonstrate logic and algorithm
    creation, so bear with me. Let''s say we have a pizzeria. We sell only one type
    of crust because we''re a specialty kind of place. We sell two different sizes
    of pizza: personal and family. There are two sauce options: marinara and garlic
    cream. There are three cheese options: no cheese, regular cheese, and extra cheese.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five toppings to choose from (I''m limiting those because we''re
    just learning the process): mushrooms, pepperoni, Italian sausage, onions, and
    peppers. And no, we''re not putting olives anywhere near my pizzeria.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's break down that problem. We want an algorithm to capture the options chosen
    by the user to order their pizza. Things we're not going to take into consideration
    right now are cost and additional items in the order, such as an additional pizza,
    beverages, desserts, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we know:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: personal or family'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sauce**: marinara or garlic cream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cheese**: no cheese, regular cheese, extra cheese'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toppings**: mushrooms, pepperoni, Italian sausage, onions, peppers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have that, let''s look at a flowchart with the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Flowchart for pizzeria decision-making'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.5_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Flowchart for pizzeria decision-making
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the figure shows a fairly *linear decision-making process* for
    this particular problem. One thing we haven't considered is asking the user if
    they wish to make any changes. That may need to happen at each step. Say you changed
    your mind while choosing cheese to go for a marinara instead of a garlic cream
    sauce. You'll need to have a way to go back, so we'll need to keep that in mind
    as we create the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we're sticking to text codes currently, so we'll use input
    from the user in numbers and letters for now. However, there are ways to incorporate
    Python into more robust algorithms that incorporate images, buttons, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following snippet from the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: ch6_pizzeria.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the snippet that we defined the size and the sauce first. I will reiterate
    here that there are other ways to tackle this particular logic process. For example,
    we can save some of the variables to dictionaries and work with arrays. For now,
    we're using what we've learned so far to create our algorithms, but we'll get
    a chance to learn about other approaches later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding snippet has a final choice of cheese. Regardless of the option
    here, we need to make decisions on toppings. That will need to happen twice since
    we'll need it for both yes and no.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following snippet with those options, which is a continuation
    of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch6_Pizzeria.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the snippet, we only worked with mushrooms. The output
    for this particular code after choosing family size, garlic sauce, regular cheese,
    and mushrooms looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the code provided and taking a look at the output, try to put together
    the rest of the code for the remaining four ingredients. And I guess that if you
    are creating your own pizza, you're welcome to change the options provided here.
    Just keep the olives to yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as mentioned before, we may need to go back and make changes. Let''s take
    a look at a snippet that does that for you:'
  prefs: []
  type: TYPE_NORMAL
- en: ch6_Pizzeria2.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the snippet of code, there is a decision that needs to
    be made about the changes needed. If yes, then we present the questions again.
    If no, then we print the choices for the user. Take a look at the following output
    with the fully run program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the code, the questions were asked twice because we made a change
    in our options. Depending on how often you want to ask that question, you'll need
    to continue to repeat some of this code. There are ways to simplify that, so we'll
    go over those options in more depth in our Python language program chapter ([*Chapter
    8*](B15413_08_Final_SK_ePub.xhtml#_idTextAnchor114), *Introduction to Python*)
    and later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let's take a look at one more problem to go through the design
    process again.
  prefs: []
  type: TYPE_NORMAL
- en: Problem 3 - Delays and Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of my first problems in Python was to create an algorithm that would react
    differently depending on the color chosen. This is similar to what you''d have
    if you were creating a traffic light. Each light has a different delay. So let''s
    create an algorithm that addresses that. We''ll make it a user-chosen color between
    green, yellow, and red, just to keep the traffic light theme. So let''s put some
    assumptions together:'
  prefs: []
  type: TYPE_NORMAL
- en: Green will mean a 5-second delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yellow will mean a 2-second delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red will mean a 4-second delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s no reason for these specific delays; I just wanted to keep them all
    under 5 seconds. Now, let''s say that we''re playing a game and the user has to
    choose a color. If they choose yellow or red, they''ll get a delay and then will
    be asked again. The goal is to get a *You win! You can go now* message from the
    program. So let''s create a flowchart for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Flowchart for traffic light game'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_6.6_B15413.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Flowchart for traffic light game
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the flowchart, the game restarts if you choose yellow or
    red. Now that we have the basics of what the game will look like, we have to code
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to use delays, we'll need to import the `time` library. Use the code
    `import time` to do so. To include a delay, we use the code `time.sleep()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a snippet of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: ch6_sleep.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the algorithm contains some of the code we''ve looked at in
    previous chapters when talking about loops, Boolean statements, and more. This
    particular code returns to the beginning for three rounds if the user has not
    won the game. We used an `if-elif-else` statement to go through the color scenarios.
    The output of the game playing three rounds looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the game output, all three rounds were played. Each delay
    happened according to the statement, which you'll have to test for yourself since
    I can't show time delays with text.
  prefs: []
  type: TYPE_NORMAL
- en: Having the flowchart made creating this algorithm simpler than if I'd started
    coding as soon as I'd read the problem. It's important to get used to fleshing
    out the processes you'll need prior to writing your algorithms. Designing solutions
    can be a long and tedious process, but the more organized we are at the start,
    the better our algorithms will be.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed how to design, diagram, and create solutions
    to problems. We went over the non-linear process of design thinking in order to
    understand how to best design solutions. The design thinking model is a five-step
    process: **Empathize**, **Define**, **Ideate**, **Prototype**, and **Test**. Using
    this five-step process within the computational thinking process can help us to
    avoid many problems and pitfalls.'
  prefs: []
  type: TYPE_NORMAL
- en: We also created brainstorms and flowcharts to establish the decision-making
    process of our algorithms to solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use our knowledge of algorithm design and designing
    solutions in order to identify challenges within solutions and debug programs.
  prefs: []
  type: TYPE_NORMAL
