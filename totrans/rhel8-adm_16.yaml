- en: '*Chapter 13*: Flexible Storage Management with LVM'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing local storage can be done in a more flexible manner than in [*Chapter
    12*](B16799_12_Final_SK_ePub.xhtml#_idTextAnchor160), *Managing Local Storage
    and Filesystems*, by using the **Logical Volume Manager** (**LVM**). LVM allows
    you to assign more than one disk to the same logical volume (the equivalent in
    LVM to a partition), have data replicated across different disks, and make snapshots
    of a volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will review the basic usage of LVM and the main objects
    that are used to manage storage. We will learn how to prepare disks to be used
    with LVM, and then aggregate them into a pool, thereby not only increasing the
    available space, but also enabling you to use it consistently. We will also learn
    how to distribute that aggregated disk space into partition-like chunks that can
    easily be extended if necessary. To do so, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, moving, and removing physical volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining physical volumes into volume groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and extending logical volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new disks to a volume group and extending a logical volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing logical volumes, volume groups, and physical volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing LVM commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, we will add two more disks to the machine we are working
    with to be able to follow the examples mentioned in this chapter. These are your
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a physical machine, you may add a couple of USB drives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using a local virtual machine, you will need to add two new virtual
    drives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using a cloud instance, you can add two new block devices to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, let''s see how these disks are added to our virtual machine
    in Linux. First, we power off the virtual machine we installed in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*, called `rhel8`. Then we open the characteristics page of the
    virtual machine. There we find the **Add Hardware** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Editing virtual machine properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Editing virtual machine properties
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the virtualization platform you are using, there are different
    paths to reach the virtual machine characteristics. However, it's very common
    that there is an option directly accessible from the virtual machine menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Add Hardware** will open the dialog in the following screenshot.
    In it, we will select the **Storage** option and specify the size of the virtual
    disk to be created and attached to the virtual machine, in this case, 1 GiB, and
    then click **Finish**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Adding a disk to a virtual machine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Adding a disk to a virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: 'We will repeat this procedure twice to add two disks. The end result will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Two new disks added to a virtual machine, making a total of
    three'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Two new disks added to a virtual machine, making a total of three
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now power on the virtual machine and log in to it to check the availability
    of new devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the new 1 GiB disks, `vdb` and `vdc`, are available. Now that
    we have a system disk, where we installed the RHEL 8 operating system and two
    more disks to work with, we are ready to continue with this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The naming of the disk devices in Linux depends on the driver they use. Devices
    attached as SATA or SCSI show as `sd` and a letter, such as `sda` or `sdb`. Devices
    connected with IDE buses use `hd` and a letter, such as `hda` or `hdb`. Devices
    as in the example, which use the VirtIO paravirtualized drivers, use `vd` and
    a letter, for example, `vda` or `vdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LVM uses three layers to manage the storage devices in our systems. These layers
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Physical Volumes** (**PV**): The first layer of LVM . Assigned to the block
    devices directly. A physical volume can be either a partition on a disk, or a
    full raw disk itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Volume Groups** (**VG**): The second layer of LVM. It groups the physical
    volumes to aggregate space. This is an intermediate layer and not very visible,
    but its role is very important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical Volumes** (**LV**): The third layer of LVM. It distributes the space
    that the volume groups aggregate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see the example that we want to implement using the two newly added
    disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – LVM example using two disks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – LVM example using two disks
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain this example diagram to understand all the layers:'
  prefs: []
  type: TYPE_NORMAL
- en: We have two disks, which, in the diagram, are **Disk1** and **Disk2**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disk1** is partitioned into two partitions, **Part1** and **Part2**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disk2** is not partitioned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three physical volumes. The mission of these is to prepare the disk
    space to be used in LVM. The physical volumes are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: – **PV1**, created on the **Part1** partition of **Disk1**
  prefs: []
  type: TYPE_NORMAL
- en: – **PV2**, created on the **Part2** partition of **Disk1**
  prefs: []
  type: TYPE_NORMAL
- en: – **PV3**, created directly on **Disk2**
  prefs: []
  type: TYPE_NORMAL
- en: One single volume group, **VG1**, aggregates all three physical volumes, **PV1**,
    **PV2**, and **PV3**. Now, all that disk space is consolidated and can be easily
    redistributed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To distribute the space, there are four logical volumes – **LV1**, **LV2**,
    **LV3**, and **LV4**. Please note that the logical volumes do not use the whole
    disk. This way, if we need to extend a volume or create a snapshot, it will be
    possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a basic description of how the layers are distributed, without diving
    into complex cases such as mirroring, thin provisioning, or snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, we need to understand that PVs are designed to prepare devices
    to be used by LVM, VGs to aggregate PVs, and LVs to distribute the aggregated
    space.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to see that if we create a VG, we can add an extra disk to
    it, thereby increasing its size without having to stop or reboot the machine.
    Likewise, we can distribute the added space along the LVs that require it without
    having to stop or reboot the machine. This is one of the main reasons why LVM
    is so powerful and recommended for every server, with very few exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the layers into which LVM is divided, let's begin using them
    to start understanding how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Creating, moving, and removing physical volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having our machine ready with the two new disks, `vdb` and `vdc`, as the *Technical
    requirements* section explains, we can get started on implementing the example
    diagram, as shown in *Figure 13.4*, in our machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is not directly related to LVM, but it is still important to
    continue with the example. This first step involves partitioning the `vdb` disk.
    Let''s take a look at this with the tool to manage partitions, `parted`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Your disk device, if you are using a physical machine or a different disk driver,
    may be different. For example, if we were using SATA disks, it would be `/dev/sdb`
    instead of `/dev/vdb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disk is completely unpartitioned, as we can see in the `unrecognised disk
    label` message. As is explained in [*Chapter 12*](B16799_12_Final_SK_ePub.xhtml#_idTextAnchor160),
    *Managing Local Storage and Filesystems*, there are two types of disk labels that
    we can use; `msdos` (also referred to as `gpt`, the new type that machines with
    a `gpt`, as we will do in this example. The option to be used with `parted` to
    create a new label is `mklabel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To create an `msdos` label, the command would be `parted /dev/vdb mklabel msdos`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a disk with a `gpt` label, but without partitions. Let''s create
    a partition using the `mkpart` option in interactive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can enter the partition name, `mypart0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For the next step, specifying the filesystem, we will use `ext2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to set the start point. We will use the first sector available,
    which is `2048s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The first sector in modern disks is, by definition, `2048s`. This is not provided
    by the tool. We could review other existing disks, when in doubt, by running `parted
    /dev/vda unit s print`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And then we come to the final step, setting the endpoint, which can be described
    as the size of the partition we want to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The command is complete with the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the partition table is refreshed in the system, and to allow
    the devices to be generated under `/dev`, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The full command to run in non-interactive mode is `parted /dev/vdb mkpart mypart0
    xfs 2048s 200MB`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the new partition available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to change the partition to be able to host `LVM` physical volumes.
    The `parted` command uses the `set` option to change the partition type. We need
    to specify the number of the partition, which is `1`, and then type `lvm` and
    `on` to activate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We see the flag of the partition now set as `lvm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the second partition, `mypart1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created two partitions, `/dev/vdb1` (with the name `mypart0`)
    and `/dev/vdb2` (with the name `mypart1`), this is what our storage looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Partitions created in our two new disks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – Partitions created in our two new disks
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There is another tool that comes by default in RHEL8 to manage partitions, which
    is `fdisk`. You may want to give it a try to see whether you find it easier to
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to create persistent volumes. We will do it only on the newly
    created partitions. First, we check the available persistent volumes with the
    `pvs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we proceed to create the persistent volumes with `pvcreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And we check they have been created correctly with `pvs` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that persistent volumes do not have their own name, but the name of the
    partition (or device) they are created on. We can refer to them as `PV1` and `PV2`
    to draw the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is now the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Persistent volumes created in the two new partitions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Persistent volumes created in the two new partitions
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a persistent volume directly on the disk device, `vdc`.
    Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the previous example, there is no name for the physical volume, which
    we will refer to as `PV3`. The result looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – Persistent volumes created in the two new partitions and the
    new disk device'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – Persistent volumes created in the two new partitions and the new
    disk device
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the persistent volumes, let's group them using virtual groups
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Combining physical volumes into volume groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to create a new volume group with the physical volumes added previously.
    Before doing that, we can check the volume groups available with the `vgs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that only the volume group created during installation for the operating
    system is available. Let''s create our `storage` volume group with the `/dev/vdb1`
    and `/dev/vdb2` partitions using the `vgcreate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the new `storage` volume group has been created. The diagram
    of the current status would now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – First volume group created with two physical volumes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – First volume group created with two physical volumes
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume groups** are a very thin layer in LVM whose only goal is to aggregate
    disks or partitions into a pool of storage. The advanced management of that storage,
    such as, for example, having data mirrored in two different disks, is done with
    logical volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: We have already prepared the partitions and disks as physical volumes and aggregated
    them into volume groups, so we have a pool of disk space. Let's move on to the
    next section to learn how the distribution of that disk space can be done using
    logical volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and extending logical volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We currently have several physical volumes created and two of them grouped
    into a volume group. Let''s move to the next layers and check the logical volumes
    with the `lvs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We see the `root` and `swap` volumes on the `rhel` volume group, which hosts
    the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a simple logical volume called `data`, 200 MB in size, on
    the `storage` volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our configuration now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – First logical created using space from a volume group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – First logical created using space from a volume group
  prefs: []
  type: TYPE_NORMAL
- en: 'The logical volume created is a block device, and behaves similarly to a disk
    partition. Therefore, in order to be used, we need to format it with a filesystem.
    Let''s do this by formatting it with the `xfs` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s ready to be mounted. We can create the `/srv/data` directory and
    mount it there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have set up our LVM-enabled space available in our system. Mounting a filesystem
    manually, as in the previous example, works while the system is not powered down
    or rebooted. To make it persistent, we need to add the following line to `/etc/fstab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that the line is correctly written, we can run the following commands.
    First, dismount the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the available space in the mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `df` (for *disk free*) command shows that the space in the
    `/srv/data/` directory is related to the `root` partition, meaning that the folder
    does not have any filesystem associated with it. Let''s now run the `mount` command
    when the system is starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'All filesystems in `/etc/fstab` that are not mounted will be mounted, or an
    error will be shown if there is any issue with them (such as a typo in `/etc/fstab`).
    Let''s check that it is mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `/dev/storage/data` and `/dev/mapper/storage-data` devices are aliases (or
    symbolic links, to be more precise) of the same device generated by a component
    called **device mapper**. They are fully interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the filesystem is properly mounted. Now that we know how to create
    a logical volume and assign a filesystem and mount point to it, we can move on
    to more advanced tasks, such as extending disk space in our LVM layers and beyond.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new disks to a volume group and extending a logical volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great things about LVM, and more specifically, volume groups, is
    that we can add a new disk to it and start using that newly extended space. Let''s
    try it by adding the physical volume in `/dev/vdc` to the `storage` volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our disk distribution looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Extended volume group with three physical volumes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – Extended volume group with three physical volumes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now extend the `data` logical volume by adding 200 MB to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The logical volume has been extended. However, the filesystem on top of it
    hasn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to extend the filesystem. The tool to do so depends on the type of
    filesystem. In our case, as it is `xfs`, the tool to extend it is `xfs_growfs`.
    Let''s do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: And now, the filesystem has some extra space added and available.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When doing this task, the logical volume can be mounted and be used by the system.
    LVM is ready to do volume extensions on production systems while running.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very easy to redistribute the space and add another logical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--size` and `--extents` options for the `lvcreate` command have several
    options that can be used to define the space to be consumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GB`, or megabytes, using `MB` (in other words, `--size 3GB`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--extents`, the command will use its internal measure, `extents`, which is
    similar to block size for disk partitions (that is, `--extents 125`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `--size` and `--extents` options also apply to the `lvextend` command.
    In this case, we can use the options shown previously for `lvcreate` to define
    the new size of a logical volume. We also have other options to define increments
    of space to be assigned to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+` symbol before the number to `lvextend`, this will increase the size in
    the measurement provided (that is, `--size +1GB` adds one extra gigabyte to the
    current logical volume).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--extents`, and the percentage of free space to be used followed by `%FREE`
    (that is, `--extents 10%FREE`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen previously in other tools, we can use the manual pages to remind
    ourselves of the options available. Please run `man lvcreate` and `man lvextend`
    to get familiar with the pages for these tools.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create a logical volume to be used as **swap**, which is a part
    of the disk that the system uses as a parking space for memory. The system puts
    processes that consume memory and that are not active there so that the physical
    memory (which is much faster than disk) is freed. It is also used when there is
    no more free physical memory in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a swap device on LVM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the memory and swap status with the `free` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The two new changes would require adding a line for each to `/etc/fstab` to
    make use of them persistently across reboots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our disk space distribution would now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Extended volume group with three physical volumes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – Extended volume group with three physical volumes
  prefs: []
  type: TYPE_NORMAL
- en: This distribution looks a lot like the initial example we used to describe the
    layers of LVM. We now have practiced with all the layers to create the pieces
    required in each one of them. We know how to create, so now it's time to learn
    how to remove them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Removing logical volumes, volume groups, and physical volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start with the commands used to remove, let''s do the simple step of removing
    the `img` logical volume. First, we need to check whether it''s mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As it is mounted, we need to dismount it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command shows an empty output, which means that it isn''t mounted.
    Let''s proceed to remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can also remove the mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And the removal of the logical volume is done. This process is not reversible,
    so run it carefully. Our disk distributions now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Volume group with logical volume removed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – Volume group with logical volume removed
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time for a more complex task, removing a physical volume from a virtual
    group. The reason for doing so is that sometimes you want to transfer the data
    stored on a physical disk to a different disk, and then detach it and remove it
    from the system. This can be done, but first, let''s add some files to the `data`
    logical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s evacuate the data from `/dev/vdb1` using the `pvmove` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the allocation of the extents, you may receive a message stating
    `no data to move for storage`. This means that the saved data was already allocated
    to the other disk. You can use `pvmove` with other devices to try it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now there is no data stored in `/dev/vdb1` and it can be removed from the volume
    group. We can do so by using the `vgreduce` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there is now less space in the storage volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see that the physical volume, `/dev/vdb1`, is not attached to any
    volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `vgdisplay`, `pvdisplay`, and `lvdisplay` commands show detailed information
    on any of the parts of LVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important part is that we can do these operations while the system
    is running production workloads with confidence. Our disk distribution now looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Volume group with physical volumes removed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_13_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.13 – Volume group with physical volumes removed
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to remove the volume group, but we need to remove the logical
    volumes first, just like we did before (feel free to run `lvs` and `vgs` before
    and after each command to check progress):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have removed `/dev/storage/swap`. Let''s now remove `/dev/storage/data`,
    using the `--yes` option so that we do not get asked for confirmation (important
    when using this command in a script):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to remove the `storage` volume group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `storage` volume group has been removed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, clean the physical volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: And with this, we know how to work with each part of the LVM in our RHEL8 systems.
    Let's review the commands used in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing LVM commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a summary of the commands used to manage physical volumes, let''s take a
    look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_Table_13.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s review the commands used to manage volume groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_Table_13.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, let''s review the commands used to manage logical volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16799_Table_13.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remember that you can always use the manual pages available for each command
    to get more information on the options you want to use and learn new ones, just
    by running `man <command>`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The web administration interface Cockpit, has an extension for managing storage
    components. It can be installed as `root` (or with `sudo`) with the following
    command, `dnf install cockpit-storaged`. A good exercise for you would be to repeat
    the process done in this chapter using the storage interface in Cockpit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LVM is an incredibly useful part of Red Hat Enterprise Linux and provides
    the capabilities to manage, reallocate, distribute, and assign disk space without
    having to stop anything in the system. Battle-tested over the years, it is a key
    component for system administrators, as well as facilitating the incorporation
    of other extended capabilities in our systems (a flexible way to provide storage
    to be shared via iSCSI).
  prefs: []
  type: TYPE_NORMAL
- en: Practicing LVM on test machines is extremely important, so we can be sure that
    the command we will run on a production system will not mean the service being
    stopped or data being lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we have seen the most basic, yet important, tasks that can
    be done with LVM. We have learned how the different layers of LVM work: physical
    volumes, volume groups, and logical volumes. Also, we''ve seen how they interact
    with each other and how they can be managed. We have practiced creating, extending,
    and removing logical volumes, volume groups, and physical volumes. It will be
    important to practice them to consolidate the knowledge acquired and be able to
    use them in production systems. However, the basis for doing so is now already
    in place.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next chapter to discover a new feature in RHEL8 to
    improve the storage layer further by adding deduplication capabilities to it –
    **Virtual Data Optimizer** (**VDO**).
  prefs: []
  type: TYPE_NORMAL
