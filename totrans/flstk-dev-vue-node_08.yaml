- en: Introducing Vuex
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex is a library that we can use with Vue.js to manage different states in
    an application. If you are building a small application that does not require
    much data exchange between its components, you are better off not using this library.
    However, as your application grows, complexities crawl along with it. There will
    be several components in the application, and, most obviously, you will need to
    exchange data from one component to another or share the same data across multiple
    components. That is when Vuex comes to the rescue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js also provides an `emit` method to pass data between different components,
    which we used in previous chapters. As your application grows, you might also
    want to update data across several components when your data gets updated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: So, Vuex provides a centralized place to store all the pieces of data in our
    application. Whenever data changes, this new set of data will be stored in this
    centralized place. Also, all of the components that want to use that data will
    be fetched from the store. This means that we have a single source to store all
    the data, and all the components that we build will be able to access that data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first get acquainted with some of the terminology that come with Vuex:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '**State**: This is an object that contains the data. Vuex uses a single state
    tree, which means that it is a single object that contains all the pieces of data
    for the application.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getters**: It is used to fetch data from the state tree.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mutations**: They are the methods that change the data in the state tree.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: They are the functions that perform mutations.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss each of these in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Traditional multi-web page application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional multi web page application, when we build a web application and
    open a website by navigating to the browser, it requests the web server to fetch
    that page and serve it to the browser. When we click on a button on the same website,
    it again requests the web server to fetch another page and again serve it. This
    process happens for every single interaction we do on the website. So, basically,
    the website gets reloaded on every single interaction, which consumes a lot of
    time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample diagram that explains how a multi-page application
    works:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/358fe12c-59b3-4c01-840a-49d48a1c85b9.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: When a request is sent from the browser, the request is sent to the server.
    The server then returns the HTML content and serves a whole new whole page.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi Page Applications **(**MPA**) can provide several benefits as well.
    It''s not a matter of whether to choose MPA or a **Single Page Application** (**SPA**),
    but it all depends on the content of your application. If your application contains
    a lot of user interaction, you should go for an SPA; however, if the only purpose
    of your application is to serve the users with the content, you can go with an
    MPA. We will explore more about SPAs and MPAs later in this chapter.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to SPAs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contrary to the traditional MPAs, SPAs are designed specifically for web-based applications.
    The SPA fetches all the data when you first load the website in the browser. Once
    all the data is fetched, you don't need to fetch any more data. When any other
    interactions are done, that data is fetched over the internet, without having
    to send a request to the server and without reloading the page. This means that
    SPAs are much faster than the traditional MPAs. However, since SPAs fetch everything
    at once on the first load, the first page load time could be slow. Some applications
    that have SPA integration are Gmail, Facebook, GitHub, Trello, and so on. SPAs
    are all about making the user experience better by putting the content on one
    single page and not making the users wait for the information they want.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample diagram of how SPAs work:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff9dc3a1-41a1-45fd-a694-0fd9084e8584.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: The website has all the content that it needs on the first page-load. When a
    user clicks on something, it just fetches the information for that particular
    area and refreshes only that part of the web page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: SPA versus MPA
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPA and MPA serve different purposes. You may want to use one over the other,
    depending on your needs. Before you start your application, ensure that you are
    clear about the kind of application that you want to build.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Pros of using MPAs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MPAs are the best approach if you want to make your application SEO friendly.
    Google can crawl different pages of your application by searching the keywords
    that you assign on each page, which is not possible in an SPA since it has only
    a single page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Cons of using MPAs
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few cons of using MPAs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The development work for an MPA is much greater than for an SPA because the
    frontend and backend are tightly coupled.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MPAs have tightly coupled frontend and backend, which makes it harder to separate
    the work between frontend and backend developers.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros of using SPAs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SPAs provides a lot of benefits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced server response tim**e: SPAs fetch all the data needed on the first
    load of the website. With such an application, the server does not need to reload
    the resources on the website. If new data needs to be fetched, it only fetches
    the updated piece of information from the server, unlike multi-page apps, decreasing
    the server response time significantly.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better user interaction**: The decrease in server response time ultimately
    improves the user experience. With every interaction, the user gets a more quickly
    rendered page, which means *happy customers*.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility to change the UI**: SPAs do not have a coupled frontend and backend.
    This means that we can change the frontend and completely rewrite it without having
    to worry about breaking anything on the server side.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data caching**: SPAs cache the data in the local storage. It only makes a
    single request the first time and saves the data. This makes the application available
    even when the internet is cut off.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cons of using  SPAs
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are few downsides of using SPAs as well:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: SPAs are not SEO friendly. Since everything is done on a single page, the crawlability
    is very low.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot share a particular piece of information with others since there is
    the only one link to the page.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security concerns are much greater with SPAs than in MPAs.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Vuex
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex is a state management library that is specifically designed to work with
    applications built with Vue.js. It is centralized state management for Vuex.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Core concepts of Vuex
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We got a glimpse of these core concepts in the introduction. Now, let''s dive
    into a little bit more detail on each of these concepts:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed51d06e-04d0-4f06-beee-3a3f7d86ae7f.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram is a simple diagram that explains how Vuex works. Initially,
    everything is stored in a state, which is the single source of truth. Every view
    component fetches data from this state. Whenever something needs to be changed,
    actions perform mutations on the data and store it back in the state:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4523972-cb5b-4dd8-8639-4bc547976d96.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: When we open our application in the browser, all the Vue components will be
    loaded. When we click on a button to fetch certain information from a component,
    that component dispatches an action that performs mutations on the data. When
    the mutation is successfully done, the state object is updated and new values
    are used. Then, we can use the new state for our components and display it in
    the browser.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Vuex application
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start a fresh new application to learn the basics of Vuex. Let's get
    started.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a new application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code snippet will ask you few questions about the application
    setup. You can choose what you want to keep. I will go with the following configuration:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/433b4667-cdfc-434e-ae05-d12d2a43efec.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'After the installation, navigate to the project directory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next thing to do is to run the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, run the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding command will spin up your server and open a port in `localhost:8080`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vuex
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to install `vuex`. To do that, run the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting up Vuex
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create a `store` folder to manage the `vuex` in our application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Creating a store file
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src` directory, create a `store` folder and `store.js` file. Then,
    add the following to the `store.js` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code block, the line `Vue.use(Vuex)` imports the Vuex library.
    Without this, we will not be able to use any of the `vuex` functionalities. Now,
    let's build a store object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: State
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same `store.js` file, add the following lines of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, we set the default state for a variable called `count`
    as `0` and exported a Vuex state through the store.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to modify `src/main.js`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code imports the store file that we just created, and we can access
    this variable in our vue components.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to creating a component that will fetch this store data. A default
    component is created when we create a new application with Vue. If we look into
    the `src/components` directory, we will find a file called `HelloWorld.vue`. Let's
    use the same component, `HelloWorld.vue`, or you can create a new one. Let's modify
    this file to access the `count`, which we defined in the state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/components/HelloWorld.vue`, add the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the final folder structure:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1eef5543-52e1-4b33-9e48-a7efbc92001a.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot should print the default value of count in the `HelloWorld.vue`
    component. If you navigate to `http://localhost:8080/#/`, you should see the following
    screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/964f5d82-853f-466c-a069-799ed8e9f367.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we accessed the count variable in the store directly
    using the `$` operator, which is not the preferred way of doing it. We have learned
    the fundamentals of using the state. Now, the proper way to access the variables
    is by using getters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `getter` is a function that is used to access the objects from the store.
    Let's create a `getter` method to fetch the count that we have in our store.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'In `store.js`, add the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code, we added a method called `fetchCount`, which returns
    the current value of `count`. Now, to access this in our vue component—`HelloWorld.vue`,
    we will need to update the content with the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have to import a module called `mapGetters` from Vuex, which is used to
    import the `fetchCount` method that we create as a `getter` method in `store.js`.
    Now, check the number by reloading the browser; this should also print the count
    as `0`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/092909d8-925c-4beb-a34f-525086a77929.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: mutations
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to `mutations`. `mutations` are methods that perform modifications
    to the state of the store. We will define the `mutations` just as we defined `getters`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'In `store.js`, add the following lines:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added two different `mutation` functions in the preceding code. The `increment`
    method increments the count by 1, whereas the `decrement` method decreases the
    count by 1\. This is where we introduce actions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actions are the methods that dispatch mutation functions. Actions perform `mutations`.
    Since `actions` are asynchronous and `mutations` are synchronous, it''s always
    a good practice to use `actions` to mutate the state. Now, just like `getters`
    and `mutations`, let''s define the `actions` as well. In the same file, that is, `store.js`,
    add the following lines of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we added two different functions for incrementing and
    decrementing. Since these methods commit the `mutations`, we will need to pass
    a parameter to make the `commit` method available.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to use the previously defined `actions` and make them available
    in our vue component, in `HelloWorld.vue`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To invoke these actions, let''s create two buttons. In `HelloWorld.vue`, let''s
    add the following lines of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding lines of code add two buttons, which, when clicked, call a method
    to increment or decrement the count. Let''s also import Bootstrap for CSS. In
    `index.html`, add the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s it. Now, if you reload the browser, you should be able to see the following
    result:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02e6929a-410b-4b2e-a264-0f595157d624.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: The count should increase or decrease when you click on the relevant button.
    This gives you a basic idea about how to implement Vuex in an application.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Vuex in a movie application
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the basics of Vuex—how it works in an application and the core concepts.
    We covered how to create a store and mutations and how to use actions to dispatch
    them, and also discussed how to use getters to fetch information from the store.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We built an application in the previous chapters for a movie listing page.
    We will use the same application for Vuex. We will be doing the following actions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: We will define a store where all the movies will be stored
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a new movie is added, we will automatically display that to the movie listing
    page without reloading the page
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s open the application and run the frontend and backend servers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, run the `mongo` server with the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The movie listing page should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e905eea-dc88-42f3-8715-2cdf705c9317.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by installing `vuex`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check your `package.json` file; `vuex` should be listed on the dependencies:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let's create a file, where we will be able to put all our `getters`, `mutations`,
    and `actions` that we will define as we go forward.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Defining a store
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a folder named `store` inside the `src` directory, and a new
    file called `store.js` inside the `store` directory, and add the following lines
    of code to it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Just like we did in the preceding sample application, let's add a `state` variable
    to store the current state of the application for movies listing page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'In `store.js`, add the following lines of code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This means that the initial state of the application will have an empty movie
    listing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to import this `store` into `main.js` so that it is accessible
    throughout the components. Add the following lines of code in `src/main.js`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we will need to fetch the movies when we open the location `http://localhost:8081/`
    in the browser. Here is what we will do:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Modify `Home.vue` to call the action that fetches the movies
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an action that will fetch all the movies
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a mutation to store the fetched movies in the movies store
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a getter method to fetch the movies from the state to display on the
    home page
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifying Home.vue
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start this section by modifying our `Home.vue` component. Update the
    `script` part of the file with the following lines of code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, in the `mounted()` method, we have dispatched an action
    called `fetchMovies`, which we will define in our action.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'When the movies are fetched successfully, we will use the `computed` method,
    which will be mapped to the `movies` variable, which we will use in our template:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating an action
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move on to add an action to the `store.js` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we have moved the `axios` part from the component. When
    we get a successful response, we will commit a mutation called `MOVIES`, which
    then mutates the value of the `movies` in the state.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mutation
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go on and add a mutation as well. In `store.js`, replace the contents
    with the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding `mutations` mutate the state of the movies of the application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: We now have the `action` and the `mutation`. Now, the last part is to add a
    `getter` method, which gets the value of the `movies` from the state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Creating a getter
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the `getter` method in `store.js` that we created to manage the
    state of our application:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That's it. When we navigate to `http://localhost:8081/movies/add`, we should
    have a functional Vuex implementation that fetches the movies to the home page.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。当我们导航到`http://localhost:8081/movies/add`时，我们应该有一个功能齐全的Vuex实现，可以将电影获取到主页上。
- en: 'Let''s move on to implement the store when we add a movie to the application.
    We will follow the same process as we did earlier:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现当我们向应用程序中添加电影时的存储。我们将按照之前的过程进行：
- en: Modify `AddMovie.vue` to call the action to create the movie
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`AddMovie.vue`以调用创建电影的`action`
- en: Create an `action` that calls the POST API to create movies
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用POST API来创建电影的`action`
- en: Create a `mutation` to `store` the added new movie to the `movies` store
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`mutation`来将新添加的电影存储到`movies`存储中
- en: 'Replace the `script` contents in `AddMovie.vue` with the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`AddMovie.vue`中的`script`内容：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, add the `action` and `mutations` to the `store.js` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`store.js`文件中添加`action`和`mutations`：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, run the following command to build our static files for Vue components:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令来构建我们的Vue组件的静态文件：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, when we log in and add a movie with the admin user, the movie should be
    added to the database and also be listed on the home page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们登录并使用管理员用户添加电影时，电影应该被添加到数据库中，并且也会在主页上列出。
- en: Using Vuex in a small application such as this is overkill. The best use of
    Vuex is in large-scale applications where data needs to be transferred and shared
    among several components. This gives you an idea of how Vuex works and how to
    implement it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样一个小型应用程序中使用Vuex是杀鸡用牛刀。Vuex最好的用法是在大型应用程序中，其中数据需要在多个组件之间传输和共享。这让你了解了Vuex的工作原理以及如何实现它。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed what Vuex is—the core concepts of Vuex state,
    getters, mutations, actions, and how to use them in an application. We discussed
    how to structure our application to implement Vuex and the benefits it adds when
    the application grows larger.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Vuex是什么——Vuex的核心概念状态、获取器、突变、操作，以及如何在应用程序中使用它们。我们讨论了如何构建我们的应用程序来实现Vuex，并且在应用程序变得更大时它所带来的好处。
- en: In the next chapter, we will cover how to write unit tests and integration for
    Vue.js and Node.js application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何为Vue.js和Node.js应用程序编写单元测试和集成测试。
