- en: Expanding Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to focus on larger, more complex applications,
    adding recipes such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing state with Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing async actions with redux-thunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding routing with react-router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding authorization to routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code splitting for performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we saw how to develop web applications with `React`,
    and endeavored to make them internationally usable, accessible for everybody,
    and nicely styled to boot. In this chapter, we'll add some more features, which
    are typical of most applications.
  prefs: []
  type: TYPE_NORMAL
- en: Managing state with Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's difficult about building an application? Obviously, you can do anything
    with plain, vanilla JS, but things start getting hairy when you try to keep the
    UI and the state of the application in sync. You call services, you get data.
    Data must be reflected in several places, HTML elements must be changed, added,
    or removed, and so on—this is where the complexity lies.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve been working only with state in components, and you could very
    well keep doing so: your top level component''s state will include everything
    you need, and you''d be able to manage by passing everything you need as props
    to the components below. Of course, as your application grows, this won''t scale
    very well. What''s the tipping point? `Redux` is a tool to manage state, but its
    own developers suggest that you should use their package if and only if you fulfill
    the following conditions, and I quote from [https://redux.js.org/#before-proceeding-further](https://redux.js.org/#before-proceeding-further):'
  prefs: []
  type: TYPE_NORMAL
- en: <q class="calibre43">"You have reasonable amounts of data changing over time."</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q class="calibre43">"You need a single source of truth for your state."</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q class="calibre43">"You find that keeping all your state in a top-level component
    is no longer sufficient."</q>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, these rules are not really precise, and allow for subjectivity, so
    there's no clear-cut point at which you'll *have* to use `Redux`. However, for
    most modern large scale applications, it's quite safe to say that `Redux` will
    probably come in handy, so let's assume that for the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll install `Redux`, and start to see how to work with it
    in `React`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before anything else, we must install a couple of packages: `redux`, the state-managing
    package itself, and the `react-redux` bindings for using `Redux` with `React`.
    (You can use `Redux` with other frameworks or libraries, but this is not covered
    in this book.) Installation is simple, just use `npm`, as we have done several
    times before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have to learn several concepts in order to use `Redux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Store*: The only place ("single source of truth") where you hold the application
    state. You create the store globally, at the beginning of your application, and
    then you *connect* components to it. Connected components will get re-rendered
    when the state changes, and everything they need to render themselves should come
    from the store. The store can only be updated through actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Actions*: Objects that your components *dispatch* with any new data you wish.
    Actions always have a `type` attribute to distinguish different types, and any
    other data, with no restriction. Actions are usually created by *action creators* to
    simplify coding, and after being dispatched they are processed by reducers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reducers*: Pure functions (meaning, no side effects!) that change the application''s
    state, depending on the data received in actions. The state is never modified;
    rather, a new state must be produced with whichever changes were necessary. The
    reducer produces a new state as a function of the old state and the data received
    in the action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9dd5a133-27e4-4945-a705-a4ac6f449bc2.png)'
  prefs: []
  type: TYPE_IMG
- en: Data flow in Redux is strictly uni-directional, always following a circular
    pattern
  prefs: []
  type: TYPE_NORMAL
- en: Using this flow cycle helps keep the state and the view in sync—since the latter
    is produced in terms of the former, and all updates to the state immediately cause
    the view to be updated. We have installed the necessary tools to use, and we know
    what we have to do; now, let's get to an actual example.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to look at `eslint-plugin-redux`, which gives you some rules for
    how to get the best out of `Redux`. Check it out at [https://github.com/DianaSuvorova/eslint-plugin-react-redux](https://github.com/DianaSuvorova/eslint-plugin-react-redux),
    and if you're interested, add some or all of its rules to your `ESLint` configuration;
    by default, they are all disabled.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, let's do a simple example to show most of the concepts in the
    previous section. After reading multiple articles and tutorials on the web, I
    think it's mandatory to provide some kind of example involving a counter, and
    let's not break that tradition and do it here too! We want to have a counter that
    we can modify by clicking on some buttons, and we also want to know how many clicks
    we've made.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing the code, let''s have it in the open: we''ll be writing
    too many lines of code for what could have been easily solved *without* `Redux`—we
    won''t have a *reasonable amount of data changing over time* but only a couple
    of counts, and we certainly won''t *find that keeping all your state in a top-level
    component* isn''t good enough, but since we want a simple initial example, we''ll
    use `Redux` anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need some actions. We''ll want to increment and decrement the counter,
    and we''ll also want to reset it to zero. The first two requirements can be achieved
    with a single action (decrementing is just incrementing by a negative amount),
    so we''ll need two actions, each identified by a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In fact, we should say that `increment()`, `decrement()`, and `reset()` are
    action creators; the actual actions are the values returned by those functions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Then, after defining our actions, we need a reducer to process them. Of course,
    this also means that we have to define the shape of our state, and its initial
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our reducer is basically a switch statement; when the right type is found, a
    new state is returned. This pattern is very important, and key to `Redux`. We
    don't simply update the state, but rather we produce a new state object every
    time. We need a default case because actions are passed to all reducers (not in
    our case, since we have a single one), so it's possible that a reducer will ignore
    an action.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we have a single reducer and a single set of actions, so it
    can be argued that they could all be placed together in the same file, but that's
    not likely with most applications. Furthermore, if your state grows too large,
    check out `combineReducers()` at [https://redux.js.org/api/combinereducers](https://redux.js.org/api/combinereducers),
    and you'll be able to work in a more organized way, with multiple reducers and
    a store divided into logical pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Then, after all the previous definitions, we can define our store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By the way, it's also possible to define the initial value for the state by
    passing it as a second parameter to `createStore()`.
  prefs: []
  type: TYPE_NORMAL
- en: Building our components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, having fully defined our store plus the actions that will be dispatched
    and the reducer that will process them, we can finish quickly by defining our
    components. Our `Counter` component will have text, the counter value, and a few
    buttons. Note that we are receiving `count` (the counter value) as a prop, and
    we also have a `dispatch()` function as yet another prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each button dispatches an action that was created by the action creators that
    we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a second component. The `ClicksDisplay` component is even simpler!
    We receive the total number of `clicks` as a prop, and we simply display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Connecting components to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good design rule, separating concerns, says that you shouldn''t directly
    connect a component to the store, but rather create a new component, a connected
    one, that will get whatever is needed from the store and pass it on to the original
    component. This rule will simplify, for example, all of our testing: our basic
    components will still receive everything via props, and we won''t have to do any
    mocking of the store or anything like that in order to test them.'
  prefs: []
  type: TYPE_NORMAL
- en: A good article on defining components, by Dan Abramov, is *Presentational and
    Container Components*, at [https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0).
    More on this can be found in *Container Components*, at [https://medium.com/@learnreact/container-components-c0e67432e005](https://medium.com/@learnreact/container-components-c0e67432e005).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, following that rule, for each component we want to connect, we''ll add
    a new connected version. In our case, the connected version of the count will
    be the following, so the `count` prop of the component will receive the `state.count`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the component to display the total number of clicks will be connected
    in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will place those connected components in our main code, and they will get
    the values from the store, and pass them on to our original components, which
    will be totally unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the main page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our last piece of code is based on the standard `App.js` file that''s produced
    by `create-react-app`; the `App` class is imported by `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The key part here is the `<Provider>` component. This is a part of `React`'s
    latest `Context` feature (see [https://reactjs.org/docs/context.html](https://reactjs.org/docs/context.html)
    for more on it), and it gives access to the `store` object to any of the following
    components; the `connect()` function (that we used in the previous section) uses
    it to provide props to those components, and to subscribe them to changes. By
    the way, we are using `Fragment` here, just because `Provider` expects a single
    element. In addition to this, `<div>` could have worked as well.
  prefs: []
  type: TYPE_NORMAL
- en: With everything together, let's see how this works!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we start the application, the current state count is zero, and so is the
    number of clicks, so the screen looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec2ddcd2-4e51-4d4e-b062-0ab272acab79.png)'
  prefs: []
  type: TYPE_IMG
- en: Our counter application in its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some clicks on the following buttons, the value and clicks count get
    updated, and the view automatically reflects those changes as they happen; see
    the following screenshot. Be sure to understand how everything happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you click a button, an action is dispatched.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the reducer processes the action, it creates a new state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `React` sees the state change, it redraws your application. Take a look
    at the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b13fdefc-caf6-40d0-873a-590d502d2f98.png)'
  prefs: []
  type: TYPE_IMG
- en: After every click, the counter value and the number of clicks get automatically
    updated, and the view is re-rendered
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have seen that we can work with `Redux` in order to keep a global state
    and have the view re-rendered whenever it''s needed, without extra work on our
    part. Now, let''s consider a common problem: how would we deal with asynchronous
    changes, for example, when we do Ajax calls?'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Redux` is not the only state management package that you can use with `React`.
    The most favored one is surely `MobX`, which adds reactive programming concepts,
    such as observable objects and arrays; check it out at [https://github.com/mobxjs/mobx](https://github.com/mobxjs/mobx).
    Its basic paradigm is quite different from the `Redux` one, simpler in many ways,
    and more akin to a spreadsheet; be ready, however, to change your way of thinking
    before using it!'
  prefs: []
  type: TYPE_NORMAL
- en: Doing async actions with redux-thunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How can we do async actions, such as calling a web service? This kind of call
    requires some different processing: you cannot just dispatch an action, if we
    are still waiting for the results of an Ajax call. The `Redux` *thunk* middleware
    lets you write an action creator that returns a function instead of an action;
    the function is given access to the store contents and to the dispatch function
    itself, and can then do async calls, dispatch other functions, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: It seems that the origin of the **thunk** word comes from a very late programming
    session, in which, after many hours of work, a solution to a problem was found
    that had been *thought before*, and *thunk* became its name as a derivative of
    *think*, make of it what you will!
  prefs: []
  type: TYPE_NORMAL
- en: This sound a bit mysterious, so let's dive in and see how it works by doing
    a variation on the country/region components we built in the *Defining components*
    section in [Chapter 6](82da8477-a63b-46d4-ad35-8a8cc114b542.xhtml), *Developing
    with React*, only that this time we'll be working with actual API calls—for which
    we already have our `Node` server, which we created in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's modify our region application so that it will connect to the backend service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, to use `redux-thunk`, we will have to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must modify the store to use the new middleware. (We''ll be seeing
    more middleware later in this chapter, and in the next one as well.) This change
    is very small, as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Defining the actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever you try to get data from a service, a common pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fire an action when you do the request*; this action may set some flag, which
    will in turn be used by some component to display a "Loading..." text or a spinning
    icon to show that something''s going on, and the user should wait'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*If the service request was successful*, fire an action signaling this success,
    resetting the *Loading...* flag, and also providing the new data that must be
    added to the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*If the service request failed*, reset the *Loading...* flag, but signal error
    in some way'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The actions we''ll need for our application have to do with, firstly, getting
    the list of countries for the country drop-down list, and, secondly, getting the
    list of regions for a given country. The actions are as follows; first, here are
    the country-related ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For regions, we have a similar set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note the style of the action constants—we are using `"countries"` and `"regions"`
    as a sort of namespacing (as in `"countries:success"` versus `"regions:success"`)
    to avoid possible name duplications.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have actions; now, we need a reducer. Its code is also not complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing that needs to be remarked upon is the following style of code,
    using the spread operator in a way you may not have seen before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We must be careful when returning the new state to not lose part of the old
    state, so starting the object with `...state` is a very common coding pattern.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid accidentally changing the state, a good solution is to handle state
    with packages such as `immutable-js` (at [https://github.com/facebook/immutable-js/](https://github.com/facebook/immutable-js/))
    or `seamless-immutable` (at [https://github.com/rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)),
    because then you aren't able to modify the state object; you are forced to produce
    a new one, avoiding many hard-to-find mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the country drop-down list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We earlier had a country drop-down list that received a list of countries.
    Let''s rewrite it so that if no such list is provided, it will use a function
    to call a thunk, and get the countries from our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the `.componentDidMount()` method, if no list is available,
    we call a function (which we'll see soon) to get that list, and put it in the
    store. A `loading` attribute will be used, so while we wait for the countries
    to arrive, a `Loading countries...` text will be shown instead of an empty `<select>`
    component. You'll also notice that I sorted the countries, because the service
    sends them ordered by country code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The connected version of this component is not as short as before, because
    we''ll have to connect props to the store, and also to actions to be dispatched;
    I highlighted those parts of the code in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Modifying the region table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since most of the new behavior will occur in the country drop-down component,
    we can make do with a very simple table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also sort the regions in alphabetic order, and we just create a plain list
    of `<div>`, each with a single region''s name. The connected component gets access
    to the list of regions and to a loading flag so that it can show something while
    the list of regions is being fetched from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the main application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have all the necessary components, so we can now produce our application.
    (And, no, I haven''t forgotten the promised functions!) Our main code will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using thunks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, things start getting interesting. We are providing two functions to the
    country drop-down list, both of which will work with thunks in order to connect
    to the server. Let's see them!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need two functions: one will deal with getting the list of countries,
    and the other will be used to get the regions for the currently selected country.
    Let''s just begin with the former, and keep in mind that this code is to be added
    to the action file we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the signature for our `getCountries()` function is a bit weird (a function
    that returns an async function, with a `dispatch` parameter), but this is what
    `redux-thunk` requires. The logic is more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we dispatch the results of the `countriesRequest()` action creator,
    so the state of the application will show that we are waiting for some results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we use the `axios()` package, as used earlier in our Node work, to call
    our server and get the list of countries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the call is successful, we dispatch a `countriesSuccess()` action, passing
    it the list of countries that we received.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the call failed, we dispatch a `countriesFailure()` action, to show that
    failure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, our code is able to dispatch many actions, but waiting until
    the right moment to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with regions, we''ll have similar code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The code is quite similar to what we had before, so we don't need to do much
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we `npm start` our application, we see a very plain design; see the following
    screenshot. Let''s understand how did we get here:'
  prefs: []
  type: TYPE_NORMAL
- en: The main page was displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The countries drop-down list, on receiving an empty list of countries, used
    a thunk to get all countries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `getCountries()` action was dispatched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reducer updated the store to set the `loadingCountries` flag to true
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The page was redrawn, and a `"Loading countries..."` text was shown instead
    of the drop-down list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the countries list came back, a `countriesSuccess()` action was dispatched,
    with the received list of countries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reducer updated the store to include all countries and to reset `loadingCountries`
    to false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The page was redrawn, and now the country drop-down list has a list of countries
    to show as shown, in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ccb95d6f-41ff-4fec-976e-b6b0d1166649.png)'
  prefs: []
  type: TYPE_IMG
- en: Our initial screen
  prefs: []
  type: TYPE_NORMAL
- en: 'If we select a country, the service will be called, and results will be shown;
    see the following screenshot. The logic for this is also interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: When the region table is drawn without any regions, some `"No regions"` text
    is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user selects a country, the drop-down list uses a thunk to get its
    regions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `regionsRequest()` action was dispatched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the regions came back, a `regionsSuccess()` action was dispatched,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The page was redrawn after the reducer created a new state, showing the regions''
    list. Refer to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d5d2b52b-d1fc-4261-8fd0-effd7607882a.png)'
  prefs: []
  type: TYPE_IMG
- en: The results of calling our restful server
  prefs: []
  type: TYPE_NORMAL
- en: 'You could be wondering, however, where is the `"Loading countries..."` text?
    The problem (if you want to call it that!) is that the service response comes
    too quickly, so the message flashes by and disappears. We can get to see it a
    bit longer if we cheat and add some delay in the `getCountries()` function. Include
    the following line before calling `axios()` to delay execution for five seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll have time to see the missing state, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a8870bb-c738-434e-b3dd-2d74b36e3c7f.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding some delay lets us see what's displayed while waiting for the list of
    countries
  prefs: []
  type: TYPE_NORMAL
- en: So, now we can see that our state handling was correct, and that everything
    is displayed the way we wanted it to be!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you write your action creator, it actually gets passed not only `dispatch()` but
    also the `getState()` function. This function can be used to access the current
    state value. We didn''t use this, but, for example, you could do so for caching
    or other similar ideas. Our `getRegions()` function could be as follows, to detect
    whether you are requesting the same country''s regions again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we aren't doing anything other than logging a message, but you
    could use the received parameters plus the current state contents in order to
    do some more complex logic.
  prefs: []
  type: TYPE_NORMAL
- en: Adding routing with react-router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you work with `React` (as with other frontend frameworks, such as `Angular`
    or `Vue`, to name just a couple) you usually develop **Single Page Applications**
    (**SPAs**) that never do a full-page reload when you access a different part of
    them; rather, new content is swapped into view, but staying put on the original
    page. Even if this kind of navigational experience is modern and fluid, some aspects
    of more traditional routing are expected: the *back* and *forward* buttons should
    move you, depending on your browsing story, and you should also be able to bookmark
    a specific part of your application to be able to quickly return to it later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, with `React`, there are many ways to handle routing, but `react-router`
    is currently by far the most used library, probably because it really fits the
    `React` paradigm: routes are just components that you render and work as expected!
    Let''s start by building a simple application to show how routes work, and in
    the next section we''ll add a bit of complexity by requiring authentication before
    allowing access to certain routes.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `react-router` library is practically a standard for handling routing within
    `React` applications. Installing it requires a subtle distinction: instead of
    directly getting that package, you must pick a different package, `react-router-dom`,
    which will itself take care of getting `react-router`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can easily build an application with several links, a router that will take
    care of rendering whichever view is correct, and even a 404 page for wrong links.
    Of course, we'll focus on the routing aspects, so in other terms, our application
    will be more of a skeleton than an actual usable web page—and don't get started
    on its very plain styling!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll be creating a basic application but with several routes;
    let's see how.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we'll need to import some packages and create a few components
    that will represent the different pages in our application. For the latter, since
    we aren't going to include any actual logic or contents, we'll make do with very
    simple functional components that render a single `H1` heading... I told you our
    application would be quite bare!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to continue, we must plan our application. We''ll have `<header>` with
    a `<nav>` bar, in which we''ll include links to the parts of our application.
    Below that, we''ll have a common area in which the right component will be rendered.
    Our `<App>` component could be as follows—though in real life, you''d probably
    define all routes in separate files; I''m placing everything here for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve highlighted several parts of the code; let''s see why:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<BrowserRouter>` is a component based on the HTML5 "History" API, and takes
    care of keeping your view synchronized with the URL; a change in the latter will
    be reflected by a new view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Link ...>` is the component you must use instead of the usual `<a ...>` HTML
    tags, and `to=` points to the desired route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Switch>` is a component that renders the first child `<Route>` or `<Redirect>`
    component (we''ll using `<Redirect>` soon) that happens to match the current location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Route ...>` defines which component must be rendered when the path is matched.
    Note that you could have to specify exactly to avoid false coincidences; otherwise,
    visiting `"/alpha"` would be matched by the first route, `"/"`, and the wrong
    component would be displayed. You may specify what is to be rendered by using
    `component=` or by providing a `render()` function; the latter is useful when
    you need to display several components or take some parameters. In particular,
    we used this for `"/about/:something"`; when this route is matched, in a way similar
    to `Express` (check the *Adding Routes* section, in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*) a new prop will be provided, with attributes
    coinciding with the colon-starting parts of the URL. You can omit this by specifying
    `path=`, and then you''ll have a *catch-all*, which is useful for 404 errors,
    as we did here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have the code; let's see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you `npm start` the application and then navigate to it, you''ll get the
    home page, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a219e50-a1cc-4580-b82d-554e9accf5b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Our routing application, showing the component for the basic "/" route
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select any valid route (that is, don''t pick the Wrong one, at least
    not yet!), the matching route will be activated, and the corresponding component
    will be displayed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7225873e-e3b7-4868-a774-a4f76c251447.png)'
  prefs: []
  type: TYPE_IMG
- en: Picking a valid route gets you the corresponding component
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you pick a wrong route, the default component will be shown, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe9b3a61-8712-4ef4-a3b8-ecdf78eba46d.png)'
  prefs: []
  type: TYPE_IMG
- en: The last route in our <Switch> is a catch-all for undefined routes
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s something we haven''t used yet: the possibility of directly navigating
    to a given route or going back to the previous location and more. Whenever a `<Route>`
    is matched, the rendered component gets some special props, which you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.props.history`, providing access to the browser history, with several
    methods like `.goBack()` to return to the previous page, or `.push("someURL")`
    to navigate to a different page; see [https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API) and
    especially [https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/history.md)
    for more on this'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.props.location`, with several properties related to the current location
    and its URL; see [https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/location.md)
    for extra data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`this.props.match`, which tells you how the current route was matched; see [https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md](https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/match.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we are now able to work with routes; let's move on to routes needing authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authorization to routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our previous routing example worked very well, but in some applications, you
    might need authorization so that only logged-in users may access parts of your
    website. (You would also need the user to be identified, if you were using an
    API such as the one we developed in [Chapter 4](6b0f5248-5e86-4182-b7fe-1501f2ff09a3.xhtml),
    *Implementing RESTful Services with Node*, which required **JSON Web Token** (**JWT**).
    So, let's see what extra work we need in order to have both restricted and unrestricted
    routes on our page.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's add authorization to our application by protecting some routes and requiring
    a previous successful login.
  prefs: []
  type: TYPE_NORMAL
- en: We can find a very `React`-like solution. We will have some unprotected routes
    that anybody may access without restriction, and protected routes that require
    having a login. We'll need two components for that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a login component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s create a `<Login>` component that we''ll call our RESTful server,
    passing a username and a password to it, and (if the values are right) getting
    back a JWT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Defining actions and the reducer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting into the details, let''s see the reducer and actions we''ll
    have. The former is quite simple, since basically all we care about is having
    a `token` and a `logging` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have some action creators that will help us understand the rest. The
    important one is `attemptLogin()` that tries connecting to the server, and if
    successful stores the token that will mark that the user is logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We'll leave it as an exercise to you to write a `<LogOut>` component that will
    provide a button, which when clicked will just call an action to delete the current
    token.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a component to protect a route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To protect a route, let''s create a new component that will check whether a
    user is logged in or not. In the first case, the route will be shown, with no
    further ado. However, in the second case, instead of the original route''s component, `<Redirect>` will
    be produced, redirecting the user to the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will connect this component to the store so that it can access the current
    token plus the path to the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have everything we need; let's make it work!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use our new component, we''ll change something in our original routes from
    earlier in this chapter. Let''s protect a few of the routes. All it will take
    is changing `Route` to `AuthRoute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: All the changed routes will require a previous login—and if the user enters
    a wrong route, we won't even tell them about the 404 error; we'll force them to
    first log in, and if they won't do it, they won't be able to even learn that the
    route existed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we open the application and try to access the normal unprotected routes,
    everything will work as before. However, if you try to get to some of the protected
    routes, such as `"/charlie"`, you will be redirected to the login page, as in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eb6ebae-52a5-46fe-934b-6354900e3064.png)'
  prefs: []
  type: TYPE_IMG
- en: Trying to go to a protected route will redirect you to the login screen
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging in, the `<Login>` component will produce a `<Redirect>` of its
    own that will send the user back to the originally requested page. See the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5d19edd-fb7b-4603-829b-236a48fe0a59.png)'
  prefs: []
  type: TYPE_IMG
- en: After a successful login process, you'll be redirected again to the page you
    had first requested; the URL now points to the page we wanted to access
  prefs: []
  type: TYPE_NORMAL
- en: So, now you have a way to handle all kinds of routes, and in a very `React`-ish
    way, too!
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In usual web development, you use cookies or possibly local storage for access
    information, but in a `React` application, storing the token (or whatever you
    use) in the state is good enough. If you need to provide the token for API calls,
    remember that actions are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So, you can access the token via the `getState()` function, and pass it back
    to the server as needed; go back to the `getRegions2()` code, where we saw how
    to do async actions, to see an example of using this function.
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting for performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As your application grows in size, it will progressively be slower to load,
    and that will be off-putting to your users. (And, remember that not everybody
    has access to high-speed connections, especially in mobile devices!) Furthermore,
    users shouldn''t have to download the whole code if they only need a small part
    of it: for example, if a user wants to browse products, why should the sign-up
    view be downloaded?'
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this space and speed problem is *code splitting*, which implies
    that your application will be broken down into smaller chunks that will be loaded
    only if needed. Fortunately, there are very good tools for this, which don't involve
    many changes to your existing code, so it's a win all around.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you import a module, it''s a static thing, and the code for the desired
    module gets included in the general source code pack. However, you can work with
    *dynamic* `import()` calls to load code at runtime. You could work with that by
    yourself, but there''s already a simple package you can import, `react-loadable`,
    that will take care of most situations. Let''s install it in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We will be using a few of all the features of this package, so you should take
    a look at [https://github.com/jamiebuilds/react-loadable](https://github.com/jamiebuilds/react-loadable)
    to get ideas about more ways to enhance your dynamic code loading features.
  prefs: []
  type: TYPE_NORMAL
- en: As of December 2018, `import()` is at stage 3, meaning that it's a candidate
    for acceptance, expecting only few a (if any) changes and is well on its way to
    stage 4, which means that it will be included in the formal ECMAScript standard.
    However, as with other JS extensions, you can already use them in your code, and
    it's supported by `Babel` and `Webpack`. You can read more about `import()` at [https://tc39.github.io/proposal-dynamic-import/](https://tc39.github.io/proposal-dynamic-import/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's modify our routing application—even if it's quite small!—to try out code
    splitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see what our main code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have separated the `Alpha`, `Bravo`, and other components so that we can
    load them dynamically. Seeing the code for one of them will be enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'But what about `AsyncAlpha`, `AsyncBravo`, and the rest? These components are
    dynamically loaded versions of their normal counterparts, which we can get using
    `react-loadable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AsyncAlpha` component can be loaded dynamically, and while it''s being
    loaded, its contents will be provided by the `LoadingStatus` component; you can
    make it as fancy as you want but I went with a very simple thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, now that we know how we can get any component to load dynamically, let's
    see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to load components dynamically, instead of whole routes as usual
    with web applications, is a great plus. For example, your application could have
    a large, heavy component in a tab, but why load it unless the user actually goes
    to that tab? Deferred loading can also help show a page faster; you could endeavor
    to first show components at the top, and use dynamic imports for the components
    at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the web developer tools to look at the network transfers. When
    we start the application, we get the home page and just a few transfers, including
    `bundle.js`, the main source block. This is the file that will grow heavily in
    size as your application becomes larger. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da642b65-fe14-4799-8cf1-c743015c4499.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial load of the page shows that only bundle.js was sent over the net
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on a link, the corresponding chunk of split code will be transferred.
    After accessing several of the links, you''d get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2eb0b6e0-d958-4832-bb6b-cd60c2f79798.png)'
  prefs: []
  type: TYPE_IMG
- en: As you go to different links, chunks will get loaded, but only as needed
  prefs: []
  type: TYPE_NORMAL
- en: Even if our example is really tiny, you can see that you could easily partition
    the application to work in several smaller chunks. We can give no rules to suggest
    when you should start applying this technique, but, as we've seen, changing any
    component into an asynchronously loaded equivalent takes little effort, so you
    could start using the technique, even with all of your application already written.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The components created by `Loadable()` include a `.preload()` method that you
    can use to start the importing process before the components are actually needed.
    We can quickly test it. For example, let''s set things up so that if the user
    moves the mouse over the Alpha link, the component will be preloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can quickly verify that this works. When you load the updated version of
    the code, if you hover over the Alpha link, you''ll see that a chunk of code gets
    downloaded—though nothing changes onscreen, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e533a515-be91-4495-91f8-1d201134bba1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Preloading works in the background and lets you download a component in advance:
    a chunk (1.chunk.js) has been loaded, though it hasn''t been shown onscreen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Give it some time, and note that when you actually click the Alpha link, the
    component will be shown immediately, with no further downloads. There are more
    usages for preloading: you could use `setTimeout()` after the initial page load,
    for instance, or you could do predictive downloading, trying to foresee what the
    user will want next, based on what they''ve been doing.'
  prefs: []
  type: TYPE_NORMAL
