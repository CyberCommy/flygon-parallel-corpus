- en: Chapter 7. Working with Modules for Penetration Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with scanner auxiliary modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with auxiliary admin modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL injection and DOS attack modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Post-exploitation modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the basics of module building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing an existing module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own post-exploitation module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter where we discussed about the Metasploit framework basics,
    we stated that it has a modular architecture. This means that all the exploits,
    payloads, encoders, and so on are present in the form of modules. Modular architecture
    makes it easier to extend the functionality of the framework. Any programmer can
    develop his/her own module and port it easily into the framework. A complete penetration
    testing process can include several modules in operation. For example, we start
    with an exploitation module, then we use a payload module, then we can use several
    post exploitation modules once the target has been compromised. At last, we can
    also use different modules to connect to the database and store our findings and
    results. Even though modules are not very much talked about while working with
    Metasploit, they form the crux of the framework, so it is essential to have a
    deep understanding of it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will particularly focus on the `pentest/exploits/framework3/modules`
    directory which contains a complete list of useful modules which can ease our
    task of penetration testing. The use of modules is very much similar to what we
    have been doing so far, but there is a slight difference in the functionality.
    Later in the chapter, we will also analyze some of the existing modules and finally
    conclude the chapter by learning how to develop our own modules for Metasploit.
    So let us start our experiments with modules.
  prefs: []
  type: TYPE_NORMAL
- en: Working with scanner auxiliary modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us begin our experimentation with scanner modules. We have already learnt
    about scanning in detail using Nmap. In this recipe, we will analyze some of the
    ready-made scanning modules which ships with the framework. Even though Nmap is
    a powerful scanning tool, still there can be situations where we have to perform
    a specific type of scan, such as scanning for the presence of a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Metasploit provides us with a complete list of such useful scanners. Let us
    move ahead and practically implement some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find the list of available scanners, we will have to browse to `/pentest/exploits/framework3/modules/auxiliary/scanner`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a collection of more than 35 useful scan modules which can be used
    under various penetration testing scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start with a basic HTTP scanner. You will see that there are many different
    HTTP scan options available. We will discuss few of them here.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `dir_scanner` script. This will scan a single host or a complete
    range of networks to look for interesting directory a listings that can be further
    explored to gather information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using an auxiliary module, we will have to perform the following steps
    in our msfconsole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `show options` command will list all the available optional parameters that
    you can pass along with the scanner module. The most important one is the `RHOSTS`
    parameter which will help us in targeting either a single computer or a range
    of computers in a network.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us discuss a specific scanner module involving some extra inputs. The `mysql_login`
    scanner module is a brute force module which scans for the availability of the
    MySQL server on the target and tries to login to the database by brute force attacking
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are many different parameters that we can pass with this
    module. The better we leverage the powers of a module, the greater are our chances
    of successful penetration testing. We can provide a complete list of usernames
    and passwords which the module can use and try on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us provide this information to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to use brute force. The last step will be selecting the target
    and provide the run command to execute the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the module starts the process by first looking for the
    presence of the MySQL server on the target. Once it has figured out, it starts
    trying for the combinations of usernames and password provided to it through the
    external text file. This is also one of the most widely used modular operations
    of Metasploit in the current scenario. A lot of automated brute force modules
    have been developed to break weak passwords.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us go through a quick and easy way of generating password files using Metasploit.
    Having a decent list of password files can be helpful during brute-force penetration
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Generating passwords using "Crunch"
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For any brute force attack, it is imperative that we have a sizeable list of
    password files which we will be using in these types of attacks. Password lists
    can be procured from online resources or the pen-tester has the option of using
    John The Ripper to generate a password list. Alternatively, one can also use the
    "crunch" utility of Backtrack to generate such a list based on the characters
    being used. You can find the "crunch" utility in `/pentest/passwords/crunch`.
    In case it is missing in your version of Backtrack, then you can install it by
    passing the following command in the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic syntax of crunch looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us understand the functionality of some of the useful parameters of the
    crunch utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min-len:` Minimum length string to start at'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max-len:` Maximum length string to end at'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charset:` Defines the character set to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-b:` Number[type: kb/mb/gb] - it specifies the size of the output file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f </path/to/charset.lst> <charset-name>:` Allows us to specify a character
    set from the `charset.lst`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o <wordlist.txt>:` Defines the file to save the output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t <@*%^>:` This is used to add those texts which are sure to appear in the
    password'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A complete documentation on the crunch utility can be found at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://sourceforge.net/projects/crunch-wordlist/files/crunch-wordlist/](http://sourceforge.net/projects/crunch-wordlist/files/crunch-wordlist/)'
  prefs: []
  type: TYPE_NORMAL
- en: You can go through the complete documentation to figure out how we can use this
    utility to generate long and complex password lists.
  prefs: []
  type: TYPE_NORMAL
- en: Working with auxiliary admin modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving ahead with our module experiment, we will learn about some admin modules
    which can be really handy during penetration testing. The admin modules can serve
    different purposes, such as it can look for an admin panel, or it can try for
    admin login, and so on. It depends upon the functionality of the module. Here
    we will look at a simple admin auxiliary module named the `mysql_enum` module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mysql_enum` module is a special utility module for MySQL database servers.
    This module provides simple enumeration of the MySQL database server provided
    proper credentials are granted to connect remotely. Let us understand it in detail
    by using the module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with launching the msfconsole and providing the path for the
    auxiliary module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the module accepts password, username, and RHOST as parameters.
    This can help the module in first searching for the existence of a MySQL database
    and then apply the credentials to try for remote login. Let us analyze the output
    of the `exploit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The module responds with lots of useful information. It tells us that `cmdshell`
    and remote access has been enabled on our target MySQL setup. It also returns
    the database name which is currently in process on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: There are several similar modules available for other services such as MSSQL
    and Apache. The working process is similar for most of the modules. Remember to
    use the show options command in order to make sure that you are passing the required
    parameters to the module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These auxiliary admin modules function by a simple enumeration process by launching
    a connection and then passing the username and password combination. It can also
    be used to check whether anonymous login is supported by the database server or
    not. We can also test for a default username and password like MySQL uses "scott"
    and "tiger" as default login credentials.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection and DOS attack modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metasploit is friendly for both penetration testers as well as hackers. The
    reason for this is that a penetration tester has to think from the hacker's perspective
    in order to secure their network, services, applications, and so on. The SQL injection
    and DOS modules helps penetration testers in attacking their own services in order
    to figure out if they are susceptible to such attacks. So let's discuss some of
    these modules in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQL injection module uses a known vulnerability in the database type to
    exploit it and provide unauthorized access. The vulnerability is known to affect
    Oracle 9i and 10g. Metasploit contains several modules that use a known exploit
    in the Oracle database in order to break them through query injection. The modules
    can be found in `modules/auxiliary/sqli/oracle`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us analyze an oracle vulnerability named **Oracle DBMS_METADATA XML** vulnerability.
    This vulnerability will escalate the privilege from `DB_USER` to `DB_ADMINISTRATOR`
    (Database Administrator). We will be using the `dbms_metadata_get_xml` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The module requests for similar parameters which we have seen so far. The database
    first checks to login by using the default login credentials, that is, "scott"
    and "tiger" as the default username and password respectively. Once the module
    gains login as a database user, it then executes the exploit to escalate the privilege
    to the database administrator. Let us execute the module as a test run on our
    target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: On successful execution of the module, the user privilege will be escalated
    from `DB_USER` to `DB_ADMINISTRATOR`.
  prefs: []
  type: TYPE_NORMAL
- en: The next module that we will cover is related to the **Denial Of Service (DOS)**
    attack. We will analyze a simple IIS 6.0 vulnerability which allows the attacker
    to crash the server by sending a POST request containing more than 40000 request
    parameters. We will analyze the vulnerability shortly. This module has been tested
    on an unpatched Windows 2003 server running IIS 6.0\. The module we will be using
    is `ms10_065_ii6_asp_dos:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once the module is executed using the run command, it will start attacking the
    target IIS server by sending an HTTP request on port 80 with the URI as page.asp.
    Successful execution of the module will lead to a complete denial of the service
    of the IIS server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us take a quick look at the two vulnerabilities. The oracle database vulnerability
    is exploited by injecting a custom PL/SQL function which is executed in SYS context
    and it elevates the privilege of user "scott" as administrator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now injecting this function in the vulnerable procedure will lead to a privilege
    escalation for the user scott.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding lines of codes explain the injection process. The detailed analysis
    of vulnerability in the Oracle software is beyond the scope of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Now moving the DOS attack module which exploits vulnerability in the IIS 6.0
    server. The attacker sends a POST request which includes more than 40000 request
    parameters, and is sent in the form of an `application/x-www-form-urlencoded`
    encoding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a part of a script that serves the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script generates a payload size of more than 40000\. Then,
    a connection is established on port 80 to send an HTTP request to the IIS server.
    Once the request has been rendered by the server, it will crash and will stop
    working unless restarted.
  prefs: []
  type: TYPE_NORMAL
- en: Post-exploitation modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have worked a lot on the post exploitation phase using various powers
    of meterpreter. However, we also have a separate dedicated list of modules that
    can enhance our penetration testing experience. As they are post exploitation
    modules, we will need an active session with our target. We can use any of the
    methods described in previous chapters to gain access to our target.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The post module is a collection of some of the most interesting and handy features
    that you can use while penetration testing. Let us quickly analyze some of them
    here. Here we are using an unpatched Windows 7 machine as our target with an active
    meterpreter session.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can locate the post modules in `modules/post/windows/gather`. Let us start
    with a simple `enum_logged_on_users` module. This post module will list the current
    logged in users in the Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: We will execute the module through our active meterpreter session. Also, keep
    in mind to escalate the privilege by using the `getsystem` command in order to
    avoid any errors during the execution of the module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Successful execution of the module shows us two tables. The first table reflects
    the currently logged in user and the second table reflects the recently logged
    in user. Follow the correct path while executing the modules. We have used the
    `run` command to execute the modules as they are all in the form of Ruby script
    so meterpreter can easily identify it.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take one more example. There is an interesting post module that captures
    a screenshot of the target desktop. This module can be useful when we have to
    know whether there is any active user or not. The module we will use is `screen_spy.rb:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed how easy and useful post modules can be. In the coming
    future, the developers of Metasploit will be focusing more on post modules rather
    than meterpreter as it greatly enhances the functionality of penetration testing.
    So if you are looking to contribute to the Metasploit community then you can work
    on post modules.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can analyze the scripts of `enum_logged_on_user.rb` and `screen_spy.rb` at
    `modules/post/windows/gather`. It can help us in getting insight about how these
    modules function.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of module building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen the utility of modules and the power that they can add
    to the framework. In order to master the framework, it is essential to understand
    the working and building of modules. This will help us in quickly extending the
    framework according to our needs. In the next few recipes, we will see how we
    can use ruby scripting to build our own modules and import them into the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start building our own module we will need basic knowledge of Ruby scripting.
    We have already discussed the use and implementation of Ruby in meterpreter scripting.
    In this recipe, we will see how we can use Ruby to start building modules for
    the framework. The process is very much similar to meterpreter scripting. The
    difference lies in using a set of pre-defined lines that will be required in order
    to make the framework understand the requirements and nature of the module. So
    let us discuss some of the essential requirements for module building.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every module in the framework is in the form of a Ruby script and is located
    in the modules directory. We will have to import some of the framework libraries
    depending on our needs. Let us move ahead and see how we can import the libraries
    in our script and design a fully-functional module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with some of the basics of module building. In order to make our
    module readable for the framework, we will have to import MSF libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the first and foremost line of every script. This line tells that the
    module will include all the dependencies and functionalities of the Metasploit
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This line defines the class which inherits the properties of the auxiliary
    family. The auxiliary module can import several functionalities such as scanning,
    opening connections, using the database, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `include` statement can be used to include a particular functionality of
    the framework into our own module. For example, if we are building a scanner module
    then we can include it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This line will include the functionality of a remote TCP scan in the module.
    This line will pull out the main scan module libraries from the Metasploit library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next few lines of script give us an introduction about the module like
    its name, version, author, description, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The next few lines of the script are used to initialize values for the script.
    The options which are marked as `true` are those which are essentially required
    for the modules, whereas the options marked as `no` are optional. These values
    can be passed/changed during the execution of the module.
  prefs: []
  type: TYPE_NORMAL
- en: These are some common lines of script that you will find in every module. Analysis
    of in-built scripts is the best way to learn more about script building. There
    are a few documentations available for learning module building. The best way
    to learn is by mastering Ruby scripting and by analyzing existing modules. In
    the next recipe, we will analyze a complete module from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing an existing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have built some background about module building in our previous
    recipe, our next step will be to analyze existing modules. It is highly recommended
    that you should look at the scripts of existing modules if you have to learn and
    dive deeper into module and platform development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will analyze a simple ftp module here in order to dive deeper into module
    building.
  prefs: []
  type: TYPE_NORMAL
- en: We will proceed from where we left off in the previous recipe. We have already
    discussed the basic template of the module in the previous recipe so here we will
    start from the main body of the script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be analyzing the ftp anonymous access module. You can find the main
    script at the following location: `pentest/exploits/framework3/modules/auxiliary/scanner/ftp/anonymous.rb`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete script for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let us move to the next section and analyze the script in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with the analysis of the main script body to understand how it
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function is used to begin the connection. The res variable holds the Boolean
    value true or false. The `connect_login` function is a specific function used
    by the module to establish a connection with the remote host. Depending upon the
    success or failure of connection, the Boolean value is stored in res.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once the connection has been set up, the module tries to check if the anonymous
    user has read/write privileges or not. The `write_check` variable checks if a
    write operation is possible or not. Then it is checked whether the operation succeeded
    or not. Depending upon the status of the privilege, a message is printed on the
    screen. If the write operation fails then the status is printed as `ro` or `read-only:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The next function is used to report authorization info. It reflects important
    parameters such as host, port, user, pass, and so on. These are the values that
    appear to us when we use the `show options` command so these values are user dependent.
  prefs: []
  type: TYPE_NORMAL
- en: This was a quick demonstration of how a simple module functions within the framework.
    You can change the existing scripts accordingly to meet your needs. This makes
    the platform extremely portable to development. As I have said it, the best way
    to learn more about module building is by analyzing the existing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next recipe, we will see how to build our own module and pass it into
    the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own post-exploitation module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have covered enough background about building modules. Here, we will
    see an example of how we can build our own module and add it into the framework.
    Building modules can be very handy as they will give us the power of extending
    the framework depending on our need.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us build a small post exploitation module that will enumerate all the installed
    applications on the target machine. As it is a post exploitation module, we will
    require a compromised target in order to execute the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with building the module, we will first import the framework libraries
    and include the required dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The script starts with including the Metasploit core libraries. Then, we build
    up the class that extends the properties of Msf::Post modules.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the `initialize` function which is used to initialize and define
    the module properties and description. This basic structure remains the same in
    almost all modules. The thing to note here is that we have included 'rex', as
    well as 'registry' libraries. This will make the framework easy to figure out
    our requirements in the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our next step will be to create a table that can display our extracted
    result. We have a special library `Rex::Ui::Text` which can be used for this task.
    We will have to define different columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The script body starts with building the table and providing different column
    names. Then, a separate array of registry locations is created which will be used
    to enumerate the application list. The array will consist of different registry
    entries that contain information about installed applications on the target machine.
    The application information is maintained in a separate array named as `apps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we start the enumeration process by running a loop that looks into different
    registry locations stored in the `appskey` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next lines of script populate the table with different values in the respective
    columns. The script uses an in-built function `registry_getvaldata` which fetches
    the values and adds them to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The last few lines of the script are used for storing the information in a separate
    text file named `applications.txt`. The file is populated by using the `store_loot`
    function which stores the complete table in the text file.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, an output is displayed on the screen stating that the file has been
    created and results have been stored in it.
  prefs: []
  type: TYPE_NORMAL
- en: The next step will be to store the complete program in a respective directory.
    You have to make sure that you choose the correct directory for storing your module.
    This will help the framework in clearly understanding the utility of the module
    and will maintain a hierarchy. Maintaining a hierarchy while updating modules
    will help in keeping a proper track of what exactly the module is targeting. For
    example, keeping an Internet Explorer module under the `modules/exploits/windows/browser`
    directory will help us in easily locating any new or existing browser module at
    this location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify the location of module storage, there are the following points
    you should look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Type of module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation performed by the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Affected software or operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metasploit follows the hierarchy of 'generalized to specialized' format for
    storing modules. It starts with the type of modules such as an exploit module
    or an auxiliary module. Then it picks up a generalized name, for example the name
    of an affected operating system. Then it creates a more specialized functionality,
    for example the module is used for browsers. Finally, the most specific naming
    is used like the name of the browser that the module is targeting.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider our module. This module is a post exploitation module that is
    used to enumerate a Windows operating system and gathers information about the
    system. So our module should follow this convention for storing.
  prefs: []
  type: TYPE_NORMAL
- en: So our destination folder should be `modules/post/windows/gather/`.
  prefs: []
  type: TYPE_NORMAL
- en: You can save the module with your desired name and with a.rb extension. Let's
    save it as `enum_applications.rb`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have saved the module in its preferred directory, the next step will
    be to execute it and see if it is working fine. We have already seen the process
    of module execution in previous recipes. The module name is used to execute it
    from the MSF terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This was a small example of how you can build and add your own module to the
    framework. You definitely need a sound knowledge of Ruby scripting if you want
    to build good modules. You can also contribute to the Metasploit community by
    releasing your module and let others. benefit from it.
  prefs: []
  type: TYPE_NORMAL
