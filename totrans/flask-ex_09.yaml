- en: Chapter 9. Building a Waiter Caller App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After going through the headlines project, in which you learned the basics of
    Flask, and the Crimemap project, in which you learned about some more useful Flask
    features, such as how to use a database and how to write some basic JavaScript
    code, we're now ready for our most sophisticated project yet! We will build a
    waiter caller web application that allows restaurant patrons to easily call a
    waiter to their table. The restaurant manager will easily be able to register
    for and start using our application without the need to invest in expensive hardware.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive even deeper into the Flask world, taking a look at some Flask extensions
    to help us with user account control and web forms, and we'll look at how to use
    template inheritance in Jinja, too. We'll also use the Bootstrap frontend framework
    so that we don't have to do so much of the HTML and CSS code from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast with the MySQL database we used for our previous application, we''ll
    take a look at a controversial alternative: MongoDB. MongoDB is a NoSQL database,
    which means that we don''t deal with tables, rows, and columns in it. We''ll also
    discuss exactly what this means.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most difficult tasks for a waiter is to know when a patron needs
    something. Either the patron complains that they waited for far too long before
    the waiter came and asked about dessert options, or they complain that the waiter
    was constantly interrupting conversation in order to ask whether everything was
    all right. In order to solve this problem, some restaurants install dedicated
    buttons at each table which, when pressed, notify the waiter that his attention
    is wanted. However, the cost of specialized hardware and installation is prohibitive
    for smaller establishments and often just too much hassle for larger ones.
  prefs: []
  type: TYPE_NORMAL
- en: In our modern day and age, nearly all restaurant-goers have smartphones, and
    we can leverage this fact to provide restaurants with a much more cost-effective
    solution. When patrons want attention, they will simply visit a short URL on their
    phone, and the waiters will receive a notification on a centralized screen.
  prefs: []
  type: TYPE_NORMAL
- en: We want the application to allow for multiple, unrelated restaurants to use
    the same web application, so each should have a private login account for our
    system. We want it to be easy for the restaurant manager to set up; that is, we
    as developers should not need to be involved at all when a new restaurant joins
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup required for our application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The restaurant manager signs up a new account on our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The restaurant manager provides basic information about how many tables the
    restaurant has
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web application provides a unique URL for each table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The restaurant manager prints out these URLs and ensures that the relevant URL
    is easily accessible from each table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The usage of our application should have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: The restaurant staff should be able to log into the web application from a centralized
    screen and see a simple notification page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some patrons would want service and visit the URL relevant to their table on
    a smartphone, so this should be possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In real time, the waiters should see a notification appear on a centralized
    screen. The waiter will then acknowledge the notification on the screen and attend
    to the patrons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If more notifications arrive before the first one is acknowledged, the later
    ones should appear beneath the earlier ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Over the next three chapters, we'll implement a Flask application that has all
    of the preceding features. We'll have a database to store the account information
    of all the individual restaurants that register to use our application so that
    we can process patron requests for each of them individually. Patrons will be
    able to make requests, which will be registered in the database, while the restaurant
    staff will be able to view current attention requests for their establishment.
    We'll build a user account control system so that restaurants can have their own
    password-protected accounts for our application.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, we'll set up a new Flask application, Git repository, and Apache
    configuration to serve our new project. We'll introduce Twitter's Bootstrap framework
    as the one we'll use on the frontend. We'll download a basic Bootstrap template
    as a start for the frontend of our application and make some changes to integrate
    it into a basic Flask application. Then, we'll set up a user account control system
    that allows users to register, log in, and log out of our application by supplying
    an e-mail address and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new `git` repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Bootstrap to kick-start our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding User Account Control to our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a new Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, we need to create a new `git` repository to host our new project.
    The first step is to go to log into the web interface of BitBucket or whichever
    code repository host you are using, select the **Create a new Repository** option,
    and select the **Git** radio option, taking note of the URL with which it provides
    you. As the next steps are identical to the previous projects, we will give you
    only a summary. If you need more fine-grained guidance, refer to the *Installing
    and using git* section of [Chapter 1](ch01.html "Chapter 1. Hello, World!"), *Hello,
    World!*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the new project locally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To set up the local project structure, run the following commands locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to get the minimal running app for this project so that we can iron
    out any configuration issues before we get started with development. Add the following
    to your `waitercaller.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `push` the project outline to the repository with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the project on our VPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On your VPS, run the following commands to clone the repository, and set up
    Apache2 to serve our new project as the default website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the `.wsgi` file we created with the most recent
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, hit *Ctrl* + *X* and select *Y* when prompted to quit Nano.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, create the Apache configuration file by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following configuration data to the `waitercaller.conf` file we just
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Quit Nano, saving the new file as before. Now, to disable our `crimemap` project
    as the default site and enable our new project instead, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Verify that everything worked by visiting the IP address of your VPS in your
    web browser. You should see the **Under construction** string. Have another look
    at your configuration and log files if things don't work out as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Using Bootstrap to kick-start our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous projects, we spent quite a bit of time on frontend work, fiddling
    around with CSS and HTML, and we didn't even touch on some of the frontend problems
    that web application developers need to be aware of, such as making sure our content
    looks good and functions correctly on all devices of all screen sizes running
    any browser on any operating system. This diversity of browsers and devices as
    well as the inconsistent way in which each of them implements certain JavaScript,
    HTML, and CSS functionality is one of the biggest challenges of web development,
    and there is no silver bullet to solve the problem. However, frontend frameworks
    such as Bootstrap can take away some of the pain, providing shortcuts for developers
    to improve their user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bootstrap was developed by Twitter and is released under an open license. It
    can greatly speed up CSS development as it provides many styles for different
    HTML layouts and form inputs. It can also provide *responsiveness*; that is, it
    can allow your website to automatically change the layout of certain elements
    based on the screen size of your user's device. We'll discuss exactly what this
    means for us and for this project later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bootstrap has faced some criticism, but it still holds its popularity. There
    are many alternatives with different strengths and weaknesses. As modern web development
    is a fast-evolving field, there are also many new frameworks that appear regularly.
    Existing frameworks often get major updates and don't provide backward compatibility
    to old versions. For important production web applications, current research into
    what best fits the specific needs of this project is always crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap's main offerings are reusable in CSS and JavaScript modules. We'll
    mainly use it for its CSS components.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at Bootstrap's homepage at [http://getbootstrap.com/](http://getbootstrap.com/)
    as well as the subpages at [http://getbootstrap.com/getting-started/#examples](http://getbootstrap.com/getting-started/#examples)
    and [http://getbootstrap.com/components/](http://getbootstrap.com/components/)
    to get an idea of what Bootstrap provides.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of writing CSS from scratch, Bootstrap allows us to use various inputs,
    icons, navigation bars, and other often-needed components of a website that look
    good by default.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Bootstrap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few ways to install Bootstrap, but keeping in mind that Bootstrap
    can be thought of as a collection of some JavaScript, CSS, and icon files, we
    will not do anything too fancy. We can simply download a `.zip` file of the compiled
    code files and use these files in our local project. We''ll include bootstrap
    in our `git` repository, so there is no need to install it on our VPS as well.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Head over to [http://getbootstrap.com/getting-started/#download](http://getbootstrap.com/getting-started/#download)
    and select the **Download Bootstrap** option, which should be the compiled and
    minified version without documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unzip the file you downloaded, and you'll find a single directory called `bootstrap-3.x.x`
    (here, the repeated letter x represents numbers that indicate which version of
    Bootstrap is contained). Inside the directory, there will be some subdirectories,
    probably `js`, `css`, and `fonts`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the `js`, `css`, and `fonts` directories to the `static` directory of
    the `waitercaller` project. Your project should now have the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because of the regular Bootstrap updates, we included a complete copy of the
    code for Bootstrap 3.3.5 in the accompanying code bundle (the latest version during
    the writing of this book). While the latest version is probably better, it might
    not be compatible with the examples we give. You can choose to test the waters
    with the version we provide, knowing that the examples should work as expected,
    or jump in at the deep end and, if necessary, try to work out how to adapt the
    examples to the newer Bootstrap code.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bootstrap strongly encourages users to build customized frontend pages instead
    of simply using existing templates. You've probably noticed a lot of modern web
    pages look very similar; this is because frontend designing is difficult, and
    people like taking shortcuts. As this book focuses on Flask development, we'll
    also take a bit of a frontend shortcut and start with one of the example template
    files that Bootstrap provides. The template file we'll work with can be seen at
    [http://getbootstrap.com/examples/jumbotron/](http://getbootstrap.com/examples/jumbotron/),
    and the adaptation for our project can be found in the accompanying code bundle
    for this chapter at `tempates/home.html`. You can note from the similarity of
    the two files that we didn't have to do too much work to get a basic web page
    that also looks good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the code from the `templates/home.html` file in the code bundle to the
    same place in your own project directory that we created earlier. If you included
    all the Bootstrap files properly in your `static` folder, opening this new file
    directly in your web browser will result in a page that looks similar to the following
    screenshot. (Note that at this stage, we still use pure HTML and none of the Jinja
    functionality, so you can just open the file locally in your web browser instead
    of serving it from a Flask application.):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap templates](img/B04312_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can note the advantages of the styling of inputs, headers, the navigation
    bar, and Jumbotron (the gray bar near the top with the oversized **Waiter Caller**
    text in it) that we can achieve with very little code. However, perhaps the most
    significant time-saving element of using Bootstrap is the *responsiveness* that
    our site has. Bootstrap is based on a grid layout, which means that different
    elements of the grid can rearrange themselves to better fit on any device. Note
    this part of HTML from the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A `"row"` has space for 12 columns. Our three main content elements below the
    Jumbotron each take up four columns, thus filling the row (*4 x 3 = 12*). We specified
    this using the `class="col-md-4"` attribute. Think of this as a medium (`md`)
    column of size four. You can read more about how the grid system works and take
    a look at some examples at [http://getbootstrap.com/css/](http://getbootstrap.com/css/).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also some code that doesn''t look used in the preceding screenshot,
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The two preceding excerpts are perhaps the most important components in making
    our web application responsive. To understand what this means, resize your browser
    window while the page is open. This simulates how our page will be seen on smaller
    devices, such as phones and tablets. It should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap templates](img/B04312_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can note that our three main content elements that used the Bootstrap grid
    functionality are now arranged beneath each other instead of side by side. This
    is ideal for smaller devices in which users are more used to scrolling down than
    to looking for more content on the side. Our navigation bar has also become more
    concise with the login inputs now hidden.
  prefs: []
  type: TYPE_NORMAL
- en: These can be revealed by selecting the *hamburger* icon in the upper right-hand
    corner; this is a controversial, but highly prevalent, element in web development.
    Most users instinctively know that they can touch the icon to get some form of
    menu or expansion, but there are many criticisms of using this technique. For
    now, we'll just accept this as normal practice and not go into the problems behind
    it. It's definitely better than trying to display exactly the same content no
    matter the screen size and having our users zoom into the page section by section,
    depending on which part they need to see.
  prefs: []
  type: TYPE_NORMAL
- en: Adding user account control to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For user account control, a user is expected to log in and authenticate using
    a password. For example, when you log in to your Webmail account, you enter your
    password upon visiting the page. Thereafter, all your actions are taken as authenticated;
    that is, you do not have to enter your password again when you send an e-mail.
    The Webmail client *remembers* that you are logged in, and you are therefore allowed
    to complete certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: However, HTTP is a stateless protocol, which means that we have no direct way
    of knowing that the user who logged in is the same user who made the request to
    send an e-mail. As a workaround for this problem, we will give the user a cookie
    when he or she logs in initially, and the user's browser will then send this cookie
    to us with *every* subsequent request. We'll use our database to keep track of
    which users are currently logged in. This allows us to authenticate the user for
    every request without requesting the user's password multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: We could implement this from scratch using Flask cookies in a similar way to
    what we saw in our Headlines project. However, there are numerous steps that we
    would need to implement, such as selecting which pages in our application require
    authentication and ensuring that the cookie is secure, and be involved in deciding
    what information to store in the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we'll go up one level of abstraction and use the `Flask-Login` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Flask-Login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Flask-Login` is a Flask extension that implements the groundwork required
    for all user account control systems. To use this, we need to install it through
    `pip` and then create a user class that follows a specific pattern. You can find
    a summary of `Flask-Login` as well as comprehensive documentation at [https://flask-login.readthedocs.org/en/latest/](https://flask-login.readthedocs.org/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and importing Flask-Login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install `Flask-Login`, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As with all the Python modules we install, remember to do this both locally
    and on your VPS.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, we'll add the most basic login functionality possible. Our application
    will display **You are logged in** for users who have authenticated, but users
    who do not enter a correct password will not be able to see the message.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flask extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we install Flask extensions, we can automatically access them through
    the `flask.ext` path. The first class we''ll use from the `Flask-Login` extension
    is the so-called `LoginManager` class. We''ll also use the `@login_required` decorator
    to specify which routes are restricted to users who are logged in. Add the following
    imports to your `waitercaller.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to connect the extension to our Flask app. In a pattern that will
    become familiar as we use more Flask extensions, add the following line to `waitercaller.py`
    directly below the place where you create the `app` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `LoginManager` class we instantiated now has a reference to our application.
    We'll use this new `LoginManager` class to—you guessed it—manage logins for our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a restricted route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's add a route to our application at `/account` and make sure that only
    authenticated users can view this page. The easy part of this step is to make
    sure that *non* authenticated users *can't* see the page, so we'll start with
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want our application to render our Bootstrap template by default.
    Add the following route to the `waitercaller.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll add a restricted route that users who aren''t logged in can''t
    see. Add the following function to `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're using the `@login_required` decorator. Similarly to the `@app.route`
    decorator, this is a function that takes the function below it as input and returns
    a modified function. In this case, instead of the routing magic, it'll verify
    that the user is logged in, and if not, it'll redirect the user to an **Unauthorized**
    page instead of returning the content we specified in the `return` statement.
    It's important that the `@app.route` decorator is first and the `@login_required`
    one is below it, as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You've probably seen **404 page not found** errors sometimes while browsing
    the Web. While **404** is especially infamous, there are many error codes that
    are part of the HTTP specification. Different browsers may show different default
    error messages when these are received, and it's also possible to define custom
    error pages to be shown when the specified errors are hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we haven''t set up any of the login logic yet, no user should be able to
    authenticate and view the new route we created. Start your Flask application locally
    and try to visit the account route at `localhost:5000/account`. If all went well,
    you should see an unauthorized error message similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a restricted route](img/B04312_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Authenticating a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Internet can be a dark and scary place. This is why you need to put passwords
    into many web applications; the password proves that you are who you claim to
    be. By telling us something that only you know, the web application knows you
    are "you" and not an imposter.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to implement a password checking system would be to store passwords
    associated with usernames in a database. When the user logs in, you need to first
    verify that the username exists, and if it does, you need to verify that the password
    the user just gave matches the one that he or she used when registering.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this is a terrible idea. Databases may be accessed by any number
    of people, including employees of the company that runs the web application and,
    potentially, hackers. Instead, we'll eventually store a cryptographic hash of
    the user's password; however for now, to make sure our login system works, we'll
    work with plaintext passwords.
  prefs: []
  type: TYPE_NORMAL
- en: We'll set up a mock database that is very similar to the one we used in our
    Crime Map project and check whether we can allow a mock user to view our `account`
    page if, and only if, the correct password is entered.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we are using the `Flask-Login` module, we need to create a `User` class that
    conforms to a strict format. `Flask-Login` is flexible enough to allow some more
    advanced login functionality, such as distinguishing between *active* and *nonactive*
    accounts as well as anonymous users. We won't use these features, but we need
    to create a `User` class that can work with `Flask-Login`, so we'll have some
    methods that look redundant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `user.py` in your `waitercaller` directory. Add the
    following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Flask-Login` requires that we implement a `get_id()` method in our `User`
    class that returns a unique identifier for the user. We''ll be using the user''s
    e-mail address for this, so in the `get_id()` function we can simply return that.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll regard all our users as having active accounts; so, in this method, which
    is also required, we'll simply return `True`. The opposite goes for the `is_anonymous()`
    function; while this is also required, we won't deal with the concept of anonymous
    logins in our application, so we'll always return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: The last function may look a bit odd; we'll always return `True` for `is_authenticated()`.
    This is because we only create the user object when the correct username and password
    combination is entered, so if the user object exists, it'll be authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking our database for users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll create a `MockDBHelper` class again and also create a configuration file
    to indicate that this should be used locally when we test our application and
    don't have access to the database. It needs to have a function that takes a username
    and password and checks whether these exist in the database and are associated
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a file called `mockdbhelper.py` in your `waitercaller` directory
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At the top, we have a dictionary that acts as the database storage. We have
    a single `get_user()` method that checks whether a user exists in our database
    and returns the password if it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a `config.py` file in the `waitercaller` directory and add the
    single line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As in our last project, this file will let our application know whether it
    is running in our test (local) environment or in our production (VPS) one. Unlike
    our previous project, we''ll add other information into this file later that doesn''t
    involve the database, which is why we''ll call it `config.py` instead of `dbconfig.py`.
    We don''t want to check this file into our `git` repository as it''ll be different
    on our VPS and will also contain sensitive database credentials that we don''t
    want to store; so, create a `.gitignore` file in your `waitercaller` directory
    with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Logging in a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our template already has a login form set up that allows a user to enter an
    e-mail and a password. We'll now set up functionality that allows us to enter
    and check the input into this form against our mock database. If we enter an e-mail
    and password that exist in our mock database, we'll log the user in and allow
    access to our `/account` route. If not, we'll just redirect back to the home page
    (we'll look at displaying feedback to a user who inputs invalid information in
    the next chapter in the *Adding user feedback using WTForms* section).
  prefs: []
  type: TYPE_NORMAL
- en: Adding imports and configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need to import the `login_user` function that is part of the `Flask-Login`
    extension as well as our new `User` class code and database helper. Add the following
    lines to your imports in `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we don't have a database helper except for our mock one at the moment, we'll
    always import the mock one. Later, we'll use the value in `config.py` to decide
    which database helper to `import`—the real or mock one—as we did in our previous
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create a `DBHelper` global class so that our application code
    can easily talk to our database. Add the following line beneath the import section
    of `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we also need to configure a secret key for our application. This is
    used to cryptographically sign the session information cookies that `Flask-Login`
    hands out to our users when they log in. Signing the cookies prevents our users
    from editing them manually, which helps prevent fraudulent logins. For this step,
    you should create a long and secure secret key; you will never have to remember
    it, so don''t think about it as you would about a password or passphrase. Although
    randomly mashing your keyboard should be sufficient, humans are generally terrible
    at creating unbiased randomness, so you could also use the following command to
    create a random string using `/dev/urandom` (changing `100` to the number of characters
    you want) via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a long random string of characters, add the following line to
    your `waitercaller.py` file under the place where you declared the `app` variable,
    substituting the random characters for your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Adding the login functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two main parts of logging a user in to consider. The first is when
    the user enters an e-mail address and password to authenticate, and the second
    is when the user does so by sending the required cookie—that is, he or she is
    still in the same browser *session* as when a successful login was completed.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the login function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We already created the stub of our login route for the first case, so now, we
    will flesh that out a bit to check the input information against our database
    and use `Flask-Login` to log the user in if the e-mail and password match.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also introduce a cleaner way of calling one Flask route from a separate
    one. Add the following lines to the imports section of `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first takes a URL and creates a response for a route that simply redirects
    the user to the URL specified. The second builds a URL from a function name. In
    Flask applications, you'll often see these two functions used together, as in
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the login function in `waitercaller.py` to match what follows through
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add `import` for the `request` library. Add the following line
    to the `import` section of `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We'll load the user's input into `email` and `password` variables and then load
    the stored password into a `user_password` variable. The `if` statement is verbose
    as we explicitly verified that a password was returned (that is, we verified that
    the user exists) and that the password was correct, even though the second condition
    implies the first. Later on, we'll talk about the trade-off of differentiating
    between the two conditions when giving feedback to our user.
  prefs: []
  type: TYPE_NORMAL
- en: If everything is valid, we will create a `User` object from the e-mail address,
    now using the e-mail address as the unique identifier required by Flask login.
    We will then pass our `User` object to the `Flask-Login` module's `login_user()`
    function so that it can handle the authentication magic. If the login is successful,
    we will redirect the user to the account page. As the user is now logged in, this
    will return the `"You are logged in"` string instead of the `"Unauthorized"` error
    we got before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we will create a URL for our account page using the `url_for()` function.
    We will pass the result of this into the `redirect()` function so that the user
    is taken from the `/login` route to the `/account` one. This is preferable to
    simply using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our intention is more explicit, and the user will see the correct URL in the
    browser (that is, both will take the user to the `/account` page), but if we don't
    use the `redirect()` function, `/login` will still be displayed in the browser
    even on the `/account` page.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the load_user function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the user has already logged in, their browser will send us information through
    the cookie that `Flask-Login` gave them when we called the `login_user` function.
    This cookie contains a reference to the unique identifier we specified when we
    created our `User` object—in our case, the e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: '`Flask-Login` has an existing function that we called `user_loader`, which
    will handle this for us; we just need to use it as a decorator for our own function
    that checks the database to make sure the user exists and creates a `User` object
    from the identifier we are given.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function to your `waitercaller.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The decorator indicates to `Flask-Login` that this is the function we want to
    use to handle users who already have a cookie assigned, and it'll pass the `user_id`
    variable from the cookie to this function whenever a user visits our site, which
    already has one. Similarly to what we did before, we will check whether the user
    is in our database (`user_password` will be blank if `user_id` is invalid), and
    if it is, we will recreate the `User` object. We'll never explicitly call this
    function or use the result as it'll only be used by the `Flask-Login` code, but
    our application will throw an error if a user who is given a cookie by our `login()`
    function visits the site and `Flask-Login` can't find an implementation for this
    `user_loader()` function.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem unnecessary to check the database in this step considering we
    gave the user a supposedly tamper-proof token that proves that he or she is a
    valid user, but it is in fact necessary as the database may have been updated
    since the user last logged in. If we make the user's session token valid for a
    long time (recall that in our Headlines project, we made the cookies last for
    a year), there is the possibility that the user's account will have been modified
    or deleted since the cookie was assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the login functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's time to give our new login functionality a try! Fire up the `waitercaller.py`
    file locally and visit `localhost:5000` in your web browser. Type in the e-mail
    ID `test@example.com` and password `123456` from our mock database and hit the
    login button. You should be redirected to `http://localhost:5000/account` and
    view the **You are logged in** message.
  prefs: []
  type: TYPE_NORMAL
- en: Close your browser and reopen it, this time visiting `localhost:5000/account`
    directly. As we didn't tell `Flask-Login` to remember users, you should now see
    the **Unauthorized** error again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the nature of our application, we would expect most users to want
    to stay logged in so that the restaurant staff can simply open the page in the
    morning and use the functionality straightaway. `Flask-Login` makes this change
    very straightforward. Simply change the line of your `login()` function that reads
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Your new `login()` function should now read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you repeat the preceding steps, you should view the **You are logged
    in** message as shown in the following screenshot, even after restarting your
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the login functionality](img/B04312_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we can log a user in, let's take a look at how we can allow the user
    to log out as well.
  prefs: []
  type: TYPE_NORMAL
- en: Logging out a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Flask-Login` provides a logout function that works straight out of the box.
    All we have to do is link it up to a route. Add the following route to your `waitercaller.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `import` for the `logout_user()` function to the imports section
    of `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note here that there's no need to pass the `User` object to `Flask-Login` for
    this call; the `logout()` function simply removes the session cookie from the
    user's browser. Once the user is logged out, we can redirect them back to the
    home page.
  prefs: []
  type: TYPE_NORMAL
- en: Visit `localhost:5000/logout` in your browser and then attempt to visit `localhost:5000/account`
    again. You should see the **Unauthorized** error again as the `test@example.com`
    user got logged out.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's great that we can log users in, but at the moment we can only do so with
    the mock user that we hardcoded into our database. We need to be able to add new
    users to our database when the registration form is filled out. We'll still do
    all of this through our mock database, so every time our application is restarted,
    all the users will be lost (they will only be saved in the local Python dictionary
    variable, which is lost when the application is terminated).
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that storing the users' passwords was a very bad idea; so first,
    we'll take a brief look at how cryptographic hashing works and how we can manage
    passwords more securely.
  prefs: []
  type: TYPE_NORMAL
- en: Managing passwords with cryptographic hashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of storing the password, we want to store something that is *derived
    from* the password. When the user registers and gives us a password, we'll run
    some modification on it and store the result of the modification instead. Then,
    the next time the user visits our site and uses the password to log in, we can
    run the same modification on the input password and verify that the result matches
    what we stored.
  prefs: []
  type: TYPE_NORMAL
- en: The catch is that we want our modification to be nonreversible; that is, someone
    who has access to the modified password should not be able to deduce the original.
  prefs: []
  type: TYPE_NORMAL
- en: Enter hash functions. These little pieces of mathematical wizardry take a string
    as input and return a (big) number as output. The same string input will always
    result in the same output, but it is almost impossible for two different inputs
    to produce the same output. Hash functions are so-called *one-way* functions as
    it is provably impossible to deduce the input if you only have the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Password storage and management is a big topic that we can only touch on in
    this project. For more information on most things regarding information security,
    [www.owasp.org](http://www.owasp.org) is a good resource. Their comprehensive
    guide to storing passwords securely can be found at [https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet).
  prefs: []
  type: TYPE_NORMAL
- en: Python hashlib
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to use hash functions in Python. Run the following
    in a Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As output, you should see the hash **ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python hashlib](img/B04312_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The random-looking string of hexadecimal characters is the `sha512` hash of
    the `'123456'` string, and this is what we will store in our database. Every time
    the user enters the plaintext password, we'll run it through the hash function
    and verify that the two hashes meet up. If an attacker or employee sees the hash
    in the database, they cannot masquerade as the user because they cannot deduce
    `'123456'` from the hash.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing hashes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Actually, the heading of this section isn't entirely true. While there is no
    way to *reverse* a hash and write a function that takes the preceding hexadecimal
    string as input and produces `'123456'` as output, people can be pretty determined.
    The hacker may still try every possible likely input and run it through the same
    hash function and keep doing this until the hashes match up. When the hacker comes
    across an input that produces **ba3253876aed6bc22d4a6ff53d8406c6ad864195ed144ab5c87621b6c233b548baeae6956df346ec8c17f5ea10f35ee3cbc514797ed7ddd3145464e2a0bab413**
    as an output, he has effectively cracked the password.
  prefs: []
  type: TYPE_NORMAL
- en: However, hashing functions tend to need a lot of processing power, so it is
    not practical to run through large amounts of input (known as *brute forcing*).
    People have also created so-called rainbow tables with all common inputs precomputed
    and stored in a database so that the results can be found instantly. This is a
    classic *space-time* trade-off that is so often seen in computer science. If we
    compute hashes for all possible inputs, it will take a long time; if we want to
    compute every possible combination in advance so that we can look up the results
    instantly, we need a lot of storage space.
  prefs: []
  type: TYPE_NORMAL
- en: If you go to a hash reversal website, such as [http://md5decrypt.net/en/Sha512/](http://md5decrypt.net/en/Sha512/),
    and input the exact hex string you noted here, it'll tell you that the decrypted
    version is **123456**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing hashes](img/B04312_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It didn't actually try every possible combination of inputs in the claimed **0.143**
    seconds, but it stored the answer from a previous time when the hash was computed.
    Such sites have a large database containing mappings and plaintext strings along
    with their hashed equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you hash a string such as `b^78asdflkjwe@#xx...&AFs[--l` and paste the resulting
    hash into the md5decrypt website, you''ll note that the string is not common enough
    for this particular site to have precomputed, and instead of getting the plain
    text back again, you''ll get a screen that looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reversing hashes](img/B04312_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We want all of the passwords we store to be complicated enough to not exist
    in precomputed hash tables. However, our users are more likely to choose passwords
    that are common enough that they *have* been precomputed. The solution is to add
    what is known as *salt* to our passwords before we store them.
  prefs: []
  type: TYPE_NORMAL
- en: Salting passwords
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As users tend to use weak passwords, such as `123456`, that quite likely exist
    in precomputed hash tables, we want to do our users a favor and add some random
    value to their passwords when we store them. This makes it even more difficult
    for a malicious attacker who has access to the stored hash to gain the user's
    private password, even though we will store the random value we used with the
    password. This is known as *salting* the password; similarly to salting food,
    it is easy for us to add some salt to the password, but removing the salt is hopefully
    impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept a plaintext password from the user at registration time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add some random value (salt) to this password to strengthen it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash the concatenation of the password and salt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the hash and salt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the user logs in, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the plaintext password from the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the stored salt in our database and add it to the user's input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash the concatenation of the password and salt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the result matches what we previously stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing secure password storage in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To implement the preceding, we'll create a very small `PasswordHelper` class
    that will take care of the hashing and generation of random salts. Although this
    is very little code, when we use the standard `hashlib`, `os`, and `base64` Python
    libraries, it is good practice to abstract all the cryptography logic to its own
    class. That way, if we change how we implement password management, we can make
    most of our changes to this new class and not have to touch the main application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to make some changes to our `login()` function, flesh out our `registration()`
    function, and create a new method for our database helper code that will add a
    new user to our mock database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PasswordHelper class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s start with `PasswordHelper`. Create a file called `passwordhelper.py`
    in your `waitercaller` directory and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two methods are used when a user registers for the first time and
    can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `get_hash()` method is just a wrapper of the `sha512` hash function that
    we looked at earlier. We'll use this to create the final hash that we will store
    in our database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `get_salt()` method uses `os.urandom()` to generate a cryptographically
    secure random string. We will encode this as a `base64` string as the random string
    may contain any bytes, some of which we may have issues with storing in our database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `validate_password()` method is used when the user logs in and gives us
    the original plaintext password again. We'll pass in what the user gave us (the
    `plain` parameter), the salt that we stored when they registered, and verify that
    hashing the two produces the same hash that we stored (the `expected` parameter).
  prefs: []
  type: TYPE_NORMAL
- en: Updating our database code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now need to store a password and salt associated with each user; we can't
    use the simple e-mail and password dictionary that we had before. Instead, for
    our mock database, we'll use a list of dictionaries, with every piece of information
    we need to store having a key and value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also update the code in `mockdbhelper.py` to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Our mock user still has the password `123456`, but a potential attacker can
    no longer work this out by looking up the hash in a rainbow table. We also created
    the `add_user()` function, which takes the `email`, `salt`, and `hashed` password
    for a new user and stores a record of this. Our `get_user()` method now needs
    to loop through all the mock users to find out whether any match the input e-mail
    address. This is inefficient but will be handled more efficiently by our database,
    and as we will never have hundreds of mock users, we don't need to worry about
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our application code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In our main `waitercaller.py` file, we need to add another `import` for our
    password helper and instantiate a global instance of our password helper class
    so that we can use it in our `register()` and `login()` functions. We also need
    to modify our `login()` function to account for the new database model and flesh
    out our `register()` function to perform some validation and call the database
    code to add a new user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the imports section of `waitercaller.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following near the place where you created the `DBHelper()` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, modify the `login()` function to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The only real change is in the `if` statement, in which we will now use the
    password helper to validate the password using the salt and user-provided password.
    We will also change the variable name of the user to `stored_user` as this is
    now a dictionary instead of just the password value it used to be.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to build the `register()` function. This will use the password
    and database helper to create a new salted and hashed password and store this
    along with the user's e-mail address in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `/register` route and associated function to the `waitercaller.py` file
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We asked the user to input their password twice on our registration form as
    it's easy for users to make a typo when they register and then not be able to
    access their account (as they registered with a different password from the one
    they meant to). Therefore, in this step, we can confirm that the two passwords
    entered by the user are the same.
  prefs: []
  type: TYPE_NORMAL
- en: We also verified that the user doesn't already exist as each user needs to use
    a unique e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we generated a salt, created a hash from the password and salt, and
    stored this in our database. Then, we redirected the user back to homepage, testing
    our registration functionality.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to give the application a test run again. Close your browser and restart
    the application locally. Visit the homepage and register an account by choosing
    an e-mail and password. When you get redirected to the homepage after registration,
    log in using the same username and password you just registered with. If all went
    well, you'll see the **You are logged in** message. Again, visit `http://localhost:5000/logout`
    in order to log out.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to use Bootstrap to make our application look
    good out of the box and to be responsive based on our user's screen size. We got
    a basic User Account Control system up and running, and we can register users,
    log users in, and log them out again.
  prefs: []
  type: TYPE_NORMAL
- en: We also spent some time looking at how to securely store passwords using cryptographic
    hash functions and salts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build out the functionality of our application, which
    we discussed in the project outline at the start of this chapter. We'll also look
    at an easier way to create the forms that our visitors will use to interact with
    our application.
  prefs: []
  type: TYPE_NORMAL
