- en: Assembly Language in Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to talk about assembly language programming in
    Linux. We will go through how to build our own code. An assembly language is a
    low-level programming language. Low-level programming languages are machine-dependent
    programming and are the simplest form that a computer understands. In assembly,
    you will be dealing with computer architecture components such as registers and
    stack, unlike most high-level programming languages such as Python or Java. Also,
    assembly is not a portable language, which means each assembly programming language
    is specific to one hardware or one computer architecture; for example, Intel has
    its own specific assembly language. We are learning assembly not to build a sophisticated
    software but to build our own customized shellcodes, so we will be going to make
    it very easy and simple.
  prefs: []
  type: TYPE_NORMAL
- en: I promise that, after this chapter, you will look at each program and process
    differently, and you will be able to understand how computers really execute your
    instructions. Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Assembly language code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we are not going to talk about the language structure but the code structure.
    Do you remember memory layout?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We are going to put our **executable code** in the `.text` section and our
    **variables** in the `.data` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s also have a closer look at the stack. The stack is **LIFO**, which means
    **Last Input First Output**, so it''s not random access, rather it uses push and
    pop operations. Push is to push something into the top of the stack. Let''s look
    at an example. Suppose that we have a stack and it contains only **0x1234**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s push something into the stack using the assembly `push 0x5678`.
    This instruction will push the value **0x5678** into the stack, and that will
    change the **stack pointer** to point to **0x5678**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we want to get data out of the stack, we use a `pop` instruction, and
    it will extract the last element pushed into the stack. So, taking the same stack
    layout, let''s extract the last element using `pop rax`, which will extract the
    value **0x5678** and move it to the **RAX** register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It's very simple!!
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to code assembly on Linux x64? Actually, it's quite simple;
    do you remember syscalls? This is how we are going to execute what we want by
    invoking system commands. For example, if I want to exit a program then I have
    to use the `exit` syscall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, this file, `/usr/include/x86_64-linux-gnu/asm/unistd_64.h`, contains
    all the syscalls for Linux x64\. Let''s search for the `exit` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `exit` syscall has a syscall number `60`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is only one argument, that is, `status`, and it has the `int` data type
    to define the exit status, such as zero status for no error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how we are going to use registers to invoke Linux x64 syscalls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We just put the **syscall number** in **RAX**, then the **first argument** in
    **RDI**, **second argument** in **RSI**, and so on, as shown in the preceding
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we are going to invoke the `exit` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.gif)'
  prefs: []
  type: TYPE_IMG
- en: We just put **60**, which is the `exit` syscall number in **RAX**, then we put
    **0** in **RDI**, which is the exit status; yes, it's that simple!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a deeper look at the assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line tells the processor to move the value `60` into `rax`, and in
    the second line it tells the processor to move the value `0` into `rdi`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the general structure of one instruction is `{Operation} {Destination},
    {Source}`.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data types are important in assembly. We can use them to define a variable or
    when we want to perform any operation on just a small portion of register or memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table explains the data types in assembly based on length:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Directive** | **Bytes** | **Bits** |'
  prefs: []
  type: TYPE_TB
- en: '| Byte | `db` | 1 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Word | `dw` | 2 | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| Doubleword | `dd` | 4 | 32 |'
  prefs: []
  type: TYPE_TB
- en: '| Quadword | `dq` | 8 | 64 |'
  prefs: []
  type: TYPE_TB
- en: To fully understand, we are going to build a hello world program in assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, let's start to go deeper. We are going to build a hello world, which is
    undoubtedly the basic building block for any programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to understand what we really need, which is a syscall to print
    `hello world` on the screen. To do this, let''s search for the `write` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `write` syscall is number `1`; now let''s look at its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `write` syscall has three arguments; the first one is the file descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The file descriptor has three modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Integer value** | **Name** | **Alias for** `stdio.h` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Standard input | `stdin` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | Standard output | `stdout` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | Standard error | `stderr` |'
  prefs: []
  type: TYPE_TB
- en: As we are going to print `hello world` on the screen, we are going to choose
    standard output `1`, the second argument, which is a pointer to the string we
    want to print; the third argument is the count of the string, including spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains what is going to be inside the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'And now, let''s jump to the full code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the `.data` section, which contains all the variables, the first variable
    in the code is the `hello_world` variable with data type byte (`db`), and it contains
    a `hello world` string along with `0xa`, which means a new line, like in `\n`
    in C. The second variable is `length`, that contains the length of `hello_world`
    string with `equ`, which means equal, and `$-`, which means evaluate the current
    line.
  prefs: []
  type: TYPE_NORMAL
- en: In the `.text` section, as we previously explained, we move `1` to `rax`, which
    indicates the `write` syscall number, then we move `1` to `rdi` as an indicator
    that the file descriptor is set to standard output, then we move the address of
    the `hello_world` string to `rsi`, and we move the length of the `hello_world`
    string to `rdx`, and finally, we invoke `syscall`, which means execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assemble and link the object code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding commands is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'It printed the `hello world` string but exited with `Segmentation fault` because
    the program doesn''t know where to go next. We can fix it by adding the `exit`
    syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We just added the `exit` syscall by moving `60` to `rax`, then we moved `1`
    to `rdi`, which indicates the exit status, and finally we invoked `syscall` to
    execute the `exit` syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s assemble the link and try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it''s exited normally; let''s also confirm the exit status using `echo
    $?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.gif)'
  prefs: []
  type: TYPE_IMG
- en: Exit status is `1`, as we selected!
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the previous chapter, a **stack** is a space allocated for
    each running application and is used to store variables and data. A stack supports
    two operations (push and pop); a **push** operation is used to push an element
    to the stack, and that will cause the stack pointer to move to a lower memory
    address (a stack grows from high memory to low memory) and point to the top of
    the stack, whereas **pop** takes the first element at the top of the stack and
    extracts it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is very simple; let''s compile and link it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then, I will run the application in a debugger (debuggers will be explained
    in the next chapter) just to show you how the stack really works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, before we run the program, all registers are empty except the RSP register, which
    is now pointing at the top of the stack `00007ffdb3f53950`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, the first instruction is executed, which moves `0x1234` to `rdx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, the `rdx` register now holds `0x1234` and there are no changes
    in the stack yet. The second instruction pushes the value of `rdx` into the Stack,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the Stack section; it moved to the lower address (from `50` to `48`),
    and now it contains `0x1234`. The third instruction is to push `0x5678` directly
    to the Stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The fourth instruction will extract the last element in the Stack to `rdi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the Stack now doesn''t contain `0x5678` anymore, and it moved
    to `rdi`. The last instruction will be to extract the last element in the Stack
    to `rsi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now the stack is back to normal and `0x1234` moved to `rsi`.
  prefs: []
  type: TYPE_NORMAL
- en: Well, so far, we have covered two basic examples on how to build a hello world
    program and also a push/pop operation in the stack, wherein we saw some basic
    instructions, such as `mov`, `push`, `pop`, and there is much more to come. Now,
    you might be wondering why I haven't explained any of those instructions and took
    you through the examples first. My strategy takes you to the next section; here,
    we will go through all the basic instructions required for an assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Data manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data manipulation** is moving data in assembly, and it is a very important
    topic because most of our operations will be moving data to execute instructions,
    so we have to really understand how to use them, such as the `mov` instruction,
    and how to move data between registers and between register and memory, copying
    addresses to registers, and how to swap the contents of two registers or between
    register and memory using the `xchg` instruction, then how to load the effective
    address of the source into the destination using the `lea` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: The mov instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `mov` instruction is the most important instruction used in assembly in
    Linux, and we used it in all the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: The `mov` instruction is used to move data between registers, and between registers
    and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples. First, let''s begin with moving data directly
    to registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will just copy `0x1234` to `rax` and `0x56789` to `rbx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go further and add some moving data between registers to the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What we added just moved the contents of both `rax` and `rbx` to `rdi` and
    `rsi` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to move data between registers and memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In `mov al, [mem1]`, the brackets mean move the contents of `mem1` to `al`.
    If we use `mov al, mem1` without brackets, it will move the pointer of `mem1`
    to `al`.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we moved `0x12` to the RAX register and, because we are moving
    only 8 bits, we used AL (the lower part of RAX register that can hold 8 bits)
    because we don't need to use all 64 bits. Also note that we defined the `mem1`
    memory section as `db`, which is byte, or it can hold 8 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **64-bit register** | **32-bit register** | **16-bit register** | **8-bit
    register** |'
  prefs: []
  type: TYPE_TB
- en: '| RAX | EAX | AX | AH, AL |'
  prefs: []
  type: TYPE_TB
- en: '| RBX | EBX | BX | BH, BL |'
  prefs: []
  type: TYPE_TB
- en: '| RCX | ECX | CX | CH, CL |'
  prefs: []
  type: TYPE_TB
- en: '| RDX | EDX | DX | DH, DL |'
  prefs: []
  type: TYPE_TB
- en: '| RSI | ESI | SI | SIL |'
  prefs: []
  type: TYPE_TB
- en: '| RDI | EDI | DI | DIL |'
  prefs: []
  type: TYPE_TB
- en: '| RSP | ESP | SP | SPL |'
  prefs: []
  type: TYPE_TB
- en: '| RBP | EBP | BP | BPL |'
  prefs: []
  type: TYPE_TB
- en: '| R8 | R8D | R8W | R8B |'
  prefs: []
  type: TYPE_TB
- en: '| R9 | R9D | R9W | R9B |'
  prefs: []
  type: TYPE_TB
- en: '| R10 | R10D | R10W | R10B |'
  prefs: []
  type: TYPE_TB
- en: '| R11 | R11D | R11W | R11B |'
  prefs: []
  type: TYPE_TB
- en: '| R12 | R12D | R12W | R12B |'
  prefs: []
  type: TYPE_TB
- en: '| R13 | R13D | R13W | R13B |'
  prefs: []
  type: TYPE_TB
- en: '| R14 | R14D | R14W | R14B |'
  prefs: []
  type: TYPE_TB
- en: '| R15 | R15D | R15W | R15B |'
  prefs: []
  type: TYPE_TB
- en: Then, we moved value `0x1234`, which is defined as `dw`, to the `rbx` register,
    and then we moved 2 bytes (16 bits) in BX, which can hold 16 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we moved the value `0x12345678`, which is defined as `dd`, to the RCX
    register, and it's 4 bytes (32 bits), to ECX.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, we moved `0x1234567891234567`, which is defined as `dq`, to the
    RDX register, and it''s 8 bytes (64 bits), so we moved it to RDX:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is what it looks like in the registers after executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about moving data from register to memory. Take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At the first and second instructions, we moved values directly to registers,
    and, in the third instruction, we moved the contents of register RAX (AL) to `mem1`
    and specified the length with byte. Then, in the fourth instruction, we moved
    the contents of register RBX (RX) to `mem2` and specified the length with word.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the contents of `mem1` and `mem2` before moving any values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screenshot is after moving values to `mem1` and `mem2`, which has
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Data swapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data swapping** is really easy too; it is used to exchange the contents of
    two registers or between register and memory using the `xchg` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we moved `0x1234` to the `rax` register, then we moved
    `0x5678` to the `rbx` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the third instruction, we swapped the contents of both `rax` and `rbx`
    with the `xchg` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we pushed `0x9876` to the `rcx` register and `mem1` holds `0x1234`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And now, swap both `rcx` and `mem1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Load effective address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **load effective address** (**lea**) instruction loads the address of the
    source into the destination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we moved the address of `mem1` to `rax`, then we moved the address inside
    `rax` to `rbx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Both are now pointing at `mem1`, which contains `0x1234`.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to talk about arithmetic operations (addition and subtraction).
    Let''s begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: First, we move `0x1` to the `rax` register, then we add `0x2`, and the result
    will be stored in the `rax` register.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we move `0x3` to the `rbx` register and add the contents of `mem1`, which
    contains `0x2` with the contents of `rbx`, and the result will be stored in `rbx`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we move `0x9` to the `rcx` register, then we subtract `0x1`, and the result
    will be stored in `rcx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we move `0x5` to the `rdx` register, subtract the contents of `mem2`
    from `rdx`, and the result will be stored in the `mem2` memory portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the contents of `mem2` after subtraction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s talk about addition with carry and subtraction with borrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we move `0x5` to the `rax` register, then we set the carry flag, which
    will be carrying `1`. After this, we add the contents of the `rax` register to
    `0x1`, and to the carry flag, which is `1`. This will give us `0x7` *(5+1+1)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we move `0x5` to the `rbx` register and set the carry flag, then we subtract
    `0x1` from the `rbx` register and also another `1` in the carry flag; that will
    give us `0x3` *(5-1-1)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the final part here is the increment and decrement operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: First, we move `0x5` to the `rax` register, increment the value of `rax` with
    `1`, then we increment again, which gives us `0x7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we move `0x6` to the `rbx` register, decrement the value of `rbx` with
    `1`, then we decrement again, which gives us `0x4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to talk about loops in assembly. Like in any other high-level
    language (Python, Java, and so on), we can use loops for iteration using the RCX
    register as a counter, then the `loop` keyword. Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, we wanted to increment the contents of RAX five times,
    so we moved `0x5` to the `rcx` register, then moved `0x1` to the `rbx` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we added the `increment` tag as an indication of the start of the block
    we wanted to repeat, then we added the increment instruction to the contents of
    the `rbx` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we called `loop increment`, which will decrement the contents of the
    RCX register and then go to start again from the `increment` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it will go until the RCX register hits zero, then the flow will go out
    of that loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, what if the program is rewritten with a value on RCX? Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing this code, the program will be stuck in an infinite loop, and
    if we look closer, we will see that the code overwrites the value in the RCX register
    after executing syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, we have to find a way to save the RCX register, such as saving it in the
    stack. First, we push the current value in the stack before executing syscall,
    and, after executing syscall, we overwrite whatever is in RCX with our value again
    and then decrement the value and push it again in the stack to save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, we save our value in the RCX register and then pop it in RCX again
    to use it. Look at the `pop rcx` instruction in the preceding code. RCX got back
    to `0x5` again, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Controlling the flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we are going to talk about controlling the flow of execution. The normal
    flow of execution is to execute step 1, then 2, and so on until the code exits
    normally. What if we decide we want something to happen in step 2, then the code
    skips 3, and goes to execute 4 directly, or we just want to skip step 3 without
    waiting for something to happen? There are two types of jumping:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the flow unconditionally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the flow based on changes in flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s start with the unconditional jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code contains four `exit` syscalls but with different exit statuses
    (`12`, `0`, `10`, `1`), and we started with `jmp exit_ten`, which means jump to
    the `exit_ten` location, and it will jump to this section of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute it and exit normally with exit status `10`. Note that the next section will
    never be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding commands can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the code exited with exit status `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the earlier code, it starts by printing `hello_one`. Then, it will hit `jmp
    print_three`, and the flow of execution will be changed to the `print_three` location
    and start printing `hello_three`. The following section will never be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s confirm that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding commands can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move on to jumping with the condition, and, to be honest, we can't
    cover all conditions here because the list is very long, but we will see some
    examples so that you can understand the concept.
  prefs: []
  type: TYPE_NORMAL
- en: The jump if below (`jb`) instruction means it will execute the jump if a **carry
    flag** (**CF**) is set (CF is equal to `1`).
  prefs: []
  type: TYPE_NORMAL
- en: As we said earlier, we can set a CF manually using the `stc` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the previous example, but using the `jb` instruction, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we executed `stc` to set a carry flag (that is, CF is equal
    to `1`), then we test that using `jb` instruction that means jump to `print_three`
    if CF is equal to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the add operation will set the carry flag, then we
    make the test using the `jb` instruction; if CF is equal to `1`, then jump to
    `exit_ten`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at a different method, that is, the jump if below or equal
    (`jbe`) instruction, which means CF is equal to `1` or **zero flag (ZF**) is equal
    to `1`. The previous example will work too, but let''s try something else to set
    ZF is equal to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the subtraction operation will set ZF and then we will
    use the `jbe` instruction to test whether CF is equal to `1` or ZF is equal to
    `1`; if true, then it will jump to execute `exit_ten`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type is jump if not sign (`jns`), which means SF is equal to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, the subtraction operation will set the **sign flag**
    (**SF**) equal to `1`. After that, we will test whether SF is equal to `0`, which
    will fail, and it won''t jump to execute `exit_ten` and will continue with the
    normal exit with exit status `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Procedures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Procedures in assembly can act as functions in high-level language, which means
    that you can write a block of code, then you can call it to execute.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can build a procedure that can take two numbers and add them.
    Also, we can use it many times during execution using the `call` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Building procedures is easy. First, define your procedure before `_start`, then
    add your instructions and end your procedure with the `ret` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to build a procedure that can take two numbers and add them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, we added an `addition` section, before the `_start` section. Then, in
    the `addition` section, we used the `add` instruction to add what's inside the `R8`
    and `R9` registers and put the result in the `R8` register, then we ended the
    `addition` procedure with `ret`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we moved `1` to the `R8` register and `3` to the `R9` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we called the `addition` procedure, which will push the next instruction
    address into the stack, which is `mov r8,0x4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that `RSP` is now pointing to the next operation, and we are inside the
    `addition` procedure, and then the code will add both numbers and store the result
    in the `R8` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After this, it will hit the `ret` instruction, which will set the flow of executing
    back to `mov r8,0x4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will move `4` to the `R8` register, then move `2` to the `R8` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, call the `addition` procedure, and it will push the next instruction
    into the stack, which is `mov rax, 60`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, add both numbers and store the result in the `R8` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we hit the `ret` instruction again, which will pop the next instruction
    from the stack and put it in the `RIP` register, which is equivalent to `pop rip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Then, the code will continue with executing the `exit` syscall.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are going to talk about logical operations such as bitwise operations
    and bit-shifting operations.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four types of bitwise operations in logical operations: AND, OR,
    XOR, and NOT.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the AND bitwise operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we moved `0x10111011` to the `rax` register, then we moved `0x11010110`
    to the `rbx` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we performed the **AND** bitwise operation on both sides and stored the
    result in RAX:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see the result inside the `RAX` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s move to the OR bitwise operation and modify the previous code to
    perform the operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We moved both values to the `rax` and `rbx` registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we executed the OR operation on those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s confirm the result in the `RAX` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now look at the XOR bitwise operation with the same values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the same values to the `rax` and `rbx` registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, execute the XOR operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see what is inside the `RAX` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can use the XOR instruction on a register with itself to clear the content
    of that register. For instance, `xor rax` and `rax` will fill the RAX register
    with zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the final one, which is the NOT bitwise operation, which will
    change ones to zeros and zeros to ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What happened is that the NOT instruction changed zeros to ones (`ff`) and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: Bit-shifting operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bit-shifting operations is an easy topic if you follow what each diagram says.
    Mainly, there are two types of bit-shifting operations: arithmetic shift operation
    and logic operation. However, we will also see the rotate operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the arithmetic shift operation.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic shift operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make this as simple as possible. There are two types of arithmetic shift:
    **shift arithmetic left** (**SAL**) and **shift arithmetic right** (**SAR**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In SAL, we push **0** at the **least significant bit** side, and the extra
    bit from the **most significant bit** side may affect **CF** if it''s a **1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'So, the result of this shift will not affect on **CF**, and it will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We moved `0x0fffffffffffffff` to the `rax` register, and this is how it looks
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we want to perform SAL with 4 bits one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Because the most significant bit was zero, so CF will not be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s try another round: we push another zero, and the most significant
    bit is one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00117.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'A carry flag will be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at the SAR instruction. In SAR, a value will be pushed based
    on the **most significant bit** if it is **0**, then **0** will be pushed, and
    if it is **1**, then **1** will be pushed to keep the sign from changing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00119.gif)'
  prefs: []
  type: TYPE_IMG
- en: The most significant bit is used as an indication for the sign, **0** for the
    positive number and **1** for the negative number.
  prefs: []
  type: TYPE_NORMAL
- en: So, in SAR, it will shift with whatever is in the most significant bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the input will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00120.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'So, SAR four times will push **0** four times as the most significant bit is
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, CF is set because the least significant bit is 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Logical shift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The logical shift also contains two types of shifting:logical **shift left**
    (**SHL**) and logical**shift right** (**SHR**). SHL is exactly like SAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it will push zero from the least significant bit side four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This will not have any effect on the carry flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At the second round, it will push zero again four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The most significant bit is 1, so this will set the carry flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now move to SHR. It simply pushes a 0 from the **most significant bit**
    side without keeping the sign from changing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So, first, we move 64 bits of ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00128.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, we will perform SHR 32 times, which will push 32 zeros to the most
    significant bit side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, as the least significant bits are ones, this will set the carry flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rotate operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rotate operation is simple: we will rotate the contents of a register to
    the right or to the left. Here, we are only going to discuss **rotate right**
    (**ROR**) and **rotate left** (**ROL**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with ROR:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'In ROR, we just rotate the bits from right to left without adding any bits;
    let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We move `0xffffffff00000000` to the `rax` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will start moving bits from right to left 32 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'There is no shifting with ones, so the carry flag will not be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move the ROL, which is the opposite of ROR, which rotates bits from
    left to right without adding any bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the previous example but ROL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we also move `0xffffffff00000000` to the `rax` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00136.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will start rotating bits from left to right 32 times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We are rotating ones, so this will set the carry flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the Intel x64 assembly language in Linux and how
    to deal with stacks, data manipulation, arithmetic and logical operations, how
    to control the flow of execution, and also how we can invoke system calls in an
    assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to make our own customized shellcodes, but before that, you
    need to learn some basics in debugging and reverse engineering, which will be
    our next chapter.
  prefs: []
  type: TYPE_NORMAL
