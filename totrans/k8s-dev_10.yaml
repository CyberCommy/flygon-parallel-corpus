- en: Troubleshooting Common Problems and Next Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have explored how to use Kubernetes in your development
    process. In this chapter, we wrap up the examples by looking at some of the common
    errors you might encounter. We look at how to understand them, and techniques
    for diagnosing the issues as well as how to resolve them. This chapter also reviews
    some of the emerging projects that are forming to assist developers with using
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics for this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Common errors and how to resolve them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emerging projects for developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the Kubernetes project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common errors and how to resolve them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we have provided examples that illustrate how to work with
    Kubernetes. In developing these examples, we hit all the same issues you are likely
    to encounter, some of them confusing—and it isn't always clear how to determine
    what the problem is and how to resolve it so that the system works. This section
    will go through a number of the errors that you might see, discuss how to diagnose
    them, and provide you with some techniques to help you understand if you see these
    same issues yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Error validating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are writing your own manifests for Kubernetes and using them directly,
    it is very easy to make simple mistakes that result in the error message : `error
    validating ...`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are fortunately very easy to understand, if terribly inconvenient. To
    illustrate this example, I created a slightly broken deployment manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cce62d17-e114-4eb8-a2f1-211d9b5993fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When running `kubectl apply` with this manifest, you will receive an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I made a subtle typo, misnaming a required field, `name`, which
    is highlighted by the message `missing required field` in the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you include an extra field that the system does know about, you will also
    receive an error, but a slightly different one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the key to understanding the message is the `unknown field` section.
    These messages also reference a path through the data structure to exactly where
    the error is occurring. In the preceding example, this is `Deployment` (the object
    defined in the `kind` key) and within that `spec` -> `template` -> `spec` -> `container`.
    The error message also defines exactly what object the Kubernetes API was attempting
    to validate against: `io.k8s.api.core.v1.Container`. If you are confused about
    what it required, you can use this information to look up the documentation at
    the Kubernetes website. These objects are versioned (note the `v1` in the object
    name), and in this case you can find the full definition in the reference documentation
    for Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reference documentation is released per version of Kubernetes, and for
    version 1.9 that documentation resides at [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/).
    The documentation includes some example details as well as the definitions within
    a three-column view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9bca5d77-59a8-4f83-9bbb-7f81d1d20f96.png)'
  prefs: []
  type: TYPE_IMG
- en: Navigating the documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The documentation follows the same pattern that we''ve seen from the Kubernetes
    objects themselves: they''re composed of smaller primitives. When you are navigating
    the documentation, for example looking at Deployment as shown in the screenshot,
    you will often see a reference to the objects that are encapsulated, and to dig
    into the details you may need to reference some of these object areas. For example,
    the Deployment example encapsulates Pods, so to properly define all the attributes
    in the template, you may need to reference the Pod v1 core documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: ErrImagePull
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ErrImagePull is quite possibly the most common, and is fortunately straightforward
    to debug and diagnose. You''ll see `ErrImagePull` as the status message when this
    occurs, indicating that Kubernetes was not able to retrieve the image you specified
    in the manifest. It''s most commonly seen when simply requesting pod status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can immediately get more detailed information about why this error occurred
    using the `kubectl describe` command. It's not entirely an error condition, as
    Kubernetes is technically in a waiting state hoping that the image will become
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we get more detail with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides information like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the container is in a waiting state from this detail, and it''s
    typically the events associated with the pod that provide the most useful information.
    The information is dense, so generally having a wider terminal window available
    when you invoke this command makes it easier to parse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7e9ea71-d041-485a-ad53-8e589067fdba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the process steps that Kubernetes has taken:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes scheduled the pod
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node where the pod was scheduled attempted to retrieve the requested image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It reported a warning that the image wasn't found, set the status to `ErrImagePull`,
    and started retrying with a back-off
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing to do is verify that the image you have requested is indeed
    the one you intended to request. In this case, I made an intentional typo to request
    an image that doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Another common problem can be that the image does exist, but isn't allowed to
    be pulled for some reason. For example, when you first create a container and
    push it to `quay.io`, it keeps that container build private until you explicitly
    go to the website and make it available publicly.
  prefs: []
  type: TYPE_NORMAL
- en: This same error message can appear if you are pulling from a private repository,
    but the credentials used are invalid (or have become invalid in the process of
    updating them).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the best debugging techniques to verify access, at least to public images,
    is to attempt to retrieve the image yourself. If you have Docker installed locally,
    this is as simple as invoking a Docker `pull` command. In this case, we could
    verify the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The error response is fairly direct from the Docker command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: CrashLoopBackOff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may find your pod reporting a status of `CrashLoopBackOff`, another incredibly
    common error state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an error condition that happens only after a container is invoked,
    so it can be delayed in appearing. You will typically see it when invoking `kubectl
    get pods`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This explicitly means that one of the containers in the pod has exited unexpectedly,
    and perhaps with a non-zero error code. The first course of action in understanding
    what happened is to utilize the `kubectl describe` command to get more detail.
    In this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Scan through the resulting content, looking at the status for each of the containers
    within the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a3ad1897-0234-4954-af13-a7c3502b23ff.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, you can see the Jaeger collector container is in the `Running`
    state, and `Ready` is reporting `True`. The flask container, however, is in a
    state of `Terminated`, with the reason only `Error` and an exit code of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: The step that often provides at least some information about why the container
    exited is leveraging the `kubectl logs` command, to see what we reported in `STDOUT`
    and `STDERR`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you invoke `kubectl logs` and the pod name, you may also see this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simply asking you to be more specific in identifying the container.
    In this example, we are using a pod that has an init container as well as two
    containers: the main and a Jaeger collector side-car. Simply appending the container
    to the end of the command, or using the `-c` option with the container name, will
    do what you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What gets returned, and how useful it is, will depend on how you created the
    container and what container runtime your Kubernetes cluster is using.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, `kubectl logs` also has the `-p` flag, which is exceptionally
    useful in retrieving the logs from the previous run of the container.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, you aren't entirely sure what's been set in the container,
    we can use some of the Docker commands to retrieve and then inspect the container
    image directly and locally, which can often shed light on what the issue may be.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, pull the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inspect it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Scrolling down to the content, you can see what the container will attempt
    to run and how it''s set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d457046a-60c5-4a27-a5bc-71c8ae8a9139.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this particular example, I intentionally introduced a typo into the name
    of the Python file getting invoked, leaving off the `.py` extension. This may
    not be obvious when you''re looking at this output, but specifically look for
    `EntryPoint` and `Cmd`, and try and verify that those are expected values. In
    this case, the entrypoint is `python3`, and the command is what gets invoked with
    it: `/opt/exampleapp/exampleapp`.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting and inspecting the image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this may be unclear without actually inspecting the image, a common way
    to diagnose something like this is to run the image with an alternative command,
    such as `/bin/sh`, and use an interactive session to look around and do your validation
    and debugging. You can do this locally if you have Docker installed; when you
    do so, make sure you explicitly override the `entrypoint` and command to run a
    command interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can then manually invoke what the container would have run, `python3 /opt/exampleapp/exampleapp`,
    and do any additional debugging there.
  prefs: []
  type: TYPE_NORMAL
- en: You can do this same thing in a Kubernetes cluster, if you don't happen to have
    Docker installed locally. If the pod already exists, you can use `kubectl exec`
    as we have done earlier, but when the container has crashed this typically isn't
    available, as the container isn't already running to utilize.
  prefs: []
  type: TYPE_NORMAL
- en: 'In those cases, creating a completely new, short lived, and ephemeral deployment
    with `kubectl run` is a good way to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You will want to be careful to have `--command=true` in your options if you
    want to override the entrypoint for the container, which is otherwise set to `python3`.
    Without that option, the `kubectl run` command will presume you are trying to
    pass different arguments to be used with the default entrypoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also find that when you attempt to invoke a command like this, you
    get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create a bare deployment like this, the pod doesn''t get deleted after
    the container exits (or errors). Invoking `kubectl get pods` with the `-a` option
    should show you the pods that exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete it in order to make another attempt at running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Adding your own setup to the container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are working with a container that includes code and systems you didn't
    create, you may find yourself wanting to set up some environment variables or
    otherwise establish some configuration files before whatever process in the container
    gets run. This is extremely common when using other prebuilt open source software,
    especially software that doesn't already have a well-established container that
    you can utilize.
  prefs: []
  type: TYPE_NORMAL
- en: A common technique for handling this situation is to add a shell script into
    the container and then have the entrypoint and arguments set to run that script.
    If you do this, make sure you include the appropriate options for invoking the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common example is to invoke a script with `/bin/bash -c /some/script`. It
    can be easy to miss the `-c` argument, which can lead to a very confusing error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This happens when the script referenced isn't set to be executable, and you
    didn't include the `-c` option to have the shell attempt to read and interpret
    the file you specified.
  prefs: []
  type: TYPE_NORMAL
- en: No endpoints available for service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most subtle issues to hunt down is why isn''t my service acting
    as I expect? A common error to see in these cases is this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have created a deployment and a service together, and everything seems
    to be running, but when you access the service endpoint you see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, I received this message when using `kubectl proxy` to access
    the service endpoint `flask-service` through the proxy using the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In these cases, use the command `kubectl describe` to get details on how the
    service is set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/8865fb81-f6e1-416d-87ad-e0077ff520cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Take close note of the selector that is set for the service, and then compare
    it to the deployment you think it should be matching. In this case, the selector
    is `app=flaskapp`, and looks at the detail on our deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/75b01149-c0a7-46b0-b577-04558cb24163.png)'
  prefs: []
  type: TYPE_IMG
- en: The immediate thing you should verify is that the containers are running and
    operational, which they are in this case. The very next thing is to look at the
    labels on the deployment, and in this case you see them set to `app=flask`, not
    `app=flaskapp` which is why nothing is responding on that service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to see what''s happening to pods backing a service is to specifically
    request pods using a label selected with the `kubectl get` command. For example,
    we could have used this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And because we haven''t set any pods with the relevant labels, we would have
    received this response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Labels and selectors are how a lot of elements are loosely coupled together
    within Kubernetes. Being loosely coupled, Kubernetes does not validate that you
    have correctly set the right values to bind pods to services. Not making sure
    the labels and selectors are correct is an easy mistake to make, and won't show
    up as an error other than nothing responding as you expected.
  prefs: []
  type: TYPE_NORMAL
- en: Stuck in PodInitializing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may see a scenario where your pods appear to be hanging while initializing,
    especially when you are first setting up the configuration where it involves volume
    mounts and ConfigMaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The status from `kubectl get pods` will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And the status doesn''t change. Trying to get logs about what is happening,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Results in this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The best thing to do here is to use `kubectl describe` to get the detail of
    what is set up on the pod and the recent events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you will see output showing the containers are all in a state of `Waiting`,
    with a reason of `PodInitializing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/204cb077-c0b0-41bc-9d44-07c64955be3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It may take a few minutes for the events that really show what happen to appear,
    but after a few minutes they should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/81c89241-9afb-4c08-a6a0-658e509d5e62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You see the warning `FailedMount`, and the relevant information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes some time to appear because Kubernetes provides for some longer
    timeouts when attempting to mount volumes, as well as retries. In this case, the
    error was a typo in the pod specification referencing a ConfigMap that doesn''t
    exist: `flaskConfig`.'
  prefs: []
  type: TYPE_NORMAL
- en: Missing resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many respects, this issue we just described is very similar to the labels
    and selectors bug, but exhibits itself quite differently. The underlying system
    does its best to look for volumes, ConfigMaps, secrets, and so on, and to let
    you create them in any order. If you make a typo, or if a ConfigMap, secret, or
    volume isn't referenced correctly or is just missing, then the pod will ultimately
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: These resources are all referenced dynamically. In doing that referencing, Kubernetes
    provides retries and timeouts, but cannot explicitly validate the failures before
    actually looking for the related resources and ultimately failing. This can make
    debugging these issues more time consuming. When you first look for why issues
    are failing, not all the information may be visible (a failed volume mount, a
    missing ConfigMap or secret, and so forth). The best option is to keep an eye
    on the events from the `kubectl describe` command, and look explicitly for warnings
    in the events, where these issues will ultimately appear.
  prefs: []
  type: TYPE_NORMAL
- en: Some development teams are resolving this C*lass A* problem by generating the
    manifests, using a program that they have verified themselves to create the appropriate
    links and making sure they are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Emerging projects for developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looking at alternatives to help the development process that uses Kubernetes
    starts to expose a large number of projects in development. While writing this
    book, Kubernetes advanced from version 1.7 to the beta release of Kubernetes v1.10\.
    At the same time, a large number of projects have started to establish themselves
    around Kubernetes, working to help smooth some of the rough edges around using
    Kubernetes actively in a development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Linters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we were talking about missing components that can''t
    be pre-validated by Kubernetes, but which we can look for ourselves. Three projects
    that are related to validation are kubeval, kube-lint, and kubetest, described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: kubeval : [https://github.com/garethr/kubeval](https://github.com/garethr/kubeval)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kubeval was created by Gareth Rushgrove to validate manifests and configuration
    files before attempting to apply them. This tool can be extremely handy in double-checking
    your work when you're creating manifests from your own code or using another project.
    It can't check everything, but it makes an excellent first pass check.
  prefs: []
  type: TYPE_NORMAL
- en: kube-lint : [https://github.com/viglesiasce/kube-lint](https://github.com/viglesiasce/kube-lint)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created by Vic Iglesias, kube-lint is more of an early experiment or functional
    prototype than a growing project. It is intended to validate a set of Kubernetes
    manifests against a group of common rules. Many of these best practices and common
    patterns are forming from the Helm project, in which Vic participates extensively,
    and there is ongoing conversation within the Kubernetes project about possible
    ways to help do more validation along these lines with a `lint` command.
  prefs: []
  type: TYPE_NORMAL
- en: kubetest : [https://github.com/garethr/kubetest](https://github.com/garethr/kubetest)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also by Gareth Rushgrove, kubetest was built to run a pass of testing across
    Kubernetes configuration files. Rather than explicitly encapsulating best practices
    and rules, it is written more in the form of unit testing, allowing assertions
    against sets of files and letting you specify your own constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have mentioned about and used Helm in earlier chapters, using it to install
    software within Kubernetes so that we can take advantage of it. Available at [https://helm.sh](https://helm.sh), Helm
    has been stable at version 2 for quite a while, and is actively used by a number
    of development teams. The charts that represent the collected best practices are
    available at [https://github.com/kubernetes/charts](https://github.com/kubernetes/charts),
    and are updated as the software they encapsulate, and Kubernetes, advances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6df6df88-30d9-440f-9e10-4fd26f94a079.png)'
  prefs: []
  type: TYPE_IMG
- en: Helm version 3 is the next large step forward with Helm, breaking some of the
    backwards compatibility guarantees they have been keeping while in version 2\.
    With the transition, the project team has been very clear that there will be a
    clear migration path and the current charts and examples will both be useful as
    they are, as well as updated as the project evolves. The details of the vision
    for Helm v3 are still forming and this project will undoubtedly be a key one in
    the larger Kubernetes ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: In version 2, it sets itself as a package manager for Kubernetes, primarily
    focusing on being a consistent way (and examples) of how to package sets of pods,
    deployments, services, ConfigMaps, and so on together, and deploy them as a whole
    within Kubernetes. Many teams created their own charts and have integrated Helm
    into their continuous integration pipeline, using Helm to render manifests as
    the underlying software was updated and to deploy as a part of that process.
  prefs: []
  type: TYPE_NORMAL
- en: One of the shortcomings of Helm may be that it is fairly complicated to create
    templates for your own software. The templating system that Helm uses is called
    sprig, and may be unfamiliar to a number of development teams. The next major
    revision of Helm, which is being defined as this book is being published, hopes
    to tackle a broad number of challenges, including making it easier for developers
    to write and publish charts. It is really worth keeping an eye on this project.
  prefs: []
  type: TYPE_NORMAL
- en: ksonnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ksonnet ([https://ksonnet.io](https://ksonnet.io)) was also mentioned earlier
    as another means of templating and rendering manifests for Kubernetes. ksonnet
    approaches the task differently to Helm, focusing on a means of templating the
    manifests, and making those templates very easy to compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b911f8b1-5192-4365-a9ec-c167d373223f.png)'
  prefs: []
  type: TYPE_IMG
- en: ksonnet uses the credentials of a user, and doesn't attempt to manage the state
    of releases that it renders, focusing instead on the templating. It is built upon
    a library called Jsonnet, which adds some programmatic aspects to JSON templating.
  prefs: []
  type: TYPE_NORMAL
- en: ksonnet is a fairly new project, and is starting to see some traction with other
    projects adopting it. They have stated that they are actively working with the
    Helm community as well, and hopes to enable ksonnet as an alternative way to create
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: Brigade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Brigade, available at [https://brigade.sh](https://brigade.sh), takes a slightly
    different tack to solving the deploy to Kubernetes problem. Rather than focus
    on the templating and what sort of DSL that might be used to programmatically
    generate Kubernetes manifests, it leans more towards embracing scripting and programming
    with Kubernetes and its events as first-class citizens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51a9a47c-c1ad-4035-a453-4efd08c9043d.png)'
  prefs: []
  type: TYPE_IMG
- en: The Microsoft team from Azure built Brigade to extend on JavaScript, exposing
    Kubernetes objects and events as elements to be composed into workflows and pipelines.
    If your development team is familiar with JavaScript, then Brigade may be an especially
    appealing means of coordinating and interacting with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: skaffold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Skaffold is available at [https://github.com/GoogleCloudPlatform/skaffold](https://github.com/GoogleCloudPlatform/skaffold) and
    is developed by a team from Google:![](assets/d3b7171d-4714-4ee4-af9d-3135251817d5.png)
  prefs: []
  type: TYPE_NORMAL
- en: It is the most recent of these developer-focused projects, and focuses specifically
    on being a command-line tool to enable the process of going from code checked
    in to source control, through building containers to Kubernetes manifests updated
    and deployed. It is also set up to be a component in a larger toolchain, and has
    hooked to work with other projects, most notably Helm, for the deployment portion
    of what it does.
  prefs: []
  type: TYPE_NORMAL
- en: img
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While looking at tools and projects as components, the img project, which is
    hosted under [genuinetools.org](https://genuinetools.org) and is available on
    GitHub at [https://github.com/genuinetools/img](https://github.com/genuinetools/img),
    is really worth noting. The examples in this book have all used Docker to build
    container images, and img builds on the underlying toolkit that the team at Docker
    has been evolving from their product to support creating containers. Most importantly,
    the img project allows for the creation of Docker images without a Daemon or running
    with significant privileges. This makes creating containers far more amenable
    to being built within a Kubernetes cluster, or more generally without having to
    give the process extensive permissions to the system hosting it.
  prefs: []
  type: TYPE_NORMAL
- en: The genuinetools project hosts a number of other useful components, most of
    them focused on alternative container runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: Draft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another tool from the team at Microsoft, Draft, is available at [https://draft.sh](https://draft.sh),
    and is a tool focused on trying to optimize the time going from a change in source
    control to being deployed within Kubernetes and to seeing those changes in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38464c7f-1ba4-4517-a1e3-b2b4c55e50b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Draft focuses on simple commands and a local configuration file to create a
    local Helm chart for your application and to streamline getting it running on
    a Kubernetes cluster, encapsulating the repetitive process of building the container,
    pushing it to a container registry, and then deploying updated manifests to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Like a few of these other tools, Draft builds on and uses Helm.
  prefs: []
  type: TYPE_NORMAL
- en: ksync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ksync, available at [https://vapor-ware.github.io/ksync/](https://vapor-ware.github.io/ksync/),
    takes a very different tactic for a development tool. Rather than optimizing the
    time to build and deploy into a Kubernetes cluster, it focuses on expanding the
    proxy capabilities to reach into a cluster and manipulate the code within a specific
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/545106ad-a2c5-4695-a294-01725dc341f7.png)'
  prefs: []
  type: TYPE_IMG
- en: A common pattern for developing with Docker has been to mount a local directory
    that contains interpreted code (such as our Python and JavaScript examples in
    this book) and to have the container run that code, so that you can edit it on
    the fly and quickly restart and retry. ksync mimics this capability by running
    both on your local development machine and within your cluster, watching for changes
    locally and reflecting them into Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: ksync focuses on the development process for software within a single pod. So
    while it won't help with deploying all the supporting applications, it may make
    the development process with a single component in Kubernetes much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Telepresence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Telepresence, available at [https://www.telepresence.io](https://www.telepresence.io),
    is another project that focuses on providing the developer with tighter access
    from their local machine into a Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c2012ba7-97ea-46c7-a9b8-7c87d2ff5875.png)'
  prefs: []
  type: TYPE_IMG
- en: Created by Datawire, which makes additional projects for developers to work
    with Kubernetes, Telepresence creates a two-way proxy that forwards connections
    and responses to a process that would be within a pod in Kubernetes to a process
    running on your local development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Where ksync copies your code and runs it within Kubernetes, Telepresence lets
    you run the code on your own machine, transparently connecting it as though it
    were a pod running within Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Kubernetes project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In discussing all these projects, the one where you can get the most information
    about how to work with Kubernetes is Kubernetes itself. The project hosts a website
    that includes the formal documentation, a blog, a community calendar, tutorials,
    and more at [https://kubernetes.io/](https://kubernetes.io/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/72a793f9-6a6d-4cd6-a448-bd5a891d01a4.png)'
  prefs: []
  type: TYPE_IMG
- en: This site makes a great jumping off point to get more information, but certainly
    isn't the only resource available.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes project is really quite large, so large that it is nearly impossible
    for any single person to track all of the efforts, evolution, projects, and interests
    that are going on within the project. To attempt to provide guidance, the Kubernetes
    project has set itself up with a number of groups to focus on these interests
    in the form of Special Interest Groups, or SIGs. These groups are the semi-formal
    subprojects of Kubernetes, and each focuses on some specific subset of Kubernetes.
    Not surprisingly, many of these SIGs overlap in specifics, and it is not uncommon
    to find a contributor within Kubernetes being active in a number of SIGs at once.
  prefs: []
  type: TYPE_NORMAL
- en: The complete list of SIGs is available online and is maintained at [https://github.com/kubernetes/community/blob/master/sig-list.md](https://github.com/kubernetes/community/blob/master/sig-list.md).
    Each SIG has specific people called out as leaders, hosts regular meetings, and
    many of them maintain online notes and even recordings of their online meetings.
    These SIGs all loosely coordinate to advance Kubernetes, and are in turn coordinated
    by a Kubernetes steering committee and a number of community managers.
  prefs: []
  type: TYPE_NORMAL
- en: There are also less formal working groups that pop up to focus on specific or
    short-lived interests that don't have any specific leadership or attendance. All
    together, the SIGs and working groups can create a tremendous amount of information
    and depth that is available to look through, and a very open community of people
    to interact with regarding the project.
  prefs: []
  type: TYPE_NORMAL
- en: The community also manages a calendar of SIG meetings and events, available
    at [https://kubernetes.io/community/](https://kubernetes.io/community/), and publishes
    regularly on the Kubernetes blog at [http://blog.kubernetes.io](http://blog.kubernetes.io).
  prefs: []
  type: TYPE_NORMAL
- en: Slack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common and interactive means of Kubernetes contributors working together is
    by using online chat channels at Slack. Kubernetes hosts a large number of interactive
    channels dedicated to SIGs, working groups, and projects within Kubernetes. Anyone
    may join, and you can sign up for access at [http://slack.k8s.io](http://slack.k8s.io).
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to Slack or Kubernetes, then the channels `#kubernetes-users`
    and `#kubernetes-novices` may be of particular interest. The overall community
    team also hosts what they call office hours, which is a live stream hosted on
    YouTube, as well as the Slack channel, `#office-hours`.
  prefs: []
  type: TYPE_NORMAL
- en: YouTube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you prefer video streams, the Kubernetes community offers a YouTube channel,
    available at [https://www.youtube.com/c/KubernetesCommunity/](https://www.youtube.com/c/KubernetesCommunity/).
    These include recorded videos from community meetings, as well as sessions from
    regular Kubernetes conferences. A large number of SIGs also record their regular
    meetings and post those on YouTube, although they are not consistently coordinated
    through this channel. If you want to find related content, it is best to track
    that down through each individual SIG, although you may be able to find what you''re
    looking for under the channel''s playlists at [https://www.youtube.com/channel/UCZ2bu0qutTOM0tHYa_jkIwg/playlists](https://www.youtube.com/channel/UCZ2bu0qutTOM0tHYa_jkIwg/playlists):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88ebb60c-5275-4271-8e04-4ada80699991.png)'
  prefs: []
  type: TYPE_IMG
- en: Stack Overflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Members of the Kubernetes community also watch and offer answers to questions
    on Stack Overflow. The office hours mentioned earlier encourage folks to post
    their questions on Stack Overflow and bring those to the office hours for interactive
    help. You can find Kubernetes-related questions at [https://stackoverflow.com/questions/tagged/kubernetes](https://stackoverflow.com/questions/tagged/kubernetes).
    If you search for Kubernetes-related topics on Google, you may also find the results
    within questions already asked, and answered, on Stack Overflow.
  prefs: []
  type: TYPE_NORMAL
- en: Mailing lists and forums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes has a general mailing list/forum, as well as mailing lists for every
    SIG and frequently for each working group as well. The common forums include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://groups.google.com/forum/#!forum/kubernetes-users](https://groups.google.com/forum/#!forum/kubernetes-users)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://groups.google.com/forum/#!forum/kubernetes-dev](https://groups.google.com/forum/#!forum/kubernetes-dev)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of SIGs at [https://github.com/kubernetes/community/blob/master/sig-list.md](https://github.com/kubernetes/community/blob/master/sig-list.md)
    also includes a reference to the individual mailing lists for each SIG.
  prefs: []
  type: TYPE_NORMAL
- en: There is no one path for information on Kubernetes, and the community works
    very hard to accommodate multiple ways to get information, ask questions, and
    encourage participation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched on some of the problems that you may run into when
    developing and deploying to Kubernetes, and then touched on a number of projects
    that may be of interest to help you or your team speed up their development process
    while also taking advantage of Kubernetes. The final portion of this chapter discussed
    the Kubernetes project itself, how you can interact with it, and where to find
    more information to leverage this amazing set of tools.
  prefs: []
  type: TYPE_NORMAL
