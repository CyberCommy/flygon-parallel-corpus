- en: Chapter 6. Django Debugging Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best test suite in the world won't save you from having to debug problems.
    Tests simply report whether code is working correctly. When there is a problem
    in the code, found either via a failing test or some other means, debugging is
    necessary to figure out what exactly has gone wrong. A good test suite, run regularly,
    can certainly help in debugging. The specifics of the error message from the failure,
    the aggregate information provided by what tests pass versus what tests fail,
    in addition to the knowledge of what code change introduced the problem, can all
    provide important clues for debugging. Sometimes those clues are enough to figure
    out what has gone wrong and how to fix it, but often it is necessary to perform
    additional debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces Django''s debugging support. It provides an overview
    of topics that will be covered in greater depth in subsequent chapters. Specifically,
    this chapter will:'
  prefs: []
  type: TYPE_NORMAL
- en: List the Django settings that control the collection and presentation of debugging
    information, and briefly describe the effects of enabling debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustrate the results of running with debug enabled in the case of serious
    code failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the database query history that is collected with debug enabled, and
    show how to access it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss features of the development server that help in debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe how errors are handled during production, when debug is off, and how
    to ensure that information about such errors is reported appropriately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django debug settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django has a number of settings that control the collection and presentation
    of debug information. The primary one is named `DEBUG`; it broadly controls whether
    the server operates in development (if `DEBUG` is `True`) or production mode.
  prefs: []
  type: TYPE_NORMAL
- en: In development mode, the end-user is expected to be a site developer. Thus,
    if an error arises during processing of a request, it is useful to include specific
    technical information about the error in the response sent to the web browser.
    This is not useful in production mode, when the user is expected to be simply
    a general site user.
  prefs: []
  type: TYPE_NORMAL
- en: This section describes three Django settings that are useful for debugging during
    development. Additional settings are used during production to control what errors
    should be reported, and where error reports should be sent. These additional settings
    will be discussed in the section on handling problems in production.
  prefs: []
  type: TYPE_NORMAL
- en: The DEBUG and TEMPLATE_DEBUG settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DEBUG` is the main debug setting. One of the most obvious effects of setting
    this to `True` is that Django will generate fancy error page responses in the
    case of serious code problems, such as exceptions raised during processing of
    a request. If `TEMPLATE_DEBUG` is also `True`, and the exception raised is related
    to a template error, then the fancy error page will also include information about
    where in the template the error occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for both of these settings is `False`, but the `settings.py`
    file created by `manage.py startproject` turns both of them on by including these
    lines at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that setting `TEMPLATE_DEBUG` to `True` when `DEBUG` is `False` isn't useful.
    The additional information collected with `TEMPLATE_DEBUG` turned on will never
    be displayed if the fancy error pages, controlled by the `DEBUG` setting, are
    not displayed. Similarly, setting `TEMPLATE_DEBUG` to `False` when `DEBUG` is
    `True` isn't very useful. In this case, for template errors, the fancy debug page
    will be lacking helpful information. Thus, it makes sense to keep these settings
    tied to each other, as previously shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Details on the fancy error pages and when they are generated will be covered
    in the next section. Besides generating these special pages, turning `DEBUG` on
    has several other effects. Specifically, when `DEBUG` is on:'
  prefs: []
  type: TYPE_NORMAL
- en: A record is kept of all queries sent to the database. Details of what is recorded
    and how to access it will be covered in a subsequent section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the MySQL database backend, warnings issued by the database will be turned
    into Python `Exceptions`. These MySQL warnings may indicate a serious problem,
    but a warning (which only results in a message printed to `stderr`) may pass unnoticed.
    Since most development is done with `DEBUG` turned on, raising exceptions for
    MySQL warnings then ensures that the developer is aware of the possible issue.
    We ran into this behavior back in [Chapter 3](ch03.html "Chapter 3. Testing 1,
    2, 3: Basic Unit Testing"), *Testing 1, 2, 3: Basic Unit Testing*, when we saw
    that the `testClosesReset` unit test produced different results depending on the
    `DEBUG` setting and the MySQL server configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The admin application performs extensive validation of the configuration of
    all registered models and raises an `ImproperlyConfigured` exception on the first
    attempt to access any admin page if an error is found in the configuration. This
    extensive validation is fairly expensive and not something you'd generally want
    done during production server start-up, when the admin configuration likely has
    not changed since the last start-up. When running with `DEBUG` on, though, it
    is possible that the admin configuration has changed, and thus it is useful and
    worth the cost to do the explicit validation and provide a specific error message
    about what is wrong if a problem is detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there are several places in Django code where an error will occur while
    `DEBUG` is on, and the generated response will contain specific information about
    the cause of the error, whereas when `DEBUG` is off the generated response will
    be a generic error page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TEMPLATE_STRING_IF_INVALID setting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A third setting that can be useful for debugging during development is `TEMPLATE_STRING_IF_INVALID`.
    The default value for this setting is the empty string. This setting is used to
    control what gets inserted into a template in place of a reference to an invalid
    (for example, non-existent in the template context) variable. The default value
    of an empty string results in nothing visible taking the place of such invalid
    references, which can make them hard to notice. Setting `TEMPLATE_STRING_IF_INVALID`
    to some value can make tracking down such invalid references easier.
  prefs: []
  type: TYPE_NORMAL
- en: However, some code that ships with Django (the admin application, in particular),
    relies on the default behavior of invalid references being replaced with an empty
    string. Running code like this with a non-empty `TEMPLATE_STRING_IF_INVALID` setting
    can produce unexpected results, so this setting is only useful when you are specifically
    trying to track down something like a misspelled template variable in code that
    always ensures that variables, even empty ones, are set in the template context.
  prefs: []
  type: TYPE_NORMAL
- en: Debug error pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With `DEBUG` on, Django generates fancy debug error pages in two circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: When a `django.http.Http404` exception is raised
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any other exception is raised and not handled by the regular view processing
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the latter case, the debug page contains a tremendous amount of information
    about the error, the request that caused it, and the environment at the time it
    occurred. Deciphering this page and making best use of the information it presents
    will be covered in the next chapter. The debug pages for `Http404` exceptions
    are considerably simpler and will be covered here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see examples of the `Http404` debug pages, consider the `survey_detail`
    view from [Chapter 4](ch04.html "Chapter 4. Getting Fancier: Django Unit Test
    Extensions"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two cases where this view may raise an `Http404` exception: when
    the requested survey is not found in the database, and when it is found but has
    not yet opened. Thus, we can see the debug 404 page by attempting to access the
    survey detail for a survey that does not exist, say survey number 24\. The result
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug error pages](img/7566_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice there is a message in the middle of the page that describes the cause
    of the page not found response: **No Survey matches the given query**. This message
    was generated automatically by the `get_object_or_404` function. By contrast,
    the bare `raise Http404` in the case where the survey is found but not yet open
    does not look like it will have any descriptive message. To confirm this, add
    a survey that has an opens date in the future, and try to access its detail page.
    The result will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug error pages](img/7566_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That is not a very helpful debug page, since it lacks any information about
    what was being searched for and why it could not be displayed. To make this page
    more useful, include a message when raising the `Http404` exception. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then an attempt to access this page will be a little more helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug error pages](img/7566_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the error message supplied with the `Http404` exception is only displayed
    on the debug 404 page; it would not appear on a standard 404 page. So you can
    make such messages as descriptive as you like and not worry that they will leak
    private or sensitive information to general users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to note is that a debug 404 page is only generated when an `Http404`
    exception is raised. If you manually construct an `HttpResponse` with a 404 status
    code, it will be returned, not the debug 404 page. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If that code were used in place of the `raise Http404` variant, then the browser
    will simply display the passed message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug error pages](img/7566_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Without the prominent **Page not found** message and distinctive error page
    formatting, this page isn't even obviously an error report. Note also that some
    browsers by default will replace the server-provided content with a supposedly
    "friendly" error page that tends to be even less informative. Thus, it is both
    easier and more useful to use the `Http404` exception instead of manually building
    `HttpResponse` objects with status code 404.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final example of the debug 404 page that is very useful is the one that is
    generated when URL resolution fails. For example, if we add an extra space before
    the survey number in the URL, the debug 404 page generated will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug error pages](img/7566_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The message on this page includes all of the information necessary to figure
    out why URL resolution failed. It includes the current URL, the name of the base
    `URLConf` used for resolution, and all patterns that were tried, in order, for
    matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do any significant amount of Django application programming, it''s highly
    likely that at some time this page will appear and you will be convinced that
    one of the listed patterns should match the given URL. You would be wrong. Do
    not waste energy trying to figure out how Django could be so broken. Rather, trust
    the error message, and focus your energies on figuring out why the pattern you
    think should match doesn''t in fact match. Look carefully at each element of the
    pattern and compare it to the actual element in the current URL: there will be
    something that doesn''t match.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you might think the third listed pattern should match the current
    URL. The first element in the pattern is the capture of the primary key value,
    and the actual URL value does contain a number that could be a primary key. However,
    the capture is done using the pattern **\d+**. An attempt to match this against
    the actual URL characters—a space followed by **2**—fails because **\d** only
    matches numeric digits and the space character is not a numeric digit. There will
    always be something like this to explain why the URL resolution failed.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will include many more examples of common errors that result
    in debug pages, and will delve into all of the information available on these
    pages. For now, we will leave the subject of debug pages and learn about accessing
    the history of database queries that is maintained when `DEBUG` is on.
  prefs: []
  type: TYPE_NORMAL
- en: Database query history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `DEBUG` is `True`, Django maintains a history of all SQL commands sent
    to the database. This history is kept in a list, named `queries`, located in the
    `django.db.connection` module. The easiest way to see what is kept in this list
    is to examine it from a shell session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see that `queries` is initially empty at the beginning of the shell
    session. We then retrieve a count of the number of `Survey` objects in the database,
    which comes back as **2**. When we again display the contents of `queries`, we
    see that there is now one query in the `queries` list. Each element in the list
    is a dictionary containing two keys: `time` and `sql`. The value of `time` is
    how long, in seconds, the query took to execute. The value of `sql` is the actual
    SQL query that was sent to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note about the SQL contained in `connection.queries`: it does
    not include quoting of query parameters. For example, consider the SQL shown for
    a query on `Surveys` with titles that start with `Christmas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the displayed SQL, `Christmas%` would need to be quoted in order for the
    SQL to be valid. However, we see here it is not quoted when stored in `connection.queries`.
    The reason is because Django does not actually pass the query in this form to
    the database backend. Rather, Django passes parameterized queries. That is, the
    passed query string contains parameter placeholders, and parameter values are
    passed separately. It is up to the database backend, then, to perform parameter
    substitution and proper quoting.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the debug information placed in `connection.queries`, Django does parameter
    substitution, but it does not attempt to do the quoting, as that varies from backend
    to backend. So do not be concerned by the lack of parameter quoting in `connection.queries`:
    it does not imply that parameters are not quoted correctly when they are actually
    sent to the database. It does mean, though, that the SQL from `connection.queries`
    cannot be successfully cut and pasted directly into a database shell program.
    If you want to use the SQL form `connection.queries` in a database shell, you
    will need to supply the missing parameter quoting.'
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed and may be curious about the `LIMIT 21` included in the
    previous SQL. The `QuerySet` requested did not include a limit, so why did the
    SQL include a limit? This is a feature of the `QuerySet repr` method, which is
    what the Python shell calls to display the value returned by the `Survey.objects.filter`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: A `QuerySet` may have many elements, and displaying the entire set, if it is
    quite large, is not particularly useful in Python shell sessions, for example.
    Therefore, `QuerySet repr` displays a maximum of 20 items. If there are more,
    `repr` will add an ellipsis to the end to indicate that the display is incomplete.
    Thus, the SQL resulting from a call to `repr` on a `QuerySet` will limit the result
    to 21 items, which is enough to determine if an ellipsis is needed to indicate
    that the printed result is incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Any time you see `LIMIT 21` included in a database query, that is a signal the
    query was likely the result of a call to `repr`. Since `repr` is not frequently
    called from application code, such queries are likely resulting from other code
    (such as the Python shell, here, or a graphical debugger variable display window)
    that may be automatically displaying the value of a `QuerySet` variable. Keeping
    this in mind can help reduce confusion when trying to figure out why some queries
    are appearing in `connection.queries`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one final item to note about `connection.queries`: despite the name,
    it is not limited to just SQL queries. All SQL statements sent to the database,
    including updates and inserts, are stored in `connection.queries`. For example,
    if we create a new `Survey` from the shell session, we will see the resulting
    SQL INSERT stored in `connection.queries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have been accessing `connection.queries` from a shell session. Often,
    however, it may be useful to see what it contains after a request has been processed.
    That is, we might want to know what database traffic was generated during the
    creation of a page. Recreating the calling of a view function from within a Python
    shell and then manually examining `connection.queries` is not particularly convenient,
    however. Therefore, Django provides a context processor, `django.core.contextprocessors.debug`,
    that provides convenient access to the data stored in `connection.queries` from
    a template. In [Chapter 8](ch08.html "Chapter 8. When Problems Hide: Getting More
    Information"), *When Problems Hide: Getting More Information*, we will see how
    we can use this context processor to include information from `connection.queries`
    in our generated pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Debug support in the development server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development server, which we have been using since [Chapter 3](ch03.html
    "Chapter 3. Testing 1, 2, 3: Basic Unit Testing"), has several characteristics
    which aid in debugging. First, it provides a console that allows for easy reporting,
    during development, of what is going on in Django application code. The development
    server itself reports general information about its operation to the console.
    For example, typical output from the development server looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the development server starts out by explicitly validating models.
    If any errors are found they will be prominently reported during server start-up,
    and will prevent the server from entering its request processing loop. This helps
    to ensure that any erroneous model changes made during development are noticed
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: The server then reports the level of Django that is running, the settings file
    in use, and the host address and port it is listening on. The first of these,
    in particular, is very useful when you have multiple Django versions installed
    and are switching between them. For example, if you have the latest release installed
    in `site-packages` but also have an SVN checkout of current trunk that you use
    by explicitly setting `PYTHONPATH`, you can use the version reported by the development
    server to confirm (or not) that you are in fact using the version you intend to
    be using at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final start-up message notes that you can terminate the server by pressing
    *Ctrl-C*. The server then enters its request processing loop and will proceed
    to report information on each request that it handles. The information printed
    for each request is:'
  prefs: []
  type: TYPE_NORMAL
- en: The date and time the request was processed, in square brackets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request itself, which includes the HTTP method (for example, GET or POST),
    the path, and the HTTP version specified by the client, all enclosed in quotes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP status code returned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of bytes in the returned response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous example output, we can see that the server has responded to
    three `GET` requests, all specifying an HTTP version of `1.1`. First for the root
    URL `/`, which resulted in an HTTP `200` (OK) status code with a `480` byte response.
    The request for `/survey/1/` was similarly processed successfully and produced
    a `280` byte response, but `/survey/888/` resulted in a `404` HTTP status with
    a `1704` byte response. The `404` status was returned because no survey with primary
    key `888` existed in the database. Simply being able to see what requests, exactly,
    are being received by the development server, and what is being returned in response,
    often comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some requests handled by the development server that are not shown
    on the console. First, requests for admin media files (that is, CSS, JavaScript,
    and images) are not logged. If you look at the HTML source for an admin page,
    you will see it does include links to CSS files in its `<head>` section. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A web browser receiving this document will proceed to retrieve `/media/css/base.css`
    and `/media/css/dashboard.css` from the same server that produced the original
    page. The development server will receive and automatically serve these files,
    but it does not log that activity. Specifically, it will serve but not log requests
    for URLs that begin with the `ADMIN_MEDIA_PREFIX` setting. (This setting's default
    value is `/media/`).
  prefs: []
  type: TYPE_NORMAL
- en: The second request that will not get logged by the development server is any
    request for `/favicon.ico`. This is a file automatically requested by many web
    browsers in order to associate an icon with a bookmarked page or to display an
    icon in the address bar. There is no point in cluttering up the output of the
    development server with requests for this file, so it is never logged.
  prefs: []
  type: TYPE_NORMAL
- en: Often when debugging a problem, the very basic information logged automatically
    by the development server will not be sufficient to figure out what is going on.
    When this happens, you may add logging to your application code. Assuming you
    route the log output you add to `stdout` or `stderr`, it will appear on the console
    of the development server along with the normal development server output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some production deployment environments do not allow sending output
    to `stdout`. In such environments, a mistakenly leftover debugging print statement
    in the application code could cause a server failure in production. To avoid this,
    always route debug print statements to `stderr` instead of `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that the request logging done by the development server happens at
    the very end of the request processing. The logged information includes the size
    of the response, so the response has been completely generated before this line
    appears. Thus, any logging added in application view functions, for example, will
    appear before the single line logged by the development server. Don''t get confused
    and think that prints from a view function are referring to the work done to service
    the request logged above them. More specifics on adding logging to application
    code will be discussed in [Chapter 8](ch08.html "Chapter 8. When Problems Hide:
    Getting More Information").'
  prefs: []
  type: TYPE_NORMAL
- en: 'A second feature of the development server that is useful when developing and
    debugging code is that it automatically notices when source code changes on disk
    and re-starts itself, so that it is always running current code. You can tell
    when this happens because when it restarts, it will again print the start-up messages.
    For example, consider this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here some code change was made that resulted in the development server restarting
    itself between the handling of the **GET /survey/888/** and the **GET /admin/**
    request.
  prefs: []
  type: TYPE_NORMAL
- en: While this automatic restart behavior is convenient, it can sometimes run into
    trouble. This most frequently happens when code is edited and saved with an error.
    Sometimes, but not always, loading the erroneous file causes the development server
    to fail to notice subsequent changes in the file. Thus, the corrected version
    may not be automatically loaded even when the error is noticed and fixed. If it
    seems like the development server is not reloading when it should, it is a good
    idea to manually stop and restart it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This automatic reloading feature of the development server can be turned off
    by passing the `--noreload` option to `runserver`. You likely will not often want
    to specify this when running the development server on its own, but if you are
    running it under a debugger, you may need to specify this option in order for
    debugger breakpoints to be properly recognized. This is a final feature of the
    development server that makes it useful for debugging: it is easy to run under
    a debugger. Details on this will be covered in [Chapter 9](ch09.html "Chapter 9. When
    You Don''t Even Know What to Log: Using Debuggers"), *When You Don''t Even Know
    What to Log: Using Debuggers*.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling problems in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an ideal world, all code problems would be found during development, and
    nothing would ever go wrong when the code was in production. However, despite
    best efforts, this ideal is rarely achieved in reality. We must prepare for the
    case where something will go seriously wrong while the code is running in production
    mode, and arrange to do something sensible when it happens.
  prefs: []
  type: TYPE_NORMAL
- en: What's involved in doing something sensible? First some response must still
    be returned to the client that sent the request that resulted in the error. But
    the response should just be a general error indication, bare of the specific internal
    details found in the fancy debug error pages produced when `DEBUG` is active.
    At best, a Django debug error page might confuse a general web user, but at worst
    information gleaned from it might be used by some malicious user to attempt to
    break the site. Thus, the public response produced for a request that causes an
    error should be a generic error page.
  prefs: []
  type: TYPE_NORMAL
- en: The specific details of such errors, though, should still be made available
    to site administrators so that the problems can be analyzed and fixed. Django
    accomplishes this by e-mailing details of errors encountered when `DEBUG` is `False`
    to a list of e-mail addresses specified in `settings.py`. The information included
    in the e-mail is not as extensive as what would be found on a debug page, but
    it is often enough to get started on recreating and fixing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: This section discusses the steps needed to handle errors encountered during
    production. First, what needs to be done to return generic error pages is described,
    and then the settings necessary to specify where to send more detailed error information
    are discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating general error pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with the fancy error pages, there are two types of general error pages:
    one to report that a page does not exist on the site, and one to report that some
    internal server error occurred during processing of the request. Django provides
    default handlers for these error cases that automatically load and render templates
    named `404.html` and `500.html` respectively. A project that relies on the default
    handling of these errors must provide templates with these names to be loaded
    and rendered. No defaults for these files are created by `manage.py startproject`.'
  prefs: []
  type: TYPE_NORMAL
- en: When the `404.html` template it rendered, it is passed a `RequestContext` in
    which a variable named `request_path` has been set to the value of the URL path
    that caused the `Http404` exception to be raised. The `404.html` template, then,
    can use the `request_path` value and the other variables set by context processors
    to tailor the specific response generated.
  prefs: []
  type: TYPE_NORMAL
- en: The `500.html` template, on the other hand, is rendered with an empty context.
    When a internal server error occurs, something has gone seriously wrong with the
    server code. Attempting to process a `RequestContext` through context processors
    might well cause yet another exception to be raised. To attempt to ensure that
    the response will be generated without any further errors, then, the `500.html`
    template is rendered with an empty context. This means that the `500.html` template
    cannot rely on any context variables that are ordinarily set by context processors.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to override the default error handling by providing custom error
    handlers for either one or both of these error situations. The Django documentation
    provides full details on how to do this; it is not covered here as the default
    handlers are fine for the vast majority of situations.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting production error information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though it is good to avoid presenting detailed technical error information
    to general users, it is not good to lose such information entirely. Django supports
    notifying site administrators when errors are encountered in production. Settings
    related to these notifications are discussed in this section. [Chapter 11](ch11.html
    "Chapter 11. When it''s Time to Go Live: Moving to Production"), *When it''s Time
    to Go Live: Moving to Production*, provides more guidance on the task of moving
    to production and solving some common problems that are encountered along the
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal server error notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a server error occurs, Django sends an e-mail containing details of the
    request that generated the error and the traceback from the error to all of the
    e-mail addresses listed in the `ADMINS` setting. `ADMINS` is a list of tuples
    containing names and e-mail addresses. The value set by `manage.py startproject`
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The commented line shows the format you should use for adding values to this
    setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no setting to control whether server error notifications should be
    sent: Django will always attempt to send these notifications. However, if you
    really do not want e-mail notifications generated for internal server errors,
    you can leave the `ADMINS` setting empty. This is not a recommended practice,
    though, as you will not have any idea, unless your users complain to you, that
    your site is experiencing difficulty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Django uses Python''s SMTP support to send e-mail. In order for this to work,
    Django must be configured properly to communicate with an SMTP server. There are
    several settings that control sending mail which you may need to customize for
    your installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EMAIL_HOST` is the name of the host running the SMTP server. The default value
    for this setting is `localhost`, so if there is no SMTP server running on the
    same machine as the Django server, this will need to be set to a host running
    an SMTP server that can be used to send mail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_HOST_USER` and `EMAIL_HOST_PASSWORD` together may be used to authenticate
    to the SMTP server. Both are set to an empty string by default. If either is set
    to the empty string, then Django does not attempt to authenticate to the SMTP
    server. If you are using a server that requires authentication, you will need
    to set these to valid values for the SMTP server in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_USE_TLS` specifies whether to use a secure (Transport Layer Security)
    connection to the SMTP server. The default value is `False`. If you are using
    an SMTP server that requires a secure connection, you will need to set this to
    `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_PORT` specifies the port to connect to. The default value is the default
    SMTP port, 25\. If your SMTP server is listening on a different port (typical
    when `EMAIL_USE_TLS` is `True`), you must specify it here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERVER_EMAIL` is the e-mail address that will be used as the `From` address
    on the sent mail. The default value is `root@localhost`. Some e-mail providers
    refuse to accept mail that uses this default `From` address, so it is a good idea
    to set this to a value that is a valid `From` address for the e-mail server you
    are using.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EMAIL_SUBJECT_PREFIX` is a string that will be placed at the start of the
    `Subject` for the e-mail. The default value is `[Django]`. You might want to customize
    this to be something that is site-specific, so administrators that support multiple
    sites will be able to tell from a glance at the e-mail subject which site encountered
    the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have set all of the values you believe are correct for the SMTP server
    you are using, it is a good idea to verify that mail is successfully sent. To
    do this, set `ADMINS` to include your own e-mail address. Then set `DEBUG=False`
    and do something that will cause a server error. One easy way to accomplish this
    is to rename the `404.html` template to something else and then attempt to access
    the server specifying a URL that will cause an `Http404` exception to be raised.
  prefs: []
  type: TYPE_NORMAL
- en: For example, attempt to access the detail page for a survey that does not exist
    or has an opens date in the future. This attempt should result in an e-mail getting
    sent to you. The subject will start with your server's `EMAIL_SUBJECT_PREFIX`
    and will include the URL path of the request that generated the error. The text
    of the e-mail will contain the traceback from the error followed by the details
    of the request that caused it.
  prefs: []
  type: TYPE_NORMAL
- en: Page not found notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Page not found errors are considerably less serious than server errors. In fact,
    they may not indicate errors in the code at all, since they can result from users
    incorrectly typing addresses in the browser address bar. If, however, they are
    the result of users attempting to follow links, you might want to know about that.
    This second case is termed a broken link and can usually be distinguished from
    the first by the presence of an HTTP `Referer` [sic] header in the request. Django
    supports sending e-mail notifications when it detects a user attempting to access
    a nonexistent page via a broken link.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike internal server error notifications, sending broken link notifications
    is optional. The setting that controls whether Django sends e-mail notifications
    for broken links is `SEND_BROKEN_LINK_EMAILS`. The default value for this setting
    is `False`; you will need to set it to `True` if you want Django to generate these
    e-mails. In addition, the common middleware (`django.middleware.common.CommonMiddleware`)
    must be enabled in order for broken link e-mails to be sent. This middleware is
    enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: The e-mails generated by this setting are sent to the e-mail addresses found
    in the `MANAGERS` setting. Thus, you can send these notifications to a different
    set of people than the server error e-mails. If, however, you want to send these
    to the same set of people who receive the server error e-mails, simply set `MANAGERS
    = ADMINS` in `settings.py` after `ADMINS` has been set.
  prefs: []
  type: TYPE_NORMAL
- en: Except for the e-mail recipients, all of the same e-mail settings will be used
    for sending broken link e-mails as are used for server error e-mails. So if you
    have verified that server error e-mails are successfully sent, broken link e-mails
    will also be successful.
  prefs: []
  type: TYPE_NORMAL
- en: Broken link e-mail notifications are only useful so long as reports of legitimate
    problems are not drowned in a sea of reports related to the activity of web crawlers,
    bots, and malicious people probing the site bent on mischief. To help ensure that
    the notifications sent are related to valid problems, there are a couple of additional
    settings that can be used to limit the URL paths reported as broken links. These
    are `IGNORABLE_404_STARTS` and `IGNORABLE_404_ENDS`. A broken link e-mail is only
    sent for request pages that do not start with `IGNORABLE_404_STARTS` and do not
    end with `IGNORABLE_404_ENDS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value for `IGNORABLE_404_STARTS` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The default value for `IGNORABLE_404_ENDS` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can add to these as necessary to ensure that the e-mails generated for broken
    links are reporting actual problems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now completed the overview of debugging support in Django. In this
    chapter, many topics were introduced that will be covered in greater depth in
    subsequent chapters. Specifically, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: Learned about the Django settings that control the collection and presentation
    of debug information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seen how when debug is turned on, special error pages are produced that help
    with the task of debugging problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned about the history of database queries that is maintained when debugging
    is turned on, and saw how to access it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed several features of the development server that are helpful when debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Described how errors are handled in production, and the settings related to
    ensuring that helpful debug information is routed to the correct people
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter will proceed to delve into the details of Django debug pages.
  prefs: []
  type: TYPE_NORMAL
