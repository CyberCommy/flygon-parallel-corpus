- en: Project 4 - Geolocated Blog
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目4 - 地理定位博客
- en: 'In this chapter, we will build our fourth app. We will cover new topics, such
    as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建我们的第四个应用程序。我们将涵盖新的主题，例如：
- en: Managing the state of the app in a centralized store using the official Vuex
    library
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用官方的Vuex库来管理应用程序的状态的集中式存储
- en: Using the Google OAuth API to connect our users to the app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google OAuth API将我们的用户连接到应用程序
- en: Integrating Google Maps to our app with the `vue-googlemaps` third-party library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`vue-googlemaps`第三方库将Google地图集成到我们的应用程序中
- en: Rendering functions and JSX
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染函数和JSX
- en: Functional components--making lighter and faster components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能组件--制作更轻量和更快的组件
- en: 'The app will be a Geolocated Blog that will mainly display a big map where
    the user will add blog posts. Here are the main features of the app:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将是一个地理定位博客，主要显示一个大地图，用户将在其中添加博客文章。以下是该应用程序的主要功能：
- en: A login page will ask the user to authenticate using their Google account
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面将要求用户使用他们的Google帐户进行身份验证
- en: The main view will be a Google map embeded in the app, with a marker for each
    post
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主视图将是嵌入应用程序中的Google地图，每个帖子都有一个标记
- en: Clicking on the markers will display the content in a side panel to the right,
    with the description of the location, the post, a like counter, and a list of
    comments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击标记将在右侧显示内容，包括位置描述、帖子、点赞计数和评论列表
- en: Clicking anywhere else on the map will display a form in the side panel so the
    user can create a new post at this location
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图的其他任何位置单击将在侧边栏中显示一个表单，以便用户可以在此位置创建新的帖子
- en: The top bar of the application will display the current user's avatar and name,
    with a button to center the map on their position and another to log out
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的顶部栏将显示当前用户的头像和名称，以及一个按钮，用于将地图居中显示在他们的位置，并另一个按钮用于注销
- en: 'The final application will look as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终应用程序将如下所示：
- en: '![](assets/4a34b78b-fc86-4bb3-b430-6072c71f2716.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4a34b78b-fc86-4bb3-b430-6072c71f2716.png)'
- en: Google Auth and state management
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google身份验证和状态管理
- en: In this first section, we will create our first Vuex store to help us manage
    the state of our application. We will use it to store the current user logging
    in through the Google OAuth API, which allows them to use their Google account
    to connect to our app.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一部分中，我们将创建我们的第一个Vuex存储，以帮助我们管理应用程序的状态。我们将使用它来存储通过Google OAuth API登录的当前用户，这允许他们使用他们的Google帐户连接到我们的应用程序。
- en: Project setup
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: First, let's set up the basic structure of our new project. We will continue
    using the router and a few parts of [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml),
    *Project 3 - Support Center*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置新项目的基本结构。我们将继续使用路由器和[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)的一些部分，*项目3
    - 支持中心*。
- en: Creating the app
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: In this section, we will setup the base app structure for our Geolocated Blog.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为我们的地理定位博客设置基本应用程序结构。
- en: 'Like we did in [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project
    3 - Support Center*, we will initialize a Vue project with `vue-init` and install
    the babel, routing, and stylus packages:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)中所做的那样，*项目3 - 支持中心*，我们将使用`vue-init`初始化一个Vue项目，并安装babel、routing和stylus包：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don't forget to add the `"vue"` preset in the `.babelrc` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`.babelrc`文件中添加`"vue"`预设。
- en: Then remove the content of the `src` directory.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后删除`src`目录的内容。
- en: We will reuse the `$fetch` plugin we made in [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml),
    *Project 3 - Support Center*, so copy the `src/plugins/fetch.js` file too in the
    new project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用我们在[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)中制作的`$fetch`插件，因此也将`src/plugins/fetch.js`文件复制到新项目中。
- en: 'In the `src` folder, add the `main.js` file that starts our app like we did
    in [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project 3 - Support
    Center*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，添加启动我们应用程序的`main.js`文件，就像我们在[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)，*项目3-支持中心*中所做的那样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will still use `moment.js` to display dates, so you can install it with
    this command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们仍然会使用`moment.js`来显示日期，所以您可以使用以下命令安装它：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This shorter notation is equivalent to `npm install --save`. For development
    dependencies, you can use `npm i -D` instead of `npm install --save-dev`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更短的表示法等同于`npm install --save`。对于开发依赖项，您可以使用`npm i -D`而不是`npm install --save-dev`。
- en: 'Create the same simple date filter as before in a new `src/filters.js` file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`src/filters.js`文件中创建与之前相同的简单日期过滤器：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the `$fetch` plugin, you can remove the references to the `state.js` file
    since we won''t have one this time:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`$fetch`插件中，您可以删除对`state.js`文件的引用，因为这次我们不会有这个文件：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Also the way we log out the user if a request receives a `403` HTTP code will
    be different, so you can remove the relevant code too:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求收到`403` HTTP代码时登出用户的方式也将不同，因此您也可以删除相关代码：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, download ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter6-full/client/src/styles](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter6-download/styles))
    and put them in a `src/styles` directory.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，下载（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter6-full/client/src/styles](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter6-download/styles)）并将它们放在`src/styles`目录中。
- en: Some routing
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些路由
- en: 'The app will have three pages:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将有三个页面：
- en: The login page with a Sign in with Google button
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有“使用Google登录”按钮的登录页面
- en: The main Geolocated Blog page with the map
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有地图的主地理定位博客页面
- en: A "not found" page
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“未找到”页面
- en: 'We will now create the main component and set up those pages with bare components:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建主组件并使用简单组件设置这些页面：
- en: Create a new `src/components` folder and copy the `NotFound.vue` component from
    [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project 3 - Support
    Center* .
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`src/components`文件夹，并从[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)，*项目3-支持中心*中复制`NotFound.vue`组件。
- en: 'Then add the `App.vue` file with the `router-view` component and the main stylus
    file:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`App.vue`文件，其中包含`router-view`组件和主要的stylus文件：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the `GeoBlog.vue` file, which will be pretty bare for now:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`GeoBlog.vue`文件，目前将非常简单：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the `Login.vue` file with the Sign in with Google button. The button calls
    an `openGoogleSignin` method:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加带有“使用Google登录”按钮的`Login.vue`文件。按钮调用`openGoogleSignin`方法：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a `router.js` file similar to what we did in [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)
    , *Project 3 - Support Center*. It will contain the three routes:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似于我们在[第5章](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml)中所做的`router.js`文件，*项目3-支持中心*。它将包含三个路由：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The router should be already imported in the main file and injected in the application.
    We are now ready to continue!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 路由应该已经在主文件中导入并注入到应用程序中。我们现在准备继续！
- en: State management with Vuex
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vuex进行状态管理
- en: This is the exciting section of this chapter where we will use the second very
    important official Vue library--Vuex!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的激动人心的部分，我们将使用第二个非常重要的官方Vue库--Vuex！
- en: Vuex allows us to use a centralized store to manage the global state of our
    app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Vuex允许我们使用集中式存储来管理应用程序的全局状态。
- en: Why do I need this?
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我为什么需要这个？
- en: The big question is why we need a centralized state management solution in the
    first place. You may have noticed in the previous projects that we have already
    used a very simple `state.js` file with an object containing the global data we
    needed across our components. Vuex is the next step in that direction. It introduce
    a few new concepts to help us manage and debug the state of our application in
    a formal and efficient way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: When your application grows, you or your team will add many more features and
    components (maybe well over a hundred). Lots of them will share data. With the
    increasing complexity of the interconnections between your components, you will
    end up with a mess, with too many components whose data you need to keep in sync.
    At this point, the state of your app will no longer be predictable and understandable,
    and your app will become very difficult to evolve or maintain. For example, imagine
    that a button buried inside four or five components in the component tree needs
    to open a side panel located in the far opposite-- you may have to use a lot of
    events and props to pass the information up and down through many components.
    You effectively have two sources of truth, which means the two components share
    data that has to be somehow in sync or else your app breaks because you no longer
    know which component is right.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/144ef140-e938-4882-8d42-2b3a06745c72.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: The recommended solution to this problem is Vuex, from Veu. It is inspired by
    the Flux concept that Facebook developed, which gave birth to the Redux library
    (well known in the React community). Flux is a set of guiding principles that
    emphasize the use of a one-way flux of information through the components with
    a centralized store. The benefits are that your application logic and flow will
    be easier to reason about, so it improves maintainability by a great margin. The
    downside is that you may have to understand some new concepts and incidentally
    write a little more code. Vuex effectively implements some of these principles
    to help you improve the architecture of your applications.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: A real example of this was the Facebook notification system--the chat system
    was complex enough that it was difficult to determine what message you had seen.
    Sometimes, you might get a notification for a new message you already read, so
    Facebook worked on this Flux concept to fix this issue by changing the application
    architecture.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: For our first example, the button and the side panel component don't need to
    synchronize their state across the whole application. Instead, they use the centralized
    store to get data and dispatch actions--this implies they don't need to know each
    other and they don't rely on their ancestors or children components to synchronize
    their data. It mean there is now a single source of truth, which is the centralized
    store--you don't need to keep data in sync between components anymore.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '>![](assets/b543f062-f694-4f8b-b6a9-cfcb04216376.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We will now architect our applications around the Vuex library and its principles.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Vuex is recommended for most applications, but you don't have to use it if it's
    not necessary, in very small projects such as prototypes or simple widgets.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The Vuex Store
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The central element of Vuex is the store. It is a special object that allows
    you to centralize the data of your app into a model that follows good design-patterns
    and helps prevent errors like we saw in the previous section. It will be the main
    architecture of our data and what we do with it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'The store contains the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The state, which is a reactive data object that holds the state of your app
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getters, which are the equivalent of computed properties for the store
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutations, which are functions used to modify the application state
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions, which are functions that usually call asynchronous APIs and then mutations
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So a store should look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0259bc16-604e-4ffa-b499-fef0bb82b39d.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'That''s a lot of new vocabulary to understand, so let''s create a store while
    walking through these new concepts. You will see that it''s not as difficult as
    it might seem:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Download vuex with the ''npm i -S vuex'' command.Create a new `store` folder
    and add a `index.js` file that installs the Vuex plugin:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the store with the `Vuex.Store` constructor:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Export it as default like we do for the router:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the main `main.js` file, import the store:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Webpack will detect that `store` is a folder and will automatically import the
    `index.js` file inside it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the store in our application, we need to inject it just like the
    router:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All the components now have access to the store with the `$store` special property,
    similar to `vue-router` special objects such as `$router` and `$route`. For example,
    you could write this inside a component:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The state is the source of truth
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main piece of the store is its state. It represents the data shared across
    the components of your app. The first principle is--this is the **single source
    of truth** for your shared data. Since components will all read data from it,
    and it will always be right.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the state will only have a `user` property, which will contain the
    logged user data:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'In the store options, add to the state a function that returns an object:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Also, the next very important principle is--the state is **read-only**. You
    shouldn't modify the state directly, or else you lose the benefits of using Vuex
    (which is to make the shared state easy to reason about). If you have lots of
    components modifying the state as they wish anywhere in the app, it will be harder
    to follow the flow of the data and debug it using the dev tools. The only valid
    way of changing the state is through mutations, as we will see in a moment.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'To try reading the state, let''s create the `AppMenu.vue` component in the
    `components` folder. It will display user info, the `center-on-user` button, and
    the `logout` button:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `user` object will have a profile property from Google, with the display
    name and the photo of the user.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this new `AppMenu` component in `GeoBlog.vue` :'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For now our user is not logged in, so nothing is displayed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Mutations update the state
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we consider the state as read-only, the only way to modify it is through
    mutations. A mutation is a synchronous function that takes the state as the first
    argument and an optional payload argument, and then updates the state. It means
    you are not allowed to do asynchronous operations (like a request to the server)
    in a mutation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our first mutation, of type `''user''`, which will update the user
    in the state:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Mutations are very similar to events--they have a type (here it's `'user'`)
    and a handler function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The word used to indicate that we are calling a mutation is **commit**. We can't
    directly call them--it's like events, we ask the store to trigger the mutations
    corresponding to a specific type.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke our mutation handler, we need to use the `commit` store method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s try this in the `logout` function in the `AppMenu` component so we can
    test the mutation:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now if you click on the logout button, you should see the user info being toggled.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutations are synchronous for debugging reasons. The way the state is handled
    makes it easy to track it and debug faulty behavior in the application since the
    dev tools can take snapshots of it. But if your mutations make asynchronous calls,
    then the debugger has no way to tell what the state is before and after the mutation,
    making it untraceable:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you avoid modifying the state outside synchronous mutations, you can
    enable strict mode like this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will throw an error when the state is modified outside of a synchronous
    mutation preventing the debugging tools from working correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'You shouldn''t enable strict mode in production, since it will have an impact
    on performance. Use this expression to do that--`strict: process.env.NODE_ENV
    !== ''production''`, which will ensure the `NODE_ENV` standard environment variable
    tells you in which development mode you are (usually development, testing, or
    production).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try changing the state directly in the `logout` test method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then click again on the logout button and open the browser console--you should
    see that Vuex has thrown errors because you are modifying the state outside of
    proper mutations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fb4e4be-c081-4d85-bf19-d87c4de3d609.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: Time-travel debugging
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the benefits of using the Vuex approach is the debugging experience.
    In more complex apps, this is very useful to track the state of the app mutation-by-mutation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Revert to the mutations call in the `logout` method. Click a few times on the
    logout button, then open the Vue dev tools and open the Vuex tab. You should see
    a list of mutations that were committed to the store:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/882a450b-d415-46d8-ae14-e2a973358052.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: On the right, you can see the state that was recorded for the selected mutation
    and its payload (the argument passed to it).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'You can go back to any state snapshot by hovering over a mutation and clicking
    on the Time Travel icon button:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f833a1fb-d016-4c38-a4e8-e8164f2ab673.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Your app will be back in the state it was originally! You can now go step-by-step
    and replay the evolution of the app state as the mutations are committed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Getters compute and return data
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Getters work like computed properties for the store. They are functions that
    take the state and the getters as arguments, and return some state data:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `user` getter that returns the user held by the state:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In our `AppMenu` component, we can use this getter instead of accessing the
    state directly:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This doesn't seem to be different from before. But accessing the state directly
    isn't recommended--you should always use getters since it allows you to modify
    the way you get the data without having to change the components using it. For
    example, you can change the structure of the state and adapt the corresponding
    getters without having an impact on the component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a `userPicture` getter that we will implement later when we
    have the real Google profile:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the `AppMenu` component, we can already use it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Actions for store operations
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final element composing the store is actions. They are different from mutations,
    because they don''t modify the state directly, but they can both **commit mutations**
    and make **asynchronous operations**. Similar to the mutations, actions are declared
    with a type and a handler. The handler can''t be called directly, you need to
    dispatch an action type like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An action handler takes two arguments:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`context`, which provides the `commit`, `dispatch`, `state`, and `getters`
    utilities linked to the store'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payload`, which is the argument provided to the `dispatch` call'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add our first actions, of type `''login''` and `''logout''`, which don''t
    expect a payload:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `AppMenu` component, we can test them by replacing the code of the methods
    corresponding to the two buttons:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, if you click on the buttons in the menu, you should see the user profile
    appear and disappear.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to getters, you should always use actions instead of mutations inside
    your components. There is a good chance that the features of your app will evolve,
    so it's a good idea to be able to change the action code rather than the component
    code (for example, if you need to call a new additional mutation). Look at actions
    as abstraction for your general application logic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Mapping helpers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex provides a few helper functions to add state, getters, mutations, and actions.
    Since we should only use getters and actions in our components to help separate
    the state and related logic from the components, we will only use `mapGetters`
    and `mapActions`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions generate appropriate computed properties and methods to the
    components that rely on the corresponding getters and actions from the store,
    so you don''t have to type `this.$store.getters` and `this.$store.dispatch` each
    time. The argument is either:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: An array of types that are mapped with the same name as? the component
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object, whose keys are the aliases on the component and the value are the
    types
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following code using the array syntax:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Is equivalent to this in the component:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And the following code using the object syntax:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Is equivalent to this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s refactor our `AppMenu` component to use those helpers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'First import those in the component:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we can rewrite the component like this:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, the component will have two computed properties that return the corresponding
    store getters, and two methods that dispatch the `'login'` and `'logout'` action
    types.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: User state
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add the user system to allow users to log in with their
    Google account.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Google OAuth
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can use the Google API, we have to configure a new project in the
    Google Developers Console:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Developer Console at [console.developers.google.com.](https://accounts.google.com/ServiceLogin/signinchooser?service=cloudconsole&passive=1209600&osid=1&continue=https%3A%2F%2Fconsole.developers.google.com%2F%3Fref%3Dhttps%3A%2F%2Fcdp.packtpub.com%2Fvue_js_2_project_guide%2Fwp-admin%2Fpost.php%3Fpost%253D366%2526post_type%253Dchapter%2526action%253Dedit&followup=https%3A%2F%2Fconsole.developers.google.com%2F%3Fref%3Dhttps%3A%2F%2Fcdp.packtpub.com%2Fvue_js_2_project_guide%2Fwp-admin%2Fpost.php%3Fpost%253D366%2526post_type%253Dchapter%2526action%253Dedit&flowName=GlifWebSignIn&flowEntry=ServiceLogin)
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new project using the Projects drop-down at the top of the page and
    give it a name. When project creation is finished, select it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To retrieve the user profile, we need to enable the Google+ API. Go to APIs
    & services | Library and click on Google+ API under the Social APIs section. On
    the Google+ API page, click on the Enable button. You should then see a usage
    dashboard with some empty graphs.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we need to create application credentials to authenticate our server to
    Google. Go to APIs & services | Credentials and select the OAuth consent screen
    tab. Make sure you select an email address and enter a *Product name shown to
    users*.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Credentials tab, click on the Create credentials drop-down, and then
    select OAuth client ID. Select Web application as the application type, then enter
    the URL where the server will be up in the Authorized JavaScript origins field.
    For now, it will be `http://localhost:3000`. Press the *Enter* key to add it to
    the list. Then add the URL to which Google will redirect the user after the Google
    login screen into the Authorized redirect URIs--`http://localhost:3000/auth/google/callback`
    and press the *Enter* key. This URL corresponds to a special route on the server.
    When you are done, click on the Create client ID button.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/aaf1ebe9-cfb0-4497-8017-b8829913d19b.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Then copy or download the credentials containing the client ID and a secret
    that you shouldn't share with anybody outside of your team. These two keys will
    allow the Google API to authenticate your application and will display its name
    when the users log in through the Google login page.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the API server of the project ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter6-full/server](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter6-full/server)),
    and extract it outside of the `Vue app` directory. Open a new Terminal inside
    this new folder, and install server dependencies with the usual command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, you need to export the two `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET`
    environment variables with the corresponding values in the credentials file you
    downloaded from the Google Developers Console. For example, on Linux:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or on Windows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You need to do that each time you want to start the server in a new Terminal
    session.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start the server with the `start` script:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Login button
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Login` component contains the button that should open a popup displaying
    the Google login page. The popup will first load a route on the Node.js server,
    which will redirect to the Google OAuth page. When the user is logged in and has
    authorized our app, the popup is redirected to our nodejs server again and will
    send a message to the main page before closing:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `openGoogleSignin` method to open the popup to the `/auth/google`
    route on the server that will redirect the user to Google:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: After the user is successfully authenticated via Google, the callback page on
    the server will send a message to the Vue app window using the standard postMessage
    API.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When we receive the message, we need to check that it comes from the right domain
    (`localhost:3000` for our server).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `handleMessage` method with a destructured message parameter:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will dispatch the `''login''` action type to the store, which will fetch
    the user data soon. Map it to the component:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then we use the `mounted` lifecycle hook (outside of the methods) to add an
    event listener to the window:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'And finally, we don''t forget to remove this listener when the component is
    being destroyed:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: User in the store
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The store will have two actions related to the user--`login` and `logout`.
    We already have them, we now need to implement what they will do. We will also
    add some user-related features in this section, such as loading the user session
    when the app starts and displaying its profile picture in the top bar:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `login` action in the store. It will fetch user data,
    just like we did in [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project
    3 - Support Center*, and then `commit` the data to the state (don''t forget to
    import ''$fetch''):'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, an action can perform asynchronous operations, for example here
    requesting data to the server. If the user is connected, we redirect them to the
    page they wanted or the home page, like we did in [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml),
    *Project 3 - Support Center*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The `''logout''` action needs to send the `/logout` request to the server and
    redirect the user back to the login screen if the current route is private:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: According to the information we have put in the `router.js` file, if the user
    was on the `'home'` route, it will be redirected to the login page.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Adapting the router
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now have to restore the navigation guards to the router like in [Chapter
    5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml), *Project 3 - Support Center*--that
    way, the user won''t be able to enter the private route if they are not connected:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `router.js` file, restore the `beforeEach` navigation guard by using
    the `user` store getter to check whether the user is connected or not. It should
    be quite similar to the one we have already implemented:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Adapting the fetch plugin
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `$fetch` plugin needs some changes as well, since we need to log the user
    out if their session has expired:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we just need to dispatch the `''logout''` action:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Don''t forget to import the store:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can now try logging in through Google to your app!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Check the user session on start
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the application starts, we want to check whether the user has an active
    session like we did in [Chapter 5](2ec000b2-cfbd-4da5-af9c-974dec1813a2.xhtml),
    *Project 3 - Support Center:*
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we will create a new generic `''init''` action in the store; this
    will dispatch the `''login''` action, but could eventually dispatch more actions:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `main.js` file, we can now dispatch and wait for this action:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now you can log in through Google and refresh the page without being brought
    back to the login page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The profile picture
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we can implement the `userPicture` getter to return the first value
    contained in the `photos` array of the Google profile:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, we can reuse existing getters inside other getters with the
    second argument!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have the complete toolbar displayed in the app when you are
    connected:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ffc64515-9e15-4962-b75d-f009eee655cc.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: Synchronizing the store and the router
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can integrate the router into the store with the official `vuex-router-sync`
    package. It will expose the current route in the state (`state.route`) and will
    commit a mutation each time the route changes:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it with the usual command:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To use it, we need the `sync` method in the main `main.js` file:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, you can access the `state.route` object and time-travel debugging will
    apply to the router as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Google Maps
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this second part, we are going to add a map to the home page and control
    it through the Vuex store.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To integrate Google Maps, we will need an API and a third-party package called
    `vue-googlemaps`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Getting the API key
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use Google Maps in our app, we need to enable the corresponding API and
    generate an API key:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: In the Google Developers Console, go back to the APIs & services *|* Library
    and click on Google Maps JavaScript API under the Google Maps APIs section. On
    the API page, click on the Enable button.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then go to Credentials and create a new API key.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing the library
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now install the `vue-googlemaps` library, which will help us integrate
    Google Maps into our app.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'In the app, install the `vue-googlemaps` package with the following command:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the main `main.js` file, you can enable it in the app with the API key from
    Google:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We also specify we want to load the Google Maps Places library, useful for showing
    info on a location.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: We now have access to the components of the library!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `App.vue` component, add the style of the library:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We use the `~` character because Stylus doesn't support absolute paths. Here
    we want to access a npm module, so we add this to tell the `stylus-loader` that
    this is an absolute path.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Adding a map
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The map will be the main component of the app, and it will contain:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The user position indicator
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A marker for each post
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The eventual "ghost" marker for the post being created
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now set up a simple map that will fill the main page:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `BlogMap.vue` component with the `center` and `zoom` properties:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, you need to add it to the `GeoBlog.vue` component:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Don't forget to import it and to put it in the `components` option!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the BlogMap and the store
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now the state related to the map is local to the `BlogMap` component--let's
    move it to the store!
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Vuex modules
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the Vuex store, we can divide our state in modules, to have better organization.
    A module contains a state, getters, mutations, and actions, just like the main
    store. The store and each module can contain any number of modules, so the store
    can have nested modules inside other modules--it's up to you to find the structure
    that works best for your project.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'In this application, we will create two modules:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '`maps` related to the map'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`posts` related to the blog posts and comments'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, we will focus on the `maps` module. It''s best to at least separate
    each module in a different file or directory:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `maps.js` file in the `store` folder that exports as default a
    module definition and the state of the map:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then to add the module to the store, put it in a new `modules` option in the
    `store/index.js` file:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: By default, the state in the getters, mutations, and actions of the module will
    be the state of this module. Here it will be `store.state.maps`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Namespaced module
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `namespaced` option tells Vuex to also add the `'maps/'` namespace before
    all the getter, mutation, and action types of the module. It will also add them
    to the `commit` and `dispatch` calls inside the namespaced module.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a few getters that will be used by the `BlogMap` component:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `maps/center` and the `maps/zoom` getters will be added to the store. To
    read them, you could do:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'With the getter helper:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can also specify a namespace parameter:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The last way to do it is to generate helpers based on a specific namespace
    with the `createNamespacedHelpers` method:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Accessing global elements
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the namespaced module getters, you can access the root state and root getters
    (which means any getter) like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the actions, you have access to `rootGetters` in the context and you can
    use the `{ root: true }` option for the `commit` and `dispatch` calls:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: BlogMap module and component
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to wire the `BlogMap` component to the `maps`
    namespaced module.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Mutations
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the `center` and `zoom` mutations in the `maps` module:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Actions
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Then, we set up the actions that commit those mutations:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Mapping in the component
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back to our `BlogMap` component; we can use the helpers to map the getters
    and the actions:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now the state of the map is managed in the Vuex store!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: User position
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we will add the user position indicator, which will give us the position
    so we can store it in the store:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `googlemaps-user-position` component inside the map:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now we need to add this `userPosition` info in the `maps` module:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: And then map the `setUserPosition` action in the `BlogMap` component using the
    appropriate helper.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we should have the user position committed in the store (assuming you have
    given the browser the permission to access your position).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Centering on the user
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This user position will be very useful to center the map on the user:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new `centerOnUser` action in the `maps` module:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With this, we can also change the `setUserPosition` action--if it's the first
    time we get the user position (which means it's `null` in the state), we should
    center the map on the user.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setUserPosition` action should now look like this:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You can try it now, and have the map centered on you with a little blue dot.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: By default, the user indicator is disabled if the accuracy of your position
    is more than 1,000 meters, so it's possible that this won't work depending on
    your hardware. You can use a higher value with the `minmumAccuracy` prop of the
    `googlemaps-user-position` component.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a `''center on user''` button in the toolbar, so we need to replace
    the `centerOnUser` action mapping in the `AppMenu` component:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Blog posts and comments
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last part, we are going to add the blog content to the app. Each blog
    post will have a position and an optional place ID from Google Maps (so the place
    can be described, for example, as "Restaurant A"). We will load the posts that
    fit in the visible bounds of the map and each one will appear as a marker with
    a custom icon. When clicking on a marker, the right side panel will display the
    post content and a list of comments. Clicking anywhere else on the map will create
    a draft post at this location in the Vuex store and display a form to write its
    content and save it in the right side panel.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Posts store module
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new `posts` namespaced Vuex module to manage shared
    data related to the blog posts:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `store/posts.js` file with those state properties:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Next we need a few getters:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And some mutations (note that we mutate `posts` and `mapBounds` together so
    they stay consistent):'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, add it to the store like we did for the `maps` module:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Rendering functions and JSX
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](cb653442-5aaa-47b6-ad7b-d94ce15821b7.xhtml), *Advanced Project
    Setup*, I already wrote about render functions and JSX, which are different ways
    other than templates to write the view of the components. Before continuing, we
    will go into more detail about those and then we will put them into practice.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Writing the view in JavaScript with render functions
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue compiles our templates into `render` functions. This means that all the
    component views are JavaScript code in the end. Those render functions will compose
    the Virtual DOM tree of elements to be displayed in the page real DOM.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, templates are fine, but you may come across cases where you
    need the full programmatic power of JavaScript to create a component view. Instead
    of specifying a template, you write a `render` function to your component. For
    example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The first argument is `createElement`, the function you need to call to create
    elements (which can be either DOM elements or Vue components). It takes up to
    three arguments:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '`element` (required), which can be the name of an HTML tag, the ID of a registered
    component, or directly a component definition object. It can be a function returning
    one of these.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data` (optional) is the Data Object, which specifies things such as CSS classes,
    props, events, and so on.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`children` (optional) is either a text string or an array of children constructed
    with `createElement`.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use `h` as an alias of `createElement`, the argument of the `render`
    function, since it's the common name used by everyone (and it's required by JSX
    as we will see in a bit). `h` comes from the hyperscript term describing "writing
    HTML using JavaScript".
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'The first example would be equivalent to this template:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Dynamic templates
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main advantages of writing render functions directly are that they are closer
    to compiler and you have the full power of JavaScript available to manipulate
    the template. The obvious drawback is that it doesn't look like HTML anymore,
    but this can be alleviated by JSX as we will see in the *What is JSX* section.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could create a component that renders a title at any level
    we want:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Here we skipped the data object argument since it is optional. We only passed
    the tag name and the content.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, for example, we would use it in our template to render an `<h2>`
    title element:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The equivalent in template would be quite tedious to write:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Data objects
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second optional argument is the data object, which allows you to pass additional
    information about the element to `createElement` (or `h`). For example, you can
    specify CSS classes in the same way we use the `v-bind:class` directive in our
    classic templates, or we can add event listeners.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a data object that covers most features:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'For example, we can apply a special CSS class if the title level is below a
    specific number:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We could also put a click event listener that calls a method of the component:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can find the full description of this object in the official documentation
    ([https://vuejs.org/v2/guide/render-function.html#The-Data-Object-In-Depth](https://vuejs.org/v2/guide/render-function.html#The-Data-Object-In-Depth)).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, Vue uses render functions in pure JavaScript under-the-hood
    of our templates! We can even write our own render functions, using the `createElement`
    (or `h`) function to construct the elements to be added to the Virtual-DOM.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: This way of writing our views is more flexible and powerful than templates,
    but is more complex and verbose. Use it when you feel comfortable with it!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The result of the `render` function is a tree of nodes created with the `createElement`
    (or `h`) function; these are called **VNodes** in Vue. It represent the view of
    the component in the Virtual DOM held by Vue. Every element in the DOM is a node--HTML
    elements, text, even comments are nodes:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a1be10b7-445c-47b5-bb36-b8944629d491.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: Vue doesn't directly replace the Real DOM tree with the new Virtual DOM tree,
    because it may engender a lot of DOM operations (add or remove nodes), which are
    costly. To be more performant, Vue will create a diff between the two trees, and
    it will only do the DOM operations necessary to update the Real DOM to match the
    Virtual DOM.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: All of this happens automatically so that Vue keeps the Real DOM up-to-date
    when data changes in your application.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: What is JSX?
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSX is a language created to write code that looks more like HTML inside the
    `render` function''s JavaScript code. It is effectively an XML-like extension
    to JavaScript. Our first previous example looks like this in JSX:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is possible thanks to Babel, the library that is in charge of compiling
    our ES2015 JavaScript (or more recent) code into old ES5 JavaScript, which runs
    in older browsers such as Internet Explorer. Babel can also be used to implement
    new features into the JavaScript language (such as the proposed draft features
    that may appear in later versions) or entirely new extensions such as JSX.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The `babel-plugin-transform-vue-jsx` included in `babel-preset-vue` takes care
    of transforming the JSX code into real JavaScript code that uses the `h` function.
    So the previous JSX example will be transformed back into:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: That's why we need to use `h` instead of `createElement` when using JSX.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, vue-cli already has this enabled, so we can write JSX code in our
    `.vue` files!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Blog content structure (in JSX!)
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a new `src/components/content` folder and a new `BlogContent.vue`
    file inside it. This component represents the right side panel and will be responsible
    for displaying the right component:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: A `LocationInfo.vue` component that may display the location adress and name
    if selected on the map
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Below, it will display one of the following:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `NoContent.vue` component if no location is selected, with a click on the
    map hint
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `CreatePost.vue` component if there is a draft post, with a form
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `PostContent.vue` component if a real post is selected, with the content and
    the comments list
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create those components as well in the `content` directory, with an
    empty template:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Back to our `BlogContent.vue` component! We will write this new component in
    JSX to practice it.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the namespaced helpers:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: It is good practice to rename the namespaced helpers because you may add helpers
    for another module in the future. For example, if you don't, you may end up with
    two `mapGetters`, which is impossible. Here we rename `mapGetters` to `postsGetters`
    and `mapActions` to `postsActions`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Then let''s write the component definition:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `has-content` CSS class will be used on a smartphone to hide the pane when
    no post is selected or no draft is being edited (it will be full screen).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to write the render function with JSX:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Don't forget to import the four other components as well!
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'In JSX, the case of the first letter of a tag is important! If it starts with
    a lowercase letter, it will be considered as a string parameter for the `createElement`
    function and will resolve either to an HTML element or a registered component
    (for example, `<div>`). On the other hand, if the first letter is uppercase, it
    will be considered as a variable! In our preceding code, `LocationInfo` is directly
    used from the import. For example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We also use this to dynamically choose which component will be displayed, thanks
    to the `Component` local variable (note the uppercase `C`). It wouldn't work if
    the first letter of the variable name was lowercase.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `GeoBlog.vue` component in JSX as well while adding the
    `BlogContent` component:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Don't forget to remove the `<template>` part in the file! You can't have both
    a render function and a template.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: No content
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before continuing, let''s quickly add the template of the `NoContent.vue` component,
    which just displays a hint when no post is selected:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Creating a post
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user clicks on a location on the map with no marker, we create a draft
    post; then the form in the right side panel will edit its content. When the user
    clicks the Create button, we send the draft to the server and add the result (the
    new post data) to the posts list.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Draft store actions
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `posts` namespaced store module, we will need a few new actions to create,
    update, and clear the draft post:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `clearDraft`, `createDraft`, `setDraftLocation`, and `updateDraft`
    actions:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The action we call when the user clicks the map is `setDraftLocation`, which
    will automatically create a new draft, if there isn't one, and update its location.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Blog Map changes
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to make some changes to the `BlogMap` component to integrate our Vuex
    store.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `BlogMap.vue` component, we can add the Vuex helpers for the `posts`
    namespaced module, while renaming the ones we already have for the `maps` module:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Add the `draft` getter:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Add the `setDraftLocation` action as well:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Click handler
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also need to handle the clicks on the map to create a new blog post.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `click` handler to the map:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Add the corresponding method that dispatches the `setDraftLocation` action
    with the eventual `latLng` (the position) and `placeId` from Google Maps:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: You can now try to click on the map--two mutations (one to create the draft
    and one to update its location) should be recorded in the dev tools.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/435f77ad-0ade-480b-8a5e-734329233d70.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
- en: Ghost marker
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would like to display a transparent marker on the position of the draft.
    The component to use is `googlemaps-marker`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new marker in the `googlemaps-map` component that uses the info from
    the `draft` getter:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If you don't see the new marker, refresh the page.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Try clicking on the map to see the ghost marker in action:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d375c3c2-a67a-4a0d-b825-ce6883bff7b8.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: Post form
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Onward to the `CreatePost.vue` component! This component will display a form
    to enter the details of the new post like its title and content.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create its template with a simple form:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Then map the Vuex helpers from the `posts` module:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Add the necessary getters and methods:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Then we will add a few computed properties bound to the form input elements
    with the `v-model` directive:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'As you can see, we can use computed properties in two ways with this object
    notation: with a getter and with a setter! That way, we can use them to read a
    value, but also to easily change it:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '`get()` is called like before when the computed property is first read or if
    it needs to be recomputed'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(value)` is called when the property is assigned a value, for example `this.a
    = ''new value''`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is very useful when working with Vuex and forms, because it allow us to
    use a Vuex getter for the `get` part, and a Vuex action for the `set` part!
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a `handleSubmit` method that dispatches the `createPost` action
    that we will create very soon:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Making the request
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now implement an action to send a new Geolocated Blog post to the server.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the new `createPost` action in the `posts` Vuex module(don''t
    forget to import ''$fetch'')):'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This is our most complex action yet! It prepares the data (notice how we serialize
    the Google Maps `position` object to a JSON-compatible plain object). Then we
    send a POST request to the `/posts/new` path on our server, and retrieve the result,
    which is the new real post object (with its `_id` field set). Finally, the draft
    is cleared, and the new post is added to the store and selected.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a new `selectPost` action so the new post will be automatically
    selected:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: You can now create posts by clicking on the map!
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3b59b9f1-15d7-400b-b937-534a89b0cb57.png)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
- en: Fetching posts
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will fetch the posts from the server and display them on
    the map.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Store action
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will fetch the posts each time the map bounds have changed due to the user
    panning or zooming the map.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Fetch posts action
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the posts-fetching action, but we need to tackle a problem first,
    though. What the following happen:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: The user moves the map.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A request A is made to the server.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user moves the map again.
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A request B is sent.
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For some reason, we receive the request B response before request A.
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the list of posts from request B.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The response of request A is received.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list of posts is replaced from a no longer up-to-date request.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s why we need to abort the previous requests if a new one is made. To
    do that, we will use a unique identifier for each request:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the unique identifier at the top of the `posts.js` file:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now we can add the new `fetchPosts` action, which fetches the posts in the
    map bounds only if it''s different from last time (with an additional `force`
    parameter in the payload):'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The `++fetchPostsUid` expression add 1 to `fetchPostsUid` and then returns
    the new value.We encode the map bounds as two points: North-East and South-West.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: The way we abort the query is by comparing the unique ID we stored before making
    the request (`requestId`) and the current ID counter (`fetchPostsUid`). If they
    are different, we don't commit the result because it means another request was
    made (since we increment the counter each time).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Action dispatching
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `maps` store, let''s create a `setBounds` action that will be dispatched
    when the maps is idle after being panned or zoomed. This action will dispatch
    the `fetchPosts` from the `posts` module:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `{ root: true }` option to dispatch the action in a non-namespaced
    way so you can reach the `posts` module one:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We have created another action in the `maps` module because it is related to
    the map and it could do more in the future than just dispatching another action.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `BlogMap.vue` component, map the new `setBounds` action on the right
    helper and add a `''map''` ref and an `''idle''` event listener to the map:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'And add the corresponding `onIdle` method to dispatch the `setBounds` action
    and pass the map bounds:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Refresh the app and look for the `posts` mutations in the dev tools when you
    pan or zoom the map.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Displaying markers
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Still in the `BlogMap` component, we will use the `googlemaps-marker` again
    to loop through the posts and display a marker for each of them. Map the `posts`
    and `currentPost` getters, plus the `selectPost` action, on the right helper and
    add the markers loop inside the `googlemaps-map` component:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: You can now refresh the app and see the posts you added earlier appear on the
    map! If you click on a post marker, its icon should turn white too.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7d9e15e1-1cf4-4e0c-9ea0-ed7506a2f990.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
- en: Login and logout
  id: totrans-516
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are not done with the post-fetching yet--we need to react to a user logging
    in or out:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: When the user log out, we will clear the posts list and the last registered
    map bounds so the posts can be fetched again
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user log in, we will fetch the posts again and eventually re-select
    the previously selected post
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logout
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will implement the logout action.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `logout` action in the `posts` Vuex module that clears the posts
    fetching data:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can call this from the `logout` action in the main store (in the `store/index.js`
    file):'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This is going to work, but we can improve this code--we could define the `logout`
    action of the `posts` namespaced submodule as a root action. That way, when we
    dispatch the `'logout'` action, both the `logout` and the `posts/logout` will
    be called!
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this object notation in the `posts` module for the `logout` action:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `handler` property is the function called on this action, and the `root`60;Boolean
    property indicates if this is a root action. Now the `logout` action is no longer
    namespaced regarding the action dispatching system, and will be called if a non-namespaced
    `'logout'` action is dispatched.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The state, getters, commit, and dispatch made inside this `logout` action are
    still namespaced to the module. Only its invocation is no longer namespaced!
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: You can remove the `dispatch('posts/logout')` line from the `logout` action
    on the main store.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Login
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user is successfully logged in, we will dispatch a non-namespaced `'logged-in'`
    action.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `posts` module, add the `logged-in` action using the new object
    notation:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'In the main store `login` action, dispatch this new `logged-in` action if the
    user is successfully authenticated:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Selecting a post
  id: totrans-538
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last section of this chapter! We will now create the post content
    component that will display the title, content, location info, and the comment
    list. A post details object is the same as a post object plus the author data,
    the list of the comments, and the authors for each comment.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Post details
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first modify our `posts` Vuex module in preparation for the posts details.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Store changes for post selection and sending
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add a `selectedPostDetails` data property in the state and add the corresponding
    getter and mutation:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In the `selectPost`, fetch the details with a request to the `/post/<id>` route
    on the server:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Also add a new `unselectPost` action:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Post Content component
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We the user clicks on a blog marker on the map, we need to display its content
    in the side pane. We will do this in a dedicated `PostContent` component.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `content/PostContent.vue` component by starting the initial
    template:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The first part is the header with the author avatar, the title, author name,
    and creation date. Then we display the post content, followed by the comment list,
    and an action toolbar at the bottom. It will also display a loading animation
    before we receive the post details response from the server.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need a script section with the `details` getter and the `unselectPost`
    action from the `posts` module:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now you can try selecting a post marker and see its content displayed in the
    right side panel:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca28bb2a-f800-4cc5-92f9-bb56bd5d761b.png)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
- en: Location info and scoped slots
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to display information about the current post location at the top
    of the right sidebar, with the name and the address. The components from `vue-googlemaps`
    that we are going to use take advantage of a Vue feature called "scoped slots."
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Scoped slots to pass data to the parent
  id: totrans-560
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should already know what slots are--they allow us to put elements or components
    inside other components. With scoped slots, the component where the `<slot>` parts
    are declared can pass down data to the view that is being embedded in the slot.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could have this component with a default slot that has a list
    of results in the `results` property:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We could pass this property to the external view that includes parts of templates
    through the slot like this:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'When using this component, you can retrieve the scoped data by wrapping your
    code with a template with a `slot-scope` attribute. All the scoped data will be
    available in this attribute object:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The `<template>` tag is not necessary if it has only one child.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: This is how the components of the `vue-googlemaps` library that we will use
    shortly will give us back the data from Google Maps.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'Scoped slots are very useful too when combined with a loop:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'When using it, the content of the slot will be repeated and will pass down
    the current item:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In this example, if the `results` computed property returns three items, we
    will have three `<div>` displaying the result labels.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Implementing of the component
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now use this new Scoped slot concept to display the information about
    the place associated with the Blog post.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a small component named `PlaceDetails.vue` in the `components/content`
    folder that displays the name and the address of a location:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Then we will implement the `LocationInfo.vue` component.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'First the template, where we use either the `googlemaps-place-details` component,
    if we have a Google Maps `placeId` stored on the post, or else the `googlemaps-geocoder`
    component that will find the most relevant corresponding addresses from the position
    of the post, and all by retrieving the results with scoped slots:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'In the script part map the `currentPost` getter from the `posts` module and
    import the `PlaceDetails` component we just created:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Now, if you select or draft a post, you should see the location info display
    at the top of the right side panel:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4f709430-71bb-473d-898f-05052dfa5146.png)'
  id: totrans-585
  prefs: []
  type: TYPE_IMG
- en: Comments - functional components
  id: totrans-586
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last section of the chapter, where we will implement post components
    and learn more about faster functional components.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Store changes for comments
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going into functional components, we need to lay the groundwork in the
    Vue
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `posts` Vuex module, we need a new mutation that will add a comment
    to a post directly:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Add the new `sendComment` action too that sends a query to the server to the
    `/posts/<id>/comment` route and adds it to the selected post:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We use `rootGetters` from the action context to retrieve the user data, because
    it is not in this namespaced module.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Functional component
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each component instance in Vue has to set up a few things when it is created,
    such as the data reactivity system, component life cycles, and so on. There is
    a lighter variant of components called functional components. They don't have
    any state of their own (you can't use the `this` keyword) and can't be displayed
    in dev tools, but they have a very nice advantage in some cases--they are much
    faster and use less memory!
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: The Comments on our blog posts are good candidates for being functional because
    we could have to display a lot of them.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a function component, add the `functional: true` option to its definition
    object:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Since the component doesn't have a state and we don't have access to `this`,
    the `render` function gets a new `context` parameter containing the props, event
    listeners, children content, slots, and other data. You can find a full list on
    the official documentation ([https://vuejs.org/v2/guide/render-function.html#Functional-Components](https://vuejs.org/v2/guide/render-function.html#Functional-Components)).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: When writing functional components, you don't always need to declare props.
    You get everything as props, but they also get passed down in `context.data`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'Not that you can also use a template with the `functional` attribute instead
    of the `functional: true` option:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now create a new `Comment.vue` component alongside the `PostContent.vue` one:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Back to our `PostContent` component; let''s add the comment list in the center
    of the pane and the comment form to the bottom of the pane:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Then add the `Comment` component, the `commentContent` data property, the `commentFormValid`
    computed property, the `sendComment` Vuex action, and the `submitComment` method
    in the script section:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'You can now add comments to the selected post:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/caf312a5-de5f-4fb8-bf99-92854abc262f.png)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-613
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the very important notion of state management
    through the usage of the official Vuex library. This will help you build more
    complex applications and improve their maintainability a lot. We used the Google
    OAuth API to authenticate our users, embed Google Maps, and a whole Geolocated
    Blog! All of this was achieved by using a Vuex store integrated into our application,
    making our components simpler and our code easier to evolve.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some ideas if you want to improve the app further:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Display the number of thumbs-up on the post markers
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow editing or deletion of comments
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add real-time updates with web-sockets
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about server-side rendering, internationalization,
    testing, and deployment.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
