- en: '`# Real-Time Video Call App with WebRTC'
  prefs: []
  type: TYPE_NORMAL
- en: Hey! Just to let you know, the JS Meetup was a great success after getting a
    backend developer to complete the serverside of the application. But you did great
    completing the entire frontend of the application. You created a complete Event
    Registration website, which lets users sign up the events, while learning some
    really important concepts, such as building reusable ES6 modules, making AJAX
    requests while handling asynchronous code using Promises, creating beautiful charts
    out of data, and of course, the classic form validation with a validation service.
  prefs: []
  type: TYPE_NORMAL
- en: The backend code was also written with JavaScript (Node.js), so you might really
    be interested in writing serverside code. But sadly, as I mentioned earlier, Node.js
    is beyond the scope of this book. Actually, you can do some really cool things
    with plain JavaScript, although many people think, "*It needs a lot of server-side
    code!*" Since you will have already read the chapter title - yup! We are going
    to build a real Video Call app in this chapter with *almost zero* server-side
    code. The best part is, just like our other applications, this one is also going
    to be responsive and will work with most mobile browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the list of concepts we are about to learn in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to WebRTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebRTC APIs in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a SimpleWebRTC framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Video Call app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from these main concepts, there is a lot more to learn in this chapter.
    So, before we start, make sure you have the following hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: A PC or laptop with webcam and microphone (you might want to use another computer
    to experience a video call in action)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Android or iPhone device (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A LAN connection so that all your devices are on the same local network to test
    the application in development (can be either Wi-Fi or wired Ethernet)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the dependencies used in this project requires you to have Python 2.7.x
    installed in your system. Linux and Mac users have Python pre-installed. Windows
    users can download Python 2.7.x version from [https://www.python.org/downloads/](https://www.python.org/downloads/)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to WebRTC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building the application, it's best to know a few things about
    WebRTC so that you get a good idea about the workings of the app.
  prefs: []
  type: TYPE_NORMAL
- en: History of WebRTC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-time communication capabilities have become a common feature of many of
    the applications we use nowadays. Say you want to chat with your friend or watch
    a live soccer game. Real-time communication is a must for these applications.
    However, having live video calls on a browser in the past was quite a difficult
    task for users, because they had to install plugins into their system for different
    applications to use video calling on the web browser, and with plugins came vulnerabilities,
    hence, regular updates.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this problem, Google released an open source project in May 2011
    for browser-based real-time communication standards, called WebRTC. The concept
    of WebRTC is simple. It defines a set of standards that should be used across
    all applications so that applications can communicate directly with each other
    (peer-to-peer communication). By implementing WebRTC, there will not be any need
    for plugins anymore, since the communication platform is standardized.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, WebRTC is being standardized by the **World Wide Web Consortium**
    (**W3C**) and the **Internet Engineering Task Force** (**IETF**). WebRTC is actively
    being implemented by most browser vendors and it will also work with native Android
    and iOS applications. If you want to know whether your browser is ready to support
    WebRTC, you can visit: [http://iswebrtcreadyyet.com/](http://iswebrtcreadyyet.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the browser support status is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Even though most commonly used browsers support WebRTC, except Safari, there
    are still a lot of issues and bugs with the implementation, hence, it is recommended
    to use a shim such as `adapter.js` ([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter))
    so that the application will not suffer any problems during changes to spec or
    vendor prefixes. We'll see more about this when we look into the JavaScript APIs
    for WebRTC.
  prefs: []
  type: TYPE_NORMAL
- en: WebRTC is also supported in the mobile versions of Chrome and Firefox; hence,
    you can use video calls even in mobile browsers with no plugins.
  prefs: []
  type: TYPE_NORMAL
- en: For iPhone users Neither Safari mobile browser or Chrome support WebRTC on the
    iPhone yet. So, you either have to install Firefox or the Bowser app from the
    app store. Link for Bowser: [https://itunes.apple.com/app/bowser/id560478358?mt=8](https://itunes.apple.com/app/bowser/id560478358?mt=8).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript WebAPIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have used a few WebAPIs such as `FileReader`, document (used in
    the `document.querySelector()` methods), `HTMLImageElement` (the `new Image()`
    constructor we used in Meme Creator), and so on. They are not part of the JavaScript
    language, but they are part of the WebAPIs. When running JavaScript in browsers,
    it will be provided with a `window` object that contains all the methods of the
    WebAPIs. The scope of the `window` object is global and the properties and methods
    of the `window` object are also global. This means, if you want to use navigator
    WebAPI, you can either do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can simply do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Both will work just fine and implement the same methods. However, do note that
    WebAPI (`window` object) is available for JavaScript only when you run JavaScript
    on a browser. If you are using JavaScript on other platforms, such as Node.js
    or React Native, you will not have WebAPIs for use.
  prefs: []
  type: TYPE_NORMAL
- en: WebAPIs are growing more powerful nowadays and provide JavaScript with the ability
    to do more functions, such as recording video and audio directly from the browser.
    Progressive web applications are one such example, powered by the `ServiceWorker`
    WebAPI.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use a lot of WebAPIs in this chapter and the upcoming chapters.
    For a full list of the WebAPIs available for JavaScript, visit the following MDN
    page: [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript WebRTC API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since browsers support WebRTC natively, JavaScript WebAPIs have been created
    by browser vendors so that developers can easily build applications. Currently,
    WebRTC implements the following three APIs that are used by JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: MediaStream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTCPeerConnection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTCDataChannel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MediaStream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MediaStream API is used for getting access to the video and audio devices of
    the user. Generally, browsers will prompt the user as to whether he/she wants
    to allow the website to access the camera and microphone of his/her device. Even
    though the underlying concept for MediaStream API is the same, different browser
    vendors have implemented the API differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using the `getUserMedia()` method with `{audio: true}` to access your
    own microphone, *either mute the speakers or mute the HTML video element*. Otherwise,
    *it might cause feedback that can damage your speakers*.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, in Chrome, to use MediaStream API, you need to use the `navigator.getUserMedia()`
    method. Also, Chrome allows MediaStream to work only in localhost or HTTPS URLs.
  prefs: []
  type: TYPE_NORMAL
- en: '`navigator.getUserMedia()` accepts three parameters. The first one is the configuration
    object that tells the browser what the website needs access to. The other two
    are callback functions for success or failure response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple HTML file, say `chrome.html`, inside an empty directory. Inside
    the HTML file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It will create a reference to the `<video>` element in the `$video` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then checks whether `navigator.getUserMedia` is available. This is done to
    avoid errors when a browser that is not compatible with WebRTC is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, it calls the `navigator.getUserMedia()` method with the following three
    parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first parameter specifies what is needed by the website to the browser.
    In our case, both audio and video. Hence, we should pass `{audio: true, video:
    true}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is the success callback function. The received video and
    audio stream from the user is available in the `stream` object that is passed
    as the parameter to this function. It adds the `srcObject` attribute to the `<video>`
    element with the value as the `stream` object of the received video and audio
    from the user's input device. `$video.onloadedmetadata` will be called when the
    stream is loaded and it will start playing the video, since we added `$video.play()`
    to its callback function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is called when the user denies permission to the website
    to access the camera or microphone, or some other error occurs and the media stream
    cannot be retrieved. This function has an `error` object as its parameter, which
    contains the error details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, open the file with Chrome in localhost using `http-server`. First, Chrome
    will prompt you to allow access to the device''s camera and microphone. It should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you click Allow, you should see your video streamed through your front camera.
    I have set up a JS fiddle at: [https://jsfiddle.net/1odpck45/](https://jsfiddle.net/1odpck45/),
    with which you can play around with the video stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click Allow or Block, Chrome will remember this preference for the
    website. To change the website''s permission, you have to click the lock or information
    icon on the left-hand side of the address bar and it will show a menu, as follows,
    from which you can change the permissions again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00024.jpeg)Since we use http-server or the Webpack dev server
    for developments that are running on localhost, we can develop WebRTC apps in
    Chrome. However, if you want to deploy the app in production, you need to deploy
    them with an HTTPS URL. Otherwise, the application won''t work on Chrome.'
  prefs: []
  type: TYPE_NORMAL
- en: The video we created works great on Chrome, but if you try to run this code
    on a different browser, Firefox, it won't work. This is because Firefox has a
    different implementation of the MediaStream API.
  prefs: []
  type: TYPE_NORMAL
- en: In Firefox, you need to use the `navigator.mediaDevices.getUserMedia()` method
    that returns a Promise. The `stream` object can be used using a `.then().catch()`
    chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for Firefox is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can run this code in Firefox either by creating a `firefox.html` file in
    the same directory you created the `chrome.html` file or by opening the following
    JS fiddle in your Firefox browser: [https://jsfiddle.net/hc39mL5g/](https://jsfiddle.net/hc39mL5g/).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the HTTPS server for production is beyond the scope of this book.
    But, depending on the type of server you want to use, it is fairly simple to find
    the instructions on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Using Adapter.js library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the WebRTC implementation varies between browsers, it is recommended
    to use a shim, such as the `adapter.js` library ([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)),
    which insulates the code from differences in browser implementations. By including
    `adapter.js` library, you can run the WebRTC code written for Chrome in your Firefox
    browser. Try running the following JS fiddle in Firefox, which has the WebRTC
    code that works on Chrome but has `adapter.js` included: [https://jsfiddle.net/1ydwr4tt/](https://jsfiddle.net/1ydwr4tt/).'
  prefs: []
  type: TYPE_NORMAL
- en: If you are wondering about the `<video>` element, it was introduced in HTML5\.
    To know more about using the video element, visit the w3schools page: [https://www.w3schools.com/html/html5_video.asp](https://www.w3schools.com/html/html5_video.asp)
    or the MDN page: [https://developer.mozilla.org/en/docs/Web/HTML/Element/video](https://developer.mozilla.org/en/docs/Web/HTML/Element/video).
  prefs: []
  type: TYPE_NORMAL
- en: RTCPeerConnection and RTCDataChannel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the MediaStream API is used to retrieve the video and audio stream from
    the user's device, the RTCPeerConnection and RTCDataChannel APIs are used for
    establishing a peer-to-peer connection and transferring data between them. In
    our Video Call app, we are going to use the SimpleWebRTC framework, which will
    abstract these APIs and provide us with a simpler object to establish a connection
    with other devices. Hence, we are not going to look into these two APIs.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one important thing to know while working with WebRTC. Even
    though WebRTC was created to make devices connect with each other directly without
    any servers, it is currently impossible to achieve this, because to connect with
    a device, you need to know where the device is located on the internet, that is,
    the device's IP address on the internet. But, generally, devices will only know
    their local IP address (192.168.1.x type). The public IP address is managed by
    firewall or router. To overcome this issue and send the exact IP address to the
    other device, we need signalling servers, such as **STUN** or **TURN**.
  prefs: []
  type: TYPE_NORMAL
- en: The device will send the request to the STUN server to retrieve its public IP
    Address and send that information to the other devices. This is widely used and
    is applicable for most scenarios. But if the router or the firewall's NAT service
    assigns a different port number to each of the device's connection's or the device's
    local address keeps changing, the data received from the STUN server might not
    be enough, hence, the TURN server must be used. A TURN server acts as a relay
    between the two devices, that is, the device sends data to the TURN server, which
    will relay the data to the other devices. However, the TURN server is not as efficient
    as the STUN server, since it consumes a lot of server-side resources.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, an **ICE **implementation is used, which determines whether a STUN
    or TURN server is needed between two devices (it will mostly go with STUN while
    using TURN as the last resort), hence, keeping the connectivity more efficient
    and stable.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time communication with WebRTC is quite a large topic to be covered in
    a chapter, but if you are interested in learning more about WebRTC, you can go
    to WebRTC's official website [https://webrtc.org/](https://webrtc.org/) to look
    into some of the various resources available to get started with WebRTC.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Video Call application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The app we are going to build in this chapter is a simple video conferencing
    app with which you create a room and then share the room URL to others. Whoever
    clicks on the URL will be able to join the call. For the UI part, we can arrange
    the video of participants in small boxes and, when you click on a participant,
    we can enlarge the video. This type of Video Call app is widely used nowadays.
    Here''s how the app will look on a desktop browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The blue box will display your video, while the other boxes are supposed to
    display the videos of the other participants. The row will automatically wrap
    to a new row when the number of participants increases (flex-wrap). In mobile
    devices, we can show the videos in columns instead of rows, since it will be more
    effective for smaller screens. So, for mobiles, the application should look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The boxes are just placeholders. For real videos, we can use margin/padding
    to give spacing between each video. Also, for sharing the link, we can use a click
    to Copy button, which will be really user-friendly. Now that you have a good understanding
    of what we are going to build, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Initial project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial setup isn't much different from what we did in the previous Event
    Registration app. Open up the starter files from `Chapter04` folder in VSCode
    and create a `.env` file. From the `.env.example` file, you should know that,
    for this application, we only need a single environment variable, `NODE_ENV`,
    whose value will be `production` only for the production environment. For development,
    we can simply assign it some other value, such as `dev`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your `.env` file, open the terminal in VSCode or your
    native terminal (navigate to project root folder) and run `npm install` to install
    all the dependencies for the project. After that, run `npm run webpack` in the
    terminal, which should start the Webpack dev server.
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles to the page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know how to work with the Webpack dev server. So, let's move on to adding
    styles to our page. First, go through the `index.html` file to understand the
    basic structure of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the page is divided into two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Navbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The container is further divided into three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: First, `create-room-area`, which contains the input fields needed to create
    a new room with a room name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, `info-area`, which contains the information regarding the room (room
    name and room URL). It also has two buttons that are going to be used to copy
    the room URL (currently hidden using the `.hidden` Bootstrap style class).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `video-area`, which is used to display the videos of all the participants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, add the following code in `src/css/styles.css` file to prevent the container
    section from overlapping with the navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With Webpack hot reloading enabled, you should see the CSS changes instantly.
    The `create-room-area` looks just fine with the default Bootstrap styles. So,
    let''s move on to the second section, info-area. To work on `info-area`, temporarily
    remove the `.hidden` class from the HTML. Also, remove `.hidden` from the two
    buttons and add some text in the paragraph element, which will contain the room
    URL. It''d be great if the room URL and the buttons are aligned in a single row.
    To align them, add the following CSS in the `styles.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For `video-area`, the videos need to be arranged in a column for mobile devices,
    while they should be arranged in a row for desktops. Hence, we can use a media
    query to assign different styles to it. Also, for the size of the video element
    (`.video-player`), we can set `max-width` and `max-height` to 25 viewport width
    so that its dimensions will be responsive for all devices. In your `styles.css`
    file, add the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's all for the styles needed right now. So, let's start writing the JavaScript
    for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Video Call app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything''s in place, so let''s start coding. As usual, as we did in the
    previous apps, open your `home.js` file and create your `Home` class with a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, create an instance of the `Home` class and assign it to an object, `home`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to have a use for the home object later. We now add the `SimpleWebRTC`
    package to our project by running the following command in the terminal from our
    project root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the following import statement to the top of your `home.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the `SimpleWebRTC` documentation, we need to create an instance of the
    `SimpleWebRTC` class with some configuration to use it in our application. In
    your `home.js` file, before the `Home` class, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Your application should now ask for permissions to access camera and microphone.
    This is because, behind the scenes, `SimpleWebRTC` has started working on setting
    up everything needed to initiate a video call. If you click Allow, you should
    see your video appear in a small rectangular box. This is what the configurations
    in the object you added in the previous code do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localVideoEl`: Contains the ID of the element that should contain your local
    video. Here, the `video#localVideo` element from our `index.html` file is going
    to display our own video, hence, it is chosen as its value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remoteVideosEl`: Contains the ID of the container in which the remote videos
    need to be added. We haven''t created that element yet and it''s better to add
    videos later, so just leave it as an empty string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoRequestMedia`: Used to prompt the user to give permission to access the
    camera and microphone and needs to be set to `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`: If true, it will print all the `webrtc` events in the console. I have
    set it to `false`, but set it to true on your system to see the events happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, `SimpleWebRTC` uses the free STUN server provided by Google, which
    is `stun.l.google.com:19302`. This STUN server is enough in most cases, unless
    you are behind some corporate firewall with complex routing protocols. Otherwise,
    you can set up your own ICE configuration with both STUN and TURN servers. For
    that, you need to install signalmaster ([https://github.com/andyet/signalmaster](https://github.com/andyet/signalmaster))
    and add the ICE configuration details to the earlier mentioned constructor. However,
    that is beyond the scope of this book. We'll simply carry on with the default
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first step, we''ll create the class variables and references to the
    DOM elements inside our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That's a lot, but they are all needed for different steps of our application.
    The only variable we created here is `roomName`, which as the name suggests, contains
    the room's name. The others are all references to DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step of this app is to create a room so that other members can join
    a call in the room. As per the current UI design, we need to create the room when
    the user clicks the Create Room button. So, let's register a click event handler
    on that button.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have been using different methods to handle events:'
  prefs: []
  type: TYPE_NORMAL
- en: In our ToDo list app, we added the `onclick` attribute to the HTML to call JavaScript
    functions `onclick` event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Meme Creator, we attached event listeners to each element, where we wanted
    to listen for a specific event to happen (keyup, change, and click events). The
    same goes for the Event Registration form, where we added an event listener to
    listen for the form submit action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is also another method in which you add a callback function to the event
    property of the reference to the DOM element. In our case, we need to detect a
    click event on the Create Room button. We can handle it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, whenever the Create Room button is clicked, it will execute the code written
    inside the preceding function. It is entirely up to you and your requirements
    to decide which event handler to use. Usually, the first method is avoided because
    it will expose your JavaScript code inside HTML and it's difficult to keep track
    of all the JavaScript functions called inside HTML in large projects.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a large number of elements, say about 100 rows in a table, attaching
    100 event listeners to each row is inefficient. You can either use the third method
    by attaching a function to the `onclick` method of the reference of each row's
    DOM element or you can attach a single event listener to the row's parent element
    and use that event listener to listen to the events of its children elements.
  prefs: []
  type: TYPE_NORMAL
- en: For a list of all the DOM events, visit the W3Schools page: [https://www.w3schools.com/jsref/dom_obj_event.asp](https://www.w3schools.com/jsref/dom_obj_event.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, we need to handle a lot of click events. So, let''s create
    a method inside the `Home` class to register all the click events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And call this method inside the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `registerClicks()` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are few things that need to happen when the user clicks the Create Room
    button. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the room name. But the room name cannot contain any special characters that
    cause problems with the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a room using `SimpleWebRTC`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect the user to a URL created for the room (a URL with the room name as
    query string)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the URL that he/she can share with others who need to participate in the
    call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should write the following code inside the `onclick` method you created
    in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will get the room name that is typed in the input field and convert it
    into URL-friendly characters using regular expressions. If the room name is not
    empty, we can proceed to the creation of the room in `SimpleWebRTC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `if` condition will check whether the room name is not empty (an empty string
    is falsy).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webrtc.createRoom()` will create the room. It accepts two parameters: the
    first one is the room name string and the second one is a callback function that
    executes when the room is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback function has the parameters `err` and `name`. Usually, we should
    check whether the process is a success. So, `if(!err) {}` will contain the code
    to execute when the process is a success. `name` is the room name created by `SimpleWebRTC`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `if(!err)` condition, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `location` object contains information regarding the current URL. `location.pathname`
    is used to set or get the current URL of the web page. So, we can construct a
    URL by appending the room name to it. So, if your current URL is `http://localhost:8080/` then,
    after creating the room, your URL should become `http://localhost:8080/?roomName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the URL without affecting the current page, we can use the `history`
    object provided by the History Web API. The `history` object is used to manipulate
    the browser''s history. If you want to perform the back action that happens when
    the user clicks the browser''s back button, you can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, for going forward, you can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: But what we need in our application is to change the current URL without affecting
    the browser history. That is, we need to change the URL from `http://localhost:8080/`
    to `http://localhost:8080/?roomName` without affecting the back or forward buttons
    of your browser.
  prefs: []
  type: TYPE_NORMAL
- en: For such complex actions, you can use the `pushState()` and `replaceState()`
    methods introduced in HTML5 for the history object. `pushState()` creates a new
    history entry on the browser and changes the URL of the page without affecting
    the current page. `replaceState()` does the same, but instead of creating a new
    history entry, it replaces the current entry, making it ideal for our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `pushState()` and `replaceState()` methods accept three parameters.
    The first one is `state` (a JSON object), the second one is `title` (string),
    and the third one is the new URL. This is how both `pushState()` and `replaceState()`
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time `pushState()` or `replaceState()` is called, it triggers a `popstate`
    event in the `window` object. The first parameter, state object, is used by the
    callback function of that event. We have no use for it now, so we set it to an
    empty object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, most browsers just ignore the second parameter, so we just set it
    to an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter URL is what we really need. It changes the browser URL to
    the provided URL string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the room has been created and the URL has been changed, we need to hide
    the `.create-room-area` div and display the `.info-area` div instead. That''s
    why I added the `this.roomCreated()` method. In the `Home` class, create the new
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This method will show the information section while hiding the create room section.
    Also, it will change the room name and URL using the `textContent()` method, which
    changes the text that is present in the respective DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information on location objects can be found on the w3schools page: [https://www.w3schools.com/jsref/obj_location.asp](https://www.w3schools.com/jsref/obj_location.asp).More
    information on the history object can be found on the MDN page: [https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History).
    Also, if you want to learn to manipulate the browser history, visit [https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding participants to your room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have an active room and the room URL with which you need to invite others.
    But wouldn't it be easier if you had a click to copy feature to copy the URL?
    That is actually a really nice feature to have. So, before we add participants
    to the room, let's build a click to copy feature.
  prefs: []
  type: TYPE_NORMAL
- en: Click to copy text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, this is how the info area looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the click to copy feature, if you hover the mouse over the room URL, it
    should show a Copy button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click the Copy button, it should copy the text and turn into the Copied
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this functionality, we need to add some event listeners. So, inside your
    home class, create a new method `addEventListeners()` and call it inside the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The reference to the div containing the copy buttons is stored in the `this.$buttonArea`
    variable. Whenever the mouse enters a div, it will fire a `mouseenter` event.
    When this event happens in `$buttonArea`, we need to remove the `.hidden` class
    from the copy button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside your `addEventListeners()` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The page will reload and you will have to create a room again. If you hover
    the mouse pointer over the room URL now, it should make the Copy button visible.
    We also need the button to be hidden when the pointer leaves `div`. Similar to
    `mouseenter`, `div` will fire a `mouseout` event when the pointer leaves it. So,
    once again, add the following code next to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, once again, try hovering your pointer over the room URL. Surprisingly,
    it doesn't work as expected. It should have done, but it didn't. It is because
    of the `mouseout` event, which also fires when your pointer enters the child elements
    of `$buttonArea`. It considers the child elements as `outside` the `div`. To fix
    this, we need to filter the `event` object that is passed in the callback function
    so that no action happens if the pointer moves `outside` by entering the child
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This one is tricky, but if you print the event object in the console, you will
    see that there are a lot of properties and methods containing all the details
    of the event. The `toElement` property or the `relatedTarget` property will contain
    the element to which the pointer moved to depending on the browser. So, we need
    to check whether the parent of that element is `$buttonArea`. If so, we should
    prevent any actions from happening. To do this, change the preceding code to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a short-circuit evaluation. What it does is, if the first value is
    truthy, it will assign it to the constant `e`. If it is falsy, the OR operator
    will evaluate the second one and assign its value to `e`. You can have any number
    of values declared like this. Say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the value of fun will be the first truthy statement on the list, hence,
    its value will be true. `'test'` is also a truthy value but it won't get evaluated,
    since there is a truthy value before it. This type of assignment is commonly used
    and is handy for certain tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the `e` object contains the target element. So, we just need to check whether
    `e` exists (to prevent exceptions) and, if so, whether its parent element or the
    element itself is `$buttonArea`. If it is true, we simply return. This way, the
    callback function stops executing without hiding the copy and copied buttons.
    We hide the copied button too because we are going to make it visible when the
    user clicks the Copy button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try hovering over the room URL again in your application and it should work
    as expected. The last step is to copy the URL when the user clicks on the copy
    button. So, let''s register a click in the `registerClicks()` method we created
    earlier in our `Home` class. Inside the `registerClicks()` method, add the code
    to handle the clicks on the Copy and Copied buttons and create a new method `copyUrl()`
    inside the `Home` class to do the copy action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, inside the `registerClicks()` method, clicking on both
    the Copy button and the Copied button will call the `copyUrl()` method of the
    class. We need to add the code to copy text inside the `copyUrl()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy text, first, we need to get a range of nodes (the DOM elements) from
    which we need to copy text. To do so, create a range object and select the `this.$roomUrl`
    node, which contains the text of the room URL. Inside the `copyUrl()` method,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the range object contains the element `$roomUrl` as the selected node.
    Then, we need to select the text in the node just as a user usually selects text
    with his/her cursor. The `window` object has the `getSelection()` method, which
    we can use for this purpose. We must remove all the ranges to clear the previous
    selections and then select a new range (which is the range object we created previously).
    Add the following code to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we don''t know whether the user''s browser supports executing the
    copy command, so we do the copying inside a `try{} catch(err){}` statement so
    that, if any error occurs, it can be handled in the catch statement. The `document.execCommand(''copy'')`
    method will copy the text in the selected range and return it as a string. Also,
    we need to hide the copy button and display the copied button when, as copy is
    successful. The code to do copying is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the preceding code, create a room in the application and try clicking
    Copy again. It should turn into the Copied button and the room URL text will be
    highlighted, because we selected the text just like how we select it, using the
    cursor with JavaScript. But it would be nice to clear the selection once copying
    is done. So, add this line at the end of the `copyUrl()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will clear the selection, so next time you click copy, the room URL text
    will not be highlighted. You can then simply paste the selected URL wherever you
    like to share it with others.
  prefs: []
  type: TYPE_NORMAL
- en: Joining a room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a link, we need to make a user join the room using that link.
    The process is simple: when the user opens the link, he joins the room and video
    of all the participants is displayed to him. To make a user join a room, `SimpleWebRTC`
    has the `joinRoom(''roomName'')` method, where the room name string is passed
    as a parameter. Once a user is in a room, it will look for the videos of other
    users connected in the room and will fire a `videoAdded` event for each video
    it finds, along with a callback function, which has the video object and the peer
    object of that user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s strategize on how the process should work:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to check whether the URL the user entered contains the room name
    in its query string. That is, if it ends with `'?roomName'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the room name exists, then we should make the user join the room while hiding
    the `.create-room-area` div and displaying the `.info-area` div with the room
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we need to listen for the `videoAdded` events and, if an event is triggered,
    we add the video to `.video-area div`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleWebRTC` fires a `readyToCall` event when it has finished loading. It
    also has the `on()` method to listen for the events fired. We can use the `readyToCall`
    event to check for the room name in the URL. This code should be outside the `Home`
    class. So, after the line where you called the `Home` class constructor, add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are using the location object to get the URL. First, we need to check whether
    the URL contains the query string using `location.search`. So, we used it in an
    if condition and, if it contains the query string, we can continue the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split()` method splits the string into an array of substrings divided
    by the value passed to it as the parameter. The URL will be something like as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`location.search` will return the query string part of the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, `location.search.split(''?'')` will convert the string into an array as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the room name at the index 1 of the array. Writing like this works,
    but here we can use a short-circuit evaluation. We used an evaluation with the
    OR operator before, where it will take the first truthy value. In this case, we
    can use the AND operator that takes the first falsy value, or the last truthy
    value if there are no falsy values. The preceding code will be simplified into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If the URL does not contain the query string, `location.search` will be an empty
    string (`""`), which is a falsy value. Hence, the value of room will be an empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: If the URL does contain the query string with the room name, then `location.search`
    will return `'?roomName'`, which is a truthy value, so the next statement `location.search.split('?')[1]`
    gets evaluated, which does the split and returns the first index in the array
    (room name). Since it is the last truthy value, the room constant will now contain
    the room name string! We just simplified three lines of code into a single line
    using short-circuit evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Detailed information on short-circuit evaluation can be found at: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation).
  prefs: []
  type: TYPE_NORMAL
- en: Setters and getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just need to add one more line to make the user join the room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will add the user to the room, however, once the user is inside the room,
    we need to hide the `.create-room-area` div and display the `.info-area` div.
    These are available in the `roomCreated()` method of the `Home` class. But that
    method depends on the `this.roomName` class variable, which should contain the
    room name. So, we need to update a class variable and call the `class` method
    from outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we can do it by using the `home` object we created earlier, it would
    make more sense if we could just update the class's room property and it will
    perform the actions automatically. For that, we can use setters. Setters are special
    methods that are used for assigning a new value to the object's property. We have
    used getters and setters several times before. Remember how we get the value of
    the input field?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the value property is a getter. It returns a value from the `$roomNameInput`
    object. However, if we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Then, it will change the value of the input field to `'New Room Name'`. This
    is because the value now acts as a setter and updates a property inside the `$roomNameInput`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a setter for our `Home` class to join a room. Creating a setter
    is simple; we simply create a method prefixed with the `set` keyword and the method
    should have *exactly one parameter*. Inside your `Home` class, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the setter (only if the room is not an empty string) in your `readyToCall`
    event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Once you have added the code, create a room in your Video Call app and then
    copy the URL and paste it in a new tab. It should automatically get the room name
    from the URL and join the room. If you can see the room information, then you
    are good to go. We are nearing the final stage of the application--adding and
    removing videos.
  prefs: []
  type: TYPE_NORMAL
- en: If and else conditions do not require `{}` curly braces if there is only one
    statement after them. That is, `if (true) console.log('true'); else console.log('false');`
    will work just fine! But it should be avoided, since it is always better to use `if
    else` conditions with `{}` curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a getter, you simply prefix the method with `get` instead of `set`,
    but the method should contain *no parameters*and it should *return a value*. Say,
    in your `Home` class, you need to know the room name using getter. Then, you can
    add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If you try `console.log(home.room)` outside the class, you should get the value
    stored in the `roomName` class variable.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing videos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `readyToCall` event, `SimpleWebRTC` will fire a `videoAdded`
    event for every video it finds in the room with a callback function having the
    video object and the peer object containing the ID (the unique ID of that user).
  prefs: []
  type: TYPE_NORMAL
- en: To test multiple videos, we are going to open two tabs on the same browser in
    the same system. This might cause feedback to damage your audio devices, so keep
    your volume muted!
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method inside the `Home` class `addRemoteVideo($video, peer)`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add another event handler for the `videoAdded` event, just as we did
    for the `readToCall` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever a video gets added, it will call the `addRemoteVideo` method of the
    `Home` class with the video object and the peer object. We have a div `.video-area`,
    which is supposed to contain all the videos. So, we need to construct a new div
    element similar to the one used for the local video, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And we should append this element to the `.video-area` div, which is currently
    referenced by `this.$remotes` variable. This is quite simple, just as we added
    the `script` element in the previous chapter. Inside your `addRemoteVideo()` method,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a `div` element using the `document.createElement('div')` method
    and assign it to the `$container` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we set the class name of `$container` to `'video-container'` and ID to
    `'container_peerid'`. We can get the peer ID from the peer object we received
    using the `webrtc.getDomId()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$video` object we received is an HTML element just like `$container`. So,
    we assign it the class name `'video-player'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, for the last step, we append `$video` as a child inside `$container` and,
    finally, append `$container` as a child inside `this.$remotes`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will construct the HTMLs we need with the classes and IDs. When a user
    leaves the room, the `videoRemoved` event will be fired, which is similar to the
    `videoAdded` event. Whenever the user leaves the room, we need to use the peer
    ID to remove the div containing the ID `''container_peerid''`, where `peerid`
    is the ID of the user who left. To do so, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `removeRemoteVideo()` method will find the div containing the remote video
    using the peer ID and will remove it from this `this.$remotes` object using the
    `removeChild()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Time to test our Video Call app. Open the application in Chrome and create the
    room. Copy the room URL and paste it in a new tab (keep your volume muted!). It
    might take a few seconds, but unless STUN didn't work for you, you should see
    two videos in each of the tabs. You are streaming video between the tabs.
  prefs: []
  type: TYPE_NORMAL
- en: The first video is your video. If you close one of the tabs, you should see
    that the second video will be removed from the other tab. Before we test this
    app in other devices, there is one more feature that would really look great in
    this app. That is increasing the size of the selected video.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, all the videos are small in size. Hence, we need a feature to enlarge
    the videos, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: In desktops, clicking on a video will increase the size of the video and bring
    it to the first spot among the list of videos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In mobiles, tapping a video will only increase the size of the video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This sounds fine. To make this happen, let''s add some styles to our `styles.css`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added two sets of styles using media queries. One for mobile (`max-width:
    736px`) and another for desktops (`min-width: 736px`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For every click made in a video, we should add the `.video-selected` class
    to that video and `.container-selected` to the parent div of that video:'
  prefs: []
  type: TYPE_NORMAL
- en: In mobiles, it will increase the size of the video up to 70% of the viewport
    width.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In desktops, it will increase the size up to 50% of the viewport width and
    also assign `order: -1` to its parent div. This way, since the parent div is part
    of flex, it will become the first item of the flex elements (but other elements
    should not contain order in their styles).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your `Home` class, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This will find the video containing the `.video-selected` class and remove the
    `.video-selected` class from that video and the `.container-selected` class from
    that video's parent div. This is useful because we can call it to clear the selected
    ones before we select another video.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can register a click event on the local video inside the `registerClicks()`
    method. Inside the `registerClicks()` method, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will add the required classes to the video element and its parent div.
    For remote videos, we cannot register clicks here because we create those elements
    dynamically. So, we either have to create an event listener or register a click
    event when the remote video elements are created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event listener for each video is not quite efficient here because
    the videos will be removed when the user leaves, so we will have unwanted event
    listeners running for each video. We will have to remove those event listeners
    using the `removeEventListener()` method or avoid this by creating an event listener
    to the parent div `.video-area` instead of the video elements. Still, this means
    that we need to filter through each of the clicks made inside `.video-area` div
    to check whether that click was made on a video.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, it''s simpler to register a click using the `onclick()` method when
    the video element is created. This saves us the trouble of dealing with event
    listeners. Inside your `addRemoteVideo()` method, add this code after the existing
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Now try clicking on a video in Chrome. You should see that the video will increase
    its size and move to the first position on the list. Congratulations! You have
    successfully built your Video Call application! Time to test Video Call in action.
  prefs: []
  type: TYPE_NORMAL
- en: Video Call in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You got the application ready, so let's test it locally. First, generate the
    production build for your app. You have already done this before in the Event
    Registration app. You need to set `NODE_ENV=production` in your `.env` file.
  prefs: []
  type: TYPE_NORMAL
- en: After that, in your project root folder, kill Webpack dev server and run the
    `npm run webpack` command. It should generate the production builds for your JS
    and CSS files. The filename will be available in the `dist/manifest.json` file.
    Include those CSS and JS files in your `index.html` page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run `http-server` in your project root folder. It should print two IP address.
    Open the one starting with 192 in your browser. This IP address is accessible
    to all the devices in your LAN, unless you have blocked the port using a firewall.
    However, Chrome will not display your video! This is because the `getUserMedia()`
    method will only work in localhost and HTTPS URLs. Since our local address is
    using HTTP only, the video will not work.
  prefs: []
  type: TYPE_NORMAL
- en: We can add HTTPS by deploying our WebRTC application on a public server with
    an SSL certificate from a certificate authority. However, for our local development
    environment, we can use a self-signed certificate. An SSL certificate from a certificate
    authority will be trusted by all browsers, but a self-signed certificate will
    not be trusted, hence, a warning will be shown, in which we should manually select
    the option to trust the website on our browser. For this reason, self-signed certificates
    are not suitable for production and should only be used for development purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a self-signed certificate is a big process but, luckily, there is
    an `npm` package that can do this in a single line. We need to install this package
    globally, since it is a command-line tool like `http-server`. In your terminal,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux users might have to add `sudo` to their command to install packages globally.
    By default, `http-server` will serve your files from port number `8080`. Say,
    if your current URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open another terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, source is the new port number and target is the port number in which
    http-server is running. You should then open the same IP address with the new
    port number and `https://` prefix in Chrome, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open this page in Chrome, you should receive a warning similar to the
    following screenshot. In that case, select Advanced as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click Advanced, you will see a page similar to the following image
    where you should click proceed link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can now use this HTTPS URL to open the app in any device that is connected
    to your LAN. Make sure there is enough distance between the devices so that it
    doesn't cause feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you had a great time building the Video Call application. In this
    chapter, we did some new things with JavaScript and learned some new concepts,
    such as JavaScript WebRTC APIs and the SimpleWebRTC framework. Along the way,
    we did lot of cool things, such as manipulating browser history, selecting text
    using JavaScript, and working with URLs. Also, we shortened some of our code with short-circuit
    evaluation and learned about setters and getters for manipulating class variables
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleWebRTC` comes with many other events and actions which allow you to
    do more in the app, such as mute your microphone, mute audio from others, and
    so on. If you are interested, you can check out the SimpleWebRTC home page for
    more examples.'
  prefs: []
  type: TYPE_NORMAL
- en: We know how to create reusable JavaScript modules, which we did in the previous
    chapter. In the next chapter, we are going to take it a step further and build
    our own reusable HTML elements using web components.
  prefs: []
  type: TYPE_NORMAL
