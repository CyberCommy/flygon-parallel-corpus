- en: '`# Real-Time Video Call App with WebRTC'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: Hey! Just to let you know, the JS Meetup was a great success after getting a
    backend developer to complete the serverside of the application. But you did great
    completing the entire frontend of the application. You created a complete Event
    Registration website, which lets users sign up the events, while learning some
    really important concepts, such as building reusable ES6 modules, making AJAX
    requests while handling asynchronous code using Promises, creating beautiful charts
    out of data, and of course, the classic form validation with a validation service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The backend code was also written with JavaScript (Node.js), so you might really
    be interested in writing serverside code. But sadly, as I mentioned earlier, Node.js
    is beyond the scope of this book. Actually, you can do some really cool things
    with plain JavaScript, although many people think, "*It needs a lot of server-side
    code!*" Since you will have already read the chapter title - yup! We are going
    to build a real Video Call app in this chapter with *almost zero* server-side
    code. The best part is, just like our other applications, this one is also going
    to be responsive and will work with most mobile browsers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the list of concepts we are about to learn in this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to WebRTC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebRTC APIs in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a SimpleWebRTC framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Video Call app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from these main concepts, there is a lot more to learn in this chapter.
    So, before we start, make sure you have the following hardware:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: A PC or laptop with webcam and microphone (you might want to use another computer
    to experience a video call in action)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Android or iPhone device (optional)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A LAN connection so that all your devices are on the same local network to test
    the application in development (can be either Wi-Fi or wired Ethernet)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the dependencies used in this project requires you to have Python 2.7.x
    installed in your system. Linux and Mac users have Python pre-installed. Windows
    users can download Python 2.7.x version from [https://www.python.org/downloads/](https://www.python.org/downloads/)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to WebRTC
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start building the application, it's best to know a few things about
    WebRTC so that you get a good idea about the workings of the app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: History of WebRTC
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-time communication capabilities have become a common feature of many of
    the applications we use nowadays. Say you want to chat with your friend or watch
    a live soccer game. Real-time communication is a must for these applications.
    However, having live video calls on a browser in the past was quite a difficult
    task for users, because they had to install plugins into their system for different
    applications to use video calling on the web browser, and with plugins came vulnerabilities,
    hence, regular updates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this problem, Google released an open source project in May 2011
    for browser-based real-time communication standards, called WebRTC. The concept
    of WebRTC is simple. It defines a set of standards that should be used across
    all applications so that applications can communicate directly with each other
    (peer-to-peer communication). By implementing WebRTC, there will not be any need
    for plugins anymore, since the communication platform is standardized.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Currently, WebRTC is being standardized by the **World Wide Web Consortium**
    (**W3C**) and the **Internet Engineering Task Force** (**IETF**). WebRTC is actively
    being implemented by most browser vendors and it will also work with native Android
    and iOS applications. If you want to know whether your browser is ready to support
    WebRTC, you can visit: [http://iswebrtcreadyyet.com/](http://iswebrtcreadyyet.com/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, the browser support status is:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00022.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Even though most commonly used browsers support WebRTC, except Safari, there
    are still a lot of issues and bugs with the implementation, hence, it is recommended
    to use a shim such as `adapter.js` ([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter))
    so that the application will not suffer any problems during changes to spec or
    vendor prefixes. We'll see more about this when we look into the JavaScript APIs
    for WebRTC.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数常用的浏览器都支持WebRTC，除了Safari，但实现中仍然存在许多问题和错误，因此建议使用适配器（如`adapter.js`）（[https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)），以便应用程序在规范或供应商前缀发生变化时不会遇到任何问题。当我们研究WebRTC的JavaScript
    API时，我们将更多地了解这一点。
- en: WebRTC is also supported in the mobile versions of Chrome and Firefox; hence,
    you can use video calls even in mobile browsers with no plugins.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC也支持Chrome和Firefox的移动版本；因此，即使在没有插件的移动浏览器中，你也可以进行视频通话。
- en: For iPhone users Neither Safari mobile browser or Chrome support WebRTC on the
    iPhone yet. So, you either have to install Firefox or the Bowser app from the
    app store. Link for Bowser: [https://itunes.apple.com/app/bowser/id560478358?mt=8](https://itunes.apple.com/app/bowser/id560478358?mt=8).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iPhone用户，iPhone上的Safari移动浏览器或Chrome尚不支持WebRTC。因此，你必须安装Firefox或来自应用商店的Bowser应用。Bowser的链接：[https://itunes.apple.com/app/bowser/id560478358?mt=8](https://itunes.apple.com/app/bowser/id560478358?mt=8)。
- en: JavaScript WebAPIs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript WebAPIs
- en: 'So far, we have used a few WebAPIs such as `FileReader`, document (used in
    the `document.querySelector()` methods), `HTMLImageElement` (the `new Image()`
    constructor we used in Meme Creator), and so on. They are not part of the JavaScript
    language, but they are part of the WebAPIs. When running JavaScript in browsers,
    it will be provided with a `window` object that contains all the methods of the
    WebAPIs. The scope of the `window` object is global and the properties and methods
    of the `window` object are also global. This means, if you want to use navigator
    WebAPI, you can either do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了一些WebAPIs，比如`FileReader`，文档（在`document.querySelector()`方法中使用），`HTMLImageElement`（我们在Meme
    Creator中使用的`new Image()`构造函数），等等。它们不是JavaScript语言的一部分，但它们是WebAPIs的一部分。在浏览器中运行JavaScript时，将提供一个包含所有WebAPIs方法的`window`对象。`window`对象的范围是全局的，`window`对象的属性和方法也是全局的。这意味着，如果你想使用navigator
    WebAPI，你可以这样做：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, you can simply do as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以简单地这样做：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both will work just fine and implement the same methods. However, do note that
    WebAPI (`window` object) is available for JavaScript only when you run JavaScript
    on a browser. If you are using JavaScript on other platforms, such as Node.js
    or React Native, you will not have WebAPIs for use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都可以正常工作并实现相同的方法。但是请注意，WebAPI（`window`对象）仅在浏览器中运行JavaScript时才可用。如果你在其他平台上使用JavaScript，比如Node.js或React
    Native，你将无法使用WebAPIs。
- en: WebAPIs are growing more powerful nowadays and provide JavaScript with the ability
    to do more functions, such as recording video and audio directly from the browser.
    Progressive web applications are one such example, powered by the `ServiceWorker`
    WebAPI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在WebAPIs变得越来越强大，为JavaScript提供了更多的功能，比如直接从浏览器录制视频和音频。渐进式Web应用程序就是这样的一个例子，由`ServiceWorker`
    WebAPI提供支持。
- en: We are going to use a lot of WebAPIs in this chapter and the upcoming chapters.
    For a full list of the WebAPIs available for JavaScript, visit the following MDN
    page: [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和接下来的章节中，我们将使用大量的WebAPIs。有关JavaScript可用的WebAPIs的完整列表，请访问以下MDN页面：[https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API)。
- en: JavaScript WebRTC API
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript WebRTC API
- en: 'Since browsers support WebRTC natively, JavaScript WebAPIs have been created
    by browser vendors so that developers can easily build applications. Currently,
    WebRTC implements the following three APIs that are used by JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器原生支持WebRTC，因此浏览器供应商创建了JavaScript WebAPIs，以便开发人员可以轻松构建应用程序。目前，WebRTC实现了以下三个JavaScript使用的API：
- en: MediaStream
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MediaStream
- en: RTCPeerConnection
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTCPeerConnection
- en: RTCDataChannel
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTCDataChannel
- en: MediaStream
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MediaStream
- en: MediaStream API is used for getting access to the video and audio devices of
    the user. Generally, browsers will prompt the user as to whether he/she wants
    to allow the website to access the camera and microphone of his/her device. Even
    though the underlying concept for MediaStream API is the same, different browser
    vendors have implemented the API differently.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: MediaStream API用于获取用户的视频和音频设备的访问权限。通常，浏览器会提示用户是否允许网站访问他/她设备的摄像头和麦克风。尽管MediaStream
    API的基本概念是相同的，但不同的浏览器供应商对API的实现方式有所不同。
- en: 'While using the `getUserMedia()` method with `{audio: true}` to access your
    own microphone, *either mute the speakers or mute the HTML video element*. Otherwise,
    *it might cause feedback that can damage your speakers*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用`getUserMedia()`方法时，使用`{audio: true}`来访问你自己的麦克风时，*要么将扬声器静音，要么将HTML视频元素静音*。否则，*可能会导致反馈，损坏你的扬声器*。'
- en: For example, in Chrome, to use MediaStream API, you need to use the `navigator.getUserMedia()`
    method. Also, Chrome allows MediaStream to work only in localhost or HTTPS URLs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Chrome中，要使用MediaStream API，你需要使用`navigator.getUserMedia()`方法。此外，Chrome只允许MediaStream在localhost或HTTPS
    URL中工作。
- en: '`navigator.getUserMedia()` accepts three parameters. The first one is the configuration
    object that tells the browser what the website needs access to. The other two
    are callback functions for success or failure response.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigator.getUserMedia()`接受三个参数。第一个是配置对象，告诉浏览器网站需要访问什么。另外两个是成功或失败响应的回调函数。'
- en: 'Create a simple HTML file, say `chrome.html`, inside an empty directory. Inside
    the HTML file, add the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的HTML文件，比如`chrome.html`，放在一个空目录中。在HTML文件中，添加以下代码：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code does the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了以下几件事：
- en: It will create a reference to the `<video>` element in the `$video` object.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将在`$video`对象中创建对`<video>`元素的引用。
- en: It then checks whether `navigator.getUserMedia` is available. This is done to
    avoid errors when a browser that is not compatible with WebRTC is used.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它检查`navigator.getUserMedia`是否可用。这样做是为了避免在使用不兼容WebRTC的浏览器时出现错误。
- en: 'Then, it calls the `navigator.getUserMedia()` method with the following three
    parameters:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它使用以下三个参数调用`navigator.getUserMedia()`方法：
- en: 'The first parameter specifies what is needed by the website to the browser.
    In our case, both audio and video. Hence, we should pass `{audio: true, video:
    true}`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一个参数指定网站对浏览器的需求。在我们的例子中，需要音频和视频。因此，我们应该传递`{audio: true, video: true}`。'
- en: The second parameter is the success callback function. The received video and
    audio stream from the user is available in the `stream` object that is passed
    as the parameter to this function. It adds the `srcObject` attribute to the `<video>`
    element with the value as the `stream` object of the received video and audio
    from the user's input device. `$video.onloadedmetadata` will be called when the
    stream is loaded and it will start playing the video, since we added `$video.play()`
    to its callback function.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是成功的回调函数。用户接收的视频和音频流在传递给此函数的`stream`对象中可用。它将`srcObject`属性添加到`<video>`元素，其值为从用户输入设备接收的视频和音频的`stream`对象。当流加载时，将调用`$video.onloadedmetadata`，并且它将开始播放视频，因为我们在其回调函数中添加了`$video.play()`。
- en: The third parameter is called when the user denies permission to the website
    to access the camera or microphone, or some other error occurs and the media stream
    cannot be retrieved. This function has an `error` object as its parameter, which
    contains the error details.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是当用户拒绝网站访问摄像头或麦克风，或者发生其他错误且无法检索媒体流时调用的函数。此函数的参数是一个`error`对象，其中包含错误详细信息。
- en: 'Now, open the file with Chrome in localhost using `http-server`. First, Chrome
    will prompt you to allow access to the device''s camera and microphone. It should
    look as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`http-server`在本地主机中的Chrome中打开文件。首先，Chrome将提示您允许访问设备的摄像头和麦克风。它应该如下所示：
- en: '![](../images/00023.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: If you click Allow, you should see your video streamed through your front camera.
    I have set up a JS fiddle at: [https://jsfiddle.net/1odpck45/](https://jsfiddle.net/1odpck45/),
    with which you can play around with the video stream.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击允许，您应该看到通过前置摄像头传输的视频。我已经在以下网址设置了一个JS fiddle：[https://jsfiddle.net/1odpck45/](https://jsfiddle.net/1odpck45/)，您可以在其中玩弄视频流。
- en: 'Once you click Allow or Block, Chrome will remember this preference for the
    website. To change the website''s permission, you have to click the lock or information
    icon on the left-hand side of the address bar and it will show a menu, as follows,
    from which you can change the permissions again:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击允许或阻止，Chrome将记住网站的偏好设置。要更改网站的权限，您必须点击地址栏左侧的锁定或信息图标，它将显示一个菜单，如下所示，您可以再次更改权限：
- en: '![](../images/00024.jpeg)Since we use http-server or the Webpack dev server
    for developments that are running on localhost, we can develop WebRTC apps in
    Chrome. However, if you want to deploy the app in production, you need to deploy
    them with an HTTPS URL. Otherwise, the application won''t work on Chrome.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00024.jpeg)由于我们使用http-server或Webpack开发服务器进行开发，这些服务器在本地主机上运行，因此我们可以在Chrome中开发WebRTC应用程序。但是，如果要在生产环境中部署应用程序，则需要使用HTTPS
    URL进行部署。否则，应用程序将无法在Chrome上运行。'
- en: The video we created works great on Chrome, but if you try to run this code
    on a different browser, Firefox, it won't work. This is because Firefox has a
    different implementation of the MediaStream API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Chrome上创建的视频在Chrome上运行得很好，但是如果您尝试在不同的浏览器Firefox上运行此代码，它将无法运行。这是因为Firefox对MediaStream
    API有不同的实现。
- en: In Firefox, you need to use the `navigator.mediaDevices.getUserMedia()` method
    that returns a Promise. The `stream` object can be used using a `.then().catch()`
    chain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中，您需要使用`navigator.mediaDevices.getUserMedia()`方法，该方法返回一个Promise。可以使用`.then().catch()`链使用`stream`对象。
- en: 'The code for Firefox is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox的代码如下：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can run this code in Firefox either by creating a `firefox.html` file in
    the same directory you created the `chrome.html` file or by opening the following
    JS fiddle in your Firefox browser: [https://jsfiddle.net/hc39mL5g/](https://jsfiddle.net/hc39mL5g/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Firefox中运行此代码，方法是在与您创建`chrome.html`文件相同的目录中创建一个`firefox.html`文件，或者在您的Firefox浏览器中打开以下JS
    fiddle：[https://jsfiddle.net/hc39mL5g/](https://jsfiddle.net/hc39mL5g/)。
- en: Setting up the HTTPS server for production is beyond the scope of this book.
    But, depending on the type of server you want to use, it is fairly simple to find
    the instructions on the internet.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生产环境设置HTTPS服务器超出了本书的范围。但是，根据您想要使用的服务器类型，可以很容易地在互联网上找到说明。
- en: Using Adapter.js library
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Adapter.js库
- en: 'Since the WebRTC implementation varies between browsers, it is recommended
    to use a shim, such as the `adapter.js` library ([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)),
    which insulates the code from differences in browser implementations. By including
    `adapter.js` library, you can run the WebRTC code written for Chrome in your Firefox
    browser. Try running the following JS fiddle in Firefox, which has the WebRTC
    code that works on Chrome but has `adapter.js` included: [https://jsfiddle.net/1ydwr4tt/](https://jsfiddle.net/1ydwr4tt/).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WebRTC在不同浏览器之间的实现不同，建议使用适配器（例如`adapter.js`库([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)））来隔离代码与浏览器实现的差异。通过包含`adapter.js`库，您可以在Firefox浏览器中运行为Chrome编写的WebRTC代码。尝试在Firefox中运行以下JS
    fiddle，其中包含适用于Chrome的WebRTC代码，但包括`adapter.js`：[https://jsfiddle.net/1ydwr4tt/](https://jsfiddle.net/1ydwr4tt/)。
- en: If you are wondering about the `<video>` element, it was introduced in HTML5\.
    To know more about using the video element, visit the w3schools page: [https://www.w3schools.com/html/html5_video.asp](https://www.w3schools.com/html/html5_video.asp)
    or the MDN page: [https://developer.mozilla.org/en/docs/Web/HTML/Element/video](https://developer.mozilla.org/en/docs/Web/HTML/Element/video).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解`<video>`元素，它是在HTML5中引入的。要了解有关使用视频元素的更多信息，请访问w3schools页面：[https://www.w3schools.com/html/html5_video.asp](https://www.w3schools.com/html/html5_video.asp)或MDN页面：[https://developer.mozilla.org/en/docs/Web/HTML/Element/video](https://developer.mozilla.org/en/docs/Web/HTML/Element/video)。
- en: RTCPeerConnection and RTCDataChannel
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTCPeerConnection和RTCDataChannel
- en: While the MediaStream API is used to retrieve the video and audio stream from
    the user's device, the RTCPeerConnection and RTCDataChannel APIs are used for
    establishing a peer-to-peer connection and transferring data between them. In
    our Video Call app, we are going to use the SimpleWebRTC framework, which will
    abstract these APIs and provide us with a simpler object to establish a connection
    with other devices. Hence, we are not going to look into these two APIs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MediaStream API用于从用户设备检索视频和音频流，但RTCPeerConnection和RTCDataChannel API用于建立对等连接并在它们之间传输数据。在我们的视频通话应用程序中，我们将使用SimpleWebRTC框架，它将抽象这些API并为我们提供一个更简单的对象来与其他设备建立连接。因此，我们不打算深入研究这两个API。
- en: However, there is one important thing to know while working with WebRTC. Even
    though WebRTC was created to make devices connect with each other directly without
    any servers, it is currently impossible to achieve this, because to connect with
    a device, you need to know where the device is located on the internet, that is,
    the device's IP address on the internet. But, generally, devices will only know
    their local IP address (192.168.1.x type). The public IP address is managed by
    firewall or router. To overcome this issue and send the exact IP address to the
    other device, we need signalling servers, such as **STUN** or **TURN**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用WebRTC时有一件重要的事情要知道。尽管WebRTC是为了使设备直接连接而无需任何服务器而创建的，但目前不可能实现这一点，因为要连接到设备，您需要知道设备在互联网上的位置，即设备在互联网上的IP地址。但是，一般来说，设备只会知道它们的本地IP地址（类似于192.168.1.x）。公共IP地址由防火墙或路由器管理。为了克服这个问题并将确切的IP地址发送给其他设备，我们需要信令服务器，例如**STUN**或**TURN**。
- en: The device will send the request to the STUN server to retrieve its public IP
    Address and send that information to the other devices. This is widely used and
    is applicable for most scenarios. But if the router or the firewall's NAT service
    assigns a different port number to each of the device's connection's or the device's
    local address keeps changing, the data received from the STUN server might not
    be enough, hence, the TURN server must be used. A TURN server acts as a relay
    between the two devices, that is, the device sends data to the TURN server, which
    will relay the data to the other devices. However, the TURN server is not as efficient
    as the STUN server, since it consumes a lot of server-side resources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设备将向STUN服务器发送请求，以检索其公共IP地址，并将该信息发送给其他设备。这是广泛使用的，并适用于大多数情况。但是，如果路由器或防火墙的NAT服务为设备的每个连接分配不同的端口号，或者设备的本地地址不断变化，那么从STUN服务器接收的数据可能不足，因此必须使用TURN服务器。TURN服务器充当两个设备之间的中继，即设备将数据发送到TURN服务器，然后TURN服务器将数据中继到其他设备。但是，TURN服务器不像STUN服务器那样高效，因为它消耗了大量服务器端资源。
- en: Usually, an **ICE **implementation is used, which determines whether a STUN
    or TURN server is needed between two devices (it will mostly go with STUN while
    using TURN as the last resort), hence, keeping the connectivity more efficient
    and stable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会使用**ICE**实现，它确定两台设备之间是否需要STUN或TURN服务器（在大多数情况下会选择STUN，而使用TURN作为最后的手段），从而保持连接更有效和稳定。
- en: Real-time communication with WebRTC is quite a large topic to be covered in
    a chapter, but if you are interested in learning more about WebRTC, you can go
    to WebRTC's official website [https://webrtc.org/](https://webrtc.org/) to look
    into some of the various resources available to get started with WebRTC.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WebRTC进行实时通信是一个很大的主题，但如果您有兴趣了解更多关于WebRTC的信息，可以访问WebRTC的官方网站[https://webrtc.org/](https://webrtc.org/)，查看一些可用于开始使用WebRTC的各种资源。
- en: Building the Video Call application
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建视频通话应用程序
- en: 'The app we are going to build in this chapter is a simple video conferencing
    app with which you create a room and then share the room URL to others. Whoever
    clicks on the URL will be able to join the call. For the UI part, we can arrange
    the video of participants in small boxes and, when you click on a participant,
    we can enlarge the video. This type of Video Call app is widely used nowadays.
    Here''s how the app will look on a desktop browser:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的应用程序是一个简单的视频会议应用程序，您可以在其中创建一个房间，然后将房间URL分享给其他人。谁点击URL将能够加入通话。对于UI部分，我们可以将参与者的视频排列在小框中，当您点击参与者时，我们可以放大视频。这种类型的视频通话应用程序现在广泛使用。以下是应用程序在桌面浏览器上的外观：
- en: '![](../images/00025.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: 'The blue box will display your video, while the other boxes are supposed to
    display the videos of the other participants. The row will automatically wrap
    to a new row when the number of participants increases (flex-wrap). In mobile
    devices, we can show the videos in columns instead of rows, since it will be more
    effective for smaller screens. So, for mobiles, the application should look as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色框将显示您的视频，而其他框应显示其他参与者的视频。当参与者数量增加时，行将自动换行到新行（flex-wrap）。在移动设备上，我们可以将视频显示为列而不是行，因为对于较小的屏幕来说，这样会更有效。因此，对于手机，应用程序应如下所示：
- en: '![](../images/00026.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: The boxes are just placeholders. For real videos, we can use margin/padding
    to give spacing between each video. Also, for sharing the link, we can use a click
    to Copy button, which will be really user-friendly. Now that you have a good understanding
    of what we are going to build, let's get started!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框只是占位符。对于真实的视频，我们可以使用margin/padding在每个视频之间留出间距。此外，为了分享链接，我们可以使用一个点击复制按钮，这将非常用户友好。现在你已经很好地理解了我们要构建的内容，让我们开始吧！
- en: Initial project setup
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始项目设置
- en: The initial setup isn't much different from what we did in the previous Event
    Registration app. Open up the starter files from `Chapter04` folder in VSCode
    and create a `.env` file. From the `.env.example` file, you should know that,
    for this application, we only need a single environment variable, `NODE_ENV`,
    whose value will be `production` only for the production environment. For development,
    we can simply assign it some other value, such as `dev`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置与我们在之前的活动注册应用程序中所做的并没有太大的不同。在VSCode的`Chapter04`文件夹中打开起始文件并创建一个`.env`文件。从`.env.example`文件中，你应该知道，对于这个应用程序，我们只需要一个环境变量`NODE_ENV`，其值只在生产环境下为`production`。对于开发，我们可以简单地为其分配其他值，比如`dev`。
- en: Once you have created your `.env` file, open the terminal in VSCode or your
    native terminal (navigate to project root folder) and run `npm install` to install
    all the dependencies for the project. After that, run `npm run webpack` in the
    terminal, which should start the Webpack dev server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`.env`文件后，在VSCode的终端或本机终端（导航到项目根文件夹）中运行`npm install`来安装项目的所有依赖项。之后，在终端中运行`npm
    run webpack`，这应该会启动Webpack开发服务器。
- en: Adding styles to the page
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为页面添加样式
- en: You know how to work with the Webpack dev server. So, let's move on to adding
    styles to our page. First, go through the `index.html` file to understand the
    basic structure of the page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何使用Webpack开发服务器。所以，让我们继续添加样式到我们的页面。首先，浏览`index.html`文件，了解页面的基本结构。
- en: 'The body of the page is divided into two sections:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的主体分为两个部分：
- en: Navbar
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航栏
- en: Container
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: 'The container is further divided into three sections:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 容器进一步分为三个部分：
- en: First, `create-room-area`, which contains the input fields needed to create
    a new room with a room name.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是`create-room-area`，其中包含创建具有房间名称的新房间所需的输入字段。
- en: Second, `info-area`, which contains the information regarding the room (room
    name and room URL). It also has two buttons that are going to be used to copy
    the room URL (currently hidden using the `.hidden` Bootstrap style class).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次是`info-area`，其中包含有关房间的信息（房间名称和房间URL）。它还有两个按钮，用于复制房间URL（当前使用`.hidden` Bootstrap样式类进行隐藏）。
- en: Finally, `video-area`, which is used to display the videos of all the participants.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后是`video-area`，用于显示所有参与者的视频。
- en: 'First, add the following code in `src/css/styles.css` file to prevent the container
    section from overlapping with the navigation bar:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`src/css/styles.css`文件中添加以下代码，以防止容器部分与导航栏重叠：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With Webpack hot reloading enabled, you should see the CSS changes instantly.
    The `create-room-area` looks just fine with the default Bootstrap styles. So,
    let''s move on to the second section, info-area. To work on `info-area`, temporarily
    remove the `.hidden` class from the HTML. Also, remove `.hidden` from the two
    buttons and add some text in the paragraph element, which will contain the room
    URL. It''d be great if the room URL and the buttons are aligned in a single row.
    To align them, add the following CSS in the `styles.css` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Webpack热重载后，你应该立即看到CSS的更改。`create-room-area`使用默认的Bootstrap样式看起来很好。所以，让我们继续进行第二部分，info-area。要处理`info-area`，暂时从HTML中删除`.hidden`类。还要从两个按钮中删除`.hidden`，并在段落元素中添加一些文本，其中包含房间URL。如果房间URL和按钮在同一行对齐会很好。为了对齐它们，在`styles.css`文件中添加以下CSS：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For `video-area`, the videos need to be arranged in a column for mobile devices,
    while they should be arranged in a row for desktops. Hence, we can use a media
    query to assign different styles to it. Also, for the size of the video element
    (`.video-player`), we can set `max-width` and `max-height` to 25 viewport width
    so that its dimensions will be responsive for all devices. In your `styles.css`
    file, add the following styles:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`video-area`，视频需要在移动设备上以列的形式排列，而在桌面上应以行的形式排列。因此，我们可以使用媒体查询为其分配不同的样式。此外，对于视频元素（`.video-player`）的大小，我们可以将`max-width`和`max-height`设置为25视口宽度，以使其在所有设备上具有响应性的尺寸。在你的`styles.css`文件中，添加以下样式：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's all for the styles needed right now. So, let's start writing the JavaScript
    for the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需的样式就是这些。所以，让我们开始编写应用程序的JavaScript。
- en: Building the Video Call app
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建视频通话应用程序
- en: 'Everything''s in place, so let''s start coding. As usual, as we did in the
    previous apps, open your `home.js` file and create your `Home` class with a constructor:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪，让我们开始编码。像以前的应用程序一样，打开你的`home.js`文件并创建你的`Home`类和构造函数：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, create an instance of the `Home` class and assign it to an object, `home`,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建`Home`类的一个实例，并将其分配给一个对象`home`，如下所示：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are going to have a use for the home object later. We now add the `SimpleWebRTC`
    package to our project by running the following command in the terminal from our
    project root folder:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以后会用到home对象。现在，通过在项目根文件夹的终端中运行以下命令，将`SimpleWebRTC`包添加到我们的项目中：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And add the following import statement to the top of your `home.js` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并在你的`home.js`文件顶部添加以下导入语句：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As per the `SimpleWebRTC` documentation, we need to create an instance of the
    `SimpleWebRTC` class with some configuration to use it in our application. In
    your `home.js` file, before the `Home` class, add the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`SimpleWebRTC`文档，我们需要创建一个`SimpleWebRTC`类的实例，并进行一些配置以在我们的应用程序中使用它。在你的`home.js`文件中，在`Home`类之前，添加以下代码：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Your application should now ask for permissions to access camera and microphone.
    This is because, behind the scenes, `SimpleWebRTC` has started working on setting
    up everything needed to initiate a video call. If you click Allow, you should
    see your video appear in a small rectangular box. This is what the configurations
    in the object you added in the previous code do:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在应该请求权限来访问摄像头和麦克风。这是因为在幕后，`SimpleWebRTC`已经开始设置一切需要启动视频通话的工作。如果您点击“允许”，您应该会看到您的视频出现在一个小矩形框中。这就是您在之前的代码中添加的对象中的配置所做的事情：
- en: '`localVideoEl`: Contains the ID of the element that should contain your local
    video. Here, the `video#localVideo` element from our `index.html` file is going
    to display our own video, hence, it is chosen as its value.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localVideoEl`：包含应该包含您本地视频的元素的ID。在这里，我们的`index.html`文件中的`video#localVideo`元素将显示我们自己的视频，因此选择它作为其值。'
- en: '`remoteVideosEl`: Contains the ID of the container in which the remote videos
    need to be added. We haven''t created that element yet and it''s better to add
    videos later, so just leave it as an empty string.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remoteVideosEl`：包含需要添加远程视频的容器的ID。我们还没有创建该元素，最好稍后再添加视频，所以将其留空。'
- en: '`autoRequestMedia`: Used to prompt the user to give permission to access the
    camera and microphone and needs to be set to `true`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoRequestMedia`：用于提示用户允许访问摄像头和麦克风的权限，需要设置为`true`。'
- en: '`debug`: If true, it will print all the `webrtc` events in the console. I have
    set it to `false`, but set it to true on your system to see the events happening.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`：如果为true，它将在控制台中打印所有的`webrtc`事件。我已将其设置为`false`，但在您的系统上将其设置为true以查看事件发生。'
- en: By default, `SimpleWebRTC` uses the free STUN server provided by Google, which
    is `stun.l.google.com:19302`. This STUN server is enough in most cases, unless
    you are behind some corporate firewall with complex routing protocols. Otherwise,
    you can set up your own ICE configuration with both STUN and TURN servers. For
    that, you need to install signalmaster ([https://github.com/andyet/signalmaster](https://github.com/andyet/signalmaster))
    and add the ICE configuration details to the earlier mentioned constructor. However,
    that is beyond the scope of this book. We'll simply carry on with the default
    configuration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`SimpleWebRTC`使用由Google提供的免费STUN服务器，即`stun.l.google.com:19302`。在大多数情况下，这个STUN服务器就足够了，除非您身处一些具有复杂路由协议的企业防火墙之后。否则，您可以设置自己的ICE配置，包括STUN和TURN服务器。为此，您需要安装signalmaster（[https://github.com/andyet/signalmaster](https://github.com/andyet/signalmaster)），并将ICE配置详细信息添加到前面提到的构造函数中。然而，这超出了本书的范围。我们将简单地继续使用默认配置。
- en: 'For our first step, we''ll create the class variables and references to the
    DOM elements inside our constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一步，我们将在构造函数中创建类变量和对DOM元素的引用：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's a lot, but they are all needed for different steps of our application.
    The only variable we created here is `roomName`, which as the name suggests, contains
    the room's name. The others are all references to DOM elements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这很多，但它们都是我们应用程序不同步骤所需的。我们在这里创建的唯一变量是`roomName`，正如其名称所示，它包含了房间的名称。其他的都是对DOM元素的引用。
- en: Creating a room
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建房间
- en: The first step of this app is to create a room so that other members can join
    a call in the room. As per the current UI design, we need to create the room when
    the user clicks the Create Room button. So, let's register a click event handler
    on that button.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的第一步是创建一个房间，以便其他成员可以加入房间进行通话。根据当前的UI设计，当用户点击“创建房间”按钮时，我们需要创建房间。因此，让我们在该按钮上注册一个点击事件处理程序。
- en: 'So far, we have been using different methods to handle events:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用不同的方法来处理事件：
- en: In our ToDo list app, we added the `onclick` attribute to the HTML to call JavaScript
    functions `onclick` event.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的待办事项列表应用程序中，我们在HTML中添加了`onclick`属性来调用JavaScript函数的`onclick`事件。
- en: In the Meme Creator, we attached event listeners to each element, where we wanted
    to listen for a specific event to happen (keyup, change, and click events). The
    same goes for the Event Registration form, where we added an event listener to
    listen for the form submit action.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Meme Creator中，我们为每个元素附加了事件侦听器，我们希望监听特定事件的发生（keyup、change和click事件）。在事件注册表单中也是如此，我们添加了一个事件侦听器来监听表单提交操作。
- en: 'There is also another method in which you add a callback function to the event
    property of the reference to the DOM element. In our case, we need to detect a
    click event on the Create Room button. We can handle it as follows:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有另一种方法，即将回调函数添加到DOM元素的引用的事件属性中。在我们的情况下，我们需要检测“创建房间”按钮的点击事件。我们可以这样处理：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, whenever the Create Room button is clicked, it will execute the code written
    inside the preceding function. It is entirely up to you and your requirements
    to decide which event handler to use. Usually, the first method is avoided because
    it will expose your JavaScript code inside HTML and it's difficult to keep track
    of all the JavaScript functions called inside HTML in large projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当单击“创建房间”按钮时，它将执行前述函数中编写的代码。完全取决于您和您的要求来决定使用哪种事件处理程序。通常，第一种方法会被避免，因为它会将您的JavaScript代码暴露在HTML中，并且在大型项目中难以跟踪HTML中调用的所有JavaScript函数。
- en: If you have a large number of elements, say about 100 rows in a table, attaching
    100 event listeners to each row is inefficient. You can either use the third method
    by attaching a function to the `onclick` method of the reference of each row's
    DOM element or you can attach a single event listener to the row's parent element
    and use that event listener to listen to the events of its children elements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有大量的元素，比如表格中的100行，为每一行附加100个事件侦听器是低效的。您可以使用第三种方法，通过将函数附加到每行DOM元素的引用的`onclick`方法，或者您可以将单个事件侦听器附加到行的父元素，并使用该事件侦听器来监听其子元素的事件。
- en: For a list of all the DOM events, visit the W3Schools page: [https://www.w3schools.com/jsref/dom_obj_event.asp](https://www.w3schools.com/jsref/dom_obj_event.asp).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有DOM事件的列表，请访问W3Schools页面：[https://www.w3schools.com/jsref/dom_obj_event.asp](https://www.w3schools.com/jsref/dom_obj_event.asp)。
- en: 'In our application, we need to handle a lot of click events. So, let''s create
    a method inside the `Home` class to register all the click events:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And call this method inside the constructor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `registerClicks()` method, add the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are few things that need to happen when the user clicks the Create Room
    button. They are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Get the room name. But the room name cannot contain any special characters that
    cause problems with the URL
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a room using `SimpleWebRTC`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect the user to a URL created for the room (a URL with the room name as
    query string)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show the URL that he/she can share with others who need to participate in the
    call
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should write the following code inside the `onclick` method you created
    in the preceding code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will get the room name that is typed in the input field and convert it
    into URL-friendly characters using regular expressions. If the room name is not
    empty, we can proceed to the creation of the room in `SimpleWebRTC`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code does the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `if` condition will check whether the room name is not empty (an empty string
    is falsy).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webrtc.createRoom()` will create the room. It accepts two parameters: the
    first one is the room name string and the second one is a callback function that
    executes when the room is created.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callback function has the parameters `err` and `name`. Usually, we should
    check whether the process is a success. So, `if(!err) {}` will contain the code
    to execute when the process is a success. `name` is the room name created by `SimpleWebRTC`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the `if(!err)` condition, add the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `location` object contains information regarding the current URL. `location.pathname`
    is used to set or get the current URL of the web page. So, we can construct a
    URL by appending the room name to it. So, if your current URL is `http://localhost:8080/` then,
    after creating the room, your URL should become `http://localhost:8080/?roomName`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace the URL without affecting the current page, we can use the `history`
    object provided by the History Web API. The `history` object is used to manipulate
    the browser''s history. If you want to perform the back action that happens when
    the user clicks the browser''s back button, you can do as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Likewise, for going forward, you can do as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But what we need in our application is to change the current URL without affecting
    the browser history. That is, we need to change the URL from `http://localhost:8080/`
    to `http://localhost:8080/?roomName` without affecting the back or forward buttons
    of your browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: For such complex actions, you can use the `pushState()` and `replaceState()`
    methods introduced in HTML5 for the history object. `pushState()` creates a new
    history entry on the browser and changes the URL of the page without affecting
    the current page. `replaceState()` does the same, but instead of creating a new
    history entry, it replaces the current entry, making it ideal for our purpose.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `pushState()` and `replaceState()` methods accept three parameters.
    The first one is `state` (a JSON object), the second one is `title` (string),
    and the third one is the new URL. This is how both `pushState()` and `replaceState()`
    works:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Every time `pushState()` or `replaceState()` is called, it triggers a `popstate`
    event in the `window` object. The first parameter, state object, is used by the
    callback function of that event. We have no use for it now, so we set it to an
    empty object.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, most browsers just ignore the second parameter, so we just set it
    to an empty string.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter URL is what we really need. It changes the browser URL to
    the provided URL string.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the room has been created and the URL has been changed, we need to hide
    the `.create-room-area` div and display the `.info-area` div instead. That''s
    why I added the `this.roomCreated()` method. In the `Home` class, create the new
    method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method will show the information section while hiding the create room section.
    Also, it will change the room name and URL using the `textContent()` method, which
    changes the text that is present in the respective DOM element.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将显示信息部分，同时隐藏创建房间部分。此外，它将使用`textContent()`方法更改房间名称和URL，该方法更改了相应DOM元素中的文本。
- en: 'More information on location objects can be found on the w3schools page: [https://www.w3schools.com/jsref/obj_location.asp](https://www.w3schools.com/jsref/obj_location.asp).More
    information on the history object can be found on the MDN page: [https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History).
    Also, if you want to learn to manipulate the browser history, visit [https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关位置对象的更多信息可以在w3schools页面上找到：[https://www.w3schools.com/jsref/obj_location.asp](https://www.w3schools.com/jsref/obj_location.asp)。有关历史对象的更多信息可以在MDN页面上找到：[https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History)。此外，如果你想学习如何操纵浏览器历史记录，可以访问[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)。
- en: Adding participants to your room
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向你的房间添加参与者
- en: You have an active room and the room URL with which you need to invite others.
    But wouldn't it be easier if you had a click to copy feature to copy the URL?
    That is actually a really nice feature to have. So, before we add participants
    to the room, let's build a click to copy feature.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个活跃的房间和房间URL，你需要邀请其他人。但是如果有一个点击复制功能来复制URL，那不是更方便吗？这实际上是一个非常好的功能。因此，在我们向房间添加参与者之前，让我们构建一个点击复制功能。
- en: Click to copy text
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击复制文本
- en: 'Currently, this is how the info area looks:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，信息区的外观是这样的：
- en: '![](../images/00027.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'For the click to copy feature, if you hover the mouse over the room URL, it
    should show a Copy button:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于点击复制功能，如果你将鼠标悬停在房间URL上，它应该显示一个复制按钮：
- en: '![](../images/00028.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: 'If you click the Copy button, it should copy the text and turn into the Copied
    button:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击复制按钮，它应该复制文本并变成已复制按钮：
- en: '![](../images/00029.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: 'For this functionality, we need to add some event listeners. So, inside your
    home class, create a new method `addEventListeners()` and call it inside the constructor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个功能，我们需要添加一些事件监听器。因此，在你的home类中，创建一个新的方法`addEventListeners()`，并在构造函数中调用它：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The reference to the div containing the copy buttons is stored in the `this.$buttonArea`
    variable. Whenever the mouse enters a div, it will fire a `mouseenter` event.
    When this event happens in `$buttonArea`, we need to remove the `.hidden` class
    from the copy button.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 包含复制按钮的div的引用存储在`this.$buttonArea`变量中。每当鼠标进入div时，它将触发一个`mouseenter`事件。当这个事件发生在`$buttonArea`中时，我们需要从复制按钮中移除`.hidden`类。
- en: 'Inside your `addEventListeners()` method, add the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`addEventListeners()`方法中，添加以下代码：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The page will reload and you will have to create a room again. If you hover
    the mouse pointer over the room URL now, it should make the Copy button visible.
    We also need the button to be hidden when the pointer leaves `div`. Similar to
    `mouseenter`, `div` will fire a `mouseout` event when the pointer leaves it. So,
    once again, add the following code next to the preceding code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 页面将重新加载，你将不得不再次创建一个房间。如果你现在将鼠标指针悬停在房间URL上，它应该会显示复制按钮。当指针离开`div`时，我们还需要隐藏按钮。类似于`mouseenter`，当指针离开`div`时，`div`将触发一个`mouseout`事件。因此，再次在前面的代码旁边添加以下代码：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, once again, try hovering your pointer over the room URL. Surprisingly,
    it doesn't work as expected. It should have done, but it didn't. It is because
    of the `mouseout` event, which also fires when your pointer enters the child elements
    of `$buttonArea`. It considers the child elements as `outside` the `div`. To fix
    this, we need to filter the `event` object that is passed in the callback function
    so that no action happens if the pointer moves `outside` by entering the child
    elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次尝试将鼠标指针悬停在房间URL上。令人惊讶的是，它并没有按预期工作。它应该有作用，但它没有。这是因为`mouseout`事件，当你的指针进入`$buttonArea`的子元素时，它也会触发。它将子元素视为`div`的`外部`。为了解决这个问题，我们需要过滤传递给回调函数的`event`对象，这样如果指针通过进入子元素而移动到`外部`，就不会发生任何操作。
- en: 'This one is tricky, but if you print the event object in the console, you will
    see that there are a lot of properties and methods containing all the details
    of the event. The `toElement` property or the `relatedTarget` property will contain
    the element to which the pointer moved to depending on the browser. So, we need
    to check whether the parent of that element is `$buttonArea`. If so, we should
    prevent any actions from happening. To do this, change the preceding code to the
    following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点棘手，但是如果你在控制台中打印事件对象，你会看到有很多属性和方法包含了事件的所有细节。`toElement`属性或`relatedTarget`属性将包含指针移动到的元素，具体取决于浏览器。因此，我们需要检查该元素的父元素是否是`$buttonArea`。如果是，我们应该阻止任何操作发生。为了做到这一点，将前面的代码更改为以下内容：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note the line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这一行：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is a short-circuit evaluation. What it does is, if the first value is
    truthy, it will assign it to the constant `e`. If it is falsy, the OR operator
    will evaluate the second one and assign its value to `e`. You can have any number
    of values declared like this. Say:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个短路评估。它的作用是，如果第一个值为真，它将把它赋给常量`e`。如果它为假，或运算符将评估第二个值，并将其值赋给`e`。你可以声明任意数量的值。比如：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the value of fun will be the first truthy statement on the list, hence,
    its value will be true. `'test'` is also a truthy value but it won't get evaluated,
    since there is a truthy value before it. This type of assignment is commonly used
    and is handy for certain tasks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，fun的值将是列表中第一个真值语句，因此它的值将为true。`'test'`也是一个真值，但它不会被评估，因为在它之前有一个真值。这种类型的赋值通常被使用，对于某些任务来说非常方便。
- en: Now, the `e` object contains the target element. So, we just need to check whether
    `e` exists (to prevent exceptions) and, if so, whether its parent element or the
    element itself is `$buttonArea`. If it is true, we simply return. This way, the
    callback function stops executing without hiding the copy and copied buttons.
    We hide the copied button too because we are going to make it visible when the
    user clicks the Copy button.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Try hovering over the room URL again in your application and it should work
    as expected. The last step is to copy the URL when the user clicks on the copy
    button. So, let''s register a click in the `registerClicks()` method we created
    earlier in our `Home` class. Inside the `registerClicks()` method, add the code
    to handle the clicks on the Copy and Copied buttons and create a new method `copyUrl()`
    inside the `Home` class to do the copy action:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, inside the `registerClicks()` method, clicking on both
    the Copy button and the Copied button will call the `copyUrl()` method of the
    class. We need to add the code to copy text inside the `copyUrl()` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy text, first, we need to get a range of nodes (the DOM elements) from
    which we need to copy text. To do so, create a range object and select the `this.$roomUrl`
    node, which contains the text of the room URL. Inside the `copyUrl()` method,
    add the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, the range object contains the element `$roomUrl` as the selected node.
    Then, we need to select the text in the node just as a user usually selects text
    with his/her cursor. The `window` object has the `getSelection()` method, which
    we can use for this purpose. We must remove all the ranges to clear the previous
    selections and then select a new range (which is the range object we created previously).
    Add the following code to the preceding code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we don''t know whether the user''s browser supports executing the
    copy command, so we do the copying inside a `try{} catch(err){}` statement so
    that, if any error occurs, it can be handled in the catch statement. The `document.execCommand(''copy'')`
    method will copy the text in the selected range and return it as a string. Also,
    we need to hide the copy button and display the copied button when, as copy is
    successful. The code to do copying is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After adding the preceding code, create a room in the application and try clicking
    Copy again. It should turn into the Copied button and the room URL text will be
    highlighted, because we selected the text just like how we select it, using the
    cursor with JavaScript. But it would be nice to clear the selection once copying
    is done. So, add this line at the end of the `copyUrl()` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will clear the selection, so next time you click copy, the room URL text
    will not be highlighted. You can then simply paste the selected URL wherever you
    like to share it with others.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Joining a room
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a link, we need to make a user join the room using that link.
    The process is simple: when the user opens the link, he joins the room and video
    of all the participants is displayed to him. To make a user join a room, `SimpleWebRTC`
    has the `joinRoom(''roomName'')` method, where the room name string is passed
    as a parameter. Once a user is in a room, it will look for the videos of other
    users connected in the room and will fire a `videoAdded` event for each video
    it finds, along with a callback function, which has the video object and the peer
    object of that user.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s strategize on how the process should work:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to check whether the URL the user entered contains the room name
    in its query string. That is, if it ends with `'?roomName'`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the room name exists, then we should make the user join the room while hiding
    the `.create-room-area` div and displaying the `.info-area` div with the room
    details.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we need to listen for the `videoAdded` events and, if an event is triggered,
    we add the video to `.video-area div`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleWebRTC` fires a `readyToCall` event when it has finished loading. It
    also has the `on()` method to listen for the events fired. We can use the `readyToCall`
    event to check for the room name in the URL. This code should be outside the `Home`
    class. So, after the line where you called the `Home` class constructor, add the
    following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are using the location object to get the URL. First, we need to check whether
    the URL contains the query string using `location.search`. So, we used it in an
    if condition and, if it contains the query string, we can continue the process.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The `split()` method splits the string into an array of substrings divided
    by the value passed to it as the parameter. The URL will be something like as
    follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`location.search` will return the query string part of the URL:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, `location.search.split(''?'')` will convert the string into an array as
    follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have the room name at the index 1 of the array. Writing like this works,
    but here we can use a short-circuit evaluation. We used an evaluation with the
    OR operator before, where it will take the first truthy value. In this case, we
    can use the AND operator that takes the first falsy value, or the last truthy
    value if there are no falsy values. The preceding code will be simplified into
    the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the URL does not contain the query string, `location.search` will be an empty
    string (`""`), which is a falsy value. Hence, the value of room will be an empty
    string.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: If the URL does contain the query string with the room name, then `location.search`
    will return `'?roomName'`, which is a truthy value, so the next statement `location.search.split('?')[1]`
    gets evaluated, which does the split and returns the first index in the array
    (room name). Since it is the last truthy value, the room constant will now contain
    the room name string! We just simplified three lines of code into a single line
    using short-circuit evaluation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Detailed information on short-circuit evaluation can be found at: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Setters and getters
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We just need to add one more line to make the user join the room:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will add the user to the room, however, once the user is inside the room,
    we need to hide the `.create-room-area` div and display the `.info-area` div.
    These are available in the `roomCreated()` method of the `Home` class. But that
    method depends on the `this.roomName` class variable, which should contain the
    room name. So, we need to update a class variable and call the `class` method
    from outside the class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Even though we can do it by using the `home` object we created earlier, it would
    make more sense if we could just update the class's room property and it will
    perform the actions automatically. For that, we can use setters. Setters are special
    methods that are used for assigning a new value to the object's property. We have
    used getters and setters several times before. Remember how we get the value of
    the input field?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, the value property is a getter. It returns a value from the `$roomNameInput`
    object. However, if we do the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then, it will change the value of the input field to `'New Room Name'`. This
    is because the value now acts as a setter and updates a property inside the `$roomNameInput`
    object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a setter for our `Home` class to join a room. Creating a setter
    is simple; we simply create a method prefixed with the `set` keyword and the method
    should have *exactly one parameter*. Inside your `Home` class, add the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, use the setter (only if the room is not an empty string) in your `readyToCall`
    event handler:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you have added the code, create a room in your Video Call app and then
    copy the URL and paste it in a new tab. It should automatically get the room name
    from the URL and join the room. If you can see the room information, then you
    are good to go. We are nearing the final stage of the application--adding and
    removing videos.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: If and else conditions do not require `{}` curly braces if there is only one
    statement after them. That is, `if (true) console.log('true'); else console.log('false');`
    will work just fine! But it should be avoided, since it is always better to use `if
    else` conditions with `{}` curly braces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a getter, you simply prefix the method with `get` instead of `set`,
    but the method should contain *no parameters*and it should *return a value*. Say,
    in your `Home` class, you need to know the room name using getter. Then, you can
    add the following method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you try `console.log(home.room)` outside the class, you should get the value
    stored in the `roomName` class variable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing videos
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `readyToCall` event, `SimpleWebRTC` will fire a `videoAdded`
    event for every video it finds in the room with a callback function having the
    video object and the peer object containing the ID (the unique ID of that user).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: To test multiple videos, we are going to open two tabs on the same browser in
    the same system. This might cause feedback to damage your audio devices, so keep
    your volume muted!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method inside the `Home` class `addRemoteVideo($video, peer)`,
    as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s add another event handler for the `videoAdded` event, just as we did
    for the `readToCall` event:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Whenever a video gets added, it will call the `addRemoteVideo` method of the
    `Home` class with the video object and the peer object. We have a div `.video-area`,
    which is supposed to contain all the videos. So, we need to construct a new div
    element similar to the one used for the local video, such as:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And we should append this element to the `.video-area` div, which is currently
    referenced by `this.$remotes` variable. This is quite simple, just as we added
    the `script` element in the previous chapter. Inside your `addRemoteVideo()` method,
    add the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code does the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a `div` element using the `document.createElement('div')` method
    and assign it to the `$container` object.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we set the class name of `$container` to `'video-container'` and ID to
    `'container_peerid'`. We can get the peer ID from the peer object we received
    using the `webrtc.getDomId()` method.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$video` object we received is an HTML element just like `$container`. So,
    we assign it the class name `'video-player'`.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, for the last step, we append `$video` as a child inside `$container` and,
    finally, append `$container` as a child inside `this.$remotes`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will construct the HTMLs we need with the classes and IDs. When a user
    leaves the room, the `videoRemoved` event will be fired, which is similar to the
    `videoAdded` event. Whenever the user leaves the room, we need to use the peer
    ID to remove the div containing the ID `''container_peerid''`, where `peerid`
    is the ID of the user who left. To do so, add the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `removeRemoteVideo()` method will find the div containing the remote video
    using the peer ID and will remove it from this `this.$remotes` object using the
    `removeChild()` method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Time to test our Video Call app. Open the application in Chrome and create the
    room. Copy the room URL and paste it in a new tab (keep your volume muted!). It
    might take a few seconds, but unless STUN didn't work for you, you should see
    two videos in each of the tabs. You are streaming video between the tabs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The first video is your video. If you close one of the tabs, you should see
    that the second video will be removed from the other tab. Before we test this
    app in other devices, there is one more feature that would really look great in
    this app. That is increasing the size of the selected video.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a video
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, all the videos are small in size. Hence, we need a feature to enlarge
    the videos, such as:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In desktops, clicking on a video will increase the size of the video and bring
    it to the first spot among the list of videos
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In mobiles, tapping a video will only increase the size of the video
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This sounds fine. To make this happen, let''s add some styles to our `styles.css`
    file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have added two sets of styles using media queries. One for mobile (`max-width:
    736px`) and another for desktops (`min-width: 736px`).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'For every click made in a video, we should add the `.video-selected` class
    to that video and `.container-selected` to the parent div of that video:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: In mobiles, it will increase the size of the video up to 70% of the viewport
    width.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In desktops, it will increase the size up to 50% of the viewport width and
    also assign `order: -1` to its parent div. This way, since the parent div is part
    of flex, it will become the first item of the flex elements (but other elements
    should not contain order in their styles).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In your `Home` class, add the following method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will find the video containing the `.video-selected` class and remove the
    `.video-selected` class from that video and the `.container-selected` class from
    that video's parent div. This is useful because we can call it to clear the selected
    ones before we select another video.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'We can register a click event on the local video inside the `registerClicks()`
    method. Inside the `registerClicks()` method, add the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will add the required classes to the video element and its parent div.
    For remote videos, we cannot register clicks here because we create those elements
    dynamically. So, we either have to create an event listener or register a click
    event when the remote video elements are created.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Creating an event listener for each video is not quite efficient here because
    the videos will be removed when the user leaves, so we will have unwanted event
    listeners running for each video. We will have to remove those event listeners
    using the `removeEventListener()` method or avoid this by creating an event listener
    to the parent div `.video-area` instead of the video elements. Still, this means
    that we need to filter through each of the clicks made inside `.video-area` div
    to check whether that click was made on a video.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, it''s simpler to register a click using the `onclick()` method when
    the video element is created. This saves us the trouble of dealing with event
    listeners. Inside your `addRemoteVideo()` method, add this code after the existing
    code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now try clicking on a video in Chrome. You should see that the video will increase
    its size and move to the first position on the list. Congratulations! You have
    successfully built your Video Call application! Time to test Video Call in action.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Video Call in action
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You got the application ready, so let's test it locally. First, generate the
    production build for your app. You have already done this before in the Event
    Registration app. You need to set `NODE_ENV=production` in your `.env` file.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: After that, in your project root folder, kill Webpack dev server and run the
    `npm run webpack` command. It should generate the production builds for your JS
    and CSS files. The filename will be available in the `dist/manifest.json` file.
    Include those CSS and JS files in your `index.html` page.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Now, run `http-server` in your project root folder. It should print two IP address.
    Open the one starting with 192 in your browser. This IP address is accessible
    to all the devices in your LAN, unless you have blocked the port using a firewall.
    However, Chrome will not display your video! This is because the `getUserMedia()`
    method will only work in localhost and HTTPS URLs. Since our local address is
    using HTTP only, the video will not work.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: We can add HTTPS by deploying our WebRTC application on a public server with
    an SSL certificate from a certificate authority. However, for our local development
    environment, we can use a self-signed certificate. An SSL certificate from a certificate
    authority will be trusted by all browsers, but a self-signed certificate will
    not be trusted, hence, a warning will be shown, in which we should manually select
    the option to trust the website on our browser. For this reason, self-signed certificates
    are not suitable for production and should only be used for development purposes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a self-signed certificate is a big process but, luckily, there is
    an `npm` package that can do this in a single line. We need to install this package
    globally, since it is a command-line tool like `http-server`. In your terminal,
    run the following command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Linux users might have to add `sudo` to their command to install packages globally.
    By default, `http-server` will serve your files from port number `8080`. Say,
    if your current URL is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, open another terminal and run the following command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, source is the new port number and target is the port number in which
    http-server is running. You should then open the same IP address with the new
    port number and `https://` prefix in Chrome, as shown in the following code block:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you open this page in Chrome, you should receive a warning similar to the
    following screenshot. In that case, select Advanced as shown in the following
    image:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00030.jpeg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'Once you click Advanced, you will see a page similar to the following image
    where you should click proceed link:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: You can now use this HTTPS URL to open the app in any device that is connected
    to your LAN. Make sure there is enough distance between the devices so that it
    doesn't cause feedback.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully, you had a great time building the Video Call application. In this
    chapter, we did some new things with JavaScript and learned some new concepts,
    such as JavaScript WebRTC APIs and the SimpleWebRTC framework. Along the way,
    we did lot of cool things, such as manipulating browser history, selecting text
    using JavaScript, and working with URLs. Also, we shortened some of our code with short-circuit
    evaluation and learned about setters and getters for manipulating class variables
    in JavaScript.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleWebRTC` comes with many other events and actions which allow you to
    do more in the app, such as mute your microphone, mute audio from others, and
    so on. If you are interested, you can check out the SimpleWebRTC home page for
    more examples.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: We know how to create reusable JavaScript modules, which we did in the previous
    chapter. In the next chapter, we are going to take it a step further and build
    our own reusable HTML elements using web components.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
