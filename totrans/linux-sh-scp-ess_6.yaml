- en: Chapter 6. Working with Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For simplicity, everything in UNIX and Linux-based operating systems is treated
    as a file. Files in the filesystem are arranged in a hierarchical tree like a
    structure with the root of the tree denoted by '`/`' (forward slash). A node of
    the tree is either a directory or file where the directory is also a special type
    of file containing inode numbers and a corresponding filename entry of the list
    of files inside it. An inode number is an entry in an inode table that contains
    metadata information related to the file.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a closer look at the important and commonly used
    file types. We will see how we can create, modify, and perform other useful operations
    on files. We will also see how to monitor a list of files opened by a process
    or user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic file operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving and copying files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Links to a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Temporary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permission and ownership
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the list of open files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing basic file operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most commonly used files are regular files and directories. In the following
    subsection, we will see the basic file operations.
  prefs: []
  type: TYPE_NORMAL
- en: Creating files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create both regular files and directories in shell using different shell
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Directory file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A directory is a special type of file that contains a list of filenames and
    a corresponding inode number. It acts as a container or folder to hold files and
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new directory through shell, we can use the `mkdir` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also provide multiple directories'' name as arguments to the `mkdir`
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a parent directory if the specified pathname to `mkdir` is not
    present. This is done using the `-p` option in `mkdir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, if `dir1` and `dir2` are the parent directories for `dir3` and don't exist
    already, the `-p` option will create the `dir1` directory first and then `dir2`
    subdirectory inside `dir1` and the `dir3` subdirectory inside `dir2`.
  prefs: []
  type: TYPE_NORMAL
- en: Regular file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, text and binary files are known as regular files. In shell, a regular
    file can be created in multiple ways. Some of them are mentioned in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Touch command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A new regular file can also be created using the `touch` command. It is mainly
    used to modify the timestamp of the existing file, but if the file doesn''t exist,
    a new file is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the command line editors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can open any command line editor; for example, `vi/vim`, emacs, nano in shell,
    write content, and save content in file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create and write a text using the `vi` editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Press the key *I* to enter the `INSERT` mode of vi and then type the text as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the command line editors](img/4335_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After writing the text, press the *Esc* key and then type the `:wq` command
    to save and exit from the vi editor. To know `vi/vim` in detail, refer to its
    `man` page or the online documentation ([http://www.vim.org/docs.php](http://www.vim.org/docs.php)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the command line editors](img/4335_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the cat command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can even use the `cat` command to write the content into an existing or
    a new regular file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By using the `>>` operator instead of `>`, we can append instead of overwriting
    the file's content.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting the command's output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While executing a command in bash or script, we can redirect results into an
    existing or a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Modifying files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To modify the content of a regular file in shell, open a file in an editor,
    make the required changes, and then save and exit. We can also use the `>>` operator
    to append the command''s output to the specified file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we will save the `ls` output of `/home` in the `ls_output.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will append the `ls` output of another directory `/home/foo/` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We saw that the `ls_output.txt` file gets modified by appending the content
    of the `ls` command output.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To view the content of a regular file, we can simply open a file in an editor
    such as vi/vim, emacs and nano. We can also use the `cat`, `less` and `more` commands
    to view the file's content.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the contents of a directory, we use the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To view the contents of a directory recursively, use `ls` with the `-R` or `--recursive`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing content using cat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `cat` command to view the content of the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: more and less
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `more` and `less` commands are very useful and handy to view a large file
    that doesn't fit on the current terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `more` command displays the content of a file in page format, in which
    we can scroll up and down to view the remaining contents of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A file path is passed as an argument to the `more` command. In the above example,
    it will display the content of the file words available in the `/usr/share/dict/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The key *s* is used to skip forward `k` lines of text. The key *f* is used to
    skip forward k screenful of text. The key *b* is used to skip backward k screenful
    of text.
  prefs: []
  type: TYPE_NORMAL
- en: The `less` command is more popular and widely used to view the content of large
    files. One of the advantages of using the `less` command is that it doesn't load
    entire files in the beginning and as a result, viewing the content of large files
    is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of `less` is very similar to the `more` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Navigation is much easier while using the `less` command. It also has more options
    to customize the filtered view of a file's content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `more` and `less` commands can take an input from `stdin` if no input file
    is provided. Use a pipe (''`|`'') to give an input from `stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See the `man` page of `more` and `less` for the detailed usage.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior of the `more` command may vary on different systems because of
    its different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also delete regular files and directories if they are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a regular file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To delete a regular file, we use the `rm` command in shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rm` command deletes the file if it exists, otherwise it prints an error
    on `stdout` if it doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To ignore an error message, `rm` can be used with the `–f` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Enter the key *y* to delete a file and *n* to skip the deletion of a file.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To delete a directory, we can use the `rmdir` and `rm` commands. We will consider
    directories that are created in the `Directory` files under the `File` creation
    subtopic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To delete a nonempty directory, first delete the contents and then remove the
    directory. We can also use `rm` to remove an empty or a nonempty directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `–d` option removes an empty directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The option `-r`, `-R`, or `--recursive` removes the directory and its contents
    recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Typing *y* confirms that `dir1` should be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `rm` carefully with the `-r` option. If possible, use it with the `-i` option
    to avoid an accidental deletion of an entire directory's contents.
  prefs: []
  type: TYPE_NORMAL
- en: Moving and copying files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often need to copy or move files from one location to another in order to
    arrange files according to the need. We also can copy our computer data to an
    external drive or another computer available locally or remotely in order to keep
    the backup of the important data.
  prefs: []
  type: TYPE_NORMAL
- en: Moving files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Moving regular files and directories is useful when we want to keep exactly
    one copy of the data at a new location. The `mv` command is used to move files
    from one location to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using the `mv` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, `source` is the file or directory to be moved. Multiple source files can
    be specified and `destination` is the location in which the files and directories
    should be moved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important options of the `mv` command are explained in following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-n` | Don''t overwrite an existing file |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | Prompt before overwriting an existing file |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | Don''t prompt while overwriting an existing file |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` | Move a source file only when the source is newer than the destination
    or when the destination is missing |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | Print name of the files being moved |'
  prefs: []
  type: TYPE_TB
- en: Moving a directory to a new location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To move a directory from one location to another, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `test_dir1` directory has been moved to `/tmp` and no copy of `test_dir1`
    exists in the home directory now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a directory called `test_dir1` again in the user''s home
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Try again to move `test_dir1` in `/tmp` with the `–i` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `-i` option asks a user explicitly whether we want to overwrite
    an existing directory with a new directory or not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `mv` command with the `-i` option to avoid an accidental overwrite of
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming a file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use the `mv` command to rename a filename. For example, we have
    the `test_dir1` directory in the `/tmp` directory. Now, we want to rename it as
    `test_dir`. We can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Copying files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating copies of files is a very common operation that can be performed locally
    or to a remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Copying files locally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To copy the files on a local machine, the `cp` command is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using the `cp` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `source` can be a single file, multiple file, or a directory, while `destination`
    can be a file if `source` is a single file. Otherwise, `destination` will be a
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of important options to the `cp` command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Options | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-f` | Don''t prompt while overwriting an existing file |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | Prompt before overwriting an existing file |'
  prefs: []
  type: TYPE_TB
- en: '| `-R` | Copy directories recursively |'
  prefs: []
  type: TYPE_TB
- en: '| `-u` | Copy a source file only when the source is newer than the destination
    or when the destination is missing |'
  prefs: []
  type: TYPE_TB
- en: '| `-p` | Preserve attributes of a copied file with the original file |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | Verbose output of which file is being copied |'
  prefs: []
  type: TYPE_TB
- en: Copying a file to another location
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To copy a file to another location, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have two copies of the `copy_file.txt` file that are at the user's home
    directory and the `/tmp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To copy a directory, we use `cp` with the `-R` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `test_dir2` directory gets copied to `/tmp` along with all the contents
    available in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: Copying files remotely
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To copy files on a remote machine, the `scp` command is used. It copies files
    between hosts on a network. The `scp` command uses `ssh` to authenticate the target
    host and transfer data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple syntax of `scp` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, in `user1@host1:source`, `user1` is the username of the source from where
    a file will be copied and `host1` is the hostname or IP address; `source` can
    be a file or a directory to be copied.
  prefs: []
  type: TYPE_NORMAL
- en: In `user2@host2:destination`, `user2` is the username of the target host where
    files should be copied and `host2` is the hostname or IP address; `destination`
    can be a file or directory where it gets copied. If no destination is specified,
    a copy will be made in the target host's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: If no remote source and destination to provided, a copy will be made locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important options of `scp` are discussed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-C` | Enable compression while transferring data over a network |'
  prefs: []
  type: TYPE_TB
- en: '| `-l limit` | Limit the used bandwidth specified in Kbit/s |'
  prefs: []
  type: TYPE_TB
- en: '| `-p` | Preserve attributes of a copied file with the original file |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | Don''t print any progress output on `stdout` |'
  prefs: []
  type: TYPE_TB
- en: '| `-r` | Copy directory recursively |'
  prefs: []
  type: TYPE_TB
- en: '| `-v` | Verbose output while the copy is in progress |'
  prefs: []
  type: TYPE_TB
- en: Copying files to a remote server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To copy files to a remote server, it is very important that the `ssh` server
    is already running on the server. If it is not, make sure to start the `ssh` server.
    To copy files, use the `scp` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have made a copy to a local machine. So, the hostname used is `localhost`.
    Now, we have another directory `test_dir2` inside `/tmp/test_dir2/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Comparing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A comparison between two similar files makes sense in order to know what differences
    exist between the two files. For example, comparing the results obtained by a
    command ran on two sets of data. Another example can be comparing an older and
    a newer version of a shell script file in order to know what modifications have
    been made in script. Shell provides the `diff` command for file comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Files comparison using diff
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `diff` command is used to compare files line by line. The syntax of using
    the `diff` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Where, `file1` and `file2` are the files to be compared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options of the `diff` command are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-q` | Only print if files differ |'
  prefs: []
  type: TYPE_TB
- en: '| `-s` | Print a message on `stdout` if the two files are identical |'
  prefs: []
  type: TYPE_TB
- en: '| `-y` | Display the `diff` results side by side |'
  prefs: []
  type: TYPE_TB
- en: '| `-i` | Do case-insensitive comparison of the files'' content |'
  prefs: []
  type: TYPE_TB
- en: '| `-b` | Ignore changes in the number of whitespace |'
  prefs: []
  type: TYPE_TB
- en: '| `-u NUM` | Output `NUM` (default 3) lines of unified context |'
  prefs: []
  type: TYPE_TB
- en: '| `-a` | Consider files as text files while comparison |'
  prefs: []
  type: TYPE_TB
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `diff` command shows the comparison results for the added, removed, and
    modified lines between two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will consider the `comparison_file1.txt` and `comparison_file2.txt` text
    files as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will compare the `comparison_file1.txt` and `comparison_file2.txt`
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<` (less than) means removed lines and `>` (greater than) means added
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `-u` option makes the `diff` output even more readable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, '`-`' tells the lines available in an older file (`comparison_file1.txt`),
    but which is no longer present in the newer file (`comparison_file2.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: The '`+`' tells lines being added in newer file (`comparison_file2.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even do a case-insensitive comparison of the content using the `–i`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To ignore multiple blank spaces, use `diff` with make `-b` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finding files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a filesystem, there is huge number of files available. Sometimes, there are
    external devices that are attached as well, which may also contain huge number
    of files. Imagine that there are millions and billions of files in a system and
    in which we have to search for a specific file or pattern of a file. Manual searching
    of a file is possible if the number of files is from 10 to 100, but it is almost
    impossible to search in millions of files. To solve this problem, UNIX and Linux
    provide the `find` command. It is a very useful command for searching files in
    a computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of using the `find` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`find search_path [option]`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, in `search_path`, specify the path in which `find` should search for `file_search_pattern`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important options are mentioned in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| -P | Don''t follow symbolic link. This is default behavior |'
  prefs: []
  type: TYPE_TB
- en: '| -L | Follow symbolic link while searching |'
  prefs: []
  type: TYPE_TB
- en: '| -exec cmd ; | Execute command cmd passed as parameter to -exec |'
  prefs: []
  type: TYPE_TB
- en: '| -mount | Don''t search in other file system |'
  prefs: []
  type: TYPE_TB
- en: '| -executable | Matches executable files |'
  prefs: []
  type: TYPE_TB
- en: '| -group gname | File belongs to group gname |'
  prefs: []
  type: TYPE_TB
- en: '| -user uname | Files owned by user uname |'
  prefs: []
  type: TYPE_TB
- en: '| -name pattern | Search file for given pattern |'
  prefs: []
  type: TYPE_TB
- en: '| -iname pattern | Case insensitive search of file for given pattern |'
  prefs: []
  type: TYPE_TB
- en: '| -inum N | Search file with inode number N |'
  prefs: []
  type: TYPE_TB
- en: '| -samefile name | File with same inode number as name |'
  prefs: []
  type: TYPE_TB
- en: '| -regex pattern | Match files with given regular expression pattern. Matches
    for whole path. |'
  prefs: []
  type: TYPE_TB
- en: '| -iregex pattern | Case insensitive match of files with given regular expression
    pattern. Matches for whole path. |'
  prefs: []
  type: TYPE_TB
- en: Searching files according to use case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following shell script shows some use cases of how to use the `find` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the sample output after executing the preceding `finding_files.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Finding and deleting a file based on inode number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `find` command can be used to find a file based on its inode number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-inum` option is good to use with `exec` to delete files that cannot be
    deleted by a filename. For example, a file named `-test.txt` can''t be deleted
    using the `rm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete the `-test.txt` file, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Links to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A link to a file means referring the same file by different filenames. In Linux
    and Unix-based system, the following two types of links exist:'
  prefs: []
  type: TYPE_NORMAL
- en: A soft link or a symbolic link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hard link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create links between files, the `ln` command can be used. The syntax is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, `target` is the filename for which a link has to be created and `link_name`
    is the name by which a link has to be created.
  prefs: []
  type: TYPE_NORMAL
- en: Soft link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A soft link is a special kind of file that just points to another file. This
    makes it easier to create a shortcut of a file and easy accessibility of a file
    to a different location in a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a symbolic link of a file, the `ln` command is used with the `-s`
    option. For example, we will create a symbolic link of the `/tmp` directory in
    our home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a symbolic link of the `/tmp` directory in our home directory
    by the name `local_tmp`. To access the `/tmp` data, we can also `cd` into the
    `~/local_tmp` directory. To know whether a file is a symbolic link or not, run
    `ls -l` on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the first character of the first column is `l`, then it means it is a symbolic
    link. Also the last column says `/home/foo/local_tmp -> /tmp/`, which means `local_tmp`
    is pointing to `/tmp`.
  prefs: []
  type: TYPE_NORMAL
- en: Hard link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hard link is a way to refer a file with different names. All such files will
    have the same inode number. An inode number is an index number in an inode table
    that contains metadata about a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a hard link of a file, use the `ln` command without any option. In
    our case, we will first create a regular file called `file.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The second column of `ls` tells the link count. We can see that currently it
    is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create a hard link of `file.txt`, we will use the `ln` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether a hard link is created for `file.txt`, we will see its link
    count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, the link count is `2` because a hard link has been created with the name
    `hard_link_file.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that the inode number of the `file.txt` and `hard_link_file.txt`
    files are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Difference between hard link and soft link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table shows a few important differences between a hard link and
    a soft link:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Soft link | Hard link |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| The inode number of the actual file and the soft link file are different.
    | The inode number of the actual file and the hard link file are the same. |'
  prefs: []
  type: TYPE_TB
- en: '| A soft link can be created across different filesystems. | A hard link can
    only be created in the same filesystem. |'
  prefs: []
  type: TYPE_TB
- en: '| A soft link can link to both regular files and directories. | A hard link
    doesn''t link to directories. |'
  prefs: []
  type: TYPE_TB
- en: '| Soft links are not updated if the actual file is deleted. It keeps pointing
    to a nonexistent file. | Hard links are always updated if the actual file is moved
    or deleted. |'
  prefs: []
  type: TYPE_TB
- en: Special files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The files other than regular files, directories, and link files are special
    files. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The block device file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The character device file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The named pipe file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The socket file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The block device file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A block device file is a file that reads and writes data in block. Such files
    are useful when data needs to be written in bulk. Devices such as hard disk drive,
    USB drive, and CD-ROM are considered as block device files. Data is written asynchronously
    and, hence, other users are not blocked to perform the write operation at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a block device file, `mknod` is used with the option `b` along with
    providing a major and minor number. A major number selects which device driver
    is being called to perform the input and output operation. A minor number is used
    to identify subdevices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `0X7` is a major number and `0X6` is a minor number in hexadecimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The first character of the first column is `b`, which means it is a block device
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth column of the `ls` output is `7` and `6`. Here, `7` is a major number
    and `6` is a minor number in decimal format.
  prefs: []
  type: TYPE_NORMAL
- en: A character device file is a file that reads and writes data in character-by-character
    fashion. Such devices are synchronous and only one user can do the write operation
    at a time. Devices such as keyboard, printer, and mouse are known as character
    device files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following command will create a character special file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, `0X78` is a major number and `0X60` is a minor number that is in hexadecimal
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The first character of the first column is `c`, which means it is a character
    device file. The fifth column of the `ls` output is `120` and `96`. Here, `120`
    is a major number and `96` is a minor number in decimal format.
  prefs: []
  type: TYPE_NORMAL
- en: Named pipe file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Named pipe files are used by different system processes to communicate with
    each other. Such communication is also known as interprocess communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create such a file, we use the `mkfifo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first character of the first column is '`p`', which means it is a
    pipe file. There are a lot of pipe files available in the `/dev` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a named pipe using the `mknod` command with the `p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell script demonstrates a reading message from a named pipe.
    The `send.sh` script creates a named pipe called `named_pipe`, if it doesn''t
    exist, and then sends a message on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `receive.sh` script checks whether a named pipe with the name `named_pipe`
    exists, reads a message from a pipe, and displays on `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute it, run `send.sh` in a terminal and `receive.sh` in another terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Socket file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A socket file is used to pass information from one application to another.
    For example, if **Common UNIX Printing System** (**CUPS**) daemon is running and
    my printing application wants to communicate with it, then my printing application
    will write a request to a socket file where CUPS daemon is listening for upcoming
    requests. Once a request is written to a socket file, the daemon will serve the
    request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The first character in the first column is `s`, which means it is a socket file.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Temporary files are the files that are needed for a short interval of time while
    an application is running. Such files are being used to keep intermediate results
    of running a program and they are no longer needed after the program execution
    is complete. In shell, we can create temporary files using the `mktemp` command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a temporary file using mktemp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mktemp` command creates a temporary file and prints its name on `stdout`.
    Temporary files are created by default in the `/tmp` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of creating a temporary file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A file with the name `tmp.xEXXxYeRcF` gets created into the `/tmp` directory.
    We can further read and write into this file in an application for temporary use.
    Using the `mktemp` command instead of using a random name for a temporary filename
    avoids accidental overwrite of an existing temporary file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a temporary directory, we can use the `-d` option with `mktemp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can explicitly delete it as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We can even specify a template to use for a temporary file by providing an argument
    as `name.XXXX`. Here, `name` can be any name by which a temporary file should
    begin, and `XXXX` tells the length of a random character to be used after a dot
    (.). In general, while writing an application if temporary files are needed, the
    application name is given as the temporary file name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a test application needs to create a temporary file. To create
    a temporary file, we will use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the temporary file name begins with `test` and contains exactly
    five random letters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time when temporary files will be cleaned up is distribution-specific.
  prefs: []
  type: TYPE_NORMAL
- en: Permission and ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a user of a system, to access a file in Linux and UNIX, it is important
    that a user has the required permission for that specific file or directory. For
    example, as a regular user, perform `cd` into `/root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We were not able to do so because of the permission denied error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We were successfully able to do `cd` into the user's home directory because
    a user had the permission to access its own home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Every file in UNIX or Linux has an owner and an associated group. It also has
    a set of permissions (read, write, and execute) with respect to the user, group,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the ownership and permission of files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ls` command with the `-l` option is used to view the ownership and permission
    of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first column of `ls` contains the permission information—that is,
    `-rw-rw-r--`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first character specifies a file''s type, which is dash (-) in this example.
    A dash means that it is a regular file. It can have other characters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'p: This means it is a named pipe file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'd: This means it is a directory file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 's: This means it is a socket file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'c: This means it is a character device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'b: This means it is a block device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three characters belong to a user's or owner's permission. It can be
    either `rwx` or `dash` at any of these spaces. The permission `r` specifies that
    the read permission is available, `w` specifies that the write permission is available,
    and `x` specifies that the execute permission is available over the given file.
    If a dash is present, then the corresponding permission is missing. In the above
    example, an owner's permission is `rw-`, which means the owner has read and write
    permission on the `permission_test_file.txt` file but no execute permission.
  prefs: []
  type: TYPE_NORMAL
- en: The next three characters belong to a group's permission. It can be `rwx` or
    `dash` at any of these places if the corresponding permission is missing. In the
    preceding example, the permission given to a group is `rw-`, which means the read
    and write permissions are present and the execute permission is missing.
  prefs: []
  type: TYPE_NORMAL
- en: The next three characters belong to other's permission. In the preceding example,
    the permission given to others is `r--`, which means other users can read the
    content of the `permission_test_file.txt` file but can't modify or execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The next column in the `ls -l` output—that is, the second column specifies who
    the owner of file is. In our example, the second column value is `foo`, which
    means `foo` has the ownership of the file. By default, the ownership of a file
    is given to whoever has created that file.
  prefs: []
  type: TYPE_NORMAL
- en: The third column in the `ls -l` output that specifies the group to which a file
    belongs to. In our case, the group of the `permission_test_file.txt` file is `foo`.
  prefs: []
  type: TYPE_NORMAL
- en: Changing permission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To change the permission of a file, the `chmod` command is used. The syntax
    of using `chmod` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Or,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: An important option of `chmod` is `-R`, which means change the files and directories
    permission recursively.
  prefs: []
  type: TYPE_NORMAL
- en: The `mode` can be `[ugoa][-+][rwx]`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `u` is the owner, `g` is the group, `o` is other, and `a` is all users—that
    is, `ugo`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying - (minus) removes the specified permission and specifying `+(plus)`
    adds the specified permission.
  prefs: []
  type: TYPE_NORMAL
- en: The letters `r`(read), `w`(write), and `x`(execute) specify permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `octal-mode` specifies the `rwx` permission of a user together in octal
    format, which can be from `0 to 7`. The following table explains the octal representation
    of a permission to a specific user:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Octal Value | Binary representation | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 000 | No read, write, and execute permissions (---) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 001 | Only execute permission (--x) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 010 | Only write permission (-w-) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 011 | Write and execute permissions (-wx) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 100 | Only read permission (r--) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 101 | Read and execute permissions (r-x) |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 110 | Read and write permissions (rw-) |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 111 | Read, write, and execute permissions (rwx) |'
  prefs: []
  type: TYPE_TB
- en: 'To demonstrate the changing permission on a file, we will create a file as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The default permission given to a regular file is the `Read` permission to an
    owner, group, and other. The `Write` permission is given to the owner and group.
    No execute permission is given to anyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to modify a permission in such a way that only the owner can have
    the `write` permission, and keeping the other permission as it is. We can do this
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see that only an owner can modify `test_file`. While using octal
    mode, we have to specify the exact permission that we want to see further. In
    `chmod`, we gave `octal_mode` as `644`; here the first octal digit, that is, `6`
    signifies the read, write, and execute permissions of the owner. Similarly, the
    second octal digit `4` specifies the permissions for the group and the third digit
    specifies the permission for others.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way to modify a permission, which is by using mode. Mode is
    specified as `[ugoa][-+][rwx]`. Here, we only have to specify which permission
    we want to add or remove.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we want to remove the write permission from an owner and add the
    execute permission to all. We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Changing the owner and group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also change the owner and group ownership of a file. This allows flexibility
    to further modify the group and owner of a file.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a file's owner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To change the owner of a command, `chown` is used. This is useful for sysadmin
    in different cases. For example, a user is working on a project and now the user
    is going to discontinue working on that project. In such a case, sysadmin can
    modify the ownership to a new user who is responsible for continuing that project.
    Sysadmin can change the ownership of a file to a new user for all the related
    files in a project.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, `foo` is the owner of the `test_file.txt` file. Now,
    we want to transfer the ownership of a file to user `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: If the user `bar` doesn't exist in a system, a new user bar can be created using
    the `useradd` command. The `useradd` command needs the root access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following command will create a new user called `bar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change ownership of `test_file.txt` file to user `bar` by executing
    the following command as `root` or `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the ownership of a file is changed to bar.
  prefs: []
  type: TYPE_NORMAL
- en: Changing group ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To modify the group ownership of a file, we can either use the `chown` or `chgrp`
    command. To create a new group, the `groupadd` command is used as `sudo` or `root`.
    For example, we want to create a new group called `test_group`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will change the group of the example file `test_file.txt` by using
    the `chown` command. This can be done by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the group has been modified to `test_group`. To change the
    group using the `chgrp` command, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will revert back the owner and group to `foo` for the `test_file.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The new owner name is provided before `:` (colon) and the group name after `:`
    ,while modifying the owner and group ownership using the `chown` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the list of open files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that there can be millions of files available in a system, which can
    be binary files, text files, directories, and so on. When a file is not in use,
    they are just available on a storage device as `0 and 1`. To view or process a
    file, it needs to be opened. An application that is executing may open multiple
    files. Knowing what files are opened by a running application is very useful.
    To know the list of opened files, the `lsof` command is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing the following command gives the list of all opened files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This gives a huge output of all the opened files.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the files opened by a specific application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To know the list of files opened by a specific application, first get the **Process
    ID** (**PID**) of the running application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s run `cat` without any parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can directly write the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a sample screenshot of the `lsof` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Knowing the files opened by a specific application](img/4335_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the output, we see that there are various columns of results. The first column
    is `COMMAND`—that is, for the application this file has been opened, the PID column
    specifies the PID with which the file has been opened, USER tells which user has
    opened the file, FD is the file descriptor, TYPE specifies the type of file, DEVICE
    specifies the device number with values separated by a comma, SIZE/OFF specifies
    the size of the file or the file offset in bytes, and NAME is the filename with
    the absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can see that the application has opened `cat binary` from
    `/usr/bin`. It has also loaded the shared library files such as `libc-2.21.so`
    and `ld-2.21.so` available in `/usr/lib64/`. Also, there is a character device
    `dev/pts/2` that has been opened.
  prefs: []
  type: TYPE_NORMAL
- en: Listing the applications that opened a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also find out which all applications opened a file. This can be done
    by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listing the applications that opened a file](img/4335_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can see that the `bash` file has been opened by six running
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the files opened by a user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To know the list of files opened by a specific user, run `lsof` with the `-u`
    option. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This means, currently `525` files are opened by the user root.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration or config files are regular files that contain settings for an
    application. During the initial stage of execution, many applications in Linux
    and UNIX read settings from config file(s) and configure the application accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and modifying configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration files are generally present in the `/etc/` directory and can be
    viewed using the `cat` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider viewing the `resolv.conf` config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `resolv.conf` file contains the order in which to contact DNS servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also modify a configuration file to meet our requirements. For example,
    we can add another DNS entry in the `/etc/resolv.conf` file with the DNS value
    `8.8.8.8`, if some of network URLs are accessible via `192.168.1.1`. The modified
    `cat /etc/resolv.conf` will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of other config files available in a system such as `ssh`, `passwd`,
    `profile`, `sysconfig`, `crontab`, `inittab`, and so on, in the `/etc/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now know that the UNIX and Linux-based
    operating system treats everything as files that can be further categorized as
    regular, directory, link, block device, character device, socket, and pipe files.
    You should also know how to perform basic operations on any of these files. Now,
    you should have good knowledge of how to view and modify the permissions and ownership
    of a file. You should also know how to monitor and manage the list of open files
    in a system using the `lsof` command.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how a process gets created in a system and
    how to monitor and manage all running processes. We will also see how two or more
    processes communicate with each other using **Inter Process Communication** (**IPC**)
    mechanism.
  prefs: []
  type: TYPE_NORMAL
