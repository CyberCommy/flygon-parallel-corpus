- en: Chapter 3. Building Base and Layered Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about building base and layered images for production-ready
    containers. As we saw, Docker containers provide us with ideal environments in
    which we can build, test, automate, and deploy. The reproductive nature of these
    exact environments affords a higher degree of efficacy and confidence that currently
    available script-based deployment systems cannot readily duplicate. The images
    a developer locally builds, tests, and debugs can then be pushed directly into
    staging and production environments as the test environment is nearly a mirror
    image under which the application code runs.
  prefs: []
  type: TYPE_NORMAL
- en: Images are the literal foundational component of containers, defining what flavor
    of Linux to deploy and what default tools to include and make available to the
    code running inside the container. Image building is, therefore, one of the most
    critical tasks in the application containerization life cycle; correctly building
    your images is critical for effective, repeatable, and secure functionality of
    containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: A container image consists of a set of runtime variables for your application
    container. Ideally, container images should be as minimal as possible, providing
    the required functionalities only, as this helps in efficient handling of the
    container image, significantly reducing the time to upload and download the image
    from the registry and having a minimal footprint on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Our focus, intent, and direction is in building, debugging, and automating images
    for your Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Building container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building base images from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official base images from Docker registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building layered images from Dockerfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging images through testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated image building with testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this book attempts to *troubleshoot Docker*, wouldn't it prove beneficial
    to reduce our chances for errors that we would have to troubleshoot in the first
    place? Fortunately for us, the Docker community (and the open source community
    at large) provides a healthy registry of base (or *root*) images that dramatically
    reduce errors and provide more repeatable processes. Searching the **Docker Registry**,
    we can find official and automated build statuses for a broad and growing array
    of container images. The Docker official repositories ([https://docs.docker.com/docker-hub/official_repos/)](https://docs.docker.com/docker-hub/official_repos/) are
    carefully organized collections of images supported by Docker Inc.-automated repositories
    that allow you to validate source and content of a particular image also exist.
  prefs: []
  type: TYPE_NORMAL
- en: A major thrust and theme of this chapter will be in basic Docker fundamentals;
    while they may seem trivial to the experienced container user, following some
    best practices and levels of standardization will serve us well in avoiding trouble
    spots in addition to enhancing our abilities to troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: Official images from the Docker Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standardization is a major component for repeatable processes. As such, wherever
    and whenever possible, one should opt for a standard base image as provided in
    the **Docker Hub** for the variant Linux distributions (for example, CentOS, Debian,
    Fedora, RHEL, Ubuntu, and others) or for specific use cases (for example, WordPress
    applications). Such base images are derived from their respective Linux platform
    images, and are built specifically for use in containers. Further, standardized
    base images are well maintained and updated frequently to address security advisories
    and critical bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: These base images are built, validated, and supported by Docker Inc. and are
    easily recognized by their single word names (for example, `centos`). Additionally,
    user members of the Docker community also provide and maintain prebuilt images
    to address certain use cases. Such user images are denoted with the prefix of
    the Docker Hub username that created them, suffixed with the image name (for example,
    `tutum/centos`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Official images from the Docker Registry](graphics/image_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To our great advantage, these standard base images remain ready and are publicly
    available on the Docker Registry; images can be searched for and retrieved simply
    using the `docker search` and `docker pull` Terminal commands. These will download
    any image(s) that are not already located on the Docker host. The Docker Registry
    has become increasingly powerful in providing official base images for which one
    can use directly, or at least as a readily available starting point toward addressing
    the needs of your container building.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While this book assumes your familiarity with Docker Hub/Registry and GitHub/Bitbucket,
    we will dedicate initial coverage of these as your first line of reference for
    efficient image building for containers. You can visit the official registry of
    Docker images at [https://registry.hub.docker.com/](https://registry.hub.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Official images from the Docker Registry](graphics/image_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Docker Registry can be searched from your Docker Hub account or directly
    from the Terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Flags can be applied to your search criteria to filter images for star ratings,
    automated builds, and many more. To use the official `centos` image from the registry,
    from a Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo docker pull centos`: This will download the `centos` image to your
    host machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ sudo docker run centos`: This will first look for this image localized on
    your host and, if not found, it will download the image to host. The run parameters
    for the image will have been defined in its Dockerfile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Further, as we have seen, we are not limited merely to the repositories of official
    Docker images. Indeed, a wealth of community users (both as individuals and from
    corporate enterprises) have prepared images constructed to meet certain needs.
    As an example, an `ubuntu` image is created to run the `joomla` content management
    system within a container running on Apache, MySql, and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a user repository with just such an image (`namespace/repository
    name`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![User repositories](graphics/image_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Try it out:** Practice an image `pull` and `run`from the Docker Registry
    from the Terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo docker pull cloudconsulted/joomla`'
  prefs: []
  type: TYPE_NORMAL
- en: pulls our base image for a container and `$ sudo docker run -d -p 80:80 cloudconsulted/joomla`
    runs our container image and maps port `80` of the host to port `80` of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Point your browser to `http://localhost` and you will have the build page for
    a new Joomla website!
  prefs: []
  type: TYPE_NORMAL
- en: Building our own base images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There may be occasion, however, when we need to create custom images to suit
    our own development and deployment environment. If your use case dictates using
    a nonstandardized base image, you will need to roll your own image. As with any
    approach, appropriate planning beforehand is necessary. Before building an image,
    you should spend adequate time to fully understand the use case your container
    is meant to address. There isn't much need for a container that cannot run the
    intended application. Other considerations may include whether the library or
    binary you are including in the image is reusable, and many more. Once you feel
    you are done, review your needs and requirements once more and filter out parts
    that are unnecessary; we do not want to bloat our containers for no good reason.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker Registry, you may find automated builds. These builds are pulled
    from repositories at GitHub/Bitbucket and can, therefore, be forked and modified
    to your own specifications. Your newly forked repository can then in turn be synced
    to the Docker Registry with your new image, which can then be pulled and run as
    needed for your containers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Try it out**: Pull the ubuntu minimal image from the following repository
    and drop it to your Dockerfile directory to create your own image:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo docker pull cloudconsulted/ubuntu-dockerbase` `$ mkdir dockerbuilder`
    `$ cd dockerbuilder`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open an editor (vi/vim or nano) and create a new Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo nano Dockerfile`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will delve into creating good Dockerfiles later as we talk about layered
    and automated image building. For now, we just want to create our own new base
    image, only symbolically going through the procedure and location for creating
    a Dockerfile. For the sake of simplicity, here we are just calling the base image
    from which we want to build our new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and close this Dockerfile. We now build our new image locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check to ensure our new image is listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note our **IMAGE ID** for **mynew-ubuntu**, as we will need it shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new public/private repository under your Docker Hub username. I''m
    adding the new repository here under `<namespace><reponame>` as `cloudconsulted/mynew-ubuntu`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building our own base images](graphics/image_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, return to the Terminal so that we can tag our new image to push to the
    new Docker Hub repository under our `<namespace>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure that our new image is correctly tagged for `<namespace><repository>`
    in our images list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Also, we will find our newly created image labeled for pushing it to our Docker
    Hub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s push the image up to our Docker Hub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, check the Hub for our new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building our own base images](graphics/image_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are essentially two approaches to building your own Docker images:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually constructing layers interactively via bash shell to install necessary
    applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating through a Dockerfile that builds the images with all necessary applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building images using the scratch repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Going about building your own container images for Docker is highly dependent
    on which Linux distribution you intend to package. With such variance, and with
    the prevalence and growing registry of images already available to us via the
    Docker Registry, we won't spend much time on such a manual approach.
  prefs: []
  type: TYPE_NORMAL
- en: Here again, we can look in the Docker Registry to provide us with a minimal
    image to use. A `scratch` repository has been created from an empty TAR file that
    can be utilized simply via `docker pull`. As before, make your Dockerfile according
    to your parameters, and you have your new image, from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process can be even further simplified by making use of available tools,
    such as **supermin** (Fedora systems) or **debootstrap** (Debian systems). Using
    such tools, the build process for an Ubuntu base image, for example, can be as
    simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Building layered images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A core concept and feature of Docker is layered images. One of the most important
    features of Docker is **image layering** and the management of image content.
    A layered approach for container images is very efficient, as you can reference
    the contents in the image, identifying the layer in a layered image. This is very
    powerful when building multiple images, using the Docker Registry to push and
    pull images.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building layered images](graphics/image_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Image Copyright © Docker, Inc.]'
  prefs: []
  type: TYPE_NORMAL
- en: Building layered images using Dockerfiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Layered images are primarily built using the **Dockerfile**. In essence, a Dockerfile
    is a script that automatically builds our containers from a source (*base* or
    *root*) image in the order you need them executed by the Docker daemon, step by
    step, layer upon layer. These are successive commands (instructions) and arguments
    enlisted within the file that execute a proscribed set of actions on a base image,
    with each command constituting a new layer, in order to build a new one. This
    not only facilitates the organization of our image building but greatly enhances
    deployments from beginning to end through its simplification. The scripts within
    a Dockerfile can be presented to the Docker daemon in a range of ways to build
    new images for our containers.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile construction
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first command of a Dockerfile is typically the `FROM` command. `FROM` specifies
    the base image to be pulled. This base image can be located in the public Docker
    registry ([https://www.docker.com/](https://www.docker.com/)) within a private
    registry or even a localized Docker image from the host.
  prefs: []
  type: TYPE_NORMAL
- en: Additional layers in a Docker image are populated as per the directives defined
    in the Dockerfile. Dockerfiles have very handy directives. Every new directive
    defined in the Dockerfile constitutes a **layer** in a layered image. With a `RUN` directive,
    we can specify a command to be run, with the result of the command as an additional
    layer in the image.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is highly advised to logically group the operations performed in an image
    and keep the number of layers to a minimum. For example, while trying to install
    the dependencies for your application, one can install all the dependencies in
    one `RUN` directive rather than using *N* number of directives per dependency.
  prefs: []
  type: TYPE_NORMAL
- en: We will inspect more closely, the aspects of Dockerfiles for automation in a
    later section, *Automated image building*. For now, we need to make certain that
    we grasp the concept and construction of the Dockerfile itself. Let's look specifically
    at a simple list of commands that can be employed. As we have seen before, our
    Dockerfile should be created in a working directory containing our existing code
    (and/or other dependencies, scripts, and others).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**CAUTION:** Avoid use of the root [`/`] directory as root of your source repository.
    The `docker build` command makes use of the directory containing your Dockerfile
    as the build context (including all of its subdirectories). The build context
    will be sent to the Docker daemon before building the image, which means if you
    use `/` as the source repository, the entire contents of your hard drive will
    get sent to the daemon (and thus to the machine running the daemon). In most cases,
    it is best to put each Dockerfile in an empty directory. Then, only add the files
    needed for building the Dockerfile to the directory. To increase the build''s
    performance, a `.dockerignore` file can be added to the context directory to properly
    exclude files and directories.'
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile commands and syntax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While simplistic, the order and syntax of our Dockerfile commands are extremely
    important. Proper attention to details and best practice here will not only help
    ensure successful automated deployments, but also serve to help in any troubleshooting
    efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's delineate some basic commands and illustrate them directly with a working
    Dockerfile; our `joomla` image from before is a good example of a basic layered
    image build from a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our sample joomla base image is located in the public Docker index via
  prefs: []
  type: TYPE_NORMAL
- en: '`cloudconsulted/joomla`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**FROM**'
  prefs: []
  type: TYPE_NORMAL
- en: A proper Dockerfile begins with defining an image `FROM`, from which the build
    process starts. This instruction specifies the base image to be used. It should
    be the first instruction in Dockerfile, and it is a must for building an image
    via Dockerfile. You can specify the local image, an image present at the Docker
    public registry, or image at a private registry.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`<tag>` and `<digest>` are optional; if you do not specify them, it defaults
    to `latest`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Dockerfile from our Joomla Image**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we define the base image to be used for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**MAINTAINER**'
  prefs: []
  type: TYPE_NORMAL
- en: This line designates the *Author* of the built image. This is an optional instruction
    in Dockerfile; however, one should specify this instruction with the name and/or
    e-mail address of the author. `MAINTAINER` details can be placed anywhere you
    prefer in your Dockerfile, so long as it is always post your `FROM` command, as
    they do not constitute any execution but rather a value of a definition (that
    is, just some additional information).
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Example Dockerfile from our Joomla Image**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we define the author for this container and image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**ENV**'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction sets the environment variable in Dockerfile. An environment
    variable set can be used in subsequent instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets one environment variable `<key>` with `<value>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding instruction sets two environment variables. Use the `=` sign
    between key and value of an environment variable and separate two environment
    key-values with space to define multiple environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Use quotes for value having spaces for environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the points to remember about `ENV` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Use single instruction to define multiple environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables are available when you create container from image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can review the environment variable from image using `docker inspect <image>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of environment variables can be changed at runtime by passing the `--env
    <key>=<value>` option to the `docker run` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example Dockerfile from our Joomla Image **'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we set the environment variables for Joomla and the Docker image running
    without an interactive Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**RUN**'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction allows you to run commands and yield a layer. The output of
    the `RUN` instruction will be a layer built for image under process. Command passed
    to the `RUN` instruction runs on the layers built before this instruction; one
    needs to take care of the orders.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `<command>` is executed in a shell -`/bin/sh -c` shell form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this particular form, you specify the `executable` and `parameters` in executable
    form. Ensure that you pass the absolute path of the executable in the command.
    This is useful for cases where the base image does not have `/bin/sh`. You can
    specify an executable, which could be your only executable in a base image and
    build the layers on top using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also useful if you do not want to use the `/bin/sh` shell. Consider
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Actually, this is a special form of example, where you specify multiple commands
    separated by `;`. The `RUN` instruction executes such commands together and builds
    a single layer for all of the commands specified.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Dockerfile from our Joomla Image**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we update the package manager and install required dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have purposefully written so that new packages are to be added
    as their own apt-get install lines, following the initial install commands.
  prefs: []
  type: TYPE_NORMAL
- en: This is done so that, should we ever need to add or remove a package, we can
    do so without requiring to re-install all other packages within our Dockerfile.
    Obviously, this provides considerable savings in build time, should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Docker Cache:** Docker will first check against the host''s image cache for
    any matching layers from previous builds. If found, the given build step within
    the Dockerfile will be skipped to utilize the previous layer, from cache. As such,
    it is best practice to enlist each of the Dockerfile''s `apt-get -y install` commands
    on their own.'
  prefs: []
  type: TYPE_NORMAL
- en: As we've discussed, the `RUN` command in a Dockerfile will execute any given
    command under the context and filesystem of the Docker container, and produce
    a new image layer with any resulting file system changes. We first run `apt-get
    update` to ensure that the repositories and the PPAs of the packages are updated.
    Then, in separate calls, we instruct the package manager to install MySQL, Apache,
    PHP, and Supervisor. The `-y` flag skips interactive confirmation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of our necessary dependencies installed to run our service, we ought
    to tidy up a bit to give us a cleaner Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**ADD**'
  prefs: []
  type: TYPE_NORMAL
- en: This information is used to copy files and directories from the local filesystem
    or files from a remote URL into the image. The source and destination must be
    specified in `ADD` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Common Constructs**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the path of `<source_file>` is relative to the build context. Also, the
    path of `<destination_directory>` could either be absolute or relative to the
    `WORKDIR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple files, for example, `<file1>` , `<file2>`, and `<file3>`, are copied
    into `<destination_directory>`. Note that paths of these source files should be
    relative to the build context, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Contents of the `<source_directory>` are copied into `<destination_directory>` along
    with the filesystem metadata; the directory itself is not copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All the files starting with `text_` in the build context directory are copied
    in the `/text_files` directory in the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Filename with a space can be specified in quotes; one needs to use a JSON array
    to specify the ADD instruction in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the points to remember about `ADD` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: All new files and directories that are copied into the container image have
    UID and GID as `0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where the source file is a remote URL, the destination file will have
    a permission of `600`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the local files referenced in the source of the `ADD` instruction should
    be in the build context directory or in its subdirectories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the local source file is a supported tar archive then it is unpacked as a
    directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple source files are specified, the destination must be a directory
    and end with a trailing slash, `/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a destination does not exist, it will be created along with all the parent
    directories in the path, if required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example Dockerfile from our Joomla Image**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we download `joomla` into the Apache web root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**COPY**'
  prefs: []
  type: TYPE_NORMAL
- en: The `COPY` command specifies that a file, located at the input path, should
    be copied from the same directory as the Dockerfile to the output path inside
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: '**CMD**'
  prefs: []
  type: TYPE_NORMAL
- en: The `CMD` instruction has three forms-a shell form, as default parameters to
    `ENTRYPOINT` and the preferred executable form. The main purpose of a `CMD` is
    to provide defaults for an executing container. These defaults can either include
    or omit an executable, the latter of which must specify an `ENTRYPOINT` instruction
    as well. If the user specifies arguments to Docker `run`, then they will override
    the default specified in `CMD`. If you would like your container to run the same
    executable every time, then you should consider using `ENTRYPOINT` in combination
    with `CMD`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the points to remember:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not to confuse `CMD` with `RUN`-`RUN` will actually execute the command and
    commit the result, whereas `CMD` does not execute commands during a build, but
    instead specifies the intended command for the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Dockerfile can only execute one `CMD`; if you enlist more than one, only the
    last `CMD` will be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example Dockerfile from our Joomla Image**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we set up Apache for it to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the content of our completed Joomla Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Other common Dockerfile commands are as follows: **ENTRYPOINT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ENTRYPOINT` allows you to configure a container that will run as an executable.
    From Docker''s documentation, we will use the provided example; the following
    will start `nginx` with its default content, listening on port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Command-line arguments to `docker run <image>` will be appended after all elements
    in an executable form `ENTRYPOINT`, and will override all elements specified using
    `CMD`. This allows arguments to be passed to the entry point, that is, `docker
    run <image> -d` will pass the `-d` argument to the entry point. You can override
    the `ENTRYPOINT` instruction using the `docker run --entrypoint` flag.
  prefs: []
  type: TYPE_NORMAL
- en: '**LABEL**'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction specifies the metadata for the image. This image metadata can
    later be inspected using the `docker inspect <image>` command. The idea here is
    to add information about the image in image metadata for easy retrieval. In order
    to get the metadata from the image, one does not need to create a container from
    the image (or mount the image on local filesystem), Docker associates metdata
    data with every Docker image, and it has a predefined structure for it; using
    `LABEL`, one can add additional associated metadata describing the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The label for the image is a key-value pair. Following are examples of using
    `LABEL` in a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This instruction will add three labels to the image. Also, note that it will
    create one new layer as all the labels are added in a single `LABEL` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Use quotes in labels if the label value has spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If the value of the label is long, use backslash to extend the label value to
    a new line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Multiple labels for an image can be defined by separating them by **End Of Line**
    (**EOL**). Note that, in this case, there will be two image layers created for
    two different `LABEL` instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notes about `LABEL` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Labels are collated together as described in Dockerfile and those from the base
    image specified in the `FROM` instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `key` in labels are repeated, later one will override the earlier defined
    key's value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try specifying all the labels in a single `LABEL` instruction to produce an
    efficient image, thus avoiding unnecessary image layer count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To view the labels for a built image, use the `docker inspect <image>` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WORKDIR**'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction is used to set the working directory for subsequent `RUN`,
    `ADD`, `COPY`, `CMD`, and `ENTRYPOINT` instructions in Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Define a work directory in Dockerfile, all subsequent relative paths referenced
    inside the container will be relative to the specified work directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of using the `WORKDIR` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding instruction specifies `/opt/myapp` as the working directory for
    subsequent instructions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding instruction defines the work directory twice. Note that the second
    `WORKDIR` will be relative to the first `WORKDIR`. The result of the `pwd` command
    will be `/opt/myapp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Work directory can resolve the environment variables defined earlier. In this
    example, the `WORKDIR` instruction can evaluate the `SOURCEDIR` environment variable
    and the resultant working directory will be `/opt/src/myapp`.
  prefs: []
  type: TYPE_NORMAL
- en: '**USER**'
  prefs: []
  type: TYPE_NORMAL
- en: This sets the user for running any subsequent `RUN`, `CMD`, and `ENTRYPOINT` instructions.
    This also sets the user when a container is created and run from the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instruction sets the user `myappuser` for the image and container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Notes about `USER` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: One can override the user using `--user=name|uid[:<group|gid>]` in the `docker
    run` command for container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image testing and debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can applaud the benefits of containers, troubleshooting and effectively
    monitoring them currently present some complexity. Since by design, containers
    run in isolation, their resulting environment can be cloudy. Effective troubleshooting
    has generally required shell entry into the container itself, coupled with the
    complications of installing additional Linux tools to merely peruse information
    that is twice as hard to investigate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, available tools, methods, and approaches for meaningful troubleshooting
    of our containers and images has required installing additional packages in every
    container. This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for connecting or attaching directly to the container, which is
    not always a piddling matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limitations on inspection of a single container at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compounding these difficulties, adding unnecessary bloat to our containers with
    these tools is something we originally attempted to avoid in our planning; minimalism
    is one of the advantages we looked for in using containers in the first place.
    Let's take a look then at how we can reasonably glean useful information on our
    container images with some basic commands, as well as investigate emergent applications
    that allow us to monitor and troubleshoot containers from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: Docker details for troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have your image (regardless of building method) with Docker running,
    let's do some testing to make sure that all is copacetic with our build. While
    these may seem routine and mundane, it is a good practice to run any or all of
    the following as a *top-down* approach to troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: The first two commands here are ridiculously simple and seemingly too generic,
    but will provide base-level detail with which to begin any downstream troubleshooting
    efforts--`$ docker version` and `$ docker info`.
  prefs: []
  type: TYPE_NORMAL
- en: Docker version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s ensure that we firstly recognize what version of Docker, Go, and Git
    we are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Docker info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Additionally, we should understand our host operating system and kernel version,
    as well as storage, execution, and logging drivers. Knowing these things can help
    us troubleshoot from our *top-down* perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A troubleshooting note for Debian/Ubuntu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From a `$ sudo docker info` command, you may receive one or both of the following
    warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to add the following command-line parameters to the kernel in
    order to enable memory and swap accounting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For these Debian or Ubuntu systems, if you use the default GRUB bootloader,
    those parameters can be added by editing `/etc/default/grub` and extending `GRUB_CMDLINE_LINUX`.
    Locate the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, replace it with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Then, run `update-grub` and reboot the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Listing installed Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also need to ensure that the container instance has actually installed your
    image locally. SSH into the docker host and execute the `docker images` command.
    You should see your docker image listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*What if my image does not appear?* Check the agent logs and make sure that
    your container instance is able to contact your docker registry by curling the
    registry and printing out the available tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What $ sudo docker images tells us:** Our container image was successfully
    installed on the host.'
  prefs: []
  type: TYPE_NORMAL
- en: Manually crank your Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know our image is installed on the host, we need to know whether
    it is accessible to the Docker daemon. An easy way to test to make certain your
    image can be run on the container instance is by attempting to run your image
    from the command line. There is an added benefit here: we will now have the opportunity
    to additionally inspect application logs for further troubleshooting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What $ sudo docker run <imagename> tells us:** Our container image is accessible
    from the docker daemon and also provides accessible output logs for further troubleshooting.'
  prefs: []
  type: TYPE_NORMAL
- en: '*What if my image does not run?* Check for any running containers. If the intended
    container isn''t running on the host, there may be issues preventing it from starting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When a container fails to start, it does not log anything. Output of logs for
    container start processes are located in `/var/log/containers` on the host. Here,
    you will find files following the naming convention of `<service>_start_errors.log`.
    Within these logs, you will find any output generated by our `RUN` command, and
    are a recommended starting point in troubleshooting as to why your container failed
    to start.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**TIP:** Logspout ([https://github.com/gliderlabs/logspout](https://github.com/gliderlabs/logspout)) is
    a log router for Docker containers that runs inside Docker. Logsprout attaches
    to all containers on a host, then routes their logs wherever you desire.'
  prefs: []
  type: TYPE_NORMAL
- en: While we can also peruse the `/var/log/messages` output in our attempts to troubleshoot,
    there are a few other avenues we can persue, albeit a little more labor intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the filesystem state from cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've discussed, after each successful `RUN` command in our Dockerfiles,
    Docker caches the entire filesytem state. We can exploit this cache to examine
    the latest state prior to the failed `RUN` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish the task:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the Dockerfile and comment out the failing `RUN` command, in addition
    to any and subsequent `RUN` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-save the Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-execute `$ sudo docker build` and `$ sudo docker run`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image layer IDs as debug containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time Docker successfully executes a `RUN` command from a Dockerfile, a
    new layer in the image filesystem is committed. Conveniently, you can use those
    layers IDs as images to start a new container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Dockerfile as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then build from this Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the preceding image layer IDs to start new containers from
    `b750fe79269d`, `de1d48805de2`, and `40fd00ee38e1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We employ `--rm` to remove all the debug containers since there is no reason
    to have them around postruns.
  prefs: []
  type: TYPE_NORMAL
- en: '*What happens if my container build fails?* Since no image is created on a
    failed build, we''d have no hash of the container with which to ID. Instead, we
    can note the ID of the preceding layer and run a container with a shell of that
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Once inside the container, execute the failing command in attempt to reproduce
    the issue, fix the command and test, and finally update the Dockerfile with the
    fixed command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also want to start a shell and explore the filesystem, try out commands,
    and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Additional example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One final example is to comment out of the following Dockerfile, including
    the offending line. We are then able to run the container and docker commands
    manually and look into the logs in the normal way. In this example Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the failure is at shoot, then comment out as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, build and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Checking failed container processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if your container successfully runs from the command line, it would prove
    beneficial to inspect for any failed container processes, for containers that
    are no longer running, and checking our container configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check for failed or no-longer running containers
    and note the `CONTAINER ID` to inspect a given container''s configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note the **STATUS** of the containers. Should any of your containers, **STATUS**
    show exit codes other than `0`, there could be issues with the container's configuration.
    By way of an example, a bad command would result in an exit code of `127`. With
    this information, you can troubleshoot the task definition `CMD` field to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although somewhat limited, we can further inspect a container for additional
    troubleshooting details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s also analyze the container''s application logs. Error messages
    for container start failures are output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Other potentially useful resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$ sudo docker` top gives us a list of processes running inside a container.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo docker htop` can be utilized when you need a little more detail than
    provided by `top` in a convenient, cursor-controlled inferface. `htop` starts
    faster than `top`, you can scroll the list vertically and horizontally to see
    all processes and complete command lines, and you do not need to type the process
    number to kill a process or the priority value to recieve a process.'
  prefs: []
  type: TYPE_NORMAL
- en: By the time this book goes to print, it is likely that the mechanisms for troubleshooting
    containers and images will have dramatically improved. Much focus is being given
    by the Docker community toward *baked-in* reporting and monitoring solutions,
    in addition to market forces that will certainly bring additional options to bear.
  prefs: []
  type: TYPE_NORMAL
- en: Using sysdig to debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any newer technology, some of the initial complexities inherent with
    them are debugged in time, and newer tools and applications are developed to enhance
    their use. As we've discussed, containers certainly fit into this category at
    this time. While we have witnessed improvements in availability of official, standardized
    images within the Docker Registry, we are also now seeing emergent tools that
    help us to effectively manage, monitor, and troubleshoot our containers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sysdig to debug](graphics/image_03_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sysdig provides application monitoring for containers [Image Copyright © 2014
    Draios, Inc.]
  prefs: []
  type: TYPE_NORMAL
- en: '**Sysdig** ([http://www.sysdig.org/](http://www.sysdig.org/) [)](http://www.sysdig.org/) is
    one such tool. As an *au courant* application for system-level exploration and
    troubleshooting visibility into containerized environments, the beauty of `sysdig`
    is that we are able to access container data from the outside (even though `sysdig`
    can actually also be installed inside a container). From a top level, what `sysdig`
    brings to our container management is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to access and review processes (inclusive of internal and external PIDs)
    in each container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to drill-down into specific containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to easily filter sets of containers for process review and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysdig provides data on CPU usage, I/O, logs, networking, performance, security,
    and system state. To repeat, this is all accomplishable from the outside, without
    a need to install anything into our containers.
  prefs: []
  type: TYPE_NORMAL
- en: We will make continued and valuable use of `sysdig` going forward in this book
    to monitor and troubleshoot specific processes related to our containers, but
    for now we will provide just a few examples toward troubleshooting our basic container
    processes and logs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig into `sysdig` by getting it installed on our host to show off what
    it can do for us and our containers!
  prefs: []
  type: TYPE_NORMAL
- en: Single step installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Installation of `sysdig` can be accomplished in a single step by executing
    the following command as root or with `sudo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**NOTE:** `sysdig` is currently included natively in the latest Debian and
    Ubuntu versions; however, it is recommended to update/run installation for the
    latest packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the `sysdig` wiki, the advanced installation method may be useful
    for scripted deployments or containerized environments. It is also easy; the advanced
    installation method is enlisted for RHEL and Debian systems.
  prefs: []
  type: TYPE_NORMAL
- en: What are chisels?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started with `sysdig`, we should understand some of its parlance, specifically
    **chisels**. In `sysdig`, chisels are little scripts (written in Lua) that analyze
    the `sysdig` event stream to perform useful actions. Events are efficiently brought
    to user level, enriched with context, and then scripts can be applied to them.
    Chisels work well on live systems, but can also be used with trace files for offline
    analysis. You can run as many chisels as you''d like, all at the same time. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`topcontainers_error` chisel will show us the top containers by number of errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a list of sysdig chisels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sysdig -cl` (use the `-i` flag to get detailed information about a specific
    chisel)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single container processes analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the example of a `topprocs_cpu` chisel, we can apply a filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the example results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike using `$ sudo docker top` (and similar), we can determine exactly which
    containers we want to see processes for; for example, the following example shows
    us processes from only the `wordpress` containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Other Useful Sysdig Chisels & Syntax**'
  prefs: []
  type: TYPE_NORMAL
- en: '`topprocs_cpu` shows top processes by CPU usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`topcontainers_file` shows top containers by R+W disk bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`topcontainers_net` shows top containers by network I/O'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lscontainers` will list the running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ sudo sysdig -pc -cspy_logs` analyzes all logs per screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ sudo sysdig -pc -cspy_logs container.name=zany_torvalds` prints logs for
    the container `zany_torvalds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting - an open community awaits you
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, most issues you may face have likely been experienced by others,
    somewhere and sometime before. The Docker and open source communities, IRC channels
    and various search engines, can provide resulting information that is highly accessible
    and likely to provide you with answers to situations, and conditions, that perplex.
    Make good use of the open source community (specifically, the Docker community)
    in getting the answers you are looking for. As with any emergent technology, in
    the beginning, we are all somewhat learning together!
  prefs: []
  type: TYPE_NORMAL
- en: Automated image building
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways we can go about automating our processes for building container
    images; too many to reasonably provide a full disclosure of approaches within
    a single book. In later chapters of this book, we will delve more deeply into
    a range of automation options and tools. In this particular instance, we are only
    speaking of automation using our Dockerfile. We have already discussed in general
    that Dockerfiles can be used in automating our image building, so let's take a
    more dedicated look into Dockerfile automation specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tested deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During the build process, Docker allows us to run any command. Let's take advantage
    of this to enable unit tests while building our image. These unit tests can help
    to identify problems in our production image before we push them to staging or
    deployment, and will at least partially verify the image functions the way we
    intend and expect. If the unit tests run successfully, we have a degree of confidence
    that we have a valid runtime environment for our service. This also means that
    should the tests fail, our build will fail, effectively keeping a nonworking image
    out of its  production.
  prefs: []
  type: TYPE_NORMAL
- en: Using our `cloudconsulted/joomla` repository image from prior, we will set up
    a sample workflow for automated builds, with testing. **PHPUnit** is what we will
    use since it is officially used by the Joomla! project's development teams, as
    it can conveniently run unit tests against our entire stack-the Joomla code, Apache,
    MySQL, and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Drop in to your Dockerfile directory for `cloudconsulted/joomla` (in our case,
    `dockerbuilder`) and update it as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install PHPUnit executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'PHPUnit can also be installed executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's run our unit tests with `phpunit:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make sure that we `COPY` our unit tests to the assets inside
    our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, let''s do some house cleaning. To ensure that our production code cannot
    rely (accidentally or otherwise) on the test code, once the unit tests complete
    we should delete those test files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Our total updates to the Dockerfile included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a scripted Dockerfile that, each and every time we build this image,
    will fully test our Joomla code, Apache, MySQL, and PHP dependencies as a literal
    part of the build process. The results are a tested, reproducible production environment!
  prefs: []
  type: TYPE_NORMAL
- en: Automating tested deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our heightened confidence in producing workable images for deployment,
    this build process still requires a developer or DevOps engineer to rebuild the
    image before every production push. Instead, we will rely on automated builds
    from our Docker and GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Our GitHub and Docker Hub repositories will serve to automate our builds. By
    maintaining our Dockerfiles, dependencies, related scripts, and so on on GitHub,
    any pushes or commits to update files on the repository will automatically force
    an updating push to the synced Docker Hub repository. Our production images for
    pull on Docker Hub are automatically updated with any new build information.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Clouds is one of the latest offerings to complete the app life cycle,
    it provides a hosted registry service with build and testing facilities. Docker
    Cloud expands on the feature of Tutum and brings a tighter integration with Docker
    Hub. With the help of a Docker Cloud system, admins can deploy and scale applications
    in the cloud with just a few clicks. Continuous deliver the code integrated and
    automated with build, test and deployment workflows. It also provides visibility
    across the containers of the entire infrastructure and accesses the programmatic
    RESTful APIs for a developer-friendly CLI tool. Thus, Docker Cloud can be used
    for automating the build process and test deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the important features of Docker Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows the building of Docker images and also linking cloud repositories to
    a source code in order to ease the process of image building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows linking your infrastructure and cloud services to provision new nodes
    automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the image has been built, it can be used to deploy services and can be
    linked with Docker Cloud's collection of services and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swarm management in beta mode is available for creating swarm within Docker
    Clouds or registering the existing swarms to Docker Clouds using Docker ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker and Dockerfiles provide repeatable processes across the application development
    cycle, providing a distinctive facility for both developers and DevOps engineers-production-ready
    deployments, infused with the confidence of tested images and the ease of automation.
    This provides a high level of empowerment to those needing it most, and results
    in the continuous delivery of tested and production-ready image building that
    we can fully automate, extended as far out as, and across, our clouds.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned that a mission-critical task in a production-ready
    application containerization is image building. The building of base and layered
    images and avoiding areas for troubleshooting are the primary topics we covered.
    In building our base images, we saw that the Docker Registry provides ample and
    validated images that we can freely use for repeatable processes. We also canvassed
    building images manually, from scratch. Moving forward, we explored building layered
    images with a Dockerfile and enlisted the Dockerfile commands in detail. Finally,
    an example workflow illustrated automated image building with baked-in testing
    of images and containers. Throughout, we highlighted the ways and means for troubleshooting
    areas and options.
  prefs: []
  type: TYPE_NORMAL
- en: Building succinct Docker images for your application container is vitally crucial
    for your application's functionality and maintainability. Now that we have learned
    about building base and layered images and basic ways to troubleshoot them, we
    will look foward to building real application images. In our next chapter, we
    will learn about planning and building multiple-tier applications with a proper
    set of images.
  prefs: []
  type: TYPE_NORMAL
