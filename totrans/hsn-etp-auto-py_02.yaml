- en: Common Libraries Used in Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will walk you through how Python packages are structured and the
    common libraries used today to automate the system and network infrastructure.
    There's a long growing list of Python packages that cover network automation,
    system administration, and managing public and private clouds.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it's important to understand how to access the module source code and
    how the small pieces inside the Python package are related to each other so we
    can modify the code, add or remove features, and share the code again with the
    community.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Python packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Python libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing module source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Python packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python core code is actually small by design to maintain simplicity. Most functionalities
    will be through adding third-party packages and modules.
  prefs: []
  type: TYPE_NORMAL
- en: Module is a Python file that contains functions, statements, and classes that
    will be used inside your code. The first thing to do is `import` the module then
    start to use its functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'On other hand, a **package** collects related modules connected to each other
    and puts them in a single hierarchy. Some large packages such as `matplotlib`
    or `django` have hundreds of modules inside them, and developers usually categorize
    the related modules into a sub-directories. For example, the `netmiko` package
    contains multiple sub-directories and each one contains modules to connect to
    network devices from different vendors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Doing that gives the package maintainer the flexibility to add or remove features
    from each module without breaking the global package operation.
  prefs: []
  type: TYPE_NORMAL
- en: Package search paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, Python searches for modules in some specific system paths. You can
    print these paths by importing the `sys` module and printing the `sys.path`. This
    will actually return the strings inside the `PYTHONPATH` environment variable
    and inside the operating system; notice the result is just a normal Python list.
    You can add more paths to the search scope using a list function such as `insert()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s better to install the packages in the default search paths so
    the code won''t break when you share it with other developers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A simple package structure with a single module will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `__init__` file inside each package (in the global directory or in the sub-directory)
    will tell the Python interpreter that this directory is a Python package, and
    each file ending with `.py` will be a module file, which could be imported inside
    your code. The second function of the `init` file is to execute any code inside
    it once the package is imported. However, most developers leave it empty and just
    use it to mark the directory as a Python package.
  prefs: []
  type: TYPE_NORMAL
- en: Common Python libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next sections, we will explore the common Python libraries used for network,
    system, and cloud automation.
  prefs: []
  type: TYPE_NORMAL
- en: Network Python Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network environments nowadays contain multiple devices from many vendors, and
    each device plays a different role. Design and automation frameworks for network
    devices are essential to network engineers in order to automate repeated tasks
    and enhance the way they usually do their job, while reducing human errors. Large
    enterprises and service providers usually tend to design a workflow that can automate
    different network tasks and improve network resiliency and agility. The workflow
    contains a series of related tasks that together form a process or a workflow
    that will be executed when there's a change needed on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the tasks that could be performed by a network automation framework
    without human intervention are:'
  prefs: []
  type: TYPE_NORMAL
- en: Root cause analysis for the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking and updating the device operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discovering the topology and relationships between nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security audits and compliance reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and withdrawing routes from the network device based on the application
    needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing device configuration and rollback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some Python libraries that are used to automate network devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Network Library** | **Description** | **Link** |'
  prefs: []
  type: TYPE_TB
- en: '| Netmiko | A multi-vendor library that supports SSHing and Telnet for network
    devices and executes commands on it. Support includes Cisco, Arista, Juniper,
    HP, Ciena, and many other vendors. | [https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko)
    |'
  prefs: []
  type: TYPE_TB
- en: '| NAPALM | A Python library that works as a wrapper for the official Vendor
    API. It provides  abstraction methods that connect to devices from multiple vendors
    and extract information from it while returning the output in an structured format.
    This can be easily processed by software. | [https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)
    |'
  prefs: []
  type: TYPE_TB
- en: '| PyEZ | A Python library used to manage and automate Juniper devices. It can
    perform CRUD operation on the device from the Python client. Also, it can retrieve
    facts about the device such as the management IP, serial number, and version.
    The returned output will be in JSON or XML format. | [https://github.com/Juniper/py-junos-eznc](https://github.com/Juniper/py-junos-eznc)
    |'
  prefs: []
  type: TYPE_TB
- en: '| infoblox-client | A Python client used to interact with infoblox NIOS over
    the interface, based on a REST called WAPI. | [https://github.com/infobloxopen/infoblox-client](https://github.com/infobloxopen/infoblox-client)
    |'
  prefs: []
  type: TYPE_TB
- en: '| NX-API | A Cisco Nexus (some platforms only) series API that exposes the
    CLI through HTTP and HTTPS. You can enter a show command in the provided sandbox
    portal and it will be converted to an API call to the device and will return the
    output in JSON and XML format. | [https://developer.cisco.com/docs/nx-os/#!working-with-nx-api-cli](https://developer.cisco.com/docs/nx-os/#!working-with-nx-api-cli)
    |'
  prefs: []
  type: TYPE_TB
- en: '| pyeapi | A Python library that acts as a wrapper around the Arista EOS eAPI
    and is used to configure Arista EOS devices. The library supports eAPI calls over
    HTTP and HTTPs. | [https://github.com/arista-eosplus/pyeapi](https://github.com/arista-eosplus/pyeapi)
    |'
  prefs: []
  type: TYPE_TB
- en: '| netaddr | A Python library for working with network addresses such as IPv4,
    IPv6, and layer 2 addresses (MAC addresses). It can iterate, slice, sort, and
    summarize the IP block. | [https://github.com/drkjam/netaddr](https://github.com/drkjam/netaddr)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ciscoconfparse | A Python library that is able to parse a Cisco IOS-style
    configuration and returns the output in a structured format. The library also
    provides support for device configuration based on brace-delimited configurations
    such as Juniper and F5. | [https://github.com/mpenning/ciscoconfparse](https://github.com/mpenning/ciscoconfparse)
    |'
  prefs: []
  type: TYPE_TB
- en: '| NSoT | A database for tracking the inventory and metadata of network devices.
    It provides a frontend GUI based on Python Django. The backend is based on SQLite
    database where the data is stored. Also, it provides the API interface for the
    inventory using pynsot bindings. | [https://github.com/dropbox/nsot](https://github.com/dropbox/nsot)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Nornir | A new automation framework based on Python and consumed directly
    from Python code without a need to have custom  **DSL** (**Domain Specific Language**).
    The Python code is called runbook and contains a set of tasks that can run against
    the devices stored in the inventory (supports also Ansible inventory format).
    The tasks can utilize other libraries (such as NAPALM) to get information or configure
    the devices. | [https://github.com/nornir-automation/nornir](https://github.com/nornir-automation/nornir)
    |'
  prefs: []
  type: TYPE_TB
- en: System and cloud Python libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some of the python packages that can be used for both system and cloud
    administration. Public cloud providers such as **Amazon Web Services** (**AWS**)
    and Google tend to provide open and standard access to their resources in order
    to be easily integrated with the organization DevOps model. Phases like continuous
    integration, testing, and deployment require *continuous* access to infrastructure
    (either virtualized or bare metal servers) in order to complete the code life
    cycle. This can''t be done manually and needs to be automated:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Library** | **Description** | **Link** |'
  prefs: []
  type: TYPE_TB
- en: '| ConfigParser | Python standard library to parse and work with the INI files.
    | [https://github.com/python/cpython/blob/master/Lib/configparser.py](https://github.com/python/cpython/blob/master/Lib/configparser.py)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Paramiko | Paramiko is a Python (2.7, 3.4+) implementation of the SSHv2 protocol,
    providing both client and server functionality. | [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pandas | A library providing high-performance, easy-to-use data structures
    and data analysis tools. | [https://github.com/pandas-dev/pandas](https://github.com/pandas-dev/pandas)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `boto3` | Offifical Python interface that manages different AWS operations,
    such as creating EC2 instances and  S3 storage. | [https://github.com/boto/boto3](https://github.com/boto/boto3)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `google-api-python-client` | Google official API client library for Google
    Cloud Platform. | [https://github.com/google/google-api-python-client](https://github.com/google/google-api-python-client)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pyVmomi` | The official Python SDK from VMWare that manages ESXi and vCenter.
    | [https://github.com/vmware/pyvmomi](https://github.com/vmware/pyvmomi) |'
  prefs: []
  type: TYPE_TB
- en: '| PyMYSQL | A pure python MySQL driver to work with MySQL DBMS. | [https://github.com/PyMySQL/PyMySQL](https://github.com/PyMySQL/PyMySQL)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Psycopg | The PostgresSQL adapter for python which conforms to DP-API 2.0
    standard. | [http://initd.org/psycopg/](http://initd.org/psycopg/) |'
  prefs: []
  type: TYPE_TB
- en: '| Django | A high-level open source web framework based on Python. The framework
    follows the **MVT** (**Model, View, and Template**) architecture design for building
    web applications without the hassle of web development and common security mistakes.
    | [https://www.djangoproject.com/](https://www.djangoproject.com/) |'
  prefs: []
  type: TYPE_TB
- en: '| Fabric | A simple Python tool for  executing commands and software deployments
    on remote devices based on SSH. | [https://github.com/fabric/fabric](https://github.com/fabric/fabric)
    |'
  prefs: []
  type: TYPE_TB
- en: '| SCAPY | A brilliant Python-based packet manipulation that is able to handle
    a wide range of protocols and can build packets with any combination of network
    layers; it can also send them on the wire. | [https://github.com/secdev/scapy](https://github.com/secdev/scapy)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Selenium | A python library used to automate web-browser tasks and web-acceptance
    testing. The library works with Selenium webdrivers for Firefox, Chrome, and Internet
    Explorer to run tests on web browsers. | [https://pypi.org/project/selenium/](https://pypi.org/project/selenium/)
    |'
  prefs: []
  type: TYPE_TB
- en: 'You can find more of the python packages categorized into different areas at
    the following link: [https://github.com/vinta/awesome-python](https://github.com/vinta/awesome-python).'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing module source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can access the source code of any module that you use in two ways. First,
    go to the `module` page at [github.com](https://github.com/) and view all the
    files, releases, commits, and issues in one place, as in the following screenshot.
    I have read access to all shared code via the `netmiko` module maintainer and
    can see a full list of commits and file contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second method is to install the package itself in the Python site-package
    directory using `pip` or PyCharm GUI. What `pip` actually does is it goes to GitHub
    and downloads the module content and runs `setup.py` to install and register the
    module. You can see the module files, but this time you have full read/write access
    on all files and you can change the original code. For example, the following
    code leverages the `netmiko` library to connect to a Cisco device and execute
    the `show arp` command on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If I want to see the netmiko source code, I can go either to site-packages
    where the netmiko library installed and list all files *or* I can use *Ctrl* and
    left-click on the module name in PyCharm. This will open the source code in a
    new tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Visualizing Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever wondered how a Python custom module or class is manufactured? How does
    the developer write the Python code and glue it together to create this nice and
    amazing *x* module? What's going on under the hood?
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is a good start, of course, but we all know that it's not usually
    updated with every new step or detail that the developer added.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we all know the powerful netmiko library created and maintained
    by Kirk Byers ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko))
    that leverages another popular SSH library called Paramiko ([http://www.paramiko.org/](http://www.paramiko.org/)).
    But we don't understand the details and how the classes are related to each other.
    If you need to understand the magic behind netmiko (or any other library) in order
    to process the request and return the result, please follow the next steps (requires
    PyCharm professional edition).
  prefs: []
  type: TYPE_NORMAL
- en: Code visualization and inspection in PyCharm is not supported in PyCharm community
    edition and is only supported in the professional version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps you need to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the netmiko module source code inside the Python library location folder
    (usually `C:\Python27\Lib\site-packages` on Windows or `/usr/local/lib/pyhon2.7/dist-packages`
    on Linux) and open the file from PyCharm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the module name that appears in the address bar and choose Diagrams
    | Show Diagram. Select Python class diagram from the pop-up window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'PyCharm will start to build the dependency tree between all classes and files
    in the `netmiko` module and then will show it in the same window. Note this process
    may require some time depending on your computer memory. Also, it''s better to
    save the graph as an external image to view it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Based on the resulting graph, you can see that Netmiko is supporting a lot of
    vendors such as HP Comware, entrasys, Cisco ASA, Force10, Arista, Avaya, and so
    on, and all of these classes are are inheriting from the                     
        `netmiko.cisco_base_connection.CicsoSSHConnection` parent class (I think this
    is because they use the same SSH style as Cisco). This in turn inherits from another
    big parent class called `netmiko.cisco_base_connection.BaseConnection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can see that Juniper has its own class (`netmiko.juniper.juniper_ssh.JuniperSSH`)
    that connects directly to the big parent. Finally, we connect to the parent of
    all parents in python: the `Object` class (remember everything in Python is an
    object in the end).'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a lot of interesting things such as an *SCP transfer* class and *SNMP*
    class, and with each one you will find the methods and parameters used to initialize
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the `ConnectHandler` method is primarily used to check the `device_type`
    availability in the vendor classes and, based on returned data, it will use the
    corresponding SSH class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Another way to visualize your code is to see exactly which modules and functions
    are being hit during code execution. This is called profiling and it allows you
    to examine the functions during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to write your code as usual and then right-click on an empty
    space and select profile instead of running the code as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Wait for the code to be executed. This time PyCharm will inspect each file
    that is called from your code and generate the *call graph* for the execution
    so you can easily know which files and functions are used and count the execution
    time for each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the previous graph, our code in `profile_code.py` (bottom
    of the graph) will call the `ConnectHandler()`  function which in turn will execute `__init__.py`,
    and execution will continue. On the graph's left side, you can see all files that
    it touched during your code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored some of most popular network, system, and cloud
    packages provided in Python. Also, we learned how to access the module source
    code and to visualize it for better understanding of the internal code. We looked
    at the call flow for code while running. In the next chapter, we will start building
    a lab environment and apply our code to it.
  prefs: []
  type: TYPE_NORMAL
