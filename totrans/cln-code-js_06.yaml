- en: Naming Things Is Hard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Names are everywhere. They are our mind's way of abstracting the complexity
    of the universe. In the world of software, we are always engaged in crafting new
    abstractions to describe our everyday realities. A common quip in the programming
    world is *naming things is hard*. Coming up with a name isn't always hard, but
    coming up with a *good* name usually is.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we have explored the principles and theory underlying
    abstractions. In this chapter, we'll provide the final key to the puzzle. An abstraction
    cannot be a good abstraction without good naming. In the names we use, we are
    distilling a concept, and that distillation will define how people end up understanding
    the concept. So, naming things isn't just the provision of arbitrary labels; it
    is the provision of understanding. Only via a good name can a user or other programmer
    be able to internalize our abstraction fully and navigate it with a full understanding.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will use some examples to explore the key characteristics
    that make a good name. We'll also discuss the challenges of naming things in a
    dynamically typed language such as JavaScript. We should come away from this chapter
    with a clear understanding of what is involved in coming up with clean and descriptive
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What's in a name?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency and hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques and consideration*s*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's in a name?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breaking down the key elements of a good name is difficult. It seems to be more
    of an art than a science. The boundary between quite a good name and a very good
    name is fuzzy and liable to subjective opinions.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a function that is responsible for applying multiple CSS styles to
    a button. Imagine a scenario in which this is a standalone function. Which of
    the following names would you consider to be the most suitable?
  prefs: []
  type: TYPE_NORMAL
- en: '`styleButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setStyleOfButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setButtonCSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stylizeButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setButtonStyles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applyButtonCSS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You''ve likely picked your favorite. And there is, among those of you reading
    this book, bound to be disagreements. Many of these disagreements will be founded
    in our own biases. And many of our biases will have been conditioned by factors
    such as what language we speak, what programming languages we''ve been previously
    exposed to, and what types of programs we spend our time creating. There are many
    variances that exist between all of us and yet, somehow, we have to come up with
    a non-fuzzy concept for what a good or clean name is. At the very least, we can
    say that a good name might have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Purpose**: What something is for and how it behaves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concept**: Its core idea and how to think about it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contract**: Expectations about how it works'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This doesn't completely cover the complexity of naming, but with these three
    characteristics, we have a starting point. In the remainder of this section, we
    will learn how each of these characteristics is vital to the process of naming
    things.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good name indicates **purpose**. Purpose is what something does, or what something
    *is*. In the case of a function, its purpose is its behavior. This is why functions
    are typically named in the verbal form, such as `getUser` or `createAccount`,
    whereas things that store values are usually nouns, such as *account* or *button*.
  prefs: []
  type: TYPE_NORMAL
- en: A name that encapsulates a clear purpose will never need further explanation.
    It should be self-evident. If a name requires a comment to explain its purpose,
    then that is usually an indicator that it has not done its job as a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of something is highly contextual and so will, therefore, be informed
    by the surrounding code and the area of the codebase in which that name resides.
    This is why it''s often okay to use a generic name as long as it is surrounded
    by context that helps to inform its purpose. For example, compare these three
    method signatures within the `TenancyAgreement` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are subjectivities to this, of course, but most people would agree that,
    when we have a surrounding context that communicates its purpose well, we shouldn''t
    need to granularize the naming of every variable within that context. With this
    in mind, we can say that `Option #1` in the preceding code is too limited and
    may invite ambiguity and that `Option #3` is needlessly verbose as parts of its
    argument names are already provided by its context. `Option #2`, however, with `documentId` and `documentTimestamp`,
    is just right: it sufficiently communicates the purpose of the arguments. And
    this is all we need.'
  prefs: []
  type: TYPE_NORMAL
- en: Purpose is absolutely central to any name. Without a description or an indication
    of purpose, a name is merely decoration, and can often mean that users of our
    code are left rummaging around between documentation and other pieces of code
    just to figure something out. Therefore, we must remember to always consider whether
    our names communicate purpose well.
  prefs: []
  type: TYPE_NORMAL
- en: Concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good name indicates **concept**. A name''s concept refers to the idea behind
    it, the intent in its creation, and how we should think about it. For example,
    a function named `relocateDeviceAccurately` not only tells us what it will do
    (its purpose) but informs us about the concept surrounding its behavior. From
    this name, we can see that devices are things that can be located and that locating
    such devices can be done at different levels of accuracy. A relatively simple
    name can arouse a rich concept within the minds of those who read it. This is
    part of the vital power of naming things: names are avenues to understanding.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A name''s concept, like its purpose, is strongly tied to the context in which
    it exists. Context is the *shared space* that our names exist within. The other
    names that surround the name we''re interested in are absolutely instrumental
    in helping us understand its concept. Imagine the following names together:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rejectedDeal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`acceptedDeal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pendingDeal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stalledDeal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By these names, we immediately understand that a *deal* is something that can
    have at least four different states. It is implied that these states are mutually
    exclusive and cannot apply to a deal at the same time, although that is unclear
    at this time. We are likely to assume that there are specific conditions related
    to whether a deal is pending or stalled, although we're not sure what those conditions
    are. So, even though there is ambiguity here, we are already starting to build
    up a rich understanding of the problem domain. That's just by looking at names—without
    even reading the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have spoken about context as a kind of *shared space* for names. In programming
    vernacular, we usually say that things named together in one area occupy a single
    namespace. A namespace can be thought of as a place where things share a conceptual
    area with each other. Some languages have formalized the concept of a namespace
    into its own language construct (often called a **package**, or simply a namespace).
    Even without such formal language constructs, JavaScript still makes it possible
    to construct namespaces via hierarchical constructs such as objects like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Most programmers tend to think of namespaces as a very formal construct, but
    this isn''t often the case. Often, without knowing it, we are composing implied
    namespaces when we write functions with functions within them. Instead of being
    delineated by a level of an object hierarchy, the namespaces, in this case, are
    delineated by the scopes of our functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are making a request to an endpoint, via `fetch`, and before we return,
    we are gathering the required data via tapping into the promise returned by `fetch`.
    To do this, we use two `then(...)` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: A **promise** is a natively provided class that provides a useful abstraction
    for handling asynchronous actions. You can usually identify a promise by its then method,
    like what we used in the preceding code. It's common practice to either use promises
    or callbacks when tapping into asynchronous actions. You can read more about this
    in [Chapter 10](b41df1c6-fc76-4d51-b95c-ae39ab040ab1.xhtml), *Control Flow*, in
    the *Asynchronous control flow* section.
  prefs: []
  type: TYPE_NORMAL
- en: Our first `then(...)` handler names its argument *response*, while the second
    one names its argument `data`. Outside the context of `makeFilteredRequest`, these
    terms would be very ambiguous. However, because we are within the implied namespace of
    a function related to making a filtered request, the terms *response* and *data*
    are sufficient to communicate their concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concepts communicated by our names, much like their purposes, are heavily
    intertwined with the contexts in which they are specified, so it''s important
    to consider not only the name itself but everything that surrounds it: the complex
    mesh of logic and behavior in which it resides. All code deals with some level
    of complexity, and a conceptual understanding of that complexity is crucial in
    being able to harness it. So, when naming something, it helps to ask yourself:
    *How do I want them to understand this complexity? *This is relevant if you''re
    crafting a simple interface to be consumed by other programmers, writing a deeply
    embedded hardware driver, or creating a GUI for non-programmers to consume.'
  prefs: []
  type: TYPE_NORMAL
- en: Contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good name indicates a **contract** with other parts of the surrounding abstraction.
    A variable, by its name, may indicate how it will be used or what type of value
    it contains and what general expectations we should have about its behavior. It''s
    not usually thought about, but when we name something, we are, in fact, setting
    up a series of implicit expectations or *contracts* that will define how people
    understand and use that thing. Here are some examples of the hidden contracts
    that exist in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable prefixed with *is*, for example, `isUser`, is expected to be a Boolean
    type (either `true` or `false`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable in all-caps is expected to be a constant (only set once and immutable),
    for example, `DEFAULT_USER_EXPIRY`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables named plurally (for example, elements) are expected to contain one
    or more items in a set-like object (for example, an array), whereas singularly
    named variables (for example, element) are only expected to contain one item (not
    in a set).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions with names beginning with `get`, `find`, or `select` are usually expected
    to return something to you. Functions beginning with `process`, `build`, or `run` are
    more ambiguous and may not do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property or method names beginning with an underscore, such as `_processConfig`,
    are usually intended to be internal to an implementation or pseudo-private. They
    are not intended to be called publicly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether we like it or not, all names carry with them the baggage of unavoidable
    expectations regarding their values and behaviors. It's important to be aware
    of these conventions so that we do not accidentally break the contracts that other
    programmers rely on. Every convention will have an exception where it doesn't
    apply, of course, but nonetheless, we should try to abide by them where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there isn't a canonical list where all of these contracts have
    been defined. They are usually quite subjective and will depend on the code base.
    Nonetheless, where we do encounter such conventions, we should follow them. As
    we mentioned in [Chapter 2](fd19fa13-f04a-4e03-9bc3-ba318cacf731.xhtml), *The
    Tenets of Clean Code*, ensuring familiarity is a great way to increase the maintainability
    of our code. And there is no better way to ensure familiarity than to adopt conventions
    that other programmers have come to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these implied contracts are related to types, and JavaScript, as you
    may be aware, is dynamically typed. This means the types of values will be determined
    at runtime, and the type contained by any variable may be liable to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The fact that a variable can refer to many different types means that the contracts
    and conventions implied by the names we adopt are even more important. There is
    no static type checker to help us. We are left alone at the chaotic whim of ourselves
    and other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we'll discuss **Hungarian notation**, a type of naming
    that is useful in dynamically typed languages. Also, it's useful to know that
    there are various static type checking and type annotating tools available for
    JavaScript if you find dealing with its dynamism painful. These will be covered
    in [Chapter 15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml), *Tools for Cleaner
    Code*.
  prefs: []
  type: TYPE_NORMAL
- en: Contracts are not only important because of JavaScript's dynamically typed nature.
    They are fundamentally useful in giving us confidence in how certain values behave
    and what we can expect from them throughout the runtime of our program. Imagine
    if there was an API with a method called `getCurrentValue()` that didn't always
    return the current value. That would break its implied contract. Seeing names
    through the lens of contracts is quite a mind-warper. Soon, you will begin to
    see contracts everywhere – contracts between variables, between interfaces, and
    at the integration level between entire architectures and systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed the three characteristics of a good name (purpose,
    concept, contract), we can begin to explore some anti-patterns, that is, ways
    of naming things that we should try to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Naming anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like the abstraction-building warnings of DRY and YAGNI, naming has its
    own warnings and anti-patterns. There are many ways to compose a bad name, and
    nearly all of them can be split into three broad naming anti-patterns: **needlessly
    short names**, **needlessly exotic names**, and **needlessly long names****.**'
  prefs: []
  type: TYPE_NORMAL
- en: Names are the initial lenses via which we and others will view the abstractions
    we build. Therefore, it is vital to know how to avoid creating lenses that only
    end up obscuring understanding and complicating things for other programmers.
    Let's begin by exploring needlessly short names and how they can end up drastically
    limiting our ability to understand what something does.
  prefs: []
  type: TYPE_NORMAL
- en: Needlessly short names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Names that are too short are usually employing either program-specific knowledge
    or domain-specific knowledge that may not generalize well to the audience of the
    code. A lone programmer may think it reasonable to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We are able to discern the fact that it is related to IDs and its purpose is
    to conditionally increment a specific object''s `n` property within the `ids` array.
    Therefore, it is possible to discern what it is doing on a functional level, but
    its meaning and intent are difficult to grasp. The programmer has used single-letter
    names (`f`, `x`, `n`) and has also employed an abbreviated function name (`incId`).
    Most of these names fail to fulfill the basic characteristics that we desire from
    a name: to indicate purpose, concept, and contract. We can only guess at these
    names'' purposes and concepts by how they are being used. It would vastly help
    to refactor this with more meaningful names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We now have a far clearer idea of what's going on. The arrays being iterated
    over contains jobs. The function's purpose is to find jobs with a specified ID
    and conditional on that job satisfying a specified filter. It increments the job's `nInstances`
    property by `1`. Via these new names, we already have a far richer conceptual
    understanding of this abstraction. We now understand that jobs are items that
    can have any number of instances and that the number of current instances is tracked
    via the `nInstances` property. Via the lenses provided by the names, we have been
    able to understand the underlying problem domain more clearly. Now, we can see
    that names are not just decoration or needless verboseness; names are the very
    essence of your abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A needlessly short name is, in many ways, just an insufficiently meaningful
    name. However, a name being short does not necessarily indicate a problem. The
    iterator variable, `i`, which we used in the preceding code, is perfectly fine
    as it is a convention that has established itself over decades. Programmers all
    over the world understand the conceptual and contractual implications of it: it
    is used only to iterate through an array and to access array elements at each
    stage of the iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: On the whole, and outside of rare exceptions such as our iteration variable,
    it is incredibly important to avoid the deficit in meaning that is invited by
    short names. They are often composed initially with haste or laziness and may
    even give the programmer attuned to their meaning a sense of accomplishment. After
    all, being able to wield obscure logic is a gift for the ego. But as we've covered,
    the ego is not a friend to clean code. Whenever you feel the urge to use a short
    name, push back on the impulse and take the time to pick a name that is richer
    in meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Needlessly exotic names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another avenue for the ego is in the proliferation of exotic names. Exotic
    names are those that draw unnecessary attention to themselves and are often obscure
    or elusive in meaning, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an ostensibly simple piece of behavior obscured by needlessly exotic
    names. We can, with minimal effort, make a world of difference to the comprehensibility
    of these abstractions with only a couple of tweaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Names, on the whole, should be boring. They should not draw attention to themselves.
    They should sit there with only their plain meaning on display and nothing that
    makes fellow programmers go, *oh that''s what it means!* or *hehe clever!* Our
    egos may have their own ideas about naming, but we should remember to limit the
    ego and think purely of the people who must endure the task of trying to understand
    our code and the interfaces we''ve created. On the whole, the following advice
    will keep us on the right track:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid fancy or longer synonyms of regular words**: For example, using `kill`
    or `obliterate`instead of `delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid words that don''t exist**: For example, `deletify`, `elementize`, or `dedupify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid puns or clever insinuations**: For example, using chemical element
    names to refer to DOM elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being overly exotic risks alienating our audience. You may be able to easily
    understand the names you've adopted, but that does not mean they are easily understood
    by others. The wider programming community is incredibly diverse and has many
    different cultural and linguistic backgrounds. It's best to stick to names that
    are descriptive and boring so that your code is understandable to as many people
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Needlessly long names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve already discovered, the needlessly short name is, in fact, a name
    without sufficient meaning. The needlessly long name is, therefore, a name with
    too much meaning. You may wonder how a name could have too much meaning. Meaning
    is a good thing, but too much meaning crushed into a single name can only serve
    to confuse; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This name is hard to understand: is it refreshing and saving documents that
    are signed and documents that are non-pending, or is it refreshing and saving documents
    that are both signed and non-pending? It''s unclear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This long name gives us a clue that the underlying abstraction is needlessly
    complex. We can split the name into its constituent parts to get a full grasp
    of its interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '**refresh (verb)**: The refreshing action that occurs on a document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**save (verb)**: The saving action that occurs on a document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**signed (adjective)**: The signed state of a document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**non-pending (adjective)**: The non-pending state of a document'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**document (noun)**: The document itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a few different things happening here. With names this long, a good
    guideline is to refactor the underlying abstraction so that we only need a name
    with, at most, one verb, one adjective, and one noun. For example, we could take
    our long name and split its function into four distinct functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if the intent is to perform actions on documents that carry
    multiple states (`SIGNED` and `NON_PENDING`), then we could implement a method
    like this for refreshing (and a similar one for the saving action):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The point is that long names are a clue to a broken or confused abstraction.
    Making a name more understandable usually goes hand in hand with making an abstraction
    more understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with short names, the problem is not the length of the name itself: it is
    what the length usually indicates. With long names, what is indicated is crushing
    too much meaning into a single name, indicating a confused abstraction.'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency and hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve talked about the three most important characteristics of a name:
    *purpose,* *concept,* and *contract*. One of the easiest ways to bestow these
    characteristics upon your names is to use consistency and hierarchy to your benefit.
    Consistency here refers to using the same pattern of naming across many different
    names within a given area of code. Hierarchy, on the other hand, refers to the
    way we structure and put together different areas of code to form a holistic architecture.
    Together, they allow us to give a name a rich context that can be used to make
    strong inferences about its purpose, concept, and contract.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is best explained by looking at the JavaScript directory of a fictional
    app. We have a directory full of files, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no hierarchy, so we can only discern context from the names themselves
    and what they appear to relate to. For example, there is a `getURL` and a `setURL`
    file, which both presumably relate to URLs and could be considered *utilities*.
    It would, therefore, be helpful to have these occupy the same part of the hierarchy
    or a shared namespace, such as `app/utils/url`. We can also refactor other parts
    of our directory structure into a more contextually rich hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, things are clearer. The cognitive strain of understanding all
    of those files and what they do is now lessened by each file having its own rich
    context. You''ll also notice that we''ve been able to simplify the names at various
    parts of the hierarchy; for example, we have renamed `openModal.js` to `modal/open.js`.
    This is an additional benefit of employing hierarchies of names: at each level
    of naming, we can simplify and shorten the names, lessening comprehension time.'
  prefs: []
  type: TYPE_NORMAL
- en: Names within a hierarchy naturally receive a portion of their meaning from the
    context that they reside in. This means that the name itself does not need to
    contain all the meaning. Always look for opportunities to provide a common context
    to similar abstractions so that the burden of comprehension is eased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we have provided meaning via the hierarchy of a directory structure,
    we can also provide meaning within the code itself. Within a function, for example,
    the names within will naturally receive a lot of their context from the function''s
    name itself and its situation within a larger module. Consider how it would be
    quite unusual to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The names within the function are needlessly prefixed with contextual information
    (such as `modalDisplayer_...`) that the reader of the code can already get from
    the function itself. Typically, we write code that takes advantage of where a
    variable sits and the meaning that it gets from its context. It would be far more
    normal for the preceding code to appear like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In an previous chapter, we discussed the principle of abstraction and how the
    implementation of a module should be independent of its interface. We can see
    that this principle is expressed in this function. The scope of a function (its
    implementation) should be entirely independent (and even ignorant!) of its interface.
    So, arguably, it's not the business of the `modalInstance` variable to know which
    function it resides in and so the former naming technique, which prefixed it with
    `modalDisplayer_...`, would be in violation of the principle of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about hierarchies in terms of abstraction is key. Hierarchies aren''t
    just useful from an organizational perspective. They should, ideally, be a reflection
    of the layers of abstraction that reside within our code. Higher-level abstractions
    are at the top of the hierarchy, and the deeper we go into the hierarchy, the
    more low-level we will get. This is a good general rule to adopt: **make your
    hierarchy reflect your abstractions**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Naming things with consistency complements this rule. Within a single layer of
    our abstraction, that is, within a single level of the hierarchy, we should adopt
    common naming patterns so that the reader of our code can easily navigate and
    understand its concepts. For example, if we are creating an interface that will
    be used to add and remove items from a data structure, then we should avoid naming
    similar actions in an inconsistent manner. Consider the following class schematic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Very confusingly, this abstraction is offering up three different variations
    of the concept of *adding* to the data structure: *adding*, *pushing*, and *setting*.
    These names are all, in fact, referring to the same concept, so we should adopt
    a common naming pattern, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This interface is now far easier to understand. There is less ambiguity and
    less cognitive burden in using it. As a user of this abstraction, I would no longer
    need to remember whether I should be using *add*, *set*, or *push*. Consistency
    is a characteristic that results from the avoidance of needless differences. Inconsistencies
    are jarring and so they should only be used to demarcate genuine functional or
    conceptual differences.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques and considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript, due to its ever-changing nature, has gathered a huge variety of
    conflicting conventions. Many of these conventions garner strong opinions either
    in support or in disapproval. We have, however, settled on some basic conventions
    around naming that are more or less globally accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: Constants should be named with underscore-separated capitals; for example, `DEFAULT_COMPONENT_COLOR`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors or classes should be camel-cased with an initial uppercase letter;
    for example, `MyComponent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else should be camel-cased with an initial lower case letter; for
    example, `myComponentInstance`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these foundational conventions, the decision of naming is left largely
    up to the creativity and skill of the programmer. The names you end up employing
    will be largely defined by what problems you're solving. Most code will inherit
    naming conventions from the APIs it interfaces with. Using the DOM API, for example,
    will usually mean that you adopt names such as *element*, *attribute*, and *node.*
    Many of the popular frameworks available will tend to dictate the names we adopt
    as well. It is absolutely useful and necessary to adopt such conventional paradigms
    from the ecosystem that you're working in, but it's also useful to have some foundational
    techniques and concepts under your belt so that you can craft beautifully named
    abstractions, even in new and alien problem domains.
  prefs: []
  type: TYPE_NORMAL
- en: Hungarian notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a dynamically typed language, meaning that the type of a value
    will be determined at runtime and that the type contained by any variable may
    be liable to change during runtime. This is in contrast to statically-typed languages,
    which have compile-time warnings related to your usage of types. The implication
    of this is that, as JavaScript programmers, we need to be much more careful in
    the way we employ types and how we name our variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, when we name things, we are implying a contract. This contract
    will define how other programmers make use of that thing. This is part of the
    reason why, in various languages, something called Hungarian notation has been
    very popular. It involves including type annotations in a name itself, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `button`, we may use `elButton` or `buttonElement`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of `age`, we may use `nAge` or `ageNumber`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of `details`, we may use `objDetails` or `detailsObject`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hungarian notation is useful for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Certainty**: It provides more certainty of a name''s purpose and contract
    to the readers of your code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: It leads to a more consistent naming approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enforcement**: It may lead to better-enforced typing conventions within your
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime changes**: If the underlying types are changed by bad code at runtime
    (for example, if a function mutates `nAge` into a string), then the name ceases
    to be useful and may only mislead us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codebase rigidity**: It may lead to a rigid code base where it''s hard to
    make appropriate changes to types. Refactoring old code may become more burdensome.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of meaning**: Knowing only a variable''s type does not inform us as
    to its purpose, concept, or contract as much as a truly descriptive non-typed
    variable name would.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the landscape of JavaScript, we see Hungarian notation used in a few places:
    the most common is when naming a variable that may refer to a DOM element. The
    notations for these names will usually be in the form `elHeader`, `headerEl`,
    `headingElement`, or even `$header`. The latter, with a dollar prefix, is most
    famously used in the jQuery library. Its fame there led to it being a standard
    in various other places. **Chromium DevTools**, for example, employs a dollar
    prefix for element references and methods related to querying the DOM (for example, `$$(...)`
    is aliased to `document.querySelectorAll(...)`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hungarian notation is something that can be utilized partially, where you''re
    concerned there may be ambiguity. For example, you can use it where you have both
    a complex type and a primitive type referring to the same concept within a single
    scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an `article` variable that refers to an instance of the `Article`class.
    In addition to this, we also want to use a string representation of our article.
    To get around a potential naming conflict, we have used an `str` prefix to indicate
    that the variable refers to a string value. In isolated cases like these, Hungarian
    notation can be useful. You don't need to use it exhaustively, but it's a useful
    tool to have up your sleeve.
  prefs: []
  type: TYPE_NORMAL
- en: Naming and abstracting functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most abstractions you end up crafting in JavaScript will be manifested within
    functions. Even within grand architectures, it is individual functions and methods
    that do the work, and it is in their conception that a good abstraction begins
    to reveal itself. It is, therefore, worth thinking quite deeply about how we should
    name our functions and what factors we should take into consideration when doing
    so.
  prefs: []
  type: TYPE_NORMAL
- en: A function's name should typically use what, in grammar, is called the **imperative
    form**. The imperative form is what we employ when we are giving instructions,
    such as *walk to the shop*, *buy bread*, *stop there!*.
  prefs: []
  type: TYPE_NORMAL
- en: Although we usually use the *imperative* form when naming functions, there are
    exceptions. For example, it is also conventional to prefix functions that return
    Boolean values with *is* or *has;* for example,`isValid(...)`*.* When creating
    constructors (which are functions), we name them according to the instance they'll
    produce; for example, `Route`or `SpecialComponent`*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'The direct nature of the imperative form is the most understandable and readable
    in the context of programming. To find the correct imperative form for your specific
    problem, it''s best to imagine the act of giving a military order, that is, don''t
    mince your words and say exactly what it is that you want to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want a prompt to be displayed, use `displayPrompt()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want elements to be removed, use `removeElements()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want a random number between `x` and `y`, use `generateRandomNumber(x,
    y)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Often, we wish to qualify our instructions. If you were to issue an instruction
    to a person, such as *find my bicycle*, you would likely further qualify that
    instruction with information such as *it''s blue* and *it''s missing its front
    wheel*. It is important, however, not to let a function''s name get bogged down
    with these qualifications. The following function would be an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned earlier, a needlessly long name is a sign of a bad abstraction.
    When we see this type of over-qualification, we should take a step back and reconsider.
    Here, it's important to draw a line between what is sensible in spoken language
    and what is sensible when programming. In programming, functions are ways of abstracting
    common behavior that can be adjusted or configured, as needed, via arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it is via arguments that we should be expressing the qualifications of
    `blue` and `missing` front wheel. And we could, for example, express these as
    a single object argument like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By moving the qualifying parts of a function's name into its arguments, we are
    producing a cleaner and more comprehensible abstraction. This has the added benefit
    of increasing the configurability of the abstraction, thereby providing the user
    with more possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we may wish to give users the ability to find objects other than
    bicycles. To cater to this, we would make the name of the function more generic
    (for example, `findObject`) and shift the qualifier to the arguments by adding
    a new option property (for example, `type`), like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Something curious happens at this stage of the process. We have, correctly,
    moved our various qualifiers to the arguments of our function, expanding the usefulness
    and configuration of our abstraction. But now what we have is an abstraction that
    is doing many things, so at some point, it may be prudent to take a step back
    and build higher-level abstractions to encapsulate these different behaviors.
    In our case, we could achieve this via functional composition, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Above all, a function is a unit of behavior. As the SRP tells us, it's important
    to ensure that they are only doing one discernible thing. When considering these
    things or units of behavior, it's important to think about what a function does
    from the perspective of those who'll use it. Technically, it's highly likely that
    our composed `findScooter` function does all manner of things beneath the surface.
    It may be incredibly complex. But at the layer of abstraction where it will be
    used, it can be said to only do one thing, and that is what's important.
  prefs: []
  type: TYPE_NORMAL
- en: Three bad names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're ever stuck for a name, there's a clever approach you can use to unstick
    yourself. When you have an abstraction or variable that needs a name, look carefully
    at what it does or what it contains and then come up with at least three bad names that
    describe it. Don't worry about the abstraction or interface you wish to provide
    for now; just imagine you were describing the functionality to someone who doesn't
    know anything about the codebase. Be direct and descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say we''re embedded in the part of the code base that deals
    with setting up new user-names. We need to check that the username does not match
    a set of specifically forbidden words, such as `admin`, `root`, or `user`. We
    want to write a function to do this but we''re not sure what name to pick. So,
    we decide to try the three bad names approach. This is what we come up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`matchUsernameAgainstForbiddenWords`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkForForbiddenWordConflicts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isUsernameReservedWord`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming up with three less-than-perfect names is a lot easier than spending many
    minutes trying but failing to come up with the perfect name. It doesn't matter
    how bad these three names are. What's important is that we can come up with at
    least three. Now, having seeded the set of possibilities, we're free to compare
    and contrast the names we've found and mix and match them to find the most descriptive
    and direct way of describing the purpose of our function. In this case, we may
    have eventually decided on a name adapted from those three possibilities: `isUsernameForbiddenWord`.
    We wouldn't have got there if it wasn't for the three bad names approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have wrestled with the difficult art of naming things. We've
    discussed the characteristics of a good name, that is, purpose, concept, and contract.
    We've walked through examples of how to weave these characteristics into our names
    and what anti-patterns to steer clear of. We've also discussed the importance
    of hierarchy and consistency in our pursuit of clean abstractions. Finally, we
    have covered several helpful techniques and conventions that we can utilize when
    we're having a difficult time naming things.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will, at last, begin to delve into the innards of the
    JavaScript language itself and learn how to wield its constructs and syntax in
    a way that yields truly clean code.
  prefs: []
  type: TYPE_NORMAL
