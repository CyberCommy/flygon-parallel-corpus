- en: Chapter 11. Data Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Data URI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session and local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IndexedDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits of the storage and how to ask for more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating the browser history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about storage, most of the developers think about storing data
    on the server on some database. HTML5 really makes a leap forward on what can
    be passed around and saved to the client side. Whether is for some temporary use,
    caching, or full offline usage of entire apps, client-side storage is becoming
    more and more common.
  prefs: []
  type: TYPE_NORMAL
- en: All of these great features that enable us to store data at the client side
    making the applications ultimately faster, more usable and reachable. Even in
    cloud-based solutions we still need some local data that will make the user experience
    nicer.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter covers some of the features that are related to HTML5 and are about
    data storage.
  prefs: []
  type: TYPE_NORMAL
- en: Data URI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used on several occasions Data **URI** (**Uniform resource identifier**)
    throughout this book, but never got into details on what can we use it for as
    well as what are the limitations. Data URI are often referred to as Data **URL**
    (**Uniform Resource Locator**) though technically speaking they don't actually
    locate anything from a remote site.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use different media types and check the size constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will only need browser and some sample text files for this example. The files
    can be downloaded as part of the `files` folder in the example files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to see some of the options available we will create a simple HTML
    file with few different use scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `head` section will include the `example.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `body` section we add a `div` element that will serve as a container
    for the CSS image Data URI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By using Data URI we can create a simple editor that will be opened by clicking
    on a link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'base64 is optional and character set can be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Data URI can be a raw SVG:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The accompanying CSS code with Data URI is used to represent `background-image`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display two images and links to simple editor and a small text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/9282OT_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common misconception is that Data URI can be used only to represent images.
    As we have seen in our example this is not the case. Strictly speaking, Data URI
    is not an HTML5 feature but included in RFC-2397 ([http://tools.ietf.org/html/rfc2397](http://tools.ietf.org/html/rfc2397)),
    specified in 1998 with the original proposal of the idea in 1995\. The idea behind
    it is to have an embeddable data directly inline. The URI form is specified as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `mediatype` attribute is Internet media type or its older name is MIME.
    In case we don't specify it, it defaults to `text/plain;charset=US-ASCII`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides being cool and different why should we use Data URI?
  prefs: []
  type: TYPE_NORMAL
- en: One good reason is to derive data from the currently displayed document. For
    example, we could create an image from a `canvas` element or have a CSV file generated
    from the current table.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is speed of loading a web page. This is contradictory, since
    Data URI often is base64 encoded and this increases the size of the document to
    1/3rd. The principle behind the speed up is the reduction in the number of requests.
    This makes sense for transfer of small files that should be less than a few kilobytes,
    otherwise the gain from not making another request is small if it even exists.
    Another problem with this approach is that we are losing the individual cache
    for separate resources. What otherwise would be a separately cached file, now
    has the same properties as the document where it is embedded. If that document
    changes often, the embedded data will get reloaded each time.
  prefs: []
  type: TYPE_NORMAL
- en: The other use cases are environments with restrictions on various resources.
    E-mail is an example of this kind of case where, in order to enable a single document
    experience without having images as attachments, Data URI can be used.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some applications of Data URI, security could be a concern, but if the client
    app in most of the browsers follow the specifications, then only the data with
    `mediatype` allowed will be handled.
  prefs: []
  type: TYPE_NORMAL
- en: There are also size limits for what the attributes in HTML5 can contain. HTML
    4 has the `ATTSPLEN` restrictions where it specifies that the maximum length of
    the attributes is `65536` characters. This is not the case for HTML5, where currently
    we have different state on each browser version. For Firefox 3.x it was 600 KB,
    for Chrome 19 it was 2 MB, and IE 8 has a limit of 32 KB. It is safe to say that
    it makes sense only for smaller resources.
  prefs: []
  type: TYPE_NORMAL
- en: Session and local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cookies are a common way to save state from our application at the client side.
    This might be some checkboxes that were selected or some kind of temporary data,
    for example, current flow in a wizard app or even a session identifier.
  prefs: []
  type: TYPE_NORMAL
- en: This is a proven method for quite some time, but there are a few use cases where
    it is just uncomfortable to create cookies and they impose certain limits and
    overhead that can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Session and local storage solve some of the issues with cookies and enable a
    simple storage of data on the client. In this recipe we will create a simple form
    that will take advantage of the HTML5 storage API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we will use several images that can be retrieved from the `images`
    folder or you can use your own selection. Additionally since we will use a simulated
    response from the REST API of a JSON object we need to start a local HTTP server
    that will serve our static files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start off by creating a form that will have a dog selection and an area
    to leave comments. When we click on a button in the form, an image will be displayed
    of the selected dog. In addition to that, we shall have an output field for the
    number of visits made by the current user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We link a simple CSS class in the `head` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The form will contain the following radio buttons and a text area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a counter for the number of visits as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also a simple `div` element as a placeholder for the selected dog image and
    the dependency to jQuery, and include the `example.js` file that we will write
    later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `example.js` file we create a function that will store the comment
    in the session on clicking on a button. If the data is not available a request
    to the `"dogs.json"` variable will be made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `#dogPicker :radio:checked`, we select all the checked input `radio` subelements
    of the element with ID `dogPicker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the data for the comment is stored in the session, upon clicking on that
    we can have a way of loading it for the next time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But using `localStorage` we can increment the `viewCount` variable or else
    initialize it for the first time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showSelectedImages` method goes through each of the dog object, in the
    list we have in `localStorage` and creates an image element with the selected
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we select a radio button and click on the it, an image of a dog should be
    displayed, if we try to reload that cache then (*Ctrl* + *F5*) in most browsers
    the comment data will still remain there. If we open the same URL it in another
    tab then the comment should not be there, meaning that the session is tied to
    a single browser window or a tab. On the other hand the counter should increment
    each time and no additional requests are done for the `dogs.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `sessionStorage` and `localStorage` share the common `Storage` interface,
    and they are defined as part of [http://www.w3.org/TR/webstorage/](http://www.w3.org/TR/webstorage/).
    We can use the dot notation to read or write to the storage, for example `storage.key
    = someValu`e and `someValue = storage.key`. The longer form is to access data
    using method calls, `storage.setItem(key, value)` and `storage.getItem(key)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tne restriction we have for the key and values here is that is that they need
    to be "strings". In our example, we needed to store JSON, so in order to make
    it compatible for values, we used `JSON.stringify` and `JSON.parse`. There is
    also a method `storage.removeItem(key)` to delete an item, or to clear the entire
    storage with `storage.clear()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sessionStorage` is an object that can be used for storing information that
    last for the duration of a browser''s session, this is where the name originates.
    Information is retained even after reload occurred making it a powerful alternative
    to session cookies. The context of which the items stored are valid is the current
    website domain for the duration of the session of the currently opened tab. For
    example, if we store an item on domain [http://example.com/1.html](http://example.com/1.html),
    it will be accessible at [http://example.com/2.html](http://example.com/2.html)
    or any other page of the same domain.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalStorage`, on the other hand, is a persistent storage, and unlike `sessionStorage`,
    it applies even after the end of session. This is similar to the behavior of standard
    cookies, but unlike them which can hold very limited amount of data. `localStorage`
    comes with 5 MB by default on most of the browsers and 10 MB on IE. You need to
    keep in mind that we are storing the data as strings rather than their original
    form, for example, integers or floats, so the final representation that will be
    stored will be larger. If we happen to overcome the size limit of our storage,
    then an exception with the `QUOTA_EXCEEDED_ERR` error message will be thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: In our code, we used `localStorage` to cache a JSON resource, giving us a full
    control of invalidation. Also, we created a simple counter for the number of visits
    by a given user.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious isolation for which separate storage exists is the combination of
    `hostname` and `port`. Less common knowledge is the isolation of the web storage
    depending on the tuple of `scheme/host/port`. Scheme contains the subdomain and
    protocol. So, if a page has a mixed type of resources loaded with `https` and
    `http`, you might not get so obvious results. Having mixed resources similar to
    that is not a good security practice, but it often happens nonetheless. In either
    case, no sensitive data should be stored in local or session storage.
  prefs: []
  type: TYPE_NORMAL
- en: Another case is the private/incognito mode that most of the browsers nowadays
    have. While the page is opened in that mode, a new temporary database for those
    values will be used. Everything that will be stored while in this mode will only
    be part of that session.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Local Storage** uses an synchronous API that runs on the main UI thread in
    the browser. Because of that, there is a very small possibility that a race condition
    can happen if we have the same site opened on multiple, different windows. This
    is not a real problem for most of the use cases. For clearing data from the client
    side, we can always call `storage.clear()`, but most browsers now have developer
    tools that ease the manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/9282OT_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When it comes to polyfills there are plenty of them available, for example
    [https://code.google.com/p/sessionstorage/](https://code.google.com/p/sessionstorage/)
    or [https://gist.github.com/remy/350433](https://gist.github.com/remy/350433).
    You might be wondering how they work, because storage is a new feature that is
    added to the browsers. Most of them use cookies to store data, so they are usually
    limited to 2 KB, the maximum size of cookie. Others use the IE userData([http://msdn.microsoft.com/en-us/library/ms531424%28VS.85%29.aspx](http://msdn.microsoft.com/en-us/library/ms531424%28VS.85%29.aspx))
    object to enable its usage on an older version of IE. There are also libraries,
    for example, [http://www.jstorage.info/](http://www.jstorage.info/) that provide
    the same interface for multiple browser versions. Also, there is `Persists.js`
    that enables multiple different fallback solutions: flash – Flash 8 persistent
    storage, gears – Google gears-based persistent storage, localstorage – HTML5 draft
    storage, whatwg_db – HTML5 draft database storage, globalstorage – HTML5 draft
    storage (now obsolete), IE – Internet Explorer user data behaviors, and cookie
    – Cookie-based persistent storage.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also a custom object-based fallback that can be created to enable `localStorage`
    on older browsers. More info on MDN can be found at [https://developer.mozilla.org/en-US/docs/DOM/Storage#Compatibility](https://developer.mozilla.org/en-US/docs/DOM/Storage#Compatibility).
  prefs: []
  type: TYPE_NORMAL
- en: '`globalStorage` is implemented in several versions of Firefox, but because
    there was a lot of confusion related to the implementations, it has been removed
    from Firefox 13, as well as the specification for Web storage.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to security, it is never a good idea to have sensitive data at
    the client side storage. If there is an XSS vulnerability in your site then the
    storage can be read. It does not make much sense to encrypt the data with server
    side-based key, since that will make us dependent on the server data. There is
    also a possible DNS spoofing attack that can happen on non-TLS sites. If the domain
    is spoofed the browser will not be able to tell if the data is accessed from a
    "wrong" site.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of criticism has been directed towards Web storage mostly due to user
    tracking. If we have the same advertiser in several different sites then he can
    easily track the user visits in those sites. This make the users a lot less anonymous
    and an easy target. There are several proposed solution to fix this problem, for
    example, having restrictions for third-party `iframes` and blacklisting of domains
    that create such data but none of them fix the problem fully at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already used file input to read some of the data, but never went into
    details about file reading and the objects that are available to us. In this recipe,
    we will create a simple file reader using input file that will act as a mini demonstration
    of some of the options provided in the File API: Directories and System, [http://www.w3.org/TR/file-system-api/](http://www.w3.org/TR/file-system-api/).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create an HTML file containing a file input control and a progress
    output for the state of the upload:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the controls and a few output placeholders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add dependencies to jQuery and our `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can proceed to the creation of the `example.js` file; here we attach an
    event handler on the `abort` button and use a `FileReader` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From the selected file input, we will iterate over the uploaded files with
    our current configuration item, and add event handles for some of the common events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getMetaData` function will read the available metadata form the `file`
    object and create a simple HTML representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the File interface in W3C File API specification at
    [http://www.w3.org/TR/FileAPI/#dfn-file](http://www.w3.org/TR/FileAPI/#dfn-file).
  prefs: []
  type: TYPE_NORMAL
- en: 'By reading the file type, we can also determine what will be the output. In
    our case, if we have file, that is, image we append the data as `src` on a `img`
    tag, on the other hand for other file types, we just print the text representation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also another way to read the files list in file input by accessing
    the property files. The `slice` button will only read the first 15 bytes from
    the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At this point we should have a running site where once we upload a file, the
    file will be read and displayed. In order to see the progress events you can try
    out with a large file, because otherwise it could be run in an instant. As for
    the `slice` button it is best if you try it out with a simple `.txt` file so that
    you can see the contents.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main idea behind these specifications is to enable fully-featured API for
    handing the file system at the client side. One unfortunate thing about the current
    state of matter is that only Chrome has implemented most of the features from
    the Filesystem and FileWriter API, while the others support the FileReader and
    File API. That is why we decided on having a working example that is supported
    in all of the major browsers and uses the features that are most common.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reading and simple manipulation, we use `FileList` that contains the `File`
    objects that can be read with `FileReader`. HTML5 defines a files property on
    a `<input type="file">` control that can be accessed using jQuery (`$(''#file'').prop(''files''))`
    or directly from the selected HTML element like we did in case of `this.files.length`.
    This property is actually an array-like object called `FileList` that contains
    the `File` objects. The `FileList` instance has a method, `item(index)` , and
    an attribute `length`. Each item is a `File` object, an interface that extends
    a `Blob`, immutable raw binary data. The File is a representation and has the
    following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This attribute represents the name of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastModifiedDate`: This attribute represents the last modified date of the
    file. If this is not available to the browser, then the current date and time
    are set as the `Date` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But besides them, there are also the ones that come from the `Blob` interface,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size`: This attribute represents the size of the file in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: The MIME type. This metadata can be read directly as we did in our
    `getMetaData` function. The metadata can be used in various different ways, for
    example in our case depending on the type of file we are matching the images `f.type&&f.type.match(''image/.+'')`,
    and then displaying a `img` tag or text otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Blob` type also contains the definition of the `slice` method and since
    `File` extends `Blob` it can also be used there. The `slice(start, end, contentType)`
    method returns a new object with the new `contentType` attribute being sliced,
    the new file will have the slice from the original.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In older browser versions, for example, Firefox version less than 12 and Chrome
    version less than 21 you needed to use a prefixed version of the `slice` method.
    For Chrome it was `File.webkitSlice()` and for Firefox, `File.mozSlice()`. The
    `Blob` object can also be created from a byte array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileReader` object is the actually object that does the reading of the
    data contained in a file, since by itself the `File` object is just a reference
    to the real data. In `FileReader` there are methods for reading from `Blob`, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`void readAsArrayBuffer(blob)`: This method reads the file as a binary array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void readAsText(blog, optionalEncoding)`: This method reads the file as text
    where the optional string name of the encoding can be added to designate the one
    that should be used. If the encoding is omitted, then the encoding is picked automatically
    using the encoding determination algorithm, as defined in the specification which
    should be sufficient in most cases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void readAsDataUrl(blob)`: This method creates a data URL from the given file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may notice that the methods don't actually return the read data. This is
    because the `FileReader` object is reading data asynchronously, so a callback
    will be run once the data is read. There is also an `abort` method that can stop
    the reading of a file once called, this is the method we call upon clicking the
    `abort` button in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Event handlers that can be attached to a file reader that could get triggered
    on certain cases. In our example, we only print the state of the file reader.
    The following events can be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onabort`: This event gets triggered once the reading operation is aborted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onerror`: This event is called when an error happens. This is the one we often
    want to handle it or at least know when it happened even though the handler is
    optional. The errors can happen for various different reasons, and our handler
    can accept an argument to check the `FileError` error code. For example, the handler
    could do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `FileError` object contains the corresponding error that has happened, but
    we handle only some of these cases for a given scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'onload – This event is the one that gets called once the read, operation is
    successfully completed. The handler accepts and progresses an event from where
    we can read the data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`onloadstart`: This method is called at the very beginning of the reading process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onloadend`: This method is called when we have successful read but also even
    if an error has happened, making it a good candidate for clearing up the resources
    that we don''t need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onprogress`: This method is called periodically while we are reading the data.
    In the progress handler, we can read several properties that are of use to us
    for making an update on a `progress` element. We can read the total amount of
    bytes for that file that is read, meaning that we can simply calculate the percentage
    of data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In most use cases, `onload` and `onerror` are sufficient, but we may need to
    show a visual display to the user or notify him or her of the reading state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For checking if the functionality we used is supported by a browser we can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more advanced logic and writing to files, there is `FileWriter`, `DirectoryReader`,
    `FileEntry`, `DirectoryEntry`, `LocalFileSystem`, and so on. The issue with this
    is that at the time of this writing only Chrome has support for them.
  prefs: []
  type: TYPE_NORMAL
- en: To request a sandboxed filesystem, we make a call to `window.requestFileSystem(type,
    size, successCallback, errorCallback)` that is a part of the FileSystem API. The
    sandbox means that this filesystem is separate from the one of the user, so you
    can't really write anywhere you wish to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filesystem has been prefixed since Chrome 12 and the current version of
    Chrome 25 are still using that version. A simple request for filesystem would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The files in the sandboxed environment are represented with `FileEntry`, and
    the directories with `DirectoryEntry`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have successfully opened the filesystem, we can read the `FileEntries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This `fs.root` call is a reference to the root of the filesystem, as for the
    `fileEntry` parameter there are a lot of methods that can be used for moving the
    file, deleting the file, converting it to a URL, copying, and all the other functionality
    you might expect from a filesystem. The URLs are relative for the given sandboxed
    filesystem so we can expect to have something similar to `/docs/books/dragon/`
    for the `root` directory for that specific sandboxed file system.
  prefs: []
  type: TYPE_NORMAL
- en: Erick Bidelman, one of the programmers behind the FileSystem API has implemented
    great wrapper of the functionality that uses well known UNIX commands such as
    `cp`, `mv`, `ls`. The lib is called `filer.js`, [https://github.com/ebidel/filer.js](https://github.com/ebidel/filer.js).
    He also has polyfill for FileSystem API called `ibd.filesystem.js`, ([https://github.com/ebidel/idb.filesystem.js](https://github.com/ebidel/idb.filesystem.js)),
    that uses IndexedDB to simulate the functionality in other browsers.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a synchronous version of the API where we call it using `webkitRequestFileSystemSync`.
    The reason why we would want to use synchronous reading is Web workers, where
    it makes sense, since we are not blocking the main application like that.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several use cases mentioned in the specification, so a summarized
    version of these use cases would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent uploader is a way to upload a file to the server one chunk at a time,
    so that when we have a server or browser failure it can continue with the last
    chunk that the server received, rather than reuploading the whole file all over
    again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game or a rich media application where the resources are downloaded as tarballs
    and are expanded locally, the same resources could be prefetched having only one
    request instead of many small requests, which can reduce the lookup times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files that will get created by applications such as offline video, audio
    or any other type of binary file viewer, and editor can be saved in local system
    for further processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IndexedDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides local and session storage, IndexedDB also provides us with a way to
    store user data in the browser. IndexedDB is more advanced than local storage:
    it allows us to store data in object stores and supports indexing the data.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to create a simple todo list app which stores its
    data in IndexedDB. We're going to use the Angular framework covered in [Chapter
    10](ch10.html "Chapter 10. Data Binding Frameworks"), *Data Binding Frameworks*
    to simplify our code. We're going to find out if IndexedDB is a better choice
    for larger, more complicated data models with more complex search and retrieval
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: The todo list application will support current and archived items and will allow
    filtering the items by date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `index.html`. To simplify our application code, we''re going to use
    `angular.js` templates. Our template will contain the following elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A select to pick between current and archived todos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A date range filter using HTML5 date components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A todo list with a checkbox and age for each item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A form to add a new item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An archive button for current items that are done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `example.js`, which will define the controller that sets up and manipulates
    the scope of the template in `index.html` and defines the age filter for dates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `DBTodo` service required by the controller in `service.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to remove the prefix from the global definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our initialization function opens the database and specifies the requested
    version. When the database doesn''t exist, the `onupgradeneeded` function is called,
    and we can use it to create our object store and indices. We also populate the
    database with some randomly generated items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This function populates the database with `50` random items that are spread
    within `25` days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`withDB` is a helper function that makes sure the database is initialized before
    executing the specified function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`withScope` is a helper function that creates a function which is called within
    `$rootScope.$apply` to indicate an update of angular scope objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `getItems`, `updateItem`, `archive`, and `addItem` are the public
    API of the `DBTodo` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Open `index.html` in a browser that supports IndexedDB and date inputs (for
    example, Google Chrome).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to the average JavaScript API, the IndexedDB API is quite verbose.
    IndexedDB uses DOM events to signal the completion of an asynchronous task. Most
    API calls return a request object. To get the results, we need to attach event
    listeners to this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, opening the database results with a request object. We can attach
    three event listeners to this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onsuccess`: This is called when the database has been successfully opened'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onerror`: This is called when there is an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onupgradeneeded`: This is called when the database is not the specified version
    or doesn''t exist yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An IndexedDB database is an object-oriented database that contains one or more
    object stores.
  prefs: []
  type: TYPE_NORMAL
- en: Object stores have a primary key index. The primary key is autogenerated in
    our example, but we can also specify an exiting property to serve as the primary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Every object store may have one or more indexes. Indexes can be added by specifying
    the path of the property that should be indexed – in our case, we define two indexes
    for our `todos` store on the date and archived fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'All queries to the database are performed within transactions. When creating
    a transaction, we define the object store that will be used in the transaction.
    Like requests, transactions also have event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '`oncomplete`: This is called when the transaction is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onerror`: This is called if an error occured'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onabort`: This is called if a transaction was aborted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the transaction we can access the object store by calling `transaction.objectStore('name')`.
    All operations on this object store will be done inside the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: The object store supports multiple methods to add, get, and delete items, as
    well as means to access the indexes. To add items we use the `add` method. To
    access items we need to show or update, we use the index by calling `objectStore.index('name')`.
  prefs: []
  type: TYPE_NORMAL
- en: The index provides a subset of the object store API used to retreive data, such
    as `get`, `count`, and `openCursor`.
  prefs: []
  type: TYPE_NORMAL
- en: To update an item or fetch multiple items, we use the `openCursor` method. It
    returns a `request` to which we can attach an `onsuccess` listener. This listener
    will be called for every item accessed by the cursor. The `cursor` can be accessed
    via `request.result`.
  prefs: []
  type: TYPE_NORMAL
- en: When we're done with the visited item, we can call `cursor.continue` to advance
    to the next item. The `onsuccess` listener will be called again, this time with
    the cursor pointing to the next item.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can restrict the cursor by specifying a key range to visit, as well as the
    direction (ascending or descending). A key range can be generated with the `IDBKeyRange`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`upperBound`: This method is used to specify an upper bound range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowerBound`: This method is used to specify a lower bound range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bound`: This method is used to specify both upper and lower bound range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`only`: This method is used to specify a range that includes only one key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides specifying the bounds, `upperBound`, `lowerBound`, and `bound`, they
    also support additional Boolean parameters which allow us to specify if the bounds
    are inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum it all up, when implementing our `getItems` method to fetch all the
    items between the specified dates, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a transaction to the todos object store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the todos object store from the transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the `date` index from the object store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `IDBKeyRange` bound specifying the first date as the lower bound and
    the second date as the upper bound (and two true parameters indicating that the
    bounds are inclusive)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a cursor from the `date` index using the created key range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the cursor request to iterate through all the items and add them into an
    array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the transaction `oncomplete` handler to call the callback function with
    the list when all the items are added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IndexedDB API is very verbose and low-level. It is not meant to be used
    directly by web applications; instead, it's meant to provide means to write more
    high-level database implementations on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'But more than that, IndexedDB doesn''t support some fundamental features we''ve
    come to accept as standard in real databases:'
  prefs: []
  type: TYPE_NORMAL
- en: There are no compound indexes, which means we can't write efficient queries
    that bound multiple properties of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we wish to order the items in an order different than the one that the index
    key provides, we will have to fill an array and sort the result manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no joins, which means that we would need to write the code to join
    two object stores and pick the most appropriate indexes to minimize the workload
    by hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, we cannot recommend using the IndexedDB API until it matures, or
    other more complete and less verbose database implementations are written on top
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check out PouchDB ([http://pouchdb.com/](http://pouchdb.com/)) for a more complete
    solution, or `db.js` ([http://aaronpowell.github.com/db.js/](http://aaronpowell.github.com/db.js/))
    for a more succinct API.
  prefs: []
  type: TYPE_NORMAL
- en: Limits of the storage and how to ask for more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have seen several different ways to have storage and access it at
    the client side. All these ways gives us the option to store large amounts of
    data at the client side. The question arises how come there are no hacks out there
    that fills up the storage of all the devices?
  prefs: []
  type: TYPE_NORMAL
- en: We will see why this is not happening everywhere, at least not without some
    browser vulnerability. To do this, we shall create a simple case where we will
    store data to the browser using `localStorage`, as long as we are allowed by the
    user agent.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start by creating a file called `example.js`, there we will generate
    data with size of `1 k` and size of `100 k`. The data for 1k can be generated
    by creating an array of `1025` elements, which we will join with the letter `"a"`,
    resulting in `1024` character string of `"a"`''S:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Following that we will create a simple function that will accept number of
    entries and data for each of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a function that will clear the entire `localStorage` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After having this we can create an HTML file, where we will have a few buttons,
    one for clearing all the data and others for filling the storage up with generated
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storage limitations as well as the behavior depend on the browser. The specification
    itself says that user agents should limit the total amount of space allowed for
    storage area. Additionally they should grant the same amount of storage for each
    subdomain (for example, `a.example.com`, `b.example.com`, and so on). There is
    also an option to prompt the user to request more storage; unfortunately, this
    is only currently done by Opera.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/9282OT_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a configurable property in Firefox called `dom.storage.default_quota`
    that can be found in `about:config`, but you can't really expect the user to set
    an increased value manually there. For IndexDB, there are no limitations on the
    storage size but the initial quota is set to 50 MB.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are talking about limitations in HTML5 Filesystem API, we have several
    storage type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary storage is the basic one, so we do not need special permissions to
    obtain it; making it a good pick for caching. Chrome currently has a temporary
    pool of 1 GB and there are plans for IndexedDB and WebSQL to become part of the
    same pool. For temporary storage there are no guarantees for persistence, so it
    can be removed at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More on WebSQL can be found on W3C, although the specification is no longer
    developed or maintained [http://www.w3.org/TR/webdatabase/](http://www.w3.org/TR/webdatabase/).
  prefs: []
  type: TYPE_NORMAL
- en: Persistent storage on the other hand is well persistent. Data remains there
    after restart, and it is there until manually deleted by the user or our application.
    When we do a request file system call, the browser will prompt us for permission
    and if we spend that we will get `QUOTA_EXCEEDE_ERR`.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a storage that is of type unlimited, but that is Chrome-specific,
    and intended to be used from extensions and Chrome apps.
  prefs: []
  type: TYPE_NORMAL
- en: Some efforts have been taken to standardize the way storage is requested, so
    the Quota API specification, [http://www.w3.org/TR/quota-api/](http://www.w3.org/TR/quota-api/),
    was created for the purpose. The specification itself defines an API to manage
    the usage and availability of local storage resources for various persistent API's.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `StorageQuota` interface where the process of getting more `PERSISTENT`
    data is described. A prefixed version of the implementation is available in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: By calling the method, a prompt will appear to the user to ask for permission.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the browser history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: History API allows you to manipulate the browser history using JavaScript. Some
    of the manipulations were available in the user agents for a long time. A new
    feature is an option to add new entries in the history, change the URL show in
    the location bar, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can create a single page app that will respect the REST way.
    The pages now can have unique identifier that will lead directly to certain view
    with specific state without doing page reloads or some client-side hacks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will use few images, so you can pick your own selection or
    use the ones provided in the example files located under the `img/` folder. The
    images will also be served in `img/` for our web page, so you should have the
    HTTP server running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create the HTML code for a cat viewer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We include a dependency to jQuery and our script, `example.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally we can add some very basic style to make the behavior of the div
    elements more like links, although in the general case we could also use `<a>`
    elements but it''s not always the best idea to override the click behavior on
    anchors. The style could be something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the `example.js` file we have a small JSON like structure called `catson`
    that describes our data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When the document is loaded, we check for the support of the history API in
    the current user agent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this we add an on-click handler for our navigation elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: At this point you should have a running example, where if you click around,
    you will notice that the browser URL gets changed but we rely on having only one
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do a refresh on some of the other URL''s that are generated, you should
    get a message similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is because we are only simulating the web page, while the page itself does
    not exist.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea behind the History API is simple. It's an object that allows us to
    manipulate browser history through the `window.history` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to go one page back we simply call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to go to the next page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a more general method that allows us to go + or – `n` pages in
    the history, for example to go three pages back we call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The most interesting of all of these methods that come with this API are probably
    the `pushState(state`, `title`, `url)` and `replaceState(state`, `title`, `url)`.
    The first one we used in our example adds a URL to the history stack with the
    given state object. To be completely conformist with the rules we should have
    used the first argument of the method which is the state object that represents
    the current document state. In our case this would have been one cat object for
    the `catison` list.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly as the `pushState`, the `replaceState` methods are updated rather
    than adding a new state on the history stack with the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The state object itself is reachable under the `history.state` variable, similar
    to the `history.state` variable there is also a `history.length` variable for
    the size of the current stack. The `history.state` variable can be used to store
    data for the given segment, making it yet another option for storing data in the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read more about History API on the live specification on WHATWG: [http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html](http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to consider is making a clever routing so that you
    will not have broken and non-existent URL's. This means that we might need some
    work at the server side so that the state of the URL will be available for rendering.
    The main goal is to improve usability and not to overuse the cool new features,
    so be careful where you really need this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: For older browsers there is a great polyfill called `history.js`, ([https://github.com/browserstate/history.js](https://github.com/browserstate/history.js))
    that additionally adds few other nice features for development.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a library called `Path.js`, that uses History API for advanced
    routing, but also abuses `hashbangs` (`#`) to achieve nice functionality.
  prefs: []
  type: TYPE_NORMAL
- en: While we are talking about complete abuse, there is a whole game written that
    uses `history.replaceState` to make the URL bar a screen. The game is called Abaroids
    and can be found at [http://www.thegillowfamily.co.uk/](http://www.thegillowfamily.co.uk/).
  prefs: []
  type: TYPE_NORMAL
