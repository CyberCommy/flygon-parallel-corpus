- en: Chapter 5. Learning Functional Programming – The Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a multiparadigm language that is not perfect for any paradigm
    it touches, but it has interesting features for its main paradigms. It is an object-oriented
    language, although the definition of object-oriented varies between object-oriented
    languages. It has been suggested that its prototypal inheritance may be less significant
    for object-oriented programming than a demonstration of how to create class-free
    objects instead of fumbling at the difficult task of getting the taxonomy right
    from the beginning. The definition of object-oriented also varies between multiparadigm
    languages with object-oriented features. For example, Python dynamically allows
    members to be added to existing objects, while Java requires members to be defined
    in a class. The object-oriented characteristics of JavaScript are useful and interesting,
    but especially in the past few years, they have been a source of frustration to
    programmers of other object-oriented languages, who have been told that JavaScript
    is object-oriented without sufficient information on how JavaScript is object
    oriented through an approach that differs profoundly from other major languages.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, for functional programming, JavaScript has functional programming
    support, or at least some of it. But like JavaScript as a whole, functional JavaScript
    is not 100 percent in line with the *The Good Parts*. One common, although not
    universal, feature of functional programming languages is tail call optimization,
    which says that recursive functions that only recur at the end are internally
    converted into a more commonplace style of loop that is faster and can go very
    deep without exhausting its quota of call stack space. This optimization is slated
    for ECMAScript 6, but at the time of writing this book, it has not been implemented
    in common browsers, which provide not only slower performance but also a limit
    of around 10,000 to 20,000 calls deep in recursion.
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot that can be done within this limit, but structured program writers
    would not be happy if their `for` loop was not implemented to go much beyond 20,000
    iterations. The point here is not to specify which solution is best for JavaScript
    not always supporting tail call optimization, but to indicate that this difficulty
    is presently here, and this is one of the few ways in which JavaScript does not
    directly support standard functional language features (summing all integers from
    1 to 1,000,000 or higher is especially not interesting to do, but it serves as
    a standard example in tutorials).
  prefs: []
  type: TYPE_NORMAL
- en: 'Literature is divided over whether or not JavaScript should be called a functional
    language; it is certainly not a pure functional language as Haskell is (but then,
    neither is OCaml). JavaScript has been called after a known functional language—Scheme
    in C''s clothing—and its basic functional features are not something tacked on
    after the fact. Perhaps this may reflect his preferences, but Douglas Crockford,
    who is willing to be both critical and picky in his judgments of what parts of
    the JavaScript language are good ideas, has never that I have seen picked functional
    aspects present in JavaScript for targets of a scathing critique. In his move
    from *JavaScript: The Good Parts* to *The Better Parts*, one of his preferences
    given ECMAScript 6 is to stop using `for` and `while` loops in an imperative style,
    and use recursion that takes advantage of tail call optimization, which is to
    be included. Maybe the strongest claim that JavaScript has a functional heart
    can be seen in the question of what feature in a language is central. It has been
    suggested that in Java, the central feature is objects. In C, it is pointers.
    In JavaScript, it is functions.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript's functions have first-class status, meaning among other things that
    (higher order) functions can act on other functions and be passed as arguments,
    or even be dynamically constructed and returned as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: Custom sort functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map, reduce, and filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fool's gold – altering the behavior of other people's prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures and information hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom sort functions – the first example of functional JavaScript and first-class
    functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To break the ice, let''s look at sorting JavaScript''s arrays. JavaScript''s
    arrays have a built-in `sort()` function, which is, at the very least, a sensible
    default. If, for instance, we create an array with the first six digits of π,
    we can sort it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Chrome''s debugger shows an array on the console, which we can access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is well and good. Let''s stretch things a little further and try mixing
    integers and floating-point decimals (floats). Note that in JavaScript, there
    is one numeric type that acts like an integer (and remains integer clean) for
    the integers between (in Firefox) -(253 - 1), or -9007199254740991, and 253 –
    1, or 9007199254740991\. This numeric type also stores floating-point numbers.
    These have a greater range and, of course, more fine-grained values for smaller
    numbers. To stretch things further, let''s have an array with integers and floats
    mixed together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Among these numbers, `Math.PI` is around 3.14, `Math.E` is around 2.72, `Math.sqrt(2)`
    is around 1.41, `Math.sqrt(3)` is around 1.73, and `Math.sqrt(5)` is around 2.24\.
    Let''s sort this like the other array and log the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Chrome's debugger, for some reason, behaved differently this time, displaying
    all of the array in a string rather than an array with a drill-down triangle to
    the left. However, the array is sorted correctly, with all the values in ascending
    order and integers and floating-point values displayed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this out on strings. Suppose we have the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we sort it, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is in order, and good. Let''s add a bit in the middle of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We sort it and get back the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What is this? All the new words are at the beginning, and all the old words
    are at the end! Sorted among themselves perhaps, but segregated by capitalization.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that string sorting is the dictionary order by Unicode
    values, which is the same as ASCII encoding for characters that are part of ASCII.
    In ASCII, all uppercase letters come before all lowercase letters. Here, uppercase
    letters are sorted correctly within uppercase and lowercase letters are sorted
    correctly within lowercase, but both of these are segregated. If we want all of
    the `A` to come before all the `B`, we need to be more specific about what we
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way we can do this is by providing a comparator function—something that
    will compare two elements and tell `Array.sort()` which one should go first. Let''s
    make a case-insensitive sort just for these words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we sort the array and specify the comparing function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we log the sorted array, we see a case-insensitive alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we want capitalization to serve as a tiebreaker and an uppercase character
    will be placed before its lowercase equivalent? This is a straightforward modification
    of our comparator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add `''ALPHA''` and `''alpha''` to the end of our list of strings and
    re-sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It works!
  prefs: []
  type: TYPE_NORMAL
- en: 'This may or may not be needed with mere string comparisons, but what if the
    server has run a database query and packaged the results in JSON for us? The result,
    once parsed on the client, will probably be an array of objects that have the
    same structure. Electronic customer contact information might include the following,
    among other things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This record structure may not be one that JavaScript innately infers how we
    would like to see it sorted, but this does not really hurt us. If we build a comparator
    function, it has full access to fields or other details of both the items that
    it is asked to compare. This means that we can compare one field, then another,
    and then a third. It also means that we can compare by different criteria if we
    want to; at one point, we could compare by name, and another point we might compare
    by geographical location. If our server stores (or looks up) GPS coordinates for
    addresses, we can search by who is closest to a particular location.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to array.filter()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In functional languages, features such as map, reduce, and filter are staples
    of everyday use. They operate on lists, which in more functional, list-centric
    languages may be finite or infinite. In this sense, a list may be more like a
    JavaScript array or a generator, a kind of function that, instead of returning
    a single value, yields zero or more values and may theoretically yield an infinite
    number of values. Unlike an array, there is no finite point where any given generator
    may be exhausted, even though one never actually produces an infinite number of
    values. Generators are a wonderful feature, but they are dodgily supported in
    browsers at the time of writing this book, which means that our use of map, reduce,
    and filter will more likely be on (finite) arrays than on generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we drop the topic of generators, let''s give two examples of generators,
    both of which will overflow before too long, but both of which serve as examples
    of what, in a language like Haskell, might be considered an infinite list with
    all the members of a mathematical series, as opposed to an array containing only
    and exactly the first *n* members. We will look at generators for powers of 2
    and Fibonacci numbers, using the ECMA6-proposed syntax for generators, as discussed
    at [http://wiki.ecmascript.org/doku.php?id=harmony:generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrast these examples with generators with standard, recursive approaches
    to compute the nth power of 2 (this is not really needed, because JavaScript''s
    arithmetic handles exponents, but is included for the sake of completeness), and
    a naïve implementation of computing the nth Fibonacci number. Both are what is
    called tail recursive, and would stand to benefit from tail call optimization
    if and when such a thing is made available from browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Both of these functions assume a nonnegative integer as the argument. The second
    function also has terrible performance characteristics, even though memory usage
    is not particularly bad. However, the number of function calls is comparable to
    the value returned, so calculating the 100th Fibonacci number, besides any concerns
    about integer overflow, could take longer than the age of the Universe. As Donald
    Knuth said, "Premature optimization is the root of all evil," but this is one
    case where optimization is not premature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that another feature of functional programming, called **memoization**—which
    means retaining the results of the intermediate calculations, instead of repeatedly
    regenerating them from scratch—avoids this performance bottleneck altogether.
    Consider the following memoization of the recursive Fibonacci function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Illusionism, map, reduce, and filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a child, I was very interested in illusionism, and I still have an illusionist's
    set—which has (or had) things such as a fake thumb and a trick cup—and books on
    illusions. One of the tricks I remember was putting a rope around one's thighs
    and looping around the hands. The rope appears tight if one's legs are relaxed,
    but much looser if one lifts one's legs a bit, thus giving the impression that
    one is tied securely, while it is straightforward to free one or both hands.
  prefs: []
  type: TYPE_NORMAL
- en: I was never too good at the showmanship aspect of amateur illusionism, which
    is really the core of the craft. Senior illusionists, when advising their juniors
    or aspirants, are apt to say things such as, "Entertain the audience and deceive
    them, but know which comes first." And I remember for a long time thinking that
    I did not know (the technical side of) real illusionism, because I knew technically
    how to do several tricks, but I did not see how one would approach doing the things
    I saw.
  prefs: []
  type: TYPE_NORMAL
- en: Much later, there was an illusionist at my company's party, and I was fascinated
    for an unusual reason. He did some tricks that were novel to me, but for about
    70 percent or 80 percent of the time, he spent making significant mileage out
    of the rope tricks I learned as a kid. And it worked very well. He had exquisite
    showmanship, and my fascination was not about wondering how he technically pulled
    off the trick, but at such an adept entertainer who could take two tricks that
    a child could do and mine them for amusement value.
  prefs: []
  type: TYPE_NORMAL
- en: Map, reduce, and filter (here, "reduce" includes both the right and left folds)
    are somewhat like this for functional programming. Map takes it and applies it
    to all members of a list. Reduce takes an operation and, starting from the right
    or left, applies it to every member with an intermediate result. Filter takes
    a function and a list and creates a new list consisting of exactly those items
    for which the function is true. These concepts will be explained and further illustrated
    in this chapter. Map, reduce, and filter aren't particularly difficult concepts,
    but there's a lot of mileage to get out of them. Let's look at map, reduce, and
    filter for arrays, bracketing the question of generators and the potentially infinite
    lists offered by languages such as Haskell. We will show you how to use JavaScript's
    array built-in versions of map, reduce, and filter. We will also take a look at
    the use of core JavaScript to implement these functions, not so much so that people
    can have IE8-compatible (and earlier) access to these functions, but to give a
    sense of how these things work.
  prefs: []
  type: TYPE_NORMAL
- en: The implementations that we will explore, after a warning about fool's gold,
    have a somewhat nonfunctional style of implementation. They use `for` loops where,
    in a purely functional language, the solution of choice would probably be a tail
    recursive implementation. The rationale for this choice is the goal of providing
    functional feature support in a way that operates optimally for JavaScript's plumbing
    and doesn't fail in the rare cases where (non-tail-call-optimized) JavaScript
    recursion runs into its limits.
  prefs: []
  type: TYPE_NORMAL
- en: Fool's gold – extending Array.prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A note of caution is due. An attractive solution, and one that can be easily
    implemented, is to extend (here) `Array.prototype` or the prototypes of other
    objects used by others, including `Object.prototype`. Don't do it.
  prefs: []
  type: TYPE_NORMAL
- en: Among other things, extending `Array.prototype` and its kin destabilizes the
    playing field for other people's software; it's like rewriting other people's
    code when you haven't seen it. Probably, the best use case for extending basic
    prototypes is polyfills (reimplementation of a functionality that is not available
    in the current environment, using the available features), but even then, if there
    are competing polyfills, only one of them can win. Now it is unlikely that your
    polyfill will have the same testing for bug-for-bug compatibility as a major browser
    manufacturer. This leaves the door open to subtle bugs. In our case, in the interest
    of supporting sparse matrices, we ignore undefined entries, but not null. I submit
    that this is reasonable in context, but far from the only conceivable way someone
    smart (or not-so-smart) would frame the matter. JavaScript has two null values,
    `null` and `undefined`, and there is potential for more than one opinion about
    how these two distinct null values should be handled. What if the semantics that
    makes sense to us isn't the semantics that was evident to someone else? Do we
    want to open the door to slippery heisenbugs?
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an alternative that is straightforward and good: make your own functions,
    preferably anonymous functions defined within a closure, and stored in a variable.
    These functions can, if desired, check whether there is a browser''s built-in
    function, such as `Array.prototype.map()`, and fall back to the built-in function
    if it is found. It can do for our code almost any job accomplished by extending
    `Array.prototype`. But it shows good habits and that doesn''t yank the rug from
    under anyone else''s feet.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term *anonymous function* in JavaScript does not exclude functions stored
    in named variables. It only means that they have been defined without a function
    name. In other words, they are defined like `function()`, `var foo = function()`,
    or other alternatives, but not a name between the function keyword and the opening
    parenthesis, that is, `function bar()`. Usually, we will be using anonymous functions,
    whether they are stored in a variable or not, but there is a debugging-related
    reason for which we might name a function even if we never use it: a debugger''s
    stack trace may be more informative in its way of mentioning functions if the
    functions are named, even if the names are never used. It does make sense, for
    this purpose, to write `var quux = function quux()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One aside about what we may be developing privately, off in a corner: an astonishing
    number of Unix utilities began life as private hacks to solve local problems for
    different people. Things that spread like wildfire are often not things that are
    engineered to spread like wildfire, such as the Web, JavaScript, and versions
    of PHP before 5.0\. In their first versions—perhaps this applies to the Web more
    than JavaScript—they did something specific and had people struggling to function
    in a more complete manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The statelessness of HTTP was a carefully chosen feature, but for that time,
    a good chunk of web programming was trying to support use cases where stateless
    HTTP was getting quite painful. There may be differences between a 5 MB HTML5
    key-value store and a 4096-byte cookie ceiling, but they present both more or
    less gracious accommodations in providing hooks for properly stateful behavior
    when the web''s HTTP is stateless: the web was built not to enable the dynamic
    content as it is the lion''s share of all web contents today. JavaScript has its
    strengths and weaknesses, and its weaknesses may be some of the worst of any wildly
    successful language, but the reason for its wide success and celebrity status
    is not its strengths or weaknesses. It succeeded because it was included in browsers
    at a time when the Web was spreading like wildfire. Both JavaScript and the Web
    had people trying to fix their limitations and weaknesses to do many things well
    after they had spread like wildfire when they actually did only one thing well.'
  prefs: []
  type: TYPE_NORMAL
- en: The mentality of "This is just something in a corner and we do not need to think
    about maintenance or interoperability" is very, very dangerous. Perhaps now your
    software will not break anything if it subtly redefines the behavior of an object
    or array, but not ever? Not even with any future decision? Not even if someone
    realizes that in solving X, you created a great engine for Y that could save a
    lot of work? Client-side JavaScript is some of the code that is most quickly made
    open source (after all, even lawyers concerned about keeping things proprietary
    know that your whole kaboodle can be delivered to anyone who logs in to your system
    from the Web), and it is dangerous to assume that a particular redefinition of
    standard behavior is simply future-proof.
  prefs: []
  type: TYPE_NORMAL
- en: 'A short answer to the preceding questions is this: don''t redefine anything
    on which other people''s code is built, including redefining part of `Object.prototype`,
    `Array.prototype`, `Function.prototype`, and so on. Opt for your own implementation
    as far as it makes sense, but don''t (forcibly) install it for everybody.'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding global pollution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is also good practice to minimize incursions into the global namespace. The
    more global variables you add, the more easily you can conflict with other tooling.
    When Yahoo! announced YUI, as a matter of basic manners, they used only one global
    variable—YUI. There's a whole library that's available, but you don't have pages
    and pages of items dumped on the browser's global namespace; every call to YUI().use()
    or whatever is entirely contained in YUI's one incursion into the global namespace.
    jQuery uses a little more of the global namespace than they advertise, but in
    principle, they ask us only to use `jQuery` and `$`. Also, they try to make the
    second one wholly negotiable, as `jQuery` acknowledges that other frameworks need
    `$` and `jQuery` is intended to play nicely with others.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can actually go further than this, by an immediately invoked function
    expression, including the ReactJS web application explored in [Chapters 8](ch08.html
    "Chapter 8. Demonstrating Functional Reactive Programming in JavaScript – A Live
    Example, Part I"), *Demonstrating Functional Reactive Programming in JavaScript
    – A Live Example* to [Chapter 11](ch11.html "Chapter 11. Demonstrating Functional
    Reactive Programming in JavaScript with a Live Example Part IV – Adding a Scratchpad
    and Putting It All Together"), *Demonstrating Functional Reactive Programming
    in JavaScript with a Live Example Part IV – Adding a Scratchpad and Putting It
    All Together*. The functionality that you can accomplish without making a single
    global variable is quite a lot. Perhaps libraries should have some global variable
    as a public face available for others, but it is perfectly possible to make a
    web application that doesn't touch global variables.
  prefs: []
  type: TYPE_NORMAL
- en: The map, reduce, and filter toolbox – map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A map takes an array and a function and returns a new array with the function
    applied to all of its elements. As an example, let''s create an array of the numbers
    1 to 10, and use map to create a new array with their squares. (Note that JavaScript
    is somewhat inconsistent about whether array options modify an array in-place,
    return a modified array, or do both. The array''s `map()`, `reduce()`, and `filter()`
    functions all create a new array, leaving the original array unchanged and untouched.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `squares` variable now holds, `[1, 4, 9, 16, 25, 36, 49, 84, 81, 100]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One implementation of `map()` might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The reduce function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What the reduce function does is it takes an operation and progressively apply
    it to the elements in an array. You may have covered infinite (and finite) series
    in school, perhaps with symbols like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The reduce function](img/B04108_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this kind of operation, the uppercase sigma (**Σ**, which is roughly equivalent
    to "S" in the Greek alphabet) is used for sums, and less frequently, the uppercase
    pi (Π, which is roughly equivalent to "P" in the Greek alphabet) is used for products.
    Both of them repeatedly apply an arithmetic operator to a finite (or infinite)
    series of numbers, and they work on the same basic principle as `reduce()`.
  prefs: []
  type: TYPE_NORMAL
- en: What this kind of notation says is, "For this series of numbers, what do we
    get if we add them together, that is, reduce them with the addition function,
    taking the first number and the second, calculating their sum, then adding it
    to the third number, and so on?"
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to add up the contents of an array, we can reduce it with an addition
    function (as a minor implementation detail, we do not use the bare `+` operator
    because we can''t directly pass an operator as a regular function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finite and infinite series taught in school are usually sums; we can use other
    series as well. For example, if we want to calculate 10!, we can reduce by multiplying
    instead of adding in terms of the function we supply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Reduction does not need to be mathematical in character; this just gives us
    a quick way to demonstrate it. We can also use reduce to concatenate arrays of
    strings, where the `+` operator serves the purpose of string concatenation rather
    than numerical addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is a basic difficulty that JavaScript''s built-in functions
    do not solve for us. We will sometimes need to make a choice and further specify
    what we really want. Numerical addition, multiplication, and string concatenation
    are all associative, which essentially means that you can put parentheses wherever
    you want, follow standard rules for parentheses, and get the same answer. In numerical
    addition, the following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these calculations give `10`, and if we multiply instead of adding,
    both give us a product of `24`. But what happens if we use exponentiation for
    very slightly different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same sort of thing we have in the immediately preceding code, although
    admittedly with an uglier namespaced function instead of an infix operator. In
    non-JavaScript notation, using a caret (`^`), we get the following pseudo-JavaScript,
    which restates the preceding calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use `console.log()` with the `Math.pow()` calculation that you just saw,
    we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There's a slight difference here. One result is a four-digit integer; the other
    is expressed in scientific notation with a lot more than four digits. Well, how
    many things are really like the special case of exponentiation?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this question is a bit tricky, partly because of how I have deceptively
    framed the question to illustrate a treacherous misunderstanding. Exponentiation,
    where it matters how you add parentheses, can be more like the general case. There
    do exist cases where it doesn''t matter, and they might even more commonly be
    candidates for `reduce()`, but in the general case, we should not assume that
    the two are equivalent. We will give a `fold_left()` and `fold_right()` function;
    these are not the only two options (you can do things manually if neither of them
    is what you want), but they respectively calculate the sum of the array one to
    ten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: One is not necessarily better than the other, but the difference can matter.
    JavaScript's built-in `reduce()` function is a left fold, starting from the left
    and moving to the right, as shown in the first of the two preceding expressions
    (and this is probably a sensible default).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we define `fold_left()` and `fold_right()`, it could look something like
    the following. I use abbreviations here where the full word spelled out would
    look too close to a reserved word; for example, array won''t collide with Array
    but they are confusingly close (there would be a similar collision with a variable
    named function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last core tool – filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filter winnows through an array for values that meet some criterion. For example,
    we can filter only positive values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `positive_and_negative` filter, after this run, is as declared; `positive_only`
    has the array value of `[1, 2, 3, 4]`.
  prefs: []
  type: TYPE_NORMAL
- en: Filter is useful for narrowing down the contents of an array. If we have an
    array, as the preceding one, with the contact information of Mr. Smith, we can
    access fields to narrow down to things that may be of our interest. We can state
    that we want only one state, or require a phone number with a particular telephone
    area code, or state some other criterion on anything that a function can tell.
    If our record includes GPS coordinates, we can filter the contents to include
    only the results within a particular radius of a specific central point. All we
    need is a function that will return true for the records that we want to include
    and false for those that we don't.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of information hiding in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In general—meaning any programming language, client-side, server-side, non-web,
    mobile application, and almost anything else, perhaps even microcontrollers (which
    can now run a stripped-down Python)—there are different methodologies that generally
    have their own strengths and weaknesses. Steve McConnell''s *Code Complete: A
    Practical Handbook of Software Construction* ([http://tinyurl.com/reactjs-code-complete](http://tinyurl.com/reactjs-code-complete))
    discusses different methodologies and covers, for instance, how object-oriented
    programming''s sweet spot is with larger projects than are really procedural programming''s
    sweet spot. For most methodologies, his suggestion is that they have their strengths,
    weaknesses, and sweet spots, and under conditions X and Y, you should consider
    methodology Z. But there is one exception—information hiding. His simple advice
    on when to use information hiding is "As much as you can".'
  prefs: []
  type: TYPE_NORMAL
- en: Procedural or structured programming is perhaps easy to overlook, and it's not
    pushing the envelope to use its strengths. But suppose we look at it when it first
    came out, with its functions/procedures, if-then-else, `for`/`while` loops, and
    procedure bodies not open to prying eyes. Now, if we compare this to straight
    assembler or machine code, with pre-Dijkstra-style use of gotos that do not even
    pretend to emulate structured control flow, then we understand that procedural
    or structured programming is really, really astounding. Also, it comes as a blinding
    flash of the obvious today because it has largely succeeded, to everyone's benefit.
    Flowcharts, which in the past were essential lifesavers for anybody hoping to
    understand a complex system, have become a novelty item. They appear on a mug,
    in an XKCD comic that shows how to deliver excellent tech support, or in other
    whimsical uses, as they are no longer needed to give any kind of road map to give
    some people—a sense of how to find their way through spaghetti.
  prefs: []
  type: TYPE_NORMAL
- en: Now a large system may be vastly more complex, and vastly larger than would
    fit into the memory or disk of an old, flowcharted, goto-navigated program, but
    procedural programming has effectively exorcized that ghost. Also, newer iterations
    in software engineering paradigms, such as object-oriented programming, have cut
    down the difficulty of understanding large systems. And in both cases, much of
    the benefit is a practical way to advance information hiding. With structured
    programming, you can navigate through source code without having to keep track
    of every point where the assembler or machine language renders a jump (that is,
    a goto). Both structured and object-oriented programming have historically allowed
    developers to unprecedentedly treat more of the program as a set of closed black
    boxes, and you only need to open and inspect a small fraction of them. They deliver
    information hiding.
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of information hiding in JavaScript](img/B04108_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding flowchart is a novelty flowchart from [http://xkcd.com/627/](http://xkcd.com/627/).
    I've never seen a real flowchart for a program that someone and I were talking
    about.
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard textbook example of information hiding, in classic Java, might be
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncharacteristic of a good example of live Java classes from production, this
    class has one private and four public members. The usual goal is to make the interesting
    heavy lifting as well hidden as possible and just present a simplified facade
    to the rest of the world. This is how Java''s object-oriented programming delivers
    information hiding, and even though there are important differences between object-oriented
    languages and how they approach and handle objects, this is one of Java''s strong
    suits. Not only are object methods supposed to be written procedurally—as black
    boxes that have defined inputs and outputs—but they are also encapsulated in objects,
    where multiple smaller black boxes can be subsumed under a larger black box. In
    this case, we see another benefit of information hiding: we are largely protected
    from the outside and free to make whatever internal changes we want without breaking
    outside usage, as long as we preserve the same behavior. Suppose we decide to
    keep a log of when the counter was changed and to what value. That''s at least
    another private field and changes to the internals of the methods that represent
    the public interface, but we can make the changes without altering any single
    detail of any class that accesses this class. Now suppose we want even more logging
    and we want our log to record a full-stack trace. Internally, we need to use something
    such as `Thread.currentThread.getStackTrace()`, but externally, no one needs to
    know or care about our refactoring. In a larger class, we might find a bottleneck
    that can be improved considerably by switching to another equivalent algorithm.
    Because of the way Java''s object-oriented programming delivers information hiding,
    we can make an awful lot of changes without disturbing other people, who can use
    our work without troubling themselves about anything other than our public interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Information hiding with JavaScript closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to look a little further to see the patterns of information hiding.
    In Java, you are quickly taught the language features for information hiding,
    and encouraged with words such as the security maxim—"Stinginess with privileges
    is kindness in disguise"—to err on the side of declaring things non-public. In
    JavaScript, there may be future-reserved words such as `public`, `private`, and
    `protected` (which Douglas Crockford suggested may be there for Java programmers
    to feel more at home with JavaScript at the expense of understanding JavaScript's
    better side), but there are not the same kind of obvious mechanisms now. All of
    an object's members, whether they are functions are not, are open for inspection.
    JSON—another thing that spread like wildfire, but without people cursing its simplicity—has
    no mechanism offered to mark anything as non-public.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is a technique to create private fields in a feature of some
    functional languages called a closure. It isn''t exactly a technique that is simply
    present in the language to create information hiding, but it allows us to create
    objects with non-public information. To port the functionality of the preceding
    example, including the non-public state, we can have something shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The example given here suggests how we might expand it. A more involved example
    could have more `var` functions storing fields and functions, and return a dictionary
    that would expose its public interface. But let's not simply jump for that; there
    are some interesting things along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a functional language, functions can contain other functions. Indeed, given
    JavaScript''s syntax—where functions are first-class entities that can be stored
    in variables, passed as arguments, and so on—it would be surprising if functions
    could not be nested even two deep. So, the following syntax is legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But the same can legally be wrapped in a function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It is a basic feature of functional languages, including JavaScript's heritage,
    that inner functions can see variables from outer functions; hence both `a` and
    `b` are equally available to the `inner` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what happens if we change the `outer` function to return the `inner` function?
    Then we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: By the time the function finishes executing, its variables have fallen out of
    scope. JavaScript now has `var` variables with the function scope and is in the
    process of getting `let` variables with the block scope, but any variables declared
    in either way in the `outer` function are no longer available. However, something
    interesting has happened; the `inner` function has survived the end of the `outer`
    function, but in a logically consistent fashion. The `inner` function should and
    does have access to its execution context. We have a closure.
  prefs: []
  type: TYPE_NORMAL
- en: This phenomenon can be used for information hiding, and information hiding is
    important. However, it may be argued that what is most interesting here is not
    that it can include non-public variables, potentially including functions, but
    that the execution context as a whole is maintained as long as something with
    access to it survives. This leaves an interesting territory to explore. A StackOverflow
    member once commented, "Objects are poor man's closures," and both objects and
    closures have interesting possibilities beyond the FAQ entry about how to use
    their features for information hiding. Even code complete, which may strongly
    endorse information hiding, never says, "Use information hiding as much as possible
    but nothing else."
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps it would be harsh to blame functional language purists for saying, "JavaScript
    has to wait until it becomes 2 decades old before implementing tail call optimization,
    instead of punishing standard functional programming's use of recursion—as in,
    old enough to go from being a newborn infant to an adult under US laws." However,
    irrespective of anything else that may irk functional programmers about JavaScript,
    JavaScript did get closures right enough from the beginning, so much so that closures
    that retained the execution context were, and remain, a significant feature in
    JavaScript all the way along. And 2 decades later, they remain the primary, and
    possibly only, information hiding resource in most browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we hit a few notes of functional programming in relation to
    JavaScript. We looked mainly at three topics. Custom sort functions provide a
    simple and useful glimpse at how we can pass a helper function to a higher order
    function to obtain more useful behavior than the default. Map, reduce, and filter
    are the three workhorses of functional programming with respect to arrays. With
    Closures and information hiding, we took a look at a functional way of providing
    some core interest in responsible software development.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a multiparadigm language with functional roots and some functional
    language strengths, although it is perhaps uncommon for functional language purists
    to lump JavaScript together with imperative multiparadigm languages. JavaScript
    does not have, as some functional languages do, permanent binding on assignments
    or purely immutable data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'All languages have better and worse neighborhoods, but JavaScript so starkly
    combines excellent parts and terrible parts that the basic approach of Crockford''s
    *JavaScrpt: The Good Parts* and *The Better Parts* is not seriously questioned
    among good developers (I wonder why no one has yet sold Kernigan and Ritchie,
    *The C Programming Language*, Second Edition, as *C++: The Good Parts*). It would
    be provocative to the point of being obnoxious to argue that defaulting to dumping
    things on a global object is a good idea for developing web applications. This
    extends to the functional aspects of JavaScript as well. JavaScript was the first
    mainstream language to allow anonymous functions, or lambdas, which have been
    staples of functional programming roughly since LISP appeared over 50 years ago.
    Even if even Java has jumped into that bandwagon now, its presence in mainstream
    languages is from JavaScript''s influence. JavaScript has also had closures from
    the beginning. As far as some of the worse neighborhoods are concerned, it seems
    to have taken decades for JavaScript to apply tail call optimization, and with
    it, the functional programming style of using tail recursion without the penalty
    instead of for and `while` loops to structure iterative work.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming is an interesting topic and something that you can explore
    indefinitely (that is, the list of interesting aspects of functional programming
    that one can profitably explore is an infinite list, even though in the concrete,
    one only ever takes a finite number of items from the left of the list). Without
    trying to settle the question of whether JavaScript should be considered a functional
    language or not, JavaScript is best understood in relation to roots in functional
    programming, and learning to program better in functional languages/paradigms
    should be the basis of better programming in JavaScript. JavaScript may go down
    in history, not only as the language of the Web and perhaps the most crucial language
    for a programmer to know, but also the bridge language through which the goodness
    of functional languages ceased to be known as (like Scheme) "the best language
    you'll never use." Maybe, the strengths of a functional language come to be seen
    as non-negotiable for the construction of serious, mainstream multiparadigm languages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with a look at functional reactive programming.
  prefs: []
  type: TYPE_NORMAL
