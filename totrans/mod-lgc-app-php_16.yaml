- en: Chapter 16. Add a Dependency Injection Container
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the final step in our modernization process. We will remove
    the last vestiges of our page scripts by moving their remaining logic into a dependency
    injection container. The container will be responsible for coordinating all the
    object creation activity in our application. In doing so, we will modify our front
    controller again, and begin adding routes that point to controller classes instead
    of file paths.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this final step in the modernization process, it is best if we have PHP
    5.3 or later installed. This is because we need closures for critical parts of
    the application logic. If we do not have access to PHP 5.3, there is a less viable
    but still workable option for implementing a dependency injection container. We
    address that situation as the last of the "Common Questions" in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What is a Dependency Injection Container?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency injection as a technique is something we have been practicing since
    early in this book. To reiterate, the idea behind dependency injection is that
    we push dependencies into an object from the outside. This is as opposed to creating
    dependency objects while inside a class via the new keyword, or reaching out of
    the current scope to bring in dependencies via the `globals` keyword.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an overview of inversion of control in general and dependency injection
    in specific, read Fowler's article on containers at [http://martinfowler.com/articles/injection.html](http://martinfowler.com/articles/injection.html).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish our dependency injection activities, we have been manually creating
    the necessary objects in a page script. For any object that needed a dependency,
    we created that dependency first, then we created the object that depended on
    it and passed in the dependency. This creation process has sometimes been deeply
    layered, as when the dependencies have dependencies. Regardless of the complexity
    and depth, the logic for doing so is currently embedded in page scripts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind a dependency injection *container* is to keep all that object
    creation logic in a single place, so that we are no longer required to use a page
    script to set up our objects. We can place each piece of object creation logic
    in the container under a unique name, called a service.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: We can then tell the container to return a new instance of any defined service
    object. Alternatively, we can tell the container to create and return a shared
    instance of that service object, so that each time we get it, it is always the
    same instance. Careful combinations of new instances and shared instances of container
    services will allow us to pare down our dependency creation logic.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At no point will we be passing the container into any of the objects that need
    dependencies. To do so would be using a pattern called Service Locator. We avoid
    Service Locator activity because doing so is a violation of scope. When the container
    is inside an object, and that object uses it to retrieve dependencies, we are
    only one step removed from where we started; that is, with the `global` keyword.
    As such, we do not pass the container around -- it stays entirely outside the
    scope of the objects it creates.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: There are many different container implementations in PHP land, each with its
    own strengths and weaknesses. To keep things tailored to our modernization process,
    we will use the *Mlaphp\Di*. This is a stripped down container implementation
    that is well-suited to our transitional needs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Adding a DI Container
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The process for adding a DI container, in general, is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Add a new `services.php` include file to create the container and manage its
    services.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `router` service in the container.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the front controller to include the `services.php` file and use the `router`
    service, then spot check the application.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Extract creation logic from each page script to the container:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service in the container named for the page script controller class.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the logic from the page script into the container service. Rename variables
    as needed to use DI container properties.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Route the page URL path to the container service name (i.e., the controller
    name).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spot check and commit the change.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue until all page scripts have been extracted to the container.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the empty `pages/` directory, commit, push, and notify QA.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a DI Container Include File
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep our existing setup files from growing even larger, we will introduce
    a new `services.php` setup file. Yes, this means adding another `include` to the
    front controller, but if we have been diligent, there are few if any includes
    remaining in our application. This one will be of little import.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to pick an appropriate location for the file. It is probably
    best if it goes along with any other setup files we already have, perhaps in an
    existing `includes/` directory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we create the file with the following line. (We will add much more to
    this file as we continue.) Because the file will be loaded as the last of our
    setup files, we can presume that autoloading will be active, so there is no need
    to load the `Di` class file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What happens as a result is that the new `$di` instance is loaded with all the
    existing global variable values. These values are retained as properties on the
    container. For example, if our setup files create a `$db_user` variable, we can
    now additionally access that value as `$di->db_user`. These are copies, not references,
    so changes to one will not affect the other.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Why do we retain the existing variables as properties?**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Currently, our page scripts access the global variables directly for their creation
    work. However, in a later step, the creation logic will no longer be in the global
    scope. It will be "inside" the DI container. Thus, we populate the DI container
    with a copy of the variables that would have been available otherwise.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Add a Router Service
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a DI container in place, let's add our first service.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the purpose of a DI container is to create objects for us. Currently,
    the front controller creates a *Router* object, so we will add a `router` service
    to the container. (In the next step, we will have the front controller use this
    service instead of creating a *Router* on its own.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `services.php` file, add the following lines:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's examine the service defination a little bit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The service name is `router`. We will use all-lowercase names for service objects
    intended to be created once as shared instances, and fully-qualified class names
    for service objects intended to be created as new instances each time. Thus, in
    this case, our intent is that only a single shared `router` will be available
    via the container. (This is a convention, not a rule that is enforced by the container.)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service definition is a callable. In this case, it is a closure. The closure
    receives no parameters, but it does use the `$di` object from the current scope.
    This makes it possible for the definition code to access container properties
    and other container services while building the service object.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create and then return the object represented by the service name. We do
    not need to check if the object already exists in the container; the container
    internals will do that for us if we ask for a shared instance.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this bit of code, the container now knows how to create a `router` service.
    It is lazy-loaded code that will only be executed when we call `$di->newInstance()`
    (to get a new instance of the service object) or `$di->get()` (to get a shared
    instance of the service object).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Modify the Front Controller
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a DI container and a `router` service definition, we modify
    the front controller to load the container and use the `router` service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have made the following changes from the previous implementation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We added a `require` for the `services.php` container file as the very last
    of our setup includes.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of creating a *Router* object directly, we `get()` a shared instance
    of the `router` service object from the `$di` container.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have changed our dispatching logic somewhat. After we get a `$route` from
    the `$router`, we check to see if the `$di` container `has()` a matching service.
    If so, it treats the `$route` as a service name for a new `$controller` instance;
    otherwise, it treats the `$route` as a file in `pages/` that creates a `$controller`.
    Either way, the code then invokes the controller and sends the response.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After these changes, we spot check the application to make sure the new `router`
    service works properly. If it does not, we undo and redo our changes up to this
    point until the application works as it did before.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: We may wish to commit our changes once the application works. This is so that
    if future changes go bad, we have a known-working state to which we can revert.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Extract Page Scripts to Services
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now comes the final push in modernizing our legacy application. We are going
    to remove our page scripts one-by-one and put their logic into the container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Create a Container Service
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pick any page script and determine what class it uses to create its `$controller`
    instance. Then, in the DI container, create an empty service definition for that
    class name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have this page script:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We the controller class being instantiated is `Controller\ArticlesPage`. In
    our `services.php` file, we create an empty service definition with that name:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we move the page script setup logic into the service definition. When
    we do so, we should note any variables that we expected from the global scope,
    and prefix them with `$di->` to reference the appropriate container properties.
    (Recall that these were loaded from `$GLOBALS` early in the `services.php` file.)
    We also return the controller instance at the end of the definition.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are done, the service definition will look something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we have copied the logic over to the container, we delete the orginal page
    script file from `pages/`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Route the URL Path to the Container Service
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have removed the page script in favor of the container service,
    we need to make sure the *Router* points to the container service instead of the
    now-missing page script. We do this by adding an array element to the `setRoutes()`
    method parameter where the key is the URL path and the value is the service name.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the URL path is `/articles.php` and our new container service
    is named `Controller\ArticlesPage`, we would modify our `router` service like
    so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Spot Check and Commit
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, we check to see if the conversion from page script to container service
    works as we expect. We spot check the URL path to the old page script by browsing
    to or otherwise invoking that URL. If it works, then we know the container service
    has successfully taken the place of the now-deleted page script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'If not, we need to undo and redo our changes to see where things went wrong.
    The most common errors I see here are:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Failure to replace `$var` variables in the page script with `$di->var` properties
    in the service definition
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure to return the object from the service definition
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mismatches between the controller service name and the mapped route value
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we are sure the application routes the URL to the new container service,
    and that the service works properly, we commit our changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We proceed to the next page script and begin the process over again. When all
    page scripts have been converted to container services and then deleted, we are
    done.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Remove pages/, Commit, Push, Notify QA
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we have extracted all of our page scripts to the DI container, the `pages/`
    directory should be empty. We can now safely remove it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: With that, we commit our work, push to the common repository, and notify QA
    that we have new changes for them to review.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we refine our service definitions?
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are done extracting our object creation logic to the container, each
    service definition is likely to be rather long, and probably repetitive. It would
    be nice to reduce the repetition and refine the service definition so as to make
    them short and succinct. We can do so by further extracting each part of object
    creation logic to its own service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we have several services that use a *Request* object, we can
    extract the object creation logic to its own service and then reference that service
    in other services. We can name it to show our intent that it be used as can be
    intended as a shared service (`request`) or as a new instance (`Mlaphp\Request`).
    Other services can then use `get()` or `newInstance()` instead of creating the
    request internally.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Given our earlier `Controller\ArticlesPage` service, we could split it up into
    several reusable services like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice how the `Controller\ArticlesPage` service now references other services
    in the container to build its own object. When we get a new instance of the `Controller\ArticlesPage`
    service object, it addresses the `$di` container to obtain the shared request
    and response objects, the `$user` property, and a new instance of the *ArticleTransactions*
    service object. That, in turn, recursively addresses the `$di` container to obtain
    the dependencies for that service object, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: What if there are includes In the Page Script?
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we have done our best to remove them, it is possible that we still
    have some include files in our page scripts. When we copy the page script logic
    to the container, we have little choice but to copy them as well. However, once
    all our page scripts have been converted to the container, we can look for commonalities
    and begin extracting the include logic either to a setup script or to separate
    classes (which themselves can become services if needed).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Can we reduce the size of the services.php file?
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the number of page scripts in our application, our DI container
    may end up with tens or hundreds of service definitions. This can be a lot to
    manage or scan through in a single file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: If we like, it is perfectly reasonable to split the container into multiple
    files, and make the `services.php` a series of include calls to bring in the various
    definitions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Can we reduce the size of the router service?
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a subset of the DI container file length, the `router` service in particular
    is likely to become very long. This is because we map every URL in the application
    to a service; if there are hundreds of URLs, there will be hundreds of `router`
    lines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative, we can create a separate `routes.php` file and have it return
    an array of routes. We can then include that file in the `setRoutes()` call:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That at least will reduce the size of the `services.php` file, even though it
    does not reduce the size of the routes array.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: What if we cannot update to PHP 5.3?
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples in this chapter show a DI container that uses closures to encapsulate
    object creation logic. Closures only became available in PHP 5.3, so if we are
    stuck on an earlier version of PHP, it looks like using a DI container is simply
    not an option.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This turns out not to be true. With some extra effort and a greater toleration
    for inelegance, we can still build a DI container for PHP 5.2 and earlier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to extend the DI container so that we can add methods to it.
    Then, instead of creating service definitions as closures, we create them as methods
    on our extended container:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: (Notice how we use `$this` instead of `$di` in the method.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Then in our `services.php` file, the callable becomes a reference to this method,
    instead of an inline closure:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is messy but workable. It can also get pretty verbose. Our earlier example
    of splitting up the `Controller\ArticlesPage` ends up looking more like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, we may have to break with some of our style conventions to keep
    the service names looking like their related method names. We also have to shorten
    the service method names intended for new instances down to their ending class
    names, instead of their fully qualified names. Otherwise we find ourselves with
    overly long and confusing method names.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，为了使服务名称看起来像它们相关的方法名称，我们可能不得不打破一些我们的风格约定。我们还必须将用于新实例的服务方法名称缩短为它们的结束类名，而不是它们的完全限定名称。否则，我们会发现自己有着过长和令人困惑的方法名称。
- en: This can get confusing fast, but it does work. In all, it really is better if
    we can upgrade to PHP 5.3 or later.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会很快让人困惑，但它确实有效。总的来说，如果我们能升级到PHP 5.3或更高版本，那真的会更好。
- en: Review and next steps
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾和下一步
- en: At last, we have completed our modernization process. We no longer have any
    page scripts. All of our application logic has been converted to classes, and
    the only remaining include files are part of the bootstrap and setup process.
    All of our object creation logic exists inside a container, where we can modify
    it directly without having to disturb the internals of our objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于完成了现代化的过程。我们不再有任何页面脚本。我们所有的应用逻辑都已转换为类，剩下的唯一包含文件是引导和设置过程的一部分。我们所有的对象创建逻辑都存在于一个容器中，我们可以直接修改它，而不必干扰我们对象的内部。
- en: What could the next step possibly be after this? The answer is continuous improvement
    and it is going to last for the rest of your career.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后可能的下一步是什么呢？答案是持续改进，这将持续到你的职业生涯的最后。
