- en: 'Chapter 10. Demonstrating Functional Reactive Programming in JavaScript: A
    Live Example Part III – A Calendar'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be the most involved in the book. Throughout the book, there
    have been minor to not-so-minor differences between chapters. These are intended
    so that if you meet a fork in the road, this book offers coverage to both options.
    The chapters are intended to be complementary, instead of hitting the same note
    all the time. Here, we will not be revealing much more about core ReactJS, but
    show how to engage a problem with the thorniness of real-world business problems,
    and a solution that engages ReactJS but is not focused on it. We will be engaging
    ReactJS on a more serious application, a calendar with support for recurring events
    that offers more sophistication and power than, for instance, Google Calendar,
    as seen in the upcoming figures. *If you have a 7:00 PM second and fourth Thursdays
    each month Toastmasters' Club meeting, it's supported!* The core functionality
    is very much intended not to be a mere toy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about calendars with repeating calendar entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nuts and bolts for a class and its Hijaxed form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic data types—plain old JavaScript objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rendering function—an outer wrapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering the page—a one-time calendar entry UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expanded user interface for recurring calendar entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering calendar entries—anonymous helper functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main loop for displaying calendar entries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting each day's calendar entries for display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting Markdown in calendar entry descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on one main component at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play it again Sam – an interesting challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a sample screenshot showing how you enter a repeating entry
    in Google Calendar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Play it again Sam – an interesting challenge](img/B04108_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This calendar system is inspired by a private calendar system that uses regular
    expressions matched against a date string, like this: `Wed Apr 29 18:13:24 CDT`.
    Also, there is really quite a lot that can be done with the power of regular expressions.
    An entry to *check car engine fluids*, for instance, *every first Saturday of
    even-numbered months*, is `periodic_Sat.(Feb|Apr|Jun|Aug|Oct|Dec).( 1| 2| 3| 4|
    5| 6| 7)..................,Check fluid levels in car`. This, however, is nothing
    compared to the hairy beast of a truly complex regular expression. But it does
    give a hint on why regular expressions are considered write-only code. It may
    be guessed that even if you are a regular expression writer, you put off checking
    until later (if you have to). In other words, you don''t want to check whether
    the regular expression quoted earlier in this paragraph matches the date for the
    first Saturdays of even-numbered months. This is the effect that regular expressions
    have on programmers, and this regular expression is elegant compared to a URL
    regular expression, which begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code in this chapter is intended to be readable, at times slowly and laboriously,
    but very clearly without a trace of regular expressions. It has been said that
    a programmer has a problem with strings, and says, "I know! I'll use regular expressions!"
    Now the programmer has two problems.
  prefs: []
  type: TYPE_NORMAL
- en: In my own experience, I've been using regular expressions for years, and they
    are by far, byte for byte, my most effective defect injection method, and I often
    get simple regular expressions wrong the first time. This is why I'm following
    others in deprecating regular expressions as Not a Good Part.
  prefs: []
  type: TYPE_NORMAL
- en: The program, by default, presents a relatively simple user interface for entering
    one-time calendar entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of our program''s user interface as it is initially presented,
    without a drill-down into the smorgasbord of options for repeating calendar entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Play it again Sam – an interesting challenge](img/B04108_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Progressive disclosure reserves a more detailed combination of supported items
    for recurring calendar entries, with added controls for repeating calendar entries
    displayed if a user opts to see them.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a screenshot of the more advanced interface for recurring calendar
    entries. Because there are several different ways in which recurring calendar
    entries are often organized, several controls are available.
  prefs: []
  type: TYPE_NORMAL
- en: '![Play it again Sam – an interesting challenge](img/B04108_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Classical Hijaxing works well
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we open the class, one member is conspicuous by its absence—`mixins: [React.addons.LinkedStateMixin]`.
    This member was featured heavily in our previous chapter where we had two-way
    data binding between form fields, for which we specified the HTML field/JSX component''s
    value and this complementary implementation where the form is not controlled (value
    not being specified). Here, form elements are queried in the old-fashioned way
    as they are needed. While ReactJS strongly believes that one-way data binding
    should be the norm, two-way data binding can be legitimate, preferably in a small
    and quarantined area. This chapter and the previous ones are intended to provide
    working examples of two slightly different approaches so as to give a reference
    to the one that you prefer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `getInitialState()` function initializes two items. One is a list for calendar
    entries. The other is a patient who is, on the operating table until the surgery
    is complete and it can be added to the list of live entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of entries: a smaller, basic entry that just gives the
    date for a one-off calendar entry, and a larger, more involved entry that gives
    the fuller information that is needed for a repeating series of calendar entries.
    Another implementation might keep them in separate lists; here, we use one list
    and check individual entries to see whether they have the `repeats` field, which
    recurring series have and one-off calendar entries lack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `handle_submit()` function Hijaxes form submission, taking the entry that
    is on the operating table and filling in its fields, whether for a one-time calendar
    entry or for a series. Then it adds the entry to the list of entries and resets
    the form (it would be simpler to simply `reset()` the form, but this provides
    slightly finer control, updating the default date to today's date so that the
    form's `reset()` does not always reset the page originally loaded to the date).
  prefs: []
  type: TYPE_NORMAL
- en: The entries are formulaic in character—all plain old JavaScript objects, easily
    JSON-serializable—and are, in essence, dictionaries containing strings, integers,
    and Booleans (in two cases, the entries also contain other dictionaries that contain
    strings and integers). There is no use of closures or other more sophisticated
    techniques here; the design is intended to be simple enough for someone to attentively
    read `handle_submit()` and accurately know how one-time and recurring calendar
    entries are represented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `handle_submit()` function pulls from the form information on whether it
    represents a one-time or repeating calendar entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, it adds the entry read from the form to the list of live entries
    and puts a new one in place for further data entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new entry. This will be a one-time calendar entry that can
    be augmented to represent a series later on, if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a screenshot of the calendar with the one one-time event represented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Classical Hijaxing works well](img/B04108_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Built with usability in mind, but there's still room to grow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a note that may address a confusing point of the code: the time units
    represented in an entry are not intended to represent everything that a JavaScript
    Date object represents, but to be maximally compatible with a JavaScript Date
    object. This means, in particular, that some programmer-confusing designs of the
    Date object are accommodated in our code because the JavaScript Date object numbers
    the dates of a month from 1 to 31, just like general calendar use, but months
    are represented from 0 (January) to 11 (December). Similarly, hours range from
    0 to 23 in the Date object.'
  prefs: []
  type: TYPE_NORMAL
- en: This function is a constructor in terms of what it does, but it is not designed
    for the new keyword, as the entire constructor and `this` is something that Crockford
    no longer includes in *The Better Parts* after he tried—in the wake of creating
    AdSafe, which forbade the use of the `this` keyword for security reasons—to take
    the medicine he was prescribing for others. He found that his code got smaller
    and better for the discipline. Working with code built to use `this` is nonnegotiable
    for serious work in ReactJS, but it may be suggested that we should opt out when
    we do not need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more specific detour, as some more perceptive readers may note:
    the initial hours are set to 12 instead of, for instance, 0\. The school that
    says not to allow the user to enter invalid data in the first place can, by itself,
    lead to some "anti-patterns" in usability. Consider the hall-of-shame-worthy interface
    to enter a United States social security number, which should be needed very rarely
    and not because you need an institution-wide identifier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows perhaps the worst way—in terms of usability and user
    interface concerns—of ensuring that (something that could be) a United States
    social security number is entered in an appropriate format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Built with usability in mind, but there''s still room to grow](img/B04108_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This user interface is not appropriate; a much better approach would be to allow
    a text input, use JavaScript to enforce exactly nine digits, and simply ignore
    the hyphens (and preferably any other non-digit characters).
  prefs: []
  type: TYPE_NORMAL
- en: This interface, as implemented, represents careful thoughts but real compromises
    with respect to usability, and a good laboratory could probably improve it nicely
    (the Holy Grail here would be to have one text field where the user types the
    time and the system automagically uses heuristics to identify what was really
    meant, but that system might have trouble identifying whether a calendar entry
    scheduled at 8 is at 8 A.M. or 8 P.M.) Putting A.M. or P.M. immediately after
    the hour and in the same input, as is done a bit further down, is a violation
    of the principle of least astonishment, which says that whatever the software
    does, it should astonish the user the least. The expected approach, which is usually
    the right approach, is to have one field for hours, one field for minutes, and
    one field for A.M. or P.M. But depending on the default values, this allows someone
    with a mid-afternoon commitment to enter 3 for the hours, 15 for the minutes,
    and click on **Save**, only to get an appointment scheduled for 3:15 AM. Mistakes
    are still possible, as they always are, but the design that is taken is intended
    to help people start in the middle of the day and have more of a fighting chance
    of entering the hour that they really intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows our program''s default user interface, without
    the added controls for the user interface. It shows the drop-down menu for the
    hour of the day, intended as a sensible default and to reduce user errors of the
    time being entered as AM or PM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Built with usability in mind, but there''s still room to grow](img/B04108_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One usability improvement on the interface would be to use—instead of a minute
    dropdown—a text field with JavaScript validation, enforcing an integer value from
    0 to 59, possibly with a leading zero before a single-digit value.
  prefs: []
  type: TYPE_NORMAL
- en: But let's move on from the default starting hours of the noon to something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a calendar with a one-time event and a repeating event:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Built with usability in mind, but there''s still room to grow](img/B04108_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Plain old JavaScript objects are all you need
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For one-time calendar entries, the fields are used just as you might expect.
    For series of calendar entries, the date becomes not the time when the calendar
    entry occurs, but the time when it starts. The user interface offers several ways
    that you might narrow down when a calendar entry occurs. This can be said to be
    every first, Tuesday only, and for a particular month. Every selection that is
    made narrows things down further, and so the desired usage is to be just specific
    enough to request the behavior that you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the variable names here are meant to be self-explanatory. Two that
    might need explanation are `frequency` and `month_occurrences`. The `frequency`
    variable has values of `Every`, `Every First`, `Every Second`, `Every Third`,
    `Every Fourth`, `Every Last`, `Every First and Third`, and `Every Second and Fourth`
    (this is the part of the web application that accommodates your Toastmasters''
    meeting at 7:00 P.M. every second and fourth Thursday). The `month_occurrences`
    variable specifies in which month something occurs (0 to 11 as per the JavaScript
    Date object for January to December, or -1 to indicate every month):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot that shows an activity that repeats every other week:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Plain old JavaScript objects are all you need](img/B04108_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Progressive disclosure that starts simply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `on_change()` function is called when the checkbox for repeating calendar
    entries is ticked, and it allows progressive disclosure, displaying the entire
    user interface for repeating calendar entries if the user opts for them. It toggles
    `this.state.entry_being_added.repeats`, which is respected by the `render()` function.
    This function displays the additional form area if the entry that is presently
    on the operating table has a `repeats` field, and it is true. If the entry does
    not have a `repeats` field, a new series is created, any time data already entered
    in the one-time calendar entry is copied over, and the new and (partly) blank
    entry is placed on the operating table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows an event that happens every other week live
    in the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Progressive disclosure that starts simply](img/B04108_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A render() method can easily delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The (outer) `render` function, is more of a wrapper than a workhorse. It displays
    the fields for a one-time calendar entry that belongs to both one-time calendar
    entries and series. Additionally, if the calendar entry that is on the operating
    table is a recurring calendar entry (which will be true only if the checkbox that
    indicates a recurring calendar entry is checked), this function includes the added
    form elements that are appropriate for a recurring calendar entry:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JSX syntax is surprisingly forgiving. However, it does have some rules,
    and they are enforced with descriptive error messages, including that if there
    are multiple elements, they need to be wrapped in an enclosing element. So, you
    do not write `<em>Hello</em>, <strong>world</strong>!`. Instead, you write `<span><em>Hello</em>,
    <strong>world</strong>!</span>`. But given a few other ground rules, JSX will
    do the right thing for a remarkably broad stretch of uses and abuses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a `render()` method, which is a central method for any component you
    define. In some cases the `render()` method will not be monolithic, but will delegate
    some or all of its work to other methods. Let''s explore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Boring code is better than interesting code!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Readers familiar with Terry Pratchett would have probably heard of *Interesting
    Times*, which opens with something that has been misattributed to China in an
    urban legend: There is a curse. *They Say: May You Live in Interesting Times!*
    One of the characters, Rincewind (this is not a kind of cheese), is on a perennial
    quest for things that are boring, and boring is precisely what he never gets.
    Part of the book''s plot has Rincewind tricked from living on a remote, boring
    tropical island to a teeming empire where all sorts of interesting things involving
    him keep on happening. For Rincewind, boring is a kind of Holy Grail that keeps
    on slipping through his fingers.'
  prefs: []
  type: TYPE_NORMAL
- en: This code is meant to be *boring*, Rincewind-style. It would be possible to
    write more concise code that would populate a hash (or array) for `hour_options`
    rather than specify the array directly. But it would not be so easily checked
    to see whether it is right or wrong. And developing in this way doesn't mean extra
    typing, which (expert opinions have recognized this) is not any real bottleneck
    in programming.
  prefs: []
  type: TYPE_NORMAL
- en: The way the following code works essentially defines arrays, and then these
    arrays are used to create/form elements (which are mostly `SELECT` populated in
    a straightforward fashion from the arrays). The task that it accomplishes is to
    display the user interface for a one-time calendar entry (plus the checkbox to
    indicate a recurring calendar entry).
  prefs: []
  type: TYPE_NORMAL
- en: There has been a conscious decision in this chapter to do things the boring
    way, with one exception—populating the menu for the number of days in a month
    that is intended. This could be 28, 29, 30, or 31 days. We show the code to generate
    the dropdown menu for hours; minutes (and months) are simpler examples of the
    same pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No programmer's wrists were harmed in the production of this chapter (it really
    didn't take that much typing or development time).
  prefs: []
  type: TYPE_NORMAL
- en: A simple UI for simply non-recurring entries...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the more basic type of calendar entry, the kind that only happens once,
    we collect the date, month, and year, defaulting to the current date's values.
    Some things are "all-day" events for that day, such as someone's birthday; others
    start at a specific time. The interface could possibly be expanded to include
    optional end time. This functionality would be an extension of the same principles
    demonstrated here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin to see the UI for rendering basic entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSX here is similar to others that we have seen before; it is provided
    to reinforce what it would be like in a case like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a dropdown for the day of a month that the user selects, and try to
    provide a slightly nicer alternative to making a first through a 31st year round
    (users shouldn''t be required to know which months have 30 days). We query the
    form''s month dropdown for the month that is presently selected. As a reminder,
    we are aiming for compatibility with JavaScript''s Date object, and while a JavaScript
    Date object can have a 1-based date value from 1 to at most 31, the month value
    is 0-based, from 0 (January) to 11 (December), and we follow this lead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The user can still opt-in for more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method is similar to the previous one, but displays the entire interface
    for repeating calendar entries. It shows further variations on the theme.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the present implementation goes with the intersection of all restricting
    criteria for recurring calendar entries is good enough for a first pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `frequency_options` functions are populated slightly differently from other
    fields; while this could also have been done with the date options, `SELECT` is
    populated in the `<option>description</option>` format, as opposed to the (usually
    secondary) `<option value="code">description</option>` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The weekdays are straightforward even if they break the pattern of populating
    `SELECT`, in a situation where a checkbox is the more obvious type of input. A
    radio button for selecting one day is also conceivable, but we are trying to accommodate
    more use cases, and a calendar entry with recurring Tuesdays and Thursdays or
    recurring Mondays, Wednesdays, and Fridays is common. Also, these aren''t the
    only patterns in which something occurs more than once per week (it would be nice
    if a college student using our program did not have to make more than one entry
    for classes that meet more than once per week):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding being clever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see a subtlety (which is less obvious when scrolling through the code
    than looking at the user interface): there are two separate dropdown menus with
    their own populating arrays representing the month. The reason for this is that
    in one case, there is supposed to be a choice, not only between specific months,
    but also between specifying one month only and all months. That menu includes
    an option of `[-1, "Every Month"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other example is for the (optionally specified) end date for a series of
    calendar entries. This is a use case where it does not really make sense to specify
    that something ends every month. The intended use is to give the day, month, and
    year on which something stops displaying. The combination of these two use cases
    makes for two separate, non-cookie-cutter ways of choosing a month. The more exclusive
    could be gotten from the more inclusive with an `array.slice(1)` function, but
    we are again going for Rincewind-style, boring code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These are baked into two separate arrays in a user interface that is slowly
    built up to calendar "entry-ually" include the last option, a checkbox to mark
    that the repeating calendar entry ends on a certain date, and fields to specify
    which date, month, and year it ends on, drawing on the first of the two preceding
    arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous two major methods are building forms for a user to enter data.
    The next method switches gears somewhat; it is set to display upcoming calendar
    entries from the present date to a year after the last scheduled one-time calendar
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous helper functions may lack pixie dust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Internally, calendar entries are segregated into one-time and recurring calendar
    entries. Premature optimization may be the root of all evil, but when it comes
    to working on calendars on other systems, looking at every calendar entry for
    every day has worse performance characteristics, roughly *O(n * m)* instead of
    the slight mindfulness shown here, which is closer to *O(n + m)*. Calendar entries
    are displayed as an H2 and a UL, each given a CSS class to facilitate styling
    (at present, the project has this portion as an unstyled, blank canvas):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code, unusually for the examples we have seen so far, uses the `var that
    = this;` hack. In general, ReactJS guarantees that this is available at any time
    and not only when a function is first run. However, ReactJS does not ensure that
    inner functions will have the same benefits as top-level methods, and in general,
    it may be recommended that you use an inner function inside a top-level method
    only if you can do without at least some of ReactJS's pixie dust. Inner functions
    are here used as, for example, detached comparators. They don't interact directly
    with ReactJS and are limited with respect to what is available in terms of direct
    interaction with ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a comparator. It is written to be boring, as are other parts
    of this method; more terse replacements are readily available, but would lose
    plodding, "Rincewind-boring" clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `successor()` function uses modified one-time entries as representations
    of days. These keep the date, month, year, and also the number of days in the
    future that a day represents. The original entry used as a day has the number
    of days (`0`) added to it as a member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect of the design is to eschew creating functions so anonymously
    that they''re not assigned to a variable. The `successor()` function is written
    for a `for` loop analogous to the `for(var index = 0; index < limit; ++index)`
    loop, and it could have been made inline, but it would have been much less clear
    (and much less boring) than if it were pulled out into its own function. This
    may not be needed for a two-line anonymous function, but here the code appears
    to be clearer and more boring, with `successor()` stored in its own variable with
    a name that is meant to be descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How far in the future should we show?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `greatest` function immediately stores the greatest one-time calendar entry''s
    date that exists in the list, and is then modified to represent the last day that
    will be represented, which is a year after the greatest one-time calendar entry
    found (if there are recurring calendar entries, there will probably be a number
    of instances rendered after the last one-time calendar entry):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Different stripes for different entry types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calendar entries are segregated into one-time and repeating entries, so only
    a probable minority of repeating calendar entries are checked for every day. One-time
    calendar entries are put into a hash with a key straightforwardly taken from their
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to display!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the `for` loop mentioned earlier; it is considerably more readable
    with `compare()` and `successor()` pulled into their own variables with descriptive
    names rather than inline. For each day, the loop compiles a (possibly empty) list
    starting with one-time activities for that day, and checks all recurring calendar
    entries against it. For a recurring calendar entry, it starts out with `accepts_this_date`
    as `true`, indicating that the calendar entry does occur on that day, and then
    each of the criteria for a repeating date has a cumulative opportunity to say
    that the criterion they are checking is not met and veto that calendar entry happening
    on that day. If a recurring calendar entry passes through the gauntlet without
    any vetoes, it is added to the calendar entries displayed for that day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's be nice and sort each day in order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that all the calendar entries, both one-time and recurring, have been assembled
    for the day, they are sorted. We begin with the all-day activities, which are
    sorted alphabetically, and then proceed with the calendar entries that occur at
    a specific time, sorted by time ascending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The day is displayed in a human-friendly fashion; it''s `Monday`, not `Mon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let them use Markdown!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The description for activities supports Markdown. Note—as is pointed out in
    Facebook's own documentation on the deliberately named `dangerouslySetInnerHTML`—that
    we are implicitly trusting Showdown (which provided our `converter`) to be secure.
    There also exist tools intended to tag clean and sanitize HTML in a fashion appropriate
    for XSS-secure display of HTML here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We strip off open and close `P` tags, so that the descriptions will appear
    on the same line as any time or other information given by the day''s ordered
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: One thing at a time!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, in the top-level `Pragmatometer` class, we comment out the display
    of `Todo`, so that only this will display while we are working on it. Next, we
    comment out the `Calendar` component to work on the scratchpad, and when this
    is done, the final integration will place these elements in the four corners of
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The holidays that inspired this calendar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, you can see the calendar set up and gracefully accommodating all the
    holidays in a list of American holidays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The holidays that inspired this calendar](img/B04108_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each nation has its own holidays, and no disrespect is meant to other nations
    and their holidays, but I know U.S. holidays better than those of other nations,
    and the approach in this chapter is partly shaped by accommodating almost all
    major holidays. The exception is Easter/Pascha (with Good Friday 2 days before),
    which is calculated according to a very specific algorithm, but one much more
    intricate than anything else we cover in this project, and it actually has two
    different algorithms for most Catholics and Protestants on one hand, and most
    Orthodox on the other. It could perhaps be included as a special case, but it
    is not entirely clear how one can create a generic solution that will accommodate
    equally complex calculations without a compromise of security (The most promising
    route for that would probably be to allow calculations in a sandbox based on Douglas
    Crockford's AdSafe project, which would allow a fairly free hand in calculations
    without needing to compromise overall page security).
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from Good Friday and Easter, the main official holidays in the U.S. are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: New Year's Day (January 1, fixed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Martin Luther King Day (third Monday in January)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: President's Day (third Monday in February)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memorial Day (last Monday in May)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independence Day (July 4, fixed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labor Day (first Monday in September)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Columbus Day (second Monday in October)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Veteran's Day (November 11, fixed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanksgiving (fourth Thursday in November)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Christmas (Western, December 25, fixed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Year's Eve (December 31, fixed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This system, is similar to the private calendar that served as its inspiration,
    is intended (among other things) to be powerful enough to allow calculation of
    floating and fixed holidays (with the regretted and intricately complex exception
    of Easter/Pascha), Also, it provides a very straightforward interface to enter
    every single holiday on the bulleted list, and much more. With a modern calendaring
    system, people in the U.S. do not research holidays on Wikipedia, and manually
    enter in their calendars that Thanksgiving is on the fourth Monday in November.
    They include a calendar that lists the holidays. However, this system is flexible
    enough for someone so inclined in any country to get a very direct interface to
    enter these holidays or others following the anticipated pattern or others like
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was meant to provide a slightly more involved example of a user
    interface built on ReactJS that has non-toy functionality. We saw both rendering
    code and backend-type functionality, that adds depth beyond a user interface alone.
    The approach was intended to be complementary to the previous chapter, in terms
    of (for instance) controlled inputs that specify what their value will be, as
    opposed to near classic Hijaxing of queried forms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From a usability perspective, the best way of handling user input for recurring
    calendar entries is probably not to directly tweak and enhance a complex and somewhat
    heterogeneous form, as we have done here. The kind of advanced recurring events
    we use here are a use case for a wizard or interview approach.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at a calendaring system that uses ReactJS in the kind of messy problem
    solving that we encounter in the real world. We have an approach to sophisticated
    render methods. With respect to usability, which ReactJS developers should perhaps
    be the most sensitive to (as they are the people most responsible for development
    that touches usability), there has been attention and a constant eye on usability,
    coupled with awareness that the user interface could stand improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we looked at boring code and boring plain old JavaScript objects
    that rather work extremely well when we need records. Finally, we looked at the
    holidays for a specific nation that our calendar was intended to be powerful enough
    to depict with its recurring event facilities.
  prefs: []
  type: TYPE_NORMAL
- en: Join us in the next chapter as we look at incorporating a third-party (non-ReactJS)
    tool and integrate the code of various applications into a single page.
  prefs: []
  type: TYPE_NORMAL
