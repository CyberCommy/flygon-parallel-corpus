- en: '*Chapter 10*: Using Different Kinds of IPC'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the various ways we can communicate between
    processes via so-called **inter-process communication** (**IPC**). We will write
    various programs that use different kinds of IPC, from signals and pipes to FIFOs,
    message queues, shared memory, and sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Processes sometimes need to exchange information—for example, in the case of
    a client and a server program running on the same computer. It could also be a
    process that has forked into two processes, and they need to communicate somehow.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple ways in which this IPC can happen. In this chapter, we'll
    learn about some of the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing about IPC is essential if you want to write more than the most basic
    of programs. Sooner or later, you'll have a program consisting of multiple pieces
    or multiple programs that needs to share information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using signals for IPC—building a client for the daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating with a pipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FIFO—using it in the shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FIFO—building the sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FIFO—building the receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queues—creating the sender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queues—creating the receiver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating between child and parent with shared memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using shared memory between unrelated processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix socket—creating the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix socket—creating the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need the GCC compiler, the Make tool, and the generic
    Makefile from [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving
    Deep into C in Linux*. If you haven't installed these tools yet, please see [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*, for installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: All the code samples—and the generic Makefile—for this chapter can be downloaded
    from GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3u3y1C0](https://bit.ly/3u3y1C0)'
  prefs: []
  type: TYPE_NORMAL
- en: Using signals for IPC – building a client for the daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already used signals several times in this book. However, when we did,
    we always used the `kill` command to send the `my-daemon-v2`, from [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical example of when signals are used for **IPC**. The daemon has
    a small "client program" that controls it, so that it can stop it, restart it,
    reload its configuration file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use signals for IPC is a solid start in writing programs that
    can communicate between them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the generic
    Makefile. You will also need the `my-daemon-v2.c` file from [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*. There is a copy of that file in this
    chapter's GitHub directory at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll add a small client program to the daemon from [*Chapter
    6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245), *Spawning Processes and Using
    Job Control*. This program will send signals to the daemon, just like the `kill`
    command does. However, this program will only send signals to the daemon, no other
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `my-daemon-ctl.c`. This program
    is a bit longer, so it''s split up into several steps. All the code goes into
    the same file, though. We''ll start with the include lines, the prototype for
    the usage function, and all the variables we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we want to be able to parse command-line options. We''ll only need two
    options; that is, `-h` for help and `-k` to kill the daemon. The default is to
    show the status of the daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s open the `cmdline` file in `/proc`. Then, we must open that file
    and read the complete command-line path from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have both the PID and the full command line, we can double-check
    that the PID belongs to `/usr/local/sbin/my-daemon-v2` and not some other process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we give the `-k` option to the program, we must set the `killit` variable
    to 1\. So, at this point, we must kill the process. Otherwise, we just print a
    message stating that the daemon is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create the function for the `printUsage()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we go any further, make sure you have disabled and stopped the `systemd`
    service for the daemon from [*Chapter 7*](B13043_07_Final_SK_ePub.xhtml#_idTextAnchor299)*,
    Using systemd to Handle Your Daemons*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile the daemon (`my-daemon-v2.c`) if you haven''t done so already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, start the daemon manually (no `systemd` service this time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try out our new program to control the daemon. Notice that we can''t
    kill the daemon as a regular user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rerun the program once the daemon has been killed, it will tell us that
    there''s no PID file and that the daemon is therefore not running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the daemon creates a PID file, we can use that file to get the PID of
    the running daemon. The daemon removes the PID file when it is terminated, so
    we can assume that the daemon isn't running if there's no PID file.
  prefs: []
  type: TYPE_NORMAL
- en: If the PID file does exist, first, we read the PID from the file. Then, we use
    the PID to assemble the path to that PID's `cmdline` file in the `/proc` filesystem.
    Each process on a Linux system has a directory in the `/proc` filesystem. Inside
    each process's directory, there is a file called `cmdline`. That file contains
    the complete command line of the process. For example, if the daemon was started
    from the current directory, it contains `./my-daemon-v2`, while if it was started
    from `/usr/local/sbin/my-daemon-v2`, it contains that complete path.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the PID of the daemon is `12345`, the complete path to `cmdline`
    is `/proc/12345/cmdline`. That is what we assemble with `sprintf()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we read the content of `cmdline`. Later, we use that file's content to
    verify that the PID does match a process with the name `my-daemon-v2`. This is
    a safety measure so that we don't kill the wrong process by mistake. If the daemon
    is killed with the `KILL` signal, it has no chance to remove the PID file. If
    another process gets the same PID in the future, we run the risk of killing that
    process instead. PID numbers will eventually be reused.
  prefs: []
  type: TYPE_NORMAL
- en: When we have the PID of the daemon and have verified that it does belong to
    the correct process, we will either get its status or kill it, depending on whatever
    we specified with the `-k` option.
  prefs: []
  type: TYPE_NORMAL
- en: This is how many control programs work that are used to control complex daemons.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the `kill()` system call, see the `man 2 kill` manual
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with a pipe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll create a program that forks and then communicates between
    two processes using a **pipe**. Sometimes, when we **fork** a process, the **parent**
    and the **child** need a way to communicate. A pipe is often a simple way to do
    just that.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to communicate and interchange data between a parent and a child
    process is important when you're writing more complex programs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll only need the GCC compiler, the Make tool, and the generic
    Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write a simple program that forks:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the following code in a file and name it `pipe-example.c`. We'll go through
    the code step by step. Remember that all the code goes in the same file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll start with the include lines and the `main()` function. Then, we''ll
    create an integer array of size 2\. The pipe will use that array later. The first
    integer in the array (0) is the file descriptor for the read end of the pipe.
    The second integer (1) is for the write end of the pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the pipe using the `pipe()` system call. We''ll give it
    the integer array as an argument. After that, we''ll fork using the `fork()` system
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are inside the parent process, we close the read end (since we only want
    to write from the parent). Then, we write a message to the pipe''s file descriptor
    (the write end) using `dprintf()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the child, we do the opposite; that is, we close the write end of the
    pipe. Then, we read the data in the pipe using the `read()` system call. Finally,
    we print the message using `printf()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile the program so that we can run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the program. The parent sends the message `Hello from parent` to
    the child using a pipe. Then, it''s the child that prints that message on the
    screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pipe()` system call returns two file descriptors to the integer array.
    The first one, `pipefd[0]`, is the read end of the pipe, while the other, `pipefd[1]`,
    is the write end of the pipe. In the parent, we write a message to the *write
    end* of the pipe. Then, in the child process, we read that data from the *read
    end* of the pipe. But before we do any reading or writing, we close the end of
    the pipe that we're not using in the respective process.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes are one of the more common IPC techniques around. But they do have a drawback
    in that they can only be used between related processes; that is, processes with
    a common parent (or a parent and a child).
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s another form of pipe that overcomes this limitation: the so-called
    *named pipe*. Another name for a named pipe is FIFO. That''s what we will cover
    in the next recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about the `pipe()` system call can be found in the `man 2 pipe`
    manual page.
  prefs: []
  type: TYPE_NORMAL
- en: FIFO – using it in the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, I mentioned that there's a disadvantage to the `pipe()`
    system call—it can only be used between related processes. But there's another
    type of pipe we can use, called a **named pipe**. Another name for it is **First
    In, First Out** (**FIFO**). Named pipes can be used between any processes, related
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: A named pipe, or a FIFO, is actually a special kind of file. The `mkfifo()`
    function creates that file on the filesystem, just like any other file. Then,
    we use that file to read and write data between processes.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a command named `mkfifo`, which we can use directly from the shell
    to create named pipes. We can use this to pipe data between unrelated commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this introduction to named pipes, we'll cover the `mkfifo` command. In the
    next two recipes, we'll write a C program using the `mkfifo()` function and then
    another program to read the pipe's data.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use named pipes will give you much more flexibility as a user,
    a system administrator, and a developer. You are no longer bound to only using
    pipes between related processes. You'll be free to pipe data between any processes
    or commands on the system—even between different users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we won't write any programs, so there are no special requirements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll explore the `mkfifo` command and learn how to use it
    to pipe data between unrelated processes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by creating a named pipe—a FIFO file. We''ll create it in the
    `/tmp` directory, which is commonplace for temporary files like this. You can,
    however, create it wherever you like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s confirm that''s it indeed a FIFO by using the `file` and `ls` commands.
    Note the current permission mode of my FIFO. It can be read by everyone. This
    can differ on your system, though, depending on your `umask`. But we should be
    vigilant of this in case we are going to pipe sensitive data. In that case, we
    can change it using the `chmod` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try sending data to the pipe. Since the pipe is a file, we will
    use redirections here instead of the pipe symbol. In other words, we redirect
    data to the pipe. Here, we''ll redirect the output of the `uptime` command to
    the pipe. Once we''ve redirected the data to the pipe, the process will hang,
    which is normal since there''s no one on the other end receiving the data. It
    doesn''t actually hang; it *blocks*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up a new terminal and type in the following command to receive the data
    from the pipe. Note that the process in the first terminal will now finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do the reverse; that is, we can open the receiving end first and
    then send data to the pipe. This will **block** the receiving process until it
    gets some data. Run the following command to set up the receiving end, and leave
    it running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we send data to the pipe using the same `uptime` command. Notice that
    once the data is received, the first process will end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also possible to send data to a FIFO from multiple processes. Open up
    three new terminals. In each terminal, type the following command but replace
    1 with 2 for the second terminal and 3 for the third:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open up another terminal and type in the following command. This will
    receive all the messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A FIFO is simply a file on the filesystem, albeit a special file. Once we redirect
    data to a FIFO, that process will **block** (or "hang") until the data is received
    on the other end.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if we start the receiving process first, that process will block until
    it gets the pipe's data. The reason for this behavior is that a FIFO isn't a regular
    file that we can save data in. We can only redirect data with it; that is, it's
    just a *pipe*. So, if we send data to it, but there's nothing on the other end,
    the process will just wait there until someone receives it on the other end. The
    data has nowhere to go in the pipe until someone connects to the receiving end.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple users on the system, you can try sending messages to them
    using FIFOs. Doing so provides us with an easy way to copy and paste data between
    users. Note that the permission mode of the FIFO must allow other users to read
    it (and write to it, if you like). It's possible to set the desired permission
    mode directly while creating the FIFO using the `-m` option. For example, `mkfifo
    /tmp/shared-fifo -m 666` will allow any user to read and write to the FIFO.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a bit more information about the `mkfifo` command in the `man 1 mkfifo`
    manual page. For a more in-depth explanation about FIFOs in general, see the `man
    7 fifo` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: FIFO – building the sender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what a FIFO is, we'll move on and write a program that can
    create and use a FIFO. In this recipe, we'll write a program that creates a FIFO
    and then sends a message to it. In the next recipe, we'll write a program that
    receives that message.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use FIFOs programmatically will enable you to write programs
    that can communicate between themselves using a FIFO directly, without needing
    to redirect the data via the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need the usual tools; that is, the GCC compiler, the Make tool, and the
    generic Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a program that creates a FIFO and sends a message
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `fifo-sender.c`. This code
    is a bit longer, so we''ll cover it step by step here. Remember that all the code
    goes in the same file. Let''s start with the `#include` lines, the prototype for
    the signal handler, and some global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start writing the `main()` function. First, we will create the
    struct for the `sigaction()` function. Then, we will check if the user provided
    a message as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must register the signal handler for all the signals we want to catch.
    We are doing this so that we can remove the FIFO when the program exits. Notice
    here that we are also registering the `SIGPIPE` signal—more on this in the *How
    it works…* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the FIFO with mode `644`. Since mode `644` is octal, we
    need to write it as `0644` in the C code; otherwise, it will be interpreted as
    644 decimal (any number that starts with a 0 in C is an octal number). After that,
    we must open the FIFO using the `open()` system call—the same system call we use
    to open regular files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must create an endless loop. Inside this loop, we will print the user-provided
    message once every second. After the loop, we will close the file descriptor and
    remove the FIFO file. We shouldn''t reach this under normal circumstances, though:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must create the `cleanUp()` function, which we registered as the
    signal handler. We use this function to clean up before the program exits. We
    must then close the file descriptor and remove the FIFO file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start another terminal so that we can receive the message using `cat`.
    The filename we used in the program is `/tmp/my-2nd-fifo`. The message will repeat
    each second. After a couple of seconds, hit *Ctrl* + *C* to exit from `cat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, go back to the first terminal. You'll notice that it says *The receiver
    stopped receiving*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `fifo-sender` program again in this first terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the second terminal again and restart the `cat` program in order to receive
    the messages. Leave the `cat` program running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'While the cat program is running on the second terminal, go back to the first
    one and abort the `fifo-sender` program by hitting *Ctrl* + *C*. Notice that this
    time, it says *Aborting* instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` program in the second terminal has now exited.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this program, we register an extra signal that we haven''t seen before:
    the `SIGPIPE` signal. When the other end terminates—in our case, the `cat` program—our
    program will receive a `SIGPIPE` signal. If we hadn''t caught that signal, our
    program would have exited with signal 141, and no clean-up would have occurred.
    From this exit code, we can figure out that it was due to a `SIGPIPE` signal since
    141-128 = 13; and signal 13 is `SIGPIPE`. See *Figure 2.2* in [*Chapter 2*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Making Your Programs Easy to Script*, for an explanation of reserved return values.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `cleanUp()` function, we use that signal number (`SIGPIPE`, which is
    a macro for 13) to print a special message when the receiver has stopped receiving
    data.
  prefs: []
  type: TYPE_NORMAL
- en: If we instead abort the `fifo-sender` program by hitting *Ctrl* + *C*, we get
    another message; that is, *Aborted*.
  prefs: []
  type: TYPE_NORMAL
- en: The `mkfifo()` function creates a FIFO file for us with the specified mode.
    Here, we specified the mode as an octal number. Any number in C that has a leading
    0 is an octal number.
  prefs: []
  type: TYPE_NORMAL
- en: Since we opened the FIFO using the `open()` system call, we got a `dprintf()`
    to print the user's message to the pipe. The first argument to the program—`argv[1]`—is
    the user's message.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the FIFO stays open in the program, `cat` will also continue to listen.
    That's why we can repeat the message every second in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See `man 3 mkfifo` for an in-depth explanation of the `mkfifo()` function.
  prefs: []
  type: TYPE_NORMAL
- en: For a list of the possible signals, see `kill -L`.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about `dprintf()`, see the `man 3 dprintf` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: FIFO – building the receiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we wrote a program that creates a FIFO and writes a
    message to it. We also tested it using `cat` to receive the messages. In this
    recipe, we'll write a C program that reads from the FIFO.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a FIFO isn't any different than reading from a regular file, or
    let's say, stdin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start this recipe, it's best if you complete the previous recipe
    first. We'll use the program from the previous recipe to write data to the FIFO
    that we'll receive in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the usual tools; that is, the GCC compiler, the Make tool,
    and the generic Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a receiving program for the sender we wrote in
    the previous recipe. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `fifo-receiver.c`. We will
    open the FIFO with a file stream and then read it character by character in a
    loop until we get an **End Of File** (**EOF**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Start `fifo-sender` from the previous recipe and leave it running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up a second terminal and run `fifo-receiver`, which we just compiled.
    Abort it after a couple of seconds by hitting *Ctrl* + *C*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the FIFO is a file on the filesystem, we can receive data from it using
    the usual functions in C, such as file streams, `getc()`, `putchar()`, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: This program is similar to the `stream-read.c` program from [*Chapter 5*](B13043_05_Final_SK_ePub.xhtml#_idTextAnchor182),
    *Working with File I/O and Filesystem Operations*, except that we read character
    by character here instead of line by line.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about `getc()` and `putchar()`, see the `man 3 getc` and
    `man 3 putchar` manual pages, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues – creating the sender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular IPC technique is **message queues**. It's pretty much what the
    name suggests. A process leaves messages in a queue, and another process reads
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of message queues available on Linux: `mq_` functions,
    such as `mq_open()`, `mq_send()`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use message queues enables you to choose from among a variety
    of IPC techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we'll only need the GCC compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll create the sender program. It''s this program that will
    create a new message queue and some messages to it. In the next recipe, we''ll
    receive those messages:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the following code in a file and save it as `msg-sender.c`. Since there
    are some new things in the code, I have broken it up into several steps. All the
    code goes into a single file, though, called `msg-sender.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start with the header files that are required. We also define a macro
    for the maximum message size. Then, we will create a struct of the `mq_attr` type
    called `msgattr`. We will then set its members; that is, we''ll set `mq_maxmsg`
    to 10 and `mq_msgsize` to `MAX_MSG_SIZE`. The first, `mq_maxmsg`, specifies the
    total number of messages in the queue. The second one, `mq_msgsize`, specifies
    the maximum size of a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll take the first argument to the program as the message. So, here, we''ll
    do a check to see if the user typed in an argument or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to open and create the message queue with `mq_open()`. The first
    argument is the name of the queue; here, it's `/my_queue`. The second argument
    is the flags, which in our case are `O_CREATE` and `O_RDWR`. These are the same
    flags that we have seen previously, for example, with `open()`. The third argument
    is the permission mode; once again, this is the same as for files. The fourth
    and last argument is the struct we created earlier. The `mq_open()` function then
    returns a message queue descriptor to the `md` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, finally, we send the message to the queue using `mq_send()`. Here, first,
    we give it the `md` descriptor. Then, we have the message we want to send, which
    in this case is the first argument to the program. Then, as the third argument,
    we must specify the size of the message. Finally, we must set a priority for the
    message; in this case, we will just go with 1\. It can be any positive number
    (an `unsigned int`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we will do before exiting the program is close the message queue
    descriptor with `mq_close()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program. Notice that we must link against the `rt` library, which
    stands for **Realtime Extensions library**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program and send three or four messages to the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we used the POSIX message queue functions to create a new queue
    and then sent messages to it. When we created the queue, we specified that this
    queue can contain a maximum of 10 messages using the `mq_maxmsg` member of `msgattr`.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the maximum length of each message to 2,048 characters using the
    `mq_msgsize` member.
  prefs: []
  type: TYPE_NORMAL
- en: We named the queue `/my_queue` when we called `mq_open()`. A message queue must
    start with a forward slash.
  prefs: []
  type: TYPE_NORMAL
- en: Once the queue was created, we sent messages to it using `mq_send()`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this recipe, we sent three messages to the queue. These messages
    are now queued, waiting to be received. In the next recipe, we'll learn how to
    write a program that receives these messages and prints them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a great overview of the POSIX message queue functionality in Linux in
    the `man 7 mq_overview` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues – creating the receiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we built a program that created a message queue named
    `/my_queue`, and then sent three messages to it. In this recipe, we'll create
    a program that receives the messages from that queue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start this recipe, you need to have completed the previous recipe.
    Otherwise, there will be no messages for us to receive.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the GCC compiler and the Make tool for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll receive the messages we sent in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `msg-receiver.c`. This code
    is a bit longer than the code for the sending program, so it''s been broken up
    into several steps, each one explaining a bit of the code. Remember, though, that
    all the code goes into the same file. We''ll start with the header files, the
    variables, the struct, and a character pointer named `buffer`. We''ll use this
    later to allocate memory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to open the message queue using `mq_open()`. This time, we
    only need to provide two arguments; the name of the queue and the flags. In this
    case, we only want to read from the queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we also want to get the attributes of the message queue using `mq_getattr()`.
    Once we have the attributes of the queue, we can use its `mq_msgsize` member to
    allocate memory for a message of that size using `calloc()`. We haven''t seen
    `calloc()` before in this book. The first argument is the number of elements we
    want to allocate memory for, while the second argument is the size of each element.
    The `calloc()` function then returns a pointer to that memory (in our case, that''s
    `buffer`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will use another member of the `mq_attr` struct called `mq_curmsgs`,
    which contains the number of messages currently in the queue. First, we will print
    the number of messages. Then, we will loop over all the messages using a `for`
    loop. Inside the loop, first, we receive a message using `mq_receive`. Then, we
    print the message using `printf()`. Finally, before iterating over the next message,
    we reset the entire memory to NULL characters using `memset()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first argument to `mq_receive` is the descriptor, the second argument is
    the buffer where the message goes, the third argument is the size of the message,
    and the fourth argument is the priority of the message, which in this case is
    NULL, meaning we receive all messages with the highest priority first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have some cleanup to do. First of all, we must `free()` the memory
    being pointed to by the buffer. Then, we must close the `md` queue descriptor,
    before removing the queue from the system using `mq_unlink()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s receive the messages using our new program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to rerun the program now, it will simply state that no such file
    or directory exists. This is because we removed the message queue with `mq_unlink()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we sent three messages to `/my_queue`. With the program
    we created in this recipe, we received those messages.
  prefs: []
  type: TYPE_NORMAL
- en: To open the queue, we used the same function we used when we created it; that
    is, `mq_open()`. But this time—since we're opening an already existing queue—we
    only needed to provide two arguments; that is, the queue's name and the flags.
  prefs: []
  type: TYPE_NORMAL
- en: Each call to an `mq_` function is error checked. If an error occurs, we print
    the error message with `perror()` and return to the shell with 1.
  prefs: []
  type: TYPE_NORMAL
- en: Before reading the actual messages from the queue, we get the queue's attribute
    with `mq_getattr()`. With this function call, we populate the `mq_attr` struct.
    The two most important members for reading the messages are `mq_msgsize`, which
    is the maximum size of each message in the queue, and `mq_curmsgs`, which is the
    number of messages currently in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: We use the maximum message size from `mq_msgsize` to allocate memory for a message
    buffer using `calloc()`. The `calloc()` function returns "zeroed" memory, which
    its counterpart, `malloc()`, doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allocate memory, we need to create a pointer to the type we want. This is
    what we did at the beginning of the program with `char *buffer`. The `calloc()`
    function takes two arguments: the number of elements to allocate and the size
    of each such element. Here, we want to number of elements to be the same as what
    the `mq_msgsize` value contains. And each element is a `char`, so the size of
    each element should be `sizeof(char)`. The function then returns a pointer to
    the memory, which in our case is saved to the `char` pointer''s `buffer`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, when we receive the queue messages, we save them in this buffer on each
    iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The loop iterates through all the messages. We got the number of messages from
    the `mq_curmsgs` member.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once we finished reading all the messages, we closed and deleted the
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the `mq_attr` struct, I suggest that you read the
    `man 3 mq_open` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the functions we have covered in this and the previous recipe has its
    own manual page; for example, `man 3 mq_send`, `man 3 mq_recevie`, `man 3 mq_getattr`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: If you're unfamiliar with the `calloc()` and `malloc()` functions, I suggest
    that you read `man 3 calloc`. This manual page covers `malloc()`, `calloc()`,
    `free()`, and some other related functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `memset()` function also has its own manual page; that is, `man 3 memset`.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating between child and parent with shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to use **shared memory** between two related
    processes—a parent and a child. Shared memory exists in various forms and can
    be used in different ways. In this book, we'll focus on the POSIX shared memory
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory in Linux can be used between related processes, as we are about
    to explore in this recipe, but also between unrelated processes using `/dev/shm`
    directory. We'll look at this in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll be using *anonymous* shared memory—memory not backed by
    a file.
  prefs: []
  type: TYPE_NORMAL
- en: Shared memory is just what it sounds like—a piece of memory that is shared between
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use shared memory will enable you to write more advanced programs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need the GCC compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a program that uses shared memory. First, before
    forking, the process will write a message to the shared memory. Then, after forking,
    the child will replace the message in the shared memory. And then, finally, the
    parent process will replace the content of the shared memory once again. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and name it `shm-parent-child.c`. As usual,
    I''ll break up the code into several smaller steps. All the code goes into the
    same file, though. First, we''ll write all of the header files. There are quite
    a few of them here. We will also define a macro for the size of our memory. We
    will then write our three messages as character array constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now comes the exciting part—mapping the shared memory space. There's a total
    of six arguments we need to provide to the memory mapping function; that is, `mmap()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first argument is the memory address, which we'll set to NULL—meaning the
    kernel will take care of it for us.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is the size of the memory area.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument is the protection the memory should have. Here, we will set
    it to write and read.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth argument is our flags, which we set to shared and anonymous—meaning
    it can be shared among processes and won't be backed by a file.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth argument is a file descriptor. But in our case, we're using anonymous,
    which means that this memory won't be backed by a file. Due to this, we will set
    it to -1 for compatibility reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last argument is the offset, which we will set to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now that the memory is ready for us, we will copy our first message to it using
    `memcpy()`. The first argument to `memcpy()` is a pointer to the memory, which
    in our case is the `addr` character pointer. The second argument is the data or
    message we want to copy from, which in our case is `startmsg`. The last argument
    is the size of the data we want to copy, which in this case is the length of the
    string in `startmsg` + 1\. The `strlen()` function doesn't include the terminating
    null character; that's why we need to add 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we print the PID of the process and the message in the shared memory.
    After that, we fork:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are in the child process, we copy the child''s message to the shared
    memory. If we are in the parent process, we''ll wait for the child. Then, we can
    copy the parent message to the memory and also print both messages. Finally, we
    will clean up by unmapping the shared memory. This isn''t strictly required, though:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program so that we can take it for a spin. Notice that we are using
    another C standard here—`MAP_ANONYMOUS` macro, but **GNU11** does. **GNU11** is
    the **C11** standard with some extra GNU extensions. Also, note that we link against
    the *Real-Time Extensions* library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shared memory is a common IPC technique between unrelated processes, related
    processes, and threads. In this recipe, we saw how we could use shared memory
    between a parent and a child.
  prefs: []
  type: TYPE_NORMAL
- en: The memory area is mapped using `mmap()`. This function returns the address
    to the mapped memory. If an error occurs, it returns the `MAP_FAILED` macro. Once
    we mapped the memory, we checked the pointer variable for `MAP_FAILED` and aborted
    it in case there was an error.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've mapped the memory and got a pointer to it, we used `memcpy()` to
    copy data to it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we unmapped the memory with `munmap()`. This isn't strictly necessary
    since it will be unmapped anyway when the last process exists. However, it's a
    bad practice not to do so. You should always clean up after yourself and free
    up any allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a more detailed explanation of `mmap()` and `munmap()`, see the `man 2 mmap`
    manual page. For a detailed explanation of `memcpy()`, see the `man 3 memcpy`
    manual page.
  prefs: []
  type: TYPE_NORMAL
- en: For a more in-depth explanation of the various C standards and what the GNU
    extensions are, see [https://gcc.gnu.org/onlinedocs/gcc/Standards.html](https://gcc.gnu.org/onlinedocs/gcc/Standards.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using shared memory between unrelated processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we used shared memory between a child and a parent.
    In this recipe, we'll learn how to use a file descriptor to mapped memory to share
    that memory between two unrelated processes. Using shared memory in this way automatically
    creates an underlying file for the memory in the `/dev/shm` directory, where **shm**
    stands for **shared memory**.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use shared memory between unrelated processes widens your use
    of this IPC technique.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you'll only need the GCC compiler and the Make tool.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we'll write a program that opens and creates a file descriptor for shared
    memory and also maps the memory. Then, we'll write another program that reads
    the memory area. Instead of just a message, as we did in the previous recipe,
    we'll write and retrieve an **array** of three floating-point numbers here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the writer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s create the writer first:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a program that will create a shared memory and write
    some data to it. Write the following code in a file and save it as `write-memory.c`.
    As usual, the code will be broken up into several steps, but all the code goes
    into a single file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just as in the previous recipe, we''ll have a bunch of header files. Then,
    we''ll create all the variables we''ll need. Here, we''ll need a variable for
    a file descriptor. Note that even if I call it a file descriptor here, it''s a
    descriptor to a memory area. `memid` contains the name of the memory-mapped descriptor.
    Then, we must use `shm_open()` to open and create the "file descriptor":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The file-backed memory is 0 bytes in size initially. To extend it to our 128
    bytes, we must truncate it with `ftruncate()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we must map the memory, just as we did in the previous recipe. But this
    time, we will give it the `fd` file descriptor instead of -1\. We have also left
    out the `MAP_ANONYMOUS` part, thus making this memory backed by a file. Then,
    we must copy our array of floats to memory using `memcpy()`. To let the reading
    program have a chance to read the memory, we must pause the program and wait for
    an *Enter* key with `getchar()`. Then, it''s just a matter of cleaning up by unmapping
    the memory and deleting the file descriptor and the underlying file with `shm_unlink()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Creating the reader
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s create the reader:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll write the program that will read the memory area and print the
    numbers for the array. Write the following program and save it as `read-memory.c`.
    This program is similar to `write-memory.c`, but instead of writing to memory,
    we are reading from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile this program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Testing everything
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to try it all out. Open up a terminal and run the `write-memory`
    program that we compiled. Leave the program running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up another terminal and check out the file in `/dev/shm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the read-memory program we just compiled. This will retrieve the three
    numbers from the shared memory and print them on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the terminal where the `write-memory` program is running and hit
    *Enter*. Doing so will clean up and delete the file. Once you have done this,
    let''s see if the file is still in `/dev/shm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using non-anonymous shared memory is similar to what we did in the previous
    recipe. The only exception is that we first open a special file descriptor using
    `shm_open()`. As you might have noticed, the flags are similar to those of the
    regular `open()` call; that is, `O_RDWR` for reading and writing and `O_CREATE`
    for creating the file if it doesn't exist. Using `shm_open()` in this fashion
    creates a file in the `/dev/shm` directory with the name specified as the first
    argument. Even the permission mode is set the same way as regular files—in our
    case, `0600` for reading and writing for the user, and no permissions for anyone
    else.
  prefs: []
  type: TYPE_NORMAL
- en: The file descriptor we get from `shm_open()` is then passed to the `mmap()`
    call. We also left out the `MAP_ANONYMOUS` macro to the `mmap()` call, as we saw
    in the previous recipe. Skipping `MAP_ANONYMOUS` means that the memory will no
    longer be anonymous, meaning it will be backed by a file. We inspected this file
    using `ls -l` and saw that it did indeed have the name we gave it and the correct
    permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The next program we wrote opened the same shared memory file descriptor using
    `shm_open()`. After `mmap()`, we looped over the floating-point numbers in the
    memory area.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once we hit *Enter* in the `write-memory` program, the file in `/dev/shm`
    was removed using `shm_unlink()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's a lot more information about `shm_open()` and `shm_unlink()` in the
    `man 3 shm_open` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Unix socket – creating the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unix sockets** are similar to **TCP/IP** sockets, but they are only local
    and are represented by a socket file on the filesystem. But the overall functions
    that are used with Unix sockets are more or less the same as for TCP/IP sockets.
    The complete name for Unix sockets is *Unix domain sockets*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unix sockets are a common way for programs to communicate locally on a machine.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to use Unix sockets will make it easier to write programs that need
    to communicate between them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you'll only need the GCC compiler, the Make tool, and the generic
    Makefile.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a program that will act as a server. It will receive
    messages from a client and respond with "*Message received*" every time a message
    is received. It will also clean up after itself when either the server or the
    client exits. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the following code in a file and save it as `unix-server.c`. This code
    is a bit longer than most of our previous examples, so it's been broken up into
    several steps. All the code goes in the same file, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are quite a few header files here. We''ll also define a macro for the
    maximum message length that we will accept. We will then write the prototype for
    the `cleanUp()` function, which will be used to clean up the file. This function
    will also be used as a signal handler. Then, we''ll declare some global variables
    (so that they can be reached from `cleanUp()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to start writing the `main()` function and declaring some variables.
    Most of this should be familiar to you by now. We will also register the signal
    handler here for all the signals. What''s new is the `sockaddr_un` struct. This
    will contain the socket type and file path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all the signal handlers, variables, and structures in place,
    we can create a socket file descriptor using the `socket()` function. Once that
    has been taken care of, we will set the type of connection (of the *family* type)
    and the path to the socket file. Then, we will call `bind()`, which will bind
    the socket for us so that we can use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will prepare the socket file descriptor for connections by calling
    `listen()`. The first argument is the socket file descriptor, while the second
    argument is the buffer size we want for the backlog. Once we''ve done that, we
    will accept a connection using `accept()`. This will give us a new socket `datafd`),
    which we will use when we send and receive data. Once a connection has been accepted,
    we can print *Client connected* to the local terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will start the main loop of the program. In the outer loop, we''ll
    just write a confirmation message when we received a message. In the inner loop,
    we''ll read data from the new socket file descriptor, save it in `buffer`, and
    then print it on our terminal. If `read()` returns -1, then something has gone
    wrong, and we must break out of the inner loop to read the next line. If `read()`
    returns 0, then the client has disconnected, and we must run `cleanUp()` and quit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we must create the body for the `cleanUp()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compile the program. This time, we''ll get a warning from GCC about an
    unused variable, `signum`, in the `cleanUp()` function. This is because we never
    used the `signum` variable inside `cleanUp()`, so we can safely ignore this warning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program. Since we don''t have a client, it won''t say or do anything
    just yet. However it does create the socket file. Leave the program as-is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a new terminal and check out the socket file. Here, we can see that it''s
    a socket file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, go back to the terminal with the server program running and abort
    it with *Ctrl* + *C*. Then, see if the file is still there (it shouldn''t be):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sockaddr_un` struct is a special structure for Unix domain sockets. There's
    another one called `sockaddr_in` for TCP/IP sockets. The `_un` ending stands for
    Unix sockets, while `_in` stands for internet family sockets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `socket()` function that we used to create a socket file descriptor takes
    three arguments: the address family (`AF_UNIX`), the type (`SOCK_SEQPACKET`, which
    provides a two-way communication), and the protocol. We specified the protocol
    as 0 since there aren''t any to choose from with a socket.'
  prefs: []
  type: TYPE_NORMAL
- en: There's also a general structure called `sockaddr`. When we pass our `sockaddr_un`
    structure as an argument for `bind()`, we need to typecast it to a `sockaddr`,
    the general type, since that's what the function expects—more precisely, a `sockaddr`
    pointer. The last argument that we supply for `bind()` is the size of the structure;
    that is, `sockaddr_un`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we created the socket and bounded it with `bind()`, we prepared it for
    incoming connections with `listen()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we accepted incoming connections with `accept()`. This gave us a new
    socket file descriptor, which we then used to send and receive messages.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s some deeper information in the manual pages for the functions we used
    in this recipe. I suggest that you check them all out:'
  prefs: []
  type: TYPE_NORMAL
- en: '`man 2 socket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 bind`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 listen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man 2 accept`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix socket – creating the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created a Unix domain socket server. In this recipe,
    we'll create a client for that socket and then communicate between the client
    and the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how we can use the socket to communicate between a
    server and a client. Knowing how to communicate over a socket is essential to
    using sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before doing this recipe, you should have finished the previous recipe; otherwise,
    you won't have a server to talk to.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also need the GCC compiler, the Make tool, and the generic Makefile for
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a client for the server that we wrote in the previous
    recipe. Once they are connected, the client can send messages to the server, and
    the server will respond with *Message received*. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following code in a file and save it as `unix-client.c`. Since this
    code is also a bit longer, it''s been split up into several steps. All the code
    goes in the `unix-client.c` file, though. The first half of this program is similar
    to that of the server, except we have two buffers instead of one and no signal
    handling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of using `bind()`, `listen()`, and `accept()`, we will use `connect()`
    to initiate a connection to the server. The `connect()` function takes the same
    arguments as `bind()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have connected to the server, we can use `write()` to send messages
    over the socket file descriptor. Here, we will use `fgets()` to read the messages
    from the user to a buffer, convert a **newline character** into a **null character**,
    and then write the buffer to a file descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to run the program now. It won''t work since the server hasn''t
    started yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the server in a separate terminal and leave it running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the terminal with the client and rerun it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: You should now see a message in the server saying *Client connected*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write some messages in the client program. You should see them appear in the
    server at the same time you hit *Enter*. After a couple of messages, hit *Ctrl*
    + *C*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch over to the terminal with the server. You should see something similar
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we wrote a socket server. In this recipe, we wrote a
    client that connects to that server using the `connect()` system call. This system
    call takes the same argument as `bind()`. Once the connection has been established,
    both the server and the client can write and read from the socket file descriptor
    (two-way communication) using `write()` and `read()`.
  prefs: []
  type: TYPE_NORMAL
- en: So, in essence, once the connection has been established, it's not that different
    than reading and writing to a file using a file descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information about the `connect()` system call, see the `man 2 connect`
    manual page.
  prefs: []
  type: TYPE_NORMAL
