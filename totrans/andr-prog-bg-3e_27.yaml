- en: '*Chapter 27*: Android Databases'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are going to make apps that offer our users significant features, then
    we are almost certainly going to need a way to manage, store, and filter significant
    amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to store very large amounts of data efficiently with JSON, but
    when we need to use that data selectively rather than simply restricting ourselves
    to the options of "save everything" and "load everything," we need to think about
    what other options are available.
  prefs: []
  type: TYPE_NORMAL
- en: A good computer science course would probably teach you about the algorithms
    necessary to handle sorting and filtering our data, but the effort involved would
    be quite extensive, and what are the chances of us coming up with a solution that
    is as good as something made by the people who gave us the Android API?
  prefs: []
  type: TYPE_NORMAL
- en: As is so often the case, it makes the most sense to use the solutions provided
    in the Android API. As we have seen, the `JSON` and `SharedPreferences` classes
    have their place, but at some point, we need to move on to using real databases
    for real-world solutions. Android uses the SQLite database management system,
    and as you would expect, there is an API to make it as easy as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Find out exactly what a database is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what SQL and SQLite are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the basics of the SQL language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at the Android SQLite API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code the Age Database app that we started in the previous chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2027](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2027).
  prefs: []
  type: TYPE_NORMAL
- en: Databases 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's answer a whole bunch of database-related questions and then we can get
    started making apps that use SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: What is a database?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **database** is both a place of storage and a means to retrieve, store, and
    manipulate data. It helps to be able to visualize a database before learning how
    to use it. The actual structure of the internals of a database varies greatly
    depending upon the database in question. SQLite actually stores all its data in
    a single file.
  prefs: []
  type: TYPE_NORMAL
- en: It aids our comprehension greatly, however, if we visualize our data as if it
    were in a spreadsheet, or sometimes multiple spreadsheets. Our database, like
    a spreadsheet, will be divided into multiple columns, which represent different
    types of data, and rows, which represent entries of the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about a database with names and exam scores. Take a look at this visual
    representation of such data and imagine what it would look like in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 27.1 – Database example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_27.1_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 27.1 – Database example
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice, however, that there is an extra column of data: an _**ID** column.
    We will talk more about this as we proceed. This single spreadsheet-like structure
    is called a **table**. As mentioned before, there might be, and often are, multiple
    tables in a database. Each column of the table will have a name that can be referred
    to when speaking to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: What is SQL?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SQL** stands for **Structured Query Language**. It is the syntax that is
    used to get things done with a database.'
  prefs: []
  type: TYPE_NORMAL
- en: What is SQLite?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite is the name of the database system that is favored by Android, and it
    has its own version of SQL. The reason the SQLite version of SQL needs to be slightly
    different to some other versions is that the database has different features.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL syntax primer that follows will be focused on SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: SQL syntax primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can learn how to use SQLite with Android, we need to first learn the
    basics of how to use SQLite in general, in a platform-neutral context.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some example SQL code that could be used on a SQLite database
    directly, without any Java or Android classes; then we can more easily understand
    what our Java code is doing later on.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite example code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL has keywords, much like Java, that cause things to happen. Here is a flavor
    of some of the SQL keywords we will soon be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT`: Allows us to add data to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: Allows us to remove data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT`: Allows us to read data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WHERE`: Allows us to specify parts of the database, matching specific criteria,
    that we want to use `INSERT`, `DELETE`, or `SELECT` on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FROM`: Used to specify a table or column name in a database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many more SQLite keywords than this; for a full list of types, take
    a look at this link: [https://sqlite.org/lang_keywords.html](https://sqlite.org/lang_keywords.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to keywords, SQL has **types**. Some examples of SQL types are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**integer**: Just what we need for storing whole numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**text**: Perfect for storing a simple name or address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**real**: For large floating-point numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many more SQLite types than this; for a full list of types, take
    a look at this link: [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can combine those types with keywords to create tables
    and add, remove, modify, and read data using full SQLite statements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be a perfectly decent question to ask why we don''t first create a
    new database. The reason for this is that every Android app has access to a SQLite
    database by default. The database is private to that app. Here is the statement
    we would use to create a table within that database. I have highlighted a few
    parts to make the statement clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous code creates a table called `StudentsAndGrades` with an integer
    row ID that will be automatically increased (incremented) each time a row of data
    is added.
  prefs: []
  type: TYPE_NORMAL
- en: The table will also have a `name` column that will be of type `text` and cannot
    be blank (`not null`).
  prefs: []
  type: TYPE_NORMAL
- en: It will also have a `score` column that will be of type `int`. Also, notice
    that the statement is completed by a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data into the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is how we might insert a new row of data into that database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous code added a row to the database. After the preceding statement,
    the database will have one entry with the values (`1`, `Bart`, `23`) for the columns
    (`_ID`, `name`, `score`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we might insert another new row of data into that database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous code added a new row of data with the values (`2`, `Lisa`, `100`)
    for the columns (`_ID`, `name`, `score`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our spreadsheet-like structure would now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 27.2 – Updated spreadsheet'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_27.2_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 27.2 – Updated spreadsheet
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is how we would access all the rows and columns from our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous code asks for every row and column. The `*` symbol can be read
    as "all."
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also be a little more selective, as this code demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would only return `100`, which of course is the score associated
    with the name `Lisa`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the database structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can even add new columns after the table has been created and the data added.
    This is simple, as far as the SQL is concerned, but can cause some issues with
    regard to users'' data on already-published apps. The next statement adds a new
    column called `age` that is of type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are many more data types, keywords, and ways to use them than we have
    seen so far. Next, let's look at the Android SQLite API; we will begin to see
    how we can use our new SQLite skills.
  prefs: []
  type: TYPE_NORMAL
- en: Android SQLite API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of different ways that the Android API makes it fairly easy
    to use our app's database. The first class we need to get familiar with is `SQLiteOpenHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: SQLiteOpenHelper and SQLiteDatabase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SQLiteDatabase` class is the class that represents the actual database.
    The `SQLiteOpenHelper` class, however, is where most of the action takes place.
    This class will enable us to get access to a database and initialize an instance
    of `SQLiteDatabase`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, `SQLiteOpenHelper`, which we will extend in our Age Database app,
    has two methods to override. First, it has an `onCreate` method, which is called
    the first time a database is used; therefore, it makes sense that we would put
    our SQL to create our table structure in.
  prefs: []
  type: TYPE_NORMAL
- en: The other method we must override is `onUpgrade`, which, as you can probably
    guess, is called when we upgrade our database (use `ALTER` to change its structure).
  prefs: []
  type: TYPE_NORMAL
- en: Building and executing queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our database structures get more complex and as our SQL knowledge grows,
    our SQL statements will get quite long and awkward. The potential for errors is
    high.
  prefs: []
  type: TYPE_NORMAL
- en: The way we will help overcome the problem of complexity is to build our queries
    from parts into a string. We can then pass that string to the method that will
    execute the query for us.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we will use `final` strings to represent things such as table and
    column names so we don't get in a muddle with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could declare the following members, which would represent
    the table name and column names from the fictitious example from earlier. Note
    that we will also give the database itself a name and have a string for that too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the preceding code how we will benefit from accessing the strings
    outside the class, as we declare them `public`. You might be thinking that this
    breaks the rules of encapsulation. It does, but when the intention of the class
    is to be used as widely as possible, that is OK. And remember, all the variables
    are final. An external class using these string variables cannot change them or
    mess things up. They can only refer to and use the values that they hold.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could then build a query like in this next example. The example adds a new
    entry to our hypothetical database and incorporates Java variables into the SQL
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice in the previous code that the regular `name` and `score` Java variables
    arehighlighted. The previous string called `query` is now the SQL statement, exactly
    equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is not essential to completely grasp the previous two blocks of code in order
    to proceed with learning Android programming. But if you want to build your own
    apps and construct SQL statements that do exactly what you need, it *will* help
    to do so. Why not study the previous two blocks of code in order to discern the
    difference between the pairs of double-quote marks, `"`, which are the parts of
    the string joined together with `+`; the pairs of single quote marks, `'`, which
    are part of the SQL syntax; the regular Java variables; and the distinct semicolons
    in the SQL statement in the string and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the typing of the query, Android Studio prompts us as to the names
    of our variables, making the chances of an error much lower, even though it is
    more verbose than simply typing the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the classes we introduced previously to execute the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When adding data to the database, we will use `execSQL` as in the previous
    code; when getting data from the database, we will use the `rawQuery` method as
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `rawQuery` method returns an object of type `Cursor`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are several different ways we can interact with SQLite, and they each
    have their advantages and disadvantages. We have chosen to use raw SQL statements
    as it makes what we are doing entirely transparent, as well as reinforcing our
    knowledge of the SQL language. See the next tip if you want to know more.
  prefs: []
  type: TYPE_NORMAL
- en: Database cursors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the classes that give us access to the database and the methods that
    allow us to execute our queries, there is the issue of exactly how the results
    we get back from our queries are formatted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is the `Cursor` class. All our database queries will return
    objects of type `Cursor`. We can use the methods of the `Cursor` class to selectively
    access the data returned from the queries, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would output to logcat the two values stored in the first
    two columns of the result that the query returned. It is the `Cursor` object itself
    that determines which row of our returned data we are currently reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access a number of methods of the `Cursor` object, including the `moveToNext`
    method, which unsurprisingly would move `Cursor` to the next row, ready for reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: On some occasions, we will be able to bind `Cursor` to a part of our UI (such
    as `RecyclerView`), as we did with an `ArrayList` instance in the Note to Self
    app, and just leave everything to the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more useful methods of the `Cursor` class, some of which we will
    see soon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This introduction to the Android SQLite API really only scratches the surface
    of its capabilities. We will bump into a few more methods and classes as we proceed
    further. It is, however, worth studying further if your app idea requires complex
    data management.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can see how all this theory comes together and how we will structure
    our database code in the Age Database app.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the database class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will put into practice everything we have learned so far and finish
    coding the Age Database app. Before our `Fragment` classes from the previous section
    can interact with a shared database, we need a class to handle interaction with,
    and the creation of, the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a class that manages our database by using the `SQLiteOpenHelper`
    class. It will also define some `final` strings to represent the names of the
    table and its columns. Furthermore, it will supply a bunch of helper methods we
    can call to perform all the necessary queries. Where necessary, these helper methods
    will return a `Cursor` object that we can use to show the data we have retrieved.
    It would be trivial, then, to add new helper methods, should our app need to evolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `DataManager` and add the following member variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, we add the constructor that will create an instance of our custom version
    of `SQLiteOpenHelper`. We will actually implement this class as an inner class
    soon. The constructor also initializes the `db` member, which is our `SQLiteDatabase`
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following constructor that we have just discussed to the `DataManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add the helper methods we will access from our Fragment classes.
    Start with the `insert` method, which executes an `INSERT` SQL query based on
    the `name` and `age` parameters passed into the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `insert` method to the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This next method called `delete` will delete a record from the database if it
    has a value in the name column that matches the passed-in `name` parameter. It
    achieves this using the SQL `DELETE` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `delete` method to the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have the `selectAll` method, which also does as the name suggests.
    It achieves this with a `SELECT` query using the `*` parameter, which is equivalent
    to specifying all the columns individually. Also, note that the method returns
    a `Cursor` instance, which we will use in some of the `Fragment` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `selectAll` method to the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we add a `searchName` method that has a `String` parameter for the name
    the user wants to search for. It also returns a `Cursor` instance that will contain
    all the entries that were found. Notice that the SQL statement uses `SELECT`,
    `FROM`, and `WHERE` to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, for the `DataManager` class, we create an inner class that will be
    our implementation of `SQLiteOpenHelper`. It is a barebones implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We have a constructor that receives a `Context` object, the database name, and
    the database version.
  prefs: []
  type: TYPE_NORMAL
- en: We also override the `onCreate` method that has the SQL statement, which creates
    our database table with `_ID`, `name`, and `age` columns.
  prefs: []
  type: TYPE_NORMAL
- en: The `onUpgrade` method is left intentionally blank for this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the inner `CustomSQLiteOpenHelper` class to the `DataManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add code to our `Fragment` classes to use our new `DataManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the Fragment classes to use the DataManager class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `InsertFragment` class to update the `onCreateView`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we get an instance of our `DataManager` class and a reference to
    each of our UI widgets. Then, in the `onClick` method, we use the `insert` method
    to add a new name and age to the database. The values to insert are taken from
    the two `EditText` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `DeleteFragment` class to update the `onCreateView`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `DeleteFragment` class, we create an instance of our `DataManager` class
    and then get a reference to the `EditText` and `Button` widgets from our layout.
    When the button is clicked, the `delete` method is called, passing in the value
    of any text from the `EditText` widget that the user has entered. The `delete`
    method searches our database for a match, and if one is found, it deletes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `SearchFragment` class to update the `onCreateView`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As we do for all our different `Fragment` classes, we create an instance of
    the `DataManager` class and get a reference to all the different UI widgets in
    the layout. In the `onClick` method, the `searchName` method is used, passing
    in the value from the `EditText` widget. If the database returns a result in the
    `Cursor` instance, then the `TextView` widget uses its `setText` method to output
    the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this highlighted code to the `ResultsFragment` class to update the `onCreateView`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this class, the `Cursor` instance is loaded up with data using the `selectAll`
    method before any interactions take place. The contents of `Cursor` are then output
    into the `TextView` widget by concatenating the results. `\n` in the concatenation
    is what creates a new line between each result in the `Cursor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Age Database app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's run through some of the functions of our app to make sure it is working
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I added a new name to the database using the **Insert** menu option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 27.3 – Insert menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_27.3_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 27.3 – Insert menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I confirmed it was there by viewing the **Results** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 27.4 – Results option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_27.4_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 27.4 – Results option
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, I added a few more names and ages just to fill the database up
    a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 27.5 – Filling the database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_27.5_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 27.5 – Filling the database
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I used the **Delete** menu option and looked at the **Results** option
    again to check that my chosen name was in fact removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 27.6 – Delete menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_27.6_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 27.6 – Delete menu
  prefs: []
  type: TYPE_NORMAL
- en: 'I then searched for a name that I knew existed to test the **Search** menu
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 27.7 – Search menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_27.7_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 27.7 – Search menu
  prefs: []
  type: TYPE_NORMAL
- en: Let's review what we have done in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter. We have learned about databases and in
    particular the database used by Android apps, SQLite. We have practiced the basics
    of communicating with a database using the SQL language.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how the Android API helps us use a SQLite database and have implemented
    our first working app with a database.
  prefs: []
  type: TYPE_NORMAL
- en: You have come a long way and have reached the end of the book. Let's talk about
    what might come next.
  prefs: []
  type: TYPE_NORMAL
