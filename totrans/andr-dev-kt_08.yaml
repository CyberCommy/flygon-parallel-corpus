- en: Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin takes design patterns pretty seriously. Previously, we've seen how the
    usage of the Singleton pattern was simplified by object declarations, and how
    usage of the Observator pattern was trivialized thanks to higher order functions
    and functional type. Also, Kotlin simplified the usage of most functional patterns,
    thanks to lambda expressions and functional types. In this chapter, we will see
    how usage of Delegation and Decorator patterns were simplified thanks to class
    delegation. We will also see a feature, which is pretty new in the programming
    world--property delegation--and how it is used to make Kotlin properties much
    more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Delegation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property delegates from the standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of a custom property delegate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin has a feature called **class delegation** . It is a really inconspicuous
    feature that has many practical applications. It is worth to notice, that it is
    strongly connected with two design patterns: Delegation Pattern and Decorator
    Pattern. We will discuss those patterns in more detail in upcoming sections. Delegation
    and Decorator pattern are known for many years, but in Java their implementation
    required a lot of boilerplate code. Kotlin is one of the first languages that
    provided native support for those patterns reducing boilerplate code to minimum.'
  prefs: []
  type: TYPE_NORMAL
- en: Delegation pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented programming, Delegation pattern is a design pattern, which
    is an alternative to inheritance. Delegation means that the object handles a request
    by delegating it to another object (delegate), instead of extending the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support the polymorphic behavior known from Java, both objects should implement
    the same interface that holds all delegated methods and properties. A simple example
    of the delegation pattern is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When we are talking about class delegation, there needs to be an interface that
    defines what methods are delegated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Object that we are delegating to (delegate).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All methods inside the `WitcherPlayer` class should call corresponding methods
    on the delegate object (`player` ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is called delegation because the `WitcherPlayer` class is delegating methods
    defined in the `Player` interface to an instance of type `RpgGamePlayer` (`player`
    ). Similar result could be reached by using inheritance instead of delegation.
    It would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, these two approaches might look similar, but delegation and
    inheritance have a lot of differences. On one hand, inheritance is much more popular
    and more common in use. It is often used in Java, and is connected to multiple
    OOP patterns. On the other hand, there are sources that strongly stand behind
    delegation. For example, the influential book *Design Patterns* , by the *Gang
    of Four* , contains the principle: *favor object composition over class inheritance*
    . Also, the popular book *Effective Java* , includes the rule: *favor composition
    over inheritance* (Item 6). Both of them strongly support the delegation pattern.
    Here are some basic arguments that stand behind the usage of the delegation pattern
    instead of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: Often classes are not designed for inheritance. When we override methods, we
    are not aware of underlying assumptions about class internal behavior (when methods
    are called, how those calls affect the objects, states, and so on). For example,
    when we override method, we might not be aware that it is used by other methods,
    so overridden methods may be called unexpectedly by a super class. Even if we
    check when the method is called, this behavior could change in a new version of
    the class (for example, if we extend class from an external library) and thus
    break our subclass' behavior. A very small amount of classes are properly designed
    and documented for inheritance, but nearly all nonabstract classes are designed
    for usage (this includes delegation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, it is possible to delegate a class to multiple classes, but inherit
    only from one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By interface, we are specifying which methods and properties we want to delegate.
    This is compatible with the *interface segregation* principle (from SOLID)--we
    shouldn't expose unnecessary methods to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some classes are final, so we can only delegate to them. In fact, all classes
    that are not designed for inheritance should be final. Kotlin designers were aware
    of it, and they made all classes in Kotlin to be final by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a class final and providing proper interface is good practice for public
    libraries. We can change the implementation of a class without worrying that it
    will affect library users (as long as the behavior will be the same from an interface
    point of view). It makes them impossible to inherit from, but they are still great
    candidates to delegate to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information on how classes should be designed to support inheritance and
    when delegation should be used can be found in the book *Effective Java* , in
    *Item 16: Favor composition over inheritance* .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are also disadvantages of using delegation instead of inheritance.
    Here are the main problems:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to create interfaces that specify which methods should be delegated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have access to protected methods and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Java, there was one more strong argument for using inheritance: it was much
    easier to implement. Even while comparing code from our `WitcherPlayer` example,
    we can see that delegation needed a lot of extra code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is especially problematic when we are dealing with interfaces with multiple
    methods. Fortunately, modern languages value the usage of the Delegation pattern,
    and many of them have native class delegation support. There is strong support
    for the Delegation pattern in Swift and Groovy, and there is also support through
    other mechanisms in Ruby, Python, JavaScript, and Smalltalk. Kotlin also strongly
    supports class delegation, and makes usage of this pattern really simple, and
    using nearly zero-boilerplate code. The `WitcherPlayer` class from the example
    could be implemented in this way in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `by` keyword, we are informing the compiler to delegate all methods
    defined in the `Player` interface from `WitcherPlayer` to `RpgGamePlayer` . An
    instance of `RpgGamePlayer` is created during the `WitcherPlayer` construction.
    In simpler words: `WitcherPlayer` is delegating methods defined in the `Player`
    interface to a new `RpgGamePlayer` object.'
  prefs: []
  type: TYPE_NORMAL
- en: What is really happening here is that during compilation, the Kotlin compiler
    is generating not implemented methods from `Player` in `WitcherPlayer` and filling
    them with calls to an `RpgGamePlayer` instance (the same way as that we implemented
    them in the first example). The big improvement is that we don't need to implement
    those methods ourselves. Also note that if a signature of a delegated method changes,
    then we don't need to change all objects that are delegated to it, so the class
    is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way to create and hold an instance of the delegate. It can
    be provided by a constructor, like in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also delegate to a property defined in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can delegate to any property accessible during class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, one object can have multiple different delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `WitcherPlayer` class is delegating the `Player` interface to a new `RpgGamePlayer`
    object, `GameMaker` to a new `WitcherCreator` object, and also includes the function
    `fulfillYourDestiny` that is using functions from both delegates. Note that both
    `WitcherPlayer` and `WitcherCreator` are not tagged as open, and without this,
    they cannot be extended. They can be delegated, though.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With such language support, the Delegation pattern is much more attractive
    than inheritance. While this pattern has both advantages and disadvantages, it
    is good to know when it should be used. The main cases where delegates should
    be used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When your subclass violates the *Liskov substitution principle* ; for example,
    when we are dealing with situations where inheritance was implemented only to
    reuse code of the superclass, but it is not really acting like it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the subclass uses only a portion of the methods of the superclass. In this
    case, it is only a matter of time before someone calls a superclass method that
    they were not supposed to call. Using delegation, we reuse only methods we choose
    (defined in the interface).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we cannot or we should not inherit, because:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class is final
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not accessible and used from behind interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is just not designed for inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that while classes in Kotlin are final by default, most of them will be
    left final. If those classes are placed in a library then most likely we won't
    be able to change or open the class. Delegation will be the only option, to make
    class with different behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov substitution principle is a concept in OOP stating that all subclasses
    should act like their superclasses. In easier words, If unit tests are passing
    for some class, they should be passing for its subclasses too. This principle
    has been popularized by Robert C. Martin, who placed it in his set of most important
    OOP rules and described it in the popular book *Clean Code* .
  prefs: []
  type: TYPE_NORMAL
- en: The book *Effective Java* states that "*inheritance is appropriate only in circumstances
    where a subclass really is a subtype of the superclass* ." In other words, class
    `B` should extend a class only if an *is-a* relationship exists between the two
    classes. If you are tempted to have class `B` extend class `A` , ask yourself
    *Is every B really an A?* In the next part, the book suggests that in every other
    case there should be composition used (which most common implementation is delegation).
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth note that Cocoa (the UI framework from Apple for building software
    programs to run on iOS) very often use delegates instead of inheritance. This
    pattern is becoming more and more popular, and in Kotlin it is highly supported.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common case where the Kotlin class delegation is really useful is when
    we are implementing a Decorator pattern. A Decorator pattern (also known as Wrapper
    pattern) is a design pattern that makes it possible to add a behavior to an existing
    class without using inheritance. In contrast to extensions where we can add a
    new behavior without modifying an object, we are creating a concrete object with
    a different behavior. A Decorator pattern uses Delegation, but in a very specific
    way--delegate is provided from outside of the class. The classic structure is
    presented in the following UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'UML diagram of classic implementation of the Decorator pattern. Source: [http://upload.wikimedia.org](http://upload.wikimedia.org)'
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator contains the objects that it is decorating while it is implementing
    the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular example of decorator usage from the Java world is `InputStream`
    . There are different kinds of types that are extending `InputStream` , and a
    lot of decorators that can be used to add functionalities to them. This decorator
    can be used to add buffering, get content of a zipped file, or convert file content
    to a Java object. Let''s look at the example where multiple decorators are used
    to read a zipped Java object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create a simple stream for reading a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new stream that contains buffering.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new stream that contains functionality of the reading compressed data
    in the GZIP file format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a new stream that adds functionality that deserializes primitive data and
    objects previously written using an `ObjectOutputStream` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stream is used in the `readObject` method of `ObjectInputStream` , but all objects
    in this example are implementing `InputStream` (what makes it possible to pack
    it this way) and can be read by the methods specified by this interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this pattern is also similar to inheritance, but we can decide what
    decorators we want to use and in what order. This is much more flexible and gives
    more possibilities during usage. Some people argue that `InputStream` usage would
    be better if designers would make one big class with all designed functionalities,
    and then use methods to turn some of them on or off. This approach would violate
    the *single-responsibility principle* and lead to much more complicated and much
    less expandable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the Decorator pattern is considered one of the best in practical use,
    it is rarely used in Java projects. This is because the implementation is not
    simple. Interfaces often contain multiple methods and creating a delegation to
    them in each decorator generates lots of boilerplate code. There is a different
    situation in Kotlin--we''ve already seen that in Kotlin class delegation is actually
    trivial. Let''s look at some classic examples of practical class delegation usage
    in the Decorator pattern. Let''s suppose that we want to add the first position
    as the *zero* element to several different `ListAdapters` . This extra position
    has some special properties. We couldn''t implement this using inheritance because
    these `ListAdapters` for different lists are of different types (which is the
    standard situation). In this case, we can either change the behaviors of each
    class (DRY rule) or we can create a decorator. Here is the short code of this
    decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We used an inflator extension property of `Context` here, which is often included
    in Kotlin Android projects and should be known from [Chapter 7](text00171.html)
    , *Extension Functions and Properties* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ZeroElementListDecorator` class defined this way always adds a first element
    with static view. Here we can see a simple example of its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In `ZeroElementListDecorator` it might look complicated that we needed to override
    four methods, but in fact, there are eight more of them and we didn't have to
    override them, thanks to Kotlin's class delegation. We can see that Kotlin class
    delegation is making the implementation of the Decorator pattern much easier.
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator pattern is really simple to implement and is pretty intuitive.
    It can be used in lots of different cases to extend a class with extra functionality.
    It is really safe and often referred as a good practice. These examples are just
    some of the possibilities provided by class delegation. I am sure that the reader
    will find more use cases with presented patterns and use class delegation to make
    the project more clean, safe, and concise.
  prefs: []
  type: TYPE_NORMAL
- en: Property delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin allows not only class delegation, but also property delegation. In this
    section, we are going to find out what delegated properties are, review property
    delegates from Kotlin standard library, and learn how to create and use custom
    property delegates.
  prefs: []
  type: TYPE_NORMAL
- en: What are delegated properties?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with explanation of what property delegates are. Here is an example
    of the use of property delegation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We are delegating `user` property to an instance of `UserDelegate` (which is
    created by the constructor).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Property delegation is similar to class delegation. We delegate to an object
    using the same keyword (`by` ). Each call to a property (`set` /`get` ) will be
    delegated to another object (`UserDelegate` ). This way we can reuse the same
    behavior for multiple properties, for example, setting a property value only when
    some criteria are met, or adding log entry when a property is accessed/updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that a property doesn''t really need a backing field. It might be defined
    just by getter (read-only) or a getter/setter (read-write). Under the hood, property
    delegates are just translated to corresponding method calls (`setValue` /`getValue`
    ). The preceding example will be compiled to such code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The example is showing that by using the `by` keyword, we are delegating the
    setter and getter calls to delegate. That is why any object that has the `getValue`
    and `setValue` functions with correct parameters (it will be described later)
    can be used as a delegate (for read-only properties `getValue` is enough, because
    only the getter is needed). It is important that all that class needs to be able
    to serve as a property delegate is to have these two methods. No interface is
    needed. Here is an example implementation of `UserDelegate` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setValue` and `getValue` methods are used to set and get value of a property
    (property setter call is delegated to a `setValue` method, and property getter
    is delegating value to the `getValue` method). Both functions need to be marked
    with the `operator` keyword. They have some special set of parameters that determine
    where and to which property the delegate can serve. If a property is read-only,
    then an object only needs to have a `getValue` method to be able to serve as its
    delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The type returned by the `getValue` method and the type of property that the
    user defined in the `setValue` method determines type of delegated property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type of the first parameter of both the `getValue` and `setValue` functions
    (`thisRef` ) is contains the reference to context in which a delegate is used.
    It can be used to restrict types that delegate can be used for. For example, we
    can define delegate that might be used only inside an `Activity` class in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we've seen, there will be a reference to `this` provided in all contexts
    where it is available. Only inside extension function or on extension property
    there is null placed instead. Reference to `this` is used to get some data from
    context. If we would type it to `Activity` , then we would be able to use this
    delegate only inside `Activity` (in any context where `this` is of the type `Activity`
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we want to force the delegate to be used only on the top-level, we
    can then specify the first parameter (`thisRef` ) type to `Nothing?` , because
    the only possible value of this type is `null` .
  prefs: []
  type: TYPE_NORMAL
- en: Another parameter in these methods is `property` . It contains a reference to
    a delegated property, which contains its metadata (property name, type, and so
    on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Property delegation can be used for properties defined in any context (top-level
    properties, member properties, local variables, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Top-level property with delegate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variable (inside top-level function) with delegate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Member property with delegate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local variable (inside method) with delegate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next few sections, we will describe delegates from the Kotlin standard
    library. They are important not only because they are often useful, but also because
    they are good examples of how property delegation can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Predefined delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kotlin standard library contains some property delegates that are very handy.
    Let's discuss how they can be used in real-life projects.
  prefs: []
  type: TYPE_NORMAL
- en: The lazy function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes we need to initialize an object, but we want to make sure that the
    object will be initialized only once, when it is used for the first time. In Java,
    we could solve this problem in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This construction is a popular pattern in Java development. Kotlin allows us
    to solve this problem in a much simpler way by providing the `lazy` delegate.
    It is the most commonly used delegate. It works only with read-only properties
    (`val` ) and its usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `lazy` function in the standard library function that is providing delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Formally, in this example object of `SynchronizedLazyImpl` , it is used as a
    property delegate. Although, most often it is called **lazy delegate** from its
    corresponding function name. The same way other delegates are named from the names
    of the functions that are providing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lazy delegate also has a thread safety mechanism. By default, delegates
    are fully thread safe, but we can change this behavior to make this function more
    efficient in situations where we know that there never will be more than one thread
    using it at the same time. To fully turn off thread-safety mechanisms we need
    to place the `enum` type value `LazyThreadSafetyMode.NONE` as a first argument
    of the `lazy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`val someProperty by lazy(LazyThreadSafetyMode.NONE) { SomeType() }`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the lazy delegate, the initialization of the property is delayed
    until the value is needed. Usage of the lazy delegate provides several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Faster class initialization leading to faster application startup time, because
    value initialization is delayed until they are used for the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some values may never be used for certain flow, so they will never be initialized--we
    are saving resources (memory, processor time, battery)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another benefit is that some objects need to be created later, after their
    class instance is created. For example, in `Activity` we cannot access the resources
    before layout is set using the `setContentView` method, which is typically called
    inside the `onCreate` method. I will present it in this example. Let''s look at
    the Java class with view reference elements filled in the classic Java way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we translate it into Kotlin, one-to-one, it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the lazy delegate, we can implement this behavior in a simpler way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefits of this approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The property is declared and initialized in a single place, so the code is more
    concise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties are non-nullable instead of nullable. This prevents lots of useless
    nullability checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The properties are read only so thanks to that we have all benefits like threads
    synchronization or smart casts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lambda passed to the lazy delegate (containing `findViewById` ) will be
    executed only when the property is accessed for the first time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values will be taken later than during class creation. This will speed-up the
    startup. If we won't use some of these views, their values won't be taken at all
    (`findViewById` is not really an efficient operation when the view is complex).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not used property will be marked by the compiler. In Java implementation it
    won't, because value set would be noticed by the compiler as usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can improve the preceding implementation by extracting the common behavior
    and converting it into an extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can define the view bindings in simpler and more concise code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to set type provided to the `bindView` function because it is
    inferred from property type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have a single delegate that calls `findViewById` under the hood, when
    we access a particular view for the first time. This is a very concise solution.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way of dealing with this problem. The current popular one is
    the *Kotlin Android Extension* plugin, which generates auto-binding to views in
    `Activities` and `Fragments` . We will discuss the practical applications in [Chapter
    9](text00222.html) , *Making your Marvel Gallery Application* .
  prefs: []
  type: TYPE_NORMAL
- en: Even with such support, there are still benefits from staying with bindings.
    One is explicit knowledge of what elements of view we are using, and another is
    the separation between the name of element ID and name of a variable in which
    we hold this element. Also compilation time is faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same mechanism can be applied to solve other Android related problems.
    For example, when we pass an argument to `Activity` . The standard Java implementation
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We could write the same implementation in Kotlin, but we can also retrieve
    parameter values (`getString` /`getParcerable` ) together with the variable declaration.
    To do this, we need the following extension functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can get extra parameters by using `extra` and `extraString` delegates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are defining properties which values should be retrieved from `Activity`
    arguments using corresponding keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we access properties from arguments within the `onCreate` method. When
    we ask for property (use getter), the lazy delegate will get its value from extras
    and store it for later usage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make a static method to start activity, we need to use a companion object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SettingsActivity::class.java` is the analogue of Java class reference `SettingsActivity.class`
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using methods defined in [Chapter 7](text00171.html) , *Extension Functions
    and Properties* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also make functions to retrieve other types that can be held by **Bundle**
    (for example, `Long` , `Serializable` ). This is a pretty nice alternative to
    the argument injection libraries such as `ActivityStarter` , when we want to keep
    a really fast compilation time. We can use similar functions to bind strings,
    colors, services, repositories, and other parts of model and logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Activity` , everything that is heavy or depends on arguments should be
    declared using lazy delegate (or provided asynchronously). Also we should define
    as lazy all the elements that depend on elements that need to be initialized lazily.
    For example, `presenter` definition, which depends on the `doctor` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the attempt to construct a `MainPresenter` object will take place
    during class creation when we cannot yet read values from the intent and it wouldn't
    be able to fill the `doctor` property, and the application would crash.
  prefs: []
  type: TYPE_NORMAL
- en: I think that these examples are enough to convince us that the lazy delegate
    is really useful in Android projects. It is also a good property delegate to start
    with, as it is simple and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: The notNull function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `notNull` delegate is the simplest standard library delegate, and that
    is why it will be presented first. The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Functions that provide most standard library delegates (including the `notNull`
    function) are defined in `object` delegates. To use them, we need to either refer
    to this object (`Delegates.notNull()` ) or import it (`import kotlin.properties.Delegates.notNull`
    ). We will assume in examples that this `object` is imported so we will omit reference
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `notNull` delegate allows us to define a variable as non-nullable, that
    is initialized at a later time and not during the object construction time. We
    can define variable to be non-nullable without providing a default value. The
    `notNull` function is an alternative to `lateinit` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `notNull` delegate provides nearly the same effect as `lateinit` (only the
    error message is different). In the case of trying to use this property before
    setting the value first, it will throw an `IllegalStateException` and it will
    terminate an Android application. Therefore, it should be used only when we know
    that a value will be set before the first attempt of usage.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `lateinit` and the `notNull` delegate is pretty simple.
    `lateinit` is faster than `notNull` delegate so it should be used instead of `notNull`
    delegate as often as possible. But it has restrictions, `lateinit` cannot be used
    for primitives or for top-level properties, so in this case, `notNull` is used
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `notNull` delegate implementation. Here is the `notNull`
    function implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, `notNull` is actually a function returning an object that is
    an instance of our actual delegate hidden behind a `ReadWriteProperty` interface.
    Let''s look at an actual delegate definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Class is private. It is possible because it is provided by function `notNull`
    , which is returning it as `ReadWriteProperty<Any?, T>` , which is public interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we see how a return value is provided. If it is null during usage, then
    value was not set and the method will throw an error. Otherwise, it is returning
    the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This delegate should be pretty simple to understand. The `setValue` function
    sets the value to a nullable field and `getValue` returns this field if it is
    not null, and throws an exception if it is. Here is an example of this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is a really simple example of delegated properties usage, but also a good
    introduction to how property delegates works. Delegated properties are very powerful
    constructs that have multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: The observable delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An observable is the most useful standard library delegate for mutable properties.
    Every time a value is set (`setValue` method is called), the lambda function from
    the declaration is invoked. A simple example of observable delegate is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments of lambda function are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`property` : Reference to the delegated property. Here it is reference to name.
    This is the same as property from `setValue` and `getValue` , which was described.
    It is of the `KProperty` type. In this case (and in most cases) we can put the
    underscore ("`_` " sign) instead when it is not used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oldValue` : The previous value of the `property` (before the change).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newValue` : The new value of the `property` (after the change).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lambda function will be invoked each time a new value is set to the property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we set the new value, then the value is updated, but at the same time lambda
    method declared in delegate is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that lambda is invoked each time setter is used and it doesn't matter if
    a new value is equal to previous.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is particularly important to remember that lambda is called each time a
    new value is set, and not when an object''s inner state is changed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Does not print anything, because we don't change the property (the setter is
    not used). We only change the property defined inside the list, but not the object
    itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we change the value of list, so the lambda function from observable delegate
    is called and text is printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observable delegate is very useful for immutable types, as opposed to mutable
    ones. Fortunately, all basic types in Kotlin are immutable by default (`List`
    , `Map` , `Set` , `Int` , `String` ). Let''s look at a practical Android example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Every time we change the list, the view is updated. Note that while `List` is
    immutable, we need to use setter when we want to apply any changes, so we can
    be sure that after this operation the list will be updated. It is much easier
    than remembering to call the `updateListView` method every time the list changes.
    This pattern can be used widely in the project to declare properties that are
    editing views. It changes the way the update view mechanism can work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another problem that can be solved using an observable delegate is that in
    `ListAdapters` there was always a problem that `notifyDataSetChanged` had to be
    called each time elements on the list were changed. In Java, the classic solution
    was to encapsulate this list, and call `notifyDataSetChanged` in each function
    that is modifying it. In Kotlin, we can simplify this using an observable property
    delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that here list is immutable, so there is no way to change its elements
    without using `notifyDataSetChanged` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The observable delegate is used to define behavior that should happen on the
    property value change. It is most frequently used when we have operations that
    should be done every time we change a property, or when we want to bind a property
    value with a view or some other values. But inside the function we cannot decide
    if a new value will be set or not. For this, the `vetoable` delegate is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: The vetoable delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `vetoable` function is a standard library property delegate that works
    similar as an observable delegate, but with two main differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The lambda from an argument is called before a new value is set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the lambda function from a declaration to decide if a new value should
    be accepted or rejected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if we have an assumption that the list must always contain larger
    number of items than the old one, then we will define the following `vetoable`
    delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If a new list will not contain a larger number of items than the old one, then
    the value will not change. So we can treat `vetoable` like `observable` , which
    is also deciding if the value should be changed or not. Let''s suppose that we
    want to have a list bounded to view, but it needs to have three elements at least.
    We don''t allow any change that will make it possible to have fewer elements.
    The implementation would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If a new list size is smaller than 3, then we do not accept it, and return `false`
    from lambda. This `false` value returned by return statement with label (that
    is used to the return from the lambda expression) is the information that the
    new value shouldn't be accepted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This lambda function needs to return a value. This value is taken either from
    `return` with a label or by the last line of the lambda body. Here value `true`
    informs that a new value should be accepted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a simple example of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also make it unchangeable because of some other reasons, for example,
    we might still be loading the data. Also, the vetoable property delegate can be
    used in validators. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This property can be changed only to a value that is correct according to the
    predicate `isValid(new)` .
  prefs: []
  type: TYPE_NORMAL
- en: Property delegation to Map type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library contains extensions for `Map` and `MutableMap` with the
    `String` key type that provides the `getValue` and `setValue` functions. Thanks
    to them, `map` can also be used as a property delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Map key type needs to be `String` , while value type is not restricted. It is
    often `Any` or `Any?`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating `Map` that contains all the values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a `map` to an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can be useful when we are keeping data in `Map` , and also for following:'
  prefs: []
  type: TYPE_NORMAL
- en: When we want to simplify the access to these values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we define a structure that is telling us what kind of keys we should expect
    in this map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we ask for a property that is delegated to `Map` , its value will be taken
    from this map value for a key equal to the property name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How is it implemented? Here is the simplified code from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`V` is a type of value on the list'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`thisRef` is of type `Any?` , so `Map` can be used as property delegate in
    any context'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`V1` is return type. This is often inferred from property, but it must be subtype
    of type `V`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name of the property is used as `key` on `map.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep in mind that this is just an extension function. All that an object needs
    to be a delegate is to contain the `getValue` method (and `setValue` , for read-write
    properties). We can even create a delegate from an object of an anonymous class
    using the `object` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Object is not implementing any interface. It just contains the `getValue` method
    with proper signature. And it is enough to make it work as a read-only property
    delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that in `map` there needs to be an entry with such a name when we are asking
    for value of property, otherwise an error will be thrown (making the property
    nullable does not change it).
  prefs: []
  type: TYPE_NORMAL
- en: Delegating fields to map can be useful, for example, when we have an object
    from an API with dynamic fields. We would like to treat the provided data as an
    object to have easier access to its fields, but we also need to keep it as a map
    to be able to list all the fields given by an API (even ones that we were not
    expecting).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we used `Map` , which is immutable; therefore, the
    object properties were read-only (`val` ). If we want to make an object that can
    be changed, then we should use `MutableMap` , and then the properties can be defined
    as mutable (`var` ). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Property value can be changed just by changing the value of the `map`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Property value can be also changed like in any other property. What is really
    happening there is that value change is delegated to `setValue` , which is changing
    `map` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While properties here are mutable, the `setValue` function must also be provided.
    It is implemented as an extension function for `MutableMap` . Here is the simplified
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note how even so simple functions can allow such innovative way of using the
    common objects. This shows what possibilities property delegates are giving.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin allows us to define custom delegates. Right now, we can find many libraries
    that provides new property delegates that can be used for different purposes in
    Android. There are various ways in which property delegation can be used in Android.
    In the next section, we will see some examples of custom property delegates, and
    we will take a look at cases where this feature can be really helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Custom delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All previous delegates came from the standard library, but we can easily implement
    our own property delegates. We''ve seen that in order to allow a class to be a
    delegate, we need to provide the `getValue` and `setValue` functions. They must
    have a concrete signature, but there is no need to extend a class or implement
    the interface. To use object as a delegate, we don''t even need to change its
    internal implementation, because we can define `getValue` and `setValue` as extension
    functions. However, when we are creating custom classes to be a delegates, then
    interface may be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: It would define functions structure, so we can generate proper methods in Android
    Studio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are creating libraries, then we might want to make delegates classes to
    be private or internal to prevent inappropriate usage of them. We've seen this
    situation in the `notNull` section, where the class `NotNullVar` was private and
    served as a `ReadWriteProperty<Any?, T>` which is an interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interfaces that provide full functionality to allow some class to be delegate
    are `ReadOnlyProperty` (for read-only properties) and `ReadWriteProperty` (for
    read-write properties). These interfaces are really useful, so let''s look at
    their definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The values of parameters were already explained, but let''s look at them again:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thisRef` : A reference to an object where the delegate is used. Its type defines
    the context in which the delegate can be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`property` : A reference that contains data about a delegated property. It
    contains all information about this property, such as its name or type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` : A new value to set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The parameters `thisRef` and `property` are not used in the following delegates:
    Lazy, Observable and Vetoable. `Map` , `MutableMap` , and `notNull` use property
    to obtain the name of the property for the key. But these parameters can be used
    in different cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some small, but useful, examples of custom property delegates.
    We''ve seen the lazy property delegate for read-only properties; however, sometimes
    we need a lazy property that is mutable. If it would be asked for the value before
    initialization, then it should fill its value from the initializer and return
    it. In other cases it should act like a normal mutable property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The delegate is hidden behind the interface and served by a function, and as
    such allows us to change the implementation of `MutableLazy` without worrying
    if it will affect the code that is using it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are implementing `ReadWriteProperty` . It is optional, but really useful
    because it is imposing the correct structure of a read-write property. Its first
    type is `Any?` meaning that we are allowed to use this property delegate in any
    context, including top-level. Its second type is generic. Note that there is no
    restrictions on this type, so it might be nullable too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of the property is stored in the `value` property, and its existence
    is stored in an initialized property. We need to do it this way because we want
    to allow `T` to be a nullable type. Then `null` in the value could mean either
    that it was not yet initialized or that it is just equal to `null` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need to use the `operator` modifier, because it is already used in
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `getValue` is called before any value is set, then the value is filled using
    initializer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to cast the value to `T` because it might be not-null, and we initialized
    value as nullable with null as an initial value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This property delegate might be useful in different use-cases in Android development;
    for example, when a default value of a property is stored in a file, and we need
    to read it (which is a heavy operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, if a user sets a custom value of this property before its usage,
    we won''t have to calculate it ourselves. Second custom property delegate will
    allow us to define property getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Before Kotlin 1.1 defined it, we always had to define the type of property.
    To avoid it, we can define the following extension function to functional type
    (therefore, also the lambda expression):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can define the properties with similar behavior this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This way is not preferred because of its decreased efficiency, but it is a
    nice example of possibilities that delegated properties provides us. Such a small
    extension function is making functional type to be property delegate. This is,
    the simplified code in Kotlin after compilation (note that the extension function
    is marked as inline, so its calls were replaced with its body):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we are going to see some custom delegates created for real
    projects. They will be presented together with the problems that they solve.
  prefs: []
  type: TYPE_NORMAL
- en: View binging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are using **Model-View-Presenter** (**MVP** ) in the project, then
    we need to make all the changes in View by Presenter. Thus, we are forced to create
    multiple functions on the view, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to define the functions in the following `interface` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We may simplify the preceding code and reduce the need for setter/getter methods
    by using property binding. We can bind the property to view element. This is the
    result we would like to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And `interface` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example is more concise and easier to maintain. Note that we
    provide element ID by argument. A simple class that will give us the expected
    results is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We could create a similar binding for different view properties and different
    contexts (`Fragment` , `Service` ). Another really useful tool is binding to visibility,
    which is binding a logical property (with the type `Boolean` ) to the visibility
    of a `view` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: These implementations provide possibilities that would be really hard to achieve
    in Java. Similar bindings might be created for other `View` elements to make using
    MVP shorter and simpler. The snippets that were just presented are only simple
    examples, but better implementations can be found in the library `KotlinAndroidViewBindings`
    ([https://github.com/MarcinMoskala/KotlinAndroidViewBindings](https://github.com/MarcinMoskala/KotlinAndroidViewBindings)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Preference binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To show more complex examples, we will present the attempt to help with the
    `SharedPreferences` usage. There are better Kotlin approaches for this problem,
    but this attempt is nice to analyze, and it is a reasonable example of we use
    property delegate on extension property. As a result, we want to be able to treat
    values saved in `SharedPreferences` as if they were properties of a `SharedPreferences`
    object. Here is example usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve it if we make the following extension property definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The property of type Boolean. When a property is non-nullable, than default
    values have to be provided in the first argument of function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The property can have custom key provided. It is useful in real-life projects,
    where we must have control over this key (for example, to not change it unintentionally
    during property rename).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s analyze how it works by deep investigation of the not-null property.
    First, let''s look at the provider functions. Note that the type of the property
    is determining the way the value is taken from `SharedPreferences` (because there
    are different functions, such as `getString` , `getInt` , and so on). To obtain
    it, we need this class type to be provided as the `reified` type of the `inline`
    function, or through the parameter. This is what a delegate provider function
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Both functions are returning object behind interface `ReadWriteProperty<SharedPreferences,
    T>` . Note that context here is set to `SharedPreferences` , so it can be used
    only there or in `SharedPreferences` extensions. This function is defined because
    the type parameter cannot be redefined and we need to provide type as a normal
    parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `bindToPreferenceField` function cannot be private or internal,
    because inline functions can use only functions with the same or less restricted
    modifiers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, let''s see the `PreferenceFieldDelegate` class, which is our delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we know how the `thisRef` parameter is used. It is of the type `SharedPreferences`
    , and we can use it to get and set all the values. Here are definitions of the
    functions used to get and save values depending on property type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need `toJson` and `fromJson` defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'With such definitions we can define additional extension properties to `SharedPreferences`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'As we''ve already seen in [Chapter 7](text00171.html) , *Extension Functions
    and Properties* , there is no such thing in Java as a field that we might add
    to a class. Under the hood, the extension property is compiled to getter and setter
    functions, and they are delegating calls to a created delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Also remember that extension functions are, in fact, just static functions
    with an extension on the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Presented examples should be enough to understand how property delegates are
    working and how they can be used. Property delegates are used intensively in Kotlin
    open source libraries. They are used to make fast and simple Dependency Injection
    (for example, Kodein, Injekt, TornadoFX), binding to views, `SharedPreferences`
    or other elements (attempts already shown includes `PreferenceHolder` , and `KotlinAndroidViewBindings`
    ), to define property keys on configuration definition (for example, Konfig),
    or even to define a database column structure (for example, Kwery). Still there
    is a big field of usages that are waiting to be discovered.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Kotlin 1.1, there is an operator, `provideDelegate` , that is used to
    provide delegate during class initialization. The main motivation behind `provideDelegate`
    was that it allows to provide customized delegate depending on traits of property
    (name, type, annotations, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `provideDelegate` operator returns delegate, and all types that have this
    operator do not need to be delegates themselves in order to be used as a delegate.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `A` is used as a delegate, while it implements neither `getvalue`
    nor `setvalue` function. This is possible, because it defines a `provideDelegate`
    operator, which returns the delegate that will be used instead of `A` . Property
    delegation is compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Practical example can be found in Kotlin supporting part of library `ActivityStarter`
    ([https://github.com/MarcinMoskala/ActivityStarter](https://github.com/MarcinMoskala/ActivityStarter)
    ). Activity arguments are defined using annotations, but we can use property delegation
    to simplify usage from Kotlin and allow properties definition as possibly read-only
    and not `lateinit` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'But there are some requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: When `argExtra` is used, property getter have to be annotated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to specify default value if argument is optional and type is not nullable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To check this requirements, we need reference to property to get getter annotation.
    We cannot have such reference in the `argExtra` function, but we can implement
    them inside `provideDevegate` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Such delegate is throwing appropriate error when condition is not fulfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`@get:Arg(optional = true) val a: A by ArgValueDelegateProvider()` throws error
    during initialization: `Arguments that are optional and have not-nullable type
    must have default value specified` .'
  prefs: []
  type: TYPE_NORMAL
- en: This way unacceptable argument definitions are throwing appropriate errors during
    object initialization instead of breaking application in unexpected situations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described class delegate, property delegates, and how they
    can be used to remove redundancy in code. We defined a delegate as an object to
    which calls from other object or property are delegated to. We learned design
    patterns that class delegation is strongly connected to Delegate pattern and Decorator
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegation pattern is mentioned as an alternative to inheritance, and Decorator
    pattern is a way to add functionality to different kinds of classes that are implementing
    the same interface. We''ve seen how property delegation works, and Kotlin standard
    library property delegates: `notNull` , `lazy` , `observable` , `vetoable` , and
    the usage of `Map` as a delegate. We learned how they work and when they should
    be used. We''ve also seen how to make a custom property delegate, together with
    examples of real-life usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge about different features and their usage is not enough--there is also
    a need to understand how they can be used together to build great applications.
    In the next chapter, we will write a demo application and explain how the various
    Kotlin features described throughout this book can be combined together.
  prefs: []
  type: TYPE_NORMAL
