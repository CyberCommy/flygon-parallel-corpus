- en: 'Chapter 2. Using PHP Data Objects: First Steps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we had a brief overview of what PDO is, how to connect
    to your favourite database using PDO, how to issue simple queries and how to handle
    errors. Now that you are convinced that PDO is a good thing and are thinking of
    using it actively, we will be delving into all the features it has to offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look more closely at creating connections to a database
    using PDO and connection strings (data source names), the `PDOStatement` class,
    and how to traverse result sets. We will also create a small library management
    application, which will allow us to manage a collection of books of your home
    library. The application will be able to list books and authors as well as add
    and edit them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: We will start by having a look at connection strings, since without them, we
    will not be able to connect to any database. We will then create a sample database,
    on which all the examples in this book will be based.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We will depart from the simplistic, imaginary cars' database and create a real
    working database with several tables. However, now we will be dealing with the
    classical example of books and authors. We chose this example because such entities
    are more common. The relational model will be relatively simple, so that you will
    be able to follow the examples easily, if you have already come across such a
    database elsewhere.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Connection Strings
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connection strings, or data source names (abbreviated DSN) as they are called
    in the PDO documentation, are PHP strings that carry such information as the name
    of the database management system and of the database itself, as well as other
    connection parameters.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Their advantage over using traditional methods of creating database connection
    is that you don't have to modify your code if you change the database management
    system. A connection string can be defined in a configuration file and that file
    gets processed by your application. Should your database (data source) change,
    you just edit that configuration file and the rest of your code is kept intact.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'The connection strings used in PDO differ due to the existence of different
    database management systems. However, they always have a common prefix, which
    denotes the underlying database driver. Remember the MySQL, SQLite, and PostgreSQL
    examples in the [Chapter 1](ch01.html "Chapter 1. Introduction"). The three connection
    strings looked like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the prefix (the substring before the first semicolon) always
    keeps the name of the PDO driver. Since we don't have to use different functions
    to create a connection with PDO, this prefix tells us which internal driver should
    be used. The rest of the string is parsed by that driver to further initiate the
    connection. In these cases we supplied the database name; for MySQL and PostgreSQL;
    we also supplied the host name on which the server runs. (As SQLite is a local
    database engine, such a parameter would not make sense.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to specify additional parameters, you should consult your database
    manual ([www.php.net/pdo](http://www.php.net/pdo) is always a good place to start).
    For example, the MySQL PDO driver understands the following parameters:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**host** - the hostname on which the server runs (*localhost* in our example)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**port** - the port number where the database server is listening (defaults
    to *3306)*'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dbname** - the name of the database (*cars* in our example)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unix_socket** - the MySQL UNIX socket (instead of host and/or port).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SQLite:` prefix denotes a connection to a SQLite 3 database. To connect
    to SQLite 2 database, you have to use `SQLite2:` prefix. Please see [http://www.php.net/manual/en/ref.pdo-sqlite.connection.php](http://www.php.net/manual/en/ref.pdo-sqlite.connection.php)
    for details.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed, different drivers use different character to delimit
    the parameters—such as a semicolon in MySQL and space in PostgreSQL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Sample Database
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose that you have a good library at home and you want your computer to help
    you manage it. You decide to create a web-based database using PHP and, of course,
    PDO. From now on, the examples will be for MySQL and SQLite databases.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The Data Model
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As our database is really simple, we will just have two entities in it: authors
    and books. Hence, we will be creating two tables with the same names. Now, let''s
    think what properties each of these entities will have.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Authors will have their first name, their last name, and a short biography.
    The table will need to have a primary key which we will call *id*. We will use
    it to refer to an author from the `books` table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Books are written by authors. (Sometimes they are written by more than one author,
    but we will consider books written by only one author here.) So we will need a
    field for the author’s ID, as well as the book’s title, ISBN number, publisher
    name, and year of publication. Also, we will include a short summary of what the
    book is about.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We need for a separate table for authors, because an author might have written
    more than one book. Also, our example would be really simple otherwise! Thus,
    we opted for a two-table database structure. If we were to consider books written
    by more than one author, we would need three tables, which would make the example
    very complicated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MySQL Database
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After you have launched your MySQL command line client, you will see the `mysql>`
    prompt, where you will be able to issue commands to create the database and the
    tables in it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, we have created a database and called it `pdo`. We also created
    two tables: books and authors, just as we had planned. Now let''s see how we do
    that in SQLite. As we cannot create the database inside the SQLite command line
    client, we launch it like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, the SQL is slightly different for SQLite—the primary keys are
    declared without the `NOT NULL` and `auto_increment` options. In SQLite, a column
    declared as `INTEGER PRIMARY KEY` is automatically incremented. Now let''s insert
    some values into our database. The syntax will be the same for MySQL and SQLite
    so here we will just present the MySQL command line client example. We will start
    with authors, because we will need their primary key values for inserting into
    the books table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have inserted three authors, let''s add some books. But before
    we do, we should know which *author* has which *id*. A simple `SELECT` query will
    help us:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can finally use this information to add three books, each written by
    one of these authors:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have filled the `authors` and `books` tables, we may begin to create
    the first page of our small library management web application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The data used is based on real books published by Packt Publishing Ltd (the
    publisher that brought to you this book you are reading now). To find out more,
    visit their site at [http://www.packtpub.com](http://www.packtpub.com)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Designing Our Code
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good application architecture is another key factor of an application, besides
    the correct data model. As the application that we are going to develop in this
    chapter, is relatively small, this task is not very complicated. First, we will
    create two pages that will list books and authors. To begin with, we should think
    about how these pages would look. To make our simple example small and compact,
    we will present a header on all pages that will contain links to the books list
    and the authors list. Later we will add two more pages that will allow us to add
    an author and a book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we should create a common include file that will define the common
    functions such as the header and footer display and the connection to the database.
    Our example is really small, so we will not be using any template system or even
    object-oriented syntax. (Indeed, these topics are beyond the scope of this book.)
    So, to summarize:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: All common functions (including code to create the PDO connection object) will
    be kept in an include file (called `common.inc.php)`.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every page will be held in a separate file, which includes the `common.inc.php`
    file.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every page will process data and display it (so that we have no separation of
    data processing and data presentation, as one would expect from an application
    designed with the model-view-controller pattern in mind).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have this small plan, we can begin with our `common.inc.php` file.
    As we have just discussed, for now, it will contain the functions to display the
    header and the footer, as well as the code to create the connection object. Let''s
    keep the PDO object in a global variable called `$conn` and call our header function
    `showHeader()`, and the footer function `showFooter()`. Also, we will keep the
    database connection string, user name, and password in this include file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the file is really simple, and you will just have to change
    the values of the `$user` and `$pass` variables (on lines 9 and 10) to match your
    setup. For a SQLite database, you would also have to change line 8 so that it
    contains an appropriate connection string, for example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Of course, you should change this to reflect the path to where you created the
    SQLite database. Also, the `showHeader()` function simply renders HTML code and
    passes the value of the `$title` variable via the `htmlspecialchars()` function
    so that any illegal characters (such as a less-than sign) are properly escaped.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Save the file to your web root directory. This again depends on your web server
    setup. For example, it could be `C:\Apache\htdocs or /var/www/html`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a page that lists the books. We will have to issue the query
    and then iterate over the results to present each book in its own row. Later,
    we will create a page that will list all the authors from the database that we
    created earlier. After we finish this task, we will look at result set traversal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call our file `books.php` and create the code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This file should be saved to the directory where the `common.inc.php` file
    is located. As you can see, there are more comments and HTML in the code, but
    there is nothing very complicated here. As we decided earlier, the code includes
    the `common.inc.php` file, then renders the page header, issues a query on the
    line #10, renders the table header, and finally iterates over every row in the
    result set to output every book''s details.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Just as in the first chapter, we traverse the result set in a `while` row, using
    the `fetch()` method of the `PDOStatement` object (held in the `$q` variable).
    We instruct this method to return the rows as arrays indexed by table column names
    (by specifying the `PDO::FETCH_ASSOC` parameter).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, we render the HTML of every row, inserting there the columns
    from our table. After the loop quits, we close the table and display the footer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to test our first PDO-powered application. Fire up your browser
    and navigate to `http://localhost/books.php`. If you did everything correctly
    (so that your web server and database are properly setup), you should see a table
    similar to the following screenshot (although your page might look much wider,
    we resized the window before taking a screenshot so that it fits on a printed
    page):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing Our Code](graphics/2660-02-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Once we have ensured that our application works with MySQL, let''s see how
    it will work with SQLite. To do this, we have to edit line 8 in the `common.inc.php`
    file so that it contains the SQLite DSN:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you did everything correctly, then after refreshing your browser, you should
    see the same screen. As we discussed earlier—only one configuration option has
    to be changed when you start using another database system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the code for the page that will list the authors. Create
    a file named `authors.php` and place it in the directory where you saved the previous
    two files. The code is practically identical to the books listing page:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This file follows the same logic: include the `common.inc.php` file, and then
    issue the query and traverse the result set. If you have done everything correctly,
    then you simply click on the **Authors** link located on the books listing page
    in your browser to get the following page:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing Our Code](graphics/2660-02-02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the page correctly presents the three authors that we added
    at the beginning of this chapter. If you want to test this with SQLite, change
    the line #10 to contain the SQLite connection string. On refreshing your browser,
    you should see the same page, but now based on the SQLite database contents.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created these two pages and seen that using PDO is not complicated,
    let's look at some theory before we extend the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: PDO Statements and Result Sets
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our examples made use of two of the main classes in PHP Data Objects: the `PDO`
    class, which is used to create a connection and issue queries, and the `PDOStatement`
    class, which we use to loop through the result set. We will look at the first
    of these classes in later chapters. Here, we will examine the `PDOStatement` class
    to see what other ways of traversing the result set that it has to offer.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: As we already know, instances of the `PDOStatement` class are returned from
    the call to `PDO::query()` method. The main purpose of this class is to provide
    an interface to the result set. In fact, we have already used its most important
    method to iterate over the result set. We only looked at one fetch style (or mode
    of the returned row), but PDO offers several styles. This class can also provide
    additional information about a result set, such as the number of rows and columns,
    and fetch the whole result set into a two-dimensional array.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by looking at some different fetch styles. We already know the
    `PDO::FETCH_ASSOC` mode that returns an array indexed by column name. The default
    operation of the `PDOStatement` object is to return an array indexed by both an
    integer index and a column name, that is the `PDO::FETCH_BOTH` fetch mode. We
    can also request only an integer-indexed array by using the `PDO::FETCH_NUM` fetch
    style. PDO also supports fetching rows as objects with the `PDO::FETCH_OBJ` mode.
    In this case the call to `PDO::fetch()method` will return an instance of the `stdClass`
    internal class with its properties populated with the row''s values. This happens
    in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `PDOStatement` class also allows you to set the fetch mode once for all
    subsequent calls to its `fetch()` method. This is done via the `PDOStatement::setFetchMode()`
    method, which accepts any of the `PDO::FETCH_ASSOC, PDO::FETCH_BOTH, PDO::FETCH_NUM`,
    and `PDO::FETCH_OBJ` constants. With this in mind, we can rewrite lines 23 and
    24 of the `authors.php` file to look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can try it on your copy of the `authors.php` file and refresh the browser
    to see that this works.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the SQLite, MySQL, and pgSQL PHP extensions all offer
    similar functionality. Indeed, we can use any of the `mysql_fetch_row(), mysql_fetch_assoc(),
    mysql_fetch_array()`, or `mysql_fetch_object()` functions to achieve the same
    effect. That''s why PDO goes further and enables us to use three additional fetch
    modes. These three modes can be only set via `PDOStatement::setFetchMode()` call,
    and here they are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::FETCH_COLUMN` allows you to instruct the `PDOStatement` object to return
    the specified column of every row. In this case, `PDO::fetch()` will return a
    scalar value. The columns are numbered starting with 0\. This happens in the following
    code snippet:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This reveals that the call to `$q->fetch()` does indeed returns scalar values
    (not arrays). Note that the column with the index 1 should be the author's last
    name, not their first name, if you are simply looking at the page with authors
    list. However, our query looks like `SELECT * FROM authors`, so it also retrieves
    the author ids, which are stored into the 0th column. You should be aware of this,
    as you may spend hours looking for the source of such a logical error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::FETCH_INTO` can be used to modify an instance of an object. Let''s rewrite
    our above example as follows:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside the `while` loop we didn't assign the `$r` variable, which is the return
    value of `$q->fetch(). $r` has been bound to this method via the call to `$q->setFetchMode()`
    before the loop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::FETCH_CLASS` can be used to return objects of a specified class. For
    every row, an instance of this class will be created with the properties named
    and assigned the values of the result set columns. Note that the class does not
    necessarily have these properties declared since PHP allows runtime creation of
    object properties. For example:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will print output similar to that for the previous example. Also, this
    fetch mode allows you to create instances by passing an array of parameters to
    their constructors:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (This will work only if the `SomeClass` class has been defined.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We would recommend using `PDOStatement::setFetchMode()` as it is more convenient
    and easier to maintain (and, of course, has more features).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Describing all of these fetch modes may seem excessive, but each of them is
    useful in certain situations. Indeed, you may have noticed that the list of books
    is somewhat incomplete. It does not contain the author''s name. We will add this
    missing column, and to make our example trickier, we will make the author''s name
    clickable and link it to the author''s profile page (which we will create). This
    profile page needs the author''s ID so that we can pass it in the URL. It will
    display all the information that we have about the author, as well as the list
    of all of their books. Let''s begin with this author''s profile page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Name this file `author.php` and save it to the directory where rest of the files
    are located.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few comments about the code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'We handle the author''s ID (line #13) by explicitly casting it to an integer
    so as to prevent a possible security hole. We later pass the `$id` variable to
    the text of the query without quoting as it''s OK to do so with numeric values.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will discuss the call to `$q->closeCursor(); $q = null` on line #13 in the
    following chapters. Here we will just note that it''s a good idea to call this
    method between queries executed on the same connection object and then set it
    to null. Our example would not work without it. Also note that we don''t need
    this after the last query.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also do simple error handling here: we check whether the author ID is invalid.
    If it is invalid, we display an error message and then exit. (See lines 22 to
    27.)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On lines 25 and 27, we use the author''s ID to create the query and set the
    fetch mode to be `PDO::FETCH_ASSOC`. Then we proceed to the display of data: first
    we render the author''s details and then all his books.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can return to your browser and point it to the URL: `http://localhost/author.php?id=1`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screen should appear:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![PDO Statements and Result Sets](graphics/2660-02-03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, everything is correct on the page: The author''s details, which
    we filed first (`id=1`), and the only book by this author. Now let''s see how
    our application reacts to an invalid ID submitted. We know that we have only three
    authors, so any number other than 1, 2, or 3 is invalid. Also, a non-number parameter
    will evaluate to 0, which is invalid. If we change the URL in the address bar
    to `http://localhost/author.php?id=zzz`. We will end up with the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![PDO Statements and Result Sets](graphics/2660-02-04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: You should also switch to SQLite in `common.inc.php` and see that this page
    also works with this database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify our existing `books.php` file to add an author column with
    a link to the author''s profile page. We will have to join the two tables where
    the book''s `author` field equals the author''s ID field, and select the author''s
    ID, first name, and last name. So our query will look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before we proceed with the changes, let''s run this query in the command line
    client. We will also modify this query for the client as its window will not fit
    the whole row:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, the query is returning two columns called `id`. This means
    that we will not be able to use the `PDO::FETCH_ASSOC` mode, since there can be
    only `id` array index. Here we have two options: Either use the `PDO::FETCH_NUM`
    mode or retrieve the ID fields using aliases.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we would code the page using `PDO::FETCH_NUM:`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note the highlighted lines—they contain the changes; the rest of file is the
    same. As you can see, we added the call to `$q->setFetchMode()` and changed the
    loop to use numeric column indexes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate back to `http://localhost/books.php`, we will see a list similar
    to the one in this screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![PDO Statements and Result Sets](graphics/2660-02-05.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: We can click on every author to get to their profile page. Of course, changing
    back to SQLite in `common.inc.php` should also work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Another (and much better) option is to use aliases for column names in the
    SQL code. If we do this, we will not have to take care of the numeric indexes
    and change the code every time we add or remove columns from our tables. We just
    change the SQL to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The final version of `books.php` will look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we changed the fetch mode back to `PDO::FETCH_ASSOC`. Also, we access
    the author's ID on line 34 with `$r['authorId']`, since we aliased that column
    with `authorId` in the query.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: PDO also allows us to fetch all the results into an array. We may need this
    for further processing or for passing to some function. However, this should be
    done only for small result sets. This is highly discouraged for applications like
    ours, because we simply display the list of books or authors. Fetching a big result
    set into an array will require memory allocated for the whole result, while in
    our case we display results row by row, so this requires memory for just one row.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is called `PDOStatement::fetchAll()`. The resulting array is either
    a two-dimensional array or a list of objects—this depends on the fetch mode. This
    method accepts all the `PDO::FETCH_xxxx` constants, just like `PDOStatement::fetch()`.
    For example, we could rewrite our `books.php` file in the following manner to
    achieve the same result. Here is the relevant part of `books.php` lines 9 to 46:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the highlighted lines here—we fetch the whole result into the `$books`
    array on line 5 and then iterate over it with a `foreach` loop on line 21\. If
    you run the modified page, you will see that we receive the same result. This
    will also work if we change to SQLite database in the `common.inc.php` file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PDOStatement::fetchAll()` method also allows us to select the values of
    a single column with the `PDO::FETCH_COLUMN` mode. If we want to fetch the entire
    book titles using the query from the last example, we can do the following (note
    the number and ordering of columns):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This would give the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, when a single column is requested, this method returns one-dimensional
    array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Result Set Metadata
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the previous section, the `PDOStatement` class allows us
    to retrieve some information about the data contained in the result set. This
    information is called **metadata**, and you probably have already used some of
    it one way or another.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The most important metadata about a result set is, of course, the number of
    rows it contains. We can use the row count to enhance user experience by, for
    example, paginating long result sets. Our example library application is still
    quite small, with only three books so far, but as our database grows, we surely
    will need some tools to get the total row count for every table displayed and
    paginate it for easy browsing.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, you would use the `mysql_num_rows(), sqlite_num_rows()` function
    or the `pg_num_rows()` function (depending on your database) to get the total
    number of rows returned by the query. In PDO, the method responsible for retrieving
    the number of rows is called `PDOStatement::rowCount()`. However, if you want
    to test it with the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: you will see that PDO returns 0 both for MySQL and SQLite. This is because PDO
    operates differently from the traditional database extensions. The documentation
    says, "If the last SQL statement executed by the associated `PDOStatement` class
    was a `SELECT` statement, some databases may return the number of rows returned
    by that statement. However, this behavior is not guaranteed for all databases
    and should not
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: be relied on for portable applications." Neither MySQL nor SQLite drivers support
    this functionality, and that's why the return value of this method is 0\. We will
    see how to count the number of rows returned with PDO (so that this is a really
    portable method) in [Chapter 5](ch05.html "Chapter 5. Handling Rowsets").
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *RDBMS* does not know how many rows a query will return till the last row
    has been retrieved. This is done because of performance considerations. In most
    cases, queries with a `WHERE` clause, return only part of the rows stored in a
    table, and database servers do their best to ensure that such queries execute
    as fast as possible. This means that they start returning rows as soon as they
    discover those that match the `WHERE` clause—this happens much earlier than when
    the last row is reached. That is why they really don't know how many rows will
    be returned beforehand. The `mysql_num_rows(), sqlite_num_rows()` function or
    the `pg_num_rows()` function operates on result sets that have been prefetched
    into memory (buffered queries). PDO's default behavior is to use unbuffered queries.
    We will speak about MySQL buffered queries later in [Chapter 6](ch06.html "Chapter 6. Advanced
    PDO Usage").
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method that can be of interest is the `PDOStatement::columnCount()`
    method, which returns the number of columns in the result set. It is handy when
    we execute arbitrary queries. (For example, a database management application
    like `phpMyAdmin` could make great use of this method, as it allows a user to
    type arbitrary SQL queries.) We can use it in the following way:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will reveal that our query returns a result set containing 10 columns (seven
    columns from the **books** table and three columns from **authors** table).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, PDO currently does not allow you to retrieve the name of the
    table or of a particular column from a result set to which it belongs. This functionality
    is useful if your application utilizes queries that join two or more tables. In
    such case, it is possible to fetch the table name for every column given its numeric
    index, starting with 0\. However, proper use of column aliases eliminates the
    need to use such functionality. For example, when we modified the books listing
    page to display the author's name, we aliased the author's ID column to avoid
    name conflict. That alias clearly identifies the column as belonging to the `authors`
    table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took our first steps with PDO and even created a small working
    database-driven, dynamic application that runs on two different databases. Now
    you should be able to connect to any supporting database, using the rules for
    constructing a connection string. You should then be able to run queries against
    it, and to traverse and display the result set.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deal with a very important aspect of any database-driven
    application—error handling. We will also extend our example application by giving
    it the ability to add and edit books and authors, thus making it more realistic
    and useful.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理任何数据库驱动应用程序的一个非常重要的方面——错误处理。我们还将通过为其添加和编辑书籍和作者的功能来扩展我们的示例应用程序，从而使其更加真实和有用。
