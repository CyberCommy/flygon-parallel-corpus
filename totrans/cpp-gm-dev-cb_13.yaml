- en: Chapter 13. Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Effectively commenting your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bit fields in a struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a sound technical design document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the const keyword to optimize your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bit shift operators in an enum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the new lambda feature in C++11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ is a vast ocean. There are many concepts and techniques that are required
    to master C++. On top of that, there are also a few little tricks that a programmer
    can learn from time to time to help develop better software. In this chapter,
    we will look at some of the techniques that a programmer can learn to write better
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Effectively commenting your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, a programmer is so engrossed in solving a problem that they forget
    to comment their code. Although this may not be a problem when they are working
    on it, if there are other team members involved who have to utilize that same
    section of code, it may become very difficult to fathom. Therefore, it is essential
    to comment code from an early stage of development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to comment code. Let''s add a source
    file called `Source.cpp`. Add the following code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comments are supposed to be written on any section, to help fellow developers
    understand what is going on. To comment a code, we use the `//` double backslash
    symbols. Whatever we write within that will not be compiled and will be ignored
    by the compiler. As a result, we can use it to make notes on different aspects
    in the code. We can also use the `/*` and `*/` symbol to comment multiple lines.
    Anything that is within a pair of `/*` and `*/` symbols will be ignored by the
    compiler. This technique becomes useful if we need to debug an application. We
    first comment out a large section of the code that we think is the culprit. The
    code should now build. Then we start uncommenting the code till we reach a point
    where the code breaks again.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes programmers tend to over-comment. For example, there is no need to
    write `//Addition` on top of an addition function, as we can clearly see that
    two numbers are being added. Similarly, we should not under-comment. As there
    are no comments on top of the `Logic` function, we have no clue as to why we are
    using that function and what that function does. So we must remember to comment
    just enough. This will only happen with practice and by working in a team environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using bit fields in a struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In structures, we can use bit fields to denote what size we want the structure
    to be. As well as this, it is also important to understand what size a struct
    actually takes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a Windows machine and a working copy of Visual Studio. No other prerequisites
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to use bit fields to find the
    size of a struct. Add a source file called `Source.cpp`. Then add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you can see, in the example we have assigned a struct of int, a char array,
    an undefined unsigned variable, and a float. When we execute the program, the
    output should be the size of both the structures in bytes. Assuming we are running
    this program on a 64-bit machine, int is 4 bytes, unsigned char array is 9 bytes,
    unsigned by default is 4 bytes, and float is 4 bytes. If we add them up, the total
    is 21 bytes. But if we print it out, we will notice that the output is 24 bytes.
    The reason for this is called *padding*. C++ always fetches data in chunks of
    4 bytes. Hence it will always pad with extra bytes till the size is a multiple
    of 4\. Because the size of the struct came out at 21, the nearest multiple of
    4 is 24, so we get that answer. Padding is not done to the structure as a whole,
    but per declaration, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the second struct, what we have done is assigned a bit field. Although
    an int is 4 bytes, we can instruct it to just have 2 bytes. The syntax for doing
    it is adding a `:` symbol followed by the byte value. So for the second struct,
    if we find the value, it is going to output it as `4` instead of `8`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a sound technical design document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we start a project, there are two documents that we generally rely on.
    The first document is a game design document, and the second is a technical design
    document. The technical design document should list the key features and high-level
    architecture of the key features. This system is changing rapidly though, with
    the advent of indie games. However, in a large-scale gaming studio, this process
    is still valid.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to create a technical design document:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an editor of your choice, preferably Microsoft Word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the key technical components of the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a data flow diagram to represent the flow of data between various components
    of the engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a flowchart to explain the logic of a certain complex section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write pseudocode for the sections that are key to the development of the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the key components are listed, the project manager can automatically assess
    the risk and complexity of each task. The developer will also understand what
    the key components of the engine or game are. This will help the developer plan
    their actions as well. When the data flow diagram is made, it will be easy to
    understand which component is dependent on which other component. As a result,
    the developer will know they have to implement *A* before they start coding *B*.
    A flow chart is also a great way to understand the flow of logic and sometimes
    helps to solve ambiguity that could occur in the future. Finally, pseudocode is
    essential for explaining to the developer how they must implement the code, or
    rather what is an advisable approach. As pseudocode is language independent, the
    same pseudocode could be used to write a game even in other languages apart from
    C++.
  prefs: []
  type: TYPE_NORMAL
- en: Using the const keyword to optimize your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen in previous recipes that a `const` keyword is used to make
    data or a pointer constant so that we cannot change the value or address, respectively.
    There is one more advantage of using the `const` keyword. This is particularly
    useful in the object-oriented paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and an installed version of
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to use the `const` keyword
    effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we are writing a simple application to add two numbers. The
    first function is a public function. This mean that it is exposed to other classes.
    Whenever we write public functions, we must ensure that they are not harming any
    private data of that class. As an example, if the public function was to return
    the values of the member variables or change the values, then this public function
    is very risky. Therefore, we must ensure that the function cannot modify any member
    variables by adding the `const` keyword at the end of the function. This ensures
    that the function is not allowed to change any member variables. If we try to
    assign a different value to the member, we will get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So this makes the code more secure. However, there is another problem. This
    public function internally calls another private function. What if this private
    function modifies the values of the member variables? Again, we will be at the
    same risk. As a result, C++ does not allow us to call that function unless it
    has the same signature of const at the end of the function. This is to ensure
    that the function cannot change the values of the member variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using bit shift operators in an enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen before in previous recipes, an enum is used to represent a collection
    of states. All the states are given an integer value by default, starting at `0`.
    However, we could specify a different integer value as well. More interestingly,
    we could use bit shift operators to club some of the states, easily set them to
    be active or inactive, and do other tricks with them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows with an
    installed Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to write bit shift operators in
    an enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the above example, we have three flag states in the enum. They are represented
    by the bit shift operator. So in memory, the first state is represented as `0000`,
    the second as `0001`, and the third as `0010`. We can now combine the states by
    using the `OR` operator (`|`). We can have a state called `JUMP` and another state
    called `SHOOT`. If we want the character to now `JUMP` and `SHOOT` together, we
    can combine these states. We can use the `&` operator to check whether a state
    is active or not. Similarly, if we have to remove a state from a combination,
    we can use the `XOR` operator (`^`). We can disable a state by using the `~` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new lambda function of C++ 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda functions are the new addition to the C++ family. They can be described
    as anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand a lambda function let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lambda functions are a new addition to the C++11 family. They are anonymous
    functions and can be very handy. They are generally passed as arguments to a function.
    The syntax of a lambda function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[ capture-list ] ( params ) mutable(optional) exception attribute -> ret {
    body }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `mutable` keyword is optional and is used to modify the parameters and
    call their non-const functions. The attribute provides the specification of the
    closure type. The capture list is optional and has a list of allowed types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[a,&b]`: Here `a` is captured by value and `b` is captured by reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[this]`: This captures the `this` pointer by value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[&]`: This captures all automatic variables used in the body of the lambda
    by reference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[=]`: This captures all automatic variables used in the body of the lambda
    by value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]`: This captures nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Params are lists of parameters, as in named functions, except that default arguments
    are not allowed (up to C++14). If auto is used as a type of a parameter, the lambda
    is a generic lambda (since C++14). `ret` is the return type of the function. If
    no type is provided, then `ret` tries to auto-inject a return type or void if
    it is not returning anything. Finally, we have the body of the function, which
    is used to write the logic of the function.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we store a vector list of numbers. After that, we traverse
    the list and use a lambda function. The lambda function stores all the numbers
    that are greater than 10 and displays the number. Lambda functions can be difficult
    to start off with but, with practice, they are very easy to grasp.
  prefs: []
  type: TYPE_NORMAL
