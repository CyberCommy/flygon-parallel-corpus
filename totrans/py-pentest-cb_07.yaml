- en: Network Sniffing with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Packet sniffer in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the packet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyShark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A sniffer is a program that can intercept network traffic and sniff packets
    to analyze them. As data streams flow across the network, the sniffer can capture
    each packet, decode the packet's raw data to get the values of various fields
    in the packet headers, and analyze its content according to the appropriate specifications.
    Network packet sniffers can be written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Packet sniffer in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple packet sniffer in Python can be created with the help socket module.
    We can use the raw socket type to get the packets. A raw socket provides access
    to the underlying protocols, which support socket abstractions. Since raw sockets
    are part of the internet socket API, they can only be used to generate and receive
    IP packets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As some behaviors of the socket module depend on the operating system socket
    API and there is no uniform API for using a raw socket under a different operating
    system, we need to use a Linux OS to run this script. So, if you are using Windows
    or macOS, please make sure to run this script inside a virtual Linux environment.
    Also, most operating systems require root access to use raw socket APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps  to create a basic packet sniffer with `socket` module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `basic-packet-sniffer-linux.py` and open it in your
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the required modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create an `INET` raw socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Both reading and writing to a raw socket require creating a raw socket first.
    Here we use the `INET` family raw socket. The family parameter for a socket describes
    the address family of the socket. The following are the address family constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AF_LOCAL`: Used for local communication'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_UNIX`: Unix domain sockets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_INET`: IP version 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_INET6`: IP version 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_IPX`: Novell IPX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_NETLINK`: Kernel user-interface device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_X25`: Reserved for X.25 project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_AX25`: Amateur Radio AX.25'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_APPLETALK`: Appletalk DDP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_PACKET`: Low-level packet interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AF_ALG`: Interface to kernel crypto API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next parameter passed is the type of the socket. The following are the
    possible values for the socket type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SOCK_STREAM`: Stream (connection) socket'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOCK_DGRAM`: Datagram (connection-less) socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOCK_RAW`: RAW socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOCK_RDM`: Reliably delivered message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOCK_SEQPACKET`: Sequential packet socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SOCK_PACKET`: Linux-specific method of getting packets at the development
    level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last parameter is the protocol of the packet. This protocol number is defined
    by the **Internet Assigned Numbers Authority** (**IANA**). We have to be aware
    of the family of the socket; then we can only choose a protocol. As we selected
    `AF_INET` (IPV4), we can only select IP-based protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, start an infinite loop to receive data from the socket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `recvfrom` method in the socket module helps us to receive all the data
    from the socket. The parameter passed is the buffer size; `65565` is the maximum
    buffer size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the program with Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)![](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Parsing the packet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can try to parse the data that we sniffed, and unpack the headers. To
    parse a packet, we need to have an idea of the Ethernet frame and the packet headers
    of the IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ethernet frame structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first six bytes are for the **Destination MAC** address and the next six
    bytes are for the **Source MAC**. The last two bytes are for the **Ether Type**.
    The rest includes **DATA** and **CRC Checksum**. According to RFC 791, an IP header
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The IP header includes the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol Version (four bits)**: The first four bits. This represents the
    current IP protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header Length (four bits)**: The length of the IP header is represented in
    32-bit words. Since this field is four bits, the maximum header length allowed
    is 60 bytes. Usually the value is `5`, which means five 32-bit words: *5 * 4 =
    20 bytes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type of Service (eight bits)**: The first three bits are precedence bits,
    the next four bits represent the type of service, and the last bit is left unused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Total Length (16 bits)**: This represents the total IP datagram length in
    bytes. This a 16-bit field. The maximum size of the IP datagram is 65,535 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flags (three bits)**: The second bit represents the **Don''t Fragment** bit.
    When this bit is set, the IP datagram is never fragmented. The third bit represents
    the **More Fragment** bit. If this bit is set, then it represents a fragmented
    IP datagram that has more fragments after it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time To Live (eight bits)**: This value represents the number of hops that
    the IP datagram will go through before being discarded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protocol (eight bits)**: This represents the transport layer protocol that
    handed over data to the IP layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header Checksum (16 bits)**: This field helps to check the integrity of an
    IP datagram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source and destination IP (32 bits each)**: These fields store the source
    and destination address, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to the RFC 791 document for more details on IP headers: [https://tools.ietf.org/html/rfc791](https://tools.ietf.org/html/rfc791)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Following are the steps to parse a packet:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `basic-parse-packet-packet-linux.py` and import the
    modules required to parse the packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a function to parse the Ethernet header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the `unpack` method in the `struct` module to unpack the headers.
    From the Ethernet frame structure, the first six bytes are for the destination
    MAC, the second 6 bytes are for the source MAC, and the last unsigned short is
    for the Ether Type. Finally, the rest is data. So, this function returns the destination
    MAC, source MAC, protocol, and data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can create a main function and, in the `ethernet_head()`, parse this
    function and get the details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can check the data section in the Ethernet frame and parse the IP headers.
    We can create another function to parse the `ipv4` headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As per the IP headers, we will unpack the headers using the `unpack` method
    in `struct`, and return the `version`, `header_lentgth`, `ttl`, protocol source,
    and destination IPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now update `main()` to print the IP headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, the IP addresses printed are not in a readable format, so we can
    write a function to format them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to update the `ipv4_head` function to format the IP address by adding
    the following lines before returning the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the internet layer unpacked, the next layer we have to unpack
    is the transport layer. We can determine the protocol from the protocol ID in
    the IP header. The following are the protocol IDs for some of the protocols:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**TCP**: 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ICMP**: 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UDP**: 17'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RDP**: 27'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we can create a function to unpack the TCP packets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The TCP packets are unpacked according to the TCP packet header''s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can update `main()` to print the TCP header details. Add the following
    lines inside the `ipv4` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, update the functions to unpack the UDP and ICMP packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The packets are unpacked according to the packet header structure. Here is
    the packet header structure for ICMP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'According to the diagram, we can unpack the packet using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the packet header structure for UDP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we did for the ICMP, we can unpack the UDP packet headers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now save and run the script with the required permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will print all the packets that were sniffed. So, it will continue
    printing until we stop it with a keyboard interrupt. The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: PyShark
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyShark is a wrapper for the Wireshark CLI (TShark), so we can have all Wireshark
    decoders in the PyShark. We can use PyShark to sniff an interface or we can analyze
    the `pcap` files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When using this module, make sure to install Wireshark on your system and install
    `pyshark` using the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Also, make sure you have installed TShark on your machine. TShark is the terminal-based
    Wireshark, which is used by PyShark for packet capturing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Learn more about TShark here: [https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html](https://www.wireshark.org/docs/wsug_html_chunked/AppToolstshark.html)
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lets try PyShark with some examples. Make sure to install TShark in your system.
  prefs: []
  type: TYPE_NORMAL
- en: For a better understanding, we can use the Python interactive terminal and go
    through the functions of PyShark. Please note that these commands can also be
    included in the scripts. The only dependency is TShark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `pyshark` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now load the `pcap` file to `pyshark`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can sniff from a live interface with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will sniff the interface for the next 3 seconds
  prefs: []
  type: TYPE_NORMAL
- en: Now you can get the packet details from the `cap` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To print out the first packet details, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can view all the possible options with `dir()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To view them in a pretty format, we can use the `pprint` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print all the possible options for a packet in PyShark. The output
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can iterate through each packet as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can get the stream of filtered packets to `pyshark` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will filter out the packets, except, TCP/IP to port `80`
  prefs: []
  type: TYPE_NORMAL
