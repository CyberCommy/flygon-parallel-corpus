- en: Shopping List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the modern languages and frameworks used to present a to-do list as
    their sample app. It is a great way to understand the basics of a framework as
    user interaction, basic navigation, or how to structure code. We''ll start in
    a more pragmatic way: building a shopping list app.'
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to develop this app in React Native code, build it for both
    iOS and Android, and finally install it on your phone. This way, you could not
    only show your friends what you built, but also understand missing features that
    you can build by yourself, thinking about user-interface improvements, and above
    all, motivating yourself to keep learning React Native as you feel its true potential.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have built a fully-functional shopping
    list that you can use on your phone and will have all the tools you need to create
    and maintain simple stateful apps.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most powerful features of React Native is its cross-platform capabilities;
    we will build our shopping list app for both iOS and Android, reusing 99% of our
    code. Let''s take a look at how the app will look on both platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/80e9e967-6d95-4ece-9618-9315dca63086.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding more products, this is how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7209e648-c819-45e5-bf3c-90ebf6db1325.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a7448887-adee-415c-a4fa-e6bff040a8eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding more products, this is how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b40260c4-d53a-4e30-b84b-6fa59943bc99.png)'
  prefs: []
  type: TYPE_IMG
- en: The app will have a very similar user interface on both platforms, but we won't
    need to care much about the differences (for example, the back button on the Add
    a product screen), as they will be handled automatically by React Native.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that each platform has its own user interface
    patterns, and it's a good practice to follow them. For example, navigation is
    usually handled through tabs in iOS while Android prefers a drawer menu, so we
    should build both navigation patterns if we want happy users on both platforms.
    In any case, this is only a recommendation, and any user interface pattern could
    be built on every platform. In later chapters, we will see how to handle two different
    patterns in the most effective way within the same codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app comprises of two screens: your shopping list and a list of the products
    which could be added to your shopping list. The user can navigate from the Shopping
    List screen to the Add a product screen through the round blue button and back
    through the < Back button. We will also build a clear button in the shopping list
    screen (the round red button) and the ability to add and remove products on the
    Add a product screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Folder structure for a basic React Native project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native's basic CLI commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JS debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live reloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling with NativeBase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncStorage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt popups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Native has a very powerful CLI that we will need to install to get started
    with our project. To install, just run the following command in your command line
    (you might need to run this with `sudo`), if you don''t have enough permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is finished, we can start using the React Native CLI
    by typing `react-native`. To start our project, we will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a basic project named `GroceriesList` with all the
    dependencies and libraries you need to build the app on iOS and Android. Once
    the CLI has finished installing all the packages, you should have a folder structure
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/127ee358-1f61-464c-8cdd-dc51619f81ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The entry file for our project is `index.js`. If you want to see your initial
    app running on a simulator, you can use React Native''s CLI again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Provided you have XCode or Android Studio and Android Simulator installed,
    you should be able to see a sample screen on your simulator after compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c08290d0-ef33-4138-b3b6-e44a8b34946c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have everything we need to set up to start implementing our app, but in
    order to easily debug and see our changes in the simulator, we need to enable
    two more features: remote JS debugging and live reloading.'
  prefs: []
  type: TYPE_NORMAL
- en: For debugging, we will use *React Native Debugger*, a standalone app, based
    on the official debugger for React Native, which includes React Inspector and
    Redux DevTools. It can be downloaded following the instructions on its GitHub
    repository ([https://github.com/jhen0409/react-native-debugger](https://github.com/jhen0409/react-native-debugger)).
    For this debugger to work properly, we will need to enable Remote JS Debugging
    from within our app by opening a React Native development menu within the simulator
    by pressing *command* + *ctrl* + *Z* on iOS or *command* + *M* on Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well, we should see the following menu appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/269055ed-9910-4a00-bba6-c43fe50bcd98.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/67e2584e-18b2-48b8-8b05-c0c966e79b18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will press two buttons: Debug Remote JS and Enable Live Reload. Once
    we are done with this, we have all our development environment up and ready to
    start writing React code.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our app only comprises of two screens: Shopping List and Add Products. Since
    the state for such a simple app should be easy to manage, we won''t add any library
    for state management (for example, Redux), as we will send the shared state through
    the navigation component. This should make our folder structure rather simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3e58d766-c67e-4b38-bffe-fb0b5d6b6875.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have to create an `src` folder where we will store all our React code. The
    self-created file `index.js` will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In short, these files will import the common root code for our app, store it
    in a variable named `App` and later pass this variable to the `AppRegistry` through
    the `registerComponent` method. `AppRegistry` is the component to which we should
    register our root components. Once we do this, React Native will generate a JS
    bundle for our app and then run the app when it's ready by invoking `AppRegistry.runApplication`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the code we will be writing, will be placed inside the `src` folder.
    For this app, we will create our root component (`main.js`) in this folder, and
    a `screens` subfolder, in which we will store our two screens (`ShoppingList` and
    `AddProduct`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s install all the initial dependencies for our app before continue
    coding. In our project''s root folder, we will need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running that command will install all the basic dependencies for every React
    Native project. Let''s now install the three packages we will be using for this
    specific app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Further ahead in this chapter, we will explain what each package will be used
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Navigation component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most mobile apps comprise of more than one screen, so we will need to be able
    to "travel" between those screens. In order to achieve this, we will need a `Navigation`
    component. React Native comes with a `Navigator` and a `NavigatorIOS` component
    out of the box, although the React maintainers recommend using an external navigation
    solution built by the community named `react-navigation` ([https://github.com/react-community/react-navigation](https://github.com/react-community/react-navigation)),
    which is very performant, well maintained, and rich in features, so we will use
    it for our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we already installed our module for navigation (`react-navigation`),
    we can set up and initialize our `Navigation` component inside our `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our root component imports both of the screens in our app (`ShoppingList` and
    `AddProduct`) and passes them to the `StackNavigator` function, which generates
    the `Navigator` component. Let's take a deeper look into how `StackNavigator`
    works.
  prefs: []
  type: TYPE_NORMAL
- en: '`StackNavigator` provides a way for any app to transition between screens,
    where each new screen is placed on top of a stack. When we request the navigation
    to a new screen, `StackNavigator` will slide the new screen from the right and
    place a `< Back` button in the upper-right corner to go back to the previous screen
    in iOS or, will fade in from the bottom while a new screen is placing a `<-` arrow
    to go back in Android. With the same codebase, we will trigger familiar navigation
    patterns in iOS and Android. `StackNavigator` is also really simple to use, as
    we only need to pass the screens in our apps as a hash map, where the keys are
    the names we want for our screens and the values are the imported screens as React
    components. The result is a `<Navigator/>` component which we can render to initialize
    our app.'
  prefs: []
  type: TYPE_NORMAL
- en: Styling our app with NativeBase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Native includes a powerful way to style our components and screens using
    Flexbox and a CSS-like API but, for this app, we want to focus on the functionality
    aspect, so we will use a library including basic styled components as buttons,
    lists, icons, menus, forms, and many more. It can be seen as a Twitter Bootstrap
    for React Native.
  prefs: []
  type: TYPE_NORMAL
- en: There are several popular UI libraries, NativeBase and React Native elements
    being the two most popular and best supported. Out of these two, we will choose
    NativeBase, since it's documentation is slightly clearer for beginners.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the detailed documentation on how NativeBase works on their website
    ([https://docs.nativebase.io/](https://docs.nativebase.io/)), but we will go through
    the basics of installing and using some of their components in this chapter. We
    previously installed `native-base` as a dependency of our project through `npm
    install` but NativeBase includes some peer dependencies, which need to be linked
    and included in our iOS and Android native folders. Luckily, React Native already
    has a tool for finding out those dependencies and linking them; we just need to
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have all the UI components from NativeBase fully available
    in our app. So, we can start building our first screen.
  prefs: []
  type: TYPE_NORMAL
- en: Building the ShoppingList screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first screen will contain a list of the items we need to buy, so it will
    contain one list item per item we need to buy, including a button to mark that
    item as already bought. Moreover, we need a button to navigate to the `AddProduct`
    screen, which will allow us to add products to our list. Finally, we will add
    a button to clear the list of products, in case we want to start a new shopping
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/81cbfccf-1b8f-48e0-9035-b47acaf9030e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's start by creating `ShoppingList.js` inside the `screens` folder and importing
    all the UI components we will need from `native-base` and `react-native` (we will
    use an alert popup to warn the user before clearing all items). The main UI components
    we will be using are `Fab` (the blue and red round buttons), `List`, `ListItem`,
    `CheckBox`, `Text`, and `Icon`. To support our layout, we will be using `Body`,
    `Container`, `Content`, and `Right`, which are layout containers for the rest
    of our components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having all these components, we can create a simple version of our `ShoppingList`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a dumb component statically displaying the components we will
    be using on this screen. Some things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`navigationOptions` is a static attribute which will be used by `<Navigator>`
    to configure how the navigation would behave. In our case, we want to display
    My Groceries List as the title for this screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `native-base` to do its magic, we need to use `<Container>` and `<Content>`
    to properly form the layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fab` buttons are placed outside `<Content>`, so they can float over the left
    and right-bottom corners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `ListItem` contains a `<Body>` (main text) and a `<Right>` (icons aligned
    to the right).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we enabled Live Reload in our first steps, we should see the app reloading
    after saving our newly created file. All the UI elements are now in place, but
    they are not functional since we didn't add any state. This should be our next
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Adding state to our screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add some initial state to our `ShoppingList` screen to populate the
    list with actual dynamic data. We will start by creating a constructor and setting
    the initial state there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can render that state inside of `<List>` (inside the `render` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now rely on a list of products inside our component's state, each product
    storing an `id`, a `name`, and `gotten` properties. When modifying this state,
    we will automatically be re-rendering the list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to add some event handlers, so we can modify the state at the
    users' command or navigate to the `AddProduct` screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the interaction with the user will happen through event handlers in React
    Native. Depending on the controller, we will have different events which can be
    triggered. The most common event is `onPress`, as it will be triggered every time
    we push a button, a checkbox, or a view in general. Let''s add some `onPress`
    handlers for all the components which can be pushed in our screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we added three `onPress` event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: On `<ListItem>`, to react when the user taps on one product in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `<CheckBox>`, to react when the user taps on the checkbox icon next to every
    product in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On both the `<Fab>` buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you know React, you probably understand why we use `.bind` in all our handler
    functions, but, in case you have doubts, `.bind` will make sure we can use `this`
    inside the definition of our handlers as a reference to the component itself instead
    of the global scope. This will allow us to call methods inside our components
    as `this.setState` or read our component's attributes, such as `this.props` and
    `this.state`.
  prefs: []
  type: TYPE_NORMAL
- en: For the cases when the user taps on a specific product, we also bind the product
    itself, so we can use them inside our event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the functions which will serve as event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, let's create a handler for when the user taps on a product from our shopping
    list or in its checkbox. We want to mark the product as `gotten` (or unmark it
    if it was already `gotten`), so we will update the state with the product marked
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will add a handler for the blue `<Fab>` button to navigate to the
    `AddProduct` screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This handler uses `this.props.navigation`, which is a property automatically
    passed by the `Navigator` component from `react-navigation`. This property contains
    a method named `navigate`, receiving the name of the screen to which the app should
    navigate plus an object which can be used as a global state. In the case of this
    app, we will store three keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addProduct`: One function to allow the `AddProduct` screen to modify the `ShoppingList`
    component''s state to reflect the action of adding a new product to the shopping
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteProduct`: One function to allow the `AddProduct` screen to modify the `ShoppingList`
    component''s state to reflect the action of removing a product from the shopping
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`productsInList`: A variable holding the list of products is already on the
    shopping list, so the `AddProducts` screen can know which products were already
    added to the shopping list and display those as "already added", preventing the
    addition of duplicate items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling state within the navigation should be seen as a workaround for simple
    apps containing a limited number of screens. In larger apps (as we will see in
    later chapters), a state management library, such as Redux or MobX, should be
    used to keep the separation between pure data and user interface handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the last handler for the blue `<Fab>` button, which enables the
    user to clear all the items in the shopping list in case you want to start a new
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are using `Alert` to prompt the user for confirmation before clearing all
    the elements in our shopping list. Once the user confirms this action, we will
    empty the `products` attribute in our component's state.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how the whole component''s structure would look like when putting
    all the methods together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The structure of a React Native component is very similar to a normal React
    component. We need to import React itself and then some components to build up
    our screen. We also have several event handlers (which we have prefixed with an
    underscore as a mere convention) and finally a `render` method to display our
    components using standard JSX.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference with a React web app is the fact that we are using React
    Native UI components instead of DOM components.
  prefs: []
  type: TYPE_NORMAL
- en: Building the AddProduct screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the user will have the need of adding new products to the shopping list,
    we need to build a screen in which we can prompt the user for the name of the
    product to be added and save it in the phone's storage for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Using AsyncStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a React Native app, it's important to understand how mobile devices
    handle the memory used by each app. Our app will be sharing the memory with the
    rest of the apps in the device so, eventually, the memory which is using our app
    will be claimed by a different app. Therefore, we cannot rely on putting data
    in memory for later use. In case we want to make sure the data is available across
    users of our app, we need to store that data in the device's persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: React Native offers an API to handle the communication with the persistent storage
    in our mobile devices and this API is the same on iOS and Android, so we can write
    cross-platform code comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API is named `AsyncStorage`, and we can use it after importing from React
    Native:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will only use two methods from `AsyncStorage`: `getItem` and `setItem`.
    For example, we will create within our screen a local function to handle the addition
    of a product to the full list of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some interesting things to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using ES7 features such as `async` and `await` to handle asynchronous
    calls instead of promises or callbacks. Understanding ES7 is outside the scope
    of this book, but it is recommended to learn and understand about the use of `async`
    and `await`, as it's a very powerful feature we will be using extensively throughout
    this book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time we add a product to `allProducts`, we also call `AsyncStorage.setItem`
    to permanently store the product in our device's storage. This action ensures
    that the products added by the user will be available even when the operating
    system clears the memory used by our app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to pass two parameters to `setItem` (and also to `getItem`): a key
    and a value. Both of them must be strings, so we would need to use `JSON.stringify`,
    if we want to store the JSON-formatted data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding state to our screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have just seen, we will be using an attribute in our component's state
    named `allProducts`, which will contain the full list of products the user can
    add to the shopping list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can initialize this state inside the component''s constructor to give the
    user a gist of what he/she will be seeing on this screen even during the first
    run of the app (this is a trick used by many modern apps to onboard users by faking
    a `used` state):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Besides `allProducts`, we will also have a `productsInList` array, holding all
    the products which are already added to the current shopping list. This will allow
    us to mark the product as `Already in shopping list`, preventing the user from
    trying to add the same product twice in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'This constructor will be very useful for our app''s first run but once the
    user has added products (and therefore saved them in persistent storage), we want
    those products to display instead of this test data. In order to achieve this
    functionality, we should read the saved products from `AsyncStorage` and set it
    as the initial `allProducts` value in our state. We will do this on `componentWillMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We are updating the state once the screen is ready to be mounted. First, we
    will update the `allProducts` value by reading it from the persistent storage.
    Then, we will update the list `productsInList` based on what the `ShoppingList`
    screen has set as the state in the `navigation` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this state, we can build our list of products, which can be added to the
    shopping list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Inside our `render` method, we will use an `Array.map` function to iterate and
    print each possible product, checking if the product is already added to the current
    shopping list to display a note, warning the user: `Already in shopping list`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we still need to add a better layout, buttons, and event handlers
    for all the possible user actions. Let's start improving our `render` method to
    put all the functionality in place.
  prefs: []
  type: TYPE_NORMAL
- en: Adding event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it happened with the `ShoppingList` screen, we want the user to be able to
    interact with our `AddProduct` component, so we will add some event handlers to
    respond to some user actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `render` method should then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three event handlers responding to the three press events in this
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: On the blue `<Fab>` button, which is in charge of adding new products to the
    products list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On each `<ListItem>`, which will add the product to the shopping list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the delete icons inside each `<ListItem>` to remove this product from the
    list of the products, which can be added to the shopping list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start adding new products to the available products list once the user
    presses the `<Fab>` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using here the `prompt` function from the `react-native-prompt-android`
    module. Despite its name, it''s a cross-platform prompt-on-a-pop-up library, which
    we will use to add products through the `addNewProduct` function we created before.
    We need to import the `prompt` function before we use it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/80a2b8e1-ff09-4493-a4ef-41a52d6ecd3e.png)![](Images/c1729134-4da3-4dcd-bf9a-f5ae93639a81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the user enters the name of the product and presses OK, the product will
    be added to the list so that we can move to the next event handler, adding products
    to the shopping list when the user taps on the product name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This handler checks if the selected product is on the shopping list already.
    If it is, it will remove it by calling `deleteProduct` from the navigation state
    and also from the component's state by calling `setState` . Otherwise, it will
    add the product to the shopping list by calling `addProduct` in the navigation
    state and refresh the local state by calling `setState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add an event handler for the delete icon on each of the `<ListItems>`,
    so the user can remove products from the list of available products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We need to remove the product from the component's local state, but also from
    the `AsyncStorage` so it doesn't show during later runs of our app.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have all the pieces to build our `AddProduct` screen, so let''s take a look
    at the general structure of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a very similar structure to the one we built for `ShoppingList `: the `navigatorOptions` constructor
    building the initial state, user action handlers, and a `render` method. In this
    case, we added a couple of async methods as a convenient way to deal with `AsyncStorage`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and distributing the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running our app on a simulator/emulator is a very reliable way to feel how our
    app will behave in a mobile device. We can simulate touch gestures, poor network
    connectivity environments, or even memory problems, when working in simulators/emulators.
    But eventually, we would like to deploy the app to a physical device, so we could
    perform a more in-depth testing.
  prefs: []
  type: TYPE_NORMAL
- en: There are several options to install or distribute an app built in React Native,
    the direct cable connection being the easiest one. Facebook keeps an updated guide
    on how to achieve direct installation on React Native's site ([https://facebook.github.io/react-native/docs/running-on-device.html](https://facebook.github.io/react-native/docs/running-on-device.html)),
    but there are other alternatives when the time comes to distribute the app to
    other developers, testers, or designated users.
  prefs: []
  type: TYPE_NORMAL
- en: Testflight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testflight ([https://developer.apple.com/testflight/](https://developer.apple.com/testflight/))
    is an awesome tool for distributing the app to beta testers and developers, but
    it comes with a big drawback--it only works for iOS. It''s really simple to set
    up and use as it is integrated into iTunes Connect, and Apple considers it the
    official tool for distributing apps within the development team. On top of that,
    it''s absolutely free, and it''s usage limits are quite large:'
  prefs: []
  type: TYPE_NORMAL
- en: Up to 25 testers in your team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to 30 devices per tester in your team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to 2,000 external testers outside your team (with grouping capabilities)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, Testflight is the platform to choose when you target your apps only
    to iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: Since, in this book, we want to focus on cross-platform development, we will
    introduce other alternatives to distribute our apps to iOS and Android devices
    from the same platform.
  prefs: []
  type: TYPE_NORMAL
- en: Diawi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Diawi ([http://diawi.com](http://diawi.com)) is a website where developers
    can upload their `.ipa` and `.apk` files (the compiled app) and share the links
    with anybody, so the app can be downloaded and installed on any iOS or Android
    device connected to the internet. The process is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `.ipa` (iOS) / `.apk` (Android) in XCode/Android studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop the generated `.ipa`/`.apk` file into Diawi's site.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Share the link created by Diawi with the list of testers by email or any other
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Links are private and can be password protected for those apps with the higher
    need of security. The main downside is the management of the testing devices,
    as once the links are distributed, Diawi loses control over them, so the developer
    cannot know which versions were downloaded and tested. If managing the list of
    testers manually is an option, Diawi is a good alternative to Testflight.
  prefs: []
  type: TYPE_NORMAL
- en: Installr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we are in need of managing what versions were distributed to which testers
    and whether they have already started testing the app or not, we should give Installr
    ([https://www.installrapp.com](https://www.installrapp.com)) a try, since functionality-wise
    it is quite similar to Diawi, but it also includes a dashboard to control who
    are the users, which apps were sent to them individually, and the status of the
    app in the testing device (not installed, installed, or opened). This dashboard
    is quite powerful and definitely a big plus when one of our requirements is to
    have good visibility over our testers, devices, and builds.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of Installr is its free plan only covers three testing devices
    per build, although they offer a cheap one-time pay scheme in case we really want
    to have that number increased. It's a very reasonable option when we are in need
    of visibility and cross-platform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the course of this chapter, we learned how to start up a React Native
    project, building an app which includes basic navigation and handling several
    user interactions. We saw how to handle persistent data and basic states using
    the navigation module, so we could transition through the screens in our project.
  prefs: []
  type: TYPE_NORMAL
- en: All these patterns can be used to build lots of simple apps, but in the next
    chapter, we will dive deeper into more complex navigation patterns and how to
    communicate and process external data fetched from the internet, which will enable
    us to structure and prepare our app for growing. On top of that, we will use MobX,
    a JavaScript library, for state management, which will make our domain data available
    to all the screens inside our app in a very simple and effective way.
  prefs: []
  type: TYPE_NORMAL
