- en: Chapter 12. Working with UE4 APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Application Programming Interface** (**API**) is the way in which you,
    as the programmer, instruct the engine, and so the PC, what to do. All of UE4's
    functionality is encapsulated into modules, including very basic and core functionality.
    Each module has an API for it. To use an API, there is a very important linkage
    step, where you must list all APIs that you will be using in your build in a `ProjectName.Build.cs`
    file, which is located in your **Solution Explorer** window.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not name any of your UE4 projects the exact same name as one of the UE4 API
    names!
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with UE4 APIs](img/00286.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a variety of APIs inside the UE4 engine that expose functionality
    to various essential parts of it. Some of the interesting APIs that we''ll explore
    in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Core/Logging API – Defining a custom log category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Logging API – `FMessageLog` to write messages to the **Message Log**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Math API – Rotation using `FRotator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Math API – Rotation using `FQuat`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Math API – Rotation using `FRotationMatrix` to have one object face another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape API – Landscape generation with Perlin noise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foliage API – Adding trees procedurally to your level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape and Foliage APIs – Map generation using Landscape and Foliage APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – Triggering an actor's gameplay abilities with game controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – Implementing stats with `AttributeSet`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – Implementing buffs with `GameplayEffect`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayTags API – Attaching `GameplayTags` to an actor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayTasks API – Making things happen with `GameplayTasks`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP API – Web request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP API – Progress bars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The UE4 engine's base functionality available in the editor is quite broad.
    The functionality from C++ code is actually grouped out into little sections called
    APIs. There is a separate API module for each important functionality in the UE4
    codebase. This is done to keep the codebase highly organized and modular.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using different APIs may require special linkage in your `Build.cs` file! If
    you are getting build errors, be sure to check that the linkage with the correct
    APIs is there!
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete API listing is located in the following documentation: [https://docs.unrealengine.com/latest/INT/API/](https://docs.unrealengine.com/latest/INT/API/).'
  prefs: []
  type: TYPE_NORMAL
- en: Core/Logging API – Defining a custom log category
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UE4 itself defines several logging categories, including categories such as
    `LogActor`, which has any log messages to do with the `Actor` class, and `LogAnimation`,
    which logs messages about Animations. In general, UE4 defines a separate logging
    category for each module. This allows developers to output their log messages
    to different logging streams. Each log steam''s name is prefixed to the outputted
    message as shown in the following example log messages from the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The above are sample log messages from the engine, each prefixed with their
    log category. Warning messages appear in yellow and have **Warning** added to
    the front as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code you will find on the Internet tends to use `LogTemp` for a
    UE4 project''s own messages, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can actually improve upon this formula by defining our own custom `LogCategory`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a UE4 project ready in which you'd like to define a custom log. Open a
    header file that will be included in almost all files using this log.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the main header file for your project; for example, if your project''s
    name is `Pong`, you''ll open `Pong.h`. Add the following line of code after `#include
    Engine.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Defined in `AssertionMacros.h`, there are three arguments to this declaration,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CategoryName`: This is the log category name being defined (`LogPong` here)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultVerbosity`: This is the default verbosity to use on log messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompileTimeVerbosity`: This is the verbosity to bake into compiled code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the main `.cpp` file for your project, include the following line of
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your log with the various display categories, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](img/00287.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging works by outputting messages to the **Output Log** (**Window** | **Developer
    Tools** | **Output Log**) as well as a file. All information outputted to the
    **Output Log** is also mirrored to a simple text file that is located in your
    project's `/Saved/Logs` folder. The extension of the log files is `.log`, with
    the most recent one being named `YourProjectName.log`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can enable or suppress log messages for a particular log channel from within
    the editor using the following console commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you'd like to edit the initial values of the output levels of some of the
    built-in log types, you can use a C++ class to create changes to the `Engine.ini`
    config file. You can change the initial values in the `engine.ini` configuration
    file. See [https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime](https://wiki.unrealengine.com/Logs,_Printing_Messages_To_Yourself_During_Runtime)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UE_LOG` sends its output to **Output Window**. If you''d like to use the more
    specialized **Message Log** window in addition, you can alternatively use the
    `FMessageLog` object to write your output messages. `FMessageLog` writes to both
    the **Message Log** and the **Output Window**. See the next recipe for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core/Logging API – FMessageLog to write messages to the Message Log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FMessageLog` is an object that allows you to write output messages to the
    **Message Log** (**Window** | **Developer Tools** | **Message Log**) and **Output
    Log** (**Window** | **Developer Tools** | **Output Log**) simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have your project ready and some information to log to **Message Log**. Display
    **Message Log** in your UE4 Editor. The following screenshot is of the **Message
    Log**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add `#define` to your main header file (`ProjectName.h`) defining `LOCTEXT_NAMESPACE`
    as something unique to your codebase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This `#define` is used by the `LOCTEXT()` macro, which we use to generate `FText`
    objects, but is not seen in output messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare your `FMessageLog` by constructing it somewhere very global. You can
    use `extern` in your `ProjectName.h` file. Consider the following piece of code
    as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, create your `FMessageLog` by defining it in a `.cpp` file and registering
    it with `MessageLogModule`. Be sure to give your logger a clear and unique name
    on construction. It''s the category of your log that will appear to the left of
    your log messages in **Output Log**. For example, `ProjectName.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `KEY` to `LOCTEXT` (first argument) must be unique or you will get a previously
    hashed string back. If you'd like, you can include a `#define` that repeats the
    argument to `LOCTEXT` twice, as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Log your messages using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code utilizes the `FTEXT()` macro defined earlier. Be sure it is in your
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constructing your message log again after initialization retrieves a copy of
    the original message log. For example, at any place in the code, you can write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Core/Math API – Rotation using FRotator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rotation in UE4 has such complete implementation that it can be hard to choose
    how to rotate your objects. There are three main methods—`FRotator`, `FQuat`,
    and `FRotationMatrix`. This recipe outlines the construction and use of the first
    of the three different methods for the rotation of objects—the `FRotator`. Using
    this, and the following two recipes, you can select at a glance a method to use
    to rotate your objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a UE4 project that has an object you can get a C++ interface with. For
    example, you can construct a C++ class Coin that derives from `Actor` to test
    out rotations with. Override the `Coin::Tick()` method to apply your rotations
    from the C++ code. Alternatively, you can call these rotation functions in the
    `Tick` event from Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will rotate an object at a rate of one degree per second.
    The actual rotation will be the accumulated time since the object was created.
    To get this value, we'll just call `GetWorld()->TimeSeconds`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a custom C++ derivative of the `Actor` class called `Coin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the C++ code, override the `::Tick()` function of the `Coin` actor derivative.
    This will allow you to effect a change to the actor in each frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct your `FRotator. FRotators` can be constructed using a stock pitch,
    yaw, and roll constructor, as shown in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `FRotator` will be constructed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The standard orientation for an object in UE4 is with Forward facing down the
    *+X* axis. Right is the *+Y* axis, and Up is *+Z*.![How to do it…](img/00289.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pitch is rotation about the *Y* axis (across), yaw is rotation about the *Z*
    axis (up), and roll is rotation about the *X* axis. This is best understood in
    the following three points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Pitch**: If you think of an airplane in UE4 standard coordinates, the *Y*
    axis goes along the wingspan (pitching tilts it forward and backward)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yaw**: The *Z* axis goes straight up and down (yawing turns it left and right)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roll**: The *X* axis goes straight along the fuselage of the plane (rolling
    does barrel rolls)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should note that in other conventions, the *X* axis is pitch, the *Y* axis
    is yaw, and the *Z* axis is roll.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply your `FRotator` to your actor using the `SetActorRotation` member function,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Core/Math API – Rotation using FQuat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quaternions sound intimidating, but they are extremely easy to use. You may
    want to review the theoretical math behind them using the following videos:'
  prefs: []
  type: TYPE_NORMAL
- en: Fantastic Quaternions by Numberphile – [https://www.youtube.com/watch?v=3BR8tK-LuB0](https://www.youtube.com/watch?v=3BR8tK-LuB0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Quaternions by Jim Van Verth – [http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding](http://gdcvault.com/play/1017653/Math-for-Game-Programmers-Understanding)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we won't cover the math background here! In fact, you don't need to
    understand much about the math background quaternions to use them extremely effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a project ready and an `Actor` with an override `::Tick()` function that
    we can enter the C++ code into.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To construct a quaternion, the best constructor to use is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**For example, to define a twisting rotation**:'
  prefs: []
  type: TYPE_NORMAL
- en: Quaternions have quaternion addition, quaternion subtraction, multiplication
    by a scalar, and division by a scalar defined for them, amongst other functions.
    They are extremely useful to rotate things at arbitrary angles, and point objects
    at one another.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quaterions are a bit strange, but using them is quite simple. If *v* is the
    axis around which to rotate, and ![How it works…](img/00290.jpeg) is the magnitude
    of the angle of rotation, then we get the following equations for the components
    of a quaternion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00291.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, for example, rotation about ![How it works…](img/00292.jpeg) by an angle
    of ![How it works…](img/00293.jpeg) will have the following quaternion components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Three of the four components of the quaternion (*x*, *y*, and *z*) define the
    axis around which to rotate (scaled by the sine of half the angle of rotation),
    while the fourth component (*w*) has only the cosine of half the angle to rotate
    with.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quaternions, being themselves vectors, can be rotated. Simply extract the (*x*,
    *y*, *z*) components of the quaternion, normalize, and then rotate that vector.
    Construct a new quaternion from that new unit vector with the desired angle of
    rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplying quaternions together represents a series of rotations that happen
    subsequently. For example, rotation of 45º about the *X* axis, followed by a rotation
    of 45º about the *Y* axis will be composed by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Core/Math API – Rotation using FRotationMatrix to have one object face another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`FRotationMatrix` offers matrix construction using a series of `::Make*` routines.
    They are easy to use and useful to get one object to face another. Say you have
    two objects, one of which is following the other. We want the rotation of the
    follower to always be facing what it is following. The construction methods of
    `FRotationMatrix` make this easy to do.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have two actors in a scene, one of which should face the other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the follower's `Tick()` method, look into the available constructors under
    the `FRotationMatrix` class. Available are a bunch of constructors that will let
    you specify a rotation for an object (from stock position) by reorienting one
    or more of the *X*, *Y*, *Z* axes, named with the `FRotationMatrix::Make*()` pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming you have a default stock orientation for your actor (with Forward
    facing down the *+X* axis, and up facing up the *+Z* axis), find the vector from
    the follower to the object he is following, as shown in this piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting one object to look at another, with a desired up vector, can be done
    by calling the correct function, depending on your object''s stock orientation.
    Usually, you want to reorient the *X* axis (Forward), while specifying either
    the *Y* axis (Right) or *Z* axis (Up) vectors (`FRotationMatrix::MakeFromXY()`).
    For example, to make an actor look along a `lookAlong` vector, with its right
    side facing right, we''d construct and set `FRotationMatrix` for it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Landscape API – Landscape generation with Perlin noise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use `ALandscape` in your scene, you may want to program the heights on
    it using code instead of manually brushing it in. To access the `ALandscape` object
    and its functions inside of your code, you must compile and link in the `Landscape`
    and `LandscapeEditor` APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Landscape API – Landscape generation with Perlin noise](img/00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating a landscape is not terribly challenging. You need to link in both
    the `Landscape` and `LandscapeEditor` APIs, and also have a programmatic way to
    set the height values across the map. In this recipe, we'll show how to use the
    Perlin noise for this.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, you may have seen Perlin noise used for coloration, but that is
    not all it is good for. It is excellent for terrain heights as well. You can sum
    multiple Perlin noise values to get beautiful fractal noise. It is worth a brief
    study of Perlin noise to understand how to get good outputs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Retrieve the Perlin noise module from [http://webstaff.itn.liu.se/~stegu/aqsis/aqsis-newnoise/](http://webstaff.itn.liu.se/~stegu/aqsis/aqsis-newnoise/).
    The two files you'll need are `noise1234.h` and `noise1234.cpp` (or you can select
    another pair of noise generation files from this repository if you wish). Link
    these files into your project and be sure to `#include YourPrecompiledHeader.h`
    into `noise1234.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link in the `Landscape` and `LandscapeEditor` APIs in your `Project.Build.cs`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct an interface using UMG that allows you to click a **Generate** button
    to call a C++ function that will ultimately populate the current Landscape with
    Perlin noise values. You can do this as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on your **Content Browser** and select **User Interface** | **Widget
    Blueprint**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populate **Widget Blueprint** with a single button that kicks off a single `Gen()`
    function. The `Gen()` function can be attached to your `Chapter12GameMode` derived
    class object as that is easy to retrieve from the engine. The `Gen()` function
    must be `BlueprintCallable UFUNCTION()`. (See the *Creating a UFUNCTION* section
    in [Chapter 2](part0032_split_000.html#UGI01-c0ca69a0411046888a488e5085138121
    "Chapter 2. Creating Classes"), *Creating Classes*, for details on how to do so.)![How
    to do it…](img/00296.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to display your UI by creating it and adding it to the viewport in one
    of your booting Blueprints; for example, in your HUD's `BeginPlay` event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it…](img/00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a Landscape using the UE4 Editor. The landscape will be assumed to stay
    on screen. We will only modify its values using code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside your map generation routine, modify your `ALandscape` object using code
    that does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `Landscape` object in the level by searching through all objects in
    the `Level`. We do this using a C++ function that returns `TArray` of all `Landscape`
    instances in the level:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the world''s `ULandscapeInfo` objects for `ALandscape` editing using
    the very important line, which is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding line of code is extremely important. Without it, the `ULandscapeInfo`
    objects will not be initialized and your code will not work. Surprisingly, this
    is a static member function of the `ULandscapeInfo` class, and so it initializes
    all `ULandscapeInfo` objects within the level.
  prefs: []
  type: TYPE_NORMAL
- en: Get extents of your `ALandscape` object so that we can compute the number of
    height values we will need to generate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a set of height values to replace original values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls `LandscapeEditorUtils::SetHeightmapData( landscape, data );` to park new
    landscape height values into your `ALandscape` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The initial values of `heightmap` will all be `32768` (`SHRT_MAX` (or `USHRT_MAX/2+1`))
    when the map is completely flat. This is because the map uses unsigned shorts
    (`uint16`) for its values, making it incapable of taking on negative values. For
    the map to dip below `z=0`, the programmers made the default value half of the
    maximum value of `heightmap`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Perlin noise function is used to generate a height value for (*x*, *y*)
    coordinate pairs. The 2D version of Perlin noise is used so that we can get a
    Perlin noise value based on 2-space spatial coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can play with the Perlin noise functions with the spatial coordinates of
    the map, and assign the heights of the maps to different combinations of the Perlin
    noise function. You will want to use a sum of multiple octaves of the Perlin noise
    function to get more detail into the landscape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PerlinNoise2D` generation function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `PerlinNoise2D` function accounts for the fact that the mid-level value
    of the function (sea level or flat land) should have a value of `SHRT_MAX` (`32768`).
  prefs: []
  type: TYPE_NORMAL
- en: Foliage API – Adding trees procedurally to your level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Foliage** API is a great way to populate your level with trees using code.
    If you do it this way, then you can get some good results without having to manually
    produce a natural looking randomness by hand.
  prefs: []
  type: TYPE_NORMAL
- en: We will correlate the placement of foliage with the Perlin noise value so that
    the chance to place a tree at a given location is higher when the Perlin noise
    values are higher.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using the code interface to the Foliage API, you should try the in-editor
    feature to familiarize yourself with the feature. After that, we will discuss
    using the code interface to place the foliage in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Important! Keep in mind that the material for a `FoliageType` object must have
    the **Used with Instanced Static Meshes** checkbox checked in its panel. If you
    do not do so, then the material cannot be used to shade a foliage material.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Be sure to check the **Used with Instanced Static Meshes** checkbox for your
    materials that you use on your `FoliageType`, otherwise your Foliage will appear
    gray.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the **Modes** panel, select the picture of a small growing plant with leaves
    ![Manually](img/00299.jpeg).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **+ Add Foliage Type** drop-down menu and select to construct a
    new `Foliage` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the `Foliage` object by whatever name you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click to edit your new `Foliage` object. Select Mesh from your project,
    preferably a tree-shaped object, to paint foliage into the landscape with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust Paint Brush Size and Paint Density to your liking. Left click to start
    painting in foliage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Shift* + click to erase foliage that you''ve put down. The Erase density value
    tells you how much foliage to leave behind when erasing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Procedurally
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you would like the engine to distribute the foliage in the level for you,
    you have a few steps to cover before being able to do so from within the editor.
    These steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Content Browser** and right-click to create a few `FoliageType`
    objects to distribute procedurally in the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Edit** | **Editor Preferences**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Experimental** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the **Procedural Foliage** checkbox. This allows you access to the **Procedural
    Foliage** classes from within the Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to **Content Browser**, right-click and create **Miscellaneous** | **Procedural
    Foliage Spawner**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click to open your **Procedural Foliage Spawner** and select-in the `FoliageTypes`
    that you created in step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag your **Procedural Foliage Spawner** onto the level and size it such that
    it contains the area where you want your procedural foliage laid out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Brushes menu, drag on a few Procedural Foliage Blocker volumes. Place
    a few of these inside the **Procedural Foliage Spawner** volume to block foliage
    from appearing in these areas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the menus downwards and click **SIMULATE**. The **Procedural Foliage Spawner**
    should fill with foliage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with the settings to get the foliage distributions that you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding recipe generates foliage prior to gameplay start. If you're interested
    in procedural foliage spawning at runtime, see the next recipe, *Landscape and
    Foliage API – Map generation using Landscape and Foliage APIs*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape and Foliage API – Map generation using Landscape and Foliage APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the earlier mentioned landscape generation code to create a landscape,
    and the procedural foliage functionality to randomly distribute some foliage on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Combining the capabilities of the Landscape API and Foliage API will allow you
    to procedurally generate complete maps. In this recipe, we will outline how this
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: We will programmatically create a landscape and populate it with foliage using
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Landscape and Foliage API – Map generation using Landscape and Foliage APIs](img/00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare to perform this recipe, we will need a UE4 project with a `Generate`
    button to kick off generation. You can see the *Landscape API – Landscape generation
    with Perlin noise* recipe for an example of how to do this. You simply need to
    create a small UMG UI widget that has a `Generate` button. Connect the `OnClick`
    event of your `Generate` button to a C++ `UFUNCTION()` inside any C++ global object,
    such as your `Chapter12GameMode` object, that will be used to generate your terrain.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enter a loop that attempts to place *N* trees, where *N* is the number of trees
    to place randomly, which is specified in the `UPROPERTY()` of the `Chapter12GameMode`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get random XY coordinates from within a 2D box bounding the landscape object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the Perlin noise value `@ (x, y)`. You may use a different Perlin noise
    formulation than the one used to determine landscape heights for foliage placement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a random number. If the number generated is within the range of units
    of the Perlin noise function there, then place a tree using the `SpawnFoliageInstance`
    function. Otherwise, do not place a tree there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should note that we are covering randomness in location using the underlying
    randomness in the spot we choose to test for tree placement. The actual chance
    to place a tree there depends on the Perlin noise value there, and whether it
    is within the range of units of `PerlinTreeValue`.
  prefs: []
  type: TYPE_NORMAL
- en: Very dense tree distributions will look like isocontours on the map then. The
    width of the isocontours is the range of units.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perlin noise works by generating smooth noise. For each location in an interval,
    (say *[-1, 1]*), there is a smoothly varying Perlin noise value.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Perlin noise values are sampled on a 2D texture. At each pixel (and even in
    between), we can get a very smoothly varying noise value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding octaves (or integer multiples) to some variable that travels in distance
    across the Perlin noise function allows us to get jaggy-looking effects; for example,
    the tufts in clouds or crags in mountains are gotten by wider-spaced samples,
    which give faster varying noise.
  prefs: []
  type: TYPE_NORMAL
- en: To get cool-looking Perlin noise outputs, we will simply apply math functions
    to sampled Perlin noise values; for example, the sin and cos functions can generate
    some cool looking marble effects for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perlin noise becomes periodic, that is, tileable, with the Perlin noise functions
    provided by the earlier linked implementation in this recipe. By default, Perlin
    noise is not periodic. If you need your Perlin noise to be periodic, be careful
    which library function you are calling.
  prefs: []
  type: TYPE_NORMAL
- en: The base Perlin noise function is a deterministic function that returns the
    same value every time you call it with the same value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may also set up sliders inside your `Chapter12GameMode` object derivative
    to affect the foliage and landscape generation, including parameters such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Amplitude of the landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Density of the foliage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isocontour level for foliage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variance in foliage height or scale
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – Triggering an actor's gameplay abilities with game controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **GameplayAbilities** API can be used to attach C++ functions to invoke
    on certain button pushes, triggering the game unit to exhibit its abilities during
    play in response to keystroke events. In this recipe, we will show you how to
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerate and describe your game character's abilities. You will need to know
    what your character does in response to key events to code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several objects that we need to use here; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UGameplayAbility` class—this is needed to derivate the C++ class instances
    of the `UGameplayAbility` class, one derivative class for each ability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define what each ability does in `.h` and `.cpp` by overriding available functions,
    such as `UGameplayAbility::ActivateAbility`, `UGameplayAbility::InputPressed`,
    `UGameplayAbility::CheckCost`, `UGameplayAbility::ApplyCost`, `UGameplayAbility::ApplyCooldown`,
    and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GameplayAbilitiesSet`—this is a `DataAsset` derivative object that contains
    a series of enum''d command values, and blueprints of the corresponding `UGameplayAbility`
    derivative classes that define the behavior for that particular input command.
    Each GameplayAbility is kicked off by a keystroke or mouse click, which is set
    in `DefaultInput.ini`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following, we'll implement a `UGameplayAbility` derivative called `UGameplayAbility_Attack`
    for a `Warrior` class object. We'll attach this gameplay functionality to input
    command string `Ability1`, which we'll activate on the left-mouse button click.
  prefs: []
  type: TYPE_NORMAL
- en: Link the `GameplayAbilities` API in your `ProjectName.Build.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Derive a C++ class from `UGameplayAbility`. For example, write a C++ `UCLASS
    UGameplayAbility_Attack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the very least, you want to override the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UGameplayAbility_Attack::CanActivateAbility` member function to indicate
    when the actor is allowed to invoke the ability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UGameplayAbility_Attack::CheckCost` function to indicate whether the player
    can afford to use ability or not. This is extremely important, because if this
    returns false, ability invocation should fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UGameplayAbility_Attack::ActivateAbility` member function and write the
    code that the `Warrior` is to execute when his `Attack` ability is activated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `UGameplayAbility_Attack::InputPressed` member function and to respond to
    the key input event assigned to the ability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derive a Blueprint class from your `UGameplayAbility_Attack` object inside the
    UE4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the editor, navigate to **Content Browser** and create a `GameplayAbilitiesSet`
    object by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right clicking on **Content Browser** and selecting **Miscellaneous** | **Data
    Asset**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the dialog box that follows, select `GameplayAbilitySet` for Data Asset Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In fact, the `GameplayAbilitySet` object is a `UDataAsset` derivative. It is
    located in `GameplayAbilitySet.h` and contains a single member function, `GameplayAbilitySet::GiveAbilities()`,
    which I strongly recommend you not to use for reasons listed in a later step.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Name your `GameplayAbilitySet` data asset something related to the `Warrior`
    object so we know to select it into the `Warrior` class (for example, `WarriorGameplayAbilitySet`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click to open and edit the new `WarriorAbilitySet` Data Asset. Stack
    in a list of `GameplayAbility` class derivative Blueprints by clicking **+** on
    the `TArray` object inside of it. Your `UGameplayAbility_Attack` object must appear
    in the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UPROPERTY UGameplayAbilitySet* gameplayAbilitySet` member to your `Warrior`
    class. Compile, run, and select-in `WarriorAbilitySet` as it sits in **Content
    Browser** (created in steps 5 to 7) of the abilities that this `Warrior` is capable
    of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that your `Actor` class derivative also derives from the `UAbilitySystemInterface`
    interface. This is extremely important so that calls to `(Cast<IAbilitySystemInterface>(yourActor))->GetAbilitySystemComponent()`
    succeed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometime after the construction of your actor, call `gameplayAbilitySet->GiveAbilities(
    abilitySystemComponent );` or enter a loop, as shown in the following step where
    you invoke `abilitySystemComponent->GiveAbility()` for each ability listed in
    your `gameplayAbilitySet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an override for `AWarrior::SetupPlayerInputComponent( UInputComponent*
    Input )` to connect the input controller to the Warrior's GameplayAbility activations.
    After doing so, iterate over each GameplayAbility listed in your GameplayAbilitySet's
    **Abilities** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use the `GameplayAbilitySet::GiveAbilities()` member function because
    it doesn't give you access to the set of `FGameplayAbilitySpecHandle` objects
    that you actually need to later bind and invoke the ability to an input component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You must subclass and link in a set of `UGameplayAbility` objects to your actor's
    `UAbilitySystemComponent` object through a series of calls to `UAbilitySystemComponent::GiveAbility(
    spec )` with appropriately constructed `FGameplayAbilitySpec` objects. What this
    does is it decks out your actor with this bunch of `GameplayAbilities`. The functionality
    of each `UGameplayAbility`, its cost, cooldown, and activation is all neatly contained
    within the `UGameplayAbility` class derivative that you will construct.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ll want to carefully code in a bunch of the other functions that are available
    in the `GameplayAbility.h` header file, including implementations for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SendGameplayEvent`: This is a function to notify GameplayAbility that some
    general gameplay event has happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CancelAbility`: This is a function to stop an ability''s usage midway through,
    and giving the ability an interrupted state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that there are a bunch of existing `UPROPERTY` near the bottom
    of the `UGameplayAbility` class declaration that either activate or cancel the
    ability upon addition or removal of certain `GameplayTags`. See the following
    *GameplayTags API – Attaching GameplayTags to an actor* recipe for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bunch more! Explore the API and implement those functions you find to be useful
    in your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GameplayAbilities` API is a rich and nicely interwoven series of objects
    and functions. Really explore `GameplayEffects`, `GameplayTags` and `GameplayTasks`
    and how they integrate with the `UGameplayAbility` class to fully explore the
    functionality the library has to offer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GameplayAbilities API – Implementing stats with UAttributeSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `GameplayAbilities` API allows you to associate a set of attributes, that
    is, `UAttributeSet`, to an Actor. `UAttributeSet` describes properties appropriate
    for that Actor's in-game attributes, such as `Hp`, `Mana`, `Speed`, `Armor`, `AttackDamage`,
    and so on. You can either define a single game-wide set of attributes common to
    all Actors, or several different sets of attributes appropriate for the different
    classes of actors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AbilitySystemComponent` is the first thing you will need to add to your actors
    to equip them to use *GameAbilities API* and `UAttributeSet`s. To define your
    custom `UAttributeSet`, you will simply derive from the `UAttributeSet` base class
    and extend the base class with your own series of `UPROPERTY` members. After that,
    you must register your custom `AttributeSet` with your `Actor` class'' `AbilitySystemComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Link to the `GameplayAbilities` API in your `ProjectName.Build.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In its own file, derive from the `UAttributeSet` class and deck the class out
    with a set of `UPROPERTY` that you want each Actor to have in their property set.
    For example, you might want to declare your `UAttributeSet` derivate class similar
    to the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your code is networked, you might want to enable replication on each of the
    `UPROPERTY` with the replicated declaration in the `UPROPERTY` macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect `GameUnitAttributeSet` with your `AbilitySystemComponent` inside your
    `Actor` class by calling the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can put this call somewhere in `PostInitializeComponents()`, or in code
    that is called later than that.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have registered `UAttributeSet`, you can move on with the next recipe
    and apply `GameplayEffect` to some of the elements in the attribute set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be sure your `Actor` class object implements `IAbilitySystemInterface` by deriving
    from it. This is extremely important as the `UAbilitySet` object will attempt
    a cast to `IAbilitySystemInterface` to call `GetAbilitySystemComponent()` on it
    at various places in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UAttributeSets` simply allow you to enumerate and define attributes of different
    actors. `GameplayEffects` will be your means to make changes to the attributes
    of a specific actor.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can code in definitions of `GameplayEffects`, which will be things that
    act on the AbilitySystemComponent's `AttributeSet` collections. You can also write
    `GameplayTasks` for generic functions that run at specific time or events, or
    even in response to tag addition (`GameplayTagResponseTable.cpp`). You can define
    `GameplayTags` to modify GameplayAbility behavior as well as select and match
    gameplay units during play.
  prefs: []
  type: TYPE_NORMAL
- en: GameplayAbilities API – Implementing buffs with GameplayEffect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A buff is just an effect that introduces a temporary, permanent, or recurring
    change to a game unit's attributes from its `AttributeSet`. Buffs can either be
    good or bad, supplying either bonuses or penalties. For example, you might have
    a hex buff that slows a unit to half speed, an angel wing buff that increases
    unit speed by 2x, or a cherub buff that recovers `5 hp` every five seconds for
    three minutes. A `GameplayEffect` affects an individual gameplay attributes in
    the `UAttributeSet` attached to an `AbilitySystemComponent` of an Actor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Brainstorm your game units' effects that happen during the game. Be sure that
    you've created an `AttributeSet`, shown in the previous recipe, with gameplay
    attributes that you'd like to affect. Select an effect to implement and follow
    the succeeding steps with your example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may want to turn `LogAbilitySystem` to a `VeryVerbose` setting by going
    to the **Output Log** and typing [PRE26]
  prefs: []
  type: TYPE_NORMAL
- en: // Create GameplayEffect recovering 50 hp one time only to unit
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRUCT_CLASS( UGameplayEffect, RecoverHP );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: AddModifier( RecoverHP,
  prefs: []
  type: TYPE_NORMAL
- en: GET_FIELD_CHECKED( UGameUnitAttributeSet, Hp ),
  prefs: []
  type: TYPE_NORMAL
- en: EGameplayModOp::Additive, FScalableFloat( 50.f ) );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: RecoverHP->DurationPolicy = EGameplayEffectDurationType::HasDuration;
  prefs: []
  type: TYPE_NORMAL
- en: RecoverHP->DurationMagnitude = FScalableFloat( 10.f );
  prefs: []
  type: TYPE_NORMAL
- en: RecoverHP->ChanceToApplyToTarget = 1.f;
  prefs: []
  type: TYPE_NORMAL
- en: RecoverHP->Period = .5f;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: FActiveGameplayEffectHandle recoverHpEffectHandle =
  prefs: []
  type: TYPE_NORMAL
- en: AbilitySystemComponent->ApplyGameplayEffectToTarget( RecoverHP,
  prefs: []
  type: TYPE_NORMAL
- en: AbilitySystemComponent, 1.f );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: FActiveGameplayEffectHandle recoverHpEffectHandle =
  prefs: []
  type: TYPE_NORMAL
- en: AbilitySystemComponent->ApplyGameplayEffectToTarget( RecoverHP,
  prefs: []
  type: TYPE_NORMAL
- en: AbilitySystemComponent, 1.f );
  prefs: []
  type: TYPE_NORMAL
- en: if( recoverHpEffectHandle ) {
  prefs: []
  type: TYPE_NORMAL
- en: recoverHpEffectHandle->AddLambda( []() {
  prefs: []
  type: TYPE_NORMAL
- en: Info( "RecoverHp Effect has been removed." );
  prefs: []
  type: TYPE_NORMAL
- en: '} );'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: UPROPERTY( EditAnywhere, BlueprintReadWrite, Category = GameplayTags )
  prefs: []
  type: TYPE_NORMAL
- en: TArray<FString> GameplayTagTableNames;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: IGameplayTagsModule::Get().GetGameplayTagsManager().
  prefs: []
  type: TYPE_NORMAL
- en: LoadGameplayTagTable( GameplayTagTableNames );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: // Like a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: UGameplayTask_CreateParticles* UGameplayTask_CreateParticles::ConstructTask(
  prefs: []
  type: TYPE_NORMAL
- en: TScriptInterface<IGameplayTaskOwnerInterface> TaskOwner,
  prefs: []
  type: TYPE_NORMAL
- en: UParticleSystem* particleSystem,
  prefs: []
  type: TYPE_NORMAL
- en: FVector location )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: UGameplayTask_CreateParticles* task =
  prefs: []
  type: TYPE_NORMAL
- en: NewTask<UGameplayTask_CreateParticles>( TaskOwner );
  prefs: []
  type: TYPE_NORMAL
- en: // Fill fields
  prefs: []
  type: TYPE_NORMAL
- en: if( task )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: task->ParticleSystem = particleSystem;
  prefs: []
  type: TYPE_NORMAL
- en: task->Location = location;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return task;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: void UGameplayTask_CreateEmitter::Activate()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Super::Activate();
  prefs: []
  type: TYPE_NORMAL
- en: UGameplayStatics::SpawnEmitterAtLocation( GetWorld(),
  prefs: []
  type: TYPE_NORMAL
- en: ParticleSystem->GetDefaultObject<UParticleSystem>(),
  prefs: []
  type: TYPE_NORMAL
- en: Location );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: UGameplayTask_CreateParticles* task =
  prefs: []
  type: TYPE_NORMAL
- en: UGameplayTask_CreateParticles::ConstructTask( this,
  prefs: []
  type: TYPE_NORMAL
- en: particleSystem, FVector( 0.f, 0.f, 200.f ) );
  prefs: []
  type: TYPE_NORMAL
- en: if( GameplayTasksComponent )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: GameplayTasksComponent->AddTaskReadyForActivation( *task );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '#include "Runtime/Online/HTTP/Public/HttpManager.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "Runtime/Online/HTTP/Public/HttpModule.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "Runtime/Online/HTTP/Public/HttpRetrySystem.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: TSharedRef<IHttpRequest> http=FHttpModule::Get().CreateRequest();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: void HttpRequestComplete( FHttpRequestPtr request,
  prefs: []
  type: TYPE_NORMAL
- en: FHttpResponsePtr response, bool success );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: FHttpRequestCompleteDelegate& delegate = http->OnProcessRequestComplete();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: delegate.BindLambda(
  prefs: []
  type: TYPE_NORMAL
- en: // Anonymous, inlined code function (aka lambda)
  prefs: []
  type: TYPE_NORMAL
- en: '[]( FHttpRequestPtr request, FHttpResponsePtr response, bool success ) -> void'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'UE_LOG( LogTemp, Warning, TEXT( "Http Response: %d, %s" ),'
  prefs: []
  type: TYPE_NORMAL
- en: request->GetResponse()->GetResponseCode(),
  prefs: []
  type: TYPE_NORMAL
- en: '*request->GetResponse()->GetContentAsString() );'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: delegate.BindUObject( this, &AChapter12GameMode::HttpRequestComplete );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: PlainObject* plainObject = new PlainObject();
  prefs: []
  type: TYPE_NORMAL
- en: delegate.BindRaw( plainObject, &PlainObject::httpHandler );
  prefs: []
  type: TYPE_NORMAL
- en: // plainObject cannot be DELETED Until httpHandler gets called..
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '// C-style function for handling the HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: void httpHandler( FHttpRequestPtr request,
  prefs: []
  type: TYPE_NORMAL
- en: FHttpResponsePtr response, bool success )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Info( "static: Http req handled" );'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: delegate.BindStatic( &httpHandler );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: http->SetURL( TEXT( "http://unrealengine.com" ) );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: http->ProcessRequest();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: HandleRequestProgress( FHttpRequestPtr request, int32 sentBytes, int32 receivedBytes
    )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: TSharedRef<IHttpRequest> http = HttpModule::Get().CreateRequest();
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: http->OnRequestProgress().BindLambda( []( FHttpRequestPtr request, int32 sentBytes,
    int32 receivedBytes ) -> void
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: int32 totalLen = request->GetResponse()->GetContentLength();
  prefs: []
  type: TYPE_NORMAL
- en: float perc = (float)receivedBytes/totalLen;
  prefs: []
  type: TYPE_NORMAL
- en: if( HttpProgressBar )
  prefs: []
  type: TYPE_NORMAL
- en: HttpProgressBar->SetPercent( perc );
  prefs: []
  type: TYPE_NORMAL
- en: '} );'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Process your request with `http->ProcessRequest()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `OnRequestProgress()` callback gets fired every so often with the bytes
    sent and bytes received HTTP progress. We will compute the total percent of the
    download that is complete by calculating `(float)receivedBytes/totalLen`, where
    `totalLen` is the HTTP response's total length in bytes. Using the lambda function
    we attached to the `OnRequestProgress()` delegate callback, we can call the UMG
    widget's `.SetPercent()` member function to reflect the download's progress.
  prefs: []
  type: TYPE_NORMAL
