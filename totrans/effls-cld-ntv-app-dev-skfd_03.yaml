- en: '[*Chapter 2*](B17385_02_Final_PD_ePub.xhtml#_idTextAnchor026): Developing Cloud-Native
    Applications with Kubernetes – A Developer''s Nightmare'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the hardships that a developer faces while
    developing a container-native application. We also covered the new steps that
    were introduced to the development life cycle. We may have simplified things to
    explain the concepts, but we will look into each step in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover the problems that developers face while developing cloud-native
    applications with Kubernetes. We will cover how and why the overall development
    experience with Kubernetes is painful. We will also see why developers are not
    Kubernetes experts and that they are looking for simplified workflows while developing
    an application with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Poor developer experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers want simplified workflows with Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers are not Kubernetes experts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the common challenges developers
    face while developing cloud-native applications with Kubernetes. Later, in the
    next chapter, we will learn how to overcome these challenges by using Skaffold
    for your development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, you need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse ([https://www.eclipse.org/downloads/](https://www.eclipse.org/downloads/))
    or IntelliJ IDE ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git ([https://git-scm.com/downloads](https://git-scm.com/downloads))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.5 ([https://start.spring.io](https://start.spring.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: minikube ([https://minikube.sigs.k8s.io/docs/](https://minikube.sigs.k8s.io/docs/))
    or Docker Desktop for macOS and Windows ([https://www.docker.com/products/dockerdesktop](https://www.docker.com/products/dockerdesktop))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 16 ([https://jdk.java.net/16/](https://jdk.java.net/16/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the code examples for this chapter from the GitHub repository
    at [https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter02](https://github.com/PacktPublishing/Effortless-Cloud-Native-App-Development-Using-Skaffold/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Poor developer experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern developers are looking for tools and technologies that give them an edge
    to deliver the software that meets the customers' expectations and keeps their
    organization competitive in today's fast-moving world. Enter Kubernetes! **Kubernetes**
    was open sourced in 2014, and since its inception, it has become the container
    orchestration platform of choice for numerous enterprises around the world. Kubernetes
    has dramatically simplified the jobs of operations folks, but we definitely cannot
    say the same thing about developers who are building and deploying applications
    to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered this in detail in this chapter. According to a recent study,
    around 59 percent of enterprise organizations are running their production workload
    with Kubernetes. This is excellent for a technology that is just 5 years old.
    The main reason enterprises are adopting Kubernetes is to increase agility, expedite
    software delivery, and support digital transformation.
  prefs: []
  type: TYPE_NORMAL
- en: Before going through the pain points of working with Kubernetes, let's take
    a real-world example to understand how Kubernetes can help organizations in their
    digital transformation journey. Let's take an example of an e-commerce website.
    On most days, the website does its job. The website takes advantage of microservices
    architecture and has multiple services that work in tandem to deliver a better
    user experience. However, due to an upcoming holiday, the IT team expects a surge
    in the usage of their website, and the team is worried that it may lead to an
    outage, as the underlying microservices may not be able to handle the load. But
    with Kubernetes, it is easy to scale out without much hassle. For example, you
    can use Kubernetes' autoscaling capabilities with its **horizontal Pod** **auto-scaler**
    (**HPA**). HPA automatically scales the number of Pods based on observed CPU utilization.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, containers and Kubernetes certainly have changed the way we package,
    deploy, and run cloud-native applications at scale. After containerization, you
    can run your application anywhere, that is, on VMs, on physical machines, or the
    cloud. And with container orchestration tools such as Kubernetes, you can scale,
    deploy, and manage cloud-native applications more efficiently. It has reduced
    the downtime in production and made the job of the operations team much more comfortable.
    However, developer experience and practices have not evolved much since the inception
    of Kubernetes as compared to traditional applications. Let's understand cloud-native
    application development flow with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the cloud-native application development workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the same *Hello-World Spring Boot Web MVC* application we created
    in [*Chapter 1*](B17385_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Code, Build,
    Test, and Repeat – The Application Development Inner Loop*; however, we will containerize
    it and deploy it to Kubernetes this time. The idea is to go through the hardships
    that a developer goes through while developing cloud-native Spring Boot applications.
    Here are the steps we''ll be following:'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using **Docker Desktop** for macOS and Windows as it comes with Kubernetes
    support, and we will not have to download **minikube** separately for this example.
    However, if macOS is not something you work with, then you can install minikube
    ([https://v1-18.docs.kubernetes.io/docs/tasks/tools/install-minikube/#installing-minikube](https://v1-18.docs.kubernetes.io/docs/tasks/tools/install-minikube/#installing-minikube))
    for other OSes as well. Follow the steps to enable Kubernetes support with Docker
    Desktop for macOS and Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Preferences** in the Docker menu bar. Then, on the **Kubernetes**
    tab, click on the **Enable Kubernetes** checkbox to start a single-node functional
    Kubernetes cluster. It will take some time to start the cluster. It is not mandatory,
    but you can also enable Kubernetes to be the default orchestrator for the `docker
    stack` command.![Figure 2.1 – Enabling Kubernetes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_2.1_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Enabling Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: After it is enabled, you will see the following screen on your Docker Desktop
    menu bar. This confirms that the Kubernetes cluster is up and running:![Figure
    2.2 – Verifying the setup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_2.2_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Verifying the setup
  prefs: []
  type: TYPE_NORMAL
- en: Next, make sure that the Kubernetes context is set to `docker-desktop` if you
    have multiple clusters or environments running locally:![Figure 2.3 – Context
    set to docker-desktop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_2.3_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Context set to docker-desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, Docker Desktop comes with **kubectl** support; you don''t have
    to download it separately. kubectl is a command-line tool for Kubernetes, and
    you can use it to run commands against your cluster. On macOS, it''s generally
    available at path, `/usr/local/bin/kubectl`. For Windows, it is available at `C:\>Program
    Files\Docker\Docker\Resources\bin\kubectl.exe`. You may want to add it to your
    `PATH` variable. Let''s verify the setup with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the Dockerfile we have used for this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a very basic Dockerfile here. Let me just explain the instructions
    in brief:'
  prefs: []
  type: TYPE_NORMAL
- en: a. The `FROM` instruction specifies the base image for our Spring Boot application,
    which is OpenJDK 16.
  prefs: []
  type: TYPE_NORMAL
- en: b. `COPY` is used to move files or directories from the host system to the filesystem
    inside the container. Here, we have copied the `.jar` files from the target directory
    to the root path inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: c. `ENTRYPOINT` works as a runtime executable for the container, which will
    start our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the Dockerfile, next we need to create an executable `.jar`
    file. We will use the `mvn clean install` command to create an executable `.jar`
    file for our application. Let''s run the `docker build` command to create a container
    image. Here, we have set the name of our image as `helloworld`. The output of
    the `docker build` command will be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created an image for the application. Now we are ready to push the
    image to the DockerHub container registry with the `docker push` command, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part of this exercise is to create Kubernetes resources (Deployments
    and Services) to get our application up and running on Kubernetes. The declarative
    YAML file for both services and deployment is inside the `K8s` directory of the
    source code. Let''s create the Deployment resource first, which is responsible
    for creating and running a set of Pods dynamically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me clarify few things regarding the YAML file we have used to create the
    Kubernetes Deployment object:'
  prefs: []
  type: TYPE_NORMAL
- en: a. `metadata.name` specifies the name of the Deployment object to be created.
  prefs: []
  type: TYPE_NORMAL
- en: b. The `spec.replicas` field indicates that the Kubernetes Deployment object
    will create a single replica.
  prefs: []
  type: TYPE_NORMAL
- en: c. The `template.spec` field indicates that the Pod will run a single container
    named `helloworld` that runs the DockerHub image of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `kubectl` command for creating the Deployment object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Services provide a single DNS name for a set of Pods and handle load balancing
    among them. Let''s create the Service resource so that the application can be
    accessed from outside the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s talk about the YAML file we have used to create the Kubernetes Service
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: a. `metadata.name` specifies the name of the Service object to be created.
  prefs: []
  type: TYPE_NORMAL
- en: b. `spec.selectors` allows Kubernetes to group Pods with the name `helloworld`
    and forward the request to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'c. `type: Nodeport` creates a static IP for each node so that we can access
    the Service from outside.'
  prefs: []
  type: TYPE_NORMAL
- en: d. `targetPort` is the container port.
  prefs: []
  type: TYPE_NORMAL
- en: e. `port` is the port exposed internally in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `kubectl` command for creating the Service object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's now verify whether we have a Pod running:![Figure 2.4 – Pod running
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/Figure_2.4_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – Pod running
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we now have our application up and running on Kubernetes. Let''s
    verify this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – REST endpoint response'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.5_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – REST endpoint response
  prefs: []
  type: TYPE_NORMAL
- en: That's a lot of steps and too many keystrokes even if your change is small and
    you don't even know whether it will work or not. Now imagine having to do this
    every time you push a change! This workflow could be even more complicated if
    you have multiple microservices talking to each other. You have the option to
    not deploy to Kubernetes for your local development, but rely instead on your
    CI/CD process. Or maybe you are using something like `docker-compose` or testing
    in isolation with Docker. Just imagine having multiple microservices that you
    need to run this way.
  prefs: []
  type: TYPE_NORMAL
- en: To test everything, realistically, you need your development environment to
    mirror your deployment environment to test your microservices' dependencies. This
    is the downside of container-native development, as the developer spends less
    time coding and more time worrying about the configuration, setting up the environment,
    and waiting for the deployment to be completed. In one of the chapters, later
    in the book, we will cover how we can build and deploy multiple microservices
    with Skaffold.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the inherent complexity that comes with Kubernetes, developers are looking
    for simple workflows. Let's discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developers want simplified workflows with Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we discussed the steps that a developer goes through while
    developing traditional Spring Boot applications in the inner development loop.
    We also discussed how easy it is to automate the whole flow with tools such as
    *spring-dev-tools*. Once a developer is confident about the changes, they can
    save them, and changes are deployed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Developers developing cloud-native applications are looking for a similar workflow
    where they can save their changes. With some magic in the background, the application
    should be deployed to local or remote clusters of their choice. Moreover, a developer
    who has previously worked on traditional monolithic applications would expect
    a similar workflow when they switch to developing cloud-native applications. From
    a developer's perspective, the expectation is that additional steps for cloud-native
    application development should be suppressed with a single command or click.
  prefs: []
  type: TYPE_NORMAL
- en: 'A developer expects a simplified workflow with Kubernetes, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Ctrl + S workflow with Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.6_B17385.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Ctrl + S workflow with Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'To address these problems, enterprises need to provide developers with tools
    that can abstract general Kubernetes complexity. To be specific, developers are
    looking for a platform or tools that can fulfill the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Developers should be able to connect with Kubernetes without going through the
    bureaucracy of getting approval from support managers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers should not be wasting their time and energy configuring the environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers should be able to start quickly while working with Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers can quickly deploy the changes to the Kubernetes cluster with a single
    command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers should be debugging cloud-native applications during development,
    such as how they are used to debug traditional applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers should not be tied to a tool for building and deploying the image.
    The good news is that many enterprises have realized how painful the developer
    experience is with Kubernetes and are coming up with their solutions to improve
    it. Later in this book, we will cover a tool, Skaffold, that simplifies developers'
    inner development loops while working with cloud-native applications. Skaffold
    implements the *Ctrl* + *Save* workflow and automates the build and deploy process.
    Skaffold also gives the developer the freedom to pick a tool for the build (Docker/Jib/Buildpacks)
    and deployment (kubectl/Helm/kustomize).
  prefs: []
  type: TYPE_NORMAL
- en: It would be a good skill set to have, but do we really want developers to be
    Kubernetes experts? Let's discuss this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Developers are not Kubernetes experts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes was originally developed for operations folks and not for developers.
    There are many reasons why a developer would not be interested in knowing Kubernetes
    for their day jobs. One valid reason is that a developer is more interested in
    solving the business problem and adding features to the products they are developing,
    and they are not bothered about the target environment, that is, where they will
    deploy the application. And, let''s be honest, Kubernetes is complex, which makes
    it hard not only for the beginner but also for experienced folks. I saw this joke,
    probably on Twitter, on how hard it is to understand Kubernetes: "*One time I
    tried to explain Kubernetes to someone. Then we both didn''t understand it*."'
  prefs: []
  type: TYPE_NORMAL
- en: It requires a different level skill set than the everyday tasks of a developer.
    Because of its complexity, it usually takes a very long time for the average developer
    to master Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'More often than not, a developer working in an enterprise environment will
    be working on the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Being involved in design discussions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new features for the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working on improving the performance of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers just want to code rather than worry about how and where their applications
    will be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that we need to keep telling ourselves that Kubernetes is
    not an easy tool for developers. Moreover, developers are more interested in creating
    applications, working with tools that can handle the build, and deploying boilerplate
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered the hardships that a developer has to go through while
    developing cloud-native applications with Kubernetes. We started the chapter by
    describing the cloud-native application development workflow for an application
    deployed to Kubernetes. We covered the additional steps with some coding examples
    that a developer has to go through while developing cloud-native applications.
    Then we explained that developers are looking for a simplified workflow for easy
    development with Kubernetes. Later in the chapter, we showed that developers are
    not Kubernetes experts, and they should be equipped with tools such as Skaffold
    to improve their development experience with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the main goal was to give you a walk-through of developers'
    problems while developing container-native applications. After reading this, you
    should be able to relate to these issues, and at the same time, I have given you
    hints about how Skaffold can help solve these problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will quickly cover Skaffold with some coding examples
    to better understand these hints.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learn more about Docker and Kubernetes at [https://www.packtpub.com/product/kubernetes-and-docker-an-enterprise-guide/9781839213403](https://www.packtpub.com/product/kubernetes-and-docker-an-enterprise-guide/9781839213403).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More on going cloud-native with Kubernetes can be discovered at [https://www.packtpub.com/product/cloud-native-with-kubernetes/9781838823078](https://www.packtpub.com/product/cloud-native-with-kubernetes/9781838823078).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
