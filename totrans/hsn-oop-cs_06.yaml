- en: Events and Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Events and delegates may seem like complex programming topics, but actually,
    they are not. In this chapter, we will first learn about these concepts by analyzing
    the meaning of their respective names. Then we will relate the general meaning
    of these words to programming. We will look at a lot of example code in this chapter,
    which will help us understand the concepts with ease. Before we dive into this,
    let''s look at the topics that we are going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create and use delegates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method group conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covariance and contravariance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events and multicast events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET event guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a delegate?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **delegate** is a proxy, an alternative, or a representative of someone else.
    For example, we may read in the newspaper that a delegate from another country
    is coming to our country to meet a high official. This person is a delegate because
    they have come to our country to represent their own country. They could be a
    representative for the president, prime minister, or any other high official of
    that country. Let's imagine that the delegate is representing the president of
    a country. Maybe the president was unable to attend this meeting in person for
    some reason, and that is why a delegate was sent on their behalf. This delegate
    will do the same work that the president was supposed to do on the trip and make
    decisions on behalf of the president. The delegate is not a fixed individual;
    could be any qualified person that the president chooses.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a delegate is similar in software development. We can have a
    functionality where a method doesn't do the actual work that it was ask to do,
    but rather, it will call another method to execute that work. Furthermore, in
    programming, the method that doesn't do the actual work, but passes it to another
    method, is called a **delegate**. Consequently, a delegate will actually hold
    a reference of a method. When the delegate is called, the referenced method will
    actually be called and executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you may ask, *"Why should I call a delegate if it is going to call another
    method? Why don't I just call the method directly?"* Well, we do this because
    if you directly call the method, you lose your flexibility by making your code
    coupled. You are hard coding the method name in your code so that, whenever that
    line of code will run, that method will be executed. However, with a delegate,
    you can decide which method to call at runtime instead of compile time.
  prefs: []
  type: TYPE_NORMAL
- en: How to create and use delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a delegate, we need to use the `delegate` keyword. Let me show you
    how to declare a delegate in a general form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let me show you some real example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec78bb93-f19d-4cd4-9c4b-3234205bb9c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now discuss the preceding code. At the very top, inside the namespace,
    we can see the declaration of the delegate, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We used the `delegate` keyword to let the compiler know that we are declaring
    a `delegate`. Then we set the return type to `int` and named the delegate `MathFunc`.
    We also passed two `int` type parameters in this delegate.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the `program` class gets started, and in that class, we have two
    methods in addition to the main method. One is `add` and the other is `sub`. If
    you pay close attention to these methods, you will see that they have the same
    signature as the delegate. This is done deliberately, because a method can use
    a `delegate` when the method has the same signature as the `delegate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we look at the main method, we will find the following interesting
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this first line of the main method, we create an object of the delegate.
    While doing this, we pass the `add` method in the constructor. This is required,
    as you need to pass a method for which you want to use the delegate. Then we can
    see that, when we call the delegate `mf(4,5)`, it returns `9`. This means that
    it is actually calling the `add` method. After that, we assign `sub` to the `delegate`.
    Upon calling the `mf(4,5)`, this time we get `1`. This means that the `sub` method
    was called. In this way, a `delegate` can be used for many methods that have the
    same signature.
  prefs: []
  type: TYPE_NORMAL
- en: Method group conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last example, we saw how we can create an object of a delegate and pass
    the method name in the constructor. Now we will look at another way of achieving
    the same thing, but in an easier way. This is called **method group conversion**.
    Here, you don''t need to initialize the `delegate` object, but you can directly
    assign the method to it. Let me show you an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that instead of passing the method name in the constructor,
    we directly assign the method to it. This is a quick way of assigning a delegate
    in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Using the static and instance methods as delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, we used static methods in our delegates. However,
    you can also use instance methods in delegates. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see that we have instance methods under the `MyMath` class.
    To use those methods in delegates, we first have to create an object of that class
    and simply assign the methods to a delegate using the object instance.
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Multicasting** is an excellent feature of delegates. With multicasting, you
    can assign more than one method to a delegate. When that delegate is executed,
    it runs all the methods that were assigned one after another. Using the `+` or
    `+=` operator, you can add methods to a delegate. There is also a way to remove
    added methods from the delegate. To do this, you have to use the `-` or `-=` operator.
    Let''s look at an example to understand clearly what multicasting is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e13be43-8af9-4cc0-84fb-356853c3a9e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we can see how our delegate executed the two methods one after the other.
    We have to keep in mind that it works like a queue, so the first method you add
    will be the first method to get executed. Now let''s see how we can remove a method
    from a delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/375ab662-d4d2-4e43-98e7-77e000cf9870.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we have firstly added two methods to the delegate. Then, we removed the
    `sub3` method and added the `mul10` method. After making all these changes when
    we executed the delegate, we saw that `5` was added to the number, then `10` was
    multiplied by the number. No subtraction took place.
  prefs: []
  type: TYPE_NORMAL
- en: Covariance and contravariance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two important delegate features. What we have learned so far is that
    normally, to register a method in a delegate, the method has to match the signature
    of the delegate. This means that the return type and the parameters of the method
    and the delegate have to be the same. However, with the use of the concepts of
    covariance and contravariance, you can actually register methods to a delegate
    that don't have the same return types or parameters. The delegate will then be
    able to execute them when called.
  prefs: []
  type: TYPE_NORMAL
- en: '**Covariance** is when you assign a method to a delegate that has a return
    type that is a derived type of the delegate''s return type. For example, if class
    `B` is derived from class `A`, and if the delegate returns class `A`, then a method
    can be registered to the delegate that returns class `B`. Let''s look at the example
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a25f3142-a1f1-4a9a-b26d-b33aa0902724.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, **contravariance** is when a method is passed to a delegate
    and the parameters of the method don''t match the parameters of the delegate.
    Here, we have to keep in mind that the parameter type of the method has to be
    at least derived from the parameter type of the delegate. Let''s look at an example
    of contravariance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c0d2d79-d593-41b5-acac-a4a38caeab8e.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that the delegate takes type `B` as a parameter. However, when
    the `WorkA` method had been registered as a method in the delegate, it didn't
    give any error or warning, even though the parameter that `WorkA` method takes
    is type `A`. The reason why it works is because type `B` is derived from type
    `A`.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can think of an **event **as a kind of method that gets executed in some circumstances
    and notifies handlers or delegates about that incident. For example, when you
    sign up for an email newsletter, you get emails from the website about the latest
    articles, blog posts, or news that are posted. These emails could be daily, weekly,
    monthly, yearly, or according to some other specified period of time that you
    have chosen. These emails are not sent by a human being manually, but by an automatic
    system/software. This automatic email sender can be developed using events. Now,
    you might think, why do I need an event for this, can''t I send an email to the
    subscriber by a normal method? Yes, you can. However, suppose that in the near
    future, you also want to introduce a feature where you will be notified on the
    mobile app. You''d have to change the code and add the functionality for that.
    A few days after that, if you want to further extend your system and send an SMS
    to specific subscribers, you have to change the code again. Not only that, but
    the code you write to achieve this will be very strongly coupled if you write
    it using normal methods. You can solve these kinds of problem using `event`. You
    can also create different event handlers and assign those event handlers to an
    event so that, whenever that event gets fired, it will notify all the registered
    handlers that will perform their work. Let''s now look at an example to make this
    a little clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c7feacb-1170-499c-b38e-72151467b6f4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code, we can see that, when the `PublishResultNow()` method
    gets called, it basically fires the  `PublishResult` event. Furthermore, the `SendMail()` method that
    did subscribe to the event gets executed and prints `Results have been emailed
    successfully!` on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Multicasting events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can multicast in an event in the same way that you can in a delegate. This
    means that you can register multiple event handlers (methods that have subscribed
    to the event) to an event and all of them will be executed one by one when the
    event gets fired. To multicast, you have to use the `+=` sign to register event
    handlers to the event. You can also remove event handlers from the event by using
    the `-=` operator. When you apply multicast, the first event handler that was
    registered will get executed first, then the second, and so on. By multicasting,
    you can easily extend or reduce event handlers in your application without doing
    much work. Let''s look at an example of multicasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd85efc4-6818-457e-ab15-3c69366339d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now if we analyze the preceding code, we can see that we have created another
    class, `SmsEventHandler`, and this class has a method called `SmsSender`, which
    follows the same signature as our delegate `GetResult`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the main method, we create an instance of this `SmsEventHandler` class
    and register the `SmsSender` method to the event, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After firing the event once, we remove the `SmsSender` event handler from the
    event using the `-=` operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When we fire the event again, we can see in the output that only the email event
    handler was executed.
  prefs: []
  type: TYPE_NORMAL
- en: Event guidelines from .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For better stability, .NET Framework has provided some guidelines for using
    events in C#. It's not that you absolutely must follow these guidelines, but following
    these guidelines will certainly make your program more productive. Now let's see
    what guidelines we need to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'An event should take the following two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The reference to the object that generated the event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of `EventArgs` that will hold other important information needed by
    the event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general form of the code should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at an example that follows these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0eb0b9af-e892-43c3-ab91-1f574877789d.png)'
  prefs: []
  type: TYPE_IMG
- en: If we analyze the preceding code, we will see that we have passed the counter
    value using the  `EventArgs` parameter, and the reference of the object using
    the `object` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about delegates and events. These topics are very
    important in software development as they provide the functionality to automate
    code over a particular occasion. These concepts are both heavily used in the field
    of web development.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into generics and collections in C#. These
    are very interesting features of the C# programming language that you can use
    to write generic delegates in your programs.
  prefs: []
  type: TYPE_NORMAL
