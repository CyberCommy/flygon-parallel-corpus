- en: Responding to User Gestures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the examples that you've implemented so far in this book have relied
    on user gestures. In traditional web applications, you mostly deal with mouse
    events. However, touchscreens rely on the user manipulating elements with their
    fingers—fundamentally different from the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this chapter is to show you how the gesture response system inside
    React Native works and some of the ways this system is exposed via components.
  prefs: []
  type: TYPE_NORMAL
- en: First you'll learn about scrolling. This is probably the most common gesture,
    besides touch. Then, you'll learn about giving the user the appropriate level
    of feedback when they interact with your components. Finally, you'll implement
    components that can be swiped.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling with your fingers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scrolling in web applications is done by using the mouse pointer to drag the
    scrollbar back and forth or up and down, or by spinning the mousewheel. This doesn't
    work on a mobile device because there's no mouse. Everything is controlled by
    gestures on the screen. For example, if you want to scroll down, you use your
    thumb or index finger to pull the content up by physically moving your finger
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling like this is difficult to implement, but it gets more complicated.
    When you scroll on a mobile screen, the velocity of the dragging motion is taken
    into consideration. You drag the screen fast, then let go, and the screen will
    continue to scroll based on how fast you moved. You can also touch the screen
    while this is happening to stop it from scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, you don't have to handle most of this stuff. The `ScrollView` component
    handles much of the scrolling complexity for you. In fact, you've already used
    the `ScrollView` component, back in Chapter 16, *Rendering Item Lists*. The `ListView`
    component has `ScrollView` baked into it.
  prefs: []
  type: TYPE_NORMAL
- en: You can hack the low-level parts of user interactions by implementing gesture
    lifecycle methods. You'll probably never need to do this, but if you're interested,
    you can read about it at [http://facebook.github.io/react-native/releases/next/docs/gesture-responder-system.html](http://facebook.github.io/react-native/releases/next/docs/gesture-responder-system.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `ScrollView` outside `ListView`. For example, if you''re just
    rendering arbitrary content such as text and other widgets—not a list, in other
    words—you can just wrap it in a `<ScrollView>`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ScrollView` component isn''t of much use on it''s own—its there to wrap
    other components. It does need a height in order to function correctly. Here''s
    what the scroll style looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `height` is set to `1`, but the `stretch` value of `alignSelf` allows the
    items to display properly. Here''s what the end result looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3da6eac6-0017-42cc-9dfa-49f283008e8e.png)'
  prefs: []
  type: TYPE_IMG
- en: There's a vertical scrollbar on the right side of the screen as you drag the
    content down. If you run this example, you can play around with making various
    gestures, such as making content scroll on its own and then making it stop.
  prefs: []
  type: TYPE_NORMAL
- en: Giving touch feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The React Native examples you've worked with so far in this book have used plain
    text to act as buttons or links. In web applications, to make text look like something
    that can be clicked, you just wrap it with the appropriate link. There's no such
    thing as mobile links, so you can style your text to look like a button.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with trying to style text as links on mobile devices is that they're
    too hard to press. Buttons provide a bigger target for fingers, and they're easier
    to apply touch feedback on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s style some text as a button. This is a great first step, making the
    text look touchable. But you also want to give visual feedback to the user when
    they start interacting with the button. React Native provides two components to
    help with this: `TouchableOpacity` and `TouchableHighlight`. But before diving
    into the code, let''s take a look at what these components look like visually
    when users interact with them, starting with `TouchableOpacity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7a1f8c69-a376-468c-9580-8b5e0a54efc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s two buttons rendered here, and the top one labeled Opacity is currently
    being pressed by the user. The opacity of the button is dimmed when pressed, which
    provides important visual feedback for the user. Let''s see what the Highlight
    button looks like when pressed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f2037baf-4709-4699-83aa-c529aa891e68.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of changing the opacity when pressed, the `TouchableHighlight` component
    adds a highlight layer over the button. In this case, it's highlighted using a
    more transparent version of the slate gray used in the font and border colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which approach you use doesn''t really matter. The important thing is that
    you provide the appropriate touch feedback for your users as they interact with
    your buttons. In fact, you might want to use the two approaches in the same app,
    but for different things. Let''s create a `Button` component, which makes it easy
    to use either approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `touchables` map is used to determine which React Native touchable component
    wraps the text, based on the `touchable` property value. Here''s the styles used
    to create this button are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how you can put those buttons to use in the main app module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `onPress` callbacks don't actually do anything,—we're passing
    them because they're a required property.
  prefs: []
  type: TYPE_NORMAL
- en: Swipeable and cancellable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part of what makes native mobile applications easier to use than mobile web
    applications is that they feel more intuitive. Using gestures, you can quickly
    get a handle on how things work. For example, swiping an element across the screen
    with your finger is a common gesture, but the gesture has to be discoverable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that you're using an app, and you're not exactly sure what something
    on the screen does. So, you press down with your finger, and try dragging the
    element. It starts to move. Unsure of what will happen, you lift your finger up,
    and the element moves back into place. You've just discovered how part of this
    application works.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll use the `Scrollable` component to implement swipeable and cancelable
    behavior like this. You can create a somewhat generic component that allows the
    user to swipe text off the screen and, when that happens, call a callback function.
    Let''s look at the code to render the swipeables before we look at the generic
    component itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render eight `<Swipeable>` components on the screen. Let''s see what
    this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5560f4b8-a3f0-4c99-8b7b-c51716fffcb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you start to swipe one of these items to the left, it will move. Here''s
    what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9438e9ef-c3a2-4e73-85b7-d0f08c051c3f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t swipe far enough, the gesture is canceled and the item moves
    back into place as expected. If you swipe it all the way, the item is removed
    from the list completely and the items on the screen fill the empty space like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/674ca464-d0aa-4179-acc7-bfb4ab83faf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s take a look at the `Swipeable` component itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `<ScrollView>` component is set to be horizontal and that `pagingEnabled`
    is true. It''s the paging behavior that snaps the components into place, and provides
    the cancelable behavior. This is why there''s a blank component beside the component
    with text in it. Here are the styles used for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `swipeBlank` style has the same dimensions as `swipeItem`, but nothing else.
    It's invisible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the idea that gestures on native platforms
    are the difference maker when compared to mobile web platforms. We started off
    by looking at the `ScrollView` component, and how it makes life much simpler by
    providing native scrolling behavior for wrapped components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we spent some time implementing buttons with touch feedback. This is another
    area that's tricky to get right on the mobile web. You learned how to use the
    `TouchableOpacity` and `TouchableHighlight` components.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you implemented a generic `Swipeable` component. Swiping is a common
    mobile pattern, and it allows for the user to discover how things work without
    feeling intimidated. In the next chapter, you'll learn how to control image display
    using React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the main difference between user interactions with web applications and
    native mobile applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no noticeable difference between user interactions in web and mobile
    apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mobile applications are inherently faster than their web equivalents, so you
    code needs to take this into consideration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no mouse. Instead, the user interacts with your UI using their fingers.
    This is a fundamentally different experience than using a mouse and needs to be
    accommodated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you provide the user with touch feedback in React Native?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By passing `View` components the `feedback` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By wrapping touchable components with the `TouchableOpacity` or `TouchableHighlight`
    component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to manually adjust the styles of the view in an `onPress` handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What makes scrolling in mobile apps so much more complex than web app scrolling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scrolling in mobile web apps needs to take into consideration things like velocity
    because the user is interacting with their fingers. Otherwise, the interactions
    feel unnatural.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no real difference in complexity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It's only complex if you make it that way. Touch interactions can be implemented
    to behave the exact same as mouse interactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you use the ScrollView component to implement swipeable behavior?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because this is what users are used to in web applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because this is what users are used to in mobile web applications and how they
    learn the controls of the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You shouldn't implement swipeable behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/scrollview](https://facebook.github.io/react-native/docs/scrollview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/touchablehighlight](https://facebook.github.io/react-native/docs/touchablehighlight)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/touchableopacity](https://facebook.github.io/react-native/docs/touchableopacity)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
