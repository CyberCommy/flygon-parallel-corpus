- en: Type Checks and Null Safety
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 1](3223f31b-0cc1-4b69-96ed-a626f77315bf.xhtml)*, Setting
    Up for Android Development*, one of the great features that Kotlin brings to the
    table is **Null safety**. In this chapter, we will learn about what makes Kotlin
    a null-safe language and how we can take full advantage of it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, we will have learned about:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Non-nullable and nullable types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The safe call operator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Elvis operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `!!` operator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The safe and unsafe cast operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null safety
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common pain points developers have with Java and a number of
    other languages has to do with accessing a member of a null reference. In most
    languages, this results in a null reference exception at runtime. Most Java developers
    know this as the `NullPointerException`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin is designed to eliminate the possibility of running into null reference,
    exceptions as much as possible. As stated in [Chapter 1](3223f31b-0cc1-4b69-96ed-a626f77315bf.xhtml), *Setting
    Up for Android Development*, there are only four possible reasons why you could
    run into a `NullPointerException` in Kotlin:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: An external Java code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explicit call to throw `NullPointerException`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of the `!!` operator (we'll learn more about this operator later)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data inconsistency regarding initialization
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So how does Kotlin ensure this?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Nullable and non-nullable types
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **nullable type** is a reference that is allowed to hold a `null` value while
    a non-nullable type is a reference that cannot hold a `null` value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin''s type system is designed to distinguish between these two types of
    references. Nullable types are declared by appending a `?` at the end of the type. For
    example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are a number of things to take note of in the previous code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '`name` cannot be assigned a `null` value because it is a non-nullable type'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gender`, on the other hand, can be assigned a `null` value because it is declared
    as a nullable type'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a member method or property of `gender` cannot be done in the same
    way as accessing one of the `name` member methods or properties
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a number of ways to access a method or property of a nullable type.
    You can check for `null` and access the method or property in the condition. For
    example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The compiler keeps track of the results of the `null` check and therefore allows
    the call to `length` with the body of the `if` condition. This is an example of
    a **smart cast**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Using the safe call operator (`?.`)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Elvis operator (`?:`)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `!!` operator
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a smart cast
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart cast is a smart feature in Kotlin where the compiler tracks the results
    in an `if` statement and performs casts automatically when needed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Safe call operator
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of accessing a method or property of a nullable type is by using
    the safe call operator:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, if the gender is not `null`, the value of `len` will
    be the result of `gender.length`. Otherwise, the value of `len` will be `null`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Using the safe call operator is great if you don't need to perform any actions
    when `gender` is `null`. What if we want to assign `len` a different value when
    `gender` is `null`? We can combine the safe call operator with the **Elvis operator**
    for that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The Elvis operator
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Elvis operator is similar to the ternary `if` operator in Java. It''s a
    way of simplifying an `if-else` statement. For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code can be simplified to:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the previous code, the value of `len` will be `0` if `gender?.length` evaluates to
    `null`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The !! operator
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we don''t care about running into a null pointer exception? Then we
    can make use of the `!!` operator. For example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will result in a null pointer exception if `gender` is `null`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Only use the `!!` operator if you're either certain of the value of the variable
    or you don't care about running into a null pointer exception.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Type checks
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like in Java, you can confirm the type of a variable. In Kotlin, this
    is done using the `is` operator. For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Just as with the `null` check from earlier, the compiler keeps track of the
    results of the type check and automatically casts `gender` to a `String`, therefore
    allowing the call to `gender.length`. This is called a smart cast.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的 `null` 检查一样，编译器会跟踪类型检查的结果，并自动将 `gender` 转换为 `String`，从而允许调用 `gender.length`。这被称为智能转换。
- en: Cast operator
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换运算符
- en: 'To cast a variable to another type, you have to use the cast operator (`as`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要将变量转换为另一种类型，您必须使用转换运算符（`as`）：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The cast operator will throw an error if the variable you''re trying to cast
    is not of the type you''re trying to cast it to. To prevent this, you can make
    use of the **safe cast operator **(`as?`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试将变量转换为的类型不是您要转换的类型，则转换运算符将抛出错误。为了防止这种情况，您可以使用**安全转换运算符**（`as?`）：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The safe cast operator does not throw an error but returns a `null` if the cast
    is not possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安全转换运算符不会抛出错误，而是在转换不可能时返回 `null`。
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the different ways Kotlin helps make your
    code null safe. There are different operators used in Kotlin to achieve this and
    we covered how to use them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Kotlin 如何帮助使您的代码具有空安全性的不同方式。 Kotlin 中有不同的运算符用于实现这一点，我们讨论了如何使用它们。
- en: In the next chapter, we will complete work on our TicTacToe game while learning
    about functions and lambdas in Kotlin.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在学习 Kotlin 中的函数和 lambda 的同时完成我们的井字棋游戏。
