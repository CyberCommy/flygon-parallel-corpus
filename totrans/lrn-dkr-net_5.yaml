- en: Chapter 5. Security and QoS for Docker Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how security is implemented in the context of
    containers in general and how QoS policies are implemented to make sure that resources
    such as CPU and IO are shared as intended. Most of the discussion will focus on
    the relevance of these topics in the context of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: File system restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only mount points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy on write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux capabilities and Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing containers in AWS ECS (EC2 container service)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker security I – kernel namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker security II – cgroups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AppArmour to secure Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker security benchmark
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystem restrictions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to study filesystem restrictions with which Docker
    containers are started. The following section explains the read-only mount points
    and copy-on-write filesystems, which are used as a base for Docker containers
    and the representation of kernel objects.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only mount points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker needs access to filesystems such as sysfs and proc for processes to function.
    But it doesn't necessarily need to modify these mount points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two primary mount points loaded in read-only mode are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/sys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: sysfs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sysfs filesystem is loaded into mount point `/sys`. sysfs is a mechanism
    for representing kernel objects, their attributes, and their relationships with
    each other. It provides two components:'
  prefs: []
  type: TYPE_NORMAL
- en: A kernel programming interface for exporting these items via sysfs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user interface to view and manipulate these items that maps back to the kernel
    objects that they represent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the mount points being mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A reference link for the preceding code is at [https://github.com/docker/docker/blob/ecc3717cb17313186ee711e624b960b096a9334f/daemon/execdriver/native/template/default_template_linux.go](https://github.com/docker/docker/blob/ecc3717cb17313186ee711e624b960b096a9334f/daemon/execdriver/native/template/default_template_linux.go).
  prefs: []
  type: TYPE_NORMAL
- en: procfs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The proc filesystem (procfs) is a special file system in Unix-like operating
    systems, which presents information about processes and other systems information
    in a hierarchical file-like structure. It is loaded into `/proc`. It provides
    a more convenient and standardized method for dynamically accessing process data
    held in the kernel than traditional tracing methods or direct access to kernel
    memory. It is mapped to a mount point named `/proc` at boot time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Read-only paths with `/proc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: /dev/pts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another mount point that is mounted as read-write for the container
    during creation. `/dev/pts` lives purely in memory and nothing is stored on disk,
    hence it is safe to load it in read-write mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entries in `/dev/pts` are pseudo-terminals (pty for short). Unix kernels have
    a generic notion of terminals. A terminal provides a way for applications to display
    output and to receive input through a terminal device. A process may have a controlling
    terminal. For a text mode application, this is how it interacts with the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: /sys/fs/cgroup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the mount point where cgroups are implemented and is loaded as `MS_RDONLY`
    for the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Copy-on-write
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker uses union filesystems, which are copy-on-write filesystems. This means
    containers can use the same filesystem image as the base for the container. When
    a container writes content to the image, it gets written to a container-specific
    filesystem. It prevents one container from being able to access the changes of
    another container even if they are created from the same filesystem image. One
    container cannot change the image content to effect the processes in another container.
    The following figure explains this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Copy-on-write](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Linux capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker containers before 1.2 could either be given complete capabilities under
    privileged mode, or they can all follow a whitelist of allowed capabilities while
    dropping all others. If the flag `--privileged` is used, it will grant all capabilities
    to the container. This was not recommended for production use because it's really
    unsafe; it allowed Docker all privileges as a process under the direct host.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Docker 1.2, two flags have been introduced with `docker run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--cap-add`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cap-drop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two flags provide fine-grain control to a container, for example, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the status of the Docker container''s interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Prevent any chown in the Docker container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow all capabilities except `mknod`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Docker starts containers with a restricted set of capabilities by default. Capabilities
    convert a binary mode of root and non-root to a more fine-grained access control.
    As an example, a web server which serves HTTP request needs to be bound to port
    80 for HTTP and 443 for HTTPs. These servers need not be run in the root mode.
    These servers can be granted `net_bind_service` capability.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and servers are a little different in this context. Servers need
    to run a few processes in the root mode. For example, ssh, cron, and network configurations
    to handle dhcp, and so on. Containers, on the other hand, do not need this access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tasks need not happen in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: ssh access is managed by Docker host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cron jobs should be run in the user mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network configuration such as ipconfig and routing should not happen inside
    the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can safely deduce containers might not need root priviledges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples that can be denied are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not allow mount operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not allow access to sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent access to filesystem operations such as changing file attributes or
    ownership of the files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevent the container from loading new modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker allows only the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A reference to the preceding code is at [https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template_linux.go](https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template_linux.go).
  prefs: []
  type: TYPE_NORMAL
- en: A full list of available capabilities can be found in the Linux man-pages ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
  prefs: []
  type: TYPE_NORMAL
- en: One primary risk with running Docker containers is that the default set of capabilities
    and mounts given to a container may provide incomplete isolation, either independently
    or when used in combination with kernel vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Docker supports the addition and removal of capabilities, allowing the use of
    a non-default profile. This may make Docker more secure through capability removal
    or less secure through the addition of capabilities. The best practice for users
    would be to remove all capabilities except those explicitly required for their
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Securing containers in AWS ECS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Amazon **EC2 container service** (**ECS**) provides a highly scalable, high-performance
    container management service that supports Docker containers. It allows you to
    easily run applications on a managed cluster of Amazon EC2 instances. Amazon ECS
    eliminates the need for you to install, operate, and scale your own cluster management
    infrastructure. With simple API calls, you can launch and stop Docker-enabled
    applications and query the complete state of your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we will see how to deploy a secured web application
    using two Docker containers, one containing a simple web application (application
    container), and the other containing a reverse proxy with throttling enabled (proxy
    container), which can be used to protect the web application. These containers
    will be deployed on the Amazon EC2 instance using ECS. As can be seen in the following
    diagram, all the network traffic will be routed through the proxy container that
    throttles requests. Also, we can perform activities such as filtering, logging,
    and intrusion detection at proxy containers using various security software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build a basic PHP web application container from the GitHub project.
    The following steps can be performed on a separate EC2 instance or a local machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Change directories to the `ecs-demo-php-simple-app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can examine `Dockerfile` as follows in order to understand the web application
    it will deploy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the container image using Dockerfile and then push it in your Docker
    Hub account. The Docker Hub account is required as it helps to deploy the containers
    on the Amazon ECS service by just specifying the container name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The image built over here is required to have `dockerhub-username` (correct
    without spaces) as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure depicts a hacker not able to access the web application,
    as the request is filtered via a proxy container and access is blocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing containers in AWS ECS](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Upload the Docker image to the Docker Hub account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to ensure your login worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Push your image to the Docker Hub account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the sample web application Docker container, we will now create
    the proxy container, which can also contain some security-related software, if
    required, in order to strengthen security. We will create a new proxy Docker container
    using a customized Dockerfile and then push the image to your Docker Hub account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous Dockerfile we are using a base Ubuntu image and installing nginx
    and exposing it on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a customized `nginx.conf`, which will override the default
    `nginx.conf` in order to ensure the reverse proxy is configured properly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the proxy Docker image and push the built image to the Docker Hub account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The ECS container service can be deployed by navigating to **AWS Management
    Console** ([https://aws.amazon.com/console/](https://aws.amazon.com/console/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Task Definitions** in the left sidebar and then click **Create a New
    Task Definition**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give your task definition a name, such as `SecurityApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, click on **Add Container** and insert the name of the proxy web container
    pushed to the Docker Hub account, as well as the name of the application web container.
    View the contents of the JSON using **Configure via JSON** tab to see the task
    definition that you have created. It should be like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Click the **Create** button in order to deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Clusters** in the left sidebar. If a default cluster does not exist,
    create one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch an ECS-optimized **Amazon Machine Image** (**AMI**), ensuring it has
    a public IP address and a path to the Internet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your instance is up and running, navigate to the **ECS** section of the
    **AWS Management Console** and click **Clusters**, then **default**. Now, we should
    be able to see our instance under the **ECS Instances** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **TASK** definitions from the left side of the **AWS Management
    Console** tab and click **Run Task**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next page, ensure the cluster is set to **Default** and the number of
    tasks is **1**, then click **Run Task**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the process completes we can see the state of the task from a pending
    state to a green running state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on the **ECS** tab, we can see the container instance created earlier.
    By clicking on it, we will get information about its public IP address. By hitting
    this public IP address via the browser we will be able to see our sample PHP application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding Docker security I – kernel namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A namespace provides a wrapper around a global system resource of the kernel
    and makes the resource appear to the process within the namespace as if they have
    an isolated instance. Global resource changes are visible to processes in the
    same namespace but invisible to others. Containers are considered an excellent
    implementation of a kernel namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following namespaces are implemented by Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pid namespace**: Used for process isolation (**PID**—**Process ID**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net namespace**: Used for managing network interfaces (**NET**—**Networking**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ipc namespace**: Used for managing access to IPC resources (**IPC**—**Inter
    Process Communication**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mnt namespace**: Used for managing mount points (**MNT**—**Mount**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uts namespace**: Used for isolating kernel and version identifiers (**UTS**—**Unix
    Time sharing System**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding namespace support in libcontainer required adding patches in the system
    layer of GoLang ([https://codereview.appspot.com/126190043/patch/140001/150001](https://codereview.appspot.com/126190043/patch/140001/150001)<emphsis>src/syscall/exec_linux.go</emphsis>)
    so that new data structures could be maintained for PIDs, user UIDs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: pid namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: pid namespaces isolate the process ID number space; processes in different pid
    namespaces can have the same pid. pid namespaces allow containers to provide functionality
    such as suspending/resuming the set of processes in the container, and migrating
    the container to a new host while the processes inside the container maintain
    the same pids.
  prefs: []
  type: TYPE_NORMAL
- en: pids in a new namespace start with PID 1\. The kernel needs to be configured
    for the flag `CONFIG_PID_NS` for the namespace to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'pid namespaces can be nested. Each pid namespace has a parent, except for the
    initial (root) pid namespace. The parent of a pid namespace is the pid namespace
    of the process that created the namespace using clone or unshare. pid namespaces
    form a tree, with all namespaces ultimately tracing their ancestry to the root
    namespace as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![pid namespace](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: net namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: net namespace provides isolation of the system resources associated with networking.
    Each network namespace has its own network devices, IP addresses, IP routing tables,
    `/proc/net` directory, port numbers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network namespaces make containers useful from a networking perspective: each
    container can have its own (virtual) network device and its own applications that
    bind to the per-namespace port number space; suitable routing rules in the host
    system can direct network packets to the network device associated with a specific
    container. Use of network namespaces requires a kernel that is configured with
    the `CONFIG_NET_NS` option ([https://lwn.net/Articles/531114/](https://lwn.net/Articles/531114/)).'
  prefs: []
  type: TYPE_NORMAL
- en: As each container has its own network namespace, which basically means its own
    network interface and routing tables, net namespace is also directly leveraged
    by Docker to isolate IP addresses, port numbers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Basic network namespace management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Network namespaces are created by passing a flag to the `clone()` system call,
    `CLONE_NEWNET`. From the command line, though, it is convenient to use the IP
    networking configuration tool to set up and work with network namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new network namespace called `netns1`. When the IP tool
    creates a network namespace, it will create a bind mount for it under `/var/run/netns`,
    which allows the namespace to persist, even when no processes are running within
    it, and facilitates the manipulation of the namespace itself. Since network namespaces
    typically require a fair amount of configuration before they are ready for use,
    this feature will be appreciated by systems administrators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ip netns exec` command can be used to run network management commands
    within the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This command lists the interfaces visible inside the namespace. A network namespace
    can be removed with the use of following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command removes the bind mount referring to the given network namespace.
    The namespace itself, however, will persist for as long as any processes are running
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: Network namespace configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New network namespaces will have a loopback device but no other network devices.
    Aside from the loopback device, each network device (physical or virtual interfaces,
    bridges, and so on) can only be present in a single network namespace. In addition,
    physical devices (those connected to real hardware) cannot be assigned to namespaces
    other than the root. Instead, virtual network devices (for example, virtual Ethernet
    or vEth) can be created and assigned to a namespace. These virtual devices allow
    processes inside the namespace to communicate over the network; it is the configuration,
    routing, and so on that determines who they can communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: When first created, the `lo` loopback device in the new namespace is down, so
    even a loopback `ping` will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous command, we can see that since the net namespace for a Docker
    container is stored in a separate location, and thus a symlink is required to
    be created to `/var/run/netns`, it can be done in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it is done by bringing that interface up, which will allow
    the pinging of the loopback address.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This still doesn't allow communication between `netns1` and the root namespace.
    To do that, virtual Ethernet devices need to be created and configured.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first command sets up a pair of virtual Ethernet devices that are connected.
    Packets sent to `veth0` will be received by `veth1` and vice versa. The second
    command assigns `veth1` to the `netns1` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, these two commands set IP addresses for the two devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Communication in both directions is now possible as the previous `ping` commands
    show.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, though, namespaces do not share routing tables or firewall rules,
    as running route and `iptables -L` in `netns1` will attest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: User namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: User namespaces allows per-namespace mappings of user and group IDs. This means
    that user IDs and group IDs of a process inside a user namespace can be different
    from its IDs outside of the namespace. A process can have a non-zero user ID outside
    a namespace while, at the same time, having a user ID of zero inside the namespace.
    The process is unprivileged for operations outside the user namespace but has
    root privileges inside the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'User namespaces are created by specifying the `CLONE_NEWUSER` flag when calling
    `clone()` or `unshare()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clone()` allows the child process to share parts of its execution context
    with the calling process, such as the memory space, the table of file descriptors,
    and the table of signal handlers.'
  prefs: []
  type: TYPE_NORMAL
- en: '`unshare()` allows a process (or thread) to disassociate parts of its execution
    context that are currently being shared with other processes (or threads). Part
    of the execution context, such as the mount namespace, is shared implicitly when
    a new process is created using `fork()` or `vfork()`.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, Docker containers are very similar to LXC containers
    as a set of namespaces and control groups are created separately for containers.
    Each container gets its own network stack and namespace. Until and unless containers
    do not have the privileged access, they are not allowed to access other hosts
    sockets or interfaces. If the host network mode is given to the container, then
    only it gets the ability to access the host ports and IP address, which can cause
    a potential threat to other programs running on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following example, where we use the `host` network mode in
    the container and it is able to access all the hosts bridges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'While auditing, it should be checked that all the containers, by default, have
    network mode set to `default` and not `host`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Each Docker container is connected to an Ethernet bridge in order to provide
    inter-connectivity between containers. They can ping each other to send/receive
    UDP packets and establish TCP connections, but that can be restricted if necessary.
    Namespace also provides a straightforward isolation in restricting the access
    of the processes running in the other container as well as the host.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using the following `nsenter` command line utility in order to enter
    into namespaces. It is an open-source project on GitHub available at [https://github.com/jpetazzo/nsenter](https://github.com/jpetazzo/nsenter).
  prefs: []
  type: TYPE_NORMAL
- en: Using it, we will try to enter existing container namespaces or try to spawn
    a new set of namespaces. It is different from the Docker `exec` command as `nsenter`
    doesn't enter the cgroups, which gives potential benefits for debugging and external
    audits by escaping the resource limitations using namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install `nsenter` from PyPI (it requires Python 3.4) and use the command
    line utility to connect to a running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To replace pid with the container''s pid, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `docker inspect` command to make it more convenient as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First start a new nginx server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then get pid of the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the running nginx container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`docker-enter` is also one of the wrappers that can be used to enter inside
    the container specifying the shell commands, and if no command is specified, a
    shell will be invoked instead. If it is required to inspect or manipulate containers
    without executing another command line tool, we can use context manager to do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Docker security II – cgroups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we look at how cgroups form the backbone of isolation for a
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Defining cgroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Control groups provide a mechanism for aggregating/partitioning sets of tasks
    (processes), and all their future children, into hierarchical groups.
  prefs: []
  type: TYPE_NORMAL
- en: A cgroup associates a set a tasks with parameters from a subsystem. A subsystem
    itself is a resource controller used to define boundaries for cgroups or for provisioning
    a resource.
  prefs: []
  type: TYPE_NORMAL
- en: A hierarchy is a set of cgroups arranged in a tree, such that every task in
    the system is in exactly one of the cgroups in the hierarchy and a set of subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: Why are cgroups required?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple efforts to provide process aggregations in the Linux kernel,
    mainly for resource-tracking purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Such efforts include cpusets, CKRM/ResGroups, UserBeanCounters, and virtual
    server namespaces. These all require the basic notion of a grouping/partitioning
    of processes, with newly forked processes ending up in the same group (cgroup)
    as their parent process.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel cgroup patch provides essential kernel mechanisms to efficiently
    implement such groups. It has minimal impact on the system fast paths and provides
    hooks for specific subsystems such as cpusets to provide additional behavior as
    desired.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a cgroup manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following steps, we will create a `cpuset` control group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`tmpfs` is a file system that keeps all files in virtual memory. Everything
    in `tmpfs` is temporary in the sense that no files will be created on your hard
    drive. If you unmount a `tmpfs` instance, everything stored therein is lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign CPU and memory limits to this cgroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command shows `/Charlie` as the cpuset cgroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Attaching processes to cgroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the process ID `PID{X}` to the tasks file as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is `PID`, not PIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can only attach one task at a time. If you have several tasks to attach,
    you have to do it one after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach the current shell task by echoing `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Docker and cgroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: cgroups are managed as part of the libcontainer project under Docker's GitHub
    repo ([https://github.com/opencontainers/runc/tree/master/libcontainer/cgroups](https://github.com/opencontainers/runc/tree/master/libcontainer/cgroups)).
    There is a cgroup manager that manages the interaction with the cgroup APIs in
    the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the lifecycle events managed by the manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Using AppArmor to secure Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AppArmor is a **Mandatory Access Control** (**MAC**) system that is a kernel
    enhancement to confine programs to a limited set of resources. AppArmor's security
    model is to bind access control attributes to programs rather than to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'AppArmor confinement is provided via profiles loaded into the kernel, typically
    on boot. AppArmor profiles can be in one of two modes: enforcement or complain.'
  prefs: []
  type: TYPE_NORMAL
- en: Profiles loaded in enforcement mode will result in enforcement of the policy
    defined in the profile, as well as reporting policy violation attempts (either
    via syslog or auditd).
  prefs: []
  type: TYPE_NORMAL
- en: Profiles in complain mode will not enforce policy but instead report policy
    violation attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'AppArmor differs from some other MAC systems on Linux: it is path-based, it
    allows mixing of enforcement and complain-mode profiles, it uses include files
    to ease development, and it has a far lower barrier to entry than other popular
    MAC systems. The following figure shows the AppArmour application profiles linked
    to apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using AppArmor to secure Docker containers](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: AppArmor is an established technology first seen in Immunix and later integrated
    into Ubuntu, Novell/SUSE, and Mandriva. Core AppArmor functionality is in the
    mainline Linux kernel from 2.6.36 onwards; work is ongoing by AppArmor, Ubuntu,
    and other developers to merge additional AppArmor functionality into the mainline
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about AppArmor at [https://wiki.ubuntu.com/AppArmor](https://wiki.ubuntu.com/AppArmor).
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor and Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications running inside Docker can leverage AppArmor for defining policies.
    These profiles can either be created manually or loaded using a tool called bane.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Ubuntu 14.x, make sure systemd is installed for the following commands to
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show how to use this tool:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the bane project for GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Make sure this is done in the directory in your GOPATH. For example, we used
    `/home/ubuntu/go` and the bane source was downloaded in `/home/Ubuntu/go/src/github.com/jfrazelle/bane`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install toml parser needed by bane to be compiled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the `/home/Ubuntu/go/src/github.com/jfrazelle/bane` directory and run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You will find the bane binary in `/home/Ubuntu/go/bin`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use a `.toml` file to create a profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute bane to load the profile. `sample.toml` is a file in the directory
    `/home/Ubuntu/go/src/github.com/jfrazelle/bane`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This profile will make a whole lot of paths read only and allows only nginx
    execution in the container we are going to create. It disables TOP, PING, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the profile is loaded you can create a nginx container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, if AppArmor is not able to find the file, copy the file into the `/etc/apparmor.d`
    directory and reload the AppArmour profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the nginx container with the AppArmor profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows how an nginx app running inside a container uses
    AppArmour application profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AppArmor and Docker](../images/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker security benchmark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following tutorial shows some of the important guidelines that should be
    followed in order to run Docker containers in secured and production environments.
    It is referred from the CIS Docker Security Benchmark [https://benchmarks.cisecurity.org/tools2/docker/CIS_Docker_1.6_Benchmark_v1.0.0.pdf](https://benchmarks.cisecurity.org/tools2/docker/CIS_Docker_1.6_Benchmark_v1.0.0.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Audit Docker daemon regularly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Apart from auditing your regular Linux filesystem and system calls, audit Docker
    daemon as well. Docker daemon runs with root privileges. It is thus necessary
    to audit its activities and usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the audit log file, if it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the audit rules for the Docker service and audit the Docker service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Create a user for the container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, mapping the container's root user to a non-root user on the host
    is not supported by Docker. The support for user namespace would be provided in
    future releases. This creates a serious user isolation issue. It is thus highly
    recommended to ensure that there is a non-root user created for the container
    and the container is run using that user.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the following snippet, by default, the `centos` Docker image
    has a `user` field as blank, which means, by default, the container will get a
    root user during runtime, which should be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'While building the Docker image, we can provide the `test` user, the less-privileged
    user, in the Dockerfile, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When we start the Docker container, we can see that it gets a `test` user,
    and the `docker inspect` command also shows the default user as `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Do not mount sensitive host system directories on containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If sensitive directories are mounted in read-write mode, it would be possible
    to make changes to files within those sensitive directories. The changes might
    bring down security implications or unwarranted changes that could put the Docker
    host in a compromised state.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `/run/systemd` sensitive directory is mounted in the container then
    we can actually shutdown the host from the container itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be audited by using the following command, which returns the list of
    current mapped directories and whether they are mounted in read-write mode for
    each container instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Do not use privileged containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker supports the addition and removal of capabilities, allowing the use of
    a non-default profile. This may make Docker more secure through capability removal,
    or less secure through the addition of capabilities. It is thus recommended to
    remove all capabilities except those explicitly required for your container process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the following, when we run the container without the privileged
    mode, we are unable to change the kernel parameters, but when we run the container
    in privileged mode using the `--privileged` flag, it is possible to change the
    kernel parameters easily, which can cause security vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'So, while auditing, it should be made sure that all the containers should not
    have the privileged mode set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a deep dive into Docker security with an overview of
    cgroups and kernel namespace. We also went over some of the aspects of filesystems
    and Linux capabilities, which containers leverage in order to provide more features,
    such as the privileged containers, but at the cost of exposing itself more on
    the threat side. We also saw how containers can be deployed in a secured environment
    in AWS ECS (EC2 container service) using proxy containers to restrict vulnerable
    traffic. AppArmor also provides kernel-enhancement features in order to confine
    applications to a limited set of resources. Leveraging their benefits to Docker
    containers helps us to deploy them in a secured environment. Finally, we had a
    quick dive into Docker security benchmarks and some of the important recommendations
    that can be followed during auditing and Docker deployment in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about tuning and troubleshooting in the Docker
    network using various tools.
  prefs: []
  type: TYPE_NORMAL
