- en: Exploring Search Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with sorting, searching is one of the most used algorithms in the programming
    world. Whether we are searching our phone book, e-mails, database, or files, we
    are actually performing some sort of search technique to locate the item we wish
    to find. It is imperative that searching and sorting are the two most important
    components of programming. In this chapter, you will learn about different searching
    techniques and how efficient they are. We will also learn about different ways
    of searching tree data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Linear searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common ways of performing a search is to compare each item
    with the one we are looking for. This is known as linear search or sequential
    search. It is the most basic way of performing a search. If we consider that we
    have *n* items in a list, in the worst case, we have to search *n* items to find
    a particular item. We can iterate through a list or array to find an item. Let''s
    consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a function named `search` , which takes two arguments. One is the list
    of numbers, and the other is the number we are looking for in the list. We are
    running a for loop to iterate through each item in the list and compare them with
    our item. If a match is found, we return true and do not continue with the search.
    However, if the loop ends and nothing is found, we return false at the end of
    the function definition. Let''s use the `search` function to find something using
    the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are generating a random array using PHP's built-in function range,
    with a range of 1 to 200 inclusive. Each item will have a gap of 5 like 1, 6,
    11, 16, and so on; then we are searching 31, which is in the list as we have 6,
    11, 16, 21, 26, 31, and so on. However, if we want to search for 32 or 33, then
    the item will not be found. So, for this case, our output will be `Found` .
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we need to remember here is that we are not worried about whether
    our list is in any particular order or organized in a certain way. If the item
    we are looking for is in the first position, that will be the best result. The
    worst result can be the last item or an item that is not in the list. In both
    cases, we have to iterate over all *n* items of the list. Here is the complexity
    for linear/sequential search:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: As we can see, the average or worst time complexity for a linear search is `O(n)`
    , and that does not change how we order the list of items. Now, if the items in
    the array are sorted in a particular order, then we might not have to do a linear
    search, and we can get a better result by doing a selective or calculative search.
    The most popular and well-known search algorithm is "binary search". Yes, it sounds
    like the binary search tree you learned in [Chapter 6](text00138.html) , *Understanding
    and Implementing Trees* , but we can use this algorithm without even constructing
    a binary search tree. So, let's explore this.
  prefs: []
  type: TYPE_NORMAL
- en: Binary search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Binary search is a very popular search algorithm in the programming world.
    In sequential search, we started from the beginning and scanned through each item
    to find the desired one. However, if the list is already sorted, then we do not
    need to search from the beginning or the end of the list. In a binary search algorithm,
    we start with the middle of the list, check whether the item in the middle is
    smaller or greater than the item we are looking for, and decide which way to go.
    This way, we divide the list by half and discard one half completely, just like
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the preceding image, we have a sorted (ascending order) list of
    numbers in an array. We want to know whether item **7** is in the array or not.
    Since the array has 17 items (0 to 16 index), we will first go to the middle index,
    which is the eighth index for this example. Now, the eighth index has a value
    of **14** , which is greater than the value we are searching for, which is **7**
    . This means that if **7** is present in this array, it is to the left of **14**
    , since the numbers are already sorted. So, we are discarding the array from the
    eighth index to the sixteenth index as the number cannot be in that part of the
    array. Now, we repeat the same process and take the middle of the remaining part
    of the array, which is the third element of the remaining part. Now, the third
    element has a value of **6** , which is less than **7** . As a result, the item
    we are looking for is on the right-hand side of the third element, not on its
    left.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will check the fourth element to the seventh element of the array, with
    the middle element to now point at the fifth element. The fifth element value
    is **8** , which is more than **7** , the one we are looking for. So, we have
    to consider the left-hand side of the fifth element to find the item we are looking.
    This time, we have only two items remaining for the array to check, and the elements
    are fourth and fifth elements. As we are moving to the left, we will check the
    fourth element, and we see the value matches with **7** , which we are looking
    for. If the fourth index value was not **7** , the function will return false
    as there are no more elements left for checking. If we look at the arrow marks
    in the preceding image, we can see that within four steps, we have found the value
    we are looking for, whereas we had to take 17 steps to check all 17 numbers in
    a linear search function in a worst case situation. This is known as a binary
    search, or half-interval search, or logarithmic search.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in our last image, we have to divide our initial list into
    halves and continue until we reach a point where we cannot make any further division
    to find our item. We can use an iterative way or recursive way to perform the
    division part. We will actually use both ways. So, let''s first define the pseudocode
    of a binary search in the iterative way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the pseudocode, we can see that we are adjusting our low and
    high based on our mid value. If the value we are looking for is greater than what
    we have in mid, we are adjusting the lower bound to be `mid+1` . If it''s less
    than the mid value, then we are setting the higher value as `mid-1` . It continues
    until the lower value becomes bigger than the higher value or the item is found.
    If the item is not found, we return false at the end of the function. Now, let''s
    implement the pseudocode using PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In our implementation, we have followed most of the pseudocode in the preceding
    page. Now, let''s run the code with two searches, where we know one value is in
    the list and one is not in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know from our previous linear search code, `31` is in the list, and it
    should show `Found` . However, `500` is not in the list, and it should show `Not
    found` . If we run the code, here is the output we will see in our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now write the recursive algorithm for the binary search, which can
    also be handy for us. The pseudocode will require us to send extra arguments every
    time we call the function. We need to send the low and high with every recursive
    call, which we did not do for the iterative one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the preceding pseudocode that we are now having low and high
    as parameters, and in each call, the new values are sent as arguments. We have
    the boundary condition where we are checking whether the low is bigger than the
    high. The code looks smaller and cleaner compared to the iterative one. Now, let''s
    implement this using PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use the following code to run this search recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding code, we sent `0` and `count($numbers)-1` in
    each call of recursive binary search for the first time. Then, this high and low
    is auto-adjusted on each recursive call based on the mid value. So, we have seen
    both the iterative and recursive implementation of binary search. Based on our
    needs, we can use any one of these in our program. Now, let's analyze the binary
    search algorithm and find out how it is better than our linear or sequential search
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of binary search algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen that for each iteration, we are dividing the list by half
    and discarding one half completely for searching. This makes our list look like
    *n/2* , *n/4* , *n/8* , and so on after 1, 2, and 3 iterations, respectively.
    So, we can say that after Kth iteration, *n/2^k* items will be left. We can easily
    say that, the last iteration occurs when *n/2^k = 1* , or we can say that, *2^K
    = n* . So, taking log from both side yields, *k = log(n)* , which is the worst
    case running time for binary search algorithm. Here is the complexity for binary
    search algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(log n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `O(log n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: If our array or list is already sorted, it is always preferred to apply binary
    search for better performance. Now, whether the list is sorted in the ascending
    order or descending order, it can have some impact on our calculation of low and
    high. The logic we have seen so far is for the ascending order. If an array is
    sorted in the descending order, the logic will be swapped where greater than will
    become less than, and vice versa. One thing to notice here is that the binary
    search algorithm provides us with the index we have found of the search item.
    However, there might be some cases where we not only need to know whether the
    number exists, but also to find the first appearance or last appearance in the
    list. If we use binary search algorithm, then it will return true or maximum index
    number, where the search algorithm found the number. However, it might not be
    the first appearance or last appearance. For that, we will modify the binary search
    algorithm a little, which we will call repetitive binary search tree algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Repetitive binary search tree algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following image. We have an array with repetitive items. If we
    try to find the first appearance of **2** from the array, binary search algorithm
    from the last section will give us the fifth element. However, from the following
    image, we can see clearly it is not the fifth element; instead, it is the second
    element, which is the correct answer. So, a modification is required in our binary
    search algorithm. The modification will be a repetitive searching until we reach
    the first appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00064.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the modified solution using iterative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, first we are checking whether the mid has the value we are looking
    for. If it is true, then we are assigning the middle index as first occurrence,
    and we will search the left of the middle element to check for any occurrences
    of the number we are looking for. We then continue the iteration until we have
    searched each index (`$low` is greater than `$high` ). If no further occurrence
    is found, then the variable first occurrence will have the value of the first
    index where we found the item. If not, we are returning `-1` as usual. Let''s
    run the following code to check whether our results are correct or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have an array with repetitive values of 2, 3, 4, and 5\. We want to
    search the array and find the position or index where the value has appeared for
    the first time. For example, if we are searching `2` in a regular binary search
    function, it will return eighth as the position where it found the value `2` .
    In our case, we are actually looking for the second index, which actually holds
    the first appearance of item `2` . Our function `repetitiveBinarySearch` does
    exactly that, and we are storing the return position to a variable called `$pos`
    . We are showing the output if the number is found along with the position. Now,
    if we run the preceding code in our console, we will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This matches our expected results. So, we can say we now have a repetitive binary
    search algorithm to find first and last occurrences of an item from a given sorted
    list. This might be a very handy function to solve many problems.
  prefs: []
  type: TYPE_NORMAL
- en: So far, from our examples and analysis, we can conclude that binary searching
    is definitely faster than linear searching. However, the major prerequisite is
    to have the list sorted before applying binary search. Applying binary search
    in an unsorted array will lead us to inaccurate results. There can be situations
    where we receive an array and we are not sure whether the array is sorted or not.
    Now, the question is, "Should we sort the array first and apply binary search
    algorithm in such cases? Or should we just run a linear search algorithm to find
    an item?" Let's discuss this a little, so that we know how to handle such situations.
  prefs: []
  type: TYPE_NORMAL
- en: Searching an unsorted array - should we sort first?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now, we are in a situation where we have an array with *n* items and they
    are not sorted. Since we know binary search is faster, we have decided to sort
    it first and then search for the item using a binary search. If we do so, we have
    to remember that the best sorting algorithms have a worst time complexity of `O(nlog
    n)` , and for binary search, the worst case complexity is `O(log n)` . So, if
    we sort and then apply the binary search, the complexity will be `O(n log n)`
    as it is the biggest one compared to `O(log n)` . However, we also know that for
    any linear or sequential search (sorted or unsorted), the worst time complexity
    is `O(n)` , which is much better than `O(n log n)` . Based on the complexity comparison
    of `O(n)` and `O(n log n)` , we can clearly say that performing a linear search
    is a better option if the array is not sorted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider another situation where we need to search a given array a multiple
    number of times. Let's denote *k* as the number of times we want to search the
    array. If *k* is 1, then we can easily apply our linear approach discussed in
    the last paragraph. It will be fine if the value of *k* is smaller compared to
    the size of the array, which is denoted by *n* . However, if the value of *k*
    is closer or bigger than *n* , then we have some problems applying the linear
    approach here.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that *k = n* , then for *n* time, linear search will have a complexity
    of `O(n² )` . Now, if we go for the sort and then search option then even if *k*
    is bigger, the onetime sorting will take `O(n log n)` time complexity. Then, each
    search will take `O(log n)` , and *n* times searching will have a worst case of
    `O(n log n)` complexity. If we take the worst running case here, we will have
    `O(n log n)` for sorting and searching *k* items, which is better than sequential
    searching.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can come to the conclusion that if a number of search operations is smaller
    compared to the size of the array, it is better not to sort the array and perform
    the sequential search. However, if the number of search operation is bigger compared
    to the size of array, it is better to sort the array first and then apply the
    binary search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over the years, the binary search algorithm evolved and came up with different
    variations. Instead of choosing the middle index every time, we can make calculative
    decisions to choose which index we should use next. That is what makes these variations
    work efficiently. We will now talk about two such variations of binary search
    algorithm: interpolation search and exponential search.'
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In binary search algorithm, we always start with the middle of the array to
    start the searching process. If an array is uniformly distributed and we are looking
    for an item, which, may be close to the end of array, then searching from the
    middle might not sound like a good choice to us. Interpolation search can be very
    helpful in such cases. Interpolation search is an improvement over binary search
    algorithm. Interpolation search may go to different location based on the value
    of the searched key. For example, if we are searching a key that is close to the
    beginning of the array, it will go to the first part of the array instead of starting
    from the middle. The position is calculated using a probe position calculator
    equation, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we are going from our generic `mid = (low+high)/2` equation
    to a more complex looking equation. This formula will return a higher value if
    the searched key is closer to `arr[high]` and a much lower value if the key is
    closer to `arr[low]` . Now, let''s implement this search method with the help
    of our binary search code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calculating in a different way. Though it is taking more computational
    steps, the good part is that if the list is uniformly distributed, then the average
    complexity of this algorithm is `O(log (log n))` , which is much better compared
    to binary search's complexity of `O(log n)` . Also, we have to be careful if the
    distributions of the keys are not uniform. In this case, the performance of the
    interpolation search could degrade.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will explore another variation of binary search known as exponential
    search, which can improve the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In binary search, we are searching the whole list for a given key. Exponential
    search improves binary search by deciding the lower and upper bound of the search
    so that we do not end up searching the whole list. It improves the number of comparisons
    we need to find an element. The search is done in the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We determine the bound size by looking for the first exponent *k* where the
    value of *2^k* is greater than the search item. Now, *2^k* and *2^(k-1)* become
    the upper bound and lower bound, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply binary search algorithm for the bound *2^k* and *2^(k-1)* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now implement the exponential search using our recursive `binarySearch`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, in step one, we are taking *i* steps to determine the boundary. So, the
    algorithm takes `O(log i)` complexity. We have to remember that here, *i* is much
    smaller than *n* . Then, we are doing a binary search with a bound of *2^j* to
    *2^(j-1)* where *j = log i* . We know binary search takes `O(log n)` complexity
    where *n* is the size of the list. However, since we are doing a smaller bound
    search, we are actually searching *2 ^(log i) \ - 2 ^(log i) - 1 = 2 ^(log i -
    1)* size. So, the complexity of this bound will be log *(2 ^(log i - 1) ) = log
    (i) - 1 = O(log i)* .
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the complexity of the exponential search is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(log i)` |'
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `O(log i)` |'
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: Search using hash table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hash table can be a very efficient data structure when it comes to search operations.
    Since hash tables store data in an associative manner, if we know where to look
    for the data, we can easily get the data quickly. In the hash table, each data
    has a unique index associated with it. If we know which index to look at, we can
    find the key very easily. Usually, in other programming languages, we have to
    use a separate hash function to calculate the hash index to store the value. The
    hash function is designed to generate the same index for the same key and also
    avoid collision. However, one of the great features of PHP is that PHP array itself
    is a hash table, in its underlying C implementation. Since an array is dynamic,
    we do not have to worry about the size of array or overflow array with many values.
    We need to store the values in an associative array so that we can associate the
    value with a key. The key can be the value itself if it is a string or an integer.
    Let''s run an example to understand searching with a hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have just built a simple random associative array where value and key are
    the same. Since we are using PHP array, though value can have a range of 1 to
    500, the actual array size is anything from 10 to 30\. If it were in any other
    language, we would have constructed an array with a size of 501 to accommodate
    this value to be a key. That is why the hash function is used to calculate the
    index. If we want, we can also use the PHP''s built-in function for hashing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter takes the type of algorithm we want to use for hashing.
    We can choose from md5, sha1, sha256, crc32, and so on. Each of the algorithms
    produces a fixed length hash output, which we can use as key for our hash table.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at our searching part, we can see that we are actually checking the
    associated index directly. This makes our searching in complexity `O(1)` . In
    PHP, it might be beneficial to use the hash table for quick searching even without
    using the hash function. However, we can always use the hash function if we want.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered searching based on arrays and linear structures. We
    will now shift our focus to hierarchical data structure searching such as searching
    trees and graphs. Though we have not discussed graphs yet (we will discuss them
    in the next chapter), we will keep our focus on tree searching, which can also
    be applied in graph searching.
  prefs: []
  type: TYPE_NORMAL
- en: Tree searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the best ways to search hierarchical data is to create a search tree.
    In [Chapter 6](text00138.html) , *Understanding and Implementing Trees* , we saw
    how to construct a binary search tree and increase the efficiency in searching.
    We have also discovered different ways to traverse a tree. Now, we will explore
    the two most popular ways of searching a tree structure commonly known as breadth
    first search (BFS) and depth first search (DFS).
  prefs: []
  type: TYPE_NORMAL
- en: Breadth first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a tree structure, a root is connected to its child node, and each child
    node can be represented as a tree. We have already seen this in [Chapter 6](text00138.html)
    , *Understanding and Implementing Trees* . In a breadth first search, popularly
    known as BFS, we start from a node (mostly root node) and first visit all adjacent
    or neighbor nodes before visiting the other neighbor nodes. In other words, we
    have to move level by level while we are applying BFS. As we search level by level,
    this technique is known as breadth first search. In the following tree structure,
    we can use BFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this tree, the BFS will follow the nodes like this: ![](Image00066.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode of BFS will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we have kept one queue for tracking which nodes we need to visit.
    We can keep another queue to hold the sequence of visits and return it to show
    the visit sequence. Now, we will implement the BFS using PHP 7.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing breadth first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we have not covered the graph in detail so far, we will keep our implementation
    for BFS and DFS strictly for tree structure. Also, we will use the generic tree
    structure we have seen in [Chapter 6](text00138.html) , *Understanding and Implementing
    Trees* , (not even binary tree). We will use the same `TreeNode` class to define
    our nodes and relationship with children. So, let''s now define the `Tree` class
    with BFS functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have implemented the BFS method inside the tree class. We are taking the
    root node as the starting point for the breadth first search. Here, we have two
    queues: one for keeping the nodes that we need to visit, and one for nodes which
    we have visited. We are also returning the visited queue at the end of the method.
    Let''s now imitate the tree we have seen at the beginning of the section. We want
    to put the data just like the tree shown in the image and also check whether the
    BFS actually returns our expected pattern of; ![](Image00066.jpg) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We are building the whole tree structure here by creating nodes and attaching
    them to root and other nodes. Once the tree is done, we are calling the `BFS`
    method to find the full sequence of traversal. The `while` loop at the end is
    printing sequences of our visited nodes. Here is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We have received our expected result. Now, if we want to search to find whether
    a node is there or not, we can add a simple condition check for our `$current`
    node value. If it matches, then we can return the visited queue.
  prefs: []
  type: TYPE_NORMAL
- en: The BFS has a worst complexity of **O** (*|V| + |E|* ), where *V* is the number
    of vertices or nodes and *E* is the number of edges or connections between the
    nodes. For space complexity, worst case is **O** (*|V|* ).
  prefs: []
  type: TYPE_NORMAL
- en: The graph BFS is similar, but with a minor difference. Since the graph can be
    cyclic (can create a loop), we need to make sure we are not visiting the same
    node again and again to create an infinite loop. In order to avoid revisiting
    graph nodes, we have to keep track of the node we have visited. For marking a
    visited node, we can either use a queue, or use a graph coloring algorithm. We
    will explore this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Depth first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depth first search, or DFS, is a search technique where we start searching
    from a node and go as deep as possible to the node from the target node through
    the branches. DFS is different from BFS, and we try to dig deeper instead of spreading
    out first. DFS grows vertically and backtracks when it reaches the end of the
    branch and moves the next available adjacent nodes until the search is over. We
    can take the same tree image from the last section, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we apply DFS here, the traversal will be ![](Image00068.jpg) . We start
    from the root and then visit the first child, which is **3** . However, instead
    of going to **10** like the BFS, we will explore the child nodes of **3** and
    do this repeatedly until we reach the bottom of the branch. In BFS, we had taken
    the iterative approach. For DFS, we will take the recursive approach. Let''s now
    write the pseudocode for DFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implementing depth first search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pseudocode for DFS looks straightforward. In order to track the sequence
    of node visits, we need to use a queue, which will track the nodes inside our
    `Tree` class. Here is our implementation of `Tree` class with recursive DFS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have added one extra property in the tree class `$visited`
    to keep track of the visited nodes. When we are calling the `DFS` method, we are
    adding the node to the queue. Now, if we use the same tree structure from the
    previous section, and just add the DFS call and fetch the visited part, it will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Since DFS does not return anything, we are using the class property `visited`
    to get the queue so that we can show the sequence of visited nodes. If we run
    this program in console, we will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The results correspond to what was expected. If we need an iterative solution
    for DFS, we have to remember that we need to use stack instead of queue to track
    the next node to visit. However, as stack follows the LIFO principle, for our
    mentioned graph image, the output will be different from our initial thought.
    Here is the implementation using the iterative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks very similar to our iterative BFS algorithm. The main difference is
    the use of stack data structure instead of queue data structure to store the visited
    nodes. It will also have an impact on the output. The preceding code will produce
    the output `8 → 10 → 14 → 13 → 3 → 6 → 7 → 4 → 1` . This is different from our
    previous output shown in the last section. As we are using stack, the output is
    actually correct. We are using stack to push the child nodes of a particular node.
    For our root node, which has value **8** , we have the first child node with value
    of **3** . It is pushed to the stack, and then, the second child node of root
    has the value of **10** and is also pushed to the stack. Since value **10** was
    pushed last, it will come first, following the LIFO principle of stack. So, the
    ordering is always going to be starting from the last branch to the first branch
    if we are using stack. However, if we want to keep the node ordering from left
    to right, then we need to make a small adjustment in our DFS code. Here is the
    code block with the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference from the previous code block is that we are adding the
    following line before visiting the child nodes from a particular node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since stack does the Last-In, First-Out (LIFO), by reversing, we are making
    sure the first node is visited first, as we reversed the order. In fact, it will
    simply work as a queue. This will produce the desired sequence as shown in the
    DFS section. If we have a binary tree, then we do it easily without requiring
    any reversal as we can choose to push the right child first, followed by the left
    child node to pop the left child first.
  prefs: []
  type: TYPE_NORMAL
- en: DFS has a worst complexity of **O** (*|V| + |E|* ), where *V* is the number
    of vertices or nodes and *E* is the number of edges or connections between the
    nodes. For space complexity, the worst case is **O** (*|V|* ), which is similar
    to BFS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed different searching algorithms and their complexities.
    You learned how to improve searching with a hash table to get a constant time
    result. We also explored BFS and DFS, two of the most important methods for hierarchical
    data searching. We will use similar concepts for graph data structure, which we
    are about to explore in the next chapter. Graph algorithms are crucial for solving
    many problems and are used heavily in the programming world. Let's get going with
    another interesting topic - the graph.
  prefs: []
  type: TYPE_NORMAL
