- en: Chapter 9. Assessment of Web Servers and Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the techniques of assessing the web servers
    and web applications that are a part of the vast majority of the environments
    we may encounter. We will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the OWASP Top Ten attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying web application firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Penetrating web application firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with information on one of the most popular attack
    vectors and the attack vector that is virtually accessible on any environment.
    Virtually all organizations will require some form of online presence. Therefore,
    it is a good bet we will have a web server and probably some web applications
    that we can use to attempt to compromise a client system and/or network.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the OWASP Top Ten attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Open Web Application Security Project** (**OWASP**) group is one of the
    best resources we can use for gathering information on not only the different
    types of attacks but also the ways to defend from them and secure coding guidance.
    As we are in our testing mode, we will concentrate on the attacks. An excellent
    reference for this is the OWASP Top Ten attacks. You can download the latest version
    at [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project).
  prefs: []
  type: TYPE_NORMAL
- en: The OWASP group also has an excellent tutorial called WebGoat. You can find
    more information about the tutorial at [https://www.owasp.org/index.php/OWASP/Training/OWASP_WebGoat_Project](https://www.owasp.org/index.php/OWASP/Training/OWASP_WebGoat_Project).
  prefs: []
  type: TYPE_NORMAL
- en: An advantage of selecting the OWASP Broken Web Application virtual machine is
    the tools that come with it. Once you have started the OWASP virtual machine,
    you will have an address assigned for the interface that we need to connect to.
    For this example in the book, the interface has been assigned the IP address of
    10.2.0.132, so all of the examples will be using this address.
  prefs: []
  type: TYPE_NORMAL
- en: Once the machine has booted, we will access it from a web browser. So, we open
    the browser of our choice and enter `http://10.1.0.132` to bring up the home page
    for the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need a VMnet2 switch connected to your host machine to be able to access
    the virtual machine from a browser on the host. If you use a virtual machine,
    then it is not required as long as you are on the VMnet2 switch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Analyzing the OWASP Top Ten attacks](img/477-1_09-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The page that is displayed once the user has logged in
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to look at specific attacks using the capabilities contained
    within this project.
  prefs: []
  type: TYPE_NORMAL
- en: Injection flaws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Injection flaws has been the number one attack for numerous versions of the
    OWASP Top Ten, and it continues to be in the lead. The most popular type of injection
    is the infamous SQL injection. Despite warning developers and providing numerous
    resources so that they can work at designing secure applications, we continue
    to see that this attack is still successful. With injection attacks, this is only
    one of the many methods. We can perform HTML, XML, and LDAP injections. The main
    component of all these attacks is getting the applications to execute something
    that is not intended, or getting access to data without authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the tool WebGoat to see how this is done. On the OWASP Broken Web
    Application homepage, click on **OWASP WebGoat** to bring up the login page. In
    the login page, enter the username as `guest` and the password as `guest` to enter
    into the tutorial. An example of the front page of the tutorial is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injection flaws](img/477-1_09-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Start WebGoat** to start the tool. This will bring you to the interface
    of the available training lessons contained within the tool. As you can see, there
    are a significant number of lessons available and as such, it would be beneficial
    to spend time working through these lessons. As we are discussing injection flaws,
    you will see an item for it on the left-hand side of the menu. Click on this and
    expand the different lessons within the topic. An example is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injection flaws](img/477-1_09-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Different lessons within the topic (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'As the previous screenshot shows, there are a variety of flaws we can work
    with, and the predominant ones are to do with the SQL injection. We will look
    at the fifth one on the list, so click on **String SQL Injection** to bring up
    the lesson''s first page with the description. An example of this is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injection flaws](img/477-1_09-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, and as you will see while reviewing the tutorial,
    there are **Hints** as well as **Solution Videos** that you can refer to for help
    completing lessons. Many of you reading this will probably know that the simplest
    way to test for an SQL injection is to enter a single quote (`''`) character and
    see whether we make it past the frontend to the backend database that will produce
    the error message. We will try that now. Enter a single quote character as the
    name and then click on **Go!**. This will submit it to the application. An example
    of the result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injection flaws](img/477-1_09-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, what does the result in the previous screenshot show us? It shows us that
    we now have a proof that the character we entered made it through the frontend
    application because it was placed into a query! If the frontend would have caught
    it, then it would not have become a part of a query. The error we see is because
    this is not a valid SQL query. So now it is a matter of entering the string that
    will evaluate to true. The most common string we use with SQL injection attacks
    is `'' OR 1=1 --` to dump the contents of the database when the data input is
    not properly sanitized. The resulting output that is returned when we use this
    common attack string is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Injection flaws](img/477-1_09-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have been successful and we have dumped
    the entire contents of the database. The output also informs us that the lesson
    has switched to a parameterized query for us to try it again. You can attempt
    this, but we will let you know ahead of time that once the query is switched to
    the parameter-based condition, the attack will no longer work. There are numerous
    SQL injection lessons here and you are encouraged to explore them. We will move
    on to the next item of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Broken authentication and session management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an application is designed, it is imperative that the designer protects
    the tokens and session keys used for authentication. Unfortunately, this is an
    area that is often neglected or implemented poorly from a security standpoint
    and as such, provides us with an excellent vector for attack. This attack usually
    involves some form of capturing of an authentication token and then cracking the
    token or using the token to assume someone''s identity. Within our WebGoat tool,
    we have two sections for learning about these attacks, and they are authentication
    flaws and session management flaws. We will look at the authentication flaws.
    In the WebGoat tutorial, on the left-hand side of the screen, navigate to **Authentication
    Flaws** | **Basic Authentication** to bring up the lesson. An example is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broken authentication and session management](img/477-1_09-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you read through the information for the lesson, it is apparent that we need
    to intercept the traffic from the application and the client to see how it is
    coded. The most common way of doing this is to use a proxy, and there are a number
    of them that you can use. We will use a simple one, which is a plugin for Firefox,
    **Tamper Data**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have added the plugin into your browser, we are ready to capture the
    traffic from the server. In your Firefox browser, navigate to **Tools** | **Tamper
    Data** to bring up the tool. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broken authentication and session management](img/477-1_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To start capturing the data with the proxy, click on **Start Tamper**. The
    next thing you will do is return to the WebGoat lesson and click on the **Submit**
    button to send the query to the application. You will get a message when the request
    is received by the tool, and if you get more than one, then make sure that the
    one you select to tamper with has the URL of the OWASP virtual machine. An example
    of the request needed is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broken authentication and session management](img/477-1_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you review the information from the intercept, you will see that we have
    **Cookie** and **Authorization** fields, which we will concentrate on. We will
    also focus on the value in the **Authorization** field. This is Base64 encoded,
    and there are many ways you can decode the value. A website for this can be found
    at [http://base64-decode.com](http://base64-decode.com), which will take the values
    and decode it for you. The decoded value comes out as `guest:guest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have the information we need to finish the lesson; at least it appears
    that way. We will return to the WebGoat lesson and enter the name of the authentication
    field, which is **Authorization**, and the value of the encoded string as `guest:guest`,
    and click on **Submit** to load the values into the application. An example of
    the expected result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broken authentication and session management](img/477-1_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have been successful. However, we have
    more to do; this is not just a one-step lesson. We now need to try and get the
    application to accept our login as `basic:basic`. To accomplish this, we need
    to corrupt the data and force the application to authenticate after the corruption.
    When you follow the instructions of the lesson, you see that it says to select
    the **Basic Authentication** lesson to continue on with the challenge. When you
    do this, you will be presented with the page in **Tamper Data**: click on **Tamper**
    to open the page so you can modify it. The key here is that we need to corrupt
    both of the fields, **Cookie** and **Authorization**, by deleting a character
    from each. Once the application detects the corruption, it will prompt for the
    credentials again, and when it does, enter `basic` as the username and `basic`
    as the password, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broken authentication and session management](img/477-1_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you have entered the credentials, click on **OK** to submit the data to
    the application. Examine the intercepted query and you will notice that your password
    is now `basic` and it is Base64 encoded. We have now authenticated `basic` as
    the user, but we are not done yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to convince the WebGoat tool that we are the user `basic`, we have
    done this on the server side. So, we now need to convince the WebGoat tool. The
    easiest way to do this is to corrupt **JSESSIONID** you intercept, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broken authentication and session management](img/477-1_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, you need to enter `novalidsession` to corrupt
    the session and force WebGoat to request the credentials again, and this will
    authenticate you as the user `basic`. Once this has occurred, you click on the
    **Basic Authentication** link to complete the lesson. An example of this is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broken authentication and session management](img/477-1_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen after clicking on the Basic Authentication link (the cropped text is
    not important)
  prefs: []
  type: TYPE_NORMAL
- en: This is the process with web application testing; there are so many different
    ways to write the code, and you have to analyze and interpret what the code is
    doing. In this lesson, we had to first intercept the query to identify what the
    names were of the parameters that we needed to interact with. Once we had done
    this, we had to corrupt the server side first and then the client side to successfully
    complete the requirements of the lesson. There are numerous lessons here, and
    the more you practice them, the better you will get at recognizing characteristics
    of authentication and session management.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another attack that has stood the test of time is the **Cross-Site Scripting**
    (**XSS**) attack. This is the process where an application takes untrusted data
    and sends it to a web browser without proper validation. There are two types of
    validation, reflected and stored, which have been used very successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we use the WebGoat tool, we will look at another method that we can
    use in the OWASP machine:'
  prefs: []
  type: TYPE_NORMAL
- en: At the main page of the machine, scroll down until you see **Applications for
    Testing Tools**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **OWASP-ZAP-WAVE** to open the applications we want to test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Active vulnerabilities** | **Cross Site Scripting** | **Simple
    XSS** in a form parameter to bring up a form for us to test XSS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the form field, enter `<script>alert("Hello")</script>` and click on **Submit**
    to test for XSS. An example is shown in the following screenshot:![Cross-Site
    Scripting](img/477-1_09_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have successfully conducted XSS, we will turn our attention to
    the lessons in the WebGoat tool:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the WebGoat tutorial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have started the program, click on the **Cross Site Scripting** link
    and expand it. An example of the lesson we are going to work on is shown in the
    following screenshot:![Cross-Site Scripting](img/477-1_09_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will start with **Stage 1**. Click on it and read the directions for the
    lesson. As the directions state, we are going to execute a XSS attack on Jerry.
    To do this, we have to store the information into the record for Tom so that when
    Jerry accesses it, he will fall into the XSS trap.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We show only pop-up boxes to make the point that there are many more things
    you can do once you have discovered the weakness. There are a number of Java calls
    that can be used once you find the vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the directions and log in to the application as Tom:'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have logged in as Tom, you navigate to **View Profile** | **Edit Profile**
    to access Tom's profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have accessed it, you will enter the script tag into the address field.
    In the **Street** field, enter `<script>alert("Hello")</script>` and then click
    on **Upload Profile** to upload the profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you will log out and log back in as Jerry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have logged in as Jerry, you will navigate to **Tom Cat** | **View
    Profile** and see if you are successful. An example is shown in the following
    screenshot:![Cross-Site Scripting](img/477-1_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will not execute **Stage 2** as it will change the code to prevent the attack
    and we are on the offense here, so we are not looking to do any defense. We will
    next perform the **Stage 3** lesson using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Stage 3: Stored XSS Revisited** to bring up the login page, then
    start the next stage by reading the directions.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we will do is log in as `David`, then navigate to the **Bruce**
    | **View Profile** record, and verify that `David` is a victim of XSS. An example
    is shown in the following screenshot:![Cross-Site Scripting](img/477-1_09_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the previous screenshot shows, rather than just a pop-up window, we have
    now accessed the cookie by using `document.cookie` inside the alert box.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to move on to **Stage 5**. Again, we will not perform **Stage
    4** because it is a matter of putting in a defense, and we are not looking for
    this now. You may, however, work with the other stages. Just remember that you
    will need to use the developer package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In **Stage 5**, we are going to work with the reflected type of XSS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Stage 5: Reflected XSS** to open the lesson and read the directions
    that are required for this stage. As the directions state, you have to embed a
    XSS string in the search function of the application.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing we need to do is log in as one of the users. As we have the
    user `Larry` listed in the application already, we will use this user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in as the user `Larry` and click on **SearchStaff** to open the search portion
    of the application code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Name** field, enter `<script>alert("You are Hacked")</script>` and
    then click on the **FindProfile** button to run the script. An example of the
    result is shown in the following screenshot:![Cross-Site Scripting](img/477-1_09_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it! You have conducted a number of different XSS attacks, and they really
    are relatively easy to prevent. Yet, we continue to see these in web applications,
    and they will remain as a viable attack vector for some time.
  prefs: []
  type: TYPE_NORMAL
- en: Insecure direct object references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a direct object reference, a developer references a file or some other
    object without using any form of authentication or access control check. When
    we discover this, we can manipulate the data and access it without providing any
    authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will once again refer to the WebGoat tool to work with this attack against
    an application. The area within OWASP WebGoat that you want to focus on is **Access
    Control Flaws**. Once you have expanded it, you will see there are a number of
    lessons for us to work with. The list of lessons is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insecure direct object references](img/477-1_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The lesson we want to open is the second one on the list. Click on **Bypass
    a Path Based Access Control Scheme** and read the directions for the lesson. The
    key to any path-based control protection is that we can break out of the intended
    directory and access a file that is located in another area. The first page of
    the application of the lesson is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insecure direct object references](img/477-1_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, the challenge is to modify the path and access a file outside of the current
    directory; in this case, the file is **tomcat-users.xml**. How do you think we
    can do this? We need to intercept something, and to do that, we have to use a
    proxy to capture the query. Earlier, we used a tool called Tamper Data and we
    will use it again. First, let''s start a workspace to record the information that
    we have so far. We will use Notepad, but you can use any program of your choice.
    We need to copy and paste the current directory path and the path to the file
    that we want to access in this document. An example of our workspace is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insecure direct object references](img/477-1_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we look at the information in our workspace, we see that there are several
    directories in the path of the current directory before we get to the `tomcat`
    directory. However, there is one concern. The current directory we are given has
    a `tomcat6` directory but our target file directory does not have this. It does
    say in the instructions that the path might be different and in this case, it
    is. We need to make the `tomcat` directory match the current directory as `tomcat6`.
    The key to breaking the access control is to break out of the directory using
    the `../` directory traversal technique. As there are four directories before
    the `tomcat6` folder, we need to enter that many directory traversals as a minimum.
    Consequently, we can always enter more to be safe. An example of the workspace
    for the string to attempt to bypass access control is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Insecure direct object references](img/477-1_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following process is to intercept the query with the Tamper Data tool and
    then paste our path into the field that contains the file we are trying to upload
    from the application:'
  prefs: []
  type: TYPE_NORMAL
- en: We will navigate to **OffByOne.html** | **View File** and intercept the query.
    An example of the query that is intercepted is shown in the following screenshot:![Insecure
    direct object references](img/477-1_09_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The intercepted query shows that we are looking at the **File** field and this
    is where we need to place our prepared string.
  prefs: []
  type: TYPE_NORMAL
- en: Paste the string in the field and click on **OK** to send the string into the
    application. Return to the WebGoat lesson and review what happened. An example
    is shown in the following screenshot:![Insecure direct object references](img/477-1_09_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the previous screenshot shows, we were not successful in our first try, but
    the error message tells us that we seem to be within one directory of our path.
    We will add another directory traversal to our string and see what happens. An
    example of the results after one more directory traversal was added is shown in
    the following screenshot:![Insecure direct object references](img/477-1_09_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are finally successful and have broken the path-based access control. This
    can be a time-consuming process, which is why we typically use tools with web
    application testing to get us to identify areas to investigate further.
  prefs: []
  type: TYPE_NORMAL
- en: Security misconfiguration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common method of attack is to look for default configurations or names that
    are set up by the administrator or just left in their install state. With web
    applications, there is almost always some form of a configuration access that
    can be used to configure or administer a site. We have a lesson for this in the
    WebGoat tool. Navigate to **Insecure Configuration** | **Forced Browsing** to
    open the lesson. As you can read in the directions, there is normally some form
    of configuration that is accessible to perform maintenance. We can try some of
    the different file names, but as the OWASP machine is a Linux machine, the most
    common configuration file for these machines is the `conf` file. So, in the browser,
    change the URL to `http://10.2.0.132/WebGoat/conf` to see whether there is a configuration
    file located here. An example of the results of this is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Security misconfiguration](img/477-1_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it! We have found a configuration access that should not be allowed to
    the public, but it is. This is a common mistake that websites have.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive data exposure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The majority of web applications do not properly protect the data that they
    either work with or store. It is common to find data either unprotected with encryption
    or poorly encoded. Furthermore, when the application is working with the data,
    it is exposed in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the WebGoat tool, there is a lesson that we can use to become more familiar
    with the different encoding techniques. Navigate to **Insecure Storage** | **Encoding
    Basics** to open the lesson; an example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sensitive data exposure](img/477-1_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The lesson is pretty straightforward, so we will not cover any more details
    of it here. You are encouraged to enter several strings and then review the results
    in the table provided.
  prefs: []
  type: TYPE_NORMAL
- en: Missing function-level access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This weakness is a result of the developer failing to verify the function-level
    access before they make the functionality visible to the **user interface** (**UI**).
    When this is discovered, you can forge requests and potentially gain access without
    proper authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Request Forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the **Cross-Site Request Forgery** (**CSRF**) attack, we need a user to be
    logged into a site with a session established that uses a cookie. When these parameters
    are met, the attack takes the included authentication information and submits
    it to a vulnerable application. As the application has the authentication information
    stored, the request is seen as legitimate.
  prefs: []
  type: TYPE_NORMAL
- en: Within the WebGoat tool, we have a number of lessons for CSRF. They are located
    in the section on Cross-Site Scripting XSS. In the WebGoat tool, navigate to **Cross-Site
    Scripting (XSS)** | **Cross Site Request Forgery** to open the lesson and review
    the directions for the lesson.
  prefs: []
  type: TYPE_NORMAL
- en: For this attack, we need to add a transfer function to an embedded URL to get
    the users authenticated information to be passed and then used to authenticate
    our transaction. We will append the code to the URL to transfer funds. As the
    directions state, we can copy the URL by right-clicking on the lesson title on
    the left-hand side of the page and saving it to the clipboard. We want to use
    the `<IMG>` tag to store our URL. The process would be to send an e-mail and get
    the user to click on a link while they are logged in to the application we are
    tricking to use for the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to enter information in two areas. The first is **Title** and the second
    is **Message**. Let''s do this now in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `CSRF-1` as the name of the title and then enter the following string
    as the message, bearing in mind that the IP address may be different in your attack.
    Enter the following as the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-Site Request Forgery](img/477-1_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The CSRF screen where the code is entered (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: Once you have verified the command, click on the **Submit** button. This will
    place your title in the application at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you click on it, start your Tamper Data proxy and intercept the request.
    An example of the intercepted request is shown in the following screenshot:![Cross-Site
    Request Forgery](img/477-1_09_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have reviewed the information in the intercepted query, click on **OK**
    and let the query be sent to the application. If required, refresh the WebGoat
    lesson. You should now see the green checkmark that shows you were successful,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-Site Request Forgery](img/477-1_09_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are several more of these lessons available for you to practice CSRF,
    and you are encouraged to work through them to perfect your skills, knowledge,
    and understanding of web application attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Using known vulnerable components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a common practice in application development to use existing libraries
    and functions to create the code, and this has been leveraged recently in attacks.
    If we can infect a library, framework, or other popular components, then every
    one of the applications that uses it will be vulnerable. This is one of the most
    effective ways to spread vulnerabilities and is something that is becoming more
    and more common, and it was added to the list of top attacks in 2013 based on
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Invalidated redirects and forwards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this attack, we take advantage of the fact that many web applications will
    use redirects and forwards without proper validation, and this can result in redirection
    of traffic to malware and other malicious sites.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying web application firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are more than likely going to encounter a **web application firewall** (**WAF**)
    when we are testing. These are designed to identify most of the attacks we have
    covered in this chapter (well, most of the URL-based attacks). We will once again
    turn to the Kali Linux distribution to identify a WAF. You will need your Kali
    Linux machine and your WAF machine we created in [Chapter 6](ch06.html "Chapter 6. Creating
    an External Attack Architecture"), *Creating an External Attack Architecture*.
  prefs: []
  type: TYPE_NORMAL
- en: Once the machines are up and running, the first thing we will do is identify
    we have a website protected by a web application firewall. We have several methods
    to do this, each with varying success. The first method we will try is the **Nmap**
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your Kali Linux machine, open a terminal window and enter `nmap –p 80 -–script
    –http-waf-detect <target IP address>`. This scripting engine will try to determine
    whether there is a web application firewall present. An example is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying web application firewalls](img/477-1_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, the script did not detect that we are running
    the WAF, so it is not always going to work. We will next take a look at the **dotDefender**
    console and see if it detected our scan. To do this, we need to open a browser
    and enter the address to the firewall and then log in. An example is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying web application firewalls](img/477-1_09_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, it detects the script running against it,
    but unfortunately, it does not tell us if there is a WAF running or not. So, we
    will look at another tool. In Kali, we have a tool for this. Navigate to **Applications**
    | **Kali** | **IDS/IPS Identification** | **Wafw00f**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying web application firewalls](img/477-1_09_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the tool is open, enter `wafw00f –v www.example.com` in the terminal window
    to run a scan against the site. We are scanning the site and comparing information
    that is received from our probing. An example of the results is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying web application firewalls](img/477-1_09_34updated.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the results show, the site appears to be behind a firewall. Now, we will
    use the tool to scan our dotDefender machine. We do this by changing the target
    to the IP address of our machine. An example of the results is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Identifying web application firewalls](img/477-1_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, it appears that the latest version of dotDefender
    is not detected using the wafw00f tool. This is the reality of security testing,
    once something has been out for some time, there are teams of people trying to
    figure out ways to change or at least modify the way a product reacts to a tool
    when the tool is used against it. This is why we build the lab environment and
    see what does and does not work. Sometimes, we will get lucky and there will be
    another way that we can identify the error; moreover, the error message in some
    cases can list the identity of the device. This is all a matter of trial and error.
  prefs: []
  type: TYPE_NORMAL
- en: Penetrating web application firewalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed previously, it can be a challenge to evade detection, and
    this is on these same lines as it will depend on how the administrator has configured
    the policy. There are excellent references on the Internet you can use to see
    whether your obfuscation technique will work. The free and open source WAF **ModSecurity**
    provides a site where you can test the string to see if it might be detected by
    a WAF. You will find the site at this location [http://www.modsecurity.org/demo](http://www.modsecurity.org/demo).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the site has opened, you will see that there is an area to post different
    strings and see the results. Before you do this, you will also see that they have
    a list of websites that many of the commercial vendors use to demonstrate their
    tools. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Penetrating web application firewalls](img/477-1_09_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing a list of the websites that many of the commercial vendors use
    to demonstrate their tools (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **ModSecurity CRS Evasion Testing Demo** link on the page. This
    will test the string against the **Core Rule Set** signatures of the ModSecurity
    tool, and you will find the area to enter a potential obfuscated script to see
    if it is detected. Not only does it tell you if it is detected, but it also provides
    a ranking with a numerical score of the string. For our first example, we will
    try a simple one to see how the form works. In the form box, enter the classic
    SQL injection string `'' OR 1=1 –-` and click on the **Send** button and view
    the results. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Penetrating web application firewalls](img/477-1_09_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have been detected! Well, we would hope
    so as we used the most common and classic string to test for. We also see that
    we have a score of a 35\. We will see if we can lower the score. Enter this string:
    `1'' AND non_existant_table =''1`. An example of the result is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Penetrating web application firewalls](img/477-1_09_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Darn! We are detected again! At least there is some good news; we have lowered
    our score to a 25\. This is the process of how we try to find a string with either
    a lower score or no detection. We will try one more string for SQL, then move
    on with one string for XSS. In the payload window, enter this string: `&#49&#39&#32&#79&#82&#32&#39&#49&#39&#61&#39&#49`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Penetrating web application firewalls](img/477-1_09_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are successful! This is a string that you find in the **SQL Inject-Me**
    tool from Security Compass. You can find the tool at their website [http://www.securitycompass.com](http://www.securitycompass.com).
    We are now ready to see whether we can find a XSS string that does not get detected.
    We will save you some time and try one that we think has a pretty good chance
    of either getting a low score or not being detected. In the payload window, enter
    this string: `prompt%28%27xss%27%29`. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Penetrating web application firewalls](img/477-1_09_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again we are successful. So now we have a string for XSS and SQL injections
    that is not detected. Of course, the reality is that we have submitted these strings,
    so someone might do their homework, and then we will be detected by the time you
    are reading this book. If this happens, our job is to continue to work with different
    things until we find one that works. Furthermore, this just potentially gets us
    through the WAF, from there it depends on whether the application developer has
    used secure coding guidelines or best practices. Welcome to the world of professional
    security testing!
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, we have not specifically set a topic point on tools. We
    have, for the most part, remained process-centric and discussed some tools within
    each chapter. For web application testing, this is a different matter. As you
    have seen throughout this chapter, there are many varieties of input and ways
    to interact with web applications, and this is the challenge with this form of
    testing. Therefore, it is usually best handled with tools to get the bulk data
    and then manually go and investigate areas of interest for the bulk data. There
    are a large number of tools out there, and we will not go through them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the tools that we like to use that has both a free version and a commercial
    version is **Burp Suite**. We like it because it allows us to do a wide variety
    of things when we are testing, and we also like the fact that the commercial version
    is a very reasonable price. You can find information about the tool at [http://www.portswigger.net](http://www.portswigger.net).
    The free version can also be found in the Kali Linux distribution. To access it,
    navigate to **Applications** | **Web Applications** | **Web Application Fuzzers**
    | **burpsuite** to open the tool. An example of the menu from the tool is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tools](img/477-1_09_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the tool has many features that can assist
    us when it comes to web application testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the assessment of web servers and web applications.
    We started the chapter with a discussion on the OWASP Top Ten. Following the discussion,
    we used the WebGoat tool and performed a number of lessons that show the concepts
    and techniques for web application testing.
  prefs: []
  type: TYPE_NORMAL
- en: Following the work with the OWASP Top Ten, we looked at methods to identify
    a web application firewall between us and the target. We used the wafw00f tool
    to potentially detect the type of protection that is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Once we had looked at how to detect a WAF, we then discussed how to penetrate
    it. We looked at methods of obfuscation we can use to try and get past the protection
    provided by the WAF. We submitted our sample strings to the ModSecurity demo site
    and we successfully evaded detection with both an SQL injection string and a XSS
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter with a discussion on the need for tools when
    it comes to web testing, especially web application testing.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. You have now practiced web application attacks and
    methods of detecting and evading a firewall.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at testing of flat and internal networks.
  prefs: []
  type: TYPE_NORMAL
