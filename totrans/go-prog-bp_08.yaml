- en: Chapter 8. Filesystem Backup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many solutions that provide filesystem backup capabilities. These
    include everything from apps such as Dropbox, Box, Carbonite to hardware solutions
    such as Apple's Time Machine, Seagate, or network-attached storage products, to
    name a few. Most consumer tools provide some key automatic functionality, along
    with an app or website for you to manage your policies and content. Often, especially
    for developers, these tools don't quite do the things we need them to. However,
    thanks to Go's standard library (that includes packages such as `ioutil` and `os`
    ) we have everything we need to build a backup solution that behaves exactly as
    we need it to.
  prefs: []
  type: TYPE_NORMAL
- en: For our final project, we will build a simple filesystem backup for our source
    code projects that archive specified folders and save a snapshot of them every
    time we make a change. The change could be when we tweak a file and save it, or
    if we add new files and folders, or even if we delete a file. We want to be able
    to go back to any point in time to retrieve old files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically in this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to structure projects that consist of packages and command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pragmatic approach to persisting simple data across tool executions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the `os` package allows you to interact with a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to run code in an infinite timed loop, while respecting *Ctrl* + *C*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `filepath.Walk` to iterate over files and folders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to quickly determine if the contents of a directory have changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `archive/zip` package to zip files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build tools that care about a combination of command-line flags and normal
    arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by listing some high-level acceptance criteria for our solution
    and the approach we want to take:'
  prefs: []
  type: TYPE_NORMAL
- en: The solution should create a snapshot of our files at regular intervals, as
    we make changes to our source code projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to control the interval at which the directories are checked for changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code projects are primarily text-based, so zipping the directories to generate
    archives will save a lot of space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build this project quickly, while keeping a close watch over where we
    might want to make improvements later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any implementation decisions we make should be easily modified if we decide
    to change our implementation in the future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will build two command-line tools, the backend daemon that does the work,
    and a user interaction utility that will let us list, add, and remove paths from
    the backup service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common in Go solutions to have, in a single project, both a package that
    allows other Go programmers to use your capabilities, and a command-line tool
    that allows end users to use your code.
  prefs: []
  type: TYPE_NORMAL
- en: A convention is emerging to structure the project by having the package in the
    main project folder, and the command-line tool inside a subfolder called `cmd`
    , or `cmds` if you have multiple commands. Because all packages (regardless of
    the directory tree) are equal in Go, you can import the main package from the
    subpackages, knowing you'll never need to import the commands from the main package.
    This may seem like an unnecessary abstraction, but is actually quite a common
    pattern and can be seen in the standard Go tool chain with examples such as `gofmt`
    and `goimports` .
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for our project we are going to write a package called `backup`
    , and two command-line tools: the daemon and the user interaction tool. We will
    structure our project in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Backup package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are first going to write the `backup` package, of which we will become the
    first customer when we write the associated tools. The package will be responsible
    for deciding whether directories have changed and need backing up or not, as well
    as actually performing the backup procedure too.
  prefs: []
  type: TYPE_NORMAL
- en: Obvious interfaces?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to think about when embarking on a new Go program is whether
    any interfaces stand out to you. We don't want to over-abstract or waste too much
    time up front designing something that we know will change as we start to code,
    but that doesn't mean we shouldn't look for obvious concepts that are worth pulling
    out. Since our code will archive files, the `Archiver` interface pops out as a
    candidate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder inside your `GOPATH` called `backup` , and add the following
    `archiver.go` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An `Archiver` interface will specify a method called `Archive` that takes source
    and destination paths and returns an error. Implementations of this interface
    will be responsible for archiving the source folder, and storing it in the destination
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defining an interface up front is a nice way to get some concepts out of our
    heads and into code; it doesn't mean this interface can't change as we evolve
    our solution as long as we remember the power of simple interfaces. Also, remember
    that most of the I/O interfaces in the `io` package expose only a single method.
  prefs: []
  type: TYPE_NORMAL
- en: From the very beginning, we have made the case that while we are going to implement
    ZIP files as our archive format, we could easily swap this out later with another
    kind of `Archiver` format.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ZIP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the interface for our `Archiver` types, we are going to implement
    one that uses the ZIP file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `struct` definition to `archiver.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are not going to export this type, which might make you jump to the conclusion
    that users outside of the package won't be able to make use of it. In fact, we
    are going to provide them with an instance of the type for them to use, to save
    them from having to worry about creating and managing their own types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following exported implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This curious snippet of Go voodoo is actually a very interesting way of exposing
    the intent to the compiler, without using any memory (literally 0 bytes). We are
    defining a variable called `ZIP` of type `Archiver` , so from outside the package
    it's pretty clear that we can use that variable wherever `Archiver` is needed—if
    you want to zip things. Then we assign it with `nil` cast to the type `*zipper`
    . We know that `nil` takes no memory, but since it's cast to a `zipper` pointer,
    and given that our `zipper` struct has no fields, it's an appropriate way of solving
    a problem, which hides the complexity of code (and indeed the actual implementation)
    from outside users. There is no reason anybody outside of the package needs to
    know about our `zipper` type at all, which frees us up to change the internals
    without touching the externals at any time; the true power of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another handy side benefit to this trick is that the compiler will now be checking
    whether our zipper type properly implements the `Archiver` interface or not, so
    if you try to build this code you''ll get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We see that our `zipper` type does not implement the `Archive` method as mandated
    in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the `Archive` method in test code to ensure that your types
    implement the interfaces they should. If you don''t need to use the variable,
    you can always throw it away by using an underscore and you''ll still get the
    compiler help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To make the compiler happy, we are going to add the implementation of the `Archive`
    method for our `zipper` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `archiver.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have to also import the `archive/zip` package from the Go standard
    library. In our `Archive` method, we take the following steps to prepare writing
    to a ZIP file:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `os.MkdirAll` to ensure the destination directory exists. The `0777` code
    represents the file permissions with which to create any missing directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `os.Create` to create a new file as specified by the `dest` path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is created without error, defer the closing of the file with `defer
    out.Close()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `zip.NewWriter` to create a new `zip.Writer` type that will write to the
    file we just created, and defer the closing of the writer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have a `zip.Writer` type ready to go, we use the `filepath.Walk` function
    to iterate over the source directory `src` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filepath.Walk` function takes two arguments: the root path, and a callback
    function `func` to be called for every item (files and folders) it encounters
    while iterating over the file system. The `filepath.Walk` function is recursive,
    so it will travel deep into subfolders too. The callback function itself takes
    three arguments: the full path of the file, the `os.FileInfo` object that describes
    the file or folder itself, and an error (it also returns an error in case something
    goes wrong). If any calls to the callback function result in an error being returned,
    the operation will be aborted and `filepath.Walk` returns that error. We simply
    pass that up to the caller of `Archive` and let them worry about it, since there''s
    nothing more we can do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each item in the tree, our code takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `info.IsDir` method tells us that the item is a folder, we just return
    `nil` , effectively skipping it. There is no reason to add folders to ZIP archives,
    because anyway the path of the files will encode that information for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error is passed in (via the third argument), it means something went wrong
    when trying to access information about the file. This is uncommon, so we just
    return the error, which will eventually be passed out to the caller of `Archive`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `os.Open` to open the source file for reading, and if successful defer its
    closing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `Create` on the `ZipWriter` object to indicate that we want to create a
    new compressed file, and give it the full path of the file, which includes the
    directories it is nested inside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `io.Copy` to read all of the bytes from the source file, and write them
    through the `ZipWriter` object to the ZIP file we opened earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `nil` to indicate no errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will not cover unit testing or **Test-driven Development** ( **TDD**
    ) practices, but feel free to write a test to ensure that our implementation does
    what it is meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are writing a package, spend some time commenting the exported pieces
    so far. You can use `golint` to help you find any exported pieces you may have
    missed.
  prefs: []
  type: TYPE_NORMAL
- en: Has the filesystem changed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest problems our backup system has is deciding whether a folder
    has changed or not in a cross-platform, predictable, and reliable way. A few things
    spring to mind when we think about this problem: should we just check the last
    modified date on the top-level folder? Should we use system notifications to be
    informed whenever a file we care about changes? There are problems with both of
    these approaches, and it turns out it''s not a trivial problem to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: We are instead going to generate an MD5 hash made up of all of the information
    that we care about when considering whether something has changed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `os.FileInfo` type, we can see that we can find out a lot of
    information about a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To ensure we are aware of a variety of changes to any file in a folder, the
    hash will be made up of the filename and path (so if they rename a file, the hash
    will be different), size (if a file changes size, it's obviously different), last
    modified date, whether the item is a file or folder, and file mode bits. Even
    though we won't be archiving the folders, we still care about their names and
    the tree structure of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `dirhash.go` and add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We first create a new `hash.Hash` that knows how to calculate MD5s, before using
    `filepath.Walk` to iterate over all of the files and folders inside the specified
    path directory. For each item, assuming there are no errors, we write the differential
    information to the hash generator using `io.WriteString` , which lets us write
    a string to an `io.Writer` , and `fmt.Fprintf` , which does the same but exposes
    formatting capabilities at the same time, allowing us to generate the default
    value format for each item using the `%v` format verb.
  prefs: []
  type: TYPE_NORMAL
- en: Once each file has been processed, and assuming no errors occurred, we then
    use `fmt.Sprintf` to generate the result string. The `Sum` method on a `hash.Hash`
    calculates the final hash value with the specified values appended. In our case,
    we do not want to append anything since we've already added all of the information
    we care about, so we just pass `nil` . The `%x` format verb indicates that we
    want the value to be represented in hex (base 16) with lowercase letters. This
    is the usual way of representing an MD5 hash.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for changes and initiating a backup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the ability to hash a folder, and to perform a backup, we are
    going to put the two together in a new type called `Monitor` . The `Monitor` type
    will have a map of paths with their associated hashes, a reference to any `Archiver`
    type (of course, we'll use `backup.ZIP` for now), and a destination string representing
    where to put the archives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `monitor.go` and add the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to trigger a check for changes, we are going to add the following
    `Now` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Now` method iterates over every path in the map and generates the latest
    hash of that folder. If the hash does not match the hash from the map (generated
    the last time it checked), then it is considered to have changed, and needs backing
    up again. We do this with a call to the as yet unwritten `act` method, before
    then updating the hash in the map with this new hash.
  prefs: []
  type: TYPE_NORMAL
- en: To give our users a high-level indication of what happened when they called
    `Now` , we are also maintaining a counter which we increment every time we back
    up a folder. We will use this later to keep our end users up-to-date on what the
    system is doing without bombarding them with information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is helping us again and reminding us that we have yet to add the
    `act` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because we have done the heavy lifting in our ZIP `Archiver` type, all we have
    to do here is generate a filename, decide where the archive will go, and call
    the `Archive` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Archive` method returns an error, the `act` method and then the `Now`
    method will each return it. This mechanism of passing errors up the chain is very
    common in Go and allows you to either handle cases where you can do something
    useful to recover, or else defer the problem to somebody else.
  prefs: []
  type: TYPE_NORMAL
- en: The `act` method in the preceding code uses `time.Now().UnixNano()` to generate
    a timestamp filename and hardcodes the `.zip` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoding is OK for a short while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hardcoding the file extension like we have is OK in the beginning, but if you
    think about it we have blended concerns a little here. If we change the `Archiver`
    implementation to use RAR or a compression format of our making, the `.zip` extension
    would no longer be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before reading on, think about what steps you might take to avoid hardcoding.
    Where does the filename extension decision live? What changes would you need to
    make in order to avoid hardcoding properly?
  prefs: []
  type: TYPE_NORMAL
- en: The right place for the filename extensions decision is probably in the `Archiver`
    interface, since it knows the kind of archiving it will be doing. So we could
    add an `Ext()` string method and access that from our `act` method. But we can
    add a little extra power with not much extra work by instead allowing `Archiver`
    authors to specify the entire filename format, rather than just the extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `archiver.go` , update the `Archiver` interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `zipper` type needs to now implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can ask our `act` method to get the whole format string from the
    `Archiver` interface, update the `act` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The user command-line tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first of two tools we will build allows the user to add, list, and remove
    paths for the backup daemon tool (which we will write later). You could expose
    a web interface, or even use the binding packages for desktop user interface integration,
    but we are going to keep things simple and build ourselves a command-line tool.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `cmds` inside the `backup` folder and create another
    `backup` folder inside that.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good practice to name the folder of the command and the command binary
    itself the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our new `backup` folder, add the following code to `main.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We first define our `fatalErr` variable and defer the function that checks to
    ensure that value is `nil` . If it is not, it will print the error along with
    flag defaults and exit with a non-zero status code. We then define a flag called
    `db` that expects the path to the `filedb` database directory, before parsing
    the flags and getting the remaining arguments and ensuring there is at least one.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting small data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to keep track of the paths, and the hashes that we generate, we will
    need some kind of data storage mechanism that ideally works even when we stop
    and start our programs. We have lots of choices here: everything from a text file
    to a full horizontally scalable database solution. The Go ethos of simplicity
    tells us that building-in a database dependency to our little backup program would
    not be a great idea; rather we should ask what is the simplest way we can solve
    this problem?'
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/matryer/filedb` package is an experimental solution for just
    this kind of problem. It lets you interact with the filesystem as though it were
    a very simple schemaless database. It takes its design lead from packages such
    as `mgo` , and can be used in the cases where data querying needs are very simple.
    In `filedb` , a database is a folder, and a collection is a file where each line
    represents a different record. Of course, this could all change as the `filedb`
    project evolves, but the interface hopefully won't.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the `filedb.Dial` function to connect with the `filedb` database.
    In actuality, nothing much happens here except specifying where the database is,
    since there are no real database servers to connect to (although this might change
    in the future, which is why such provisions exist in the interface). If that was
    successful, we defer the closing of the database. Closing the database does actually
    do something, since files may be open that need to be cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: Following the `mgo` pattern, next we specify a collection using the `C` method
    and keep a reference to it in the `col` variable. If at any point an error occurs,
    we assign it to the `fatalErr` variable and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store data, we are going to define a type called `path` , which will store
    the full path and the last hash value, and use JSON encoding to store this in
    our `filedb` database. Add the following `struct` definition above the `main`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Parsing arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we call `flag.Args` (as opposed to `os.Args` ), we receive a slice of arguments
    excluding the flags. This allows us to mix flag arguments and non-flag arguments
    in the same tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our tool to be able to be used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To list all paths:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To achieve this, since we have already dealt with flags, we must check the first
    (non-flag) argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we simply switch on the first argument, after setting it to lowercase (if
    the user types `backup LIST` , we still want it to work).
  prefs: []
  type: TYPE_NORMAL
- en: Listing the paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To list the paths in the database, we are going to use a `ForEach` method on
    the path''s `col` variable. Add the following code to the list case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We pass in a callback function to `ForEach` that will be called for every item
    in that collection. We then `Unmarshal` it from JSON, into our `path` type, and
    just print it out using `fmt.Printf` . We return `false` as per the `filedb` interface,
    which tells us that returning `true` would stop iterating and that we want to
    make sure we list them all.
  prefs: []
  type: TYPE_NORMAL
- en: String representations for your own types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you print structs in Go in this way, using the `%s` format verbs, you can
    get some messy results that are difficult for users to read. If, however, the
    type implements a `String()` string method, that will be used instead and we can
    use this to control what gets printed. Below the path struct, add the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `path` type how it should represent itself as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Adding paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a path, or many paths, we are going to iterate over the remaining arguments
    and call the `InsertJSON` method for each one. Add the following code to the `add`
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the user hasn't specified any additional arguments, like if they just called
    `backup add` without typing any paths, we will return a fatal error. Otherwise,
    we do the work and print out the path string (prefixed with a `+` symbol) to indicate
    that it was successfully added. By default, we'll set the hash to the `Not yet
    archived` string literal—this is an invalid hash but serves the dual purposes
    of letting the user know that it hasn't yet been archived, as well as indicating
    as such to our code (given that a hash of the folder will never equal that string).
  prefs: []
  type: TYPE_NORMAL
- en: Removing paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove a path, or many paths, we use the `RemoveEach` method for the path''s
    collection. Add the following code to the `remove` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function we provide to `RemoveEach` expects us to return two bool
    types: the first one indicates whether the item should be removed or not, and
    the second one indicates whether we should stop iterating or not.'
  prefs: []
  type: TYPE_NORMAL
- en: Using our new tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have completed our simple `backup` command-line tool. Let's see it in action.
    Create a folder called `backupdata` inside `backup/cmds/backup` ; this will become
    the `filedb` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the tool in a terminal by navigating to the `main.go` file and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If all is well, we can now add a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add another path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see the complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our program should yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s remove `test3` to make sure the remove functionality is working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take us back to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We are now able to interact with the `filedb` database in a way that makes sense
    for our use case. Next we build the daemon program that will actually use our
    `backup` package to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: The daemon backup tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `backup` tool, which we will call `backupd` , will be responsible for periodically
    checking the paths listed in the `filedb` database, hashing the folders to see
    whether anything has changed, and using the `backup` package to actually perform
    the archiving of folders that need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `backupd` alongside the `backup/cmds/backup` folder,
    and let''s jump right into handling the fatal errors and flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You must be quite used to seeing this kind of code by now. We defer the handling
    of fatal errors before specifying three flags: `interval` , `archive` , and `db`
    . The `interval` flag represents the number of seconds between checks to see whether
    folders have changed, the `archive` flag is the path to the archive location where
    ZIP files will go, and the `db` flag is the path to the same `filedb` database
    that the `backup` command is interacting with. The usual call to `flag.Parse`
    sets the variables up and validates whether we''re ready to move on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to check the hashes of the folders, we are going to need an instance
    of `Monitor` that we wrote earlier. Append the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a `backup.Monitor` method using the `archive` value as the `Destination`
    type. We'll use the `backup.ZIP` archiver and create a map ready for it to store
    the paths and hashes internally. At the start of the daemon, we want to load the
    paths from the database so that it doesn't archive unnecessarily as we stop and
    start things.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You have seen this code before too; it dials the database and creates an object
    that allows us to interact with the `paths` collection. If anything fails, we
    set `fatalErr` and return.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicated structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we''re going to use the same path structure as in our user command-line
    tool program, we need to include a definition of it for this program too. Insert
    the following structure above the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The object-oriented programmers out there are no doubt by now screaming at the
    pages demanding for this shared snippet to exist in one place only and not be
    duplicated in both programs. I urge you to resist this compulsion of early abstraction.
    These four lines of code hardly justify a new package and therefore dependency
    for our code, when they can just as easily exist in both programs with very little
    overhead. Consider also that we might want to add a `LastChecked` field to our
    `backupd` program so that we could add rules where each folder only gets archived
    at most once an hour. Our `backup` program doesn't care about this and will chug
    along perfectly happy with its view into what fields constitute a path.
  prefs: []
  type: TYPE_NORMAL
- en: Caching data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now query all existing paths and update the `Paths` map, which is a useful
    technique to increase the speed of a program, especially given slow or disconnected
    data stores. By loading the data into a cache (in our case, the `Paths` map),
    we can access it at lightening speeds without having to consult the files each
    time we need information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the body of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Using the `ForEach` method again allows us to iterate over all the paths in
    the database. We `Unmarshal` the JSON bytes into the same path structure as we
    used in our other program and set the values in the `Paths` map. Assuming nothing
    goes wrong, we do a final check to make sure there is at least one path, and if
    not, return with an error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One limitation to our program is that it will not dynamically add paths once
    it has started. The daemon would need to be restarted. If this bothers you, you
    could always build in a mechanism that updates the `Paths` map periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next thing we need to do is to perform a check on the hashes right away
    to see whether anything needs archiving, before entering into an infinite timed
    loop where we check again at regular specified intervals.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop sounds like a bad idea; in fact to some it sounds like a bug.
    However, since we're talking about an infinite loop within this program, and since
    infinite loops can be easily broken with a simple `break` command, they're not
    as dramatic as they might sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, to write an infinite loop is as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The instructions inside the braces get executed over and over again, as quickly
    as the machine running the code can execute them. Again this sounds like a bad
    plan, unless you're careful about what you're asking it to do. In our case, we
    are immediately initiating a `select` case on the two channels that will block
    safely until one of the channels has something interesting to say.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, as responsible programmers, we care about what happens when the
    user terminates our programs. So after a call to the `check` method, which doesn''t
    yet exist, we make a signal channel and use `signal.Notify` to ask for the termination
    signal to be given to the channel, rather than handled automatically. In our infinite
    `for` loop, we select on two possibilities: either the `timer` channel sends a
    message or the termination signal channel sends a message. If it''s the `timer`
    channel message, we call `check` again, otherwise we go about terminating the
    program.'
  prefs: []
  type: TYPE_NORMAL
- en: The `time.After` function returns a channel that will send a signal (actually
    the current time) after the specified time has elapsed. The somewhat confusing
    `time.Duration(*interval) * time.Second` code simply indicates the amount of time
    to wait before the signal is sent; the first `*` character is a dereference operator
    since the `flag.Int` method represents a pointer to an int, and not the int itself.
    The second `*` character multiplies the interval value by `time.Second` , which
    gives a value equivalent to the specified interval in seconds. Casting the `*interval
    int` to `time.Duration` is required so that the compiler knows we are dealing
    with numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We take a short trip down the memory lane in the preceding code snippet by using
    the `goto` statement to jump out of the switch and to block loops. We could do
    away with the `goto` statement altogether and just return when a termination signal
    is received, but the pattern discussed here allows us to run non-deferred code
    after the `for` loop, should we wish to.
  prefs: []
  type: TYPE_NORMAL
- en: Updating filedb records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All that is left is for us to implement the `check` function that should call
    the `Now` method on the `Monitor` type and update the database with new hashes
    if there are any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `main` function, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `check` function first tells the user that a check is happening, before
    immediately calling `Now` . If the `Monitor` type did any work for us, which is
    to ask if it archived any files, we output them to the user and go on to update
    the database with the new values. The `SelectEach` method allows us to change
    each record in the collection if we so wish, by returning the replacement bytes.
    So we `Unmarshal` the bytes to get the path structure, update the hash value and
    return the marshaled bytes. This ensures that next time we start a `backupd` process,
    it will do so with the correct hash values.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's see whether our two programs play nicely together and what affects the
    code inside our `backup` package. You may want to open two terminal windows for
    this, since we'll be running two programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already added some paths to the database, so let''s use `backup` to
    see them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You should see the two test folders; if you don't, refer back to the *Adding
    paths* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In another window, navigate to the `backupd` folder and create our two test
    folders called `test` and `test2` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Build `backupd` using the usual method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming all is well, we can now start the backup process being sure to point
    the `db` path to the same path as we used for the `backup` program, and specify
    that we want to use a new folder called `archive` to store the ZIP files. For
    testing purposes, let''s specify an interval of `5` seconds to save time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, `backupd` should check the folders, calculate the hashes, notice
    that they are different (to `Not yet archived` ), and initiate the archive process
    for both folders. It will print the output telling us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the newly created `archive` folder inside `backup/cmds/backupd` and notice
    it has created two subfolders: `test` and `test2` . Inside those are compressed
    archive versions of the empty folders. Feel free to unzip one and see; not very
    exciting so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, back in the terminal window, `backupd` has been checking the folders
    again for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In your favorite text editor, create a new text file inside the `test2` folder
    containing the word `test` , and save it as `one.txt` . After a few seconds, you
    will see that `backupd` has noticed the new file and created another snapshot
    inside the `archive/test2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it has a different filename because the time is different, but if
    you unzip it you will notice that it has indeed created a compressed archive version
    of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Play around with the solution by taking the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the contents of the `one.txt` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a file to the `test` folder too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we successfully built a very powerful and flexible backup system
    for your code projects. You can see how simple it would be to extend or modify
    the behavior of these programs. The scope for potential problems that you could
    go on to solve is limitless.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having a local archive destination folder like we did in the previous
    section, imagine mounting a network storage device and using that instead. Suddenly,
    you have off-site (or at least off-machine) backups of those vital files. You
    could easily set a Dropbox folder as the archive destination, which would mean
    not only do you get access to the snapshots yourself, but also a copy is stored
    in the cloud and can even be shared with other users.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the `Archiver` interface to support `Restore` operations (which would
    just use the `encoding/zip` package to unzip the files) allows you to build tools
    that can peer inside the archives and access the changes of individual files much
    like Time Machine allows you to do. Indexing the files gives you full search across
    the entire history of your code, much like GitHub does.
  prefs: []
  type: TYPE_NORMAL
- en: Since the filenames are timestamps, you could have backed up retiring old archives
    to less active storage mediums, or summarized the changes into a daily dump.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, backup software exists, is well tested, and used through the world
    and it may be a smart move to focus on solving problems that haven't yet been
    solved. But when it requires such little effort to write small programs to get
    things done, it is often worth doing because of the control it gives you. When
    you write the code, you can get exactly what you want without compromise, and
    it's down to each individual to make that call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically in this chapter, we explored how easy Go''s standard library makes
    it to interact with the filesystem: opening files for reading, creating new files,
    and making directories. The `os` package mixed in with the powerful types from
    the `io` package, blended further with capabilities like `encoding/zip` and others,
    gives a clear example of how extremely simple Go interfaces can be composed to
    deliver very powerful results.'
  prefs: []
  type: TYPE_NORMAL
