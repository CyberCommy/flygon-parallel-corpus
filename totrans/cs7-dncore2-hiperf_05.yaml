- en: Designing Guidelines for .NET Core Application Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Architecture and design are the core foundations for any application. Conforming
    to the best practices and guidelines makes the application highly maintainable,
    performant, and scalable. Applications can vary from a web-based application,
    Web APIs, a server/client TCP-based messaging application, a mission-critical
    application, and so on. However, all of these applications should follow certain
    practices that benefit in various ways. In this chapter, we will learn certain
    practices that are common in almost all of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the principles we will learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coding principles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One class per file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One logic per method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Design principles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KISS (Keep It Simple, Stupid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAGNI (You Aren't Gonna Need It)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRY (Don't Repeat Yourself)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of Concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover some of the basic coding principles that help
    in writing quality code that improves the overall performance and scalability
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Always use the proper naming convention in every application, starting with
    the solution name, which should provide meaningful information about the project
    you are working on. The project name specifies the layer or component part of
    the application. Finally, classes should be nouns or noun phrases, and methods
    should represent the actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a new project in Visual Studio, the default solution name is
    set to what you specify for the project name. The solution name should always
    be different from the project name as one solution may contain multiple projects.
    The project name should always represent the specific part of the system. For
    example, suppose we are developing a messaging gateway that sends different types
    of messages to different parties and contains three components, namely, listener,
    processor, and dispatcher; the listener listens for incoming requests, the processor
    processes the incoming message, and the dispatcher sends the message to the destination.
    The naming convention could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solution name: `MessagingGatewa`*y* (or any code word)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Listener project name: `ListenerApp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Processor project name: `ProcessorAPI` (if it''s an API)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dispatcher project name: `DispatcherApp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In .NET, the naming convention we usually follow is Pascal casing for class
    and method names. In Pascal casing, the first character of every word is a capital
    letter, whereas the parameters and other variables follow Camel casing. Here is
    some sample code showing how casing should be used in .NET.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a constant field, `SmtpAddress`, and a `SendEmail`
    method that is cased using Pascal casing, whereas the parameters are cased using
    Camel casing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the naming conventions for different artifacts
    in .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Naming Convention** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| Class | Pascal casing | `class PersonManager {}` |'
  prefs: []
  type: TYPE_TB
- en: '| Method | Pascal casing | `void SaveRecord(Person person) {}` |'
  prefs: []
  type: TYPE_TB
- en: '| Parameters/Member variables | Camel casing | `bool isActive;` |'
  prefs: []
  type: TYPE_TB
- en: '| Interface | Pascal casing; starts with letter I | `IPerson` |'
  prefs: []
  type: TYPE_TB
- en: '| Enum | Pascal casing | `enum Status {InProgress, New, Completed}` |'
  prefs: []
  type: TYPE_TB
- en: Code comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any code that contains proper comments assists developers in many ways. It not
    only reduces the time to understand the code thoroughly, but can also give leverage
    with certain tools like *Sandcastle* or *DocFx* to generate complete code documentation
    on the fly that can be shared with other developers across the team. Also, when
    talking about APIs, Swagger is widely used and popular in the developer community.
    Swagger empowers API consumers by providing complete information about the API,
    available methods, parameters each method takes, and so on. Swagger also reads
    these comments to provide the complete documentation and interface to test any
    API.
  prefs: []
  type: TYPE_NORMAL
- en: One class per file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike many other languages, in .NET we are not restricted to create separate
    files for each class. We can create one single `.cs` file and create numbers of
    classes inside it. Conversely, this is a bad practice and painful when working
    with large applications.
  prefs: []
  type: TYPE_NORMAL
- en: One logic per method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Always write methods to do one thing at a time. Let''s suppose we have a method
    that reads the user ID from the database and then calls an API to retrieve the
    list of documents the user has uploaded. The best approach with this scenario
    is to have two separate methods, `GetUserID` and `GetUserDocuments`, to retrieve
    the user ID first and then the documents, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of this approach is that it reduces code repetition. In the future,
    if we wanted to change the logic of either method, we just have to change it in
    one place rather than replicating it everywhere and increasing the chances of
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing a clean architecture adhering to the best practices adds several
    benefits, and application performance is one of them. We have seen many times
    that the technologies used behind an application are robust and powerful, but
    the application's performance remains unsatisfactory or poor, which is usually
    because of bad architecture design and investing less time on the application's
    design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss a few common design principles that should
    be addressed when designing and developing applications in .NET Core:'
  prefs: []
  type: TYPE_NORMAL
- en: KISS (Keep It Simple, Stupid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAGNI (You Aren't Gonna Need It)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRY (Don't Repeat Yourself)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separation of Concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KISS (Keep It Simple, Stupid)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing cleaner code and keeping it simple always helps developers understand
    and maintain it in the long run. Adding needless complexity in the code does not
    only make it less understandable, but also hard to maintain and change when required.
    This is what KISS states. In a software context, KISS can be considered while
    designing software architecture, using **Object Oriented Principles** (**OOP**),
    designing the database, user interfaces, integration, and so on. Adding unnecessary
    complexity complicates the software's design and may affect the application's
    maintainability and performance.
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI (You Aren't Gonna Need It)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: YAGNI is one of the core principles of XP (extreme programming). XP is a software
    methodology that contains short spans of iterations to meet customer requirements
    and welcomes changes when they are required or initiated by the customer. The
    primary goal is meeting the customer's expectation, and keeping the quality and
    responsiveness the customer needs. It involves pair programming and code reviews
    to keep the quality intact and to satisfy the customer's expectations.
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI is best suited for the extreme programming methodology, which helps developers
    focus on the features that are part of the application's functionality or customer's
    requirements. Doing something extra that is not communicated to the customer or
    is not part of the iteration or requirement may end up needing a rework and being
    a waste of time.
  prefs: []
  type: TYPE_NORMAL
- en: DRY (Don't Repeat Yourself)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DRY (Don't Repeat Yourself) is also one of the core principles of writing cleaner
    code. It addresses the challenges developers face in big applications when they
    are constantly changing or extending with respect to functionality or underlying
    logic. As per the principle, it states that "*Every piece of knowledge must have
    a single dependable representation within the system.*"
  prefs: []
  type: TYPE_NORMAL
- en: When writing an application, we can use abstractions and avoid repetition of
    code to avoid redundancy. This benefits in accommodating changes and lets developers
    focus on one area where the change is required. If the same code is repeated in multiple
    areas, changes at one place need to be done in other places as well, and this
    eliminates good architecture practice, thus initiating higher risks of errors
    and making the application code more buggy.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of Concerns (SoC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core principles for developing clean architecture is **Separation
    of Concerns** (**SoC**). This pattern states that each distinct type of work application
    that is performing should be built separately as a separate component with little
    or no tight coupling with other components. For example, if a program saves the
    user message into the database and then a service randomly picks up the message
    and chooses the winner, you can see that these are two separate operations, and
    this is known as Separation of Concerns. With SoC, the code is considered a separate
    component and any customization, if needed, can be done at one place. Reusability
    is another factor that helps developers change code in one place so that they
    can use it in multiple places. Nevertheless, testing is far easier and bugs can
    be secluded and fixed later in case of predicament scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SOLID is a collection of 5 principles, which are listed as follows. They are
    common design principles that are highly used when developing software design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle** (**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Closed Principle** (**OCP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle** (**LSP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle** (**ISP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle** (**DIP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Single Responsibility Principle states that the class should only have one
    particular objective and that responsibility should be entirely encapsulated from
    the class. If there is any change or a new objective has to be accommodated for,
    a new class or interface should be created.
  prefs: []
  type: TYPE_NORMAL
- en: Applying this principle in software design makes our code maintainable and easier
    to understand. Architects usually follow this principle when designing software
    architecture, but, with the passage of time when many developers work and incorporate
    changes into that code/class, it becomes bloated and disaffirms the single responsibility
    principle, thus eventually making our code unmaintainable.
  prefs: []
  type: TYPE_NORMAL
- en: This also relates to the concepts of Cohesion and Coupling. Cohesion refers
    to the measure of how strongly related the responsibilities in the class are,
    whereas coupling refers to the degree to which each class relies on one another.
    We should always focus on maintaining low coupling between classes and high cohesion
    within the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the basic `PersonManager` class that contains four methods, namely
    `GetPerson`, `SavePerson`, `LogError`, and `LogInformation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.gif)'
  prefs: []
  type: TYPE_IMG
- en: All of these methods use the database persistence manager to read/write the
    record into the database. As you may have noticed, `LogError` and `LogInformation`
    are not highly cohesive to the `PersonManager` class, and are tightly coupled
    with the `PersonManager` class. If we wanted to reuse these methods in other classes,
    we have to use the `PersonManager` class, and changing the logic of internal logging
    requires this `PersonManager` class to be changed as well. Hence, `PersonManager`
    violates the single responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this design, we can create a separate `LogManager` class that can be
    used by the `PersonManager` to log information or errors when executing operations.
    Here is the updated class diagram representing the associations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.gif)'
  prefs: []
  type: TYPE_IMG
- en: Open Closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the definition, the Open Closed principle states that software entities
    like classes, methods, interfaces, and others should be closed for modification
    and open for extension. This means we cannot modify the existing code and extend
    the functionality by adding additional classes, interfaces, methods, and so on
    to address any changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this principle in any application solves various problems, which are
    listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new functionality without changing existing code produces fewer errors
    and does not require thorough testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less of a ripple effect that is usually experienced when changing existing code
    to add or update functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions are mostly implemented using new interfaces or abstract classes where
    the existing code is unnecessary and has a lesser chance to break existing functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement the Open Closed Principle, we should use abstractions which is
    possible through parameters, inheritance, and composition approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Special parameters can be set in the methods, which can be used to control
    the behavior of the body written in that method. Suppose there is a `LogException`
    method that saves the exception into the database and also sends an email. Now,
    whenever this method is called, both the tasks will be performed. There is no
    way to stop sending an email for a particular exception from the code. However,
    if it is articulated in a way and uses some parameters to decide whether the email
    has to be sent out or not, it can be controlled. Nonetheless, if the existing
    code doesn''t support this parameter, then customization is required, but, while
    designing, we can keep this approach to expose certain parameters so that we can
    handle the internal behavior of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The recommended implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the inheritence approach, we can use the Template method pattern. Using
    the Template method pattern, we can create a default behavior in the root class
    and then create child classes to override the default behavior and implement new
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a `Logger` class that logs information into the file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have one `LogMessage` method that logs the message into the file system by
    calling the `LogToFileSystem` method. This method works fine until we wanted to
    extend the functionality. Suppose, later on, we come up with the requirement to
    log this information into the database as well. We have to change the existing
    `LogMessage` method and write the code into the same class itself. Later on, if
    any other requirement comes along, we have to add that functionality again and
    again and modify this class. As per the Open Closed Principle, this is a violation.
  prefs: []
  type: TYPE_NORMAL
- en: With the Template method pattern, we can redesign this code to follow the Open
    Closed Principle so that we can make it open for extension and closed for customization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the OCP, here is the new design where we have one abstract class
    that contains the `LogMessage` abstract method, and two child classes that have
    their own implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'With this design, we can add the nth number of extensions without changing
    the existing `Logger` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third approach is composition, and this can be achieved using the Strategy
    pattern. With this approach, the client code is dependent on the abstraction,
    and the actual implementation is encapsulated in a separate class which is injected
    into the class exposed to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look into the following example that implements the strategy pattern.
    The basic requirement is to send messages that could be either emails or SMSes,
    and we need to construct it in a way so that new message types can be added in
    the future without any modification to the main class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.gif)'
  prefs: []
  type: TYPE_IMG
- en: As per the strategy pattern, we have one `MessageStrategy` abstract class that
    exposes one abstract method. Each type of work is encapsulated into the separate
    class that inherits the `MessageStrategy` base abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `MessageStrategy` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two concrete implementations of `MessageStrategy`; one to send an email
    and another to send an SMS, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `MessageSender` class, which will be used by the client.
    In this class, the client can set the message strategy and call the `SendMessage`
    method that invokes the particular concrete implementation type to send the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'From the Main program, we can use `MessageSender`, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Liskov principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As per the Liskov principle, the function that uses the references of derived
    classes through the base class object must comply with the behavior of the base
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the child classes should not remove the behavior of the base
    class since this violates the invariants of it. Typically, the calling code should
    completely rely on the methods exposed in a base class without knowing its derived
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example where we first violate the definition of the Liskov
    principle and then fix it to learn what it is particularly designed for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The `IMultiFunctionPrinter` interface exposes two methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an interface that can be implemented by different kinds of printers.
    The following are two kinds of printers that implement the `IMultiFunctionPrinter`
    interface, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding implementations, we have one `OfficePrinter` that provides
    printing and scanning functionalities, whereas the other home purpose `DeskjetPrinter`
    only provides the printing functionality. This `DeskjetPrinter` actually violates
    the Liskov principle as it throws the `NotImplementedException` when the `Scan`
    method is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a remedy to the preceding problem, we can split the `IMultiFunctionPrinter`
    into two interfaces, namely `IPrinter` and `IScanner`, whereas `IMultiFunctionPrinter`
    can also implement both the interfaces to support both functionalities. The `DeskjetPrinter`
    only implements the `IPrinter` interface as it does not support scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code for the three interfaces, `IPrinter`, `IScanner`, and `IMultiFunctionPrinter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the concrete implementation will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Interface Segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Interface Segregation principle states that the client code should only
    depend on the things the client use and should not depend on anything they do
    not use. This means you cannot force client code to depend on certain methods
    which are not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example that first violates the Interface Segregation principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.gif)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, we have the ILogger interface that contains two methods,
    namely `WriteLog` and `GetLogs`. The `ConsoleLogger` class writes the message
    into the application console window, whereas the `DatabaseLogger` class stores
    the message into the database. The `ConsoleLogger` prints the message on the console
    windows and does not persist it; it throws the `NotImplementedException` for the
    `GetLogs` method, and so this violates the Interface Segregation principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the preceding problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To obey the **Interface Segregation Principle** (**ISP**), we split the ILogger
    interface and make it more precise and pertinent with other implementers. The
    ILogger interface will only contain the `WriteLog` method and a new `IPersistenceLogger`
    interface is introduced that inherits the ILogger interface and provides the `GetLogs`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the modified example, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Dependency Inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dependency Inversion principle states that high-level modules should not
    depend on low-level modules and both of them should depend on abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: The software application contains numerous types of dependencies. A dependency
    could be a framework dependency, a third-party libraries dependency, a web service
    dependency, a database dependency, a class dependency, and so on. As per the Dependency
    Inversion principle, the dependencies should not be tightly coupled with one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the layered architecture approach we have a presentation layer
    where all the views are defined; the service layer that exposes certain methods
    used by the presentation layer; the business layer that contains core business
    logic of the system; and the database layer where the backend database connectors
    and the repository classes are defined. Consider this an ASP.NET MVC application
    where the controller invokes the service that references the business layer, where
    the business layer contains the core business logic of the system, and where it
    uses the database layer to perform CRUD (Create, Read, Update and Delete) operations
    on the database. The dependency tree will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'As per the Dependency Inversion principle, it is not recommended to instantiate
    the objects directly from each layer. This creates a tight coupling between the
    layers. To break this coupling, we can implement abstraction through interfaces
    or abstract classes. We may use some instantiation patterns like factory or dependency
    injection to instantiate objects. Moreover, we should always use interfaces rather
    than classes. Suppose in our service layer we have a reference to our business
    layer, and our service contract is using `EmployeeManager` to perform some CRUD
    operations. `EmployeeManager` contains the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the service layer, we can instantiate the business layer `EmployeeManager`
    object using the new keyword. Adding more methods in the `EmployeeManager` class
    will directly use the service layer based on the access modifiers being set at
    each method. Moreover, any changes in the existing methods will break the service
    layer code. If we expose the interface to the service layer and use some factory
    or **Dependency Injection** (**DI**) patterns, it encapsulates the underlying
    implementation and exposes only those methods that are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `IEmployeeManager` interface being extracted from
    the `EmployeeManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Considering the preceding example, we can inject types using dependency injection,
    so whenever the service manager is invoked, the business manager instance will
    be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is one of the best practices that can be used to increase application
    performance. It is often used with data where changes are less frequent. There
    are many caching providers available that we can consider to save data and retrieve
    it when needed. It is faster than the database operation. In ASP.NET Core, we
    can use in-memory caching that stores the data in the memory of the server, but
    for a web farm or a load balancing scenario where an application is deployed to
    multiple places, it is recommended to use a distributed cache. Microsoft Azure
    also provides a Redis cache which is a distributed cache that exposes an endpoint
    that can be used to store values on the cloud and can be retrieved when they are
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the in-memory cache in the ASP.NET Core project, we can simply add the
    memory cache in the `ConfigureServices` method, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can inject `IMemoryCache` in our controllers or page models through
    dependency injection and set or get values using the `Set` and `Get` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Choosing the right data structure plays a vital role in application performance.
    Before choosing any data structure, it is highly recommended to think about whether
    it is an overhead or it literally solves a particular use case. Some key factors
    to be considered while choosing an appropriate data structure are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Know about the type of data you need to store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know how the data grows and whether there is any drawback when it grows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know if you need to access your data through an index or key/value pairs and
    choose the appropriate data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know if you need synchronized access and choose thread-safe collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many other factors when choosing the right data structure, and they
    have already been covered in [Chapter 4](part0107.html#361C60-84c100e6bea3438e8844d99ae7f5dfa9), *Data
    Structures and Writing Optimized Code in C#.*
  prefs: []
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nowadays, communication has become an important epitome in any application,
    and the primary factor is the rapid evolution of technology. Applications such
    as web-based applications, mobile applications, IoT applications, and other distributed
    applications perform different types of communication over the wire. We can take
    an example of an application that has a web frontend deployed on some cloud instance,
    invoking some service deployed on a separate instance in the cloud and performing
    some backend connectivity to the database which is hosted locally. Besides this,
    we can have an IoT application that sends the room temperature by calling some
    service over the internet, and many more. Certain factors that need to be considered
    when designing distributed application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using lighter interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Avoid multiple round trips to the server that adds more network latency and
    decreases application performance. Using the unit of work pattern avoids sending
    redundant operations to the server and performs one single operation to communicate
    to the backend service. The unit of work groups all the messages as a single unit
    and processes them as one unit.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing message size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use as little data as possible to communicate to the service. For example, there
    is a Person API that provides some `GET`, `POST`, `PUT`, and `DELETE` methods
    to perform a CRUD operation on that backend database. To delete a person’s record,
    we can just pass the `ID` (primary key) of the person as a parameter to the service
    rather than passing the whole object as a parameter. Moreover, use objects that
    are less bloated with properties or methods that offer a minimal set of artifacts.
    The best case is to use **POCO** (**Plain Old CLR object**) entities that have
    minimal dependencies on other objects which contain only those properties that
    are necessary to be sent across the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For larger object or complex operation, decoupling the single request/response
    channel from the distributed messaging channel increases the application's performance.
    For large, chunky operations, we can design and distribute communication into
    multiple components. For example, there is a website that calls a service to upload
    an image, and, once it is uploaded, it does some processing to extract a thumbnail
    and saves it in the database. One way is to do both uploading and processing in
    a single call, but at times when the user uploads a larger image or if the image
    processing takes a longer time, the user may face a request timeout exception,
    and the request will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the queuing architecture, we can distribute these two operations into
    separate calls. The user uploads the image which is saved in the filesystem, and
    the image path will be saved into storage. A service running in the background
    will pick up that file and do the processing asynchronously. Meanwhile, when the
    backend service is processing, the control is returned to the user, where the
    user can see some in-progress notification. Finally, when the thumbnail is generated,
    the user will be notified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Resource management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every server has a limited set of resources. No matter how good the server specification,
    if the application is not designed to utilize resources in an efficient manner,
    this leads to performance issues. There are certain best practices that need to
    be addressed to optimally use server resources when designing .NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding improper use of threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a new thread for each task without monitoring or aborting the lifecycle
    of the thread is a bad practice. Threads are good to perform multitasking and
    to utilize multiple resources of the server to run things in parallel. However,
    if the design is to create threads for each request, this can slow down the application's
    performance, as the CPU will take more time in the context of switching between
    the threads rather than executing the actual job.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we use threads, we should always try to keep a shared thread pool where
    any new item that needs to be executed waits in the queue if the thread is busy,
    and is acquired when it is available. This way, thread management is easy and
    server resources will be used efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Disposing objects in a timely fashion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CLR** (**Common Language Runtime**) provides automatic memory management,
    and the objects instantiated with a new keyword do not require to be garbage collected
    explicitly; **GC** (**Garbage Collection**) does the job. However, non-managed
    resources are not automatically released by the GC and should be explicitly collected
    by implementing the `IDisposable` interface. Such resources could be database
    connections, file handlers, sockets, and so on. To learn more about disposing
    of unmanaged resources in .NET Core, please refer to [Chapter 6](part0161.html#4PHAI0-84c100e6bea3438e8844d99ae7f5dfa9),
    *Memory Management Techniques in .NET Core.*'
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring resources when they are required
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Always acquire resources only when they are required. Instantiating objects
    ahead of time is not a good practice. It takes unnecessary memory and utilizes
    resources of the system. Furthermore, use *try*, *catch,* and *finally* to block
    and release objects in the *finally* block. This way, if any exception occurs,
    the objects which have been instantiated within the method will be released.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In concurrent programming, many objects may access the same resource at the
    same time, and keeping them thread-safe is the primary objective. In .NET Core,
    we can use locks to provide synchronized access. However, there are cases where
    a thread has to wait for a longer time to get access to resources, and this makes
    applications unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to apply for synchronized access only for those specific
    lines of code where the actual resource needs to be thread-safe, for example,
    where the locks can be used, which are the database operations, file handling,
    bank account access, and many other critical sections in the application. These
    need synchronized access so that they can be handled one thread at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing cleaner code, following the architecture and design principles, and
    adhering to the best practices play a significant role in application performance.
    If the code if baggy and repetitive, it can increase the chances of errors, increase
    complexity, and affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have learned some coding principles that make the application
    code look cleaner and easier to understand. If the code is clean, it offers other
    developers a way to understand it completely and helps in many other ways. Later
    on, we learned some basic design principles that are considered to be the core
    principles when designing applications. Principles such as KISS, YAGNI, DRY, Separation
    of Concerns, and SOLID are highly essential in software design, and caching and
    choosing the right data structure have a significant impact on performance and
    increase performance if they are used properly. Finally, we learned some best
    practices that should be considered when handling communication, resource management,
    and concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is a detailed introduction to memory management, where we will
    explore some techniques of memory management in .NET Core.
  prefs: []
  type: TYPE_NORMAL
