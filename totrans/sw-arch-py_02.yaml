- en: Chapter 2. Writing Modifiable and Readable Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter, we discussed the various aspects of software architecture,
    and covered some definitions of the terms involved. We looked at the different
    aspects of software architecture that an architect should be concerned with. Towards
    the end of the chapter, we discussed the various architectural quality attributes
    that an architect should focus on when building a system. We went in some detail
    into each of these attributes, looked at some definitions, and also various concerns
    that should be kept in mind when architecting a system for achieving these attributes.
  prefs: []
  type: TYPE_NORMAL
- en: From this chapter onwards, we will focus on each of these quality attributes
    one by one, and discuss them in detail, per chapter. We will delve deep into an
    attribute—such as its various factors, techniques to achieve it, aspects to keep
    in mind when programming towards it, and so on. Since our focus in this book is
    on Python and its ecosystem, we will also look at various code examples and third-party
    software support that Python provides for achieving and maintaining these quality
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The focus of this chapter is on the quality attribute of Modifiability.
  prefs: []
  type: TYPE_NORMAL
- en: What is modifiability?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The architectural quality attribute of Modifiability can be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Modifiability is the degree of ease at which changes can be made to a system,
    and the flexibility with which the system adapts to such changes.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We discussed various aspects of modifiability in the first chapter, such as
    **cohesion**, **coupling**, and others. We will dig a little bit deeper into these
    aspects in this chapter with some examples. However, before we dig deeper, it
    might be a good idea to take a look at the big picture of how modifiability fits
    in with the other quality attributes that are related to it.
  prefs: []
  type: TYPE_NORMAL
- en: Aspects related to Modifiability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already seen some aspects of modifiability in the previous chapter.
    Let us discuss this a bit further, and look at some of the related quality attributes
    that are closely related to modifiability:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readability**: Readability can be defined as the ease with which a program''s
    logic can be followed and understood. Readable software is code that has been
    written in a specific style, following guidelines typically adopted for the programming
    language used, and whose logic uses the features provided by the language in a
    concise, clear way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity**: Modularity means that the software system is written in well-encapsulated
    modules, which do very specific, well-documented functions. In other words, modular
    code provides programmer friendly APIs to the rest of the system. Modifiability
    is closely connected to Reusability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: This measures the number of parts of a software system, including
    code, tools, designs, and others, that can be reused in other parts of the system
    with zero or very little modifications. A good design would emphasize reusability
    from the beginning. Reusability is embodied in the DRY principle of software development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: Maintainability of a software is the ease and efficiency
    with which the system can be updated and kept working in a useful state by its
    intended stakeholders. Maintainability is a metric, which encompasses the aspects
    of modifiability, readability, modularity and testability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to go deep into the readability and reusability/modularity
    aspects. We will look at these one by one from the context of the Python programming
    language. We will start with readability first.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding readability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The readability of a software system is closely tied to its modifiability. Well-written,
    well-documented code, keeping up with standard or adopted practices for the programming
    language, tends to produce simple, concise code that is easy to read and modify.
  prefs: []
  type: TYPE_NORMAL
- en: Readability is not only related to the aspect of following good coding guidelines,
    but it also ties up to how clear the logic is, how much the code uses standard
    features of the language, how modular the functions are, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we can summarize the different aspects of readability as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Well-written**: A piece of code is well-written if it uses simple syntax,
    uses well-known features and idioms of the language, the logic is clear and concise,
    and if it uses variables, functions, and class/module names meaningfully; that
    is, they express what they do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Well-documented**: Documentation usually refers to the inline comments in
    the code. A well-documented piece of code tells what it does, what its input arguments
    (if any) are, and what is its return value (if any) along with the logic or algorithm,
    if any, in detail. It also documents any external library, or API usage and configuration
    required for running the code either inline or in separate files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Well-formatted**: Most programming languages, especially the open source
    languages developed over the Internet via distributed but closely-knit programming
    communities, tend to have well-documented style guidelines. A piece of code that
    keeps up with these guidelines on aspects such as indentation and formatting will
    tend to be more readable than something which doesn''t.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code which doesn't keep up with these guidelines would in general be lacking
    on the readability aspect.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of readability affects modifiability, and hence, maintainability of the
    code, thereby incurring ever-increasing costs for the organization in terms of
    resources—mainly people and time—in maintaining the system in a useful state.
  prefs: []
  type: TYPE_NORMAL
- en: Python and readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a language that has been designed from the ground-up for readability.
    To borrow a line from the well-known Zen of Python.
  prefs: []
  type: TYPE_NORMAL
- en: '*readability counts*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Zen of Python is a set of 20 principles that influence the design of the
    Python programming language, 19 of which have been written down. You can see the
    Zen of Python by opening the Python interpreter prompt and typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Python, as a language, emphasizes readability. It achieves this by clear, concise
    keywords, which mimic their English language counterparts, using minimal operators,
    and following the following philosophy:'
  prefs: []
  type: TYPE_NORMAL
- en: '*There should be one-- and preferably only one --obvious way to do it.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is one way to iterate through a sequence in Python while
    also printing its index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a more common idiom used in Python is to use the `enumerate()` helper
    for iterators, which returns a two tuple of (`idx`, `item`) for each item in the
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In many programming languages like C++, Java, or Ruby, the first version would
    be considered equally good as the second version. However, in Python, there are
    certain idioms of writing code, which keep up with the language's principles—the
    Zen—than certain others.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the second version is closer to the way Python programmers would
    write code to solve the problem. The first way would be considered less Pythonic
    than the second one.
  prefs: []
  type: TYPE_NORMAL
- en: The term "Pythonic" is something you would commonly encounter when interacting
    with the Python community. It means that the code not just solves the problem,
    but follows the conventions and idioms the Python community generally follows,
    and uses the language in the way it is intended to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The definition of Pythonic is subjective, but you can think of it as Python
    code keeping up with the Zen of Python, or in general, following well-known idiomatic
    programming practices adopted by the community.
  prefs: []
  type: TYPE_NORMAL
- en: Python, by its design principles and clean syntax, makes writing readable code
    easy. However, it is a common trap for programmers migrating to Python from other
    more pedantic and less-idiomatic languages like say C++ or Java to write Python
    code in a less Pythonic way. For example, it is more likely that the first version
    of the loop is written by someone migrating to Python from one of these languages
    than someone who has been coding in Python for some time.
  prefs: []
  type: TYPE_NORMAL
- en: It is important for a Python programmer to understand this aspect early so that
    you tend to write more idiomatic or Pythonic code as you get used to the language
    more and more. You can be more productive with Python in the long term if you
    familiarize yourself with its coding principles and idioms than otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Readability - antipatterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python, in general, encourages and facilitates writing readable code. However,
    it would be, of course, very unrealistic to say that any code written in Python
    is highly readable. Even with all its readability DNA, Python also has its fairshare
    of difficult-to-read, badly written, or unreadable code as can be evident by spending
    some time scanning through some of the public, open-source code written in Python
    on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are certain practices that tend to produce difficult-to-read or unreadable
    code in a programming language. These can be thought of as antipatterns, which
    are a bane, not just in programming with Python, but in any programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code with little or no comments**: Lack of code comments is often the primary
    reason for producing code that is unreadable. More often than not, programmers
    don''t do a very good job of documenting their thoughts, which led to a particular
    implementation, in code. When the same code is read by another programmer or by
    the same programmer a few months later (this happens quite a lot!), it is not
    easy to figure out why the specific implementation approach was followed. This
    makes it difficult to reason about the pros and cons of an alternate approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This also makes taking decisions on modifying the code—perhaps for a customer
    fix—difficult, and in general, affects code modifiability in the long term. Commenting
    of code is often an indicator of the discipline and rigor of the programmer who
    wrote the code, and also of the organization in enforcing such practices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code which breaks best practices of the language**: Best practices of a programming
    language typically evolves from years of experience in using the language by a
    community of developers, and the efficient feedback that it generates. They capture
    the best way of putting the programming language to good use to solve problems,
    and typically, capture the idioms and common patterns for using the language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, in Python, the Zen can be considered as a shining torch to its
    best practices and the set of common programming idioms adopted by the community.
  prefs: []
  type: TYPE_NORMAL
- en: Often, programmers who are either inexperienced or those who migrate from other
    programming languages or environments tend to produce code that is not in keeping
    with these practices, and hence, end up writing code that is low on readability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming antipatterns**: There are a large number of coding or programming
    antipatterns which tend to produce difficult-to-read, and hence, difficult-to-maintain
    code. Here are some of the well-known ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spaghetti code**: A piece of code with no discernible structure or control-flow.
    It is typically produced by following complex logic with a lot of unconditional
    jumps and unstructured exception handling, badly designed concurrency structures,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Big ball of mud**: A system with pieces of code that show no overall structure
    or goal. Big ball of mud typically consists of many pieces of spaghetti code,
    and is usually a sign of code that has been worked on by multiple people, patched-up
    multiple times with little or zero documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy-Paste programming**: Often produced in organizations where expediency
    of delivery is favored over thoughtful design, copy/paste coding produces long,
    repetitive chunks of code, which essentially do the same thing again and again
    with minor modifications. This leads to code-bloat, and in the long term, the
    code becomes unmaintainable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A similar antipattern is *cargo-cult programming*, where programmers follows
    the same design or programming pattern over and over again without a thought to
    whether it fits the specific scenarios or problems that it is trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ego Programming**: Ego programming is where a programmer—often an experienced
    one—favors his personal style over the documented best practices or the organizational
    style of coding. This sometimes creates code that is cryptic and difficult to
    read for the other—usually, the younger or less-experienced programmers. An example
    is the tendency to use functional programming constructs in Python to write everything
    as a one-liner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding antipatterns can be circumvented by adopting practices of Structured
    Programming in your organization, and by enforcing the use of coding guidelines
    and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some antipatterns which are specific to Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mixed Indentation**: Python uses indentation to separate blocks of code,
    as it lacks braces or other syntactical constructs of languages like C/C++ or
    Java which separate code blocks. However, one needs to be careful when indenting
    code in Python. A common antipattern is where people mix both tabs (the `\t` character)
    and spaces in their Python code. This can be fixed by using editors which always
    use either tabs or spaces to indent code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python comes with built-in modules like *tabnanny*, which can be used to check
    your code for indentation issues.
  prefs: []
  type: TYPE_NORMAL
- en: '**Mixing string literal types**: Python provides three different ways to create
    string literals: either by using the single quote (`''`), the double quote (`"`),
    or Python''s own special triple quote (`''''''` or `"""`). Code which mixes these
    three types of literals in the same block of code or functional unit becomes more
    difficult to read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A related abuse of strings is where programmers use the triple-quoted string
    for inline comments in their Python code rather than using the `#` character to
    prefix their comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overuse of functional constructs**: Python, being a mixed paradigm language,
    provides support for functional programming via its lambda keyword and its `map()`,
    `reduce()`, and `filter()`functions. However, sometimes, experienced programmers
    or programmers coming from a background of functional programming to Python, overuse
    these constructs producing code that is too cryptic, and hence, unreadable to
    other programmers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for readability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a good knowledge on what helps readability of code, let us
    look at the approaches that we can adopt in order to improve the readability of
    code in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Document your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple and effective way to improve the readability of your code is to document
    what it does. Documentation is important for readability and long term modifiability
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code documentation can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inline documentation**: The programmer documents his code by using code comments,
    function documentation, module documentation, and others as part of the code itself.
    This is the most effective and useful type of code documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External documentation**: These are additional documentation captured in
    separate files, which usually document aspects such as usage of code, code changes,
    install steps, deployment, and the like. Examples are the `README`, `INSTALL`,
    or `CHANGELOG`, files usually found with open-source projects keeping up with
    the GNU build principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Manuals**: These are formal documents, usually by a dedicated person
    or team, using pictures and text that is usually targeted towards users of the
    system. Such documentation is usually prepared and delivered towards the end of
    a software project when the product is stable and is ready to ship. We are not
    concerned with this type of documentation in our discussion here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python is a language that is designed for smart inline code documentation from
    the groundup. In Python, inline documentation can be done at the following levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code comments**: This is the text inline with code, prefixed by the hash
    (`#`) character. They can be used liberally inside your code explaining what each
    step of the code does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The liberal use of comments even in places it may be deemed superfluous. We
    will look at some general rules of thumb in commenting your code later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function doc-strings**: Python provides a simple way to document what a function
    does by using a string literal just below the function definition. This can be
    done by using any of the three styles of string literals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function docstring is the line which says *Fetch a given URL and return
    its contents*. However, though it is useful, the usage is limited, since it only
    says what the function does and doesn''t explain its parameters. Here is an improved
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the function usage has become much more clear to the
    programmer, who may be planning to import its definition and use it in his code.
    Note that such extended documentation would usually span more than one line, and
    hence, it is a good idea to always use triple quotes with your function docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class docstrings**: These work just like a function docstring except that
    they provide documentation for a class directly. This is provided just below the
    class keyword defining the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See how the class docstring defines some of the main methods of the class. This
    is a very useful practice, as it gives the programmer useful information at the
    top level without having to go and inspect each function's documentation separately.
  prefs: []
  type: TYPE_NORMAL
- en: '**Module docstrings**: Module docstring capture information at the module level,
    usually about the functionality of the module and some detail about what each
    member of the module (function, class, and others) does. The syntax is the same
    as the class or function docstring. The information is usually captured at the
    beginning of the module code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A module documentation can also capture any specific external dependencies
    of a module if they are not very obvious, for example, importing a third-party
    package which is not very commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Follow coding and style guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most programming languages have a relatively well-known set of coding and/or
    style guidelines. These are either developed over many years of use as a convention,
    or come as a result of discussions in the online community of that programming
    language. C/C++ is a good example of the former, and Python is a good example
    of the latter.
  prefs: []
  type: TYPE_NORMAL
- en: It is also a common practice for companies to specify their own guidelines—mostly,
    by adopting existing standard guidelines, and customizing them for the company's
    own specific development environment and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For Python, there is a clear set of coding style guidelines published by the
    Python programming community. This guideline, known as PEP-8, is available online
    as part of the **Python Enhancement Proposal** (**PEP**) set of documents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find PEP-8 at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/).'
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8 was first created in 2001, and has undergone multiple revisions since
    then. The primary author is the creator of Python, is Guido Van Rossum, with inputs
    from Barry Warsaw and Nick Coghlan.
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8 was created by adapting Guido's original *Python Style Guide essay* with
    additions from Barry's style guide.
  prefs: []
  type: TYPE_NORMAL
- en: We will not go deep into PEP-8 in this book, as the goal of this section is
    not to teach you PEP-8\. However, we will discuss the general principles underlying
    PEP-8, and list out some of its main recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The philosophy underlying PEP-8 can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Code is read more than it is written. Hence, providing a guideline would make
    code more readable, and make it consistent across a full spectrum of Python code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistency within a project is important. However, consistency within a module
    or package is more important. Consistency within a unit of code—such as class
    or function is the most important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know when to ignore a guideline. For example, this may happen if adopting the
    guideline makes your code less readable, breaks the surrounding code, or breaks
    backward compatibility of the code. Study examples, and choose what is best.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a guideline is not directly applicable or useful for your organization, customize
    it. If you have any doubts about a guideline, get clarification by asking the
    helpful Python community.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not cover the PEP-8 guidelines in detail here. The interested reader
    can refer to the documentation online on the Web using the URLs given here.
  prefs: []
  type: TYPE_NORMAL
- en: Review and refactor code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code requires maintenance. Unmaintained code which is used in production can
    become a problem and a nightmare if not tended to periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Periodically scheduled reviews of code can be very useful in keeping the code
    readable and in good health aiding modifiability and maintainability. Code which
    is central to a system or an application in production tends to get a lot of quick-fixes
    over time, as it is customized or enhanced for different use cases or patched
    for issues. It is observed that programmers generally don't document such quick
    fixes (called "patch" or "hot-fix"), as the time demands often expedite immediate
    testing and deployment over good engineering practices such as documentation and
    following guidelines!
  prefs: []
  type: TYPE_NORMAL
- en: Over time, such patches can accumulate, thereby causing code-bloat and creating
    huge future engineering debts for the team, which can become a costly affair.
    The solution is periodical reviews.
  prefs: []
  type: TYPE_NORMAL
- en: Reviews should be done with engineers who are familiar with the application,
    but need not be working on the same code. This gives the code a fresh set of eyes,
    which is often useful in detecting bugs that the original author(s) may have overlooked.
    It is a good idea to get large changes reviewed by a couple of reviewers who are
    experienced developers.
  prefs: []
  type: TYPE_NORMAL
- en: This can be combined with the general refactoring of code to improve implementation,
    reduce coupling, or increase cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are coming towards the end of our discussions on readability of code, and
    it is a good time to introduce some general rules of thumb to follow when writing
    code comments. These can be listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Comments should be descriptive, and should explain the code. A comment which
    simply repeats what is obvious from the function name is not very useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example. Both of the following codes show the same implementation
    of an **root-mean-squared** (**RMS**) velocity calculation, but the second version
    has a much more useful `docstring` than the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Code comments should be written in the block we are commenting on, rather than
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding version is much more clearer than the following version, which
    uses comments below the code since it is in keeping with the natural order of
    reading from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inline comments should be used as little as possible. This is because it is
    very easy to get these confused as part of the code itself, especially if the
    separating comment character is accidentally deleted, causing bugs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to avoid comments that are superfluous and add little value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The second comment in the last piece of code adds little value, and can be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of Modifiability – Cohesion & Coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now get back to the main topic of modifiability, and discuss the two
    fundamental aspects that affect modifiability of code—namely, cohesion and coupling.
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed these concepts briefly in the first chapter. Let us
    do a quick review here.
  prefs: []
  type: TYPE_NORMAL
- en: The cohesion refers to how tightly the responsibilities of a module are related
    to each other. A module which performs a specific task or group of related tasks
    has high cohesion. A module in which a lot of functionality is dumped without
    a thought as to the core functionality would have low cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: The coupling is the degree to which the functionality of two modules A and B
    are related. Two modules are strongly coupled if their functionality overlaps
    strongly at the code level—in terms of function or method calls. Any changes in
    module A would probably require changes in module B.
  prefs: []
  type: TYPE_NORMAL
- en: Strong coupling is always prohibitory for modifiability, as it increases the
    cost of maintaining the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Code which aims to increase modifiability should aim for high cohesion and low
    coupling.
  prefs: []
  type: TYPE_NORMAL
- en: We will analyze cohesion and coupling in the following subsections with some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring cohesion and coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at a simple example of two modules to figure out how we can measure
    coupling and cohesion quantitatively. The following is the code for module A,
    which purportedly implements functions that operate with a series (array) of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next is the listing of module B.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us do an analysis of the functions in module A and B. Here is the report:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Module | Core functions | Unrelated functions | Function dependencies |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | 4 | 0 | 3 x 1 = 3 |'
  prefs: []
  type: TYPE_TB
- en: '| A | 3 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'This has four functions that can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Module B has four functions, all of them dealing with the core functionality.
    There are no unrelated functions in this module from its core functionality. The
    module B has 100% cohesion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module A has four functions, three of which are related to its core functionality,
    but the last one (frequency) isn't. This gives module A approximately `75%` cohesion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three of module B has functions that depend on one function in module A, namely,
    square. This makes module B strongly coupled to module A. coupling at function
    level is *75%* from module B ? A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module A doesn't depend on any functionality of module B. Module A will work
    independent of module B. coupling from module A ? B is zero.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us now look at how we can improve the cohesion of module A. In this case,
    it is as simple as dropping the last function which doesn't really belong there.
    It could be dropped out entirely or moved to another module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the rewritten module A code, now with 100% cohesion with respect to
    its responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now analyze the quality of coupling from module B? A, and look at the
    risk factors of modifiability of code in B with respect to code in A, which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The three functions in B depend on just one function in module A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function is named squares, which takes in an array and returns each of its
    member squared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function signature (API) is simple, so chances of changing the function
    signature in the future is less.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no two-way coupling in the system. The dependency is only from direction
    B ? A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, even though there is strong coupling from B to A, it is good
    coupling, and doesn't affect the modifiability of the system in any way at all.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at another example.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring cohesion and coupling – string and text processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider a different use case now, an example with functions which do
    a lot of string and text processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the listing of module B which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the coupling and cohesion analysis of these modules given
    in following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Module | Core functions | Unrelated functions | Function dependencies |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | 2 | 0 | 1 x 1 = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| A | 2 | 0 | 1 x 1 = 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Here is an explanation of these numbers in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: Module A and B has two functions each, each of them dealing with the core functionality.
    Modules A and B both have *100%* cohesion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One function of module A is dependent on one function of module B. Similarly,
    one function of module B is dependent on one function of module A. There is strong
    coupling from A? B, and also from B ? A. In other words, the coupling is bidirectional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional coupling between two modules ties their modifiability to each
    other very strongly. Any changes in module A will quickly cascade to the behavior
    of module B and viceversa. In other words, this is bad coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring strategies for modifiability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen some examples of good and bad coupling and also cohesion,
    let us get to the strategies and approaches that a software designer or architect
    can use to reduce the effects of these aspects on modifiability in order to improve
    the modifiability of the software system.
  prefs: []
  type: TYPE_NORMAL
- en: Providing explicit interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A module should to and mark a set of functions, classes, or methods as the **interface**
    it provides to external code. This can be thought of as the API of this module,
    which is exported from it. Any external code which uses this API would become
    a client to the module.
  prefs: []
  type: TYPE_NORMAL
- en: Methods or functions which the module considers internal to its function, and
    which do not make up its API, should either be explicitly made private to the
    module or should be documented as such.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, which doesn't provide variable access scope for functions or class
    methods, this can be done by conventions such as prefixing the function name with
    a single or double underscore, thereby signaling to potential clients that these
    functions are internal and shouldn't be referred to from outside.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing two-way dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the examples earlier, coupling between two software modules is manageable
    if the coupling direction is one-way. However, bidirectional coupling creates
    very strong linkages between modules, which can complicate the usage of the modules
    and increase their maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: In languages like Python, which uses reference-based garbage collection, this
    may also create cryptic referential loops for variables and objects, thereby making
    their garbage collection difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional dependencies can be broken by refactoring the code in such a way
    that a module always uses the other one and not vice-versa. In other words, encapsulate
    all related functions in the same module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are our modules A and B of the earlier example, rewritten to break their
    bidirectional dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next is the listing of module B.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We achieved this by simply moving the function `common`, which picks common
    words from two strings from module B to A. This is an example of refactoring to
    improve modifiability.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract common services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Usage of helper modules which abstract common functions and methods can reduce
    coupling between two modules, and also increase their cohesion. For example, in
    the first example, the module A acts as a helper module for module B. In the second
    example also, after the refactoring step, module A acts as a helper module to
    module B.
  prefs: []
  type: TYPE_NORMAL
- en: Helper modules can be thought of as intermediaries or mediators, which abstract
    common services for other modules so that the dependent code is all abstracted
    in one place without duplication. They can also help modules to increase their
    Cohesion by moving away unwanted or unrelated functions to a suitable helper module.
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we find similar code or functionality occurring in classes, it might be
    a good time to refactor them so as to create class hierarchies so that common
    code is shared by virtue of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another module, `urlrank`, which performs the same function on URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Both these modules perform similar functions of ranking a set of input data
    in terms of how much a given keyword appears in them. Over time, these classes
    could develop a lot of similar functionality, and the organization can end up
    with a lot of duplicate code, reducing modifiability.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use inheritance to help us here to abstract away the common logic in
    a parent class. Here is the parent class named `RankBase`, which accomplishes
    this by moving away all common code to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the `textrank` and `urlrank` modules rewritten to take advantage
    of the logic in the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the modified listing for the `urlrank` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Not only has refactoring reduced the size of the code in each module, but it
    has also resulted in improved modifiability of the classes by abstracting the
    common code to a parent module/class, which can be developed independently.
  prefs: []
  type: TYPE_NORMAL
- en: Using late binding techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The late binding refers to the practice of postponing the binding of values
    to parameters as late as possible in the order of execution of a code. Late binding
    allows the programmer to defer the factors which influence code execution, and
    hence the results of execution and performance of the code, to a later time by
    making use of multiple techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some late-binding techniques which can be used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plugin mechanisms**: Rather than statically binding modules together, which
    increases coupling, this technique uses values resolved at runtime to load plugins
    which execute a specific dependent code. Plugins can be Python modules whose names
    are fetched during computations done at runtime, or via IDs or variable names
    loaded from database queries or from configuration files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brokers/Registry lookup services**: Some services can be completely deferred
    to brokers, which look up the service names from a registry on demand, and call
    them dynamically and return results. An example may be a currency exchange service,
    which accepts a specific currency transformation as input (say USDINR), and looks
    up and configures a service for it dynamically at runtime, thereby requiring only
    the same code to execute on the system at all times. Since there is no dependent
    code on the system that varies with the input, the system remains immune from
    any changes required if the logic for the transformation changes, as it is deferred
    to an external service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notification services**: Publish/Subscribe mechanisms which notify subscribers
    when the value of an object changes or when an event is published, can be useful
    to decouple systems from a volatile parameter and its value. Rather than tracking
    changes to such variables/objects internally, which may need a lot of dependent
    code and structures, such systems keep their clients immune to the changes in
    the system which affect and trigger the objects internal behavior, but bind them
    only to an external API, which simply notifies the clients of the changed value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment time binding**: By keeping the variable values associated to names
    or IDs in configuration files, we can defer object/variable binding to deployment
    time. The values are bound at startup by the software system once it loads its
    configuration files, which can then invoke specific paths in the code that creates
    appropriate objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach can be combined with object-oriented patterns like Factories,
    which create the required object at runtime given the name or ID, thus, keeping
    the clients which are dependent on these objects immune from any internal changes,
    increasing their modifiability.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using creational patterns**: Creational design patterns such as factory or
    builder, which abstract the task of creating of an object from the details of
    creating it, are ideal for separation of concerns for client modules which don''t
    want their code to be modified when the code for creation of a dependent object
    changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These approaches, when combined with deployment/configuration time or dynamic
    binding (using Lookup Services), can greatly increase the flexibility of a system
    and aid its modifiability.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at examples of Python patterns in a later chapter in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics – tools for static analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static code analysis tools can provide a rich summary of information on the
    static properties of your code, which can provide insights into aspects like complexity
    and modifiability/readability of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has a lot of third-party tool support, which helps in measuring the
    static aspects of Python code such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Conformance to coding standards like PEP-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code complexity metrics like the McCabe metric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors in code such as syntax errors, indentation issues, missing imports, variable
    overwrites, and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic issues in code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code smells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the most popular tools in the Python ecosystem which
    can perform such static analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pylint**: Pylint is a static checker for Python code, which can detect a
    range of coding errors, code smells, and style errors. Pylint uses a style close
    to PEP-8\. The newer versions of Pylint also provide statistics about code complexity,
    and can print reports. Pylint requires the code to be executed before checking
    it. You can refer to the [http://pylint.org](http://pylint.org) link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pyflakes**: Pyflakes is a more recent project than Pylint. It differs from
    Pylint in that it need not execute the code before checking it for errors. Pyflakes
    does not check for coding style errors, and only performs logic checks in code.
    You can refer to the [https://launchpad.net/pyflakes](https://launchpad.net/pyflakes)
    link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**McCabe**: It is a script which checks and prints a report on the McCabe complexity
    of your code. You can refer to the [https://pypi.python.org/pypi/mccabe](http://pypi.python.org/pypi/mccabe)
    link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pycodestyle**: Pycodestyle is a tool which checks your Python code against
    some of the PEP-8 guidelines. This tool was earlier called PEP-8\. Refer to the
    [https://github.com/PyCQA/pycodestyle](http://github.com/PyCQA/pycodestyle) link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flake8**: Flake8 is a wrapper around the Pyflakes, McCabe, and pycodestyle
    tools, and can perform a number of checks including the ones provided by these
    tools. Refer to the [https://gitlab.com/pycqa/flake8/](http://gitlab.com/pycqa/flake8/)
    link.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are code smells?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C**ode smells** are surface symptoms of deeper problems with your code. They
    usually indicate problems with the design which can cause bugs in the future or
    negatively impact development of the particular piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: Code smells are not bugs themselves, but they are patterns that indicate that
    the approach to solving problems adopted in the code is not right, and should
    be fixed by refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common code smells are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '**God Object**: A class which tries to do too many things. In short, this class
    lacks any kind of cohesion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constant Class**: A class that''s nothing but a collection of constants,
    which is used elsewhere, and hence, should not ideally belong here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refused Bequest**: A class which doesn''t honor the contract of the base
    class, and hence, breaks the substitution principle of inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Freeloader**: A class with too few functions, which do almost nothing and
    add little value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature Envy**: A class which is excessively dependent on methods of another
    class indicating high coupling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the method/function level:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long method**: A method or function which has grown too big and complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter creep**: Too many parameters for a function or method. This makes
    the call ability and testability of the function difficult.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cyclomatic complexity**: A function or method with too many branches or loops,
    which creates a convoluted logic that is difficult to follow, and can cause subtle
    bugs. Such a function should be refactored and broken down to multiple functions,
    or the logic rewritten to avoid too much branching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overly long or short identifiers**: A function which uses either overly long
    or overly short variable names such that their purpose is not clear from their
    names. The same is applicable to the function name as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A related antipattern to code smell is design smell, which are the surface symptoms
    in the design of a system that indicate underlying deeper problems in the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclomatic complexity – the McCabe metric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cyclomatic complexity is a measure of complexity of a computer program. It is
    computed as the number of linearly independent paths through the program's source
    code from start to finish.
  prefs: []
  type: TYPE_NORMAL
- en: For a piece of code with no branches at all, such as the one given next, the
    cyclomatic complexity would be `1`, as there is just one path through the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A piece of code with one branch, like the following one, will have a complexity
    of 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The use of Cyclomatic complexity as a metric using the control graph of a code
    was developed by Thomas J. McCabe in 1976\. Hence, it is also called McCabe complexity
    or the McCabe index.
  prefs: []
  type: TYPE_NORMAL
- en: To measure the metric, the control graph can be pictured as a directed graph,
    where the nodes represent the blocks of the program and edges represent control
    flow from one block to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'With respect to the control graph of a program, the McCabe complexity can be
    expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*M = E - N + 2P*'
  prefs: []
  type: TYPE_NORMAL
- en: where,
  prefs: []
  type: TYPE_NORMAL
- en: '*E => Number of edges in the graph,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*N => Number of nodes in the graph*'
  prefs: []
  type: TYPE_NORMAL
- en: '*P => Number of connected components in the graph*'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the package `mccabe`, written by Ned Batcheldor, can be used to measure
    a program's Cyclomatic complexity. It can be used as a standalone module, or as
    a plugin to programs like Flake8 or Pylint.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is how we measure the Cyclomatic complexity of the two code
    pieces given earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cyclomatic complexity – the McCabe metric](../Images/image00375.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: McCabe metrics for some sample Python programs
  prefs: []
  type: TYPE_NORMAL
- en: The argument `–min` tells the `mccabe` module to start measuring and reporting
    from the given McCabe index.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now try a few of the aforementioned tools, and use them on an example
    module to find out what kind of information these tools report.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The purpose of the following sections is not to teach you the usage of these
    tools or their command-line options—these can be picked up by the reader via the
    tool's documentation. Instead, the purpose is to explore the depth and richness
    of information that these tools provide with respect to the style, logic, and
    other issues with the code.
  prefs: []
  type: TYPE_NORMAL
- en: For purposes of this testing, the following contrived module example has been
    used. It is written purposefully with a lot of coding errors, style errors, and
    coding smells.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the tools we are using lists errors by line numbers, the code has been
    presented with numbered lines so that it is easy to follow the output of the tools
    back to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Running Static Checkers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us see what Pylint has to say about our rather horrible looking piece of
    test code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pylint prints a lot of styling errors, but the purpose of this example being
    to focus on logic issues and code smells, the log is shown only starting from
    these reports.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the detailed output captured in two screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Static Checkers](../Images/image00376.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2\. Pylint output for metric test program (page 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the another screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Static Checkers](../Images/image00377.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pylint output for metric test program (page 2)
  prefs: []
  type: TYPE_NORMAL
- en: Let us focus on those very interesting last 10-20 lines of the Pylint report,
    skipping the earlier styling and convention warnings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the errors, classified into a table. We have skipped similar occurrences
    to keep the table short:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Error | Occurrences | Explanation | Type of Code Smell |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid function name | function `fn` | Name `fn` is too short toexplain
    what the function does | Too short identifier |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid variable name | variables `x`, `y` of the `fn` function `f` | Names
    `x`, `y` too short to indicate what the variables represent | Too short identifier
    |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid function name | Function name `find_optimal_route_to_my_office_from_home`
    | Function name is too long | Too long identifier |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid variable name | variable `d` of function `find_optimal`... | Name
    `d` too short to indicate what the variable represents | Too short identifier
    |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid class name | Class `C` | Name `C` doesn''t tell anything about the
    class | Too short identifier |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid method name | Class `C`: Method `f` | Name `f` too short to explain
    what it does | Too short identifier |'
  prefs: []
  type: TYPE_TB
- en: '| Invalid `__init__` method | Class `D`: Method `__init__` | Doesn''t call
    base class''s `__init__` | Breaks contract with base Class |'
  prefs: []
  type: TYPE_TB
- en: '| Arguments of f differ in class `D` from class `C` | Class `D`: Method `f`
    | Method signature breaks contract with base class''s signature | Refused bequest
    |'
  prefs: []
  type: TYPE_TB
- en: '| Arguments of `g` differ in class `D` from class `C` | Class `D`: Method `g`
    | Method signature breaks contract with base class''s signature | Refused bequest
    |'
  prefs: []
  type: TYPE_TB
- en: As you can see, Pylint has detected a number of code smells, which we discussed
    in the previous section. Some of the most interesting ones are how it detected
    the absurdly long function name, and also how the subclass D breaks the contract
    with the base class `C` in its `__init__` and other methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what `flake8` has to tell about our code. We will run it in order
    to report the statistics and summary of error counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![Running Static Checkers](../Images/image00378.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4\. flake8 static check output of metric test program
  prefs: []
  type: TYPE_NORMAL
- en: As you would've expected from a tool which is written to mostly follow PEP-8
    conventions, the errors reported are all styling and convention errors. These
    errors are useful to improve the readability of the code, and make it follow closer
    to the style guidelines of PEP-8.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can get more information about the PEP-8 tests by passing the option `–show-pep8`
    to Flake8.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a good time to now check the complexity of our code. First, we will use
    `mccabe` directly, and then call it via Flake8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Static Checkers](../Images/image00379.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: mccabe complexity of metric test program
  prefs: []
  type: TYPE_NORMAL
- en: As expected, the complexity of the office-route function is too high, as it
    has too many branches and sub-branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'As `flake8` prints too many styling errors, we will grep specifically for the
    report on complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Static Checkers](../Images/image00380.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: mccabe complexity of metric test program as reported by flake8
  prefs: []
  type: TYPE_NORMAL
- en: As expected, Flake8 reports the function find `_optimal_route_to_my_office_from_home`
    as too complex.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a way to run `mccabe` as a plugin from Pylint as well, but since it
    involves some configuration steps, we will not cover it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last step, let us run `pyflakes` on the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Static Checkers](../Images/image00381.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Static analysis output of pyflakes on the metric test code
  prefs: []
  type: TYPE_NORMAL
- en: There is no output! So Pyflakes finds no issues with the code. The reason is
    that PyFlakes is a basic checker, which does not report anything beyond the obvious
    syntax and logic errors, unused imports, missing variable names, and the liked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add some errors into our code, and rerun Pyflakes. Here is the adjusted
    code with line numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Static Checkers](../Images/image00382.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8\. Static analysis output of pyflakes on the metric test code, after
    modifications
  prefs: []
  type: TYPE_NORMAL
- en: Pyflakes now returns some useful information in terms of a missing name (random),
    unused import (`sys`), and an undefined name (variable `c` in the newly introduced
    function `myfunc`). So it does perform some useful static analysis on the code.
    For example, the information on the missing and undefined names is useful to fix
    obvious bugs in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good idea to run Pylint and/or Pyflakes on your code to report and figure
    out logic and syntax errors after the code is written. To run Pylint to report
    only errors, use the -E option. To run Pyflakes, just follow the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how static tools can be used to report a wide range of
    errors and issues in our Python code, let us do a simple exercise of refactoring
    our code. We will take our poorly written metric test module as the use case (the
    first version of it), and perform a few refactoring steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the rough guidelines we will follow when doing the refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fix complex code first**: This will get a lot of code out of the way, as
    typically, when a complex piece of code is refactored, we end up reducing the
    number of lines of code. This overall improves the code quality, and reduces code
    smells. You may be creating new functions or classes here, so it always helps
    to perform this step first.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Do an analysis of the code now**: It is a good idea to run the complexity
    checkers at this step, and see how the overall complexity of the code—class/module
    or functions—has been reduced. If not, iterate again.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fix code smells next**: Fix any issue with code smells—class, function, or
    module—next. This gets your code into a much better shape, and also improves the
    overall semantics.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Run checkers**: Run checkers like Pylint on the code now, and get a report
    on the code smells. Ideally, they should be close to zero, or reduced very much
    from the original.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Fix low-hanging fruits**: Fix low-hanging fruits such as code style and convention
    errors, the last. This is because, in the process of refactoring, trying to reduce
    complexity and code smells, you typically would introduce or delete a lot of code.
    So, it doesn''t make sense to try and improve the coding convention at earlier
    stages.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Perform a final check using the tools**: You can run Pylint for code smells,
    Flake8 for PEP-8 conventions, and Pyflakes for catching the logic, syntax, and
    missing variable issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here is a step-by-step demonstration of fixing our poorly written metric test
    module using this approach in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code – fixing complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the complexity is in the office route function, so let''s try and fix
    it. Here is the rewritten version (showing only that function here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding rewrite, we got rid of the redundant if.. else conditions.
    Let us check the complexity now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring code – fixing complexity](../Images/image00383.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'mccabe metric of metric test program after refactoring step #1'
  prefs: []
  type: TYPE_NORMAL
- en: We were able to reduce the complexity from `7` to `5`. Can we do better?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following piece of code, the code is rewritten to use ranges of values
    as keys, and the corresponding return value as values. This simplifies our code
    a lot. Also, the earlier default return at the end would never have got picked,
    so it is removed now, thus getting rid of a branch and reducing complexity by
    one. The code has become much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![Refactoring code – fixing complexity](../Images/image00384.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'mccabe metric of metric test program after refactoring step #2'
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the function is now reduced to `4`, which is manageable.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code - fixing code smells
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to fix code smells. Thankfully, we have a very good list from
    the previous analysis, so this is not too difficult. Mostly, we need to change
    function names, variable names, and also fix the contract issue from sub-class
    to base-class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code with all the fixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us run Pylint on this code, and see what it outputs this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring code - fixing code smells](../Images/image00385.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Pylint output of refactored metric test program
  prefs: []
  type: TYPE_NORMAL
- en: You see that the number of code smells has boiled down to near zero except a
    complaint of lack of `public` methods, and the insight that the method `some_func`
    of class `MiscClassD` can be a function, as it does not use any attributes of
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have invoked Pylint with the option `–reports=n` in order to avoid Pylint
    printing its summary report, as it would make the entire output too long to display
    here. These reports can be enabled by calling Pylint without any argument.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring code - fixing styling and coding issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have fixed the major code issues, the next step is to fix code style
    and convention errors. However, in order to shorten the number of steps and the
    amount of code to be printed in this book for this exercise, this was already
    merged along with the last step, as you may have guessed from the output of Pylint.
  prefs: []
  type: TYPE_NORMAL
- en: Except for a few whitespace warnings, all the issues are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our refactoring exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the architectural quality attribute of modifiability,
    and its various aspects. We discussed readability in some detail, including the
    readability antipatterns along with a few coding antipatterns. During the discussion,
    we understood that Python, from its ground up, is a language written for readability.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the various techniques for improving readability of code, and spent
    some time with the various aspects of code commenting and looked at documentation
    strings in Python at the function, class, and module levels. We also looked at
    PEP-8, the official coding convention guideline for Python, and learned that continuous
    refactoring of code is important to keep up its modifiability and to reduce its
    maintenance costs in the long term.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at some rules of thumb for code comments, and went on to discuss
    the fundamentals of modifiability, namely, coupling and cohesion of code. We looked
    at different cases of coupling and cohesion with a few examples. We then went
    on to discuss the strategies of improving modifiability of code such as providing
    explicit interfaces or APIs, avoiding two-way dependencies, abstracting common
    services to helper modules, and using inheritance techniques. We looked at an
    example where we refactored a class hierarchy via inheritance to abstract away
    common code and to improve the modifiability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end, we listed the different tools providing static code metrics
    in Python such as PyLint, Flake8, PyFlakes, and others. We learned about McCabe
    Cyclomatic complexity with the help of a few examples. We also learned what code
    smells are, and performed a refactoring exercise to improve the quality of the
    piece of code in stages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss another important quality attribute of software
    architecture, namely, Testability.
  prefs: []
  type: TYPE_NORMAL
