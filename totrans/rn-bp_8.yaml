- en: E-Commerce App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Online shopping is something most retailers have adopted, but users are slowly
    migrating from websites to mobile apps. That's why e-commerce has set a strong
    focus on responsive websites, which can be seamlessly accessed from a desktop
    computer or a mobile browser. Along with that, users also demand higher standards
    of quality which cannot always be met by even the most responsive websites. Loading
    times, laggy animations, non-native components, or a lack of native features may
    hurt user experiences resulting in low conversion rates.
  prefs: []
  type: TYPE_NORMAL
- en: Building our e-commerce app in React Native can reduce the development efforts
    required due to the possibility of reusing some web components, which were already
    designed for the web (using React.js). Besides that, we can reduce the time to
    market and development costs, making React Native a very attractive tool for small
    and medium-sized businesses willing to sell their products or services online.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on building a bookstore for iOS and Android reusing
    100% of our code. Despite focusing on a bookstore, the same codebase could be
    reused to sell any kind of products just by replacing the products list.
  prefs: []
  type: TYPE_NORMAL
- en: To free us from building an API for this app, we will mock all the data behind
    a fake API service. The state management library we will use for this app will
    be Redux and its middleware `redux-thunk` to handle asynchronous calls.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous calls and redux-thunk were already explained in [Chapter 4](377902fe-8517-4d67-b0c2-3bc5648b4aa0.xhtml),
    *Image Sharing App*. It may be useful to review its usage in that chapter to reinforce
    the main concepts before moving into the Actions sections in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation will be handled by `react-navigation` as it is the most complete
    and performant navigation library in React Native developed to date. Finally,
    we will use some very useful libraries, especially for e-commerce apps, such as `react-native-credit-card-input`,
    which handles credit card inputs.
  prefs: []
  type: TYPE_NORMAL
- en: While building this app, we will emphasize several quality aspects to make sure
    the app is production-ready by the end of the chapter. For example, we will use
    type validation extensively for properties and code linting.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of putting much effort into the app's look and feel, as we did in previous
    chapters, we will focus on functionality and code quality for this one. Nevertheless,
    we will build it in a way which will allow any developer to style it easily at
    a later stage. With that in mind, let's take a look at what the app will look
    like once finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from the home screen where all the books are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/35d223a1-9081-46a0-8a74-f23d43e13360.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Android, we will add a drawer navigation pattern instead of a tabbed one
    as Android users are more used to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e509bfbc-76aa-4c7c-91e3-82f44799e3c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The drawer can be opened by swiping the screen from the left edge to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/eab6735d-bb99-4584-9320-cb66e6699cbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see what happens when a user taps on one of the books from the
    home screen (list of books available):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/00265d03-c3d9-48d9-b6fa-41d1ca088047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Android version for this screen will be similar, as only a couple of native
    components will adopt a different styling, depending on which platform the app
    is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/dd9bd883-85d8-4171-b83b-746b52d0b546.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Only logged-in users will be able to buy books from our app. This means that
    we need to pop up a login/registration screen at a certain point, and clicking
    on the BUY! button seems like an appropriate moment for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fd7a6b32-2641-4a77-8a21-33851ddc5ef0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, the Android version will look different from the iOS because
    of the difference in styles between native buttons on each platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2a40e2ee-0ca2-44a5-9e07-3303edebf0af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For testing purposes, we created a test account in this app with the following
    credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: 'e-mail: `test@test.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'password: `test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case the user still doesn''t have an account, she will be able to click
    on the OR REGISTER button to create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f1c5c3ea-c226-4389-b911-27d3f8762d3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This form will include the following validations:'
  prefs: []
  type: TYPE_NORMAL
- en: e-mail and repeat e-mail field values match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the fields are entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case any of these validations fail, we will display an error message at
    the bottom of this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b99f89e2-e60f-4660-9d9f-3bdf55f6fea4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After registering, the user will be logged in automatically and will be able
    to continue her purchase journey by reviewing her cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/866c27f0-574b-4849-aa0c-e52bc0ea5ce5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, the Android version will show small differences in the looks of this
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7e7acaf7-3ef6-4504-850f-3109090f8fbf.png)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on the KEEP BUYING button on this screen, the user will be sent
    back to the home screen where all the available books are displayed for her to
    continue adding items to her cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case she decides to confirm her purchase, the app will display a payment
    screen in which the user can enter her credit card details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5ad5d072-b725-4f89-8b66-bce250083042.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Pay now button will only be active when all the data has been entered correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7a3462f7-1be7-48f8-a8b9-8ee78512443c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For testing purposes, the developers can use the following credit card data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Card number: `4111 1111 1111 1111`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Date of expiration: any date in the future'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CVC/CVV: `123`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the payment has gone through, the user will receive a confirmation of
    her purchase detailing all the items which will be sent to her address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6e87bdd5-c49c-4d41-9748-cb23c1c3155b.png)'
  prefs: []
  type: TYPE_IMG
- en: This screen will finish the purchase journey. At this stage, the user can click
    on the Continue Shopping button to go back to the list of available products.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two more journeys available through the tabbed/drawer navigation.
    The first one is to the My Profile section to review her account details or Logout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7d246216-405b-4448-8de7-8b05b90a273f.png)'
  prefs: []
  type: TYPE_IMG
- en: If the user still didn't log in, the app will show the login/register form on
    this screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last journey is accessed through the Sales tab/menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/728b0175-6837-4357-9974-73998e5c0539.png)'
  prefs: []
  type: TYPE_IMG
- en: By pressing Add to cart, the user will be sent directly to the purchase journey
    where she can add more items to the cart or directly confirm the purchase by entering
    her login (if not present) and payment details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, every time we need to receive data from the backend API, we will display
    a spinner to let the user know there is some activity happening in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/85b9c5c9-85ef-4a28-88cf-8c9949f8e628.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we will mock all the API calls, we will need to add a small delay to their
    responses in order to see the spinners, so the developers can have a similar experience
    as users will have, when we replace the mocked up calls for real API requests.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This app will use Redux, as its state management library, which will define
    the folder structure we will be using throughout this chapter. Let''s start by
    initializing the project through React Native''s CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have seen in previous chapters where we used Redux, we need our folder
    structure to accommodate different module types:  `reducers`, `actions`, `components`, `screens`, and `api` calls.
    We will do this in the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f421a392-a486-4146-aa7f-b4ca0f63b299.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Apart from the folder structure created by React Native''s CLI, we added the
    following folders and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/components`: This will hold the reusable visual components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/reducers`: This will store the reducers, which modify the state of the
    app by detecting which actions were triggered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/screens`: This will store all the different visual containers connecting
    them to the app state through Redux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/api.js`: By the end of the chapter, we will have all the required API
    calls mocked inside this file. In case we wanted to connect to a real API, we
    would just need to change this file to make HTTP requests to the proper endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`src/main.js`: This is the entry point to the app and will set up the navigation
    components and initialize the store in which the app''s state will live.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `src/components` folder will contain the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9d122f1c-c516-4414-9aaf-03e28883928b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `src/reducers` will hold the three different data domains in our app: user,
    payment, and products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/de00dfb4-eacb-479f-aaa6-894c70ff8210.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Last, the `screens` folder will store a file for each of the screens the user
    will be able to see in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cf773ca1-d83d-49c0-957b-1f0f067e9e4b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look now at the `package.json` file we will use to install all
    required libraries for this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using the following extra libraries for our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`native-base`: This is for styled components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prop-types`: This is for property validation inside components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-native-credit-card-input`: This is for the user to enter her credit
    card details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-redux`: This and Redux are used for state management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redux-thunk`: This is for connecting Redux to asynchronous calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides all these dependencies, we will add some other `dev` dependencies,
    which will help our developers write code in a very comfortable and confident
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`babel-eslint`: This is for linting our ES6 code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eslint-config-airbnb`: This is the set of coding styles we will use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prettier`: This is the code formatter we will use to support ES6 and JSX.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having this `package.json` in place, we are ready to install all these dependencies
    by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Before starting to write code let's configure our linting rules and the text
    editor to take full advantage of the code formatting tools we will use in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Linting and code formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing clean, bug-free code is challenging. There are a lot of pitfalls that
    we may face such as indentation, importing/exporting misses, tags not closed,
    and so on. Having to overcome all of them manually is a tough job which can distract
    us from our main purpose: writing functional code. Luckily, there are a handful
    of very useful tools to help us with this task.'
  prefs: []
  type: TYPE_NORMAL
- en: The tools we will be using in this chapter to ensure our code is clean will
    be ESLint ([https://eslint.org/](https://eslint.org/)) and Prettier ([https://github.com/prettier/prettier](https://github.com/prettier/prettier)).
  prefs: []
  type: TYPE_NORMAL
- en: ESLint will be in charge of identifying and reporting on patterns found in the
    ES6/JavaScript code, with the goal of making the code more consistent and avoiding
    bugs. For example, ESLint will flag any use of non-declared variables, exposing
    the error while we are writing code instead of waiting until compilation.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Prettier enforces a consistent code style across your entire
    codebase because it disregards the original styling by parsing it away and reprinting
    it with its own rules that take the maximum line length into account, wrapping
    code when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use ESLint to enforce Prettier code styles directly in our browser.
    Our first step will be to configure ESLint to adapt to the formatting and linting
    rules we want to enforce in our project. In the case of this app, we will follow
    Airbnb's and Prettier's rules as we already installed them as a developer's dependency
    in this project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure ESLint will use these rules, we will create a `.eslintrc` file containing
    all the options we want to set up when linting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We won't explore much in how to configure ESLint much in this book as their
    documentation is quite extensive and well explained. For this project, we will
    only need to extend Airbnb's and Prettier's rules while setting the corresponding
    plugins (`react`, `react-native`, `flowtype`, and `prettier`) in the configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Setting rules for the linter is a matter of taste, and in case of not having
    had much experience with it, it is always good to start with a set of prebuilt
    rules (such as the Airbnb rules) and modify them one rule at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we would need to configure our code editor to display those rules,
    flag them, and ideally fix them on saving. Visual Studio Code does a very good
    job at integrating these linting/code formatting rules as its ESLint plugin ([https://github.com/Microsoft/vscode-eslint](https://github.com/Microsoft/vscode-eslint))
    does all the work for us. It is highly recommended to enable the `eslint.autoFixOnSave`
    option to ensure the editor fixes all the code formatting issues after saving
    the file we are working on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our linting tools in place, let's start writing our app's codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes and main files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Both the iOS and Android platforms will share the same codebase using `src/main.js`
    as an entry point. Therefore, we will change `index.ios.js` and `index.android.js`
    to import `main.js` and initialize the app with that component as a root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same structure we used for all apps sharing codebase throughout
    the book. Our `main.js` file should now initialize the navigation components and
    set up the store we will use to hold the app''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main navigator (`Navigator`) will be a tabbed navigation on iOS and a drawer
    navigator on Android. This navigator will be the root for the app and will use
    two nested stacked navigators (`ProductsNavigator` and `PurchaseNavigator`), which
    will cover the following journeys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductsNavigator`: ProductList | ProductDetail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PurchaseNavigator`: MyCart | Payment | PaymentConfirmation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each step in each journey is a specific screen in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Login and registration are not steps in those journeys since they will be treated
    as pop-up screens displaying only if they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in this file is in charge of setting up Redux, applying all the
    reducers and middleware (only `redux-thunk` in our case), which will be in place
    for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once `store` is created, we pass it to the provider in the root of our app to
    make sure the state will be shared among all the screens. Before moving into each
    individual screen, let's create our reducers and actions so that we can have them
    available to be used when building the screens.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous chapters, we split our Redux-specific code (reducers, actions,
    and action creators) in the standard way that is documented in Redux''s documentation.
    To make it easy to maintain in the future, we will use a different approach for
    this app: Redux Ducks ([https://github.com/erikras/ducks-modular-redux](https://github.com/erikras/ducks-modular-redux)).'
  prefs: []
  type: TYPE_NORMAL
- en: Redux Ducks is a proposal for bundling together reducers, action types, and
    actions when using Redux. Instead of creating separate folders for reducers and
    actions, they are put together in files based on which kind of functionality they
    handle, reducing the number of files to deal with when implementing new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `products` reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This file handles all the business logic related to products in our app. Let''s
    review each action creator and how it modifies the state when processed by the
    reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addProductToCart()`: This will dispatch the `ADD_TO_CART` action, which will
    be picked up by the reducer. If the provided product is already present in the
    cart inside the state, it will increase the quantity by one item. Otherwise, it
    will insert the product into the cart and set its quantity to one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeProductFromCart()`: This action does the opposite to the previous one.
    It decreases the quantity of this product if already present in the cart stored
    in the state. If the quantity of this product is one, the reducer will remove
    the product from the cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchProducts()`: This is an asynchronous action and therefore will return
    a function for `redux-thunk` to pick it up. It will make a `GET` request (implemented
    by the `get()` function in the `api.json` file) to the API to the `/products`
    endpoint. It will also handle the response from this endpoint, dispatching a `FETCH_SUCCESS`
    action when the request is successfully fulfilled, or a `FETCH_ERROR` action in
    case the request is errored out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resetCart()`: This dispatches a `RESET_CART` action, which will be used by
    the reducer to clear all the cart details from the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we are following Redux Ducks recommendation, all these actions are put together
    in the same file making it easy to determine what actions do and what effect they
    cause in the application state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move now to the next reducer: the `user` reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The action creators in this reducer are quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '`login()`: This takes an `email` and `password` to dispatch the `LOGIN` action
    and then makes a `POST` request to the `/login` endpoint to validate the credentials.
    If the API call becomes successful, the action creator will dispatch a `LOGIN_SUCCESS`
    action logging the user in. In case the request fails, it will dispatch a `LOGIN_ERROR`
    action so the user can know what happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`register()`: This is similar to the `login()` action creator; it will dispatch
    a `REGISTER` action, then a `REGISTER_SUCCESS` or `REGISTER_ERROR`, depending
    on how the API call returns. If the registration was successful, the user data
    will be stored in the application''s state, flagging that the user has logged
    in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout()`: This dispatches a `LOGOUT` action, which will make the reducer
    clear the `user` object in the application state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last reducer deals with payments data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only two action creators in this reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pay()`: This takes a user, a cart, and a credit card and calls the `/pay`
    endpoint in the API to make a payment. If the payment is successful, it triggers
    a `PAY_SUCCESS` action, otherwise, it triggers a `PAY_ERROR` action to notify
    the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resetPayment()`: This clears any payment data by triggering the `RESET_PAYMENT`
    action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen these action creators contact the API in several ways. Let's now
    create some API methods, so the action creators can interact with the application's
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API service we will be using will use two HTTP methods (`GET` and `POST`)
    and four endpoints (`/products`, `/login`, `/register`, and `/pay`). We will mock
    up this service for testing and development reasons but will leave the implementation
    open to plug in external endpoints easily at a later stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: All calls are wrapped inside a `setTimeout()` function with 1-second delays
    to simulate network activity so indicators can be tested. The service only replies
    successfully when credentials are `test@test.com/test`. On the other hand, the
    `pay()` service only returns a successful response when the CVC/CVV code is `123`.
    The register call just returns the provided data as successfully registered user
    data.
  prefs: []
  type: TYPE_NORMAL
- en: This setTimeout() trick is used to mock asynchronous calls up as they would
    happen with a real backend. It is an useful way to develop front-end solutions
    before the backend or testing environments are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now move on to the screens in the application.
  prefs: []
  type: TYPE_NORMAL
- en: ProductList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our home screen displays a list of products available to be purchased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Right after this screen is mounted, it will retrieve the latest list of available
    products by invoking `this.props.fetchProducts();`. This will trigger a re-render
    in the screen, so all the available books are displayed on the screen. For that
    to happen, we rely on Redux updating the state (through the product reducer) and
    injecting the new state into this screen by calling the `connect` method, to which
    we will need to pass `mapStateToProps` and `mapStateActionsToProps` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`mapStateToProps` will be in charge of extracting the list of products from
    `state` while `mapStateActionsToProps` will connect each action with the `dispatch()`
    function, which will connect those actions with the Redux state, applying each
    triggered action to all the reducers. In this screen, we are only interested in
    product-related actions, so we will bind only `ProductActions` and the `dispatch`
    function together through the `bindActionCreators` Redux function.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `render` method, we use the `map` function to translate the list
    of retrieved products into several `<ListItem/>` components, which will be displayed
    inside `<List/>`. Above this list, we will display `<Spinner/>` while waiting
    for the network request to be fulfilled: `{this.props.loading && <Spinner />}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also added property validation through the `prop-types` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we will get a warning every time this component receives a wrongly
    typed prop, or it actually fails to receive one of the required props. In this
    case, we expect to receive:'
  prefs: []
  type: TYPE_NORMAL
- en: A function named `fetchProducts`, which will request the list of available products
    to the API. It will be provided by Redux through `mapStateActionsToProps` as defined
    on this screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `products` array that contains the list of available products. This will be
    injected by Redux through the previously stated `mapStateToProps` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A loading Boolean to flag network activity (also provided by Redux through `mapStateToProps`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A navigation object provided by `react-navigation` automatically. We mark it
    as type `any` as it is an external object, which may change its type out of our
    control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these will be available to be used inside our component's props (`this.props`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to note about this container is how we are going to deal with
    the user actions. In this screen, there is only one action: the user clicking
    on a product item to see its details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the user taps on a specific product, this screen will call the `navigate`
    function in the `navigation` prop to move to our next screen, `ProductDetail`.
    Instead of saving the selected product in the state through an action, we will
    pass it directly using `navigation` options to simplify our store.
  prefs: []
  type: TYPE_NORMAL
- en: ProductDetail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This screen will show the user all the details about the selected product and
    allow her to add this selected product to her cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`ProductDetail` requires Redux to provide it with the user details stored in `state`.
    This is achieved by calling the `connect` method, passing a `mapStateToProps`
    function which will extract the user from the specified `state` and return it
    to be injected as `prop` in the screen. It also requires an action from Redux: `addProductToCart`.
    This action just stores the selected product in the store when the user expressee
    her wish to buy it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render()` method in this screen shows `<ScrollView />` wrapping the book
    image, price, description (we will display a fake `lorem ipsum` description for
    now), and a `Buy!` button, which will be connected to the `addProductToCart` action
    provided by Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `onBuyPress()` method invokes the mentioned action and does a small navigation
    trick afterwards. It goes back by calling the `goBack()` method on the `navigation`
    object to remove the `ProductDetail` screen from the navigation stack, as the
    user won't need it anymore after adding the product to the cart. Immediately after
    doing this, the `onBuyPress()` method will invoke the `navigate` method on the
    `navigation` object to be moved and display the state of the user's cart in the
    `MyCart` screen. We are using `setTimeout` here to make sure we wait until the
    previous call (`this.props.navigation.goBack();`) has finished all the navigation
    tasks and the object is again ready for us to use. Waiting for `0` seconds should
    be enough, since we just want to wait for the call stack to be cleared.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at what the `MyCart` screen looks like now.
  prefs: []
  type: TYPE_NORMAL
- en: MyCart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This screen expects Redux to inject the cart stored in the state, so it can
    render all the items in the cart for the user to review before confirming the
    purchase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the cart itself, as we can see in the `propTypes` definition, this
    screen needs the action `removeProductFromCart` from `ProductActions`, and the
    `navigation` object to be provided to navigate to the `Payment` screen when the
    user is ready to confirm her purchase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, the user can take three actions from here:'
  prefs: []
  type: TYPE_NORMAL
- en: Removing an item from the cart by clicking on the Trash icon on each product
    row (invoking `this.onTrashPress()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to the `Payment` screen to complete her purchase (invoking `this.props.navigation.navigate('Payment')`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to the home screen to keep buying products (invoking `this.props.navigation.navigate('Home')`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's continue to the purchase journey by reviewing the `Payment` screen.
  prefs: []
  type: TYPE_NORMAL
- en: Payment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `react-native-credit-card-input` library to capture the user''s
    credit card details. For this screen to work, we will request the cart, the user,
    and several important actions from Redux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a complex component. Let''s take a look at the props validation to
    understand its signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following props need to be passed for the component to work properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user`: We need the user to check if she is logged in. In case she is not,
    we will display the login/registration components instead of the credit card input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cart`: We need it to calculate and display the total to be charged to the
    credit card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: This action will be invoked if the user decides to log in from this
    screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`register`: This action will be invoked if the user decides to register from
    this screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout`: This action is needed for the `<LoginOrRegister />` component to
    work, so it needs to be provided from Redux so it can be injected into the child
    `<LoginOrRegister />` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pay`: This action will be triggered when the user has entered valid credit
    card details and pressed the Pay now button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loading`: This is a flag for the child `<LoginOrRegister />` component to
    work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paying`: This flag will be used to display a spinner while the payment is
    being confirmed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This is a description of the last error to have happened when trying
    to pay or log in/register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paymentConfirmed`: This flag will let the component know when/if the payment
    has gone through correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navigation`: The `navigation` object used to navigate to other screens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This component also has its own state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both attributes in this state will be provided by `<CreditCardInput />` (the
    main component form `react-native-credit-card-input` ) and will hold the user's
    credit card details and their validity together.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect when the payment has been confirmed, we will use the React method `componentWillReceiveProps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This method just detects when the prop `paymentConfirmed` changes from `false`
    to `true` in order to navigate to the `PaymentConfirmation` screen.
  prefs: []
  type: TYPE_NORMAL
- en: PaymentConfirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A simple screen displays a summary of the purchase just confirmed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing this screen does is to save the app''s state related to the
    cart in the own component''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is necessary because we want to reset the cart and payment details right
    after this screen is shown as it won't be needed on any further occasion. This
    is done by invoking both the `resetCart()` and `resetPayment()` actions provided
    by Redux.
  prefs: []
  type: TYPE_NORMAL
- en: The `render` method just maps the items in the cart (now saved in the component's
    state) into a list of views so the user can review her order. At the bottom of
    these views, we will display a button labeled Continue Shopping, which will return
    the user to the `ProductList` screen by calling the `continueShopping` method.
    Besides navigating to the `ProductList` screen, we need to reset the navigation
    so the purchase journey can be started from scratch the next time the user wants
    to buy some items. This is achieved by creating a reset navigation action and
    invoking `this.props.navigation.dispatch(resetAction);`.
  prefs: []
  type: TYPE_NORMAL
- en: The method `continueShopping` calls `NavigationActions.reset` to clear the navigation
    stack and go back to the home screen. This method is usually called at the end
    of a user journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'This screen completes the purchase journey, so let''s focus now in a different
    part of the application: the user profile.'
  prefs: []
  type: TYPE_NORMAL
- en: MyProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw before, only logged-in users can complete purchases so we need a
    way for the users to log in, log out, register, and review their account details.
    This will be achieved by the `MyProfile` screen and the `<LonginOrRegister />`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This screen receives the user from the app's state and a number of actions (`login`,
    `register`, and `logout`), which will be fed into the `<LoginOrRegister />` component
    to enable login and registration. Most of the logic, therefore, will be deferred
    to the `<LoginOrRegister />` component, leaving the `MyProfile` screen with the
    tasks of listing the user's account details and displaying a button for logging
    her out.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review what the `<LoginOrRegister />` component does and how.
  prefs: []
  type: TYPE_NORMAL
- en: LoginOrRegister
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actually, this component is compounded by two sub-components: `<Login />` and
    `<Register />`. The only task of `<LoginOrRegister />` is to save the state of
    which component (`<Login />` or `<Register />`) should be displayed, showing it
    accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The state in this component can be changed by their child components as it
    passes a function to do so to each child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's now take a look at how the `<Login />` and `<Register />` components will
    use these props to update their parents' state, switching from one view to another.
  prefs: []
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The login view will be displayed by default on the parent component. Its task
    is to capture login information and call the `login` action once the user pushes
    the `Login` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Two inputs capture the email and the password and save them into the component
    state as the inputs are being changed. Once the user has finished entering her
    credentials, she will press the `Login` button and trigger the login action passing
    the email and password from the component's state.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `<LinkButton />` labeled `or Register`, which will invoke (when
    pressed) the `this.props.changeToRegister()` function passed by its parent, `<LoginOrRegister
    />`.
  prefs: []
  type: TYPE_NORMAL
- en: Register
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly to the login form, the `<Register />` component is a list of input
    fields saving its changes into the component state until the user is confident
    enough to press the `Register` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `<LinkButton />` at the bottom of the view will invoke `this.props.changeToLogin()`
    when pressed to switch to the login view.
  prefs: []
  type: TYPE_NORMAL
- en: Sales
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We added one last screen to demonstrate how different journeys can be linked
    together reusing screens and components. In this case, we will create a list of
    products with their prices reduced, which can be added directly to the cart for
    a quick purchase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the same full list of available products, already stored in Redux''s
    state, to filter (by reduced price) and map into an appealing list item that are
    ready to be added to the cart by triggering the `onBuyPress()` method, which in
    turn triggers `addProductToCart()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Besides triggering this Redux action, `onBuyPress()` navigates to the `MyCart`
    screen, but it does so after the call stack is cleared to ensure the product has
    been added to the cart correctly.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the purchase journey will kick in again allowing the user to
    log in (if not logged in yet), pay for the items, and confirm the purchase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed several common functionalities present in most
    e-commerce apps, such as user login and registration, retrieving data from an
    API, purchase journeys, and payments.
  prefs: []
  type: TYPE_NORMAL
- en: We tied all the screens with a common app state managed through Redux, which
    makes this app scalable and easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: With maintainability in mind, we added properties validation for all our components
    and screens. Moreover, we enforced standard code formatting and linting, using
    ESLint, so that the app is ready for various team members to align and develop
    comfortable new features or maintain the current ones.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also added API mocking for the developers to work locally without
    needing a backend when building the mobile app.
  prefs: []
  type: TYPE_NORMAL
