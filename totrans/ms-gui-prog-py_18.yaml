- en: PyQt Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi is one of the most successful and exciting computers of the
    past decade. Introduced in 2012 by a British nonprofit organization as a way to
    teach children about computer science, the tiny **Advanced RISC Machine** (**ARM**)-based
    computer has become a ubiquitous tool for hobbyists, tinkerers, developers, and
    IT professionals of all kinds. With Python and PyQt readily available and well
    supported on its default OS, the Raspberry Pi is a great tool for PyQt developers
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at developing with PyQt5 on the Raspberry Pi in
    the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Running PyQt5 on the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling **General Purpose Input/Output** (**GPIO**) devices with PyQt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling PyQt with GPIO devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow along with the examples in this chapter, you''ll need these
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: A Raspberry Pi—preferably 3 Model B+ or newer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A power supply, keyboard, mouse, monitor, and network connection for the Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A micro SD card with Raspbian 10 or later installed; you can refer to the official
    documentation at [https://www.raspberrypi.org/documentation/installation/](https://www.raspberrypi.org/documentation/installation/)
    for instructions on how to install Raspbian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, Raspbian 10 has not yet been released, though it is
    possible to upgrade Raspbian 9 to the testing version. You can refer to [Appendix
    B](18a932ab-b74e-42b2-b793-4e39a5208cc0.xhtml), *Upgrading Raspbian 9 to Raspbian
    10,* of this book for instructions on how to upgrade if Raspbian 10 is not available.
  prefs: []
  type: TYPE_NORMAL
- en: To program our GPIO-based projects, you'll also need some electronic components
    to interface with. These parts are commonly available in electronics starter kits or
    from your local electronics supply store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first project will require the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three identical resistors (between 220 and 1,000 ohms)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One tri-color LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four female-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second project will require the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: A breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One DHT11 or DHT22 temperature/humidity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One push button switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One resistor (the value isn't important)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three female-to-male jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Adafruit DHT sensor library, which is available from PyPI using the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can refer to the GitHub repository at [https://github.com/adafruit/Adafruit_Python_DHT](https://github.com/adafruit/Adafruit_Python_DHT)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to download the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter15](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xDSx](http://bit.ly/2M5xDSx)
  prefs: []
  type: TYPE_NORMAL
- en: Running PyQt5 on the Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi is capable of running many different operating systems, so
    installing Python and PyQt is entirely dependent on which operating system you
    choose. In this book, we're going to focus on **Raspbian**—the official (and most
    commonly used) operating system for the Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Raspbian is based on the stable release of Debian GNU/Linux, which, at the time
    of publication, is Debian 9 (Stretch). Unfortunately, the versions of Python and
    PyQt5 available for this release of Debian are too old for the code in this book.
    If, as you read this book, Raspbian 10 has not yet been released, please consult
    [Appendix B](18a932ab-b74e-42b2-b793-4e39a5208cc0.xhtml), *Upgrading Raspbian
    9 to Raspbian 10*, for instructions on how to upgrade Raspbian 9 to Raspbian 10.
  prefs: []
  type: TYPE_NORMAL
- en: Raspbian 10 comes with Python 3.7 preinstalled, but we'll need to install PyQt5
    ourselves. Note that you cannot use `pip` to install PyQt5 on the Raspberry Pi,
    as the required Qt binary files are not available from PyPI for the ARM platform
    (on which the Pi is based). However, a version of PyQt5 is available from the
    Raspbian software repositories. This will *not* be the latest version of PyQt5,
    but a version that was chosen during the Debian development process to be the
    most stable and compatible with the release. For Debian/Raspbian 10, this version
    is PyQt 5.11.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, first make sure that your device is connected to the internet.
    Then, open a command-line Terminal and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Advanced Packaging Tool** (**APT**) utility will download and install
    PyQt5 and all of the necessary dependencies. Note that this command only installs
    the main modules of PyQt5 for Python 3\. Certain modules, such as `QtSQL`, `QtMultimedia`,
    `QtChart`, and `QtWebEngineWidgets`, are packaged separately and will need to
    be installed using an additional command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many more optional libraries packaged for PyQt5\. To obtain a complete
    list, you can use the `apt search` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: APT is the primary way in which software is installed, removed, and updated
    on Raspbian, Debian, and many other Linux distributions. While similar to `pip`,
    APT is used for the whole operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Editing Python on the Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although you can edit Python on your own computer and copy it to the Raspberry
    Pi for execution, you will likely find it more convenient to edit your code directly
    on the device. If your favorite code editor or **Integrated Development Environment**
    (**IDE**) is not available for Linux or ARM, never fear; Raspbian offers several
    alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Thonny** Python IDE comes preloaded with the default Raspbian image and
    is perfectly suitable for the examples in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IDLE**, Python''s default programming environment is also preinstalled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geany**, a generic programming text editor suitable for many languages, is
    also preinstalled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditional code editors such as **Vim** and **Emacs** and Python IDEs, such
    as **Spyder**, **Ninja IDE**, and **Eric**, can be installed from the package
    repository using the Add/Remove Software tool (found under Preferences in the
    Programs menu) or using the `apt` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever application or approach you choose, make sure that you back up your
    files to another device, as Raspberry Pi's SD card storage is not the most robust.
  prefs: []
  type: TYPE_NORMAL
- en: Running PyQt5 applications on the Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once Python and PyQt5 are installed on your Raspberry Pi, you should be able
    to run any of the applications we've written so far in this book. Essentially,
    the Pi is a computer running GNU/Linux, with which all of the code in this book
    is compatible. With this in mind, you *could* simply use it as a small, energy-efficient
    computer for running your PyQt applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Raspberry Pi has some distinctive features of its own, most notably,
    its GPIO pins. These pins enable the Pi to communicate with external digital circuits
    in a very simple and accessible way. Raspbian comes with software libraries preinstalled,
    which allows us to control these pins using Python.
  prefs: []
  type: TYPE_NORMAL
- en: To take full advantage of the unique platform that this feature offers us, we're
    going to spend the rest of this chapter focused on using PyQt5 in combination
    with the GPIO features of the Raspberry Pi to create GUI applications that interact
    with real-world circuitry in a way that only a device like the Pi can.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling GPIO devices with PyQt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our first project, we're going to learn how we can control an external circuit
    from a PyQt application. You'll be wiring up a multicolor LED and controlling
    its color using `QColorDialog`. Gather the components listed in the *Technical
    requirements* section for the first project and let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the LED circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin this project by connecting the components of our circuit on the
    breadboard. Power off the Pi and disconnect the power, and then place it near
    your breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: It's always a good idea to shut down your Raspberry Pi and disconnect the power
    before connecting circuits to the GPIO pins. This will reduce the risk of destroying
    your Raspberry Pi in the event that you connect something incorrectly, or if you
    accidentally touch the component leads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main component in this circuit is the tri-color LED. Although these vary
    slightly, the most common pinout for this component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d1018be-3dc8-4a65-ad28-831c18015ade.png)'
  prefs: []
  type: TYPE_IMG
- en: Essentially, a tri-color LED is a red LED, a green LED, and a blue LED combined
    into one package. It provides separate input leads to send current into each color
    separately and a fourth lead for the common ground. By feeding different voltages
    into each pin, we can mix red, green, and blue light to create a wide variety
    of colors, just as we mix these three elements to create RGB colors in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the LED to your breadboard so that each pin is on a separate row in the
    board. Then, connect the remaining components as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/37d2d5a0-2e88-4956-8fbb-04b724336b0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding diagram, we''re making the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: The ground pin on the LED is connected directly to the third outside pin from
    the left on the Raspberry Pi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The red pin on the LED is connected to one of the resistors, which is then connected
    to the next pin to the right (that is, pin 8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The green pin on the LED is connected to another resistor, which is then connected
    to the next free pin to the right (that is, pin 10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blue pin on the LED is connected to the last resistor, which is connected
    to the next free pin to the right on the Pi (pin 12)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is important to double-check your circuit and make sure that you''ve connected
    the wires to the correct pins on the Raspberry Pi. Not all GPIO pins on the Raspberry
    Pi are the same; some of them are programmable, while others have a hardcoded
    purpose. You can view a listing of the pins on your Pi by running the `pinout`
    command in the Terminal; you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5f9f8eee-267d-4935-ab36-6c1c18bd542d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the layout of the pins as if you were holding
    the Pi in front of you with the USB ports down. Note that several of the pins
    are marked **GND**; these are always the ground pins so you can connect the ground
    of your circuit to any of those pins. Other pins are labeled **5V** or **3V3**;
    these are always 5 volts or 3.3 volts, respectively. The remaining pins with the
    GPIO labels are programmable pins. Your wires should be connected to pins **8** (**GPIO14**),
    **10** (**GPIO15**), and **12** (**GPIO18**).
  prefs: []
  type: TYPE_NORMAL
- en: Double-check your circuit connections, and then boot the Raspberry Pi. It's
    time to start coding!
  prefs: []
  type: TYPE_NORMAL
- en: Writing a driver library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our circuit is connected, we need to write some code to control it.
    To do this, we're going to make use of the `GPIO` library on the Pi. Create a
    copy of your PyQt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `three_color_led_gui.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by importing the `GPIO` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What we want to do first is to create a Python class that will serve as an
    API for our circuit. We''ll call it `ThreeColorLed`, and then start it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `__init__()` method takes five arguments: the first three arguments are
    the pin numbers for the red, green, and blue LED connections; the fourth argument
    is the **pin mode** used to interpret the pin numbers; and the fifth argument
    is a frequency, which we''ll discuss later. First, let''s talk about the pin mode.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the output from the `pinout` command, you'll notice that there
    are two ways to describe a pin on the Pi using integers. The first is by its position
    on the board, from 1 to 40\. The second is by its GPIO number (that is, the number
    following GPIO in the pin description). The `GPIO` library allows you to specify
    pins using either number, but you have to tell it which method you're going to
    use by passing one of two constants to the `GPIO.setmode()` function. `GPIO.BOARD`
    specifies that you're using the positional numbers (such as 1 to 40), while `GPIO.BCM`
    means you want to use the GPIO names. As you can see, we default here to using
    `BOARD`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you write a class that takes GPIO pin numbers as arguments, be sure
    to allow the user to specify the pin mode as well. The numbers themselves are
    meaningless without the context of the pin mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, our `__init__()` method needs to set up the output pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A GPIO pin can be set to the `IN` or `OUT` mode, depending on whether you want
    to read from the pin's state or write to it. In this project, we're going to be
    sending information from the software to the circuit, so we need all of the pins
    in the `OUT` mode. After storing our pin numbers in a `dict` object, we have iterated
    through them and set them to the appropriate mode using the `GPIO.setup()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once set up, we can tell an individual pin to go high or low using the `GPIO.output()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code simply turns each pin on and immediately off again (probably faster
    than you can see). We could use this approach to set the LED to a few simple colors;
    for example, we could make it red by setting the red pin `HIGH` and the others
    `LOW`, or cyan by setting the blue and green pins `HIGH` and the red `LOW`. Of
    course, we want to produce a much wider variety of colors, but we can't do that
    by simply turning the pins fully on or off. We need some way to vary the voltage
    of each pin between the minimum (0 volts) and the maximum (5 volts) smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the Raspberry Pi cannot do this. The outputs are digital, not
    analog, so they can only be fully on or fully off. However, we can *simulate* varying
    voltage by using a technique called **Pulse Width Modulation** (**PWM**).
  prefs: []
  type: TYPE_NORMAL
- en: PWM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find a light switch in your house with reasonably responsive bulbs (LED bulbs
    work best). Then, try turning them on and off once per second. Now flick the switch
    faster and faster until the light in the room appears almost constant. You should
    notice that it seems dimmer in the room than when you had the light on all of
    the time, even though the bulb is only ever completely on or completely off.
  prefs: []
  type: TYPE_NORMAL
- en: PWM works in the same way, except that, with the Pi, we can turn the voltage
    on and off so quickly (and quietly, of course) that the toggling between on and
    off appears seamless. Additionally, by varying the ratio of how long the pin is
    on to how long it is off in each cycle, we can simulate varying voltages between
    zero voltage and the maximum voltage. This ratio is known as the **duty cycle**.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the concept and use of pulse width modulation can be
    found at [https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use PWM on our pins, we have to set them up first by creating a `GPIO.PWM`
    object on each pin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're using a list comprehension to produce another `dict` that
    will contain the name of each pin along with a `PWM` object. The `PWM` object
    is created by passing in a pin number and a frequency value. This frequency will
    be the rate at which the pin is toggled on and off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve created our `PWM` objects, we need to start them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `PWM.start()` method begins the flicking of the pin from on to off. The
    argument passed to `start()` indicates the duty cycle as a percentage; here, `0`
    means that the pin will be on 0% of the time (so, basically, it's off). A value
    of 100 will keep the pin completely on all of the time, and values in between
    indicate the amount of on time the pin receives per cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our pins are configured for PWM, we need to create a method that will
    allow us to set the LED to a specific color by passing in red, green, and blue
    values. Most software RGB color implementations (including `QColor`) specify these
    values as 8-bit integers (0 to 255). Our PWM values, however, represent a duty
    cycle, which is expressed as a percentage (0 to 100).
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, since we''re going to need to convert numbers from the 0 to 255
    range into the 0 to 100 range several times, let''s start with a static method
    that will do such a conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This method ensures that we''ll get a valid duty cycle regardless of the input
    by using simple arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we use the absolute value of the number to prevent passing any negative
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, we divide the value by 2.55 to find the percentage of 255 that it represents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we get the modulus of 101 for the number, so that percentages higher
    than 100 will cycle around and remain in range.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s write our `set_color()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `PWM.ChangeDutyCycle()` method takes a value from 0 to 100 and adjusts the
    duty cycle of the pin accordingly. In this method, we're simply converting our
    input RGB values into the proper scale and passing them into the corresponding
    PWM objects.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last method we need to add to our class is a clean-up method. The GPIO pins
    on the Raspberry Pi can be thought of as a state machine, in which each pin has
    a state of high or a state of low (that is, on or off). When we set these pins
    in our program, the state of those pins will remain set after our program exits.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this could cause a problem if we're connecting a different circuit
    to our Pi; having a pin set to `HIGH` at the wrong moment while connecting a circuit
    could fry some of our components. For that reason, we want to leave everything
    off when we exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done using the `GPIO.cleanup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By adding this method to our LED driver class, we can easily clean up the state
    of the Pi after each use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the PyQt GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve taken care of the GPIO side, let''s create our PyQt GUI. In
    `MainWindow.__init__()`, add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating a `ThreeColorLed` instance using the pin numbers that we
    connected to our breadboard. Remember that the class uses the `BOARD` numbers
    by default, so `8`, `10`, and `12` are the correct values here. If you want to
    use the `BCM` numbers, be sure to specify this in the constructor arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add a color picker dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Typically, we invoke a color dialog by calling `QColorDialog.getColor()`, but
    in this case, we want to use the dialog as if it were a widget. So, we're instantiating
    one directly and setting the `NoButtons` and `DontUseNativeDialog` options. By
    taking away the buttons and using the Qt version of the dialog, we can prevent
    the user from canceling or submitting the dialog. This allows us to treat it as
    a regular widget and assign it as the main window's central widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve connected the `currentColorChanged` signal (which is emitted whenever
    the user selects a color) to a `MainWindow` method called `set_color()`. We''ll
    add this next, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `currentColorChanged` signal includes a `QColor` object representing the
    color selected, so we can simply dissect that into red, green, and blue values
    using the `QColor` property accessors, and then pass that information to our `ThreeColorLed`
    object's `set_color()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Now the script is complete. You should be able to run it and light up your LED—give
    it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Note that the color you pick won't exactly match the color output for the LED
    due to differences in the relative brightness of different colored LEDs. However,
    they should be reasonably close.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling PyQt with GPIO devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling circuits from Python using GPIO pins is fairly straightforward.
    It's simply a matter of calling the `GPIO.output()` function with the appropriate
    pin number and high or low value. Now, however, we're going to look at the opposite
    situation, that is, controlling or updating a PyQt GUI from GPIO input.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we're going to build a temperature and humidity readout.
    Just as before, we'll start by connecting the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the sensor circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DHT 11 and DHT 22 sensors are both temperature and humidity sensors that
    can easily work with the Raspberry Pi. Both are packaged as four-pin components,
    but only three of the pins are actually used. Some component kits even mount the
    DHT 11/22 on a small PCB with only the active three pins for output.
  prefs: []
  type: TYPE_NORMAL
- en: 'In either case, if you''re looking at the DHT''s front (that is, the grill
    side), then the pins from left to right are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The input voltage—either 5 or 3 volts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sensor output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dead pin (on a 4-pin configuration)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either the DHT 11 or the DHT 22 will work equally well for this project. The
    11 is smaller and cheaper, but slower and less accurate than the 22\. Otherwise,
    they are functionally the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Plug your sensor into the breadboard so that each pin is in its own row. Then,
    connect it to the Raspberry Pi using jumper wires, as demonstrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a29672ae-3bab-464d-891e-54cde52127fe.png)'
  prefs: []
  type: TYPE_IMG
- en: The sensor's voltage input pin can be connected to either of the 5V pins, and
    the ground can be connected to any of the GND pins. Additionally, the data pin
    can be connected to any GPIO pin on the Pi, but in this case, we'll use pin 7
    (once again, going by the `BOARD` numbers).
  prefs: []
  type: TYPE_NORMAL
- en: Double-check your connections to make sure everything is correct, then power
    on the Raspberry Pi, and we'll start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the sensor interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin our sensor interface software, first, create another copy of your Qt
    application template and call it `temp_humid_display.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is import the necessary libraries, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`Adafruit_DHT` will encapsulate all of the complicated bits required to talk
    to the DHT unit so that we only need to work with high-level functions to control
    and read data from the device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the imports, let''s set up a global constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We're setting up a global constant indicating which model of DHT we're working
    with; if you have the DHT 22, then set this value to 22\. We're also setting up
    the Pi's pin mode. But this time, we're going to use the `BCM` mode to specify
    our pin numbers. The Adafruit library only takes `BCM` numbers, so it makes sense
    to be consistent across all of our classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start our sensor interface class for the DHT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time, we're going to base our class on `QObject` so that we can emit signals
    when the values are read from the sensor and run the object in its own thread.
    The DHT units are a bit slow and can take a full second or more to respond when
    we request a reading. For that reason, we'll want to run its interface in a separate
    thread of execution. As you may remember from [Chapter 10](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml),
    *Multithreading with QTimer and QThread,* this is easily done when we can interact
    with the object using signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the `__init__()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor will take three arguments: the pin connected to the data line,
    the model number (11 or 22), and a Boolean indicating whether we want to use the
    Fahrenheit or Celsius scale. We''ll simply save all of these arguments to instance
    variables for the time being.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to create a method to tell the sensor to take a reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Adafruit_DHT` library takes all of the complications out
    of reading this sensor. We simply have to call `read_entry()` with the model and
    pin numbers of our sensor and it returns a tuple containing the humidity and temperature
    values. The temperature is returned in degrees Celsius, so for American users,
    we're doing a calculation to convert this into Fahrenheit if the object is configured
    to do so. Then, we emit our three signals—one each for temperature, humidity,
    and the current time.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have wrapped this function using the `pyqtSlot` decorator. Again,
    recall from [Chapter 10](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml), *Multithreading
    with QTimer and QThread,* that this will remove some of the complications of moving
    this class to its own thread.
  prefs: []
  type: TYPE_NORMAL
- en: This takes care of our sensor driver class, so now, let's build the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the readings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this point in this book, creating a PyQt GUI to display a couple of numbers
    should be a walk in the park. Just to make things interesting and to create a
    stylish look, we're going to use a widget that we haven't talked about yet—`QLCDNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a base widget in `MainWindow.__init__()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s apply some of the styling skills that we learned in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating a custom `QPalette` object for this widget and its children,
    giving it a color scheme that is reminiscent of a blue-backlit LCD screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create widgets to display our readings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `QLCDNumber` widget is a widget for displaying numbers. It resembles an
    eight-segment LCD display, such as you might find on an instrument panel or digital
    clock. Its `segmentStyle` property switches between a couple of different visual
    styles; in this case, we're using `Flat`, which draws the segments filled in with
    the foreground color.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the layout now configured, let''s create a sensor object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a sensor connected to pin GPIO4 (that is, pin 7), which
    passes in the `SENSOR_MODEL` constant that we defined earlier and sets Fahrenheit
    to `True` (feel free to set it to `False` if you prefer Celsius). After that,
    we create a `QThread` object and move the `SensorInterface` object to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s connect our signals and slots, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `QLCDNumber.display()` slot can be connected to any signal that emits a
    number, so we connect our temperature and humidity signals directly. The `QTime`
    object sent with the `read_time` signal will need some parsing, however, so we'll
    connect it to a `MainWindow` method called `show_time()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That method looks like the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This method will take advantage of the `MainWindow` object's convenient `statusBar()`
    method to show the time of the last temperature reading in the status area.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, that takes care of our GUI output display; we now need a way to trigger
    the sensor to take readings. One approach we could take is to create a timer to
    do it periodically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this case, this timer will call `sensor.take_reading()` every minute, ensuring
    that our readings are regularly updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add `QPushButton` to the interface so that the user can get fresh
    readings on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is fairly trivial, as we just need to connect the button's `clicked` signal
    to the sensor's `take_reading` slot. But what about a hardware control? How might
    we implement something external to trigger a temperature reading? We'll explore
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a hardware button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading values from a sensor can be useful, but what would be even more useful
    is being able to respond to events that happen in a circuit and take action as
    a result. To demonstrate this process, we'll add a hardware button to our circuit
    and monitor its state so that we can take temperature and humidity readings at
    the push of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, power off the Raspberry Pi and let''s add some components to the
    circuit, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b493a2fa-96bd-4435-9ba8-d2ae3ee2fe9c.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we've essentially added a button and a resistor. The button needs to be
    connected to pin 8 on the Pi on one side, and the resistor, which is connected
    to ground, on the other. To keep the wiring clean, we've also taken advantage
    of the common ground and common voltage rails on the side of the breadboard, although
    this is optional (you can just connect things directly to the appropriate GND
    and 5V pins on the Pi, if you prefer).
  prefs: []
  type: TYPE_NORMAL
- en: The push buttons that are often found in starter kits have four connectors—two
    for each side of the switch. Make sure that your connections are not connected
    until the button is pushed. If you find that they are always connected even without
    the button being pushed, then you probably need to rotate your button by 90 degrees
    in the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: The button in this circuit will simply connect our GPIO pin to ground when pushed,
    which will allow us to detect a button push. We'll see how that works in more
    detail when we write the software.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the button driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start a new class at the top of your script to be the driver for our push button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we're using `QObject` so that we can emit Qt signals, which we'll
    do when we detect that the button has been pushed down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first thing our `__init__()` method does after calling `super().__init__()`
    is configure our button's GPIO pin to be an input pin by passing the `GPIO.IN`
    constant to the `setup()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `pull_up_down` value we've passed here is very important. Because of the
    way we've connected this circuit, the pin will be connected to the ground whenever
    the button is pushed. But what happens when the button is not pushed? Well, in
    that case, it's in a state called **float**, in which the input will be unpredictable.
    In order to keep the pin in a predictable state when the button is not pushed,
    the `pull_up_down` argument will cause it to be pulled either `HIGH` or `LOW`
    when it is not otherwise connected. In our case, we want it pulled `HIGH` because
    our button will be pulling it `LOW`; passing in the `GPIO.PUD_UP` constant will
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: This could work in a reverse fashion as well; for example, we could have connected
    the other side of the button to 5V, and then set `pull_up_down` to `GPIO.PUD_DOWN`
    in the `setup()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to figure out how to detect when the button is being pressed so
    that we can emit our signal.
  prefs: []
  type: TYPE_NORMAL
- en: One simple approach to this task is **polling**. Polling simply means that we're
    going to check the button at a regular interval and emit a signal if something
    changes from the last check.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first need to create an instance variable to save the last known
    state of the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can check the current state of the button by calling the `GPIO.input()` function
    with the pin number. This function will return either `HIGH` or `LOW`, indicating
    whether the pin is at 5V or ground. If the pin is `LOW`, then that means the button
    is pressed down. We'll save that result to `self.pressed`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll write a method to check the state of the button for changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This check method will take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it compares the output of `input()` to the `LOW` constant to see whether
    the button is pressed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we compare the current state of the button to the saved state to see whether
    the button's state has changed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it has, we then need to check whether the change of state is a press or a
    release
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is a press (`pressed` is `True`), then we emit the signal
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In either case, we update `self.pressed` with the new state
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, all that remains is to call this method on a regular basis to poll for
    changes; back in `__init__()`, we can do this with a timer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created a timer that times out every 50 milliseconds, calling `self.check()`
    when it does so. This should be often enough to catch even the fastest button
    push that a human being can execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polling works well, but there is a cleaner way to do this by using the `GPIO`
    library''s `add_event_detect()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `add_event_detect()` function will start monitoring the pin in another thread
    for either a `RISING` event or a `FALLING` event, and call the configured `callback`
    method when such an event is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we just call the following instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We could pass our `emit()` method directly as a callback, but `add_event_detect()`
    will call the callback function with the pin number as an argument, which `emit()`
    will not accept.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of using `add_event_detect()` is that it introduces another thread,
    using the Python `threading` library, which can lead to subtle problems with the
    PyQt event loop. Polling is a perfectly workable alternative that allows you to
    avoid this complication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Either approach will work for our simple script, so let''s head back to `MainWindow.__init__()`
    to add support for our button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: All we need to do is create an instance of our `HWButton` class with the right
    pin number and connect its `button_press` signal to the sensor's `take_reading()`
    slot.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you fire everything up on the Pi, you should be able to see an update
    when you push the button.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi is an exciting technology, not only because of its small size,
    low cost, and low resource usage, but because it makes connecting the world of
    programming to real-world circuitry simple and accessible in a way that nothing
    had before. In this chapter, you learned how to configure the Raspberry Pi to
    run PyQt applications. You also learned how to control circuits using PyQt and
    Python, and how circuits could control actions in your software.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to bring the World Wide Web into our PyQt applications
    using `QtWebEngineWidgets`, a full Chromium-based browser inside a Qt Widget.
    We'll build a functional browser, and we'll learn about the ins and outs of the
    web engine library.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try answering the following questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You have just bought a Raspberry Pi with Raspbian preinstalled to run your PyQt5
    application. When you try to run your application, you get an error trying to
    import `QtNetworkAuth`, which your application depends on. What is likely to be
    the problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have written a PyQt frontend for a legacy scanner device. Your code talks
    to the scanner through a proprietary driver utility called `scanutil.exe`. It
    is currently running on a Windows 10 PC, but your employer wants to save money
    by moving it to a Raspberry Pi. Is this a good idea?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've acquired a new sensor and want to try it out with the Raspberry Pi. It
    has three connections, labeled Vcc, GND, and Data. How would you connect this
    to the Raspberry Pi? Is there more information you need?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're trying to light an LED connected to the fourth GPIO pin from the left
    on the outside. What is wrong with this code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You are trying to dim an LED connected to GPIO pin 12\. Does the following code
    work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You have a motion sensor with a data pin that goes `HIGH` when motion is detected.
    It''s connected to pin `8`. The following is your driver code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Your main window class creates a `MotionSensor` object and connects its `detection`
    signal to a callback method. However, nothing is being detected. What is missing?
  prefs: []
  type: TYPE_NORMAL
- en: Combine the two circuits in this chapter in a creative way; for example, you
    might create a light that changes color depending on humidity and temperature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: More documentation for the Raspberry Pi's `GPIO` library can be found at [https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/](https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt offers many books covering the Raspberry Pi in detail; you can find more
    information at [https://www.packtpub.com/books/content/raspberry-pi](https://www.packtpub.com/books/content/raspberry-pi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
