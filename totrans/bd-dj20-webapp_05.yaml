- en: Deploying with Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll look at how to deploy MyMDB into a production environment
    using Docker containers hosted on a Linux server in Amazon's **Electric Computing
    Cloud** (**EC2**). We will also use **Simple Storage Service** (**S3**) of **Amazon
    Web Services** (**AWS**) to store files that users upload.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Split up our requirements and settings files to separate development and production
    settings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a Docker container for MyMDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a database container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Docker Compose to launch both containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launch MyMDB into a production environment on a Linux server in the cloud
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's split up our requirements and settings so that our development
    and production values are kept separate.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Organizing configuration for production and development
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we've kept a single requirements file and a single `settings.py` file.
    This has made development convenient. However, we can't use our development settings
    in production.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The current best practice is to have a separate file for each environment. Each
    environment's file then imports a common file with shared values. We'll use this
    pattern for requirements and settings files.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by splitting up our requirements files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Splitting requirements files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create `requirements.common.txt` at the root of our project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Regardless of the environment that we're in, we always need Django, Postgres
    drivers, and Pillow (for the `ImageField` class). However, this requirements file
    is never used directly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s list our development requirements in `requirements.dev.txt`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding file will install everything from `requirements.common.txt` (thanks
    to `-r`) and the Django Debug Toolbar.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'For our production packages, we''ll use `requirements.production.txt`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will also install the packages from `requirements.common.txt`. It will
    also install the `boto3` and `django-storages` packages to help us upload files
    to S3 easily. The `uwsgi` package will provide the server we'll use to serve Django.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'To install packages for production, we can now execute the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, let's split up the settings file along similar lines.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Splitting settings file
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we will follow the current Django best practice of splitting our settings
    file into the following three files: `common_settings.py`, `production_settings.py`,
    and `dev_settings.py`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Creating common_settings.py
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create `common_settings.py` by renaming our current `settings.py` file
    and then making the changes mentioned in this section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change `DEBUG = False` so that no new settings file can *accidentally*
    be in debug mode. Then, let''s change the `SECRET_KEY` setting to get its value
    from an environment variable, by changing its line to be:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s also add a new setting, `STATIC_ROOT`. `STATIC_ROOT` is the directory
    where Django will collect all the static files from across our installed apps
    to make it easier to serve them:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the database config, we can remove all the credentials but keep the `ENGINE` value
    (to make it clear, we intend to use Postgres everywhere):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, let's delete the `CACHES` setting. This will have to be configured
    differently in each environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a development settings file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Creating dev_settings.py
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our development settings will be in `django/config/dev_settings.py`. We'll build
    it incrementally.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import everything from `common_settings`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we''ll override the `DEBUG` and `SECRET_KEY` settings:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In development, we want to run in debug mode. We will also feel safe hardcoding
    a secret key, as we know that it won't be used in production.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s update the `INSTALLED_APPS` list:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In development, we can run extra apps (such as the Django Debug Toolbar) by
    appending a list of development-only apps to the `INSTALLED_APPS` list.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s update the database configuration:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since our development database is local, we can hardcode the values in our settings
    to make the file simpler. If your database is not local, avoid checking passwords
    into version control and use `os.getenv()`, as in production.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s update the cache configuration:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll use a very short timeout in our development cache.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to set file upload directory:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In development, we'll store uploaded files on our local filesystem in development.
    We will specify the directory to upload to using `MEDIA_ROOT`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The Django Debug Toolbar needs a bit of configuration as well:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Django Debug Toolbar will only render at predefined IPs, so we will give
    it our localhost IP so that we can use it locally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: We can also add more settings that our development-only apps may require.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add production settings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Creating production_settings.py
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create our production settings in `django/config/production_settings.py`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`production_settings.py` is similar to `dev_settings.py` but often uses `os.getenv()`
    to get values from environment variables. This helps us keep secrets (for example,
    Passwords, API tokens, and so on) out of version control and decouples settings
    from particular servers:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we import the common settings. Out of an abundance of caution, we ensure
    that the debug mode is off.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Having a `SECRET_KEY` set is vital to our system staying secure. We `assert`
    to prevent Django from starting up without `SECRET_KEY`. The `common_settings` module should
    have already set it from an environment variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: A production website will be accessed from a domain other than `localhost`.
    We then tell Django what other domains we're serving by appending the `DJANGO_ALLOWED_HOSTS` environment
    variable to the `ALLOWED_HOSTS` list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll update the database configuration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We update the database configuration using values from environment variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Then, the cache configuration needs to be set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In production, we will accept the trade-offs of a local memory cache. We configure
    the timeout at runtime using another environment variable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Next, the file upload configuration settings need to bedded.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In production, we won't store uploaded images on our container's local filesystem.
    One core concept of Docker is that containers are ephemeral. It should be acceptable
    to stop and delete a container and replace it with another. If we stored uploaded
    images locally, we’d go against that philosophy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Another reason for not storing uploaded files locally is that they should also
    be served from a different domain (we discussed this in [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml), *Posters,
    Headshots, and Security*). We will use S3 storage since it's cheap and easy.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The `django-storages` app provides file storage backends for many CDNs, including
    S3\. We tell Django to use that S3 by changing the `DEFAULT_FILE_STORAGE` setting.
    The `S3Boto3Storage` backend requires a few more settings to be able to work with
    AWS, including an AWS Access Key, an AWS Secret Access Key, and the name of the
    destination bucket. We'll discuss the two Access Keys later, in the AWS section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Now that our settings are organized, we can create our MyMDB `Dockerfile`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MyMDB Dockerfile
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a Dockerfile for MyMDB. Docker runs containers
    based on an image. An image is defined by a Dockerfile. A Dockerfile must extend
    another Dockerfile (the reserved `scratch` image being the end of this cycle).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Docker's philosophy is that each container should have a single concern (purpose).
    This may mean that it runs a single process, or it may run multiple processes
    working together. In our case, it will run both uWSGI and Nginx processes to provide
    MyMDB.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Confusingly, Dockerfile refers to both the expected *filename* and the *file
    type*. So `Dockerfile` is a Dockerfile.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a Dockerfile at the root of our project in a file called `Dockerfile`.
    Dockerfile uses its own language to define the files/directories in the image,
    as well as any commands required to run while making the image. A complete guide
    on writing a Dockerfile is out of the scope of this chapter. Instead, we'll build
    our `Dockerfile` incrementally, discussing only the most relevant elements.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll build our `Dockerfile` by following six steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the base image and adding the source code to the image
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installing packages
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collecting static files
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring Nginx
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring uWSGI
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cleaning up unnecessary resources
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting our Dockerfile
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part of our `Dockerfile` tells Docker which image to use as the base,
    adds our code, and creates some common directories:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s look at these instructions in more detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`: This is required in a Dockerfile. `FROM` tells Docker what image to
    use as the base image for our image. We will use `phusion/baseimage` because it
    provides a lot of convenient facilities and uses very little memory. It''s a tailored-for-Docker
    Ubuntu image with a smaller easy-to-use init service manager called runit (instead
    of the Ubuntu''s upstart).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`: This executes a command as part of building the image. `RUN mkdir /mymdb`
    creates the directory in which we''ll store our files.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR`: This sets the working directory for all our future `RUN` commands.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY`: This adds a file (or directory) from our filesystem to the image. Source
    paths are relative to the directory containing our `Dockerfile`. It''s best to
    make the destination path an absolute path.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also reference a new directory called `scripts`. Let''s create it at
    the root of our project directory:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As part of configuring and building the new image, we'll create a few small
    bash scripts that we'll keep in the `scripts` directory.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Installing packages in Dockerfile
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we''ll tell our `Dockerfile` to install all the packages we will need:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We used `RUN` statements to install the Ubuntu packages and create a virtual
    environment. To install our Python packages into our virtual environment, we''ll
    create a small script in `scripts/pip_install.sh`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding script simply activates the virtual environment and runs `pip3
    install` on our production requirements file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: It's often hard to debug long commands in the middle of a Docker file. Wrapping
    commands in scripts can make them easier to debug. If something isn't working,
    you can connect to a container using the `docker exec -it bash -l` command and
    debug the script as normal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Collecting static files in Dockerfile
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Static files are the CSS, JavaScript, and images that support our website.
    Static files may not always be created by us. Some static files come from installed
    Django apps (for example, Django admin). Let’s update our `Dockerfile` to collect
    the static files:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, we''ve wrapped the command in a script. Let''s add the following script
    to `scripts/collect_static.sh`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding script activates the virtual environment we created in the preceding
    code and sets the required environment variables. Most of these values don't matter
    in this context as long as the variables are present. However, the `DJANGO_SETTINGS_MODULE` environment
    variable is very important. The `DJANGO_SETTINGS_MODULE` environment variable is
    used by Django to find the settings module. If we don't set it and don't have `config/settings.py`,
    then Django won't start (even `manage.py` commands will fail).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Adding Nginx to Dockerfile
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure Nginx, we will add a config file and a runit service script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Configuring Nginx
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add an Nginx configuration file to `nginx/mymdb.conf`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Nginx will be responsible for the following two things:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files (URLs starting with `/static`)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing all other requests to uWSGI
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `upstream` block describes the location of our Django (uWSGI) server. In
    the `location /` block, nginx is instructed to pass requests on to the upstream
    server using the uWSGI protocol. The `include /etc/nginx/uwsgi_params` file describes
    how to map headers so that uWSGI understands them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`client_max_body_size` is an important setting. It describes the maximum size
    for file uploads. Leaving this value too big can expose a vulnerability, as attackers
    can overwhelm the server with huge requests.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Creating Nginx runit service
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for `runit` to know how to start Nginx, we will need to provide a
    `run` script. Our `Dockerfile` expects it to be in `runit/nginx/run`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`runit` doesn''t want its services to fork off a separate process, so we run
    Nginx with `daemon off`. Further, `runit` wants us to use `exec` to replace our
    script''s process, the new Nginx process.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Adding uWSGI to the Dockerfile
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re using uWSGI because it often ranks as the fastest WSGI app server. Let''s
    set it up in our `Dockerfile` by adding the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This instructs Docker to use a `mymdb.ini` file to configure uWSGI, creates
    log directories, and adds a uWSGI runit service. In order for runit to start the
    uWSGI service, we give the runit script permission to execute using the `chmod` command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Configuring uWSGI to run MyMDB
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create the uWSGI configuration in `uwsgi/mymdb.ini`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s take a closer look at some of these settings:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`socket` tells uWSGI to open a socket on `127.0.0.1:3031` using its custom
    `uwsgi` protocol (confusingly, the protocol and the server have the same name).'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chdir` changes the processes''s working directory. All paths need to be relative
    to this location.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`virtualenv` tells uWSGI the path to the project''s virtual environment.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `env` instruction sets an environment variable for our process. We can
    access these with `os.getenv()` in our code (for example, `production_settings.py`).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$(...)` are references environment variables from the uWSGI process''s own
    environment (for example, `$(DJANGO_SECRET_KEY )`).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proccesses` sets how many processes we should run.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`threads` sets how many threads each process should have.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `processes` and `threads` settings will need to be fine-tuned based on production
    performance.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Creating the uWSGI runit service
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for runit to know how to start uWSGI, we will need to provide a `run`
    script. Our `Dockerfile` expects it to be in `runit/uwsgi/run`. This script is
    more complex than what we used for Nginx:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This script does the following three things:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether it can connect to the DB, exiting otherwise
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs all the migrations or exits on failure
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts uWSGI
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runit requires that we use `exec` to start our process so that uWSGI will replace
    the `run` script's process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Finishing our Dockerfile
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the final step, we will clean up and document the port we''re using:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `EXPOSE` statement documents which port we're using. Importantly, it does
    not actually open any ports. We'll have to do that when we run the container.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a container for our database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database container
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need a database to run Django in production. The PostgreSQL Docker community
    provides us with a very robust Postgres image that we can extend.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another container for our database in `docker/psql/Dockerfile`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The base image for this `Dockerfile` will use Postgres 10.1\. It also has a
    convenient facility that it will execute any shell or SQL scripts in `/docker-entrypoint-initdb.d` as
    part of the DB initialization. We'll take advantage of this to create our MyMDB
    database and user.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our database initialization script in `docker/psql/make_database.sh`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We used a shell script in the preceding code so that we can use environment
    variables to populate our SQL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have both our containers ready, let's make sure that we can actually
    launch them by signing up for and configuring AWS.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Storing uploaded files on AWS S3
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We expect our MyMDB to save files to S3\. To accomplish that, we will need to
    sign up for AWS and then configure our shell to be able to use AWS.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Signing up for AWS
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To sign up, navigate to [https://aws.amazon.com](https://aws.amazon.com) and
    follow their instructions. Note that signing up is free.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The resources we will use are all in the AWS free tier at the time of writing
    this book. Some elements of the free tier are only available to new accounts for
    the first year. Review your account's eligibility before executing any AWS command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the AWS environment
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To interact with the AWS API, we will need the following two tokens—an Access
    Key and a Secret Access Key. This key pair defines access to an account.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: To generate a pair of tokens, go to [https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential_](https://console.aws.amazon.com/iam/home?region=us-west-2#/security_credential),
    click on Access Keys, and then click on the create new access keys button. There
    is no way to retrieve a Secret Access Key if you lose it, so ensure that you save
    it in a safe place.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The preceding AWS Console link will generate tokens for your root account. This
    is fine while we're testing things out. In future, you should make users with
    limited permissions using the AWS IAM permissions system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s install the AWS **command-line interface** (**CLI**):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then,we need to configure the AWS command line tool with our key and region.
    The `aws` command offers an interactive `configure` subcommand to do this. Let’s
    run it on the command line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `aws configure` command stores the values you entered in a `.aws` directory
    in your home directory.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that your new account is set up correctly, request a list of EC2
    instances (there should be none):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating the file upload bucket
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: S3 is organized into buckets. Each bucket must have a unique name (unique across
    all of AWS). Each bucket will also have a policy, which controls access.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a bucket for our file uploads by executing the following commands
    (change `BUCKET_NAME` to your own unique name):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To let unauthenticated users access the files in our bucket, we must set a
    policy. Let''s create the policy in `AWS/mymdb-bucket-policy.json`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ensure that you update `BUCKET_NAME` to the name of your bucket.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can apply the policy on your bucket using the AWS CLI:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Ensure that you remember your bucket name, AWS access key, and AWS secret access
    key as we'll use them in the next section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have all the pieces of production deployment ready. Docker Compose is
    how Docker lets multiple containers work together. Docker Compose is made of a
    command-line tool, `docker-compose`; a configuration file, `docker-compose.yml`;
    and an environment variable file, `.env`. We will create both these files at the
    root of our project directory.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Never check your `.env` file into version control. That's where your secrets
    live. Don't let them leak.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s list our environment variables in `.env`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Many of these values are okay to hardcode, but there are a few values that
    you need to set for your project:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '`DJANGO_SECRET_KEY`: The Django secret key is used as part of the seed for
    Django''s cryptography'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DJANGO_DB_PASSWORD`: This is the password for the Django''s MyMDB database
    user'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AWS_ACCESS_KEY_ID`: Your AWS access key'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AWS_SECRET_ACCESS_KEY_ID`: Your AWS secret access key'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DJANGO_UPLOAD_S3_BUCKET`: Your bucket name'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRES_PASSWORD`: The password for the Postgres database super user (different
    from the MyMDB database user)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DJANGO_ALLOWED_HOSTS`: The domain we''ll be serving from (we''ll fill this
    in once we start an EC2 instance)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we define how our containers work together in `docker-compose.yml`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This Compose file describes the two services that make up MyMDB (`db` and `web`).
    Let''s review the configuration options we used:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`build`: Path to a build context. A build context is, generally speaking, a
    directory with a `Dockerfile`. So, `db` uses the `psql` directory and `web` uses
    the `.` directory (the project root directory, which has a `Dockerfile`).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports`: A list of port mappings, describing how to route connections from
    ports on the host to ports on the container. In our case, we''re not changing
    any ports.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`environment`: Environment variables for each service. The format we''re using
    implies we''re getting the values from our `.env` file. However, you could hardcode
    values using the `MYVAR=123`  syntax.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restart`: This is the restart policy for the container. `always` indicates
    that Docker should always try to restart the container if it stops for any reason.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on`: This tells Docker to start the `db` container before the `web`
    container. However, we still can''t be sure that Postgres will manage to start
    before uWSGI, so we need to check the database is up in our runit script.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing environment variables
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our production configuration relies heavily on environment variables. Let''s
    review the steps we must follow before it can be accessed in Django by `os.getenv()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: List the variable in `.env`
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the variable under the environment option `environment` in `docker-compose.yml`
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the uWSGI ini file variable with `env`
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access the variable with `os.getenv`
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running Docker Compose locally
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have configured our Docker containers and Docker Compose, we can
    run the containers. One of the advantages of Docker Compose is that it can provide
    the same environment everywhere. This means that we can run Docker Compose locally
    and get the exact same environment that we'll get in production. There's no need
    to worry that there's an extra process or a different distribution across environments.
    Let's run Docker Compose locally.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the rest of this chapter, you must install Docker on your
    machine. Docker, Inc. provides Docker Community Edition for free from its website: [https://docker.com](https://docker.com).
    The Docker Community Edition installer is an easy-to-use wizard on Windows and
    Mac. Docker, Inc. also offers official packages for most major Linux distributions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Once you have it installed, you'll be able to follow all of the next steps.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Compose
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start our containers locally, run the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`docker-compose up` builds and then starts our containers. The `-d` option
    detaches Compose from our shell.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether our containers are running, we can use `docker ps`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To check the Docker logs, you can use the `docker logs` command to note the
    output of startup scripts:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To access a shell inside the container (so that you can examine files or view
    application logs), use this `docker exec` command to start bash:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To stop the containers, use the following command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To stop the containers and *delete* them, use the following command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When you delete a container, you delete all the data in it. That's not a problem
    for the Django container as it holds no data. However, if you delete the db container,
    you *lose the database's data*. Be careful in production.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your container via a container registry
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a working container, we may want to make it more widely accessible.
    Docker has the concept of a container registry. You can push your container to
    a container registry to make it available either publicly or to just your team.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The most popular Docker container registry is the Docker Hub ([https://hub.docker.com](https://hub.docker.com)).
    You can create an account for free and, at the time of writing this book, each
    account comes with one free private repository and unlimited public repositories.
    Most cloud providers also have a docker repository hosting facilities as well
    (though prices may vary).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section assumes that you have a host configured. We'll use
    Docker Hub as our example, but all the steps are the same regardless of who hosts
    your container repository.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'To share your container, you''ll need to do the following things:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Log in to a Docker registry
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tag our container
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push to a Docker registry
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s start by logging in to a Docker registry:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `USERNAME` and `PASSWORD` values need to be the same as you used for your
    account on Docker Hub. `docker.io` is the domain of Docker Hub's container registry.
    If you're using a different container registry host, then you need to change the
    domain.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re logged in, let''s rebuild and tag our container:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Where your `USERNAME` and `REPOSITORY` values are replaced with your values.
    The `:latest` suffix is the tag for the build. We could have many different tags
    in the same repository (for example, `development`, `stable`, and `1.x`). Tags
    in Docker are much like tags in version control; they help us find a particular
    item quickly and easily. `:latest` is the common tag given to the latest build
    (though it may not be stable).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s push our tagged build to our repository:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Docker will show us its progress uploading and then show a SHA256 digest upon
    success.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: When we push a Docker image to a remote repository we need to be mindful of
    any private data stored on the image. All the files we created or added in `Dockerfile` are
    contained in the pushed image. Just like we don’t want to hard code passwords
    in code that is stored in a remote repository, we also don’t want to store sensitive
    data (like passwords) in Docker images that might be stored on remote servers.
    This is another reason we emphasize storing passwords in environment variables
    rather than hard coding them.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now you can share the repo with other team members to run your Docker
    container.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's launch our container.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Launching containers on a Linux server in the cloud
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have everything working, we can deploy it to the internet. We can
    use Docker to deploy our containers to any Linux server. Most people who use Docker
    are using a cloud provider to provide a Linux server host. In our case, we will
    use AWS.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding section, when we used `docker-compose`, we were actually using
    it to send commands to a Docker service running on our machine. Docker Machine
    provides a way to manage remote servers running Docker. We will use `docker-machine`
    to start an EC2 instance, which will host our Docker containers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Starting an EC2 instance can cost money. We'll use an instance that is eligible
    for the AWS free tier `t2.micro` at the time of writing this book. However, you
    are responsible for checking the terms of the AWS free tier.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Docker EC2 VM
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will launch our EC2 VM (called an EC2 instance) into our account''s **Virtual
    Private Cloud** (**VPC**). However, each account has a unique VPC ID. To get your
    VPC ID, run the following command:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The value used in the preceding code is not a real value.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know our VPC ID, we can use `docker-machine` to launch an EC2 instance:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This tells Docker Machine to launch an EC2 `t2.micro` instance in the `us-west-2`
    region and the provided VPC. Docker Machine takes care of ensuring that a Docker
    daemon is installed and started on the server. When referencing this EC2 instance
    in Docker Machine, we refer to it by the name `mymdb-host`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'When the instance is started, we can ask AWS for the public DNS name for our
    instance:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding command may return multiple copies of the same value even if only
    one instance is up. Put the result in the `.env` file as `DJANGO_ALLOWED_HOSTS`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'All EC2 instances are protected by a firewall determined by their security
    group. Docker Machine automatically created a security group for our server when
    it started our instance. In order for our HTTP requests to make it to our machine,
    we will need to open port `80` in the `docker-machine` security group, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now that everything is set up, we can configure `docker-compose` to talk to
    our remote server and bring up our containers:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都设置好了，我们可以配置`docker-compose`与我们的远程服务器通信，并启动我们的容器：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Congratulations! MyMDB is up in a production environment. Check it out by navigating
    to the address used in `DJANGO_ALLOWED_HOSTS`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！MyMDB已经在生产环境中运行起来了。通过导航到`DJANGO_ALLOWED_HOSTS`中使用的地址来查看它。
- en: The instructions here are focused on starting an AWS Linux server. However,
    all the Docker commands have equivalent options for Google Cloud, Azure, and other
    major cloud providers. There's even a *generic* option that is made to work with
    any Linux server, though your mileage may vary depending on the Linux distribution
    and Docker version.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的说明重点是启动AWS Linux服务器。然而，所有的Docker命令都有等效的选项适用于Google Cloud、Azure和其他主要的云服务提供商。甚至还有一个*通用*选项，可以与任何Linux服务器配合使用，尽管根据Linux发行版和Docker版本的不同，效果可能有所不同。
- en: Shutting down the Docker EC2 VM
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭Docker EC2虚拟机
- en: 'Docker machine can also be used to stop VM running Docker as shown in the following
    snippet:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine也可以用于停止运行Docker的虚拟机，如下面的代码片段所示：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This will stop the EC2 instance and destroy all the containers in it. If you
    wish to preserve your DB, ensure that you back up your database by running the
    preceding `eval` command and then opening a shell using `docker exec -it mymdb_db_1
    bash -l`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止EC2实例并销毁其中的所有容器。如果您希望保留您的数据库，请确保通过运行前面的`eval`命令来备份您的数据库，然后使用`docker exec
    -it mymdb_db_1 bash -l`打开一个shell。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've launched MyMDB into a production Docker environment on
    the internet. We've created a Docker container for MyMDB using a Dockerfile. We
    used Docker Compose to make MyMDB work with a PostgreSQL database (also in a Docker
    container). Finally, we launched the containers on the AWS cloud using Docker
    Machine.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经将MyMDB部署到了互联网上的生产Docker环境中。我们使用Dockerfile为MyMDB创建了一个Docker容器。我们使用Docker
    Compose使MyMDB与PostgreSQL数据库（也在Docker容器中）配合工作。最后，我们使用Docker Machine在AWS云上启动了这些容器。
- en: Congratulations! You now have MyMDB running.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经让MyMDB运行起来了。
- en: In the next chapter, we'll make our implementation of Stack Overflow.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将实现Stack Overflow。
