- en: Mathematical Plotting with Matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: Plotting is a fundamental tool in all of mathematics. A good plot can reveal
    hidden details, suggest future directions, verify results, or reinforce an argument.
    It is no surprise, then, that the scientific Python stack features a powerful
    and flexible plotting library called Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will plot functions and data in a variety of styles and
    create figures that are fully labeled and annotated. We will create three-dimensional
    plots, customize the appearance of figures, create figures that contain multiple
    plots using subplots, and save figures directly to files for applications that
    are not running in an interactive environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic plotting with Matplotlib
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the plotting style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding labels and legends to plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding subplots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving Matplotlib figures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surface and contour plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing three-dimensional plots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main plotting package for Python is Matplotlib, which can be installed
    using your favorite package manager, such as `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will install the most recent version of Matplotlib, which, at the time
    of writing this book, is version 3.2.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matplotlib contains numerous sub-packages, but the main user interface is the
    `matplotlib.pyplot`package, which, by convention, is imported under the `plt`alias.
    This is achieved using the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Many of the recipes in this chapter also require NumPy, which, as usual, is
    imported under the `np`alias.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found in the `Chapter 02` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2ZOSuhs](https://bit.ly/2ZOSuhs).'
  prefs: []
  type: TYPE_NORMAL
- en: Basic plotting with Matplotlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plotting is an important part of understanding behavior. So much can be learned
    by simply plotting a function or data that would otherwise be hidden. In this
    recipe, we will walk through how to plot a simple function or data using Matplotlib.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib is a very powerful plotting library, which means it can be rather
    intimidating to perform simple tasks with it. For users who are used to working
    with MATLAB and other mathematical software packages, there is a state-based interface
    called `pyplot`. There is also an object-orientated interface, which might be
    more appropriate for more complex plots. The `pyplot` interface is a convenient
    way to create basic objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most commonly, the data that you wish to plot will be stored in two separate
    NumPy arrays, which we will label `x`and `y`for clarity (although this naming
    does not matter in practice). We will demonstrate plotting the graph of a function,
    so we will generate an array of `x` values and use the function to generate the
    corresponding `y` values. We define the function that we will plot as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can plot the function, we must generate the `x` and `y` data to be
    plotted. If you are plotting existing data, you can skip these commands. We need
    to create a set of the `x` values that cover the desired range, and then use the
    function to create the `y` values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `linspace` routine from NumPy is ideal for creating arrays of numbers for
    plotting. By default, it will create 50 equally spaced points between the specified
    arguments. The number of points can be customized by providing an additional argument,
    but 50 is sufficient for most cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the `x` values, we can generate the `y` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To plot the data, we simply need to call the `plot` function from the `pyplot`
    interface, which is imported under the `plt` alias. The first argument is the
    `x`*data and the second is the `y` data. The function returns a handle to the
    axes object on which the data is plotted:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*[PRE5]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will plot the `y` values against the `x` values on a new figure. If you
    are working within IPython or with a Jupyter notebook, then the plot should automatically
    appear at this point; otherwise, you might need to call the `plt.show` function
    to make the plot appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `plt.show`, the figure should appear in a new window. The resulting
    plot should look something like the plot in *Figure 2.1*. The default plot color
    might be different on your plot. It has been changed for high visibility for this
    book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c3c939df-e3cf-44f2-b35b-897b2b5ba75a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Plot of a function produced using Matplotlib without any additional
    styling parameters'
  prefs: []
  type: TYPE_NORMAL
- en: We won't add this command to any further recipes in this chapter, but you should
    be aware that you will need to use it if you are not working in an environment
    where plots will be rendered automatically, such as an IPython console or Jupyter
    Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there are currently no `Figure` or `Axes` objects, the `plt.plot` routine
    creates a new `Figure` object, adds a new `Axes` object to the figure, and populates
    this `Axes` object with the plotted data. A list of handles to the plotted lines
    is returned. Each of these handles is a `Lines2D` object. In this case, this list
    will contain a single `Lines2D` object. We can use this `Lines2D` object to customize
    the appearance of the line later (see the *Changing the plotting style* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: The object layer of Matplotlib interacts with a lower-level *backend*, which
    does the heavy lifting of producing the graphical plot. The `plt.show` function
    issues an instruction to the backend to render the current figure. There are a
    number of backends that can be used with Matplotlib, which can be customized by
    setting the `MPLBACKEND` environment variable, modifying the `matplotlibrc` file,
    or by calling `matplotlib.use` from within Python with the name of an alternative
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: The `plt.show` function does more than simply call the `show` method on a figure.
    It also hooks into an event loop to correctly display the figure. The `plt.show`
    routine should be used to display a figure, rather than the `show` method on a
    `Figure` object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is sometimes useful to manually instantiate a `Figure` object prior to calling
    the `plot` routine—for instance, to force the creation of a new figure. The code
    in this recipe could instead have been written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `plt.plot` routine accepts a variable number of positional inputs. In the
    preceding code, we supplied two positional arguments that were interpreted as
    `x` values and `y` values (in that order). If we had instead provided only a single
    array, the `plot` routine would have plotted the values against their position
    in the array; that is, the `x` values are taken to be `0`, `1`, `2`, and so on.
    We could also supply multiple pairs of arrays to plot several sets of data on
    the same axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c6e0b680-a648-4082-bbf0-b7d40a1635c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Multiple plots on a single figure, produced using a single call
    to the plot routine in Matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is occasionally useful to create a new figure and explicitly create a new
    set of axes in this figure together. The best way to accomplish this is to use
    the `subplots` routine in the `pyplot` interface (refer to the *Adding subplots*
    recipe). This routine returns a pair, where the first object is `Figure` and the
    second is an `Axes` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This sequence of commands produces the same plot as the preceding one displayed
    in *Figure 2.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib has many other plotting routines besides the `plot` routine described
    here. For example, there are plotting methods that use a different scale for the
    axes, including the logarithmic *x* or *y* axes separately (`semilogx` or `semilogy`,
    respectively) or together (`loglog`). These are explained in the Matplotlib documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the plotting style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic style of Matplotlib plots is fine for plotting functions or data that
    is ordered, but it is less appropriate for plotting discrete data that is not
    presented in any order. To prevent Matplotlib from drawing lines between each
    data point, we can change the plotting style to "turn off" the line drawing. In
    this recipe, we will customize the plotting style for each line on the axes by
    adding a format string argument to the `plot` method.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to have your data stored in pairs of arrays. For the purposes
    of this demonstration, we will define the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will plot these points against their position in the array (that is, the
    *x* coordinate will be `0`, `1`, `2`, `3`, or `4`, respectively, for each array).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to control the style of a plot is to use a **format string**,
    which is provided as an optional argument after the *x-y* pair or the `y`*data
    in the `plot` command. When plotting multiple sets of data, a different format
    string can be provided for each set of arguments. The following steps give a general
    procedure for creating a new figure and plotting data on this figure:*
  prefs: []
  type: TYPE_NORMAL
- en: '*1.  We first create the `Figure` and `Axes` objects explicitly using the `subplots`
    routine from `pyplot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have created the `Figure` and `Axes` objects, we can plot the data
    using the `plot` method on the `Axes` object. This method takes the same arguments
    as the `plot` routine from `pyplot`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This plots the first dataset (`y1`) with a circle marker, the second (`y2`)
    with an `x` marker, and the third (`y3`) with a star (`*`) marker. The output
    of this command is shown in *Figure 2.3*. The format string can specify a number
    of different marker lines and color styles. The same applies if we instead used
    the plot routine from the `pyplot` interface, which has the same calling signature
    as the `plot` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a98c28e3-2c76-4e50-87ac-079979b9bd71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Plot of three sets of data, each plotted using a different marker
    style'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The format string has three optional parts, each consisting of one or more
    characters. The first part controls the marker style, which is the symbol that
    is printed at each data point; the second controls the style of the line that
    connects the data points; and the third controls the color of the plot. In this
    recipe, we onlyspecified the marker style, which means that no connecting line
    is drawn between adjacent data points. This is useful for plotting discrete data
    where no interpolation between points is necessary. Four line style parameters
    are available: a solid line (`-`); a dashed line (`--`); a dash-dot line (`-.`);
    or a dotted line (`:`). Only a limited number of colors can be specified in the
    format string; they are red, green, blue, cyan, yellow, magenta, black, and white.
    The character used in the format string is the first letter of each color (with
    the exception of black), so the corresponding characters are`r`, `g`, `b`, `c`,
    `y`,`m`, `k`, and `w`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to change the marker style only, as we did in this recipe,
    to a plus character, we would use the `"+"`format string. If we also want to change
    the line style to a dash-dot line, we would use the `"+-."`format string. Finally,
    if we also wish to change the color of the marker to red, we would use the `"+-.r"`format
    string. These specifiers can also be provided in other configurations, such as
    specifying the color before the marker style, but this might lead to ambiguities
    in the way Matplotlib parses the format string.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a Jupyter notebook and the `subplots` command, you must include
    the call to `subplots` within the same cell as the plotting commands or the figure
    will not be produced.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `plot` method also accepts a number of keyword arguments that can also be
    used to control the style of a plot. Keyword arguments take precedence over format
    string parameters if both are present, and they apply to all sets of data plotted
    by the call. The keyword to control the marker style is `marker`, the keyword
    for the line style is `linestyle`, and the keyword for color is `color`. The `color`
    keyword argument accepts a number of different formats to specify a color, which
    includes RGB values as a `(r, g, b)`tuple, where each character is a float between
    `0` and `1` or is a hex string. The width of the line plotted can be controlled
    using the `linewidth`keyword, which should be provided with a`float` value. There
    are many other keyword arguments that can be passed to `plot`; a list is given
    in the Matplotlib documentation. Many of these keyword arguments have a shorter
    version, such as `c` for `color` and `lw` for `linewidth`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could set the color of all of the markers in the recipe by
    using the `color` keyword argument in the call to `plot` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Line2D` objects returned from calls to the `plot` method (or the `plt.plot`
    routine) can also be used to customize the appearance of each set of data. For
    example, the `set_linestyle` method in a `Line2D` object can be used, with the
    appropriate line style format string, to set the line style.
  prefs: []
  type: TYPE_NORMAL
- en: Other aspects of the plot can be customized by using methods on the `Axes` object.
    The axes ticks can be modified using the `set_xticks` and `set_yticks` methods
    on the `Axes` object, and the grid appearance can be configured using the `grid`
    method. There are also convenient methods in the `pyplot` interface that apply
    these modifications to the current axes (if they exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we modify the axis limits, set the ticks at every multiple of
    `0.5` in both the *x* and *y* direction, and add a grid to the plot by using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we set the limits slightly larger than the extent of the plot. This
    is to avoid markers being placed on the boundary of the plot window.
  prefs: []
  type: TYPE_NORMAL
- en: The `scatter` plotting routine may be better if you wish to plot discrete data
    on axes without connecting the points with a line. This allows more control over
    the style of the marker. For example, you can scale the marker according to some
    additional information.
  prefs: []
  type: TYPE_NORMAL
- en: Adding labels and legends to plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every plot should have a title, and the axes should be properly labeled. For
    plots displaying multiple sets of data, legends are a good way to help the reader
    quickly identify the marker, the line, and the color of different datasets. In
    this recipe, we will add axes labels and a title to a plot, and then add a legend
    to help distinguish between the different sets of data. To keep the code simple,
    we will plot the data from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to add labels and a legend to your plots to help distinguish
    the sets of data that they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first recreate the plot from the previous recipe using the following `plot`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a reference to the `Axes` object on which our data is plotted,
    and so we can start to customize these axes by adding labels and titles. The title
    and axes labels can be added to a figure by using the `set_title`, `set_xlabel`,
    and `set_ylabel` methods on the `ax` object created by the `subplots` routine.
    In each case, the argument is a string that contains the text to be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we plot the three datasets with a different style. The marker style is
    the same as in the previous recipe, but we have added a solid line for the first
    dataset, a dashed line for the second, and a dash-dot line for the third.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a legend, we call the `legend` method on the `ax` object. The argument
    should be a tuple or list containing the description to be placed in the legend
    for each set of data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding sequence of commands is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0ab005b7-27f6-4a24-8ec9-acdb04abd3d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: A plot with axes labels, a title, and a legend produced using Matplotlib'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `set_title`, `set_xlabel`, and `set_ylabel` methods simply add the text
    argument to the corresponding position of the `Axes` object. The `legend` method,
    as called in the preceding code, adds the labels to the datasets in the order
    that they were added to the plot—in this case, `y1`, `y2`, and then `y3`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of keyword arguments that can be supplied to the `set_title`,
    `set_xlabel`, and `set_ylabel`routines to control the style of the text. For example,
    the `fontsize`keyword can be used to specify the size of the label font in the
    usual `pt`point measure. The text argument can also be rendered using TeX for
    additional formatting by supplying `usetex=True`to the routine. The TeX formatting
    of labels is demonstrated in *Figure 2.5*. This is especially useful if the title
    or axis label contains a mathematical formula. Unfortunately, the `usetex`keyword
    argument cannot be used if TeX is not installed on the system—it will cause an
    error in this case. However, it is still possible to use the TeX syntax for formatting
    mathematical text within labels, but this will be typeset by Matplotlib, rather
    than by TeX.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a different font by using the `fontfamily` keyword, the value of
    which can be the name of a font or `serif`, `sans-serif`, or `monospace`, which
    will choose the appropriate built-in font. A complete list of modifiers can be
    found in the Matplotlib documentation for the `matplotlib.text.Text` class.
  prefs: []
  type: TYPE_NORMAL
- en: To add separate text annotations to a plot, you can use the `annotate` method
    on the `Axes` object. This routine takes two arguments—the text to display as
    a string and the coordinates of the point at which the annotation should be placed.
    This routine also accepts the previously mentioned styling keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Adding subplots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, it is useful to place multiple related plots within the same figure
    side by side but not on the same axes. Subplots allow us to produce a grid of
    individual plots within a single figure. In this recipe, we will see how to create
    two plots side by side on a single figure using subplots.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need the data to be plotted on each subplot. As an example, we will
    plot the first five iterates of Newton's method applied to the *f*(*x*) = *x²-1*function*with
    an initial value of *x[0] = 2*on the first subplot, and for the second, we will
    plot the error of the iterate. We first define a generator function to get the
    iterates:*
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE18]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This routine generates two lists. The first list contains iterates of Newton''s
    method applied to the function, and the second contains the error in the approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to create a figure that contains multiple subplots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `subplots` routine to create a new figure and references to all
    of the `Axes` objects in each subplot, arranged in a grid with one row and two
    columns. We also set the `tight_layout` keyword argument to `True` to fix the
    layout of the resulting plots. This isn''t strictly necessary, but it is in this
    case as it produces a better result than the default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once the `Figure` and `Axes` objects are created, we can populate the figure
    by calling the relevant plotting method on each `Axes` object. For the first plot
    (displayed on the left), we use the `plot` method on the `ax1` object, which has
    the same signature as the standard `plt.plot` routine. We can then call the `set_title`,
    `set_xlabel`, and `set_ylabel` methods on `ax1` to set the title and the `x` and
    `y`*labels. We also use TeX formatting for the axes labels by providing the `usetex`
    keyword argument; you can ignore this if you don't have TeX installed on your
    system:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*[PRE21]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can plot the error values on the second plot (displayed on the right)
    using the `ax2` object. We use an alternative plotting method that uses a logarithmic
    scale on the *y*-axis, called `semilogy`. The signature for this method is the
    same as the standard `plot` method. Again, we set the axes labels and the title.
    Again, the use of `usetex` can be left out if you don''t have TeX installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this sequence of commands is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f335dbe8-fa72-4b78-8a52-20f3159250f8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Matplotlib subplots'
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side plots the first five iterates of Newton's method and the
    right-hand side is the approximation error plotted on a logarithmic scale.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Figure` object in Matplotlib is simply a container for plot elements, such
    as `Axes`, of a certain size. A `Figure` object will usually onlyhold a single
    `Axes`object, which occupies the entire figure area, but it can contain any number
    of `Axes`objects in the same area. The `subplots`routine does several things.
    It first creates a new figure and then creates a grid with the specified shape
    in the figure area. Then, a new `Axes`object is added to each position of the
    grid. The new `Figure`object and one or more `Axes`objects are then returned to
    the user. If a single subplot is requested (one row and one column, with no arguments)
    then a plain`Axes`object is returned. If a single row or column is requested (with
    more than one column or row, respectively), then a list of the `Axes`objects is
    returned. If more than one row and column is requested, a list of lists, with
    rows represented by inner lists filled with the `Axes`objects, will be returned.
    We can then use the plotting methods on each of the `Axes`objects to populate
    the figure with the desired plots.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we used the standard `plot` method for the left-hand side plot,
    as we have seen in previous recipes. However, for the right-hand side plot, we
    used a plot where the *y-*axis had been changed to a logarithmic scale. This means
    that each unit on the *y*-axis represents a change of a power of 10, rather than
    a change of one unit, so that `0` represents 10⁰ = 1, `1` represents 10, `2` represents
    100, and so on. The axes labels are automatically changed to reflect this change
    in scale. This type of scaling is useful when the values change by an order of
    magnitude, such as the error in an approximation, as we use more and more iterations.
    We can also plot with a logarithmic scale for *x* only by using the `semilogx`
    method, or both axes on a logarithmic scale by using the `loglog` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to create subplots in Matplotlib. If you have already
    created a `Figure` object, then subplots can be added using the `add_subplot`
    method of the `Figure` object. Alternatively, you can use the `subplot` routine
    from `matplotlib.pyplot` to add subplots to the current figure. If one does not
    yet exist, it will be created when this routine is called. The `subplot` routine
    is a convenience wrapper of the `add_subplot` method on the `Figure` object.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new figure with one or more subplots, you can also use the `subplots`
    routine from the `pyplot` interface—as we saw in the *Changing the plotting style*
    recipe—which returns a new figure object and an array of the `Axes` objects, one
    for each position. All three of these methods require the number of rows and columns
    for the subplot matrix. The `add_subplot` method and the `subplot` routine also
    require a third argument, which is the index of the subplot to modify. The `Axes`
    object of the current subplot is returned.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created two plots with differently scaled *y-*axes.
    This demonstrates one of the many possible uses of subplots. Another common use
    is for plotting data in a matrix where columns have a common `x` label and rows
    have a common `y` label, which is especially common in multivariate statistics
    when investigating the correlation between various sets of data. The `plt.subplots`
    routine for creating subplots accepts the `sharex` and `sharey`keyword parameters,
    which allows the axes to be shared among all the subplots or among a row or column.
    This setting affects the scale and ticks of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib supports more advanced layouts by providing the `gridspec_kw` keyword
    arguments to the `subplots` routine. See the documentation for `matplotlib.gridspec`
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Saving Matplotlib figures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work in an interactive environment, such as an IPython console or a
    Jupyter notebook, displaying a figure at runtime is perfectly normal. However,
    there are plenty of situations where it would be more appropriate to store a figure
    directly to a file, rather than rendering it on screen. In this recipe, we will
    see how to save a figure directly to a file, rather than displaying it on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need the data to be plotted and the path or file object in which you
    wish to store the output. We store the result in `savingfigs.png` in the current
    directory. In this example, we will plot the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to save a Matplotlib plot directly to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create the figure, as usual, and add any labels, titles,
    and annotations that are necessary. The figure will be written to the file in
    its current state, so any changes to the figure should be made before saving:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `savefig`method on `fig` to save this figure to a file. The
    only required argument is the path to output to or a file-like object that the
    figure can be written to. We can adjust various settings for the output format,
    such as the resolution, by providing the appropriate keyword arguments. We''ll
    set the **Dots per Inch** (**DPI**) of the output figure to `300`, which is a
    reasonable resolution for most applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Matplotlib will infer that we wish to save the image in the **Portable Network
    Graphics** (**PNG**) format from the extension of the file given. Alternatively,
    a format can be explicitly provided as a keyword argument (by using the `format`keyword),
    or it will fall back to the default from the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `savefig` method chooses the appropriate backend for the output format and
    then renders the current figure in that format. The resulting image data is written
    to the specified path or file-like object. If you have manually created a `Figure`
    instance, the same effect can be achieved by calling the `savefig` method on that
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `savefig` routine takes a number of additional optional keyword arguments
    to customize the output image. For example, the resolution of the image can be
    specified using the `dpi` keyword. The plots in this chapter have been produced
    by saving the Matplotlib figures to the file.
  prefs: []
  type: TYPE_NORMAL
- en: The output formats available include PNG, **Scalable Vector Graphics** (**SVG**),
    **PostScript** (**PS**), **Encapsulated PostScript** (**EPS**), and **Portable
    Document Format** (**PDF**). You can also save to JPEG format if the Pillow package
    is installed, but Matplotlib does not support this natively since version 3.1\.
    There are additional customization keyword arguments for JPEG images, such as
    `quality` and `optimize`. A dictionary of image metadata can be passed to the
    `metadata` keyword, which will be written as image metadata when saving.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples gallery on the Matplotlib website includes examples of embedding
    Matplotlib figures into a **Graphical User Interface** (**GUI**) application using
    several common Python GUI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Surface and contour plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matplotlib can also plot three-dimensional data in a variety of ways. Two common
    choices for displaying data like this are by using **surface plots** or **contour
    plots** (think of contour lines on a map). In this recipe, we will see a method
    for plotting surfaces from three-dimensional data and how to plot contours of
    three-dimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To plot three-dimensional data, it needs to be arranged into two-dimensional
    arrays for the *x*, *y*, and *z* components, where both the *x* and *y* components
    must be of the same shape as the *z* component. For the sake of this demonstration,
    we will plot the surface corresponding to the *f*(*x*, *y*) = *x*²*y*³function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to plot the *f*(*x*, *y*) = *x*²*y*³functionon the -2 ≤ *x* ≤ 2 and
    -1 ≤ *y ≤* 1range. The first task is to create a suitable grid of (*x*, *y*) pairs
    on which to evaluate this function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first use `np.linspace`to generate a reasonable number of points in these
    ranges:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to create a grid on which to create our *z*values. For this, we
    use the `np.meshgrid`routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create the *z*values to plot, which hold the value of the function
    at each of the grid points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To plot three-dimensional surfaces, we need to load a Matplotlib toolbox, `mplot3d`,
    which comes with the Matplotlib package. This won''t be used explicitly in the
    code, but behind the scenes, it makes the three-dimensional plotting utilities
    available to Matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a new figure and a set of three-dimensional axes for the figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call the `plot_surface` method on these axes to plot the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It is extra important to add axis labels to three-dimensional plots because
    it might not be clear which axis is which on the displayed plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also set a title at this stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `plt.show` routine to display the figure in a new window (if
    you are using Python interactively and not in a Jupyter notebook or on an IPython
    console) or `plt.savefig` to save the figure to a file. The result of the preceding
    sequence is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b844fb9d-e453-46f2-a233-9ec2e4eeb71e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: A three-dimensional surface plot produced with Matplotlib using
    the default settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contour plots do not require the `mplot3d` toolkit, and there is a `contour`
    routine in the `pyplot` interface that produces contour plots. However, unlike
    the usual (two-dimensional) plotting routines, the `contour` routine requires
    the same arguments as the `plot_surface` method. We use the following sequence
    to produce a plot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18cd3684-5b44-4b67-9ce2-d48ecd675303.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Contour plot produced using Matplotlib with the default settings'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `mplot3d` toolkit provides an `Axes3D` object, which is a three-dimensional
    version of the `Axes` object in the core Matplotlib package. This is made available
    to the `axes` method on a `Figure` object when the `projection="3d"` keyword argument
    is given. A surface plot is obtained by drawing quadrilaterals, in the three-dimensional
    projection, between nearby points in the same way that a two-dimensional curve
    is approximated by straight lines joining adjacent points.
  prefs: []
  type: TYPE_NORMAL
- en: The `plot_surface` method needs the *z* values to be provided as a two-dimensional
    array that encodes the *z* values on a grid of (*x*, *y*) pairs. We created the
    range of *x* and *y* values that we are interested in, but if we simply evaluate
    our function on the pairs of corresponding values from these arrays, we will get
    the *z* values along a line and not over a grid. Instead, we use the `meshgrid`
    routine, which takes the two `X` and `Y`arrays and creates from them a grid consisting
    of all the possible combinations of values in `X`and `Y`. The output is a pair
    of two-dimensional arrays on which we can evaluate our function. We can then provide
    all three of these two-dimensional arrays to the `plot_surface`method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The routines described in the preceding section, `contour` and `plot_contour`,
    only work with highly structured data where the *x*, *y*, and *z* components are
    arranged into grids. Unfortunately, real-life data is rarely so structured. In
    this case, you need to perform some kind of interpolation between known points
    to approximate the value on a uniform grid, which can then be plotted. A common
    method for performing this interpolation is by triangulating the collection of
    (*x*, *y*) pairs and then using the values of the function on the vertices of
    each triangle to estimate the value on the grid points. Fortunately, Matplotlib
    has a method that does all of these steps and then plots the result, which is
    the `plot_trisurf` routine. We briefly explain how this can be used here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the use of `plot_trisurf`, we will plot a surface and contours
    from the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we will plot both the surface and contour(approximations) on the
    same figure as two separate subplots. For this, we supply the `projection="3d"`
    keyword argument to the subplot that will contain the surface. We use the `plot_trisurf`
    method on the three-dimensional axes to plot the approximated surface, and the
    `tricontour` method on the two-dimensional axes to plot the approximated contours:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now plot the contours for the triangulated surface using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We include the `tight_layout=True`keyword argument with the figure to save
    a call to the `plt.tight_layout`routine later. The result is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c347d304-3e13-4341-a1e8-20ce0854d5a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Approximate surface and contour plots generated from unstructured
    data using triangulation'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to surface plotting routines, the `Axes3D` object has a `plot` (or
    `plot3D`) routine for simple three-dimensional plotting, which works exactly as
    the usual `plot` routine but on the three-dimensional axes. This method can also
    be used to plot two-dimensional data on one of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing three-dimensional plots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contour plots can hide some detail of the surface that they represent since
    they only show where the "height" is similar and not what the value is, even in
    relation to the surrounding values. On a map, this is remedied by printing the
    height onto certain contours. Surface plots are more revealing, but the problem
    of projecting three-dimensional objects into 2D to be displayed on a screen can
    itself obscure some details. To address these issues, we can customize the appearance
    of a three-dimensional plot (or contour plot) to enhance the plot and make sure
    the detail that we wish to highlight is clear. The easiest way to do this is by
    changing the colormap of the plot.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the reverse of the `binary` colormap.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will generate surface plots for the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de81842d-a1b9-4ec4-b7a8-5e3fe30bb458.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We generate the points at which this should be plotted as in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matplotlib has a number of built-in colormaps that can be applied to plots.
    By default, surface plots are plotted with a single color that is shaded according
    to a light source (see the *There''s more...* section of this recipe). A colormap
    can dramatically improve the effect of a plot. The following steps show how to
    add a colormap to surface and contour plots:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we simply apply one of the built-in colormaps, `binary_r`, which
    is done by providing the `cmap="binary_r"` keyword argument to the `plot_surface`
    routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a figure (*Figure* 2.9) where the surface is colored according
    to its value, with the most extreme values at either end of the colormap—in this
    case, the larger the *z* value, the lighter the shade of gray. Note that the jaggedness
    of the plot in the following diagram is due to the relatively small number of
    points in the mesh grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cf0e7c34-b176-49b8-b54f-0a4150f9b746.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: A surface plot with a grayscale colormap applied'
  prefs: []
  type: TYPE_NORMAL
- en: Colormaps apply to other plot types in addition to surface plots. In particular,
    colormaps can be applied to contour plots, which can help to distinguish between
    the contours that represent higher values and those that represent lower values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the contour plot, the method for changing the colormap is the same; we
    simply specify a value for the `cmap` keyword argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34011236-d782-49c1-910d-b4283dbe9951.png)Figure 2.10: A contour
    plot with an alternative colormap set'
  prefs: []
  type: TYPE_NORMAL
- en: The darker shades of gray in the diagram correspond to the lower values of z.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Color mapping works by assigning an RGB value according to a scale—the **colormap**.
    First, the values are normalized so that they lie between `0` and `1`, which is
    typically done by a linear transformation that takes the minimum value to `0`
    and the maximum value to `1`. The appropriate color is then applied to each face
    of the surface plot (or line, in another kind of plot).
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib comes with a number of built-in colormaps that can be applied by
    simply passing the name to the `cmap`keyword argument. A list of these colormaps
    is given in the documentation ([https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html)),
    and also comes with a reversed variant, which is obtained by adding the `_r`suffix
    to the name of the chosen colormap.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The normalization step in applying a colormap is performed by an object derived
    from the `Normalize` class. Matplotlib provides a number of standard normalization
    routines, including `LogNorm` and `PowerNorm`. Of course, you can also create
    your own subclass of `Normalize` to perform the normalization. An alternative
    `Normalize` subclass can be added using the `norm` keyword of `plot_surface` or
    other plotting functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more advanced uses, Matplotlib provides an interface for creating custom
    shading using light sources. This is done by importing the `LightSource` class
    from the `matplotlib.colors` package, and then using an instance of this class
    to shade the surface elements according to the *z* value. This is done using the
    `shade` method on the `LightSource` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Complete examples are shown in the Matplotlib gallery should you wish to learn
    more about how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Matplotlib package is extensive and we can scarcely do it justice in such
    a short space. The documentation contains far more detail than is provided here.
    Moreover, there is a large gallery ([https://matplotlib.org/gallery/index.html#](https://matplotlib.org/gallery/index.html#))
    of examples covering many more of the capabilities of the package than in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: There are other packages that build on top of Matplotlib that offer high-level
    plotting methods for specific applications. For example, the Seaborn libraries
    provide routines for visualizing data ([https://seaborn.pydata.org/](https://seaborn.pydata.org/)).****
  prefs: []
  type: TYPE_NORMAL
