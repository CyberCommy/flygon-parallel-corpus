- en: Turning Things On and Off
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at core electronic circuits and concepts
    that you will use when interfacing digital and analog circuits with your Raspberry
    Pi's GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover how to switch *things* on and off that require
    more voltage and current than can be safely used with your Raspberry Pi. When
    it comes to electronics, hundreds of different components can be used for controlling
    and switching. And there are thousands of different ways they can be configured.
    We will be focusing on three common complements—optocouplers, transistors, and
    relays.
  prefs: []
  type: TYPE_NORMAL
- en: An understanding of how to control and switch electrical circuits on or off
    is a very important topic when interfacing with a Raspberry Pi. As we discussed
    in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting your Raspberry
    Pi to the Physical World*, Raspberry Pi GPIO pins are only capable of safely delivering
    a few milliamps of output current and a fixed 3.3-volts. After completing this
    chapter, your knowledge of optocouplers, transistors, and relays will mean you
    can start controlling devices that have different current and voltage requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a relay driver circuit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining a load's voltage and current
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an optocoupler as a switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a transistor as a switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a relay as a switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform the exercises in this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 Model B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspbian OS Buster (with desktop and recommended software)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A minimum of Python version 3.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  prefs: []
  type: TYPE_NORMAL
- en: You will find this chapter's source code in the `chapter07` folder in the GitHub
    repository available here: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following dependencies are installed from `requirements.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 x 2N7000 MOSFET (sample datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/171823/ONSEMI/2N7000.html](https://www.alldatasheet.com/datasheet-pdf/pdf/171823/ONSEMI/2N7000.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x FQP30N06L MOSFET (optional—sample datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/52370/FAIRCHILD/FQP30N06L.html](https://www.alldatasheet.com/datasheet-pdf/pdf/52370/FAIRCHILD/FQP30N06L.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x PC817 optocoupler (sample datasheet [https://www.alldatasheet.com/datasheet-pdf/pdf/547581/SHARP/PC817X.html](https://www.alldatasheet.com/datasheet-pdf/pdf/547581/SHARP/PC817X.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x SDR-5VDC-SL-C relay (sample datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/1131858/SONGLERELAY/SRD-5VDC-SL-C.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1131858/SONGLERELAY/SRD-5VDC-SL-C.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 1N4001 diode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x 1k Ω and 1 x 100k Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x 5mm red LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 x Size 130 (R130) DC motor rated 3-6 volts (ideally with a stall current <
    800mA) or alternate DC motor with compatible voltage and current ratings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital multimeter capable of measuring current (it'll have an A or mA setting)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 x External power sources—at a minimum, a 3.3V/5V breadboard-mountable power
    supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring a relay driver circuit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common introduction to electronic switching is the mechanical relay—a device
    that operates like a common switch, only it''s turned on and off by applying power
    to it. Unfortunately, connecting a relay directly to a Raspberry Pi is dangerous!
    Relays commonly require too much current and voltage and (if they do switch) can
    damage your Raspberry Pi. So, we need a driver circuit that sits between your
    Raspberry Pi and the relay. An example of this circuit is shown in *Figure 7.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ca2a40c5-0e53-42e6-a25f-bf6361a8ddd7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Relay driver circuit
  prefs: []
  type: TYPE_NORMAL
- en: This is the circuit we will build, piece-by-piece during this chapter. This
    circuit is representative of the many relay control modules that you will find
    on eBay, Banggood, and similar web sites. These boards are certainly convenient
    to use—when you get them to work. Unfortunately, all too often, a lack of clear
    documentation can make getting them to work fiddly and difficult, especially if
    you are new to electronics.
  prefs: []
  type: TYPE_NORMAL
- en: We are about to build and explore the three sub-circuits depicted in *Figure
    7.1.* This will help you to understand how optocouplers, transistors, and relays
    work as switches and why they are often chained together to control a relay. This
    knowledge will also help you to reverse-engineer a pre-made relay control module
    in case you can't get one working.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at the optocoupler sub-circuit, we need to first discuss load
    voltages and currents.
  prefs: []
  type: TYPE_NORMAL
- en: Determining a load's voltage and current
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *load* is something that you want to control, or for this chapter, switch
    on and off. LEDs, transistors, optocouplers, relays, lights, electric motors,
    heaters, pumps, automatic garage doors, and TVs are all examples of a load. If
    you refer back to *Figure 7.1*, you will notice the word Load on the right-hand
    side of the diagram. This is where you connect the thing you want to switch on
    or off.
  prefs: []
  type: TYPE_NORMAL
- en: The *transistors, optocouplers,* and *relays* components appear in this aforementioned load
    list*.* Referring back to *Figure 7.1*, the relay appears as the load to the transistor
    sub-circuit while the transistor sub-circuit appears as the load to the optocoupler
    sub-circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to know two properties about the load you want to control:'
  prefs: []
  type: TYPE_NORMAL
- en: What **voltage** does the load require?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What **current** does the load require?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, these properties can be found on the device itself or in its manual
    or datasheet. At other times, they need to be calculated or the load needs to
    be manually measured.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing these properties is important because they influence which components
    are chosen for a circuit, including the specifications for a suitable power supply.
    We will make mention of load currents as we build circuits throughout this chapter,
    so a little more context is coming. For now, let's look at how to measure the
    current load of a DC motor.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the current requirement of a DC motor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Motors are a common item that people want to control, and they serve as an
    excellent example in current measurement. Let''s perform an exercise to measure
    the current used by our DC motor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d5acaf87-b079-48d5-90bf-cbbc17d30445.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – R130 DC Motor
  prefs: []
  type: TYPE_NORMAL
- en: A typical size 130 (R130) DC motor is shown in the preceding photograph, together
    with a set of jumper leads soldered to the motor's terminals so it can be plugged
    easily into a breadboard. This motor has a red back, however, other colors are
    common—especially clear/white. The color has no bearing on the motor specifications.
  prefs: []
  type: TYPE_NORMAL
- en: As you proceed with the following steps, please consult your multimeter manual
    if you are unsure how to place it into current measurement mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect up a circuit as shown in *Figure 7.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/6b3b720f-a005-4681-bb38-757fb1735714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Measuring current with a multimeter
  prefs: []
  type: TYPE_NORMAL
- en: We are assuming that the motor here is the one mentioned in the *Technical requirements*
    section at the start of the chapter. This motor is small enough to be powered
    from a breadboard power supply, which typically can supply between 500mA and 800mA.
    For larger motors (and other items where you do not know their ratings and want
    to measure them), you will require a more capable power supply.
  prefs: []
  type: TYPE_NORMAL
- en: If you are powering a breadboard power supply from a USB phone charger, check
    your power supplies 5-volt output with a multimeter to make sure it is providing
    about 5 volts. Low wattage chargers and poor quality USB cables might not be able
    to deliver enough power for the power supply to operate correctly. Ideally, read
    the datasheet and use the suggested power adapter, which commonly are 7 to 12
    volts and 1 amp.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your multimeter is set to measure **milliamps** (**mA**), and that
    its red lead is connected to the correct lead input (typically it will be labeled
    A or mA). If your DMM has a µA input, *do not use it* or you may blow your DMM's
    protection fuse (the fuse can be replaced).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply power to the circuit, and the motor will spin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your multimeter will display the current draw of the motor. Write down this
    value. This is known as the **continuous** or **free current** and is the current
    your motor uses while freely spinning with nothing connected to its shaft.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect power to the motor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a pair of pliers, hold the motor's shaft so it cannot spin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reapply power to the motor, and quickly observe (and write down) the DMM's reading.
    This reading is called the **stall current***.* A motor will use the most current
    when its shaft has been forcefully stopped from moving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disconnect the power to the motor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have now measured two currents. My readings on an R130 motor were as follows
    (and yours will be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous or free current**: ~110mA to ~200mA—As the motor heats from use,
    it will use less; the ~200mA measurement was when the motor was cold. Over one
    minute, it dropped to ~110mA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stall current**: This was ~500mA to ~600mA.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What this means is that our motor will need between 200mA and 600mA milliamps
    for normal operation and that any circuit we wish to use with our motor must be
    able to realistically handle 600mA so that it will not get damaged if the motor
    stalls (or we need to design suitable protection, however, this is beyond our
    scope).
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that there's also a **start-up current**, which is
    a momentary peak current that occurs when the motor starts, but we won't be able
    to measure that on a generic DMM.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the current draw for our R130 motor, let's collect more current
    data for a relay and an LED.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring the current requirement of a relay and LED
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will also measure the current draw of an LED and the relay we will use in
    this chapter when we reach the section titled *Using a relay as a switch*. You
    can measure the current draw using *steps 1 to 4* from the preceding section.
    The setup to perform this measurement for an LED and resistor pair is illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ad9ebbb-3904-4bd9-b56d-4355f09f095f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Measuring current through a resistor/LED circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the basic process we follow:'
  prefs: []
  type: TYPE_NORMAL
- en: We attach an LED and a 1kΩ resistor (or a relay) in place of the motor shown
    in *Figure 7.3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set your multimeter to milliamps mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply power to the circuit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Measure the amperage on your multimeter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have performed (and jotted down) the measurement you receive, remove
    the LED and resistor from the breadboard and wire in your relay and perform the
    same measurement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an SRD-05VDC-SL-C relay and which terminals on
    your relay you need to connect. Please note that you will need to solder header
    pins (pictured) or wires (a good option is to cut in half a DuPont cable) onto
    your relay''s terminals as it will not fit directly into a breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89750306-8613-4edf-8650-96bb9ea9b654.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – SRD-05VDC-SL-C relay
  prefs: []
  type: TYPE_NORMAL
- en: 'With a 5V source, you should obtain values similar to these on your multimeter:'
  prefs: []
  type: TYPE_NORMAL
- en: '5mm red LED in series with a 1000Ω resistor: 3mA (values from Ohms calculation
    and rounded up *I = (5V - 2.1V) / 1000Ω = 2.9mA*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relay: 70mA to 90mA (values from the datasheet and confirmed by my own measurements)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process for calculating the current for the LED was discussed in [Chapter
    6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics 101 for the Software
    Engineer.* The only difference isthat here we are using a 5-volt source and a
    1kΩ resistor, not 3.3 volts and a 200Ω resistor as we did in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the optocoupler and MOSFET component we will be using do have
    a voltage drop aspect to them that does affect current through the attached load.
    This impact of these voltage drops are immaterial for our purposes, so they are
    not taken into account for the calculations in this chapter for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: You have now learned how to measure the current draw of a DC motor, LED/resistor
    pair, and a relay using a multimeter. Knowing the current limitations and expectations
    of a device you want to control, and even the sub-circuit you are connecting to,
    is a vital piece of information that is required so that you can select suitably
    rated components when designing a circuit and choosing a suitable power source.
  prefs: []
  type: TYPE_NORMAL
- en: We will be referencing the measurements you have performed in this section as
    we explore optocouplers, MOSFETs, and relays throughout this chapter. Specifically,
    we will compare the current ratings of these components (found in their respective
    datasheets) to our DC motor, LED/resistor, and relay measurements and consider
    what components can be used to directly control which load.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by learning about optocouplers and how to use them as a switch.
  prefs: []
  type: TYPE_NORMAL
- en: Using an optocoupler as a switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An optocoupler (or optoisolator) is a light-controlled component that is used
    to electrically isolate two circuits. An illustration and the schematic symbol
    of an optocoupler are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/22ab1665-4970-450c-a2f0-da1ada722194.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Optocoupler symbol and component with pins labeled
  prefs: []
  type: TYPE_NORMAL
- en: 'The two sides of an optocoupler can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An *input* side: The side we will connect to a Raspberry Pi GPIO pin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An *output* side: The side we will connect to another circuit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside an optocoupler on the *input* side is an internal LED (you will notice
    the LED symbol within the optocoupler symbol in *Figure 7.6*) while on the *output* side
    there is a phototransistor that responds to the LED's light. What this means is
    that the transfer of control (that is, switching) from the *input* side to the
    *outside* side is performed by light, hence, there is no physical electrical connection
    between the two sides. For us, this means that any failures or accidents on the
    output side should not cause damage to our Raspberry Pi. The PC817 has its isolation
    rated as 5000 volts, which are well beyond any voltages we would expect to be
    used with IoT electronics and devices.
  prefs: []
  type: TYPE_NORMAL
- en: When the *input* side LED is off, the *output* side phototransistor is off.
    However, when the LED is illuminated (it's inside the optocoupler component, so
    you will not see it) by applying current to pins 1 (anode) and 2 (cathode), the
    phototransistor is activated (on) and allows current to flow between pins 4 (collector)
    and 3 (emitter).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple circuit to demonstrate a PC817 optocoupler, which has
    the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input side (the LED): This has the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical **forward voltage (V[F])** is 1.2 volts DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum **forward current** **(I[F]) **is 50mA DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output side (the phototransistor): This has the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maximum **collector-emitter voltage (V[CEO])**: 80 volts DC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maximum **collector current (I[C])**: 50mA DC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collector-Emitter Saturation Voltage V[CE(sat)]** in the range 0.1 to 0.2
    volts (basically the voltage drop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping these specifications in mind, let's begin our circuit build.
  prefs: []
  type: TYPE_NORMAL
- en: Building the optocoupler circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re about to build the circuit illustrated in the following diagram. This
    circuit uses the PC817 optocoupler to electrically isolate our Raspberry Pi and
    the LED subcircuit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3d363ad-4fbd-47aa-841a-a0648293090f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Optocoupler circuit
  prefs: []
  type: TYPE_NORMAL
- en: 'The step numbers here match the numbered black circles in *Figure 7.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the LED into your breadboard, taking care to orientate the LED as illustrated
    regarding its cathode leg.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor into the breadboard. One end of this resistor connects
    inline with the cathode leg of the LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the PC817 Optocoupler IC into your breadboard. The white dot on the IC
    indicates pin number 1 of the IC. Your IC may have or not have the white dot,
    however, there should be a distinct marking on the IC to tell you the first pin.
    Please refer back to *Figure 7.6 *for all pin numberings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor into your breadboard. One end of this resistor connects
    with pin 1 of the PC817.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode leg of the LED to the positive rail of the right-hand side
    power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin 4 of the PC817 to the other end of the resistor you placed at *step
    2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin 3 of the PC817 to the negative rail of the right-hand side power
    rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the positive output of a 5-volt power supply into the right-hand side positive
    power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative output of a power supply into the right-hand side negative
    power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other end of the resistor you placed at *step 4* to a 3.3-volt pin
    on your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect pin 2 of the PC817 to GPIO 21 on your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *Figure 7.7*, you could connect the wires at *steps 8* and *9* (which go
    to the External Power Supply) directly to your Raspberry Pi's +5-volt pin and
    a GND pin. We're only using a small amount of current for the red LED, however,
    for higher current loads, you must use an external power supply. The +5 volt pin
    on your Raspberry Pi is connected directly to the power supply you are using to
    power your Raspberry Pi. Using this power supply to power your circuits effectively robs current
    available to your Raspberry Pi. Take too much, and your Raspberry Pi will reset!
    **Please note (this is important) that the caveat of this action is that ****you
    lose the electrical isolation offered by the optocoupler** because you will have
    electrically connected the *input* and *output* sides of the optocoupler together
    (remember, the *input* and *output* sides are not electrically inside the optocoupler
    because control is achieved by light).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have completed the circuit build, we will test the circuit and
    explore the code that makes it work.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the optocoupler with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by running the code in the `chapter07/optocoupler_test.py` file, and
    observe the LED blink. Following is the part of the code responsible for the blinking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: At line (1), GPIO 21 is low and the internal LED on the *input* side is on.
    The phototransistor on the *output* side detects this light and is activated,
    allowing current to flow between the output side's collector (pin 4) and emitter
    (pin 3), and hence our red LED illuminates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The input side of the PC817 circuit is wired as *active low—*that's why at line
    (1), GPIO 21 is made low to turn the circuit on, and at line (2), GPIO 21 is set
    to high to turn the circuit off. Alternative wiring would be *active high.* If
    you want to experiment and change the circuit to be active-high, you would attach
    the wire from *step 10* in *Figure 7.7 *to a GND pin (rather than a 3.3-volt pin),
    and reverse the `pigpio.LOW` and `pigpio.HIGH` statements in the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could have used a lower value resistor for R1 for the input-side LED, however,
    a 1kΩ resistor provides more than enough current (*(3.3V - 1.2V)/1000Ω = 2.1mA*)
    to the internal LED for the optocoupler circuit to work. You'll see 1kΩ, 10kΩ,
    and 100kΩ resistors used in a lot of circuits simply because these are nice round
    values. We've also used a 1kΩ resistor for R2 for the red LED for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Can you remember from the previous chapter, [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics
    101 for the Software Engineer*, when we discussed that we should not expect more
    than 8mA from a Raspberry Pi GPIO pin? Well, by using a PC817 optocoupler, we
    can now control up to 50mA by placing an optocoupler between a GPIO pin and a
    circuit. Furthermore, we are also not limited to the 3.3 volts of a GPIO pin since
    the PC817 can handle up to 80 volts.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that a GPIO pin's primary role is to *control* something, not *power* it,
    so always think about *control* and *power* requirements independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we calculated (or measured) the current draw of our
    motor, relay, and an LED. Here is that data in the context of our PC817 optocoupler
    using a 5-volt power source on the output side:'
  prefs: []
  type: TYPE_NORMAL
- en: The LED and 1kΩ resistor needed a current of 3mA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relay needed between 70mA and 90mA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The motor needed ~500mA to ~600mA (stall current).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LED's 3mA is less than the optocouplers maximum output-side rating of 50mA,
    so it's fine to drive the LED directly on the output side. The relay and motor,
    however, require a current beyond the limits of the PC817, so using them on the
    output may result in damage to the optocoupler.
  prefs: []
  type: TYPE_NORMAL
- en: While we can and do use optoisolators as a digital switch, they are often used
    as an isolating barrier to drive other components, which in turn can drive loads
    requiring higher currents. We will see this later on when we build the full relay
    driver circuit from *Figure 7.1,* but for now, let's learn how to use a transistor
    as a digital switch.
  prefs: []
  type: TYPE_NORMAL
- en: Using a transistor as a switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transistors are a hands-down most significant electronic component in use today
    and the backbone of the digital revolution. They can be used in two basic ways—as
    an amplifier or as a digital switch. Our focus is going to be on digital switching,
    and we will be using a transistor type known as a **Metal-Oxide-Semiconductor-Field-Effect
    Transistor** (**MOSFET**), specifically, an N-Channel Enhancement Mode MOSFET—yes,
    it's a mouthful!
  prefs: []
  type: TYPE_NORMAL
- en: Don't get too caught up on the long technical name or the many forms of transistors
    that exist. The simple take-home here is that an N-Channel Enhancement Mode MOSFET
    works well as a digital switch that we can control using our Raspberry Pi, or
    as we will see later, from another source such as an optocoupler.
  prefs: []
  type: TYPE_NORMAL
- en: FETs are *voltage-*controlled transistors. Another type of transistor known
    as a **Bipolar Junction Transistor** (**BJT**) is a *current*-controlled transistor.
    BJTs are perfectly fine to use with a Raspberry Pi but require additional considerations.
    You'll find a link in the *Further reading* section to further your learning on
    transistors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following exercise will be using a 2N7000, an N-Channel Enhancement Mode MOSFET,
    as illustrated in *Figure 7.8*. The leg names are ***S***ource, ***G***ate, and
    ***D***rain. Two different packaging styles are also illustrated, the TO92 and
    TO220\. Notice that the arrangement of the Source, Gate, and Drain legs on the
    two styles are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7baa943-66c4-4e49-9d06-54d41f12d36d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – N-Channel Enhancement MOSFET symbol and common package styles
  prefs: []
  type: TYPE_NORMAL
- en: 'The 2N7000 has the following specifications in its datasheet:'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum **Drain Source Voltage (V[DSS])** of 60 volts DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum **Continuous Drain Current (I[D])** of 200 mA DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum **Pulsed Drain Current (I[DM])** of 500 mA DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gate Threshold Voltage (V[GS(th)])** in the range of 0.8 to 3 volts DC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drain−Source On−Voltage (V[DS(on)])** in the range of 0.45 to 2.5 volts DC 
    (voltage drop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how to interpret these parameters regarding the 2N7000:'
  prefs: []
  type: TYPE_NORMAL
- en: It can safely control a load not exceeding 60 volts (V[DSS]) and a continuous
    200mA (I[D]), but a pulse of 500mA (I[DM]) is OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will ideally require a voltage >= 3 volts to switch it on (V[GS(th)]).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will consume, on the load-side circuit, a voltage in the range of 0.45 to
    2.5 volts (V[DS(on)]).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 2N7000 (and the FQP30N06L that we will discuss shortly) are logic-level
    comparable MOSFETs. They are suitable for a Raspberry Pi because their maximum
    gate voltage V[GS(th)]is less than a GPIO pin's 3.3 volts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started and build a circuit to use the 2N7000 with our Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Building the MOSFET circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will build our circuit in two parts, starting with the placement of the
    components on our breadboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2bd266b-bb0c-4d22-979f-3f16b40d3f84.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – MOSFET transistor circuit (part 1 of 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps for the first part of our build. The step numbers match
    the numbered black circles in *Figure 7.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the MOSFET into your breadboard, taking care to orientate the component
    the correct way around regarding the Source, Gate, and Drain legs. Our example
    layout assumes a 2N7000 MOSFET. Please see *Figure 7.8 *if you need help to identify
    the legs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 100kΩ resistor into your breadboard. One end of this resistor connects
    to the Gate leg of the MOSFET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor into the breadboard. One end of this resistor also connects
    to the Gate leg of the MOSFET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the LED into the breadboard, taking care to orientate the component as
    shown regarding its cathode leg.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor into the breadboard. One end of this resistor connects
    with the cathode leg of the LED.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the diode into the breadboard, orientating the component so that the cathode
    leg (the end of the diode with the band on the casing) is facing toward the bottom
    of the breadboard. We will discuss the purpose of this diode shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have placed the components into our breadboards, let''s wire them
    all up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/848bd536-8eff-4760-a235-335d457bb7a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – MOSFET transistor circuit (part 2 of 2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps for the second part of the build. The step numbers
    match the numbered black circles in *Figure 7.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect a GND pin from your Raspberry Pi into the negative rail of the right-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative rails of the right-hand side and left-hand side power rails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the 100kΩ resistor into the negative power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Source leg of the MOSFET into the negative power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Drain leg of the MOSFET to the 1kΩ resistor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode leg of the LED to the cathode leg of the diode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode leg of the LED (and cathode leg of the diode) to the positive
    power rail on the right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the 1kΩ resistor to GPIO 21 on your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the positive output terminal on your power supply into the positive
    rail of the right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative output terminal on your power supply into the negative
    rail of the right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well done. That's our circuit build complete. Let's briefly discuss this circuit
    before we test it out.
  prefs: []
  type: TYPE_NORMAL
- en: Notice in* Figure 7.10 *(and *Figure 7.1*) the 100kΩ resistor R3\. This is an
    external pull-down resistor that ensures that the Gate leg of the MOSFET is tied
    to GND (0 volts) when it is not pulled up to +3.3 volts when GPIO 21 is high.
    MOSFETs have capacitive charge, so without a pull-down, the MOSFET may appear
    sticky and slow when it transitions from on (GPIO 21 is high) to off (GPIO 21
    goes low) as it discharges (note that this circuit is active high). The pull-down
    resistor ensures a rapid discharge into the off state. We use an external pull-down
    resistor in preference to an in-code activated pull-down to ensures the MOSFET
    Gate is pulled down even when the Raspberry Pi is powered off or when code has
    not run.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that R1 and R3 create a voltage divider. The ratio of 1kΩ
    and 100kΩ is suitable to ensure that >3 volts get to the gate leg of the MOSFET
    to switch it on. If you need a refresher on pull-down resistors and voltage dividers,
    we discussed them in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer.*
  prefs: []
  type: TYPE_NORMAL
- en: When adding resistors into a circuit—like adding in a pull-down—always consider
    with the wider impact of the change. If, for example, the addition creates a voltage
    divider due to the presence of an existing resistor, you then need to access the
    impact of the change on the surrounding circuit. For our scenario, this is to
    ensure enough voltage is reaching the MOSFET gate leg to turn it on.
  prefs: []
  type: TYPE_NORMAL
- en: After running the code in the next section, try removing R3 and run the code
    again. I can't guarantee that you will see anything at your end, but you may observe that
    the red LED fizzles out slowly rather than turning off promptly when GPIO 21 goes
    low and that it behaves erratically instead of fading in and out smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: As with the optocoupler example, you can connect the wire's external power supply
    to your Raspberry Pi's +5 pin and a GND pin for this LED example since its current
    requirements are low.
  prefs: []
  type: TYPE_NORMAL
- en: With this basic understanding of a MOSFET circuit, let's run and explore a simple
    Python program that interacts with our circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the MOSFET with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the code in the `chapter07/transistor_test.py` file, and the red LED will
    turn on then off, then fade in and out. Once you have confirmed that your circuit
    works, let''s continue and look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are using PWM in this example. In line (1), we are telling PiGPIO that, for
    GPIO 21 (`GPIO_PIN = 21`), we want its duty cycle to be constrained to the value
    range 0 to 100 (rather than the default 0 to 255). This is an example of how we
    can change the granularity of duty cycle values in PiGPIO. We're using 0 to 100
    just to make reporting easier because it maps into 0% to 100% for terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in line (2), we simply turn the GPIO on and off for a duration to test
    the transistor circuit, and we will see the LED turn on then off after a 2-second
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line (3) in the following code, we use PWM to fade in the LED, before fading
    it out again at line (4), both times using the duty cycle range set at line (1)
    in the preceding code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check whether our relay and motor are safe to use with this transistor
    circuit, given our 2N7000 is rated for 200 milliamps:'
  prefs: []
  type: TYPE_NORMAL
- en: The relay can be used in place of the LED because it only needs between 70mA
    and 90mA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The motor requires ~200mA to spin freely *(continuous* current), so it might
    be safe...or not? Let's see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we tested the motor earlier in this chapter, we anticipated it will need
    between ~200mA (the *continuous* current when cold) and ~500mA to ~600mA (the
    *stall* current)—*remember these are my measurements, so replace the values with
    your measurements*. So, in principle, our 2N7000 will be OK as long as the motor
    is not under load. Realistically, as soon as we place a load on the motor's shaft,
    it will require more than 200mA continuous current. In this respect, the 2N7000
    is probably not an ideal transistor for driving this motor. We need to seek out
    a MOSFET that can comfortably handle 600mA of continuous current or more. We'll
    see the FQP30N06L MOSFET shortly, which can handle this current and much more.
  prefs: []
  type: TYPE_NORMAL
- en: While the LED faded in and out with the PWM-related code, if you connect the
    motor into the circuit in place of the LED/resistor pair, you will notice it revs
    up then down. You've just discovered how to use the duty cycle property of PWM
    to control the speed of a motor! We will be covering motors in more detail in [Chapter 10](https://cdp.packtpub.com/hands_on_python_programming_for_iot/wp-admin/post.php?post=37&action=edit#post_34),
    *Movement with Servos, Motors, and Steppers*.
  prefs: []
  type: TYPE_NORMAL
- en: To use the motor or relay, you must use an external power supply and not the
    +5-volt pin on your Raspberry Pi. If you try and use the +5-volt pin, you may
    find your Raspberry Pi resets as you run the code.
  prefs: []
  type: TYPE_NORMAL
- en: We do not use PWM with relays because they're too slow to switch and if they
    do work (at a very low PWM frequency), it's only wearing them out—but try it anyway
    to see what happens; a short test will do no harm (try adjusting the frequency
    of 8000 in code down to 10, that is, `pi.set_PWM_frequency(GPIO_PIN, 10)`).
  prefs: []
  type: TYPE_NORMAL
- en: In our circuit, there is also the 1N4001 diode D1\. This is known as a fly-back
    or suppression diode. Its role is to protect the circuit from reverse voltage
    spikes that can occur in electromagnetic components such as a relay or motor when
    they are powered down. Granted, our LED is not magnetic, however, it does not
    do any harm having the diode present.
  prefs: []
  type: TYPE_NORMAL
- en: Anytime you are controlling a component that works on electromagnetism (also
    known as an inductive load), always correctly install a fly-back suppression diode.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 7.8*, we also have an illustration of an FQP30N06L. This is a Power
    N-Channel Enhancement Mode MOSFET capable of driving high amperage loads. It has
    the following specifications in its datasheet:'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum **Drain Source Voltage (V[DSS])** of 60 volts DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum **Continuous Drain Current (I[D])** of 32A DC (amps not milliamps!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum **Pulsed** **Drain Current (I[DM])** of 128A DC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gate Threshold Voltage (V[GS(th)])** in the range of 1 to 2.5 volts DC (<
    5 volts so it''s logic-level compatible)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drain−Source On−Voltage (V[SD])** maximum of 1.5 volts DC'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can substitute an FQP30N06L (or another N-Channel Enhancement mode logic-level
    capable MOSFET) in the preceding circuit and it will work, but keep the following
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The G, D, and S legs of the FQP30N06L are in a different order to the 2N7000
    so you will need to adjust the wiring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with higher voltages and currents, it's a good idea to electrically
    isolate the MOSFET from the Raspberry Pi using an optocoupler (we'll see this
    configuration when we discuss relays next).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At high currents, Power MOSFETs can get very hot—the surrounding components
    and wires and even the breadboard can melt, so approach their use with caution
    and care.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher power MOSFETs can get hot when controlling high power loads and can be
    fitted with a heatsink, for example, the FQP30N06L has a metal top with a hole
    where the heatsink is attached. The determining factors and calculations as to
    when a headsink is required are beyond our scope, however, if your MOSFET is getting
    too hot (and you are using it within its datasheet parameters), then add a heatsink.
  prefs: []
  type: TYPE_NORMAL
- en: If you like the idea of controlling higher current loads using MOSFETs, you
    might like to research ready-made MOSFET modules on sites such as eBay. You now
    have the background after learning about optocouplers and MOSFETs to understand
    how these modules are constructed—some just use a MOSFET directly connected to
    the controlling device (that is, GPIO pin) as we have just done while others place
    an optocoupler in between the controlling device and the MOSFET.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned the basics of using a MOSFET transistor as a digital switch.
    Next, we will put that learning together with our learning on optocouplers to
    build our relay driver circuit on a breadboard.
  prefs: []
  type: TYPE_NORMAL
- en: Using a relay as a switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classic relays are an electro-mechanical component that allows a smaller current
    device to switch a higher current device or load on and off. In principle, they
    are just like the MOSFET or optocoupler we used previously. So, why have relays?
    Here are a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: For high voltage and current loads, they tend to be much cheaper compared to
    an equivalent MOSFET.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At high currents, they do not get untouchably hot like a MOSFET.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to an optocoupler, relays also provide electrical isolation between
    the input and output circuits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are simply electrically controlled switches so they are easy to understand
    and use for non-electrical engineers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They have stood the test of time and proven to be a simple and robust way to
    control high loads (even though they eventually will wear out—the SRD-05VDC-SL-C
    datasheet lists its rated life expectancy to be 100,000 operations).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a type of relay known as a **Solid State Relay** (**SSR**) that
    has no moving parts, however, they are typically more expensive than a comparable
    mechanical relay.
  prefs: []
  type: TYPE_NORMAL
- en: Our first task is to create our circuit, which we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Building the relay driver circuit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s build our relay driver circuit. We will do this in three parts, starting
    with the placements of the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/814252c9-a725-4bbe-b868-5afa0feb6307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Relay driver circuit (part 1 of 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps for the first part of the build. The step numbers match
    the numbered black circles in *Figure 7.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the PC817 into your breadboard, taking care that pin 1 of the IC is connected
    to the left-hand breadboard bank as illustrated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor into your breadboard. One end of the resistor connects
    to pin 1 of the PC817.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the MOSFET into your breadboard, taking care to orientate the component
    the correct way around regarding the Source, Gate, and Drain legs. Our example
    layout assumes a 2N7000 MOSFET. Please see *Figure 7.8 *if you need help to identify
    the legs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 1kΩ resistor into your breadboard. One end of this resistor connects
    the Gate leg of the MOSFET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a 100kΩ resistor into your breadboard. One end of this resistor also connects
    the Gate leg of the MOSFET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the diode into your breadboard, taking care to orientate the component
    as illustrated with the cathode leg (the end of the component with the band) pointing
    toward the bottom of the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you have placed the individual components, next, we will wire up the
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c7e47a62-1634-47f0-af11-1245d959e552.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Relay driver circuit (part 2 of 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps for the second part of the build. The step numbers
    match the numbered black circles in *Figure 7.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the resistor you placed at the previous *step 2* to a 3.3-volt pin on
    your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin 2 of the PC817 to GPIO 21 on your Raspberry Pi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin 4 of the PC817 to the positive rail of the right-hand side power
    rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Source leg of the MOSFET into the negative rail of the right-hand
    side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the 100kΩ resistor that connects into the Drain leg of the MOSFET to
    the negative rail of the right-hand side power rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect pin 4 of the PC817 to the cathode leg of the diode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Drain leg of the MOSFET to the anode leg of the diode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we will connect the power supplies and relay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/408611d1-d641-4d3f-a788-a1252a0bbb0e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Relay driver circuit (part 3 of 3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps for the third and last part of the build. The step
    numbers match the numbered black circles in *Figure 7.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect the positive rail of the right-hand side power rail to the positive
    output terminal of a 5-volt power supply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative rail of the right-hand side power rail to the negative
    output terminal of a 5-volt power supply.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the anode leg of the diode to one of the relay's coil terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the cathode leg of the diode to the relay's other coil terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the negative output of a *different* 5-volt power supply to the com
    terminal on your relay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At *step 5*, you must use two different external power sources for this circuit
    because the current requirements of the relay coil and potential relay load will
    very likely be too much to borrow (rob) from your Raspberry Pi's power supply.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the positive output terminal of the *different* 5-volt power supply
    to the positive input terminal of your load (for example, one of the terminals
    on a motor).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the **NO** (**Normally Open**) terminal of the relay to the
    negative input terminal of your load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the NO terminal on the relay means the load will be off by default and
    only powered when the relay is engaged, which happens when GPIO 21 is low (remembering
    this circuit is *active-low*). If you connect your load to the **NC** (**Normally
    Closed**) terminal in the relay, the load will be powered by default, including
    when your Raspberry Pi is switched off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well done! Your completed breadboard circuit, as illustrated in *Figure 7.13**.*
    This is the breadboard build that matches the schematic diagram shown at the commencement
    of this chapter in *Figure 7.1*. This breadboard circuit is shown with a 5-volt
    *relay coil power* sourc*e* and a 5-volt *load power* source. This circuit, however,
    can be used with different power supplies subject to the following pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: The choice of resistors and the 2N7000 MOSFET used in this circuit is capable
    of driving a 12-volt relay like an SRD-12VDC-SL-C. You'll just need to make sure
    the *relay coil power* source is 12 volts rather than 5 volts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The load power source is illustrated as 5 volts, however, if your load requires
    more voltage (that's within the relay's specifications), it can be increased.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a finished circuit, let's run a Python program to control the
    relay.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Relay Driver Circuit with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the following code, which is in the `chapter07/optocoupler_test.py` file.
    The relay should activate with a click sound, and deactivate after 2 seconds.
    This is the same code we used when we created and tested our optocoupler circuit
    since it's the optocoupler that our Raspberry Pi is connected to.
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier when we learned about MOSFETs that we could connect the MOSFET
    directly to a GPIO pin and control the relay, without needing an optoisolator.
    So, why does the preceding circuit have one?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that our circuit does not technically need one, and there are
    ready-made relay modules to be found (though rarer) that do not have an optoisolator.
    However, there is no harm in having one present since it does provide a level
    of electrical isolation protection just in case the relay control circuit fails
    or there is a mishap when wiring up the power supply.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, what about relay modules you can find on sites such as eBay that have
    more than one relay? There is just a single relay circuit replicated multiple
    times—you will typically be able to count a transistor and optocoupler pair for
    each relay (although optocouplers and transistors can come in chip form, that
    is, multiple optocouplers or optocouplers in a single package, so on some modules
    you may just see the chips instead). Also, note that some modules will use a BJT
    rather than a MOSFET. If you can read the part numbers on the components, you
    can always perform a web search to determine what they are.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude our exploration of turning things on and off, here is a table comparing
    the switching components we used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Optocoupler** | **MOSFET** | **Relay** |'
  prefs: []
  type: TYPE_TB
- en: '| **Construction** | Solid state | Solid state | Mechanical |'
  prefs: []
  type: TYPE_TB
- en: '| **Current** | AC or DC (depending on optocoupler)  | DC only (start your
    research with TRIACS for AC) | AC and DC |'
  prefs: []
  type: TYPE_TB
- en: '| **Cost** | $ - $$ | $ (low capacity) to $$$ (high capacity) | $ |'
  prefs: []
  type: TYPE_TB
- en: '| **Gets Really Hot (Can''t touch)** | No | Yes for high current power MOSFETs
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| **Control Voltage / Current** | Low (need to turn off and on the internal
    LED) | Low (need to apply voltage to the Gate) | High (need to energize the relay
    coil) |'
  prefs: []
  type: TYPE_TB
- en: '| **Load Voltage / Current** | Low (for example, PC817 max 50mA) | Low (for
    example, 2N27000 at 200mA); High (for example, FQP30N06L at 32A) | High (for example, SRD-05VDC-SL-C 10A)
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Electrical Isolation** | Yes | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **Example application** | Provides electrical isolation between a controlling
    circuit and the circuit to be controlled | Allows a low current/voltage circuit
    to control a higher voltage/current circuit | Allows a low current/voltage circuit
    to control a higher voltage/current circuit |'
  prefs: []
  type: TYPE_TB
- en: '| **Longevity** | Long life | Long life  | Short life (moving parts will wear
    out eventually) |'
  prefs: []
  type: TYPE_TB
- en: '| **Use PWM** | Yes | Yes | No—a relay will not switch fast enough, plus you''ll
    only wear out the relay faster! |'
  prefs: []
  type: TYPE_TB
- en: Well done on completing this chapter! You now understand multiple ways to control
    loads that have voltage and current requirements beyond the 3.3 volt/8mA limits
    of your Raspberry Pi's GPIO pins.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to switch things on and off. We commenced by
    briefly reviewing a typical relay driver circuit, before learning how to measure
    the current requirements of a DC motor, LED, and relay using a multimeter. Next,
    we discussed the properties of an optocoupler and learned at low to use it as
    a digital switch. Then, we discussed MOSFETs and discovered how to use them as
    a switch and for motor speed control using PWM.
  prefs: []
  type: TYPE_NORMAL
- en: The information, circuits, and exercises you have learned in this chapter will
    help you to make informed decisions and make the necessary calculations and measurements
    to select suitable components and create circuits that can be used to switch devices on
    and off and other loads that demand more current and higher voltages that can
    be sourced safely from a Raspberry Pi pin.
  prefs: []
  type: TYPE_NORMAL
- en: Our approach to this chapter was to incrementally explore and build a relay
    driver circuit, which provides you with a practical example of how and why switching
    components are chained together to control higher power components and/or loads.
    Also, we learned that optocouplers can be used to electrically isolate circuits,
    which can be a useful and practical technique to help us to isolate and protect
    our Raspberry Pi from accidental damage should a circuit fail or be wired incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we turn our attention to different types of LEDs, buzzers,
    and visual components we can use to signal or display information to users.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to controlling a transistor, how do MOSFET and BJT differ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are controlling a motor using a MOSFET, however, you switch off the MOSFET
    (for example, making the GPIO pin low), but the motor does not turn off promptly
    but instead spins down. Why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have selected a random MOSFET that you want to control from a Raspberry
    Pi 3.3-volt GPIO but it does not work. What is some possible cause of the problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other than switching, what common feature do optocouplers and relays share that
    transistors do not?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between an active low and active high GPIO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we prefer a physical pull-down resistor for the MOSFET's Gate leg over
    an in-code activated pull-down?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a DC motor, what does the stall current represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a DC motor, what is the difference between continuous and free current?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following tutorial is a thorough introduction to transistors, their various
    types, and applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.electronics-tutorials.ws/category/transistor](https://www.electronics-tutorials.ws/category/transistor)
    (start with the MOSFET sections)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
