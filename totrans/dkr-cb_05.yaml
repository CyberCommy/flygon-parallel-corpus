- en: Chapter 5. Docker Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing CI/CD with Shippable and Red Hat OpenShift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing CI/CD with Drone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up PaaS with OpenShift Origin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and deploying an app on OpenShift v3 from the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Docker as a hypervisor driver for Openstack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know how to work with containers and images. In the last chapter, we
    also saw how to link containers and share data between the host and other containers.
    We also saw how containers from one host can communicate with other containers
    from other hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at different use cases of Docker. Let''s list a few of them
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick prototyping of ideas**: This is one of my favorite use cases. Once
    we have an idea, it is very easy to prototype it with Docker. All we have to do
    is set up containers to provide all the backend services we need and connect them
    together. For example, to set up a LAMP application, get the web and DB servers
    and link them, as we saw in the previous chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration and distribution**: GitHub is one of the best examples of collaborating
    and distributing the code. Similarly, Docker provides features such as Dockerfile,
    registry, and import/export to share and collaborate with others. We have covered
    all this in earlier chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**): The following definition on Martin Fowler''s
    website ([http://www.martinfowler.com/articles/continuousIntegration.html](http://www.martinfowler.com/articles/continuousIntegration.html))
    covers it all:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"Continuous Integration is a software development practice where members of
    a team integrate their work frequently, usually each person integrates at least
    daily - leading to multiple integrations per day. Each integration is verified
    by an automated build (including test) to detect integration errors as quickly
    as possible. Many teams find that this approach leads to significantly reduced
    integration problems and allows a team to develop cohesive software more rapidly.
    This article is a quick overview of Continuous Integration summarizing the technique
    and its current usage."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Using recipes from other chapters, we can build an environment for CI using
    Docker. You can create your own CI environment or get services from companies
    such as Shippable and Drone. We''ll see how Shippable and Drone can be used for
    CI work later in this chapter. Shippable is not a hosted solution but Drone is,
    which can give you better control. I thought it would be helpful if I talk about
    both of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Delivery** (**CD**): The next step after CI is Continuous Delivery,
    through which we can deploy our code rapidly and reliably to our customers, the
    cloud and other environments without any manual work. In this chapter, we''ll
    see how we can automatically deploy an app on Red Hat OpenShift through Shippable
    CI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform-as-a-Service** (**PaaS**): Docker can be used to build your own
    PaaS. It can be deployed using tools/platforms such as OpenShift, CoreOS, Atomic,
    Tsuru, and so on. Later in this chapter, we''ll see how to set up PaaS using OpenShift
    Origin ([https://www.openshift.com/products/origin](https://www.openshift.com/products/origin)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While doing the development or QA, it will be helpful if we can check our code
    against different environments. For example, we may wish to check our Python code
    between different versions of Python or on different distributions such as Fedora,
    Ubuntu, CentOS, and so on. For this recipe, we will pick up sample code from Flask's
    GitHub repository, which is a microframework for Python ([http://flask.pocoo.org/](http://flask.pocoo.org/)).
    I chose this to keep things simple, and it is easier to use for other recipes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will create images to have one container with Python 2.7
    and other with Python 3.3\. We'll then use a sample Python test code to run against
    each container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we are going to use example code from Flask''s GitHub repository, let''s
    clone it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Dockerfile_2.7` file as follows and then build an image from it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the `python2.7test` image, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, create a Dockerfile with `python:3.3` as the base image and build
    the `python3.3test` image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the image, run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Make sure both the images are created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](../Images/image00347.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, using Docker''s volume feature, we will mount the external directory that
    contains the source code and test cases. To test with Python 2.7, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the directory that contains the Flask examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Start a container with the `python2.7` test image and mount `blueprintexample`
    under `/test`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00348.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, to test with Python 3.3, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While running the preceding test on Fedora/RHEL/CentOS where SELinux is enabled,
    you will get a `Permission denied` error. To fix it, relabel the host directory
    while mounting it within the container as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details on SELinux, please look at [Chapter 9](part0092.xhtml#aid-2NNJO2
    "Chapter 9. Docker Security"), *Docker Security*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see from the Dockerfile, before running CMD, which runs the `py.test`
    binary, we change our working directory to `/test`. And while starting the container,
    we mount our source code to `/test`. So, as soon as the container starts, it will
    run the `py.test` binary and run tests.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have seen how to test our code with different versions of
    Python. Similarly, you can pick up different base images from Fedora, CentOS,
    Ubuntu and test them on different Linux distributions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use Jenkins in your environment, then you can use its Docker plugin to
    dynamically provision a slave, run a build, and tear it down on the Docker host.
    More details about this can be found at [https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing CI/CD with Shippable and Red Hat OpenShift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we saw an example of how Docker can be used for testing
    in a local Dev and QA environment. Let's look at an end-to-end example to see
    how Docker is now used in the CI/CD environment. In this recipe, we'll see how
    we can use Shippable ([http://www.shippable.com/](http://www.shippable.com/))
    to perform CI/CD and deploy it on Red Hat's OpenShift environment ([https://openshift.redhat.com](https://openshift.redhat.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Shippable is a SaaS platform that lets you easily add Continuous Integration/Deployment
    to your GitHub and Bitbucket(Git) repositories, which is completely built on Docker.
    Shippable uses build minions, which are Docker-based containers, to run workloads.
    Shippable supports many languages such as Ruby, Python, Node.js, Java, Scala,
    PHP, Go, and Clojure. The default build minions are of Ubuntu 12.04 LTS and Ubuntu
    14.04\. They have also added support to use custom images from Docker Hub as minions.
    Shippable CI needs information about the project and build instructions in a `yml`
    file called `shippable.yml`, which you have to provide in your source code repo.
    The `yml` file contains the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build_image`: This is a Docker image to use to build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`language`: This will show the programming language'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`versions`: You can specify different versions of the language to get tested
    in a single build instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before_install`: These are the instructions before running the build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`script`: This is a binary/script to run the test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`after_success`: These are instructions after the build succeeds; this is used
    to perform deployment on PaaS such as Heroku, Amazon Elastic Beanstalk, AWS OpsWorks,
    Google App Engine, Red Hat OpenShift, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red Hat's OpenShift is a PaaS platform to host your application. Currently,
    it uses non-Docker based container technology to host the application, but the
    next version of OpenShift ([https://github.com/openshift/origin](https://github.com/openshift/origin))
    is being built on Kubernetes and Docker. This tells us the pace at which Docker
    is being adopted in the enterprise world. We'll see how to set up OpenShift v3
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will use the same example code we used in the previous recipe,
    to first test on Shippable and then deploy it on OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an account on Shippable ([https://www.shippable.com/](https://www.shippable.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fork the flask example from [https://github.com/openshift/flask-example](https://github.com/openshift/flask-example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an app on OpenShift for the forked repository with the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an account ([https://www.openshift.com/app/account/new](https://www.openshift.com/app/account/new))
    on OpenShift and log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Python 2.7 Cartridge** for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the **Public URL** section you want. In the **Source Code** section,
    provide the URL of our forked repo. For this example, I have put down `blueprint`
    and `https://github.com/nkhare/flask-example` respectively:![Getting ready](../Images/image00349.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Create Application** to create the new app. Once created, you should
    be able to access the Public URL we mentioned in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the app is created, OpenShift provides a way to manage/update the source
    code for this app in the `Making code changes` section. As we want to deploy the
    app using Shippable, we don't have to follow those instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the forked repository on the local system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the same blueprint example that we used earlier. To do so, follow
    these instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the flask repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the blueprint example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `flask-example/wsgi/application` file to import the `app` module
    from the `blueprintexample` module. So, the last line in the `flask-example/wsgi/application`
    file looks like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `requirements.txt` file with the following contents at the top level
    of the flask-example repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `shippable.yml` file with following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Commit the code and push it in your forked repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log in to Shippable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After logging in, click on **SYNC ACCOUNT** to get your forked repository listed,
    if it has not already been listed. Find and enable the repo that you want to build
    and run tests. For this example, I chose `flask-example` from my GitHub repos.
    After enabling it, you should see something like the following:![How to do it…](../Images/image00350.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the play button and select branch to build. For this recipe, I chose
    master:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the build is successful, then you will see the success icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next time you do a commit in your repository, a build on Shippable will be
    triggered and the code will be tested. Now, to perform Continuous Deployment on
    OpenShift, let''s follow the instructions provided on the Shippable website ([http://docs.shippable.com/deployment/openshift/](http://docs.shippable.com/deployment/openshift/)):'
  prefs: []
  type: TYPE_NORMAL
- en: Get the deployment key from your Shippable dashboard (located on the right-hand
    side, below **Repos**):![How to do it…](../Images/image00351.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy it under the ([https://openshift.redhat.com/app/console/settings](https://openshift.redhat.com/app/console/settings))
    **Settings** | **Public** **Keys** section on OpenShift as follows:![How to do
    it…](../Images/image00352.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the **Source Code** repository link from the OpenShift application page,
    which will be used as `OPNESHIFT_REPO` in the next step:![How to do it…](../Images/image00353.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the deployment key is installed, update the `shippable.yml` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`OPENSHIFT_REPO` should reflect the app you have deployed using OpenShift.
    It will be different from what is shown in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: Now commit these changes and push it to GitHub. You will see a build on Shippable
    triggered and a new app deployed on OpenShift.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit your app's homepage, and you should see its updated contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At every build instruction, Shippable spins off new containers depending on
    the image and language type specified in the `shippable.yml` file and runs the
    build to perform testing. In our case, Shippable will spin off two containers,
    one for Python 2.6 and the other for Python 2.7\. Shippable adds a webhook to
    your GitHub repository as follows when you register it with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](../Images/image00354.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So every time a change is committed to GitHub, a build on Shippable gets triggered
    and after the success, it is deployed on OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Detailed documentation is available on the Shippable website at [http://docs.shippable.com/](http://docs.shippable.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing CI/CD with Drone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned on the Drone website ([https://drone.io/](https://drone.io/)),
    Drone is a hosted Continuous Integration service. It enables you to conveniently
    set up projects to automatically build, test, and deploy as you make changes to
    your code. They provide an open source version of their platform, which you can
    host in your environment or on cloud. As of now, they support languages such as
    C/C++, Dart, Go, Haskell, Groovy, Java, Node.js, PHP, Python, Ruby, and Scala.
    Using Drone, you can deploy your application on platforms such as Heroku, Dotcloud,
    Google App Engine, and S3\. You can also SSH (rsync) your code to a remote server
    for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, let's use the same example that we used in the earlier recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log in to Drone ([https://drone.io/](https://drone.io/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **New Project** and set up repository. In our case, we'll pick the
    same repository from GitHub that we used in the previous recipe ([https://github.com/nkhare/flask-example](https://github.com/nkhare/flask-example)):![Getting
    ready](../Images/image00355.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once selected, it will ask you to select the programming language for the selected
    repository. I selected Python in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will then prompt you to set up the build script. For this recipe, we''ll
    put the following and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Trigger a manual build by clicking on **Build Now**, as shown in the following
    screenshot:![How to do it…](../Images/image00356.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The build process starts a new container, clones the source code repository,
    and runs the commands that we specified in the **Commands** section (running the
    test cases) within it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the build is complete, you can look at the console output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drone also adds a webhook in GitHub; so the next time you commit changes in
    the repository, a build will be triggered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drone also supports Continuous Deployment to different cloud environments, as
    we have seen in the earlier recipe. To set that up, go to the **Settings** tab,
    select **Deployment**, and then select **Add New Deployment**. Select your cloud
    provider and set it up:![There's more…](../Images/image00357.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Drone documentation at [http://docs.drone.io/](http://docs.drone.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The steps to configure a self-hosted Drone environment, which is in the alpha
    stage as of now, at [https://github.com/drone/drone](https://github.com/drone/drone)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up PaaS with OpenShift Origin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Platform-as-a-Service is a type of cloud service where the consumer controls
    the software deployments and configuration settings for applications (mostly web),
    and the provider provides servers, networks, and other services to manage those
    deployments. The provider can be external (a public provider) or internal (an
    IT department in an organization). There are many PaaS providers, such as Amazon
    ([http://aws.amazon.com/](http://aws.amazon.com/)), Heroku ([https://www.heroku.com/](https://www.heroku.com/)),
    OpenShift ([https://www.openshift.com/](https://www.openshift.com/)), and so on.
    In the recent past, containers seem to have become the natural choice for applications
    to get deployed to.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we looked at how we can build a CI/CD solution using
    Shippable and OpenShift, where we deployed our app to OpenShift PaaS. We deployed
    our app on Openshift Online, which is the Public Cloud Service. At the time of
    writing this book, the OpenShift Public Cloud Service uses non-Docker container
    technology to deploy apps to the Public Cloud Service. The OpenShift team has
    been working on OpenShift v3 ([https://github.com/openshift/origin](https://github.com/openshift/origin)),
    which is a PaaS that leverages technologies such as Docker and Kubernetes ([http://kubernetes.io](http://kubernetes.io))
    among others, providing a complete ecosystem to service your cloud-enabled apps.
    They plan to move this to the Public Cloud Service later this year. As we have
    talked about Kubernetes in [Chapter 8](part0081.xhtml#aid-2D7TI1 "Chapter 8. Docker
    Orchestration and Hosting Platforms"), *Docker Orchestration and Hosting Platforms*,
    it is highly recommended to read that chapter first before continuing with this
    recipe. I am going to borrow some of the concepts from that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up PaaS with OpenShift Origin](../Images/image00358.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[https://blog.openshift.com/openshift-v3-deep-dive-docker-kubernetes/](https://blog.openshift.com/openshift-v3-deep-dive-docker-kubernetes/)'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides container cluster management with features such as scheduling
    pods and service discovery, but it does not have the concept of complete application,
    as well as the capabilities to build and deploy Docker images from the source
    code. OpenShift v3 extends the base Kubernetes model and fills those gaps. If
    we fast-forward and look at [Chapter 8](part0081.xhtml#aid-2D7TI1 "Chapter 8. Docker
    Orchestration and Hosting Platforms"), *Docker Orchestration and Hosting Platforms*,
    for the Kubernetes section, you will notice that to deploy an app, we need to
    define Pods, Services, and Replication-Controllers. OpenShift v3 tries to abstract
    all that information and let you define one configuration file that takes care
    of all the internal wiring. Furthermore, OpenShift v3 provides other features
    such as automated deployment through source code push, the centralized administration
    and management of an application, authentication, team and project isolation,
    and resource tracking and limiting, all of which are required for enterprise deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will set up all-in-one OpenShift v3 Origin on a VM and start
    a pod. In the next recipe, we will see how to build and deploy an app through
    source code using the **Source-to-image** (**STI**) build feature. As there is
    active development happening on OpenShift v3 Origin, I have selected a tag from
    the source code and used that code-base in this recipe and the next one. In the
    newer version, the command-line options may change. With this information in hand,
    you should be able to adapt to the latest release. The latest example can be found
    at [https://github.com/openshift/origin/tree/master/examples/hello-openshift](https://github.com/openshift/origin/tree/master/examples/hello-openshift).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set up Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/)) and
    install the VirtualBox provider ([https://www.virtualbox.org/](https://www.virtualbox.org/)).
    The instructions on how to set these up are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the OpenShift Origin repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the `v0.4.3` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the VM:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Build the OpenShift binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the `hello-openshift` examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Start all the OpenShift services in one daemon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: OpenShift services are secured by TLS. Our client will need to accept the server
    certificates and present its own client certificate. Those are generated as part
    of Openshift start in the current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the pod from the `hello-pod.json` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00359.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect to the pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When OpenShift starts, all Kubernetes services start as well. Then, we connect
    to the OpenShift master through CLI and request it to start a pod. That request
    is then forwarded to Kubernetes, which starts the pod. In the pod configuration
    file, we mentioned to map port `6061` of the host machine with port `8080` of
    the pod. So, when we queried the host on port `6061`, we got a reply from the
    pod.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you run the `docker ps` command, you will see the corresponding containers
    running.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Learn More* section on [https://github.com/openshift/origin](https://github.com/openshift/origin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenShift 3 beta 3 Video tutorial at [https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/](https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest OpenShift training at [https://github.com/openshift/training](https://github.com/openshift/training)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenShift v3 documentation at [http://docs.openshift.org/latest/welcome/index.html](http://docs.openshift.org/latest/welcome/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and deploying an app on OpenShift v3 from the source code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OpenShift v3 provides the build process to build an image from source code.
    The following are the build strategies that one can follow to build images:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker build**: In this, users will supply to the Docker context (Dockerfiles
    and support files), which can be used to build images. OpenShift just triggers
    the `docker build` command to create the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source-to-image (STI) build**: In this, the developer defines the source
    code repository and the builder image, which defines the environment used to create
    the app. STI then uses the given source code and builder image to create a new
    image for the app. More details about STI can be found at [https://github.com/openshift/source-to-image](https://github.com/openshift/source-to-image).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom build**: This is similar to the Docker build strategy, but users might
    customize the builder image that will be used for build execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we are going to look at the STI build process. We are going
    to look at sample-app from the OpenShift v3 Origin repo ([https://github.com/openshift/origin/tree/v0.4.3/examples/sample-app](https://github.com/openshift/origin/tree/v0.4.3/examples/sample-app)).
    The corresponding STI build file is located at [https://github.com/openshift/origin/blob/v0.4.3/examples/sample-app/application-template-stibuild.json](https://github.com/openshift/origin/blob/v0.4.3/examples/sample-app/application-template-stibuild.json).
  prefs: []
  type: TYPE_NORMAL
- en: In the `BuildConfig` section, we can see that the source is pointing to a GitHub
    repo (`git://github.com/openshift/ruby-hello-world.git`) and the image under the
    `strategy` section is pointing to the `openshift/ruby-20-centos7` image. So, we
    will use the `openshift/ruby-20-centos7` image and build a new image using the
    source from the GitHub repo. The new image, after the build is pushed to the local
    or third-party Docker registry, depending on the settings. The `BuildConfig` section
    also defines triggers on when to trigger a new build, for instance, when the build
    image changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the same STI build file (`application-template-stibuild.json`), you will
    find multiple `DeploymentConfig` sections, one of each pod. A `DeploymentConfig`
    section has information such as exported ports, replicas, the environment variables
    for the pod, and other info. In simple terms, you can think of `DeploymentConfig`
    as an extended replication controller of Kubernetes. It also has triggers to trigger
    new deployment. Each time a new deployment is created, the `latestVersion` field
    of `DeploymentConfig` is incremented. A `deploymentCause` is also added to `DeploymentConfig`
    describing the change that led to the latest deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageRepository`, which was recently renamed as `ImageStream`, is a stream
    of related images. `BuildConfig` and `DeploymentConfig` watch `ImageStream` to
    look for image changes and react accordingly, based on their respective triggers.'
  prefs: []
  type: TYPE_NORMAL
- en: The other sections that you will find in the STI build file are services for
    pods (database and frontend), a route for the frontend service through which the
    app can be accessed, and a template. A template describes a set of resources intended
    to be used together that can be customized and processed to produce a configuration.
    Each template can define a list of parameters that can be modified for consumption
    by containers.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to STI build, there are examples of Docker and custom build in the same
    sample-app example folder. I am assuming you have the earlier recipe, so we will
    continue from there.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should have completed the earlier recipe, *Setting up PaaS with OpenShift
    Origin*.
  prefs: []
  type: TYPE_NORMAL
- en: Your current working directory should be `/data/src/github.com/openshift/origin
    /examples/hello-openshift` inside the VM, started by Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deploy a private Docker registry to host images created by the STI build process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the registry has started (this can take a few minutes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00360.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new project in OpenShift. This creates a namespace `test` to contain
    the builds and an app that we will generate later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in with the `test-admin` user and switch to the `test` project, which will
    be used by every command from now on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Submit the application template for processing (generating shared parameters
    requested in the template) and then request the creation of the processed template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not trigger the build. To start the build of your application, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Monitor the build and wait for the status to go to `complete` (this can take
    a few minutes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the list of services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `BuildConfig` (`ruby-sample-build`) section, we specified our source
    as the `ruby-hello-world` Git repo (`git://github.com/openshift/ruby-hello-world.git`)
    and our image as `openshift/ruby-20-centos7`. So the build process takes that
    image, and with STI builder, a new image called `origin-ruby-sample` is created
    after building our source on `openshift/ruby-20-centos7`. The new image is then
    pushed to the Docker registry we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: With `DeploymentConfig`, frontend and backend pods are also deployed and linked
    to corresponding services.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding frontend service can be accessed through the service IP and corresponding
    port, but it will not be accessible from the outside world. To make it accessible,
    we give our app an FQDN; for instance, in the following example, it is defined
    as `www.example.com`:![There's more…](../Images/image00361.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenShift v3 provides an HAProxy router, which can map over FQDN to the corresponding
    pod. For more information, please visit [http://docs.openshift.org/latest/architecture/core_objects/routing.html](http://docs.openshift.org/latest/architecture/core_objects/routing.html).
    You will also require an entry in the external DNS to resolve the FQDN provided
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenShift v3 Origin is also a management GUI. To look at our deployed app on
    the GUI, bind the username `test-admin` to the view role in the default namespace
    so you can observe the progress in the web console:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, through the browser, connect to `https://<host>:8443/console` and log
    in through the `test-admin` user by giving any password. As Vagrant forwards the
    traffic of port `8443` on the host machine to the VM, you should be able to connect
    through the host on which VM is running. Then select **OpenShift 3 Sample** as
    the project and explore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](../Images/image00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the multiple node setup, your pods can be scheduled on different systems.
    OpenShift v3 connects pods though the overlay network pod running on one node
    can access another. It is called `openshift-sdn`. For more details, please visit
    [https://github.com/openshift/openshift-sdn](https://github.com/openshift/openshift-sdn).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Learn More* section at [https://github.com/openshift/origin](https://github.com/openshift/origin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenShift 3 beta 3 video tutorial at [https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/](https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest OpenShift training at [https://github.com/openshift/training](https://github.com/openshift/training)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The OpenShift v3 documentation at [http://docs.openshift.org/latest/welcome/index.html](http://docs.openshift.org/latest/welcome/index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Docker as a hypervisor driver for OpenStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am assuming that the reader has some exposure to OpenStack for this recipe,
    as covering it is outside the scope of this book. For more information on OpenStack
    and its components, please visit [http://www.openstack.org/software/](http://www.openstack.org/software/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In OpenStack, Nova supports different hypervisors for computation, such as
    KVM, XEN, VMware, HyperV, and others. We can provision VMs using these drivers.
    Using Ironic ([https://wiki.openstack.org/wiki/Ironic](https://wiki.openstack.org/wiki/Ironic)),
    you can provision bare metal as well. Nova added support for containers provisioning
    using Docker in the Havana ([https://www.openstack.org/software/havana/](https://www.openstack.org/software/havana/))
    release, but currently, it lives out of the mainline for faster dev cycle. There
    are plans to merge it in the mainline in the future. Under the hood, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Docker as a hypervisor driver for OpenStack](../Images/image00363.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '[https://wiki.openstack.org/wiki/File:Docker-under-the-hood.png](https://wiki.openstack.org/wiki/File:Docker-under-the-hood.png)'
  prefs: []
  type: TYPE_NORMAL
- en: DevStack ([http://docs.openstack.org/developer/devstack/overview.html](http://docs.openstack.org/developer/devstack/overview.html))
    is a collection of scripts to quickly create an OpenStack development environment.
    It is not a general-purpose installer, but it is a very easy way to get started
    with OpenStack. In this recipe, we'll configure DevStack's environment with Docker
    as Nova driver on Fedora21.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Docker on the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone `nova-docker` and `devstack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following step is needed until we can make use of `configure_nova_hypervisor_rootwrap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare Devstack for installation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the stack user and add it to `sudo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `docker-py` to communicate with docker through Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the prerequisite steps are completed, run the following commands to install
    Devstack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `prepare_devstack.sh` driver makes the following entries in the `localrc`
    file set the right environment to set Docker for the Nova driver:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the `stackrc` file, we can see the following changes with respect
    to Nova and Glance:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `/etc/nova/nova.conf` file changes the compute driver:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/etc/nova/rootwrap.d/docker.filters` file is updated with the following
    content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In `/etc/glance/glance-api.conf`, adds `docker` in the container/image format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `localrc`, we mentioned `cirros` as the default image, so once the setup
    is completed, we can see that the Docker image for `cirros` is downloaded:![There's
    more…](../Images/image00364.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is being imported to Glance automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](../Images/image00365.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that the container format is Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can create an instance using a `cirros` image using Horizon, or from
    the command line, and look at the container started using the Docker command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To import any image to Glance, you can do something like the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pull the required image from Docker Hub:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the image (currently only admin can import the image):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![There''s more…](../Images/image00366.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is a lack of integration with Cinder and Neutron, but things are catching
    up quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While installing, if you get the `AttributeError: ''module'' object has no
    attribute ''PY2'' error`, then run the following commands to fix it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation on OpenStack website at [https://wiki.openstack.org/wiki/Docker](https://wiki.openstack.org/wiki/Docker).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker is also one of the resource types for OpenStack Heat. Learn more about
    it at [http://docs.openstack.org/developer/heat/template_guide/contrib.html#dockerinc-resource](http://docs.openstack.org/developer/heat/template_guide/contrib.html#dockerinc-resource).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an interesting project in OpenStack called Kolla, which focuses on
    deploying OpenStack services through Docker containers. Find more about it at
    [https://github.com/stackforge/kolla/](https://github.com/stackforge/kolla/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
