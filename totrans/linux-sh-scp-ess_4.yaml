- en: Chapter 4. Modularizing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the real world, when you write code, you either maintain it forever or someone
    takes ownership of it later and makes changes into it. It is very important that
    you write a good quality shell script so that it's easier to maintain it further.
    It is also important that the shell script is bug-free in order to get the work
    done as expected. Scripts running on production systems are very critical because
    any error or wrong behavior of the script may cause minor or major damage. To
    solve such critical issues, it is important to get it fixed as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how we can write modular and reusable code so that
    maintaining and updating our shell script application can be done quickly and
    without any hassle. We will also see how easily and quickly bugs in shell scripts
    can be solved using different debugging techniques. We will see how we can provide
    our users different choices for different tasks by providing support for command
    line options in a script. The knowledge of how to provide command line completion
    in a script will even increase the ease of using the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing your scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing command line parameters to script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command completion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modularizing your scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing a shell script, there is one stage when we feel that a shell script
    file has become too big to read and manage. To avoid such a scenario in our shell
    script, it is very important to keep the script modular.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to keep the script modular and maintainable, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create functions instead of writing the same code again and again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a common set of functions and variables in a separate script and then
    source to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have already seen how to define and use a function in [Chapter 3](ch03.html
    "Chapter 3. Effective Script Writing"), *Effective Script Writing*. Here, we will
    see how to divide a bigger script into smaller shell script modules and then use
    them by sourcing. In other words, we can say creating libraries in `bash`.
  prefs: []
  type: TYPE_NORMAL
- en: Source to a script file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source is a shell built in command that reads and executes a script file in
    the current shell environment. If a script calls a source on another script file,
    all functions and variables available in that file will be loaded for use in calling
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The syntax of using the source is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`source <script filename> [arguments]`'
  prefs: []
  type: TYPE_NORMAL
- en: 'OR:'
  prefs: []
  type: TYPE_NORMAL
- en: '`. <script filename> [arguments]`'
  prefs: []
  type: TYPE_NORMAL
- en: The `script filename` can be with or without a path name. If the absolute or
    relative path is provided, it will look only into that path. Otherwise, a filename
    will be searched in the directories specified in the `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` are treated as positional parameters to the script filename.
  prefs: []
  type: TYPE_NORMAL
- en: The exit status of the `source` command will be the exit code of the last command
    executed in the script filename. If the script filename doesn't exist or there
    is no permission, then the exit status will be `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shell script library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A library provides a collection of features that can be reused by another application
    without rewriting from scratch. We can create a library in shell by putting our
    functions and variables to be reused in a shell script file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `shell_library.sh` script is an example of a shell library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `shell_library.sh` shell script contains the `is_regular_file`
    and `is_directory_file` global variables that can be used to know whether a given
    file is a regular file or directory after invoking the `file_type()`function.
    Furthermore, depending upon the type of the file, useful detailed information
    can be printed.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a shell script library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating shell libraries are of no use unless it is used in another shell script.
    We can either use a shell script library directly in shell or within another script
    file. To load a shell script library, we will use the source command or. (period
    character) followed by shell script library.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a shell library in bash
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use the `shell_library.sh` script file in shell, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'OR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling any of them will make functions and variables available for use in
    the current shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the `file_type /usr/bin` command is executed, the `file_type()`function
    with the `/usr/bin` parameter will be called. As a result, the global variable
    `is_directory_file` or `is_regular_file` will get set to `1` (`true`), depending
    upon the type of the `/usr/bin` path. Using the shell `if` condition, we test
    whether the `is_directory_file` variable is set to `1` or not. If set to `1`,
    then call the `print_directory_details()` function with `/usr/bin` as a parameter
    to print its details.
  prefs: []
  type: TYPE_NORMAL
- en: Calling shell library in another shell script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following example explains the usage of the shell library in a shell script
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after running the `shell_library_usage.sh` script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To load a shell script library, use `source` or `.` followed by `script_filename`.
  prefs: []
  type: TYPE_NORMAL
- en: Both source and `.`(period character) execute a script in the current shell.
    `./script` is not the same as `. script` because `./script` executes the script
    in a subshell, while `. script` executes in a shell from where it was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Passing command line parameters to script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen the usage of the commands such as `grep`, `head`, `ls`,
    `cat`, and many more. These commands also support passing arguments to a command
    via a command line. Some of command line arguments are input files, output files,
    and options. Arguments are provided as per output needs. For example, `ls -l filename`
    is executed to get a long listing output, while `ls -R filename` is used to display
    recursively the contents of a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Shell script also supports providing command line arguments that we can process
    further by a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command line arguments can be given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `script_file` is a shell script file to be executed, and `arg1`, `arg2`,
    `arg3`, `argN`, and so on, are command line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Reading arguments in scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command line arguments are passed to a shell script as positional parameters.
    So, `arg1` will be accessed in a script as `$1`, `arg2` as `$2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell demonstrates the usage of the command line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained after running the `command_line_arg.sh` script
    with arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows special variables that are useful to get more information
    about command line parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Special variables | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$#` | Number of the command line arguments |'
  prefs: []
  type: TYPE_TB
- en: '| `$*` | Complete set of command line arguments in a single string—that is,
    `''$1 $2 … $n''` |'
  prefs: []
  type: TYPE_TB
- en: '| `$@` | Complete set of command line arguments, but each argument is enclosed
    in separate quotes—that is, `''$1'' ''$2'' … ''$n''` |'
  prefs: []
  type: TYPE_TB
- en: '| `$0` | Name of the shell script itself |'
  prefs: []
  type: TYPE_TB
- en: '| `$1, $1, … $N` | Refers to argument1, argument2, …, argumentN, respectively
    |'
  prefs: []
  type: TYPE_TB
- en: Using `$#` in a script to check the number of command line arguments will be
    very helpful to process arguments further.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another shell script example that takes command line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained after executing the `command_line_arg2.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Shifting command line arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To shift command line arguments towards the left, the `shift` built in can
    be used. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shift N`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `N` is the number of arguments by which it can shift to the left.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose the current command line arguments are `arg1`, `arg2`,
    `arg3`, `arg4` and `arg5`. They can be accessed in a shell script as `$1`, `$2`,
    `$3`, `$4`, and `$5`, respectively; the `$#` value is `5`. When we call `shift
    3`, arguments get shifted by `3`. Now, `$1` contains `arg4` and `$2` contains
    `arg5`. Also, the `$#` value is `now 2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script demonstrates the usage of `shift`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained after running the `shift_argument.sh` script
    with the arguments `a b c d e f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Processing command line options in a script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Providing command line options make shell scripts more interactive. From the
    command line arguments, we can also parse options for further processing by a
    shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell script shows the command line usage with options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained after executing the `myprint.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Debugging your scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We write different shell scripts to perform different tasks. Have you ever encountered
    any errors while executing a shell script? The answer would be mostly yes! This
    is to be expected as it is practically impossible to always write perfect shell
    scripts, without errors or bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following shell script is a buggy script while execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained after executing `buggy_script.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'From the output, we see that the error `[: a: integer expression expected`
    occurred at line 6\. It''s not always possible to know the reason of the error
    by just looking into an error message, especially when seeing an error for the
    first time. Also, looking manually into the code and rectifying an error is difficult
    when dealing with a lengthy shell script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome all kinds of troubles while resolving an error or bug in a shell
    script, it''s preferred to debug code. Debugging ways to debug a shell script
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `echo` in an expected buggy area of a script to print the contents of
    the variables or commands to be executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging an entire script using `-x` while running a script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a section of a script using set builtin command with the `-x` and
    `+x` options inside the script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging using echo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `echo` command is very useful as it prints whatever arguments are provided
    to it. When we encounter an error while executing a script, we know the line number
    with an error message. In such a case, we can use `echo` to print what is going
    to be executed before the actual execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, `buggy_script.sh`, we got an error at line 6—that
    is `if [ a -gt $b ]`—while execution. We can use the `echo` statement to print
    what is actually going to be executed at line 6\. The following shell script adds
    `echo` in line 6, to see what will be executed finally at line 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now execute the `debugging_using_echo.sh` script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the character `a` is getting compared with `8`, while we were
    expecting the value of the variable `a`. This means that, by mistake, we forgot
    to use `$` with `a` to extract the value of the variable `a`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging an entire script using -x
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `echo` to debug is easy if the script is small, or if we know where exactly
    the problem is. Another disadvantage of using `echo` is that every time we make
    changes, we will have to open a shell script and modify the `echo` command accordingly.
    After debugging, we will have to remember to delete the extra `echo` lines added
    for the purposes of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these problems, bash provides the `-x` option that can be used while
    executing a shell script. Running a script with the `-x` option runs a script
    in the debug mode. This prints all the commands that are going to be executed
    along with the output of the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following shell script as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will run the preceding script as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives an error that the `/tmp/` directory already exists. By looking into
    the error, we can''t say why it is trying to create the `/tmp` directory. To trace
    the entire code, we can run the `debug_entire_script.sh` script with the `-x`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see that `dir2` is `/tmp/`. This means that no input is given to create
    the second directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `-v` option along with `-x` makes debugging even more verbose because
    `-v` displays input lines as it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With verbose output, it is quite clear that the dir1 and dir2 variables are
    expecting a command line argument. So, two arguments must be provided from a command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, the script works without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of passing the `-xv` options to bash from a command line, we can add
    it in the `shebang` line in the script file—that is, `#!/bin/bash -xv`.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging sections of a script using the set options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To debug a shell script, it''s not necessary to debug the entire script all
    the time. Sometimes, debugging a partial script is more useful and time-saving.
    We can achieve partial debugging in a shell script using the `set` builtin command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can use `set +x` and `set -x` inside a shell script at multiple places depending
    upon the need. When a script is executed, commands in between them are printed
    along with the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following shell script as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this script gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We get the syntax error with an expression that is most likely the third expression—that
    is, `expr $a * $b`.
  prefs: []
  type: TYPE_NORMAL
- en: To debug, we will use `set -x` before and `set +x` after `expr $a * $b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another script `partial_debugging.sh` with partial debugging is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained after executing the `partial_debugging.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that `expr $a * $b` is executed as `expr
    23 eval.sh partial_debugging.sh 6`. This means, instead of doing multiplication,
    bash is expanding the behavior of `*` as anything available in the current directory.
    So, we need to escape the behavior of the character `*` from getting expanded—that
    is, `expr $a \* $b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script `eval_modified.sh` is a modified form of the `eval.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output of running `eval_modified.sh` will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The script runs perfectly now without any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Other than what we have learned in debugging, you can also use the `bashdb`
    debugger for even better debugging of the shell script. The source code and documentation
    for `bashdb` can be found at [http://bashdb.sourceforge.net/](http://bashdb.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Command completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While working on a command line, everyone has to do a common task such as typing,
    which includes commands, its options, input/output file path, and other arguments.
    Sometimes, we write a wrong command name because of a spelling error in the command
    name. Also, typing a long file path will be very difficult to remember. For example,
    if we want to look recursively into the contents of a directory present at the
    path `/dir1/dir2/dir3/dir4/dir5/dir6`, we will have to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the path of this directory is very long and there is a high
    chance of making an error while typing the full path. Due to these issues, working
    on a command line will take a longer time than expected.
  prefs: []
  type: TYPE_NORMAL
- en: To solve all these problems, shell supports a very nice feature called command
    completion. Along with the other shell, bash also has a very good support of command
    completion.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the Linux distributions, for example, Fedora, Ubuntu, Debian, and CentOS
    have a pre-installed bash completion for core commands. If not available, it can
    be downloaded using the corresponding distribution package manager with the package
    name `bash-completion`.
  prefs: []
  type: TYPE_NORMAL
- en: Command completion in shell allows you to autocomplete the rest of the characters
    of the partially typed command, suggesting possible options associated with the
    given command. It also suggests and autocompletes the partially typed file path.
  prefs: []
  type: TYPE_NORMAL
- en: To enable autocompletion feature in bash, the *Tab* key is used. While typing
    a command, a single `TAB` autocompletes the command if the single command matches,
    and double `[TAB]` lists all the possible commands starting with a partially typed
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to see the contents of the `/usr/share/man/` directory,
    we will have to type `ls /usr/share/man/`. Using bash completion, type the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash completion will auto-complete the missing partial path and the command
    will become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Managing bash completion with complete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `complete` is a shell builtin that can be used to see the available bash
    completion specification for the available commands in a system. It is also used
    to modify, delete, and create bash completion.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the existing bash completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To know the existing bash completion, use the `complete` command with or without
    the`–p` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some of the outputs of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To see bash completion on these commands, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This lists all files/directories, including hidden files/directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This lists all files/directories, including hidden files/directories:'
  prefs: []
  type: TYPE_NORMAL
- en: $ cat [TAB][TAB]
  prefs: []
  type: TYPE_NORMAL
- en: This tries to list all the available commands in a system. Pressing *y* will
    display commands and *n* will display nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Modifying default bash completion behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also modify the existing bash completion behavior of a given command
    using the complete shell builtin command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is used to change the behavior of the `which` command
    to not display any options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command is used to change the `ls` command tab behavior to show
    only the directories list as bash completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Removing bash completion specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can remove bash completion specification for a command using the shell builtin
    `complete` with the `–r` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If no `command_name` is given as an argument to complete `-r`, all the completion
    specifications are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Writing bash completion for your own application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bash-completion package doesn't provide autocompletion feature for any external
    tools. Suppose that we want to create a tool that has multiple options and arguments.
    To add a bash-completion feature to its options, we will have to create our own
    bash completion file and source into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, package managers such as `dnf` and `apt-get` have its own bash
    completion file to support autocompletion for its options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following shell script as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To know about the supported options in `bash_completion_example.sh`, we will
    run the `--help` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: So, the supported options are `-h`, `--help`, `-v`, `--version`, `-p`, and `--print`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write bash completion, information of the following bash internal variables
    are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bash variables | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `COMP_WORDS` | An array of words that is typed on the command line |'
  prefs: []
  type: TYPE_TB
- en: '| `COMP_CWORD` | An index of the word containing the current cursor position.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `COMPREPLY` | An array that holds the completion results that get displayed
    after pressing [TAB][TAB] |'
  prefs: []
  type: TYPE_TB
- en: The `compgen` is a shell builtin command that displays the possible completions
    depending on the options. It is used in shell functions to generate possible completions.
  prefs: []
  type: TYPE_NORMAL
- en: An example of bash completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A bash-completion file for our shell script `bash_completion_example` will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As per convention, a bash-completion function name should start with an underscore
    (_) followed by the name of the application—that is, `_bash_completion_example`.
    Furthermore, we reset the bash variable `COMPREPLY` to clean up any previous left
    out data. Then, we declare and set the `cur` variable to the current word of the
    command line and the `prev` variable to the previous word in the command line.
    Another variable `opts` is declared and initialized with all the options that
    are recognized by an application; in our case, they are `-h -v -p --help --verbose
    –print`. The condition `if [[ ${cur} == -* ]]` checks whether the current word
    is equal to `-*` because our option starts with `-` followed by any other character.
    If `true`, then display all the matching options using the `compgen` shell builtin
    with the `-W` option.
  prefs: []
  type: TYPE_NORMAL
- en: Running the created bash completion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to run the created bash completion, the easiest way is to source into
    `source bash_completion_example shell script` and then run the script or command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Here, `--p[TAB]` gets auto-completed to `-–print`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should now able to write a shell script that
    can be easy to maintain and modify by others. Now, you know how to use an existing
    shell script library in your own script by using the `source` command. You also
    got familiarity with fixing errors and bugs in a shell script by making use of
    the different debugging techniques. You should also know how to write a script
    by taking command line arguments and providing bash completion features for it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to view, change, create, and delete environment
    variables in order to meet the requirement of running our applications.
  prefs: []
  type: TYPE_NORMAL
