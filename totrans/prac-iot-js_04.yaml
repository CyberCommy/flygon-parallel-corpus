- en: Smart Agriculture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to take our framework which we built in [Chapter
    2](part0032.html#UGI00-ce91715363d04669bca1c1545beb57ee), *IoTFW.js - I* and [Chapter
    3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),Â *IoTFW.js - II,* and
    start working on various use cases. We are going to start with the agricultural
    sector and build a smart weather station in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple requirement for any farmer is to have the ability to understand the
    environmental factors near and around their farm. So, we are going to build a
    prototype of a portable weather station. We are going to work on the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Agriculture and IoT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a smart weather station
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the code for Raspberry Pi 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating MQTT code in the API engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the templates for web apps, desktop apps, and mobile apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agriculture and IoT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A report by Beecham Research predicts that the world population will reach
    8 billion by 2025 and 9.6 billion by 2050, and in order to keep pace, food production
    must increase by 70% by 2050\. Here is the report: [https://www.beechamresearch.com/files/BRL%20Smart%20Farming%20Executive%20Summary.pdf](https://www.beechamresearch.com/files/BRL%20Smart%20Farming%20Executive%20Summary.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: This means that we need to find quicker and more productive ways of farming.
    Land and resources are going to get scarcer as we keep moving toward 2050\. This
    is when, given the resources, we would need to feed more mouths than ever before,
    unless a zombie apocalypse comes and all of us get eaten up by other zombies!
  prefs: []
  type: TYPE_NORMAL
- en: This is a very good opportunity for technology to provide solutions to make
    this happen. IoT has almost always been about smart homes, smart offices, and
    convenience, but it can do more than that. That is what we are going to cover
    in this chapter. We are going to build a smart weather station that a farmer can
    deploy in their farm to get real-time metrics such as temperature, humidity, soil
    moisture, and rain detection.
  prefs: []
  type: TYPE_NORMAL
- en: Other sensors can be added based on availability and need.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a smart weather station
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an idea of what we are building and why, let us get started
    with the design. The first thing we are going to do is identify the sensors needed.
    In this smart weather station, we are going to use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A temperature sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A humidity sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soil moisture sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A rain detector sensor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have picked sensors that are available off the shelf, to showcase the proof
    of concept. Most of them will work well for testing, and validating an idea, or
    as a hobby, but are not suitable for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to connect these sensors to our Raspberry Pi 3\. We are going
    to use the following models for the sensors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Temperature and humidity: [https://www.amazon.com/Gowoops-Temperature-Humidity-Digital-Raspberry/dp/B01H3J3H82/ref=sr_1_5](https://www.amazon.com/Gowoops-Temperature-Humidity-Digital-Raspberry/dp/B01H3J3H82/ref=sr_1_5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Soil moisture sensor: [https://www.amazon.com/Hygrometer-Humidity-Detection-Moisture-Arduino/dp/B01FDGUHBM/ref=sr_1_4](https://www.amazon.com/Hygrometer-Humidity-Detection-Moisture-Arduino/dp/B01FDGUHBM/ref=sr_1_4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rain detector sensor: [https://www.amazon.com/Uxcell-a13082300ux1431-Rainwater-Detection-3-3V-5V/dp/B00GN7O7JE](https://www.amazon.com/Uxcell-a13082300ux1431-Rainwater-Detection-3-3V-5V/dp/B00GN7O7JE)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can buy these sensors elsewhere as well.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in [Chapter 3](https://cdp.packtpub.com/b07286advancediotwithjavascripteas/wp-admin/post.php?post=266&action=edit#post_235),
    *IoTFW.js - II*, the temperature and humidity sensor is a digital sensor, and
    we are going to use the `node-dht-sensor` module to read the temperature and humidity
    values. The soil moisture sensor is an analog sensor, and Raspberry Pi 3 does
    not have any analog pins. For this, we are going to use a 12-bit A/D IC from Microchip
    named MCP3208, to convert the analog output from the sensor and feed it to Raspberry
    Pi over the SPI protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia defines the SPI protocol in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Serial Peripheral Interface** (**SPI**) bus is a synchronous serial communication
    interface specification used for short distance communication, primarily in embedded
    systems. The interface was developed by Motorola in the late 1980s and has become
    a de facto standard.For more information on SPI, refer to: [https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus](https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus).'
  prefs: []
  type: TYPE_NORMAL
- en: The rain detector sensor can be read as both analog and digital. We are going
    to use the analog output to detect the level of rain, and not just whether it
    is raining or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to MCP3208, it is a 16-pin package that can read eight analog inputs
    at once and can convert them and feed to Raspberry Pi over the SPI protocol. You
    can read more about MCP3208 IC here: [`http://ww1.microchip.com/downloads/en/DeviceDoc/21298c.pdf`](http://ww1.microchip.com/downloads/en/DeviceDoc/21298c.pdf).
    You can purchase it from here: [https://www.amazon.com/Adafruit-MCP3008-8-Channel-Interface-Raspberry/dp/B00NAY3RB2/ref=sr_1_1](https://www.amazon.com/Adafruit-MCP3008-8-Channel-Interface-Raspberry/dp/B00NAY3RB2/ref=sr_1_1).'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to connect the temperature and humidity sensor directly to Raspberry
    Pi 3, and the moisture sensor and the rain sensor to MCP3208, and MCP3208 will
    connect to Raspberry Pi 3 over SPI.
  prefs: []
  type: TYPE_NORMAL
- en: And on the broker, we are not going to change anything. In the API engine, we
    are going to add a new topic to the MQTT client named `weather-status`, and then
    send the data from Raspberry Pi 3 to this topic.
  prefs: []
  type: TYPE_NORMAL
- en: On the web app, we are going to update the template for viewing the weather
    metrics. The same goes for the desktop app and mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Raspberry Pi 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us get started with the schematics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up Raspberry Pi 3 and the sensors as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is a table showing these connections:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi and MCP3208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Raspberry Pi pin number - pin name** | **MCP3208 pin number - pin name**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - 3.3V | 16 - VDD |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - 3.3V | 15 - AREF |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND | 14 - AGND |'
  prefs: []
  type: TYPE_TB
- en: '| 23 - GPIO11, SPI0_SCLK | 13 - CLK |'
  prefs: []
  type: TYPE_TB
- en: '| 21 - GPIO09, SPI0_MISO | 12 - DOUT |'
  prefs: []
  type: TYPE_TB
- en: '| 19 -GPIO10, SPI0_MOSI | 11 - DIN |'
  prefs: []
  type: TYPE_TB
- en: '| 24 - GPIO08, CEO | 10 - CS |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND | 9 - DGND |'
  prefs: []
  type: TYPE_TB
- en: Moisture sensor and MCP3208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **MCP3208 pin number - pin name** | **Sensor name** - **pin number** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - A0 | Rain sensor - A0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 - A1 | Moisture sensor - A0 |'
  prefs: []
  type: TYPE_TB
- en: Raspberry Pi and DHT11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Raspberry Pi number - pin name** | **Sensor name** - **pin number** |'
  prefs: []
  type: TYPE_TB
- en: '| 3 - GPIO2 | DHT11 - Data |'
  prefs: []
  type: TYPE_TB
- en: All grounds and all 3.3V are connected to a common point.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have connected the sensors as shown previously, we will write the code
    needed to interface with the sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go further, we are going to copy the entire [Chapter 2](part0032.html#UGI00-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - I*, and [Chapter 3](part0072.html#24L8G0-ce91715363d04669bca1c1545beb57ee),
    *IoTFW.js - II*, code into another folder named `chapter4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `chapter4` folder should look as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will head back to the Raspberry Pi and inside the `pi-client` folder, we
    will update the `index.js` file. Update `pi-client/index.js`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have left the MQTT setup as is. We have added the
    `mcp-adc` ([https://github.com/anha1/mcp-adc](https://github.com/anha1/mcp-adc))
    and `async` ([https://github.com/caolan/async](https://github.com/caolan/async))
    modules. `mcp-adc` manages the SPI protocol interface exposed by MCP3208, and
    we are using the `async` module to read data from all sensors in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: We have started off by establishing a connection with the broker over MQTTS.
    Then, we have set up an infinite loop using `setInterval()` with a time delay
    of 3 seconds between executions. Inside the `callback` of `setInterval()`, we
    have invoked `readSensorValues()` to get the latest sensor values.
  prefs: []
  type: TYPE_NORMAL
- en: '`readSensorValues()` uses `async.parallel()` to read the three sensors in parallel
    and update the data in the global variables we have defined. Once all the sensor
    data is gathered, we are passing the results to the `callback` function as an
    argument.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we receive the sensor data, we are going to check whether something has
    changed between the temperature, humidity, rain, and moisture values. If nothing
    has changed, we chill; otherwise, we will publish this data to the broker on the
    weather-status topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save all the files. Now, we will start the Mosca broker from our desktop machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you have started the Mosca server, check the IP address of the server on
    which Mosca is running. Update the same IP in your Raspberry Pi `config.js` file.
    Otherwise, Raspberry Pi cannot post data to the broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Mosca has started successfully and we have validated the IP, run this
    on Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the server, and we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When I started the Raspberry Pi, the rain sensor was dry and the moisture sensor
    was placed inside dry soil. Initially, the value of the rain sensor was `1.86%`
    and the moisture sensor value was `4.57%`.
  prefs: []
  type: TYPE_NORMAL
- en: When I added water to the plant/moisture sensor, the percentage increased to
    `98.83%`; similarly, when I simulated rainfall on the rain sensor, the value went
    up to `89.48%`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is my prototype setup of the smart weather station:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00056.jpeg)![](../images/00057.jpeg)![](../images/00058.jpeg)![](../images/00059.jpeg)The
    blue chip is DHT11, the moisture sensor is plotted inside my desk-side plant,
    and the rain sensor is placed inside a plastic tray for collecting rainwater.
    The breadboard has the MCP3208 IC and the required connections.'
  prefs: []
  type: TYPE_NORMAL
- en: Lots of wires!
  prefs: []
  type: TYPE_NORMAL
- en: With this, we complete the code needed for Raspberry Pi 3\. In the next section,
    we are going to set up the code needed for the API engine.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last section, we have seen how to set up the components and code needed
    to set up our smart weather station using Raspberry Pi 3\. Now, we will work on
    managing the data that we receive on the API engine from the Raspberry Pi 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `api-engine/server/mqtt/index.js` and update it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are waiting for a message on the `weather-status` topic, and when we
    receive the data from the Raspberry Pi, we save it to our database and that pushes
    the data to the web app, mobile app, and desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: Those are all the changes we need to make to absorb the data from the Raspberry
    Pi 3 and pass it on to the web, desktop, and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save all the files and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the API engine and connect to Mosca, along with Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And if we leave the API engine running for a while, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The data from the device is logged here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to update the web app so it can represent
    the data from the API engine.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are done with the API engine, we are going to develop the interface
    needed to show the weather output from the Raspberry Pi 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `web-app/src/app/device/device.component.html` and update it, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added four rows in a table that displays temperature,
    humidity, rain level, and moisture level. We have also set up the canvas to display
    the values in the chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the class definition for `DeviceComponent`, present in `web-app/src/app/device/device.component.ts`.
    Update `web-app/src/app/device/device.component.ts`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have used the `ngOnInit` hook and have made a request
    to get the device data. Using `socketInit()`, along with the data, we are going
    to register for socket data events for the current device.
  prefs: []
  type: TYPE_NORMAL
- en: In `getData()`, we fetch the data from the server, extract the latest record,
    and set it to the `lastRecord` property. And finally, we call `genChart()` to
    draw a chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are done with the required changes. Save all the files and run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we navigate to `http://localhost:4200`, log in, and click on VIEW **DEVICE**,
    we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever there is change in the data, we should see the UI update automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to build the same app and show it inside the
    electron shell.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the desktop app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we developed the template and interface for the web app.
    In this section, we are going to build the same thing and dump it inside the desktop
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, head back to the terminal/prompt of the `web-app` folder, and
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new folder inside the `web-app` folder named `dist`. The
    contents of the `dist` folder should consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code we have written is finally bundled into the preceding files. We
    will grab all the files (not the `dist` folder) present inside the `dist` folder
    and then paste them inside the `desktop-app/app` folder. The final structure of
    desktop-app after the preceding changes will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To test drive the process, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to the VIEW **DEVICE** page, and we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever there is a change in the data, we should see the UI update automatically.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we are done with the development of the desktop app. In the next
    section, we will update the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the mobile app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we saw how to build and run the desktop app for the smart
    weather station. In this section, we are going to update the template of the mobile
    app to show the weather station data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `mobile-app/src/pages/view-device/view-device.html` and update it, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created four items inside the list view to display
    the temperature, humidity, rain level, and moisture level. And the required logic
    for `ViewDevicePage` class would be present in `mobile-app/src/pages/view-device/view-device.ts`.
    Update `mobile-app/src/pages/view-device/view-device.ts`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are getting the latest data from the API engine using
    `getData()`. Then, using `socketInit()`, we are subscribing to the latest changes
    to the data.
  prefs: []
  type: TYPE_NORMAL
- en: Check the IP address of the server on which the API engine is running. Update
    the same IP in your mobile app's `mobile-app/src/app/app.globals.ts` file. Otherwise,
    the mobile app cannot communicate with the API engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, save all the files and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can deploy the same to your device as well, by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the app is launched, and when we navigate to the VIEW **DEVICE** page,
    we should see the following on our screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00064.gif)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the image, we are able to view the data updating in real
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used the knowledge we gained in chapters two and three and
    built a prototype of a smart weather station. We started by identifying the sensors
    needed to build the weather station. Next, we set them up on the Raspberry Pi
    3\. We wrote the code needed to interface with the sensors. Once this was done,
    we updated the API engine to read the data from the Raspberry Pi 3 on the new
    topic. Once the API engine received the data, we saved it in the database and
    then sent it to the web, desktop, and mobile apps over web-sockets. Finally, we
    updated the presentation templates on the web, desktop, and mobile apps; then,
    we displayed the data from the Raspberry Pi on the web, desktop, and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](part0095.html#2QJ5E0-ce91715363d04669bca1c1545beb57ee), *Smart
    Agriculture and Voice AI*, we are going to work with voice artificial intelligence,
    using Alexa from Amazon and the smart weather station we built.
  prefs: []
  type: TYPE_NORMAL
