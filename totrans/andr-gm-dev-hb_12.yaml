- en: Chapter 12. Polishing Android Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quality of a developed game mostly depends on the final polishing. Polishing
    is basically a stage in development where the game is improved in every possible
    aspect to provide maximum user experience. There is no limit to such improvisation.
    Most game developers allocate a major time period to polishing.
  prefs: []
  type: TYPE_NORMAL
- en: In the polishing stage, the game should be ready for release. Most of the time,
    the developer faces a time crunch at the end of the development process. Polishing
    takes a significant amount of time. There are many examples where the developer
    chooses to polish the game after release. However, it is not recommended from
    the user experience and retention point of view.
  prefs: []
  type: TYPE_NORMAL
- en: The polishing job is carried out by the full development team, including designers,
    artists, and developers. It is the responsibility of the product manager and producer
    to ensure the target polishing level of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers choose to carry out play testing with a significant but limited
    number of users. Then, the issues and improvements are charted down for polishing.
    There are several approaches to polishing an Android game used by developers.
    We will discuss the general and widely used methods and practices of polishing
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will have a detailed look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for polishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking care of UX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android-specific polishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements for polishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polishing any game defines the quality of development. So, it is absolutely
    necessary to polish any game before releasing it in the market. A polished game
    performs far better than unpolished games in terms of visibility, smoothness,
    and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polishing Android games covers all the three development components of a game:'
  prefs: []
  type: TYPE_NORMAL
- en: Development polishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Art polishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design polishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development polishing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polishing the engineering or the technical aspect of the game development process
    to improve smooth playability of the game is the main target of development polishing.
    This section includes programming optimization, memory optimization, and stripping
    unnecessary code blocks to avoid any extra processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Development polishing can be further split into three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already discussed memory optimization in detail in the previous chapter.
    Memory optimization ensures that the game runs with minimum memory usage. In a
    way, it helps a lot to increase device support and game stability. A good game
    must have excellent memory management so that it can run smoothly even with limited
    memory capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performance optimization ensures that the game runs smoothly on each and every
    target Android device. However, it is not always possible to test such smoothness
    in all devices. Mostly, developers select a few devices that are almost equivalent
    to other targeting devices to test the game.
  prefs: []
  type: TYPE_NORMAL
- en: Portability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multi-resolution support and multi-platform support are also a part of development
    polishing. Thus the game can reach the maximum possible audience with minimal
    effort. Portability might be the key to success for many Android games.
  prefs: []
  type: TYPE_NORMAL
- en: Art polishing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Game art is polished during this phase. The main target in polishing the game
    art is to provide better visual quality within the same art space.
  prefs: []
  type: TYPE_NORMAL
- en: Game art is the initial driving force of the game. So, the polishing of game
    art may create or destroy the future of the game in the market. Especially for
    Android, where a wide range of device variations are available in the market with
    different visual quality, game art polishing becomes extremely useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are mainly three phases of art polishing:'
  prefs: []
  type: TYPE_NORMAL
- en: UI polishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation polishing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marketing graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI polishing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UI drives the game flow. So, the UI art should convey the desired path easily
    for users to roam around within the game. Thus, it becomes absolutely necessary
    to polish the UI art accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Animation polishing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost every game uses animations for various purposes. Polishing animations
    means increasing the visual effectiveness and make a user see the game from a
    developer's point of view. Mainly for sports games, FPSs, and RPGs, animations
    are inevitable. Animations decide the character of gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Marketing graphics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Marketing assets are the first thing to be visualized when it comes to a game.
    They create the hype and interest to start playing the game for the user. If marketing
    art is not polished enough to attract users to the game, then there may be significant
    loss, irrespective of the actual game quality.
  prefs: []
  type: TYPE_NORMAL
- en: Design polishing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It may be a general concept that design is a phase of preproduction and can
    be improvised during production. However, it is very important to polish up the
    design after development so that the final application can have improved quality.
    It has five phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing UX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polishing the game flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polishing the metagame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game economy balance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game difficulty balance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing UX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: UX is the overall playing and browsing experience of a game from the user's
    point of view. There are several cases where a game failed to retain users because
    of poor UX designing. So, UX has to be polished with the help of actual user behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Polishing the game flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often in the game development process, the game flow might contain some unnecessary
    loops or actions. Users should have the maximum experience of the game with minimal
    action. Each action should be simplified enough for the users to understand without
    any tutorial. However, it is not always possible to simplify the game flow to
    that level. But it should be simplified enough to make it easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Polishing the metagame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A metagame is basically the container or packaging of the core gameplay. Polishing
    the metagame means polishing the packaging so that the game becomes more interesting
    and engaging for users. The metagame is also responsible for monetization. So,
    an extremely well polished metagame increases the chance of success in terms of
    revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Game economy balance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many developers used to polish economy balancing along with metagame polishing.
    However, there are many aspects that need to be taken care of separately, depending
    on the core game model. Almost every game has an economical aspect associated
    to it. This aspect should be balanced throughout the game to keep users moving
    and give them a sense of progression.
  prefs: []
  type: TYPE_NORMAL
- en: Game difficulty balance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As they say, all the fingers on a hand are never the same. Similarly, user efficiency
    is also not the same. It is the most likely thing to vary, and is reflected on
    the game leaderboard. So, the difficulty of the game should be balanced in a way
    such that almost each and every player has a chance to keep playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Play testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play testing is a part of planning game polishing. Play testing is carried out
    after the game has been made according to the initial design. It basically reveals
    the entire user behavior throughout the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the fields of exploration during play testing:'
  prefs: []
  type: TYPE_NORMAL
- en: User gameplay difficulty level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User actions during gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User actions while browsing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the user is paying or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the game is running smoothly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the user can adopt the gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User retention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play testing is planned on a limited group of targeted users. Often, developers
    release beta versions of the game in a certain region to carry out play testing.
    The preceding points are basically the advantages of play testing. The only disadvantage
    of performing such an act is that the developer might lose some audience in the
    play test region because of a poor initial game plan, which can be improved after
    play testing. So, it is always recommended that you complete the game with the
    full game experience planned in the initial phase and make the game release-ready
    before performing play testing.
  prefs: []
  type: TYPE_NORMAL
- en: User gameplay difficulty levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Difficulty aspects of a game vary with game design and core gameplay. All users
    of the same game are not equally efficient in playing the game. Play testing reveals
    the difficulty faced by users while playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: Game balancing is improvised after collecting this data from the play testing
    result. This has a direct impact on game polishing.
  prefs: []
  type: TYPE_NORMAL
- en: User actions during gameplay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section typically reveals the use of gameplay controls by users. For example,
    it reveals whether a gameplay mechanism supports few gameplay controls such as
    swiping, tapping on different buttons, choosing options, and so on. The developer
    collects data on all of these during play testing. Even the reaction time of each
    action may be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on this data, the developer can have an idea of the ease of game control.
    Whether the user can use the control properly or not determines the success of
    the game. Sometimes, developers change the game control if they encounter a serious
    issue with regard to user actions.
  prefs: []
  type: TYPE_NORMAL
- en: User actions while browsing the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the user actions during UI browsing are recorded during the play testing
    phase. The UI flow and navigation style of the game are validated throughout this
    process. Sometimes, a UI section may be overlooked by the user. It is very difficult
    for developers to identify such UI sections from a user's point of view, although
    developers can easily browse those segments as they themselves have implemented
    those UI sections. Such cases indicate that the section of UI that is overlooked
    by a decent number of users is not highlighted enough by any means.
  prefs: []
  type: TYPE_NORMAL
- en: There may be several sections in the UI that are not a direct part of the main
    game flow, such as the leaderboard, offer wall, achievements, help, settings,
    IAP screens, secondary game mode, and so on. If a user does not visit such UI
    sections for a long period of time, which cannot be predicted by the developer,
    then the developer may choose to change the UI style or find out an alternate
    solution. The success of metagames mostly depends on this kind of polishing. Game
    monetization can also be improved a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the user is paying or not
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several game monetization models available. The basic three types
    are premium, free, and freemium. Developers adopt any model for the game to generate
    revenue.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, premium games are basically paid games. This means the
    full game is bought by the user in the first instance. So, in this case the user
    does not need to pay while playing. A free game is completely free to play and
    has no provision for paying to gain any advantage while playing. The developer
    can plan revenue through game advertising. User actions and behavior during gameplay
    can help place advertisements strategically. Users have an option to pay after
    starting to play the game in the case of the freemium model. The developer designs
    the metagame to make users pay for the game to gain advantage or increase game
    progression speed.
  prefs: []
  type: TYPE_NORMAL
- en: In the play testing stage, the developer monitors users when they are paying
    for the game. In the freemium model, the developer defines stages where the user
    should pay to progress faster or more smoothly. This plan is validated through
    play testing to project future revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the game is running smoothly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have already discussed previously, from the optimization point of view,
    smooth gameplay is one of the major segments of game polishing. Initial testing
    is carried out on a few restricted devices. However, in the case of play testing,
    it is much more reliable to focus on real-time scenarios with a real device to
    validate smooth gameplay. However, a variety of hardware configurations are available
    on Android. The developer must decide the test configuration and set the benchmark
    before play testing.
  prefs: []
  type: TYPE_NORMAL
- en: The developer can take note of real-time FPS, crashes, and other performance
    data through play testing. The game is then further optimized to achieve target
    playability.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the user can adopt the gameplay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not each and every game is easily understandable. It is a proven and common
    behavior of users that they do not pay attention to a separate game instruction
    section to understand the game. Instead, they directly jump into the gameplay.
    Hence, most of the time, it takes a considerable amount of time for a normal user
    to understand the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Some developers use an interactive tutorial to help users understand game controls,
    gameplay, and game objective. Sometimes, it is mandatory to finish the interactive
    tutorial to continue playing the game. This is the best possible solution to the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are several ways to design the interactive tutorial. The game
    might not be understood through a poorly designed tutorial. It is not always possible
    to predict the time taken by the user to adopt to the gameplay. Thus, it becomes
    very important to know whether the user understands the game within the planned
    time or not through play testing. This has a great impact on user retention.
  prefs: []
  type: TYPE_NORMAL
- en: User retention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'User retention prediction is directly associated with predicting the game revenue,
    which signifies the commercial success of the game. If a user plays the game for
    the first time and never comes back, it means the user is not retained. User retention
    has a few segments: daily retention, weekly retention, monthly retention, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: During the play test phase, developers count the number of users who are playing
    the game repeatedly and the number of users who left the game. Developers even
    collect data about the time and the specific point in the game where the user
    left it. This may reveal an issue with the game model. This issue can be rectified
    to retain more users.
  prefs: []
  type: TYPE_NORMAL
- en: Taking care of the UX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to the quality of the game, UX or user experience is the most
    important factor to be considered. Thus, it becomes extremely necessary to polish
    the UX of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can categorize UX polishing into the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Action feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The user experience of a game is mostly visual. So, each visual effect adds
    an extra layer of polishing for the game to increase experience quality. There
    are several types of users. Visual effect ensures the engagement of the user.
    Basically, polishing visual effects means each action feedback should be visual.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there are a few users who might be color blind. For them, only
    color visuals is not enough. This scenario may be improved by introducing visual
    effects with different shapes of objects or by some other action.
  prefs: []
  type: TYPE_NORMAL
- en: Sound effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sound defines the mood of the game. Sound designers design sounds according
    to the game type. There are two separate types of sound effects:'
  prefs: []
  type: TYPE_NORMAL
- en: Theme music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFXs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theme music
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The theme music is the music that plays in loop continuously. It creates an
    ambience for playing the game. Most of the time, it enhances the fun while playing
    the game or browsing through its UI. A good game must have a theme that complements
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: SFXs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SFXs are the event-based sounds that can be specified for a particular action
    or event in the game. A few common uses of SFXs are button clicks, user actions,
    game win, game lose, game start, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Transaction effects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most games have multiple stages of action. The main transaction is the one between
    the stages. Smoother transaction effects result in a better user experience as
    the user has a clear idea about the flow.
  prefs: []
  type: TYPE_NORMAL
- en: There can be other transactions as well. For example, if the game supports an
    in-game currency system, then there have to be currency transactions. Most of
    the time, the user does not pay attention to the numbers and text changes. However,
    a visible transaction makes the user notice the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Action feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many games nowadays that strictly follow the action feedback system.
    There should be a feedback of each action made by the user. Feedback can be either
    visual, sound, or both. More prominent feedback results in a better user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Android-specific polishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android has a specific set of features and limitations. This opens up the possibility
    for Android-specific polishing. This can be done on the following features or
    limitations of the Android platform and devices:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimum use of hardware buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sticking to basic Android features and functionalities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longer background running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following Google guidelines for Play Store efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimum use of hardware buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A typical Android mobile or tablet device has the following buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: Home button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume up button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume down button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock/Unlock/Power button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each button has its own functionality based on the Android standard. It is always
    a good practice to use these buttons for the exact same functionality in the game.
  prefs: []
  type: TYPE_NORMAL
- en: For example, pressing the Back button should take the user to the previous screen
    or previous state of the game. The most common use of the Back button for in-game
    play is to pause the game cycle. Similarly, the Volume up/down button should have
    a direct effect on the game sound in line with the native functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Sticking to basic Android features and functionalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always a good practice to implement basic Android functionalities and
    use Android-specific features for an Android game. We just spoke about using the
    device buttons for Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: From the features point of view, the Android standard features support killing
    the game application from the game itself. Unlike iOS, an Android game can be
    quit.
  prefs: []
  type: TYPE_NORMAL
- en: Longer background running
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a common practice for users to not always quit the gameplay in a conventional
    way. Rather, Home buttons are used to quickly get out of the game. In that case,
    the game goes to the background and keeps on running unless the user resumes it
    or the OS kills the process. The longer it can stay in the background, the quicker
    the game can be resumed.
  prefs: []
  type: TYPE_NORMAL
- en: Mainly, using low memory and low process overhead can increase the time the
    game persists in the background. A few times there might be several interrupts.
    In this case, it is a best practice to resume to the same state for a better user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Following Google guidelines for Play Store efficiency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Android is an open source platform, Google has some guidelines for
    Android applications; these are also applicable to games. It is obvious that the
    Google Play Store is the biggest platform to reach a global audience in the current
    market scenario. So, it is always a wise decision to follow their guidelines to
    get featured.
  prefs: []
  type: TYPE_NORMAL
- en: There are several millions of applications available on the Google Play Store.
    Without getting featured, it is very difficult to attract users to a particular
    game or application.
  prefs: []
  type: TYPE_NORMAL
- en: Game portability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polishing is the best phase where game portability should be increased to its
    maximum level without affecting the game itself. In this phase, portability can
    be increased in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for various screen sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple resolutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for multiple hardware configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for various screen sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android has a lot of variety in terms of screen size. The game control system
    is the main segment affected by varying sizes. When a game is designed, the control
    system is also planned according to user convenience.
  prefs: []
  type: TYPE_NORMAL
- en: For Android mobile game development, Android tablet controls are usually a bit
    different from Android mobile controls. The screen size of tabs is usually bigger
    than mobiles. So, there is more space to be used by the user. The game should
    be optimized for both small and big screen scenarios for ease of control.
  prefs: []
  type: TYPE_NORMAL
- en: Support for multiple resolutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast, there are Android devices that have the same screen size, but different
    resolutions. In this scenario, the main difference occurs in terms of visibility.
    So, supporting multiple resolution devices is more art-intensive.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers use different art assets to support different resolution devices.
    We have already discussed the variety of resolutions in dpi for Android. So, it
    is possible to detect the device resolution and use art assets accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically for Google Play Store games, Google supports four different application
    packages under the same application. So, the developer has the flexibility to
    create and use four different APKs for the same game. However, there are more
    resolutions. Hence, there are several other ways to achieve them.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a game-specific server is one of the most popular ways to do the
    job. Developers do not include the major chunk of art assets in the APK. Instead,
    they put different art packages for different resolutions on a game-specific server.
    Thus, the game can download specific resolution assets when required. In this
    way, the developer manages to keep the APK size to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Support for multiple hardware configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A single game cannot have equal visual and performance impact on every hardware
    platform. Game developers try to maintain a certain standard to run the game on
    several configurations smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the game is optimized specially for some hardware platforms. One
    of the common examples of such optimization is processor architecture. We have
    already discussed the variety of processor architectures used in Android games.
    So, games can be ported for a separate processor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to support as many possible hardware configurations as
    possible to target or acquire users. Developers might need to write separate code
    to perform such a game polishing function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game polishing is an inevitable part of game development. However, game improvisation
    has no limit. Developers should plan polishing stages and changes to support and
    meet the development timeline. Game polishing helps a game acquire more users,
    more retention, and eventually more revenue. A highly polished game covers each
    and every section discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A game must look good, feel good, and be interesting enough to continue. Last
    but not least, it should be top-quality so that users pay for it or refer other
    users. Game polishing increases the life of a game. It helps developers plan updates
    and features, and keeps users in the game for a longer period.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have covered almost every aspect of game development for Android.
    However, a developer cannot be at rest even after developing the game. There are
    certain parameters to be fulfilled to make a successful game. For these reasons,
    the developer must include a few non-gaming features and functionalities in the
    game. We will explore these extra integrations through third parties in depth,
    and we will try to explore monetization techniques to make the game profitable
    in the last chapter of this book.
  prefs: []
  type: TYPE_NORMAL
