- en: Running Serverless Tasks on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will dive into one of the hottest trends in cloud-native
    systems: serverless computing (also known as **Function as a Service**, or **FaaS**).
    We will explain what serverless means (spoiler alert: it means more than one thing)
    and how it compares to microservices. We will implement and deploy a cool new
    feature for Delinkcious, known as link checking, using the Nuclio serverless framework.
    Finally, we''ll briefly cover other ways to do serverless computing in Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Serverless in the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link checking with Delinkcious
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless link checking with Nuclio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll install a serverless framework called Nuclio. First,
    let''s create a dedicated namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good security practice because Nuclio will not interfere with the
    rest of your cluster. Next, we''ll apply some **role-based access control **(**RBAC**)
    permissions. If you take a look at the file (you should always check Kubernetes
    manifests before running them on your cluster), you''ll see that most of the permissions
    are limited to the Nuclio namespace and there are a few cluster-wide permissions
    regarding **custom resource definitions** (**CRDs**) that Nuclio itself creates;
    this is an excellent hygiene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now deploy Nuclio itself; it creates a few CRDs, and deploys a controller
    and a dashboard service. This is very economical and straightforward, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s verify the installation by checking that the controller and the
    dashboard pods are running successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The dashboard is nice, but it is more appropriate for ad hoc exploration. For
    more serious production use, it is better to use the `nuctl` CLI. The next step
    is to download and install `nuctl` from [https://github.com/nuclio/nuclio/releases](https://github.com/nuclio/nuclio/releases).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, copy the executable to your path to create `symlink nuctl`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s create an image pull secret so that Nuclio can deploy functions
    to our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also use other registries with the proper credentials; in Minikube,
    you can even use a local registry. However, we'll use the Docker Hub registry
    for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code is split between two Git repositories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code samples at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Microservices-with-Kubernetes/tree/master/Chapter09)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the updated Delinkcious application at [https://github.com/the-gigi/delinkcious/releases/tag/v0.7](https://github.com/the-gigi/delinkcious/releases/tag/v0.7)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serverless in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People have two different definitions for serverless in the cloud, especially
    in the context of Kubernetes. The first meaning is that you don't have to manage
    the nodes for your cluster. Some good examples of this concept include AWS Fargate
    ([https://aws.amazon.com/fargate/](https://aws.amazon.com/fargate/)) and **Azure
    Container Instances** (**ACI**) ([https://azure.microsoft.com/en-us/services/container-instances/](https://azure.microsoft.com/en-us/services/container-instances/)).
    The second meaning of serverless is that your code is not deployed as a long-running
    service, but is packaged as a function that can be invoked or triggered in different
    ways on demand. Some good examples of this concept include AWS Lambda, and Google
    Cloud Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the commonalities and differences between services and serverless
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices and serverless functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same code can often run either as a microservice or as a serverless function.
    The difference is mostly operational. Let''s compare the operational attributes
    of microservices and serverless functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Microservices** | **Serverless functions** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Always running (it can scale down to at least one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can expose multiple endpoints (such as HTTP and gRPC).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires that you implement the request handling and routing yourself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can listen to events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service instances can maintain in-memory caches, long-term connections, and
    sessions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Kubernetes, microservices are represented directly by the service object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Runs on demand (theoretically; it can scale down to zero).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposes a single endpoint (usually HTTP).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be triggered by events or get an automatic endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often has severe limitations on resource usage and maximum runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, it might have a cold start (that is, when scaling up from zero).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Kubernetes, there is no native serverless function concept (Jobs and CronJobs
    come close).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'This should provide you with some relatively good guidance on when to use microservices
    and when to use serverless functions. A microservice is the right choice in the
    following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Your workload needs to run non-stop, or almost non-stop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each request runs for a long time and can't be supported by serverless function
    limitations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workload uses a local state between invocations that can't be easily moved
    to an external data store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if you have workloads that run infrequently for a relatively short
    time, then you may prefer to use a serverless function.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other engineering considerations to bear in mind. For example,
    services are more familiar and often have various support libraries. Developers
    may be more comfortable with services and prefer to have a single paradigm for
    deploying code to your system. In particular, in Kubernetes, there is a large
    selection of serverless functions options and it can be difficult to choose the
    right one. On the other hand, serverless functions often support agile and lightweight
    deployment models, where developers can just put some code together and it magically
    starts running on the cluster because the serverless function solution takes care
    of all the business of packaging and deploying it.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling serverless functions in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the day, Kubernetes runs containers, so you know your serverless
    function will be packaged as a container. However, there are two primary ways
    to represent serverless functions in Kubernetes. The first one is just as code;
    here, developers, essentially, provide a function in some form (as a file or by pushing
    to a Git repository). The second one is to build it as an actual container. The
    developer builds a regular container and the serverless framework takes care of
    scheduling it and running it as a function.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The benefit of this approach is that, as a developer, you completely sidestep
    the whole business of building images, tagging them, pushing them to a registry,
    and deploying them to the cluster with all the Kubernetes ceremony around it (that
    is, deployment, service, ingress, and NetworkPolicy). It's great for ad hoc exploration
    and one-off jobs too.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, as a developer, you are on familiar ground. You build a container using
    your regular process and you just deploy it later to the cluster as a serverless
    function. It is still more lightweight than a regular service because you only
    need to implement a function in your container and not a fully-fledged HTTP or
    gRPC server or register to listen for some events. You get all that for the serverless
    functions solution.
  prefs: []
  type: TYPE_NORMAL
- en: Building, configuring, and deploying serverless functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have implemented your serverless function and now you want to deploy it
    to the cluster. Regardless of whether you build your serverless function (if it's
    a container) or whether you provide it as a function, you typically also need
    to configure it in some way. The configuration may contain information such as
    scaling limits, where the function code is located, and how to invoke and trigger
    it. Then, the next step is to deploy the function to the cluster. It may be a
    one-time deployment through a CLI or web UI, or, alternatively, it may be integrated
    with your CI/CD pipeline. This depends mostly on whether your serverless function
    is part of your main application or whether it is something you launch in an ad
    hoc manner for troubleshooting or manual cleanup tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking serverless functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a serverless function is deployed in the cluster, it will be dormant. There
    will be a controller that runs constantly ready to invoke or trigger functions.
    The controller should take very few resources and just listen for incoming requests
    or events to trigger functions. In Kubernetes, if you need to invoke functions
    from outside the cluster, there will probably be some additional ingress configuration.
    However, the most common use case is to invoke functions internally and expose
    a fully-fledged service to the world.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what serverless functions are all about, let's add some
    serverless function capabilities to Delinkcious.
  prefs: []
  type: TYPE_NORMAL
- en: Link checking with Delinkcious
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Delinkcious is a link management system. Links – or, as they are known officially, **uniform
    resource identifiers** (**URIs**) – are really just a pointer to a particular
    resource. There could be two issues with links, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: They may be broken (that is, they point to a non-existent resource).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They may point to a *bad* resource (such as a phishing or virus-injecting site,
    hate speech, or child pornography).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking links and maintaining the status of each link is an important aspect
    of link management. Let's start by designing the way Delinkcious will perform
    link checking.
  prefs: []
  type: TYPE_NORMAL
- en: Designing link checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider link checking in the context of Delinkcious. We should consider
    the current state as a future improvement. Here are some assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Links can be temporarily or permanently broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link checking may be a heavyweight operation (especially if analyzing content).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of a link may change at any time (that is, a valid link can suddenly
    break if the resource that it's pointing to is deleted).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically, Delinkcious links are stored redundantly per user. If two users
    add the same link, it will be stored for each user separately. This means that,
    if link checking happens when a link is added, and if *N* users add the same link,
    then it will be checked each time. This is not very efficient, especially for
    popular links that many users may add and that can all benefit from a single check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following case, which is even worse:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N* users add the link, *L*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The link check for *L* passed for all those *N* users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another user, *N+1*, adds the same link, *L*, which is now broken (for example,
    the hosting company removed the page).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the last user, *N+1*, will have the correct status of the link, *L*, as
    invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All previous *N* users will still assume that the link is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we want, in this chapter, to focus on serverless functions, we will accept
    these limitations in the way in which Delinkcious stores links for each user.
    A more efficient and robust design in the future could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Store all the links independent of the users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users that add a link will have an association to that link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Link checking will automatically reflect the latest status of a link for all
    users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to designing a link check, let''s consider some of the following
    options for checking links when adding a new link:'
  prefs: []
  type: TYPE_NORMAL
- en: When adding a link, just run the link checking code in the link service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding a link, call a separate link checking service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding a link, invoke a link checking serverless function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding a link, keep it in pending status, which periodically runs checks
    on all recently added links.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, since links can break at anytime, it may be useful to run link
    checks periodically for existing links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the first option, that is, running the link check inside the
    link manager. While it has the benefit of simplicity, it also suffers from several
    problems, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If link checking takes too long (for example, if the target is unreachable or
    the content takes a long time to classify), then it will delay the response to
    the user adding the link or it can even time out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the actual link checking is done asynchronously, it still ties up resources
    of the link service in unpredictable ways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no easy way to schedule periodic checks or ad hoc checks of links without
    making serious changes to the link manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conceptually, link checking is a separate responsibility to link management
    and shouldn't live in the same microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider the second option, that is, implementing a dedicated link checking
    service. This option addresses most of the issues as the first option, but it
    may be overkill. That said, it is not the best option when there is no need to
    check links very often; for example, if the majority of added links are checked
    or if link checking happens only periodically. Additionally, for implementing
    a service for a single operation, checking links seems like overkill for a service.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves us with the third and fourth options, and both can be implemented
    effectively using a serverless function solution, as shown in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following simple design:'
  prefs: []
  type: TYPE_NORMAL
- en: The link manager will invoke a serverless function when adding a new link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new link will initially be in a pending state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The serverless function will only check whether the link is reachable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The serverless function will send an event through the NATS system, which the
    link manager will subscribe to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The link manager will update the link status from *pending* to *valid* or *invalid*
    when it receives the event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a diagram that describes this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/10fb6373-7451-42ce-9277-26ed16dbf867.png)'
  prefs: []
  type: TYPE_IMG
- en: With a solid design in place, let's go ahead and implement and integrate it
    with Delinkcious.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing link checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this stage, we will implement the link checking functionality independent
    of serverless functions. Let''s start with our object model and add the `Status`
    field to our link object with the possible values of `pending`, `valid`, and `invalid`.
    We define an `alias` type here called `LinkStatus`, and constants for the values.
    However, note that it is not a strongly typed `enum` like other languages; it
    is really just a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also define a `CheckLinkRequest` object that will come in handy later.
    Note that each request is per specific user and includes the link''s URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define an interface that `LinkManager` will implement to get notified
    when a link has been checked. The interface is very simple and has a single method
    that informs the receiver (`LinkManager`, in our case) of the user, the URL, and
    the link status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a new package, `pkg/link_checker`, to isolate this functionality.
    It has a single `CheckLink()` function that accepts a URL and uses the built-in
    Go HTTP client to call its HEAD HTTP method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the result is less than 400, it is considered a success, otherwise, it returns
    the HTTP status as an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The HEAD method, which just returns a few headers, is an effective way to check
    whether a link is reachable because, even for very large resources, the headers
    will be a small amount of data. Obviously, this is not good enough if we want
    to extend link checks to scanning and analyzing the content, but it will do for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to our design, when the link checking is complete, `LinkManager`
    should receive an event through NATS with the check result. This is very similar
    to the news service listening to link events (such as the link added and the link
    updated events). Let''s implement another package, `link_checker_events`, for
    the NATS integration, which will allow us to send and subscribe to link checking
    events. First, we need an event object that contains the username, the URL, and
    the link status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to be able to send events through NATS. The `eventSender` object
    implements the `LinkCheckerEvents` interface. Whenever it receives a call, it
    creates `link_checker_events.Event` and publishes it to NATS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The reason the event is defined in the `link_checker_events` package and not
    in the general Delinkcious object model is that this event is just created for
    the purpose of interfacing though NATS with the link checker listener that is
    also implemented in this package. There is no need to expose this event outside
    the package (except for letting NATS serialize it). In the `Listen()` method, the
    code connects to the NATS server and subscribes to NATS in a queue (which means
    that only one listener will handle each event, even if multiple subscribers subscribe
    to the same queue).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the listener function that is subscribed to the queue receives an event
    from NATS, it forwards it to the event sink that implements `om.LinkCheckerEvents`
    (while ignoring the link deletion events):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you followed closely, you may have noticed that there is one key piece missing,
    which we described in our design, that is, invoking the link checking. Everything
    is wired up and ready to check links, but nobody is actually calling the link
    checker. This is where `LinkManager` comes in to invoke the serverless function.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless link checking with Nuclio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into `LinkManager` and close the loop of link checking in Delinkcious,
    let's get familiar with Nuclio ([https://nuclio.io/](https://nuclio.io/)) and
    explore how it provides a serverless function solution that works very well for
    Delinkcious.
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to Nuclio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nuclio is a polished, open source platform for high-performance serverless
    functions. It was developed by Iguazio and supports multiple platforms, such as
    Docker, Kubernetes, GKE, and Iguazio itself. We obviously care about Kubernetes,
    but it''s interesting to note that Nuclio can be used on other platforms too.
    It has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It can build functions from the source code or provide your own container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a very clean, conceptual model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has great integration with Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a CLI called `nuctl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a web dashboard if you want to play with it interactively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a slew of methods to deploy, manage, and invoke your serverless functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers GPU support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a managed solution with 24/7 support (this is paid).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, it has a super cool logo! You can view the logo here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5a1e8c8f-634e-4833-b4ed-81635a523bba.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now build and deploy our link checking capability into Delinkcious using
    Nuclio.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a link checker serverless function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is creating a serverless function; there are two components
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: The function code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a dedicated directory called `fun` for storing serverless functions.
    Serverless functions don''t really fit into any of our existing categories; that
    is, they are not plain packages, they are not services, and they are not commands.
    We can put the function code and its configuration as a YAML file under the `link_checker`
    subdirectory. Later, if we decide to model additional capabilities as serverless
    functions, then we can create additional subdirectories for each function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The function itself is implemented in `link_checker.go`. The `link_checker`
    function is responsible for checking a link when triggered and publishing an event
    to NATS with the results. Let''s break it down piece by piece, starting with the
    imports and constants. Our function will utilize the Nuclio GO SDK, which provides
    a standard signature that we will look at later. It also imports our Delinkcious
    packages: the `object_model`, the `link_checker`, and the `link_checker_events` packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we also define the NATS URL based on the well-known Kubernetes DNS name.
    Note that the `natsUrl` constant includes the namespace (by default). The `link_checker`
    serverless function will run in the Nuclio namespace, but will send events to
    the NATS server running in the default namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not a problem; namespaces are not isolated from each other at the network
    level (unless you explicitly create a network policy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a Nuclio serverless function (in Go) means implementing a handler
    function with a certain signature. The function accepts a Nuclio context and a
    Nuclio event object. Both are defined in the Nuclio GO SDK. The handler function
    returns an empty interface (which can pretty much return anything). However, there
    is a standard Nuclio response object for the HTTP-invoked functions that we use
    here. The Nuclio event has a `GetBody()` message that can be used to get the input
    to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we unmarshal it using the standard JSON encoder in `CheckLinkRequest`
    from the Delinkcious object model. This is the contract between whoever invokes
    the `link_checker` function and the function itself. Since Nuclio provides a generic
    signature, we must validate the input that was provided in the body. If it wasn''t,
    then the `json.Unmarshal()` call will fail and the function will return a 400
    (that is, a bad request) error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, if the unmarshaling succeeded but the resulting `CheckLinkRequest`
    has an empty username or empty URL, it is still an invalid input and the function
    will return a 400 error as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the function validated the input, we got a username and a URL,
    and it''s ready to check whether the link itself is valid. All it takes is to
    call the `CheckLink()` function of the `pkg/link_checker` package that we implemented
    earlier. The status is initialized to `LinkStatusValid` and, if the check returns
    an error, then the status is set to `LinkStatusInvalid` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, don't get confused! The `pkg/link_checker` package is a package that
    implements the `CheckLink()` function. In comparison, `fun/link_checker` is a
    Nuclio serverless function that calls `CheckLink()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The link was checked and we have its status; it''s now time to publish the
    result through NATS. Again, we''ve already done all the hard work in `pkg/link_checker_events`.
    The function creates a new event sender using the `natsUrl` constant. If it failed,
    then the function returns an error. If the sender was created properly, it invokes
    its `OnLinkChecked()` method with the username, the URL, and the status. Finally,
    it returns the Nuclio response (initialized to 200 OK) and no error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The code is only half the story, however. Let's review the function configuration
    in `fun/link_checker/function.yaml`. It looks just like a standard Kubernetes
    resource and this is no coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: You can take a look at the full specification at [https://nuclio.io/docs/latest/reference/function-configuration-reference/](https://nuclio.io/docs/latest/reference/function-configuration-reference/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we specify the API version, the kind (`NuclioFunction`),
    and then the spec. We have a description filled, the runtime field says Golang,
    and the handler defines the package and function name that implements the handler
    function. We also specify the minimum and maximum replicas, which, in this case,
    are both `1`. Note that Nuclio doesn''t provide a way to scale to zero. There
    will always be at least one replica of each deployed function waiting to be triggered.
    The only custom part of the configuration is the `build` command to install the
    `ca-certificates` package. This uses the **Alpine Linux Package Manager** (**APK**)
    system. This is necessary because the link checker needs to check HTTPS links
    too, and that requires root CA certificates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All right! We created a link checker serverless function and a configuration;
    let's now deploy it to our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the link checker function with nuctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Nuclio deploys a function, it actually builds a Docker image and pushes
    it to a registry. Here, we''ll use the Docker Hub registry; so, first, let''s
    log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The function name must follow DNS naming rules, so the `""` marks in `link_checker`
    are not acceptable. Instead, we''ll name the function `link-checker` and run the
    `nuctl deploy` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the documentation for deploying a function with `nuctl` to the Docker
    Hub registry is incorrect at the time of writing. I opened a GitHub issue ([https://github.com/nuclio/nuclio/issues/1181](https://github.com/nuclio/nuclio/issues/1181))
    for the Nuclio team. Hopefully, it will be fixed by the time you read this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function was deployed to the Nuclio namespace, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The best way to see all the configuration is to use `nuctl` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it borrows a lot from our `function.yaml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully deployed our function using the `nuctl` CLI, which is great
    for developers and CI/CD systems. Let's now take a look at how to deploy a function
    using the Nuclio web UI.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a function using the Nuclio dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nuclio has a cool web UI dashboard. The Nuclio dashboard is very well done;
    it is installed as a service in our cluster. First, we need to do a little port
    forwarding before we can access it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can browse to `localhost:8070` and play with the dashboard. The dashboard
    allows you to view, deploy, and test (or invoke) serverless functions directly
    from a single screen. This is great for ad hoc exploration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I slightly modified the `hello` example function (in Python) and even
    tested it with the text, `Yeah, it works!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9b6b1b79-bec6-467a-96fc-b431bd03c809.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the function is deployed in the cluster, we can invoke it in different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking the link-checker function directly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Invoking the function using `nuctl` is very simple. We need to provide the
    function name (`link-checker`), the namespace, the cluster IP address, and the
    body, which is the input to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Triggering link checking in LinkManager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `nuctl` is nice when you develop your functions and want a quick edit-deploy-debug
    cycle. However, in production, you will want to either invoke the function by
    using an HTTP endpoint or one of the triggers. For Delinkcious, the simplest way
    is by having `LinkManager` directly hit the HTTP endpoint. This happens when a
    new link is added to the `AddLink()` method of `LinkManager`. It simply calls
    `triggerLinkCheck` with the username and URL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It's important that the `AddLink()` method doesn't have to wait for the link
    check to complete. If you remember, the link will be stored immediately with a
    *pending* status. Later, when the check is complete, the status will be changed
    to either *valid* or *invalid*. To accomplish this, the `triggerLinkCheck()` function
    runs a goroutine that returns control immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goroutine, in the meantime, prepares `om.CheckLinkRequest`, which the handler
    of the `link_checker` serverless function is expecting. It serializes it into
    JSON via `json.Marshal()` and, using the Go built-in HTTP client, it sends a POST
    request to the link checker function URL in the Nuclio namespace (it has no problem
    hitting HTTP endpoints in another namespace). Here, we just ignore any errors;
    if something goes wrong, then the link will stay in the *pending* state and we
    can decide what to do about it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We did a lot of work here, but we kept everything loosely coupled and ready
    for extension. It would be very easy to add more sophisticated link checking logic
    in order to trigger link checking as a NATS event instead of directly hitting
    an HTTP endpoint, or even replace the Nuclio serverless function with a completely
    different serverless function solution. Let's briefly take a look at the other
    options in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Other Kubernetes serverless frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS Lambda functions made serverless functions in the cloud very popular. Kubernetes
    is not a fully-fledged serverless function primitive, but it gets pretty close
    with the Job and CronJob resources. In addition to this, a plethora of serverless
    function solutions were developed by the community (Nuclio being one of them).
    Here are some of the more popular and mature options that we will see in the following
    subsections:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Jobs and CronJobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KNative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubeless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenFaas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes Jobs and CronJobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes deployments and services are all about creating a set of long-running
    pods that are supposed to run indefinitely. A Kubernetes Job is all about running
    one or more pods until one of them completes successfully. When you create a Job,
    it looks very much like a deployment, except that the restart policy should be
    `Never`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a Kubernetes Job that prints `Yeah, it works in a Job!!!` from Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'I can now run this Job, watch it complete, and check the logs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is almost a serverless function. Of course, it doesn''t come with all
    the bells and whistles, but the core functionality is there: launch a container,
    run it to completion, and get back the results.'
  prefs: []
  type: TYPE_NORMAL
- en: A Kubernetes CronJob is similar to a Job, except that it gets triggered on a
    schedule. If you don't want to incur additional dependencies on a third-party
    serverless function framework, then you can build a basic solution on top of the
    Kubernetes Job and CronJob objects.
  prefs: []
  type: TYPE_NORMAL
- en: KNative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'KNative ([https://cloud.google.com/knative/](https://cloud.google.com/knative/))
    is a relative newcomer to the serverless functions scene, but I actually predict
    that it will become the mainstream go-to solution, and there are several reasons
    for this, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a strong solution that can scale to zero (unlike Nuclio).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can build images in-cluster (using Kaniko).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is Kubernetes-specific.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has the cloud of Google behind it and is available on GKE via Cloud Run ([https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack](https://cloud.google.com/blog/products/serverless/announcing-cloud-run-the-newest-member-of-our-serverless-compute-stack)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses the Istio service mesh as a foundation, and Istio is becoming very important
    (more on that in [Chapter 13](b39834c8-859c-42a5-846a-e48b76dfd6cc.xhtml), *Service
    Mesh – Working with Istio*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KNative has three separate components, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Building
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eventing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is designed to be very pluggable so that you bring your own builder or event
    sources. The build component is in charge of going from the source to the image.
    The serving component is responsible for scaling the number of containers needed
    to handle the load. It can scale up as more load is generated, or down, including
    all the way to zero. The eventing component is related to producing and consuming
    events in your serverless functions.
  prefs: []
  type: TYPE_NORMAL
- en: Fission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fission ([https://fission.io/](https://fission.io/)) is an open source serverless
    framework from Platform9 that supports multiple languages, such as Python, NodeJS,
    Go, C#, and PHP. It can be extended to support other languages. It keeps a pool
    of containers ready to go, so new function invocations have very low latency at
    the expense of not scaling to zero when there is no load. What makes Fission special
    is its ability to compose and chain functions through Fission workflows ([https://fission.io/workflows/](https://fission.io/workflows/)).
    This is similar to AWS step functions; other interesting features of Fission include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It can integrate with Istio for monitoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can incorporate logs into the CLI through Fluentd integration (Fluentd is
    automatically installed as a DaemonSet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers Prometheus integration for metrics collection and dashboard visibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubeless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubeless is another Kubernetes-native framework from Bitnami. It uses a conceptual
    model of functions, triggers, and runtimes, which are implemented using Kubernetes
    CRDs that are configured through ConfigMaps. Kubeless uses Kubernetes deployments
    for function pods, and **Horizontal Pod Autoscaler** (**HPA**) for autoscaling.
  prefs: []
  type: TYPE_NORMAL
- en: This means that Kubeless doesn't scale to zero because HPA doesn't scale to
    zero at the moment. One of Kubeless's primary claims to fame is its excellent
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: OpenFaas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenFaas ([https://www.openfaas.com/](https://www.openfaas.com/)) is one of
    the earliest FaaS projects. It can run on Kubernetes or Docker Swarm. Since it's
    cross-platform, it does a lot of things in a generic and non-Kubernetes way. For
    example, it can scale to zero by using its own management for function containers.
    It also supports many languages and even plain binaries as functions.
  prefs: []
  type: TYPE_NORMAL
- en: It also has the OpenFaaS Cloud project, which is a complete GitOps-based CI/CD
    pipeline to manage your serverless functions. Similar to other serverless function
    projects, OpenFaas has its own CLI and UI for management and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced link checking to Delinkcious and we did it in
    style! We discussed the serverless scene, including its two common meanings; that
    is, not dealing with instances, nodes, or servers, and cloud functions as a service.
    We then implemented a loosely coupled solution within Delinkcious for link checking,
    which took advantage of our NATS messaging system to distribute events when links
    are checked. Then, we covered Nuclio in some detail and used it to close the loop
    and let the `LinkManager` initiate link checks on a serverless function and get
    notified later to update the link status.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we surveyed many other solutions and frameworks for serverless functions
    on Kubernetes. At this point, you should have a solid understanding of what serverless
    computing and serverless functions are all about. You should be able to make an
    informed decision about whether your systems and projects can benefit from serverless
    functions and which solution is the best. It's clear that the benefits are real,
    and that it's not a fad that will disappear. I anticipate that the serverless
    solutions in Kubernetes will consolidate (possibly around KNative) and become
    a cornerstone of most Kubernetes deployments, even if they are not part of core
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go back to the basics and explore one of my favorite
    subjects, that is, testing. Testing can make or break large projects and there
    are many lessons to apply in the context of microservices and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following references for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nuclio documentation**: [https://nuclio.io/docs/latest](https://nuclio.io/docs/latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes (Jobs – Run to Completion)**: [https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/](https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CronJob**: [https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KNative**: [https://cloud.google.com/knative/](https://cloud.google.com/knative/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fission**: [https://fission.io/](https://fission.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubeless**: [https://kubeless.io/](https://kubeless.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenFaas**: [https://www.openfaas.com](https://www.openfaas.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
