- en: Chapter 13. Building a Complete Cyber Range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will put all of the components together and discuss the
    architecture that can support the scenarios we have covered throughout the book.
    In this chapter, we will be discussing the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layered architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating decoys and honeypots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking the cyber range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording the attack data for further training and analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with a complete architecture that we can use to
    preform our testing. This design will allow us to plug in any required components
    that we might have. Furthermore, it will provide you with the capability to test
    all types of testing that you might need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed throughout the book, the goal of the ranges we create is
    to provide the capability to hone and improve our skills so that when we go on
    the site, we have already practiced against as many similar environments as the
    client might have.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting the switching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With VMware Workstation, we can take advantage of its capability to create a
    number of different switches that will allow us to perform a variety of scenarios
    when we build or test ranges.
  prefs: []
  type: TYPE_NORMAL
- en: Segmenting the architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our approach is to create a segmented architecture that takes advantage of
    the switch options within the virtualization framework. Furthermore, we want to
    build different types of segments so that we can test a combination of flat and
    layered networks. We have discussed these architectures a number of times throughout
    the book. An example of our proposed range of architecture is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Segmenting the architecture](img/477-1_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A public DMZ
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A review of the previous diagram shows that we have a number of different architectures
    that we can explore with our design. The first one that we will discuss is that
    of a public DMZ; this is created when we have a buffer zone between our internal
    network and the external Internet. We consider it public as it will be, for the
    most part, accessible to anyone who wants to use the services that are running
    there. The location of the public DMZ is between the perimeter or screening router
    and the Bastion Host that is usually running our firewall software. For our example,
    this would be connected to the VMnet2 subnet.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this configuration is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A public DMZ](img/477-1_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The problem with this approach is that the public DMZ is only protected by a
    screening router and, as such, is at risk of an attack; so, a potential solution
    to this problem is to move the DMZ.
  prefs: []
  type: TYPE_NORMAL
- en: A private DMZ
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As a solution to the protection problem of the public DMZ, we can use a private
    DMZ or a separate subnet DMZ, as it is sometimes referred to. The concept of having
    a separate subnet DMZ is to provide an extra layer of protection over that of
    the public DMZ. Furthermore, this configuration also has an added benefit; if
    communications are compromised in the DMZ, then the only thing that is compromised
    is the data that is passed in that DMZ. This is not the case in a public DMZ,
    because the communications between the internal and external networks traverse
    through the public DMZ, so if anything is compromised in that DMZ, then the data
    is compromised as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this configuration is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A private DMZ](img/477-1_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous diagram shows, we now have two layers of defense protecting
    the machines that are placed in the private DMZ. Having said that, there is one
    disadvantage of this approach, and that is the fact that we are allowing our public
    services all the way in through our firewall. Consequently, the bandwidth is shared
    by all the traffic to and from the Internet. We will look at a potential solution
    to this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Decoy DMZ
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we mentioned earlier, with the subnet configuration of private or separate
    services, we have to allow the traffic into our second layer of defense. We will
    now discuss the concept of a decoy DMZ. With this concept, we leave the public
    DMZ as originally discussed, and then, we only place monitoring devices within
    that segment as we want to configure rules to alert us on any unwanted traffic
    that is received. For example, if we see any port 80 destination traffic, then
    we know that it is malicious, and as such, we generate alerts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another benefit of this configuration is the fact that we can bind ports inside
    the firewall for the users and then only bind the bare minimum of the ports on
    the external interface. An example of this is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decoy DMZ](img/477-1_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An advantage of the architecture in the previous diagram is that the performance
    of the network tends to improve as the main traffic to and from the Internet is
    not shared with the traffic to and from the services in the public DMZ. As we
    have concentrated on attacking throughout the book, we will not cover the advantages
    from a defense standpoint. However, for those of you who want to learn more, you
    can check out the **Advanced Network Defense** course in the **Center of Advanced
    Security Training** section that I have created. You can read more at the following
    link: [http://www.eccouncil.org/Training/advanced-security-training/courses/cast-614](http://www.eccouncil.org/Training/advanced-security-training/courses/cast-614).'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating decoys and honeypots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that continues to grow in popularity is the deployment of
    honeypots and decoys on networks. Therefore, we want to deploy these in our architecture
    so that we can see how they react and what indications we can use to identify
    them when we encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of different honeypots that we might encounter, so we need
    to look at the characteristics that they exhibit. The best way to think of these
    is that there will be a number of ports that are shown as open; however, when
    you connect to them, they will not respond as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first honeypot that we will look at was created by **Marcus Ranum** many
    years ago when the Back Orifice tool was infecting machines around the Internet.
    The tool is no longer available, but you can search around on the Internet and
    you should be able to discover it. The tool is called **BackOfficer Friendly**,
    and it has a small footprint, but it is very effective in the role of a honeypot.
    The tool allows you to select a number of ports that it will listen on for connections.
    An example of these options is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have all of the ports set to listen on
    the honeypot. We do not have the **Fake Replies** option selected; this is because
    if this option is set, the banner will give the honeypot away. Now that we have
    the honeypot listening on this range of ports, we will scan it and see what it
    looks like when scanned.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results after scanning the machine with Nmap is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have these ports open on the machine,
    so we would want to explore this further. The preferred method is to connect to
    the ports manually and grab the banner of these ports, because if we scan the
    ports, they will report back as `tcpwrapped`; therefore, we will look at the ports
    manually. We have a number of methods we could use to connect to this port, and
    for the example in the book, we will use `netcat`. In the terminal window, enter
    `nc <target> 21` to connect to the FTP server; an example of this result is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, the `netcat` command does nothing but returns
    a command prompt, which means that the connection was not successful; yet, when
    we use telnet, the connection is made and then closed immediately. These are the
    types of things you want to look for in your testing, that is, look for things
    that are not behaving as they should be. When we scan the machine, we see that
    there are open ports; yet, when we attempt to connect to these identified open
    ports, we are not successful. This should not happen and, as such, is suspicious.
    It is important to remember that if it does not behave normal even though it has
    open ports, there is a good chance that you have encountered a honeypot. What
    about the honeypot itself? An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the tool shows the connection attempts; even
    though the user does not get a connection, the honeypot still records it.
  prefs: []
  type: TYPE_NORMAL
- en: The next honeypot we will look at is the **Labrea** honeypot. Labrea provides
    a number of mechanisms that can be used if a malware communicates with the machine.
    The Labrea tool is available as a Debian package. As we have used Debian a number
    of times throughout the book, we will use it now to configure and set up the Labrea
    honeypot so that we can identify what it will look like if we encounter it when
    we are doing our testing.
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal window of the Debian machine, enter `apt-get install labrea`
    to install the package. Once the software has installed, you can view the configuration
    file if you like. As it might not be located in the same place when you install
    the package, you can enter `find / -name labrea.conf` to locate the file and then
    open it in the editor of your choice. There is no need to change any configuration
    as it is set and ready to run once you install the package.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a note of caution, the Labrea tool will take up any IP address that is not
    used on the network. Therefore, you might want to configure a range of IP addresses
    as being excluded from the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are ready to run the tool in the terminal window, enter `labrea –v
    –i eth0 -sz -d -n <target> -o`. We will not review the options, but you are encouraged
    to review them on your own. We have set the output to be written to the screen,
    so we will see the output of anything that the Labrea tool intercepts. An example
    of the output of the command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One thing to note in the previous screenshot is the fact that the configuration
    file has been set to only respond to `1-3000` ports. Next, we need to see how
    the honeypot will respond on the network. We will use the Kali Linux machine;
    in a terminal window in Kali, enter `ping –c 7 <target>` where the target is any
    IP address of your target network.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this for the `192.168.177` network is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, the first ping request comes back as unreachable.
    Therefore, there is no host there. The machine responds on the fourth ping; this
    is a response that is coming from the Labrea honeypot. We can verify this by referring
    to the terminal window where we started the program. An example of this is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see the real power of the Labrea honeypot, we will use one of the tools
    in the Kali Linux distribution to ping a range of IP addresses. In the Kali Linux
    terminal, enter `fping –g <target IP block>`. An example of a portion of the results
    of this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This shows that the Labrea honeypot has created a decoy presence of all of the
    possible machines on the `192.168.177` subnet; these machines will appear to be
    live machines. This is to solicit connections to these IP addresses as they would
    be malicious.
  prefs: []
  type: TYPE_NORMAL
- en: The Labrea honeypot uses a technique called **tarpitting**, which causes the
    connections to take a very long time. As we have shown that there are a number
    of decoy machines out there, we will scan one of them now. In the Kali machine,
    enter `nmap –sS <target ip address> -Pn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results of a scan of one of the decoy machines is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another response that we want to note is that of connecting to the machine
    using `netcat`; we will attempt this now. In the Kali machine, enter `nc <target
    IP address> 445`. An example of the results when we manually connect is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, every connection is detected by the honeypot
    and placed into the tarpit, making it take more time and trapping the communications
    to the machine. To research and learn more about Labrea, refer to [http://sourceforge.net/projects/labrea/](http://sourceforge.net/projects/labrea/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next honeypot we will look at is the commercial product **KFSensor**. You
    can find out more about it at [http://www.keyfocus.net/kfsensor/](http://www.keyfocus.net/kfsensor/).
    The site will require that you register on it to download the tool. Once you have
    downloaded it, you need to install it on a Windows system. An example of the interface
    of the tool is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have numerous ports that are open via the
    honeypot, so the next step is to check and see what it would return once it is
    scanned. Remember that we want to perform our testing so that we know what to
    expect when we encounter a network with this honeypot. Furthermore, we want to
    ensure that we note the artifacts that can help us identify whether KFSensor is
    deployed on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an `Nmap` scan directed at the honeypot is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have the ports open, but `Nmap` is reporting
    them as `tcpwrapped`. This is what it looks like when we do the `Nmap` scan, so
    what does it look like on the target? Moreover, what does the honeypot show? An
    example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An added benefit of the tool is the fact that it also has numerous UDP ports
    open, and as such provides a very effective honeypot. An example of the UDP ports
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating decoys and honeypots](img/477-1_13_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is just a look at some of the many different honeypots that are available,
    and as such, you should practice with the different ones on your testing range
    and document how each of them behave once they are deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking the cyber range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have mentioned earlier, the goal of building our pentesting ranges is
    to practice our skills. Therefore, we need to approach the architecture that we
    created and attack it at every location and entry point. Furthermore, it is very
    important that we practice attacking the targets directly, that is, on a flat
    network. Once we have attacked and identified the reactions of the targets from
    the different types of attacks, we change the approach and attack through the
    layered architecture to see what the reactions are and make a comparison of the
    results from the different locations.
  prefs: []
  type: TYPE_NORMAL
- en: Recording the attack data for further training and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have built and attacked the range, it is highly recommended that you
    record the attacks so that you can use them to practice with and, more importantly,
    for training purposes. Each time you carry out attacks, you are creating extremely
    valuable data that should be captured and used again. One of the easiest ways
    to capture the data is to use Wireshark. Once you have captured the data, save
    it, and then you can use a tool to replay the captured traffic. There are a number
    of ways in which you can accomplish this. One of the easiest ways is to use the
    **tcpreplay** tool; it is part of the Kali Linux distribution. Additionally, there
    are a number of packet traces you can download that cover many different attacks
    if you prefer to not create your own. An example of the command used to replay
    the file from one of the earlier DEFCON conferences is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording the attack data for further training and analysis](img/477-1_13_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For those of you who want to use a GUI tool, there are a number of them to
    choose from. A free one that works very well is Colasoft Packet Player from Colasoft;
    you can download it from [http://www.colasoft.com](http://www.colasoft.com). An
    example of this tool being used to replay the DEFCON packet capture is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording the attack data for further training and analysis](img/477-1_13_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, you can set a number of different playback
    speeds, and in the **Burst** mode, the playback will be as fast as the network
    card can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the creation of a layered architecture and
    the need for building segmented networks in our testing. Following the discussion
    of creating a layered architecture, we looked at the integration of decoys and
    honeypots to include the BackOfficer Friendly tool, Labrea tarpit, and KFSensor.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we looked at the process of attacking our architecture and expressed
    the technique of attacking the targets directly and on a flat network before we
    add protections and layers to penetrate them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter and looked at recording the attack data and also
    replaying the files that we created or downloaded from the Internet on our network
    using the tcpreplay command-line tool and the Colasoft Packet Player GUI tool.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter and the book. Remember that the testing you do is
    all about being prepared. When you build your pen testing labs, you are creating
    an environment that you can use for many years to practice your skills. Once the
    architecture is developed, it is just a matter of adding different devices to
    your architecture to serve as your targets for practice. Good luck in your **pwning**
    of networks and systems!
  prefs: []
  type: TYPE_NORMAL
