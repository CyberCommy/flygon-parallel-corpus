- en: Chapter 2. Models in MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the chapter, we will be discussing what Model is in the MVC structure,
    what its purpose is, what its role is in the SOLID design pattern, how Laravel
    defines it, and the advantages of Laravel's Model layers and Eloquent ORM. We
    will also discuss Laravel's classes related to handling data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of the Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The roles of the Model in a solid MVC design pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model and Model Instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Laravel defines the Model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database-related classes of Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a Model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Model is that part of the Model-View-Controller design pattern that we can
    simply describe as the layer of the design pattern that handles the management
    of the data, which is received from the corresponding layers and then sent back
    to those layers. One thing to note here is that the Model does not know where
    the data comes from and how it is received.
  prefs: []
  type: TYPE_NORMAL
- en: In simple words, we can say that the Model implements the business logic of
    the application. The Model is responsible for fetching the data and converting
    it into more meaningful data that can be managed by other layers of the application
    and sending it back to corresponding layers. The Model is another name for the
    domain layer or business layer of an application.
  prefs: []
  type: TYPE_NORMAL
- en: '![What is a Model?](Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Purposes of the Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Model in an application manages all of the dynamic data (anything that's
    not hardcoded and comes from a database driver) and lets other related components
    of the application know about the changes. For example, let's say that there is
    a news article in your database. If you alter it from the database manually, when
    a route is called—and due to this request—the Controller requests for the data
    over the Model after the request from the Routing handler, and the Controller
    receives the updated data from the Model. As a result, it sends this updated data
    to the View, and the end user sees the changes from the response. All of these
    data-related interactions are the tasks of the Model. This "data" that the Model
    handles does not always have to be database related. In some implementations,
    the Model can also be used to handle some temporary session variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic purposes of the Model in a general MVC pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To fetch the data using a specified (database) driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To validate the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To store the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To update the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To delete the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create conditional relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To monitor the file I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To interact with third-party web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To handle caches and sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, if you follow with an MVC pattern consistently, the Model covers
    a huge percentage of the application's logic. In modern frameworks, there is a
    common mistake about the Model that is made by users when learning design patterns.
    They usually confuse the Model with Model Instances. Although they are quite similar,
    they have different meanings.
  prefs: []
  type: TYPE_NORMAL
- en: Model instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your application, there will usually be more than one data structure to manage.
    For example, let's say you are running a blog. In a simple blog system, there
    are authors, blog posts, tags, and comments. Let's say you want to update a blog
    post; how do you define that the data you want to update is for the blog posts?
    This is where Model Instances come handy.
  prefs: []
  type: TYPE_NORMAL
- en: Model Instances are simple classes that mostly extend from the Model layer of
    the application. These instances separate the data logic for each section of your
    application. In our example, we have four sections to handle (users, posts, tags,
    and comments). If we are going to handle these using the Model, we have to create
    at least four instances (we will cover why it is at least four and not exactly
    four in the *Relationships* section that is under *Eloquent ORM* in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: '![Model instances](Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the diagram, the Controller interacts with the Model Instance
    to fetch data. Since Model Instances extend from the Model itself, instead of
    raw Model output, the Controller can customize it or add other layers (such as
    Validation) to the process.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you want to fetch the user who has the username `George` . If no Validation
    layer has been added from the Model Instance to the database, the `username` parameter
    will go to the database directly, which could be harmful. If you did add a validation
    layer on your Model Instance (which checks if the username parameter is a clean
    string), even if the parameter was SQL injection code, it would first be filtered
    by the validation layer instead of going to the database directly and then be
    detected as harmful code. Then, the Model Instance will return a message or an
    exception to the Controller that the parameter is invalid. Then, the Controller
    will send a corresponding message to the View, and from there, the message will
    be shown to the end user. In this process, optionally, the application might even
    fire an Event to log this attempt.
  prefs: []
  type: TYPE_NORMAL
- en: The Model in Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you recall, we mentioned earlier in this chapter that there are many important
    jobs that the Model needs to handle. Laravel 4 does not use the MVC pattern directly,
    but it extends the pattern further. For example, Validation—which is part of the
    Model in the solid MVC pattern—has its own class, but it's not part of the Model
    itself. The database connection layer has its own classes for each database driver,
    but they are not packed in the Model directly. This brings testability, modularity,
    and extensibility to the Models.
  prefs: []
  type: TYPE_NORMAL
- en: The Laravel Model structure focuses more on the database processes directly,
    and it is separated from other purposes. The other purposes are categorized as
    Facades.
  prefs: []
  type: TYPE_NORMAL
- en: To access the database, Laravel has two classes. The first one is Fluent Query
    Builder and the second one is Eloquent ORM.
  prefs: []
  type: TYPE_NORMAL
- en: Fluent Query Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fluent is the query builder class of Laravel 4\. Fluent Query Builder handles
    base database query actions using PHP Data Objects in the backend, and it can
    be used with almost any database driver. Let's say that you need to change the
    database driver from SQLite to MySQL; if you've written your queries using Fluent,
    then you mostly don't need to rewrite or alter your code unless you've written
    raw queries using `DB::raw()` . Fluent handles this behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the Eloquent Model of Laravel 4 (which can be found
    in the `Vendor\Laravel\Framework\src\Illuminate\Database\Query` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Eloquent Model uses some classes, such as `Database` , `ConnectionInterface`
    , `Collection` , `Grammar` , and `Processor` . All of these are required to standardize
    database queries in the backend, cache the queries if required, and return the
    output as a collection object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some basic examples that present how the queries look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get all of the names and show them one by one from a `users` table, use
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `get()` method fetches all of the records from the table in the form of
    a collection. With a `foreach()` loop, the records are looped, and then we access
    each name column using `->name` (an object). If the column we want to access is
    an e-mail, then it'll look like `$user->email` .
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch the first user named `Arda` from the `users` table, use the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `where()` method filters the query with given parameters. The `first()`
    method directly returns the collection object of a single item from the first
    matched element. If there were two users named `Arda` , only the first one would
    be caught and set to the `$user` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to use `OR` statements in the `where` clauses, you could use
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To use operators in the `where` clauses, the following third parameter should
    be added between the column name and variable that is to be filtered:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using offsets and limits, execute the following query:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This produces `SELECT` `* FROM` users `LIMIT 10,5` in MySQL. The `skip($integer)`
    method will set an offset to the query, and `take($ integer)` will limit the output
    by the natural number that has been set as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also limit what is to be fetched using the `select()` method and use
    the following `join` statements easily in Fluent Query Builder:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These methods simply join the `users` table with contacts, then join orders
    with users, and then get the user ID, the phone column from the `contacts` table,
    and the price column from the `orders` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can group queries by parameters easily, using closure functions. This will
    allow you to write more complicated queries with ease, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use aggregations in the query builder (such as `count` , `max`
    , `min` , `avg` , and `sum` ) as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, such builders might not be enough, or you might want to run raw
    queries. You can also wrap your raw queries inside of Fluent as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert new data into the table, use the `insert()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To update a row(s) from a table, use the `update()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete a row(s) from a table, use the `delete()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Benefiting of `CachingIterator` that''s used the `Collection` class, Fluent
    Query Builder can also cache results upon calling using the method `remember()`
    :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: After this query is called once, it's cached for 10 minutes; if this query is
    called again, instead of fetching from the database, it'll fetch directly from
    the cache instead, until 10 minutes have passed.
  prefs: []
  type: TYPE_NORMAL
- en: Eloquent ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eloquent ORM is the Active Record implementation in Laravel. It's simple, powerful,
    and easy to handle and manage.
  prefs: []
  type: TYPE_NORMAL
- en: For each database table, you'll need a new Model Instance to benefit from Eloquent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have a `posts` table, and you want to benefit from Eloquent;
    you need to navigate to `app/models` and save this file as `Post.php` (the singular
    form of the table name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! You're ready to benefit from Eloquent methods for your table.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel allows you to assign any table to any Eloquent Model Instance. It's
    not necessary, but it's a good habit to name Model Instances with the singular
    name of the corresponding table. This name should be a singular form of the table
    name it represents. If you have to use a name that does not follow this general
    rule, you can do so by setting a protected `$table` variable inside of the Model
    Instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can assign a table to any desired Model Instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's not necessary to add the instance into the `models` folder in `app` . As
    long as you've set an `autoload` path in `composer.json` , you can get rid of
    this folder completely and add it wherever you like. This will bring flexibility
    to your architecture during programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the following `Model` class of Laravel 4 that we
    just extended from (which is in the `Vendor\Laravel\Framework\src\Illuminate\Database\Eloquent`
    folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Eloquent uses `Illuminate\Database\Query\Builder` , which is the Fluent Query
    Builder that we described earlier, and its methods are defined inside it. Thanks
    to this, all of the methods that can be defined in Fluent Query Builder can also
    be used in Eloquent ORM.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all of the used classes are split according to their purpose.
    This brings a better **Abstraction** and **Reusability** to the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Eloquent ORM has other benefits in addition to Fluent Query Builder. The major
    benefit is Model Instance Relations, which allows Fluent Query Builder to form
    a relationship with other Model Instances easily. Let''s say you have `users`
    and `posts` tables, and you want to get the posts made by a user with an ID of
    `5` . After the relationship is set, the collection of these posts can be fetched
    with this code easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This couldn''t be easier, could it? There are three major relationship types:
    one-to-one, one-to-many, and many-to-many. In addition to these, Laravel 4 also
    has the has-many-through and morph-to-many (many-to-many polymorphic) relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '**One-to-one relationships** : These are used when both Models have only one
    element of each other. Let''s say you have a `User` Model, which should only have
    one element in your `Phone` Model. In this case, the relationship will be defined
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**One-to-many relationships** : These are used when a Model has more than one
    element of another. Let''s say you have a news system with categories. A category
    can have more than one item. In this case, the relationship will be defined as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Many-to-many relationships** : These are used when two Models have more than
    one element of each other. Let''s say you have `Blog` and `Tag` Models. A blog
    post might have more than one tag, and a tag might be assigned to more than one
    blog post. For such instances, a pivot table is used along with Many to Many Relationships.
    The relationship can be defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Laravel 4 adds some flexibility and additional relationships to these known
    relationships. They are "has-many-through" and "polymorphic relationships".
  prefs: []
  type: TYPE_NORMAL
- en: '**Has-many-through relationships** : These are more like shortcuts. Let''s
    say you have a `Country` Model, `User` Model, and `Post` Model. A country may
    have more than one user, and a user may have more than one post. If you want to
    access all of the posts created by the users of a specific country, you need to
    define the relationship as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Polymorphic relationships** : These are featured in Laravel v4.1\. Let''s
    say you have a `News` Model, `Blog` Model, and `Photo` Model. This `Photo` Model
    holds images for both `News` and `Blog` , but how do you relate this or identify
    a specific photo that is either for blogs or posts? This can be done easily. It
    needs to be set as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The keyword `imageable` , which will describe the owner of the image, is not
    a must; it could be anything, but you need to set it as a method name and put
    it as a second parameter into `morphMany` relationship definitions. This helps
    us understand how we''re going to access the owner of the photo. This way, we
    can call this easily from the `Photo` Model without needing to understand whether
    its owner is `Blog` or `News` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, you'll need to add two additional columns to your `Photo` Model's
    table. These columns are `imageable_id` and `imageable_type` . The section `imageable`
    is the name of the morphing method, and the suffix's ID and type are the keys
    that will define the exact ID and type of the item that it will be morphed to.
  prefs: []
  type: TYPE_NORMAL
- en: Mass assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating a new Model Instance (when inserting or updating data), we pass
    a variable that is set as an array with attribute names and values. These attributes
    are then assigned to the Model by mass assignment. If we blindly add all of the
    inputs into mass assignment, this will become a serious security issue. In addition
    to querying methods, Eloquent ORM also helps us with mass assignment. Let''s say
    you don''t want the column e-mail in your `User` Model (`Object` ) to be altered
    in any way (blacklist), or you just want the title and body columns to be altered
    in your `Post` Model (whitelist). This can be done by setting protected `$fillable`
    and `$guarded` variables in your Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Soft deleting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's say you have a `posts` table, and let's assume the data inside this table
    is important. Even if the `delete` command is run from the Model, you want to
    keep the deleted data inside your database just in case. In such cases, you can
    use soft deletes with Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: Soft deleting doesn't actually delete the row from the table; instead, it adds
    a key if the data is actually deleted. When a soft deletion is made, a new column
    called `deleted_at` is filled with a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: To enable the soft deletes, you need to first add a timestamp column called
    `deleted_at` to your table (you could do this by adding `$table->softDeletes()`
    to your migration), then set a variable called `$softDelete` to `true` in your
    Model Instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example Model Instance for soft deletes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run the `delete()` method in this model, instead of actually deleting
    the column, it will add a `deleted_at` timestamp to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you run the `all()` or `get()` method, the soft-deleted columns won't
    be listed, like they have actually been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'After such deletes, you might want to get results along with soft-deleted rows.
    To do this, use the `withTrashed()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In some cases, you may want to fetch only soft-deleted rows. To do this, use
    the `onlyTrashed()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To restore the soft-deleted rows, use the `restore()` method. To restore all
    soft-deleted posts, run a code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To hard delete (totally delete) the soft-deleted rows from a table, use the
    `forceDelete()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When fetching rows from a table (including soft deletes), you may want to check
    whether they have been soft deleted or not. This check is done by running the
    `trashed()` method on collection rows. This method will return a Boolean value.
    If true, it means the row has been soft deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Eager loading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Eloquent ORM also brings a neat solution to the N+1 query problem with **Eager
    Loading** . Let''s assume that you have a query and loop like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, to access the images, one more query is executed for each loop
    in the backend. This will exhaust the database drastically, so to prevent this,
    we will use the `with()` method on the query. This will fetch all of the blogs
    and images, relate them in the backend, and serve them as a collection directly.
    Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This way, the querying will be much faster, and fewer resources will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main benefits of Eloquent ORM are seen when you set `$timestamps` to `true`
    (which is the default); you will have two columns, the first is `created_at` and
    the second is `updated_at` . These two columns keep the creation and last update
    times of data as timestamps and update them automatically on the creation or update
    of each row.
  prefs: []
  type: TYPE_NORMAL
- en: Query scopes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say that you repeat a `where` condition several times because it''s
    a commonly used clause in your application and this condition means something.
    Let''s say you want to get all of the blog posts that have more than 100 views
    (we''ll call it popular posts). Without using scopes, you''d get the posts in
    the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: However, in the example, you'll be repeating this through your application over
    and over again. So, why not set this as a scope? You can do this easily using
    Laravel's Query Scope feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `Blog` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, you can use your scope easily with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also chain the post as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Accessors and mutators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the features of Eloquent ORM is accessors and mutators. Let''s say you
    have a column called `name` on your table, and on calling this column, you want
    to pass PHP''s `ucfirst()` method to uppercase its name. This can be done by simply
    adding the following lines of code to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s consider the opposite. Each time you save or update the name column,
    you want to pass the PHP `strtolower()` function to the column (you want to mutate
    the input). This can be done by adding the following lines of code to the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that the method name should be CamelCased even though the column name is
    `snake_cased` . If your column name is `first_name` , the getter method name should
    be `getFirstNameAttribute` .
  prefs: []
  type: TYPE_NORMAL
- en: Model events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Model events play an important part in the Laravel design pattern. Using Model
    events, you can call any method right after the event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that you have set a cache for your comments, and you want to flush
    the cache each time a comment is deleted. How can you catch the comment's deletion
    event and do something there? Should there be various places in the application
    that such comments can be deleted? Is there a way to catch exact the "deleting"
    or "deleted" event? In such case, the Model events come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Models hold the following methods: `creating` , `created` , `updating` , `updated`
    , `saving` , `saved` , `deleting` , `deleted` , `restoring` , and `restored` .'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a new item is being saved for the first time, the creating and created
    events will fire. If you are updating a current item on the Model, the `updating`
    /`updated` events will fire. Whether you are creating a new item or updating a
    current one, the `saving` /`saved` events will fire.
  prefs: []
  type: TYPE_NORMAL
- en: If `false` is returned from the `creating` , `updating` , `saving` , or `deleting`
    event, the action will be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s check whether a user has been created. If its first name
    is `Hybrid` , we''ll cancel the creation. To add this condition, include the following
    lines of code in your `User` Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Model observers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Model observers are quite similar to Model Events, but the approach is a little
    bit different. Instead of defining all events (`creating` , `created` , `updating`
    , `updated` , `saving` , `saved` , `deleting` , `deleted` , `restoring` , and
    `restored` ) inside of the Model, it "abstracts" the logic of the events to a
    different class and "observes" it with the `observe()` method. Let''s assume we
    have a Model event like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep the abstraction, it will be much better to wrap all of these events
    and separate their logic from the Model. In an observer, these events will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can imagine, you can put this class anywhere in your application. You
    can even group all of these events in a separate folder for a better architectural
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to register this event `Observer` class to a Model. This can
    be done with the following simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage of this approach is that you can use observers in more than
    one Model and register more than one observer to a Model this way.
  prefs: []
  type: TYPE_NORMAL
- en: Migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Migrations are easy tools to version control your database. Let's say there
    is a place where you need to add a new column to the table or roll back to the
    previous state because you did something wrong or the link to your application
    broke. Without migrations, these are tedious tasks to handle, but with migrations,
    your life will be much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various reasons to use migrations; some of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll benefit from this versioning system. If you made a mistake or need to
    roll back to a previous state, you can do so with only a single command using
    migrations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of migrations for alteration will bring about flexibility. The migrations
    that are written will work on all supported database drivers, so you won't need
    to rewrite database code again and again for different drivers. Laravel will handle
    this in the background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are quite easy to generate. Using the migration commands of the Laravel
    `php` client, which is called `artisan` , you can manage all of your application's
    migrations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is what a migration file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `up()` method runs when the migration is run forward (a new migration).
    The `down()` method runs when the migration is run backward, meaning it reverses
    or resets (reverses and reruns) the migration.
  prefs: []
  type: TYPE_NORMAL
- en: After these methods are triggered via the `artisan` command, it runs the method
    up or down, corresponding the parameters of the `artisan` command, and returns
    the status of the message.
  prefs: []
  type: TYPE_NORMAL
- en: Database seeders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say you've programmed a blog application. You need to show what it's capable
    of, but there are no example blog posts to show the awesome blog you've programmed.
    This is where seeders come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database seeders are some simple classes that fill random data in a specified
    table. The seeder class has a simple method called `run()` to make this seeding(s).
    The following is what a seeder looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When you call this class from a terminal using the `artisan` command, it connects
    to the database and fills it with the given data. After this attempt, it returns
    a command message to the user over the terminal about the status of the seeding.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com) . If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the role of the Model in the MVC pattern
    and how Laravel 4 "defines" the Model by extending its roles to various classes.
    We've also seen what the Model components of Laravel 4 are capable of with examples.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn about the role of the View and how it interacts
    with end users and other aspects of the application using the MVC pattern on Laravel
    4.
  prefs: []
  type: TYPE_NORMAL
