- en: Pentesting SQL and XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss some serious attacks on a web application.
    You must have heard about incidents such as data theft, the cracking of usernames
    and passwords, the defacement of websites, and so on. These are known to occur
    mainly due to the vulnerabilities that exist in web applications, which are usually
    performed with SQL injection and XSS attacks. In [Chapter 7](d120a8af-c365-43e1-9b66-1328a1e3ea74.xhtml),
    *Foot Printing a Web Server and a Web Application*, you learned how to see which
    database software is being used and which OS is running on the web server. Now,
    we will proceed with our attacks one by one. In this chapter, we will cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL injection attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of SQL injection attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An SQL injection attack by Python script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cross-site scripting attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An XSS attack by Python script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the SQL injection attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL injection is a technique, or you could say, an expert technique, that is
    used to steal data by taking advantage of a nonvalidated input vulnerability.
    The method by which a web application works can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f55d0252-f3f7-486f-ac45-48329533f0c1.png)'
  prefs: []
  type: TYPE_IMG
- en: The method by which a web application works
  prefs: []
  type: TYPE_NORMAL
- en: If our query were not validated, then it would go to the database for execution,
    and then it might reveal sensitive data or delete data. How data-driven websites
    work is shown in the preceding screenshot. In this screenshot, we are shown that
    the client opens the web page on a local computer. The host is connected to a
    web server via the internet. The preceding screenshot clearly shows the method
    by which the web application interacts with the database of a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Types of SQL injections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SQL injection attacks can be categorized into the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blind SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple SQL injection attack contains tautology. In tautology, injecting statements
    are always `true`. A union select statement returns the union of the intended
    data with the targeted data. We will look at SQL injection in detail in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Blind SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this attack, the attacker takes advantage of the error messages generated
    by the database server after performing an SQL injection attack. The attacker
    gleans data by asking a series of true or false questions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the SQL injection attack by a Python script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All SQL injection attacks can be carried out manually. However, you can use
    Python programming to automate the attack. If you are a good pentester and know
    how to perform attacks manually, then you can make your own program check this.
  prefs: []
  type: TYPE_NORMAL
- en: In order to obtain the username and password of a website, we must have the
    URL of the admin or login console page. The client does not provide the link to
    the admin console page on the website.
  prefs: []
  type: TYPE_NORMAL
- en: Here, Google fails to provide the login page for a particular website. Our first
    step is to find the admin console page. I remembered that, years ago, I used the
    URLs `http://192.168.0.4/login.php` and `http://192.168.0.4/login.html`. Now,
    web developers have become smart, and they use different names to hide the login
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that I have more than 300 links to try. If I try doing this manually,
    it would take around one to two days to obtain the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a small program, `login1.py`, to find the login page
    for PHP websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For a better understanding, assume that the preceding code is an empty pistol.
    The `mohit.raj` file is like the magazine of a pistol, and `data_handle.py` is
    like a machine that can be used to put bullets in the magazine.
  prefs: []
  type: TYPE_NORMAL
- en: I have written this code for a PHP-driven website. Here, I imported `httplib`
    and `shelve`. The `url` variable stores the URL of the website entered by the
    user. The `url2` variable stores only the domain name or IP address. The `s =
    shelve.open("mohit.raj",writeback=True)` statement opens the `mohit.raj` file
    that contains a list of the expected login page names that I entered (the expected
    login page) in the file, based on my experience. The `s['php']` variable means
    that `php` is the key name of the list, and `s['php']` is the list saved in the
    shelve file (`mohit.raj`) using the name `'php'`. The `for` loop extracts the
    login page names one by one, and `url_n = url2+a+u` will show the URL for testing.
    An `HTTPConnection` instance represents one transaction with an HTTP server. The
    `http_r = httplib.HTTPConnection(url2)` statement only needs the domain name;
    this is why only the `url2` variable has been passed as an argument and, by default,
    it uses port `80` and stores the result in the `http_r` variable. The `http_r.request("GET",u)`
    statement makes the network request, and the `http_r.getresponse()` statement
    extracts the response.
  prefs: []
  type: TYPE_NORMAL
- en: If the return code is `200`, it means that we have succeeded. It will print
    the current URL. If, after this first success, you still want to find more pages,
    you could press the *C* key.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why I used the `httplib` library and not the `urllib`
    library. If you are, then you are thinking along the right lines. Actually, what
    happens is that many websites use redirection for error handling. The `urllib`
    library supports redirection, but `httplib` does not support redirection. Consider
    that when we hit a URL that does not exist, the website (which has custom error
    handling) redirects the request to another page that contains a message such as
    `Page not found` or `Page does not exist`, that is, a custom 404 page. In this
    case, the HTTP status return code is `200`. In our code, we used `httplib`; this
    doesn't support redirection, so the HTTP status return code, `200`, will not produce.
  prefs: []
  type: TYPE_NORMAL
- en: In order to manage the `mohit.raj` database file, I made a Python program, `data_handler.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to see the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57f91848-73a8-42ac-b1fe-54b136736f87.png)'
  prefs: []
  type: TYPE_IMG
- en: The login.py program showing the login page
  prefs: []
  type: TYPE_NORMAL
- en: Here, the login pages are `http://192.168.0.6/admin` and `http://192.168.0.6/admin/index.php`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's check the `data_handler.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I hope you remember the port scanner program in which we used a database file
    that stored the port number with the port description. Here, a list named `php`
    is used and the output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1116c28a-e909-4fea-aa5e-2ea04a3434a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing mohit.raj by data_handler.py
  prefs: []
  type: TYPE_NORMAL
- en: The previous program is for PHP. We can also make programs for different web
    server languages such as ASP.NET.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to perform an SQL injection attack that is tautology based. Tautology-based
    SQL injection is usually used to bypass user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume that the database contains usernames and passwords. In
    this case, the web application programming code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$uname` variable stores the username, and the `$pass` variable stores
    the password. If a user enters a valid username and password, then `count(*)`
    will contain one record. If `count(*) > 0`, then the user can access their account.
    If an attacker enters `1" or "1"="1` in the username and password fields, then
    the query will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `User` and `Pass` fields will remain `true`, and the `count(*)` field will
    automatically become `count(*)> 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the `sql_form6.py` code and analyze it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be able to understand the program up until the `for` loop. The `pass_exp`
    variable represents the list that contains the password attacks based on tautology.
    The `user1` and `pass1` variables ask the user to enter the username and password
    field as shown by form. The `flag=0` variable makes the `while` loop continue,
    and the `p` variable initializes as `0`. Inside the `while` loop, which is the
    `br.select_form(nr=0)` statement, select the HTML form one. Actually, this code
    is based on the assumption that, when you go to the login screen, it will contain
    the login username and password fields in the first HTML form. The `br.form[user1]
    = ''admin''` statement stores the username; actually, I used it to make the code
    simple and understandable. The `br.form[pass1] = pass_exp[p]` statement shows
    the element of the `pass_exp` list passing to `br.form[pass1]`. Next, the `for`
    loop section converts the output into string format. How do we know if the password
    has been accepted successfully? You have seen that, after successfully logging
    in to the page, you will find a logout or sign out option on the page. I stored
    different combinations of the logout and sign out options in a list named `list`.
    The `data1 = data.lower()` statement changes all of the data to lowercase. This
    will make it easy to find the logout or sign out terms in the data. Now, let''s
    look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding piece of code will find any value of the `list` in `data1`. If
    a match is found, then `flag` becomes `1`; this will break the `while` loop. Next,
    the `if flag ==1` statement will show successful attempts. Let''s look at the
    next line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding piece of code shows that if all of the values of the `pass_exp`
    list are over, then the `while` loop will break.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s check the output of the code in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28f33c91-bf6d-417a-b141-d36043aad1ab.png)'
  prefs: []
  type: TYPE_IMG
- en: A SQL injection attack
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the output of the code. This is very basic code
    to clear the logic of the program. Now, I want you to modify the code and make
    a new code in which you can provide list values to the password as well as to
    the username.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write different code (`sql_form7.py`) for the username that contains
    `user_exp = [''admin" --'', "admin'' --", ''admin" #'', "admin'' #" ]` and fill
    in anything in the password field. The logic behind this list is that after the
    admin strings `–` or `#` make a comment, the rest of the line is in the SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used one more variable, `form`; in the output, you
    have to select the form name. In the `sql_form6.py` code, I assumed that the username
    and password are contained in the form number `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19af076d-d080-46c5-857b-e5cd0670cc36.png)'
  prefs: []
  type: TYPE_IMG
- en: The SQL injection username query exploitation
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can merge both the `sql_form6.py` and `sql_from7.py` code and make one
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mitigate the preceding SQL injection attack, you have to set a
    filter program that filters the input string entered by the user. In PHP, the `mysql_real_escape_string()` function
    is used to filter. The following screenshot shows us how to use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb29908b-a891-4d3d-bcc6-71308962fd9a.png)'
  prefs: []
  type: TYPE_IMG
- en: The SQL injection filter in PHP
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you have got the idea of how to carry out a SQL injection attack. In
    a SQL injection attack, we have to do a lot of things manually, because there
    are a lot of SQL injection attacks, such as time-based, SQL query-based contained
    order by, union-based, and so on. Every pentester should know how to craft queries
    manually. For one type of attack, you can make a program, but now, different website
    developers use different methods to display data from the database. Some developers
    use HTML forms to display data, and some use simple HTML statements to display
    data. A Python tool called *sqlmap* can do many things. However, sometimes, a
    web application firewall, such as mod security, is present; this does not allow
    queries such as *union* and *order by*. In this situation, you have to craft queries
    manually, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can make a list of crafted queries. When simple queries do not work, you
    can check the behavior of the website. Based on the behavior, you can decide whether
    the query is successful or not. In this instance, Python programming is very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the following steps to make a Python program for a firewall-based
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a list of all of the crafted queries
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply a simple query to a website and observe the response of the website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use this `attempt not successful` response to unsuccessful attempts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the listed queries one by one and match the response by the program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the response is not matched, then check the query manually
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it appeared to be successful, then stop the program
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps are used to show only whether the crafted query is successful
    or not. The desired result can be found only by viewing the website.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about cross-site scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the **Cross-Site Scripting** (**XSS**) attack.
    XSS attacks exploit vulnerabilities in dynamically-generated web pages, and this
    happens when invalidated input data is included in the dynamic content that is
    sent to the user's browser for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cross-site attacks are of the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent or stored XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonpersistent or reflected XSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent or stored XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this type of attack, the attacker's input is stored in the web server. In
    several websites, you will have seen comment fields and a message box where you
    can write your comments. After submitting the comment, your comment is shown on
    the display page. Try to think of one instance where your comment becomes part
    of the HTML page of the web server; this means that you have the ability to change
    the web page. If proper validations are not there, then your malicious code can
    be stored in the database, and when it is reflected back on the web page, it produces
    an undesirable effect. It is stored permanently in the database server, and that's
    why it is known as being persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Nonpersistent or reflected XSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this type of attack, the input of the attacker is not stored in the database
    server. The response is returned in the form of an error message. The input is
    given with the URL or in the search field. In this chapter, we will work on stored
    XSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code for the XSS attack. The logic of the code is to
    send an exploit to a website. In the following code, we will attack one field
    of a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code has been written for a website that uses the name and comment fields.
    This small piece of code will give you an idea of how to accomplish the XSS attack.
    Sometimes, when you submit a comment, the website will redirect to the display
    page. That's why we make a comment using the `br.set_handle_redirect(False)` statement.
    In the code, we stored the exploit code in the `mohit.xss` shelve file. The statement
    for the form in `br.forms():` will print the form. By viewing the form, you can
    select the form field which you want to attack. Setting the `flag = 'y'` variable
    makes the `while` loop execute at least once. The interesting thing is that, when
    we used the `br.open(url)` statement, it opened the URL of the website every time
    because, in my dummy website, I used redirection; this means that after submitting
    the form, it will redirect to the display page, which displays the old comments.
    The `br.form[non] = 'aaaaaaa'` statement just fills the `aaaaaa` string in the
    input field. The `br.form[att] = s['xss'][p]` statement shows that the selected
    field will be filled by the XSS exploit string. The `ch = raw_input("Do you continue
    press y ")` statement asks for user input for the next exploit. If a user enters
    `y` or `Y`, `ch.lower()` makes it `y`, keeping the `while` loop alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time for the output. The following screenshot shows the Index page
    of `192.168.0.5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5916f5a3-1575-4f97-a56c-b00cc712e959.png)'
  prefs: []
  type: TYPE_IMG
- en: The Index page of the website
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to see the code''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e03ccebe-7cd9-4ad8-9a7e-3595379b560f.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of the code
  prefs: []
  type: TYPE_NORMAL
- en: You can see the output of the code in the preceding screenshot. When I press
    the *y* key, the code sends the XSS exploit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the output of the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83e5f7e2-45c0-492a-bf07-10d5f1d35d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of the website
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that the code is successfully sending the output to the website.
    However, this field is not affected by the XSS attack because of the secure coding
    in PHP. At the end of the chapter, you will see the secure coding of the Comment
    field. Now, run the code and check the name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f13b0f3-0988-4508-9b2d-b84767fa2772.png)'
  prefs: []
  type: TYPE_IMG
- en: A successful attack on the name field
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the code of `xss_data_handler.py`, from which you
    can update `mohit.xss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I hope that you are familiar with the preceding code. Now, look at the output
    of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f10eadf-1cad-4681-99ed-93cea687ba03.png)'
  prefs: []
  type: TYPE_IMG
- en: The output of xss_data_handler.py
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the contents of the `mohit.xss` file; the `xss.py`
    file is limited to two fields. However, now let's look at the code that is not
    limited to two fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `xss_list.py` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code has the ability to attack multiple fields or a single field.
    In this code, we used two lists, `list_a` and `list_n`. The `list_a` list contains
    the field(s) name on which you want to send XSS exploits, and `list_n` contains
    the field(s) name on which you don't want to send XSS exploits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the program. If you understood the `xss.py` program, you
    would have noticed that we made an amendment to `xss.py` to create `xss_list.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I have already explained the significance of `list_a[]` and `list_n[]`. The
    variable field asks the user to enter the total number of form fields in the form
    that is not read-only. The `for i in xrange(0,field):` statement defines for loop
    from 0 to field, running field times, means the total number of field present
    in the form. The `na` variable asks the user to enter the field name, and the
    `ch` variable asks the user, `Do you attack on this field`? This means, if you
    press *y* or *Y*, the entered field would go to `list_a`; otherwise, it would
    go to `list_n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding piece of code is very easy to understand. Two `for` loops for
    two lists are iterated and fill in the form fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7715e22d-362c-4cb7-a710-7c566fd8f98c.png)'
  prefs: []
  type: TYPE_IMG
- en: Form filling to check list_n
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows that the number of form fields is two. The user
    entered the form fields'' names and made them nonattack fields. This simply checks
    the working of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/638f24e0-0c72-43f3-8fce-a679aa9deb98.png)'
  prefs: []
  type: TYPE_IMG
- en: Form filling to check the list_a list
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that the user entered the form field and made
    it attack fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check the response of the website, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c397eb86-585b-4bab-8286-7e3a640f1a36.png)'
  prefs: []
  type: TYPE_IMG
- en: Form fields filled successfully
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows that the code is working fine; the first two
    rows have been filled with the ordinary `aaaaaaa` string. The third and fourth
    rows have been filled by XSS attacks. So far, you have learned how to automate
    the XSS attack. By proper validation and filtration, web developers can protect
    their websites. In the PHP function, the `htmlspecialchars()` string can protect
    your website from an XSS attack. In the preceding screenshot, you can see that
    the Comment field is not affected by an XSS attack. The following screenshot shows
    the coding part of the Comment field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bba3501b-f423-4f0c-a492-32b4c05715e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure showing the htmlspecialchars() function
  prefs: []
  type: TYPE_NORMAL
- en: When you see the view source of the display page, it looks like `&lt;script&gt;alert(1)&lt;/script&gt`;
    the special character `<` is converted into `&lt`, and `>` is converted into `&gt`.
    This conversion is called HTML encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about two major types of web attacks, SQL injection,
    and XSS. In SQL injection, you learned how to find the admin login page using
    Python script. There are lots of different queries for SQL injection and, in this
    chapter, you learned how to crack usernames and passwords based on a tautology.
    In another attack of SQL injection, you learned how to make a comment after a
    valid username. In the XSS, you saw how to apply XSS exploits to the form field,
    and in the `mohit.xss` file, you saw how to add more exploits.
  prefs: []
  type: TYPE_NORMAL
