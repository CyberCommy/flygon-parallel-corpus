- en: Lists and Pointer Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed **lists** in Python, and these are convenient and powerful.
    Normally, most of the time, we use Python's built-in list implementation to store
    any data. However, in this chapter, we will be understanding how lists work and
    will be studying list internals.
  prefs: []
  type: TYPE_NORMAL
- en: Python's list implementation is quite powerful and can encompass several different
    use cases. The concept of a node is very important in lists. We shall discuss
    them in this chapter and will be referring to them throughout the book. Thus,
    we suggest readers study the content of this chapter carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The focus of this chapter will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pointers in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the concept and implementation of nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing singly, doubly, and circularly linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Executing the programs based on the concepts discussed in this chapter will
    help you to better understand them. We have provided the source codes of all the
    programs and concepts in the chapter. We also provide the complete source code
    files on GitHub at the following link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: We assume that you have already installed Python on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's remind you about the concept of pointers as we will be dealing with them
    in this chapter. To begin with, imagine that you have a house that you want to
    sell. Lacking time, you contact an agent to find interested buyers. So, you pick
    up your house and take it over to the agent, who will, in turn, carry the house
    to anybody who may want to buy it. Ludicrous, you say? Now imagine that you have
    a few Python functions that work with images. So, you pass high-resolution image
    data between your functions.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you don't carry your house around. What you do is write the address
    of the house down on a piece of scrap paper and hand it over to the agent. The
    house remains where it is, but the note containing the directions to the house
    is passed around. You might even write it down on several pieces of paper. Each
    one is small enough to fit in your wallet, but they all point to the same house.
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, things are not very different in Python land. Those large image
    files remain in one single place in memory.
  prefs: []
  type: TYPE_NORMAL
- en: What you do is create variables that hold the locations of those images in memory.
    These variables are small and can easily be passed around between different functions.
  prefs: []
  type: TYPE_NORMAL
- en: That is the big benefit of pointers—they allow you to point to a potentially
    large segment of memory with just a simple memory address.
  prefs: []
  type: TYPE_NORMAL
- en: Support for pointers exists in your computer's hardware, where it is known as
    indirect addressing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, you don''t manipulate pointers directly, unlike in some other languages,
    such as C or Pascal. This has led some people to think that pointers aren''t used
    in Python. Nothing could be further from the truth. Consider this assignment in
    the Python interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We would normally say that `s` is a variable of the **set** type. That is, `s`
    is a set. However, this is not strictly true; the variable `s` is rather a reference
    (a *safe* pointer) to a set. The set constructor creates a set somewhere in memory
    and returns the memory location where that set starts. This is what gets stored
    in `s`. Python hides this complexity from us. We can safely assume that `s` is
    a set and that everything works fine.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a sequential list of data. Being sequential means that each element
    is stored right after the previous one in memory. If your array is really big
    and you are low on memory, it could be impossible to find large enough storage
    to fit your entire array. This will lead to problems.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the flip side of the coin is that arrays are very fast. Since each
    element follows on from the previous one in memory, there is no need to jump around
    between different memory locations. This can be a very important point to take
    into consideration when choosing between a list and an array in your own real-world
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed arrays in [Chapter 2](c25be006-f893-4141-99c3-0d726bc31664.xhtml),
    *Python Data Types and Structures*. We looked at the array data type and discussed
    various operations that could be performed on it.
  prefs: []
  type: TYPE_NORMAL
- en: Pointer structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contrary to arrays, pointer structures are lists of items that can be spread
    out in memory. This is because each item contains one or more links to other items
    in the structure. The types of these links are dependent on the type of structures
    we have. If we are dealing with linked lists, then we will have links to the next
    (and possibly previous) items in the structure. In the case of a tree, we have
    parent-child links as well as sibling links.
  prefs: []
  type: TYPE_NORMAL
- en: There are several benefits to pointer structures. First of all, they don't require
    sequential storage space. Secondly, they can start small and grow arbitrarily
    as you add more nodes to the structure. However, this flexibility in pointers
    comes at a cost. We need additional space to store the address. For example, if
    you have a list of integers, each node is going to take up space by storing an
    integer, as well as an additional integer for storing the pointer to the next
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of lists (and several other data structures) is the concept of
    a node. Before we go any further, let us consider this idea for a while.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let us consider an example. We shall create a few strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now you have three variables, each with a unique name, a type, and a value.
    At the moment, there is no way to show the relationships between these variables.
    Nodes allow us to show how these variables relate to each other. A node is a container
    of data, together with one or more links to other nodes. A link is a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple type of node is one that has only a link to the next node. As we know
    about the pointers, the string is not actually stored in the node, but rather
    there is a pointer to the actual string. Consider the example in the following
    diagram, in which there are two nodes. The first node has a pointer to the string
    (**eggs**) stored in the memory and another pointer that stores the address of
    another node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0b94a5a7-7532-473e-91a9-06287979287c.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, the storage requirement for this simple node is two memory addresses.
    The data attributes of the nodes are pointers to the strings **eggs** and **ham**.
  prefs: []
  type: TYPE_NORMAL
- en: Finding endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created three nodes—one containing **eggs**, one **ham**, and another
    **spam**. The **eggs** node points to the **ham** node, which in turn points to
    the **spam** node. But what does the **spam** node point to? Since this is the
    last element in the list, we need to make sure its next member has a value that
    makes this clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we make the last element point to nothing, then we make this fact clear.
    In Python, we will use the special value **None** to denote nothing. Consider
    the following diagram. Node **B** is the last element in the list, and thus it
    is pointing to **None**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/938a3e9b-a0e1-4b54-bfbf-149bcfe6f360.png)'
  prefs: []
  type: TYPE_IMG
- en: The last node has its next point pointing to **None**. As such, it is the last
    node in the chain of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Node class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a simple node implementation of what we have discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The **Next** pointer is initialized to `None`, meaning that unless you change
    the value of **Next**, the node is going to be an endpoint. This is a good idea,
    so that we do not forget to terminate the list properly.
  prefs: []
  type: TYPE_NORMAL
- en: You can add other things to the node class as you see fit. Just make sure that
    you keep in mind the distinction between nodes and data. If your node is going
    to contain customer data, then create a `Customer` class and put all the data
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing you may want to do is implement the `_str_ ` method so that it calls
    the `_str_` method of the contained object is called when the node object is passed
    to print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Other node types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already discussed a node that has a pointer to the next node to link
    the data items, however, it is probably the simplest type of node. Further, depending
    on our requirements, we can create a number of other types of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we want to go from node **A** to node **B**, but at the same time
    we may need to go from node **B** to node **A**. In that case, we add a **Previous**
    pointer in addition to the **Next** pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/70762d9f-ef9c-4282-bbc4-e7d6dca8689b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding diagram, we have created the**Previous** pointer
    in addition to the data and the **Next** pointer. It is also important to note
    that the **N****ext** pointer to **B** is **None**, and the **Previous** pointer
    in node **A** is also **None**—that is to indicate that we have reached the boundary
    of our list at both endpoints. The first node **A**'s previous pointer points
    to **None** since it has no predecessor, just as the last item **B**'s **Next**
    pointer points to **None** because it has no successor node.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The list is an important and popular data structure. There are three kinds of
    the list—singly linked list, doubly linked list, and circular linked list. We
    will discuss these data structures in more detail in this chapter. We will also
    be discussing various important operations such as the `append` operation, `delete`
    operation, and the `traversing` and `searching` operations that can be performed
    on these lists in subsequent subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A singly linked list is a list with only one pointer between two successive
    nodes. It can only be traversed in a single direction; that is, you can go from
    the first node in the list to the last node, but you cannot move from the last
    node to the first node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually use the node class that we created earlier to implement a very
    simple singly linked list. For example, we create three nodes `n1`, `n2`, and
    `n3` that stores three strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we link the nodes together so that they form a chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To traverse the list, you could do something like the following. We start by
    setting the `current` variable to the first item in the list, and then we traverse
    the whole list through a loop as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the loop, we print out the current element after which we set `current` to
    point to the next element in the list. We keep doing this until we have reached
    the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are, however, several problems with this simplistic list implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires too much manual work by the programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is too error prone (this is a consequence of the first point)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Too much of the inner workings of the list is exposed to the programmer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to address all these issues in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Singly linked list class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A list is a separate concept from a node. We start by creating a very simple
    class to hold our list. We start with a constructor that holds a reference to
    the very first node in the list (that is `tail` in the following code). Since
    this list is initially empty, we will start by setting this reference to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The append operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first operation that we need to perform is to append items to the list.
    This operation is sometimes called an insert operation. Here we get a chance to
    hide away the `Node` class. The user of our list class should really never have
    to interact with `Node` objects. These are purely for internal use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first shot at an `append()` method may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We encapsulate data in a node so that it has the next pointer attribute. From
    here, we check if there are any existing nodes in the list (that is, whether `self.tail`
    points to a `Node` or not). If there is `None`, we make the new node the first
    node of the list; otherwise, we find the insertion point by traversing the list
    to the last node, updating the next pointer of the last node to the new node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example code to append three nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'List traversal will work as we discussed before. You will get the first element
    of the list from the list itself, and then traverse the list through the `next` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A faster append operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a big problem with the append method in the previous section: it has
    to traverse the entire list to find the insertion point. This may not be a problem
    when there are just a few items in the list, but it will be a big problem when
    the list is long, as we would need to traverse the whole list to add an item every
    time. Each append will be slightly slower than the previous one. The current implementation
    for the append operation is slowed down by  `O(n)`, which is not desirable in
    the case of a long list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we store not only a reference to the first node in the list but
    also a reference to the last node. That way, we can quickly append a new node
    at the end of the list. The worst-case running time of the append operation is
    now reduced from `O(n)` to `O(1)`. All we have to do is make sure the previous
    last node points to the new node that is about to be appended to the list. Here
    is our updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the convention being used. The point at which we append new nodes
    is through `self.head`. The `self.tail` variable points to the first node in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the size of the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would like to be able to get the size of the list by counting the number
    of nodes. One way we could do this is by traversing the entire list and increasing
    a counter as we go along:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine. However, list traversal is potentially an expensive operation
    that we should avoid wherever we can. So instead, we shall opt for another rewrite
    of the method. We add a size member to the `SinglyLinkedList` class, initializing
    it to `0` in the constructor. Then we increment the size by one in the append
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because we are now only reading the size attribute of the node object, and not
    using a loop to count the number of nodes in the list, we reduce the worst-case
    running time from `O(n)` to `O(1)`.
  prefs: []
  type: TYPE_NORMAL
- en: Improving list traversal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you will notice in the earlier of the list traversal, where we are exposing
    the node class to the client/user. However, it is desirable that the client node
    should not interact with the node object.  We need to use `node.data` to get the
    contents of the node and `node.next` to get the next node. We can access the data
    by creating a method that returns a generator. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, list traversal is much simpler and looks a lot better as well. We can
    completely ignore the fact that there is anything called a node outside of the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that since the `iter()` method yields the data member of the node, our
    client code doesn't need to worry about that at all.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common operation that you will perform on a list is to delete nodes.
    This may seem simple, but we first have to decide how to select a node for deletion.
    Is it going to be determined by the index number or by the data the node contains?
    Here, we will choose to delete a node depending on the data it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a diagram of a special case considered when deleting a node
    from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9a448606-c04c-4256-babb-acae72ff10b6.png)'
  prefs: []
  type: TYPE_IMG
- en: When we want to delete a node that is between two other nodes, all we have to
    do is we make the previous node point to the successor of its next node that is
    to be deleted. That is, we simply cut the node to be deleted out of the chain
    and point directly to the next node as shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the implementation of the `delete()` method may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `delete` operation to remove a node has the time complexity `O(n).`
  prefs: []
  type: TYPE_NORMAL
- en: List search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may also need a way to check whether a list contains an item. This method
    is fairly easy to implement thanks to the `iter()` method we previously wrote.
    Each pass of the loop compares the current data to the data being searched. If
    a match is found, `True` is returned, or else `False` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Clearing a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may need to clear a list quickly; there is a very simple way to do it. We
    can clear a list by simply clearing the pointer head and tail by setting them
    to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Doubly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed the singly linked list and the important operation that can
    be performed on it. Now, we will be focusing on the topic of a doubly linked list
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A doubly linked list is quite similar to the singly linked list in the sense
    that we use the same fundamental concept of string nodes together, as we did in
    a singly linked list. The only difference between a singly linked list and a doubly
    linked list is that in a singly linked list, there is only one link between each
    successive node, whereas, in a doubly linked list, we have two pointers—a pointer
    to the next node and a pointer to the previous node. See the following diagram
    of a *node*; there is a pointer to the next node and the previous node, which
    are set to `None` as there is no node attached to this node. Consider the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9f1ca24a-6fc0-4c9e-9668-ca3fa2df2ee0.png)'
  prefs: []
  type: TYPE_IMG
- en: A node in a singly linked list can only determine the next node associated with
    it. However, there is no way or link to go back from this referenced node. The
    direction of flow is only one way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a doubly linked list, we solve this issue and include the ability not only
    to reference the next node but also to reference the previous node. Consider the
    following example diagram to understand the nature of the linkages between two
    successive nodes. Here, node **A** is referencing node **B**; in addition, there
    is also a link back to node **A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/be75f67d-d6ff-420d-b5e0-1cd2ca679be2.png)'
  prefs: []
  type: TYPE_IMG
- en: With the existence of two pointers that point to the next and previous nodes,
    doubly linked lists become equipped with certain capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists can be traversed in any direction. A node in a doubly linked
    list can be easily referred to its previous node whenever required without having
    a variable to keep track of that node. However, in a singly linked list, it may
    be difficult to move back to the start or beginning of the list in order to make
    some changes at the start of the list, which is very easy now in the case of a
    doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: A doubly linked list node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python code to create a doubly linked list node includes its initializing
    methods, the `prev` pointer, the `next` pointer, and the `data` instance variables.
    When a node is newly created, all these variables default to `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `prev` variable has a reference to the previous node, while the `next` variable
    keeps the reference to the next node, and the `data` variable stores the data.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The doubly linked list class captures the data on which our functions will
    be operating. For the `size` method, we set the count instance variable to `0`;
    it can be used to keep track of the number of items in the linked list. `head` and `tail` will
    point to the head and tail of the list when we begin to insert nodes into the
    list. Consider the following Python code for creating a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We adopt a new convention where `self.head` points to the beginner node of the
    list and `self.tail` points to the latest node added to the list. This is contrary
    to the convention we used in the singly linked list. There are no fixed rules
    as to the naming of the head and tail node pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked lists also require functionalities that return the size of the
    list, insert items into the list, and also delete nodes from the list. We will
    be discussing and providing important functionalities and code on the doubly linked
    list in the following subsections. Let's start with the append operation.
  prefs: []
  type: TYPE_NORMAL
- en: Append operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `append` operation is used to add an element at the end of a list. It is
    important to check whether the `head` of the list is `None`. If it is `None`,
    it means that the list is empty, or else the list has some nodes and a new node
    will be appended to the list. If a new node is to be added to the empty list,
    it should have the `head` pointing to the newly created node, and the tail of
    the list should also point at this newly created node through `head`. By the end
    of these series of steps, the head and tail will now be pointing to the same node.
    The following diagram illustrates the `head` and `tail` pointers of the doubly
    linked list when a new node is added to an empty list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/39e8e53b-5a79-4ba8-912d-6fe36f8871d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code is used to append an item to the doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `If` part of the preceding program is for adding a node to the empty node;
    the `else` part of the preceding program will be executed if the list is not empty.
    If the new node is to be added to a list, the new node''s previous variable is
    to be set to the tail of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The tail''s next pointer (or variable) has to be set to the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we update the tail pointer to point to the new node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since an append operation increases the number of nodes by one, we increase
    the counter by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'A visual representation of the append operation to an existing list is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/65d93f4e-efe7-408f-99c5-e7817f1262f5.png)'
  prefs: []
  type: TYPE_IMG
- en: The delete operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The deletion operation is easier in the doubly linked list compared to the singly
    linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a singly linked list, where we needed to keep track of the previously
    encountered node any time we traverse the whole length of the list, the doubly
    linked list avoids that whole step. This is made possible by the use of the previous
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `delete` operation in a doubly linked list can encounter the following
    four scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The search item to be deleted is not found in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search item to be deleted is located at the start of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search item to be deleted is found at the tail end of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search item to be deleted is located in the middle of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The node to be deleted is identified by matching the data instance variable
    with the data that is passed to the method. If the data matches the data variable
    of a node, that matching node will be deleted. Following is the complete code
    to delete a node from the doubly linked list. We''ll discuss each part of this
    code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we create a `node_deleted` variable to denote the deleted node in
    the list and this is initialized to `False`.  The `node_deleted` variable is set
    to `True` if a matching node is found and subsequently removed. In the delete
    method, the `current` variable is initially set to the `head` of the list (that
    is, it points to the `self.head` of the list). See the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, we use a set of `if...else` statements to search various parts of the
    list to find out the node with the specified data that is to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all,  we search for the data to be deleted at the `head` node and if
    the data is matched at the `head` node, this node would be deleted. Since `current`
    is pointing at `head`, if `current` is `None`, it means that the list is empty
    and has no nodes to find the node to be deleted. The following is its code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if `current` (which now points to head) contains the data being searched
    for, it means that we found the data to be deleted at the `head` node, then `self.head`
    is marked to point to the `current` node. Since there is no node behind `head`
    now, `self.head.prev` is set to `None`. Consider the following code snippet for
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if the node that is to be deleted is found at the `tail` end of
    the list, we delete the last node by setting its previous node pointing to `None`.
    This is the third possible scenario in the `delete` operation in a doubly linked
    list that searches for the node to be deleted might be found at the end of the
    list. The `self.tail` is set to point to `self.tail.prev`, and `self.tail.next`
    is set to `None` as there is no node afterward. Consider the following code fragment
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we search for the node to be deleted by looping through the whole list
    of the nodes. If the data that is to be deleted is matched with a node, that node
    will be deleted. To delete a node, we make the previous node of the `current` node
    to point to the current''s next node using the code  `current.prev.next = current.next`.
    After that step, we make the current''s next node to point to the previous node
    of the `current` node using `current.next.prev = current.prev`. Consider the following
    code snippet for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To better understand the concept of a delete operation in a doubly linked list,
    consider the following example diagram. In the following diagram, there are three
    nodes, **A**, **B**, and **C**. To delete node **B** in the middle of the list,
    we will essentially make **A** point to node **C** as its next node, while making
    **C** point to **A** as its previous node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/53dc9efd-2d80-4221-a5d9-deb25a9d0999.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After such an operation, we end up with the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9f1a8569-6ab4-4de8-b252-429145333607.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the `node_delete` variable is then checked to find out if a node is
    actually deleted or not. If any node is deleted then we decrease the count variable
    by `1`, and this keeps track of the total number of nodes in the list. See the
    following code fragment that decrements the count variable by `1` in case any
    node is deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: List search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The search for an item in a doubly linked list is similar to the way we did
    it in the singly linked list. We use the `iter()` method to check the data in
    all the nodes. As we run a loop through all the data in the list, each node is
    matched with the data passed in the `contain` method. If we find the item in the
    list, `True` is returned, denoting that the item is found, otherwise `False` is
    returned, which means the item was not found in the list. The Python code for
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The append operation in a doubly linked list has running time complexity `O(1)`
    and the delete operation has the complexity  `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Circular lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A circular linked list is a special case of a linked list. In a circular linked
    list, the endpoints are connected to each other. It means that the last node in
    the list points back to the first node. In other words, we can say that in circular
    linked lists all the nodes point to the next node (and the previous node in the
    case of a doubly linked list) and there is no end node, thus no node will point
    to `Null`. Circular lists can be based on both singly and doubly linked lists.
    In the case of a doubly linked circular list, the first node points to the last
    node and the last node points back to the first node. Consider the following diagram
    for the circular linked list, based on a singly linked list where the last node
    **C** is again connected to the first node **A**, thus making a circular list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5226b232-2fca-4ddf-a27f-680cc8883b9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows the concept of the circular linked list based on
    a doubly linked list where the last node **C** is again connected to the first
    node **A** through the `next` pointer. The node **A** is also connected to the
    node **C** through, `previous` pointer, thus making a circular list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3dd10ee2-a107-4e9c-b869-0cd26cfa9414.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we are going to look at an implementation of a singly linked circular
    list. It should be straightforward to implement a doubly linked circular list
    once we understand the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: We can reuse the node class that we created in the subsection—singly linked
    lists. As a matter of fact, we can reuse most parts of the `SinglyLinkedList`
    class as well. So we are going to focus on the methods where the circular list
    implementation differs from the normal singly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Appending elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To append an element to the circular list in a singly linked list, we have
    to just include a new functionality so that the newly added or appended node points
    back to the `tail` node. This is demonstrated in the following code. There is
    one extra line as compared to the singly linked list implementation, which is
    shown in bold font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Deleting an element in a circular list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete a node in a circular list, it looks like we can do it similarly to
    how we did in the case of the append operation—simply make sure that `head` points
    to the `tail`. There is just a single line that needs to change in the delete
    operation. It is only when we remove the `tail` node that we need to make sure
    that the `head` node is updated to point to the new tail node. This would give
    us the following implementation (the bold font code line is an addition to the
    delete operation implementation in the singly linked list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, there is a serious problem with this code. In the case of a circular
    list, we cannot loop until `current` becomes `None`, since the current node will
    never point to the `None` in case of circular linked lists. If you delete an existing
    node, you won't see this, but try deleting a nonexistent node and you will get
    stuck in an indefinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We thus need to find a different way to control the `while` loop. We cannot
    check whether `current` has reached `head`, because then it will never check the
    last node. But we could use `prev`, since it lags behind `current` by one node.
    However, there is a special case. The very first loop iteration, `current`, and
    `prev`, will point to the same node, namely the tail node. We want to ensure that
    the loop runs here since we need to take the one node list into consideration.
    The updated delete method now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Iterating through a circular list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To traverse the circular linked list, it is very convenient as we don''t need
    to look for the starting point. We can start anywhere, and we just need to carefully
    stop traversing when we reach the same node again. We can use the same `iter()`
    method, which we discussed at the start of this chapter. It should work for our
    circular list; the only difference is that we have to mention an exit condition
    when we are iterating through the circular list, or otherwise the program will
    get stuck in a loop and it will run indefinitely. We can make an exit condition
    by using a counter variable. Consider the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once we have printed out 1,000 elements, we break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at linked lists. We studied the concepts that underlie
    lists, such as nodes and pointers to other nodes. We implemented the major operations
    that occur in these types of lists and saw how the worst-case running times compare.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to look at two other data structures that
    are usually implemented using lists—stacks and queues.
  prefs: []
  type: TYPE_NORMAL
