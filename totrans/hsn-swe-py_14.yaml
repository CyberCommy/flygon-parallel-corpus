- en: Testing Data Persistence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repeatable unit testing of code is rarely more critical than in the case of
    data persistence. Code can change or be replaced over time, perhaps even to the
    point of changing to a completely different system, written in a completely different
    language, but once data exists, it can potentially outlive any number of code
    bases that make use of it. The data in a system, it could be argued, is where
    the real business value usually exists, so testing of the processes that interact
    with it, and have the potential to destroy that value, is extremely important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, the bulk of this chapter will be focused on the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the unit tests for the data object and related classes created in this
    iteration:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `hms_artisan` classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `hms_core` classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of those tests with the build process
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s also been enough new functionality added that some attention will
    have to be paid to the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Other effects of the new code on the build process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstration of the new code, and how acceptance of the related stories might
    be facilitated
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the new code affects operations, use, maintenance, and decommissioning concerns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the unit tests
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the process of writing the unit tests for the new data object classes
    can simply follow the process established in previous iterations:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Create the top-level test module for the package being tested.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the child modules of the package being tested, and create a corresponding
    test module for each.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add references to the child test modules to the package test module and import
    their tests.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each child test module:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the module and create test case classes for each item reported as missing
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the module and create tests methods for each member (property or method)
    reported as missing
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several test modules that need to be created, one for each module
    that was created in the `src` directories across the projects this iteration touched,
    yielding the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`hms_core/../data_objects.py → test_hms_core/test_data_objects.py` (already
    tested, but listed here for the sake of having a complete list)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hms_artisan/../data_storage.py → test_hms_artisan/test_data_storage.py`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hms_artisan/../artisan_objects.py → test_hms_artisan/test_artisan_objects.py`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hms_core/../co_objects.py → test_hms_core/test_co_objects.py`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing hms_artisan.data_storage
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unit tests for `hms_artisan.data_storage` are, at this point, all concerned
    with testing the `JSONFileDataStore` class. Because of what that class actually
    does, the typical patterns for unit testing apply poorly, if at all. It has no
    properties to test, and the one class attribute that can be tested (`_file_store_dir`)
    is overridden by derived classes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s probably worth asserting that the default attribute is what''s expected,
    though, since if it doesn''t default to `None`, that could cause failures in derived
    classes and instances of those classes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As far as the testing of methods is concerned, while there are several, they
    are somewhat intertwined, and they also frequently rely upon implementations of
    methods that are abstract themselves and thus not available in the ABC itself:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '`get`, `delete`, and `save` all call the `_load_objects` helper class method'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That `_load_objects` method relies on a concrete implementation of `from_data_dict`
    in order to generate the collection of objects that the other methods refer to
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save` method also requires a concrete implementation of the `to_data_dict`
    method
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since unit testing is about proving predictable functionality, the question
    then becomes: what can we prove?'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, and probably most obvious, item is that object initialization works
    in pretty much the same fashion that it does in `BaseDataObject`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `GoodDateTimes` test values are the same values we used to test `BaseDataObject`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `_create` and `_update` methods aren''t going to be used, we can
    prove that they raise the expected errors when called:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The individual CRUD operations, plus the `_load_objects` method, since they
    are joined at the hip, would end up with a lot of overlap – tests for one method
    would have to execute tests for other methods as part of their own testing process
    in order to really prove that everything was working as expected. Tests of that
    complexity are tedious to write, but more importantly, require more effort and
    discipline to maintain, and are thus more prone to getting out of touch with the
    code they are testing. A better option, in this case, might be to skip those tests,
    and create one larger, unified test of all the related functionality. Python''s
    stock `unittest` module provides a `skip` decorator function that provides the
    ability to tag tests to be skipped by standard unit testing runs, and calling
    that requires that we log a reason for the test being skipped. In this case, the
    reason is that all of the methods in question will be tested in one large pass
    in a different test method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That leaves the responsibility for testing most of `JSONFileDataObject` in
    the hands of a single test-method – one that''s not required by the code that
    enforces the standard test policy, but that represents the best compromise between
    individual class-member test coverage and maintainability: `testCRUDOperations`.
    There''s not a lot of opportunity for elegance in it; it has to brute-force its
    way through a lot of conditions and object states simply because of the nature
    of the methods being tested. If it''s well thought out, though, it leaves the
    tests for the classes derived from it free to not have to test the common functionality.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that it has to do is ensure that there''s a clean object repository,
    both in memory and on the filesystem. In order to do that, a throwaway class has
    to be defined, with the bare minimum of the required functionality needed to assure
    that all the necessary method classes are being made. That class, `JSONFileDataObjectDerived`,
    looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''re providing a file storage location that is not in use by any real objects,
    which can be deleted and recreated with object data however and whenever we need
    to:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because these tests are concerned with file system data-persistence, they were
    written for the OS that system development was undertaken on—a Linux installation—though
    they would execute without modification on any Unix-like OS. Converting them to
    run under Windows isn''t difficult:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Create a test-data directory (`C:\TestData`, for example), and change all filesystem
    references that start with `/tmp/` to `C:\\TestData\\` (note the double-backslashes),
    and alter the remaining filesystem paths to use Windows' filesystem notation (`C:\\TestData\\path\\to\\some\\file.ext`,
    note the double-backslashes again).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'We supply the bare minimum required functionality, using defaults or proven/provable
    functionality from parent classes wherever possible, or the simplest possible
    implementations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Where no default or inheritable functionality is available, we keep to the
    bare minimum necessary for the tests to be meaningful – in the case of the `to_data_dict`
    method, that means sticking to the properties and data structure required by all
    classes derived from `BaseDataObject`, including `JSONFileDataObject`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That, then, lets us start the `testCRUDOperations` test method by directly
    clearing the in-memory object cache, and removing any files in the storage location:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `rmtree` function is from a Python package called `shutils`, and recursively
    deletes files and sub directories from a specified location, raising an error
    if the target location doesn't exist. The `os.path.exists` call, from the built-in
    `os` module, checks for the existence of a file or directory at the specified
    path, returning `True` if something exists there, and `False` otherwise.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need at least one object stored in the newly cleared caches to start
    our testing process, so the creation of a data object, and saving its state data,
    comes next:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With one object created and saved, we can verify that the data-write and -read
    processes allow us to read the same data that we were expecting to be written.
    We can leverage the `matches` method of the class, since it's inherited from `BaseDataObject`,
    ultimately, and has been tested earlier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并保存一个对象后，我们可以验证数据写入和读取过程是否允许我们读取我们期望被写入的相同数据。我们可以利用类的`matches`方法，因为它最终是从`BaseDataObject`继承而来，并且之前已经经过测试。
- en: 'Since `matches` uses the `data dict` generated by `to_data_dict`, and that
    doesn''t include properties that don''t persist, such as `is_dirty` and `is_new`,
    those need to be checked separately:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`matches`使用`to_data_dict`生成的`data dict`，而其中不包括不持久的属性，比如`is_dirty`和`is_new`，这些需要单独检查：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A viable alternative, if any concerns arise about using `matches` as a data-structure-verification
    process, would be to explicitly check each property of the retrieved object against
    the corresponding property of the original. Using `matches` is a convenience,
    not a requirement.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对使用`matches`作为数据结构验证过程有任何疑虑，一个可行的替代方案是显式检查检索到的对象的每个属性与原始属性相对应。使用`matches`只是一种便利，而不是必须的。
- en: 'Next, we will check to make sure that multiple objects are saved and read as
    expected. Since the files and the keys for the objects are both functions of the
    `oid` of the objects, and we now know that the files and in-memory copies of data
    objects work with the creation of one object, we just need to ensure that multiples
    don''t break anything. Creating two more objects also allows us to re-verify the
    entire collection later on:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查确保多个对象被保存和读取如预期。由于文件和对象的键都是对象的`oid`的函数，而且我们现在知道文件和内存中的数据对象的创建与一个对象的创建有关，我们只需要确保多个对象不会出现任何问题。创建另外两个对象还允许我们稍后重新验证整个集合：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also need to test that deletions behave as expected, removing the deleted
    object from the in-memory cache and deleting the applicable file. Before performing
    the deletion, we need to confirm that the file that''s going to be deleted exists,
    in order to avoid a false positive test result once the deletion executes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测试删除行为是否符合预期，从内存缓存中删除已删除的对象并删除适用的文件。在执行删除之前，我们需要确认要删除的文件是否存在，以避免删除执行后出现错误的测试结果：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we can delete the item and verify the deletion from both the memory and
    filesystem:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以删除该项，并验证从内存和文件系统中的删除：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need to verify that data writes of updated state data work. We can
    check that by changing the `is_active` and `is_deleted` flags of an existing object,
    then saving it, and retrieving a copy of it for comparison, and checking with
    `matches`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要验证更新状态数据的数据写入是否有效。我们可以通过更改现有对象的`is_active`和`is_deleted`标志，然后保存它，并检索其副本进行比较，并使用`matches`进行检查：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the event that other tests might be added to this test case class later,
    and in the interests of cleaning up files once they are no longer needed, we''ll
    repeat the process of clearing out the in-memory and on-disk object stores. If
    other tests, created later for whatever ends, need to start with the in-memory
    and on-disk stores in any particular state, they''ll have to make arrangements
    to get that state set up, but they won''t have to worry about clearing it first:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后可能向此测试用例类添加其他测试，并且为了清理不再需要的文件，我们将重复清除内存和磁盘对象存储的过程。如果以后为任何目的创建其他测试需要以特定状态开始内存和磁盘存储，它们将不得不安排设置该状态，但它们不必担心首先清除它：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The original `test_file_store_dir` test method did not account for proving
    that derived classes will not allow themselves to be instantiated without a `_file_store_dir`
    class attribute that is set to something other than `None`. Revising that, and
    using another class derived from `JSONFileDataObject`, which is essentially a
    copy of the `JSONFileDataObjectDerived` class used for CRUD operations testing
    but without the attribute specification, allows that to be tested as part of the
    original test method like so:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`test_file_store_dir`测试方法没有考虑到派生类不允许在没有设置为`None`以外的其他值的`_file_store_dir`类属性的情况下实例化自己。修改这一点，并使用另一个从`JSONFileDataObject`派生的类，这个类本质上是用于CRUD操作测试的`JSONFileDataObjectDerived`类的副本，但没有属性规范，允许将其作为原始测试方法的一部分进行测试：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing hms_artisan.artisan_objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试hms_artisan.artisan_objects
- en: 'After the initial unit test setup, there are 74 tests that need to be implemented,
    largely due to the overrides of properties and their setter and deleter methods
    from their `Base` counterpart classes in `hms_core`. Since the main difference
    between the properties and their overridden methods is the inclusion of an automatic
    change in the instance''s `is_dirty` property during a set or delete call, that
    might appear to be the only thing that the property-related tests at this level
    need to be concerned with:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 初始单元测试设置完成后，需要实现74个测试，这主要是由于在`hms_core`中的`Base`对应类中覆盖了属性及其setter和deleter方法。由于属性及其重写方法之间的主要区别在于在设置或删除调用期间自动更改实例的`is_dirty`属性，因此在这个级别上与属性相关的测试可能需要关注的唯一事情可能是这个：
- en: '![](assets/36de70e3-fbd5-4fbc-91ec-7c4b2f885d1c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36de70e3-fbd5-4fbc-91ec-7c4b2f885d1c.png)'
- en: The tests for the properties are all close to the standard structure that has
    been used so far, essentially verifying that each property has the appropriate
    getter, setter, and deleter method associations. The only real difference is in
    which of those methods are being specified. Looking at the `testArtisan.testcontact_name`,
    which tests `Artisan.contact_name` as an example, the test assertions for the
    setter and deleter methods are structurally identical to their counterparts from
    the tests for `BaseArtisan` – they assert that the Artisan setter and deleter
    methods are associated with the property's set and delete actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The getter method assertion is where things get different:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the `Artisan` class provided overridden methods for each setter and deleter
    method, but not for the getter method, the assertion for that aspect of the property
    is pointing instead to the original getter method, in this case, the one defined
    in and inherited from `BaseArtisan`. The same basic pattern holds true even for
    properties without a local setter or deleter method, such as `Product.metadata`,
    tested by `testProduct.testmetadata`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The tests for the setter and deleter methods themselves can also be very simple,
    with a caveat. If the fundamental assumptions are that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: All the properties inherited from a `Base` class in `hms_core.business_objects`
    will be tested (which is true as things stand right now)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those tests can be trusted to prove the predictable behavior of those properties
    when they are set or deleted
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local setter and deleter methods will always call back to their tested counterparts
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then all that needs to be done in testing the local methods is checking that
    they set `is_dirty` accordingly. There may not be any way, realistically, to verify
    that those assumptions are in play as part of a unit-test set, though. It becomes
    a matter of knowing that these items are expected, standard procedure, and maintaining
    those procedures as new code is developed. If those principles and procedures
    can be counted upon, the tests for the derived class property-method overrides
    don''t need to go through the same level of effort/detail that their ancestors
    do, and can be as simple as these:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The data-dict methods (`to_data_dict` and `from_data_dict`) are common across
    all of the data objects, and show up in the list of tests to be implemented across
    all of the test case classes as a result. All of them have their own particular
    challenges to writing good, thorough unit tests. The variations of `to_data_dict` all
    follow a pretty consistent pattern:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over a (hopefully short) list of representative values for each property
    that should appear in the output
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an expected dictionary value that can be used to compare the output against
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the expected dictionary and the results of `to_data_dict` are the
    same
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In theory, the best way to ensure that all possible good and bad value combinations
    get tested is to iterate over all those possible combinations, nesting loops within
    other loops so that, for example, all possible combinations of `name`, `street_address`,
    `city` values are tested. In practice, tests built using that strategy will take
    a long time to execute, with a large number of combinations to test (the number
    of `name` values × the number of `street_address` values × the number of `city`
    values, and so on). The class with the fewest properties that needs to appear
    in a data-dict representation is the `Order` class, with five local properties
    in addition to the ones that are inherited from other classes that are already
    tested. An incomplete start of the relevant `testto_data_dict` method, with only one of
    those properties included in the mix, comes to 72 lines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Each additional property that needs to be tested results in another loop inside
    the current loop, and the creation of a new test object, making sure to include
    the new property item/argument being tested:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each sub-loop has to create its own `expected` value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Each sub-loop also has to perform its own assertion to test `expected` against
    the actual value returned by the `test_object.to_data_dict` call:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are, at this point, four more properties that have to be tested, each
    of which will start with its own nested loop:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Forcing a failure, with a notation that the test-method is not complete, helps
    prevent false positives from sneaking in, and can also help to track down which
    test is being worked on in a large list of results:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The tests for the various `from_data_dict` methods are similarly complex and
    deeply nested, for a variation of the same reason – they have to account for reasonable
    possibilities for all of the values that could be supplied. An incomplete start
    to testing that method in the `Order` class shows the pattern that''s started
    to take shape in 72 lines:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since there should always be default `None` values for certain results in the
    expected values of each iteration segment, we can define them once, then add them
    to the expected at each point needed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The collection of nested loops themselves is identical to the ones for testing
    `to_data_dict`, starting with variants of all of the required properties/arguments:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Each loop segment needs to create a `data_dict` with the current values in
    it, and create a test object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we''ll also be testing `to_data_dict`, we can assume that it''s trustworthy
    for the purposes of comparison to the test object''s `data-dict`. If the `to_data_dict`
    tests fail, they will raise those failures on their own, and not allow the test
    run to pass until those failures are resolved, with the same net result tests
    failing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Creation of the expected value is a bit more complicated. It starts with a
    copy of the preceding `defaults` values (since we don''t want test iterations
    to pollute the master defaults values). We also need to capture the expected values
    from the instance, as we''d expect them to appear in the final data dict:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Building the `expected` value at this point, then, is simply a matter of updating
    it with the data dict and instance values. With that done, we can perform the
    actual test assertion:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As before, each property/argument that needs to be tested requires its own
    nested loop, and a copy of the same process from the topmost loop. At each successive
    loop level, the `data_dict` value has to include more and more data to pass to
    the `from_data_dict` method, but the balance of each sub-loop is otherwise identical:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Testing the `matches` method turns out to be less complicated than might be
    expected at first glance. A complete test, after all, needs to test for both `True`
    and `False` results, across all the properties of an object instance, with criteria
    that might be 1 value or 12, or (theoretically) dozens or hundreds. Fortunately,
    by using the same nested loop structure that''s been used for `to_data_dict` and
    `from_data_dict` tests, but varying it to create the criteria being used for the
    test and determining what the expected value needs to be at every step along the
    way, it''s actually not that difficult. The test process starts by creating an
    object with known functional data in every attribute:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The nested loop structure iterates over a range of numbers (`0` and `1`), and
    retrieves the test value from the appropriate list based on the type of value
    that the property in the loop relates to, creates or adds to the criteria, and
    determines whether the expected result should be `True` or `False` based on any
    previous expected value and the comparison of the loop''s criteria value against
    the corresponding object property. All that remains after that is the assertion
    that the expected value equals the actual value from calling the test object''s
    `matches` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The reason that each sub-loop pays attention to the `expected` value set in
    its parent is to make sure that `False` results at a higher loop level won''t
    get overridden by a potential `True` result at the current loop level. For example,
    at this point in the test iterations, if `name` results in a `False` result (because
    it doesn''t match `test_object.name`), even if `street_address` does match, it
    should still return a `False` result:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The pattern for each sub-loop is, apart from the name of the property value
    being added to the criteria, and the redefinition of the `expected` value, identical
    all the way down the tree of loops:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last remaining method that''s common to all of the new data objects is
    the `_load_objects` helper class method. Initial unit testing raised some syntax
    concerns that made it necessary to remove the abstraction on the method in `JSONFileDataObject`,
    and implement an overriding class method in each of the subordinate classes, all
    of which call the original class method as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That, in turn, started raising test-method requirements for the methods in
    the test runs. The implementation of those tests was not difficult, building to
    some extent on the original test method written for `JSONFileDataObject`, where
    it originated. The structure for that test against the `Order` class is the simplest
    example, and starts much the same way, but forcing the on-disk and in-memory data
    stores to clear, but after setting the on-disk location to a disposable directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Again, in order to test the loading process, it''s necessary to create and
    save some objects:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As each object is created, its presence in the in-memory and on-disk stores
    is verified:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It''s also necessary to clear the in-memory store, reload it, and verify that
    the newly created object is still there. This happens in each object-creation
    iteration:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Verification that the deletion process removes in-memory and on-disk objects
    works by iterating over a list of instances, selecting one at random, deleting
    that instance, and verifying its removal the same way that the initial creation
    was verified:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The list of instances is updated at the end of each iteration:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, any files that might remain are deleted, just to be safe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Most of the balance of the test methods follow patterns established previously:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The various properties and their getter, setter, and deleter methods use the
    structure noted at the beginning of this section
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various `__init__` methods still create and assert argument-to-property
    settings for a reasonable subset of good values for all arguments/properties
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few outliers, though. First and foremost, the `sort` class method
    that was defined without implementation, as an abstract class method in `BaseDataObject`, has
    surfaced. At this point, we don''t even know whether we''re going to need it,
    let alone what shape it will need to take. Under the circumstances, deferring
    both its implementation and the testing of that implementation feels prudent.
    In order to allow the required unit test to be ignored, it can be decorated with
    `unittest.skip`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Two more outliers surfaced in the Artisan class: `add_product` and `remove_product`,
    which had no testable concrete implementation before now. With the addition of
    the `Goodproducts` and `Badproducts` value lists to test with, `testadd_product`
    is very similar to previous test methods utilizing value lists to test against:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The process for testing `remove_product` starts by using that same process
    to create a collection of products, then removes them one at a time, verifying
    the removal at each iteration:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Because `hms_artisan..Order` was built from the ground up, its property method
    tests needed to explicitly perform that same sort of `is_dirty` check noted earlier,
    but also had to implement any of several standard property tests. A typical deleter
    and setter method test looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The final test-run report for all tests for the `hms_artisan` namespace shows
    that all the tests were run except the seven that were explicitly skipped, with
    no test failures:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/290e854c-1c7d-4088-a9f8-01f8281be892.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Testing the new hms_core Classes
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going through the usual setup process for the unit tests of a module
    (creating the test module, executing the test module, creating test case classes
    for each item reported as missing, executing the test module, and creating test
    methods for each item reported as missing), the initial results show far fewer
    tests in need of implementation than in previous unit test modules, with only
    11 tests that need to be populated:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f61743e9-8d38-40f4-8d8c-af52dfab303b.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'There is a caveat to these results, though: they **do not** include tests of
    the data object methods required by `BaseDataObject` and `HMSMongoDataObject`,
    just of the properties and methods defined as part of the `Artisan` and `Product`
    classes that were created. Those, living in their own test module, add another
    33 tests that need to be implemented:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aedb6c7e-2e4e-4661-a292-bfa7ab1f351b.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Unit testing hms_core.data_storage.py
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bulk of the testing for the `DatastoreConfig` class follows testing patterns
    that''ve been established earlier. The noteworthy exception is in testing its
    `from_config` class method, which requires actual config files to be written to
    test against. Testing all of the good values by creating a config file full of
    them doesn''t look that much different from other test methods that involve creating
    an object instance from a `dict` value, though – the same sort of iteration over
    all the good test values starts it off:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is where the temporary configuration file is created:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then `from_config` is called, and the various assertions are executed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A similar approach/structure is used in testing the various bad values for
    each argument/property (`database`, `host`, `password`, `port`, and `user`). They
    all look much like the test of bad database values:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Much of the testing processes for `HMSMongoDataObject` are also in the vein
    of previously established test-writing patterns:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Because the class derives from `BaseDataObject`, there are many of the same
    required test methods that depend on abstract functionality being implemented,
    so a derived class is created to test against, if only to ensure that the dependent
    method calls are successful
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests of the `_create` and `_update` methods are essentially identical to
    those created while testing their `hms_artisan` counterparts, since they too simply
    raise `NotImplementedError`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the functionality of any `HMSMongoDataObject`-derived class requires
    an operational MongoDB installation. Without one, the tests may raise errors (which
    would hopefully at least indicate what the problem is), or may just sit waiting
    for a connection to a MongoDB to resolve until the connection-effort times out.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The local properties, since they all use actual deletion of their underlying
    storage attributes, and are lazily instantiated (created when they are needed
    if they aren''t already available), require a different approach than previous
    property tests. In the interests of keeping all of the related test code in one
    spot, the `test_del_` methods have been skipped, and the testing of the deletion
    aspects of the properties merged in with the `test_get_` methods. Using `test_get_connection`
    as an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The process for each is similar:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Create a `test_object` instance
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the tested property getter returns the common class attribute value
    when called (`HMSMongoDataObjectDerived._connection` in this case)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the deleter method
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reassert that the common class attribute value is returned when the getter is
    called again
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It might also be a good idea to assert, between the deleter and getter method
    calls, that the class attribute value is deleted, but it's not really necessary
    so long as the final getter call assertion still passes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: There are several items in the test case class for `HMSMongoDataObject` that
    depend on an actual database connection in order to be even remotely useful. In
    addition, there are test methods that directly relate to that dependency that
    can be skipped, or whose implementation is noteworthy. Since we'll need a database
    connection, that has to be configured every time that the test case class runs.
    Ideally, it should not run for every test that needs a connection, though – it's
    not a big deal if it does, at least not at the scale of the system so far, but
    in larger-scale systems, creating a new database for every test method that needs
    it could slow things down. Maybe substantially.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the standard Python `unittest` module provides methods that can
    be used to both initialize the database connection data, and delete the database
    used for testing after all the tests are complete. Those are, respectively, the
    `setUp` and `tearDown` methods. `setUp` need do nothing more than configure the
    data access, since `HMSMongoDataObjects` will take care of creating the `connection`,
    `database`, and `collection` objects it needs when they are needed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`tearDown` is responsible for completely deleting the test database that will
    have been created for the test case class, and simply creates a `MongoClient`,
    then uses it to drop the database specified in the configuration:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `setUp` and `tearDown` methods won''t behave the same way as a typical
    test method if we try to assert any expected values or behavior – any assertions
    made that fail will simply raise errors. That, then, means that while we could
    assert that configuration has completed accurately, it doesn''t really do anything
    useful from the perspective of reporting. In this case, if the configuration call
    doesn''t raise any errors, and the various test methods that rely on it pass,
    it can be taken as proof that configuration is doing what it''s expected to do.
    In that case, we can skip the relevant test methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to fully test the `delete`, `get`, and `save` methods, we have to
    implement a throwaway derived class – `HMSMongoDataObjectDerived`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''ll want some local properties that can be used to test `get`, in particular,
    but they don''t need to be anything more than simple attributes that are set during
    initialization and that appear in the results of a `to_data_dict` call:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In order to test the `delete` method, we need to first create and save some
    objects:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We''ll want to test that we can delete multiple items and single items alike,
    so we''ll take the last half of the collection of objects created, delete those,
    then take the last half of the remaining items, and so on, until we''re down to
    a single object. In each iteration, we delete the current collection of `oid`,
    and verify that they don''t exist after they''ve been deleted. Finally, we verify
    that all of the created objects have been deleted:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'A similar approach is taken for testing `get` – creating several items with
    easily identifiable property values that can be used as `criteria`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then we can iterate over those same values, creating a `criteria` set to use,
    and verifying that the returned objects have the `criteria` values that we passed.
    One `criteria` value first:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then we test with multiple `criteria`, to assure that more than one `criteria`
    value behaves as expected:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Between the tests of the `delete` and `get` methods, we''ve effectively already
    tested the `save` method as well – we had to save objects to get or delete them,
    after all – so `testsave` is arguably not really needed. In the interest of having
    an actual test, rather that an entry for another skipped test, we''ll implement
    it anyway, and use it to test that we can also get an object by its `oid` value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The final test output, once everything is implemented and passes, shows 47
    tests, with five skipped:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c22f40e6-92ce-4f9c-bc68-507be164440b.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Unit testing hms_core.co_objects.py
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Artisan` and `Product` classes in `co_objects`, like their counterparts
    in the `artisan_objects` module of `hms_artisan`, had to be overridden in order
    to provide the appropriate `is_dirty` behavior when any of those properties that
    are part of a state data record are altered. As a result, their corresponding
    test methods had to be created, just as happened when testing their counterparts
    in the `hms_artisan` package. Effectively, the same changes were made in both
    modules, and as a result the test classes and the test methods within them for
    classes that exist in both packages turned out to be identical.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests and trust
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was noted earlier that the real purpose of unit testing code is about ensuring
    that code behaves in a predictable fashion across all possible execution cases.
    In a very real way, it is also about establishing a measure of trust in a code
    base. In that context, there is a line that has to be drawn with respect to where
    that trust can simply be taken as a given. For example, the various unit tests
    in this iteration have focused on ensuring that the code created for data persistence
    gets everything that is necessary to and from the database engine. It has not
    been concerned with whether the library to connect to the database engine is trustworthy;
    for our purposes, we assume that it is, at least until we encounter a test failure
    that cannot be explained in any other way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests provide that trust for others who might consume our code – knowing
    that everything that needs to be tested has been, and that all the tests have
    passed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Building/distribution, demonstration, and acceptance
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build process for the individual modules will not have changed much, though
    with unit tests now available, those can be added to the `setup.py` files that
    are used to package the individual Python packages. The `setup` function that's
    already in place can, with minimal changes, be used to execute the entire test
    suite simply by providing a `test_suite` argument that points to the root test
    suite directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be necessary to ensure that the path to the test suite directory has
    been added to `sys.path` as well:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The current `setup` function call, then, includes `test_suite` like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The entire test suite can then be executed with `python setup.py test`, which
    returns a line-by-line summary of the tests executed and their results:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1b2a20c0-4b4f-41d7-b01b-63d65a66e9ef.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Packaging the code in a component project still uses `python setup.py sdist`
    from within the individual project directories, and still yields an installable
    package:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6b72172-6fef-4178-b77b-8fef817def58.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Demonstrating the new data-persistence functionality could be done in several
    ways, but requires the creation of disposable/temporary demo data objects in a
    disposable/temporary database. There''s code in the `test_co_objects` test module
    that does just that, so creating a minimal data object class based on that structure
    (calling it `ExampleObject` for demonstrative purposes), then running:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'It takes care of generating a dataset that can be examined. From that point,
    any tool – the command-line `mongo` client or a GUI, such as Robo3T – can be used
    to view and verify that data was, in fact, persisted:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e59a1ff0-2bc4-42a8-bea5-4c6e3090b0a8.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: If more detailed acceptance examples are needed – such as examples for each
    of the business object types – a similar script could be written to create `Artisan`
    and `Product` instances and save them as well. Similarly, with respect to the
    `hms_artisan` data object classes, simply showing the files written for objects
    in an example/demo environment should suffice.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Operations/use, maintenance, and decommissioning considerations
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no substantial change yet as these items are concerned:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The packages, though there are now three of them, are still very simple.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we've added an external dependency with the inclusion of the `pymongo`
    library, we're not yet at a point where we need to worry about how that dependency
    will be handled.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will obviously need to be a MongoDB installation, but until the code is
    ready to be integrated to some shared environment, even that is a non-issue –
    local development can use local database engines for now.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a decommissioning perspective, uninstalling the software hasn't really
    changed except that there are now three packages to uninstall – but the process
    for each is a variation of the process as it stood at the end of the last iteration
    (`pip uninstall HMS-Core`).
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there may be other data-access and data-persistence tweaks in later iterations,
    and there are a few data objects whose specific details aren't known yet because
    of integration concerns with other systems, the bulk of the data objects work
    is complete.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, the development iterations against the `hms_sys` code bases have had
    most of their attention focused on what might be thought of as system functionality – ensuring
    that data structures are well formed, can be validated, and will live longer than
    a single user session or Python run. Interaction with system data from a user
    perspective hasn't been addressed yet at all. Before that can be addressed, though,
    there is another layer that needs to be at least analyzed, if not built – the
    Artisan Gateway service, which acts as a central point where data from remote
    artisans and Central Office staff comes together.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
