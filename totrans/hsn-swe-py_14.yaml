- en: Testing Data Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Repeatable unit testing of code is rarely more critical than in the case of
    data persistence. Code can change or be replaced over time, perhaps even to the
    point of changing to a completely different system, written in a completely different
    language, but once data exists, it can potentially outlive any number of code
    bases that make use of it. The data in a system, it could be argued, is where
    the real business value usually exists, so testing of the processes that interact
    with it, and have the potential to destroy that value, is extremely important.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, the bulk of this chapter will be focused on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing the unit tests for the data object and related classes created in this
    iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `hms_artisan` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new `hms_core` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of those tests with the build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There''s also been enough new functionality added that some attention will
    have to be paid to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Other effects of the new code on the build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Demonstration of the new code, and how acceptance of the related stories might
    be facilitated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the new code affects operations, use, maintenance, and decommissioning concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the process of writing the unit tests for the new data object classes
    can simply follow the process established in previous iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the top-level test module for the package being tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the child modules of the package being tested, and create a corresponding
    test module for each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add references to the child test modules to the package test module and import
    their tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For each child test module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the module and create test case classes for each item reported as missing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the module and create tests methods for each member (property or method)
    reported as missing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are several test modules that need to be created, one for each module
    that was created in the `src` directories across the projects this iteration touched,
    yielding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hms_core/../data_objects.py → test_hms_core/test_data_objects.py` (already
    tested, but listed here for the sake of having a complete list)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hms_artisan/../data_storage.py → test_hms_artisan/test_data_storage.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hms_artisan/../artisan_objects.py → test_hms_artisan/test_artisan_objects.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hms_core/../co_objects.py → test_hms_core/test_co_objects.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing hms_artisan.data_storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unit tests for `hms_artisan.data_storage` are, at this point, all concerned
    with testing the `JSONFileDataStore` class. Because of what that class actually
    does, the typical patterns for unit testing apply poorly, if at all. It has no
    properties to test, and the one class attribute that can be tested (`_file_store_dir`)
    is overridden by derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s probably worth asserting that the default attribute is what''s expected,
    though, since if it doesn''t default to `None`, that could cause failures in derived
    classes and instances of those classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As far as the testing of methods is concerned, while there are several, they
    are somewhat intertwined, and they also frequently rely upon implementations of
    methods that are abstract themselves and thus not available in the ABC itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`, `delete`, and `save` all call the `_load_objects` helper class method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That `_load_objects` method relies on a concrete implementation of `from_data_dict`
    in order to generate the collection of objects that the other methods refer to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save` method also requires a concrete implementation of the `to_data_dict`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since unit testing is about proving predictable functionality, the question
    then becomes: what can we prove?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, and probably most obvious, item is that object initialization works
    in pretty much the same fashion that it does in `BaseDataObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `GoodDateTimes` test values are the same values we used to test `BaseDataObject`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `_create` and `_update` methods aren''t going to be used, we can
    prove that they raise the expected errors when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual CRUD operations, plus the `_load_objects` method, since they
    are joined at the hip, would end up with a lot of overlap – tests for one method
    would have to execute tests for other methods as part of their own testing process
    in order to really prove that everything was working as expected. Tests of that
    complexity are tedious to write, but more importantly, require more effort and
    discipline to maintain, and are thus more prone to getting out of touch with the
    code they are testing. A better option, in this case, might be to skip those tests,
    and create one larger, unified test of all the related functionality. Python''s
    stock `unittest` module provides a `skip` decorator function that provides the
    ability to tag tests to be skipped by standard unit testing runs, and calling
    that requires that we log a reason for the test being skipped. In this case, the
    reason is that all of the methods in question will be tested in one large pass
    in a different test method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'That leaves the responsibility for testing most of `JSONFileDataObject` in
    the hands of a single test-method – one that''s not required by the code that
    enforces the standard test policy, but that represents the best compromise between
    individual class-member test coverage and maintainability: `testCRUDOperations`.
    There''s not a lot of opportunity for elegance in it; it has to brute-force its
    way through a lot of conditions and object states simply because of the nature
    of the methods being tested. If it''s well thought out, though, it leaves the
    tests for the classes derived from it free to not have to test the common functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that it has to do is ensure that there''s a clean object repository,
    both in memory and on the filesystem. In order to do that, a throwaway class has
    to be defined, with the bare minimum of the required functionality needed to assure
    that all the necessary method classes are being made. That class, `JSONFileDataObjectDerived`,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re providing a file storage location that is not in use by any real objects,
    which can be deleted and recreated with object data however and whenever we need
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Because these tests are concerned with file system data-persistence, they were
    written for the OS that system development was undertaken on—a Linux installation—though
    they would execute without modification on any Unix-like OS. Converting them to
    run under Windows isn''t difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a test-data directory (`C:\TestData`, for example), and change all filesystem
    references that start with `/tmp/` to `C:\\TestData\\` (note the double-backslashes),
    and alter the remaining filesystem paths to use Windows' filesystem notation (`C:\\TestData\\path\\to\\some\\file.ext`,
    note the double-backslashes again).
  prefs: []
  type: TYPE_NORMAL
- en: 'We supply the bare minimum required functionality, using defaults or proven/provable
    functionality from parent classes wherever possible, or the simplest possible
    implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Where no default or inheritable functionality is available, we keep to the
    bare minimum necessary for the tests to be meaningful – in the case of the `to_data_dict`
    method, that means sticking to the properties and data structure required by all
    classes derived from `BaseDataObject`, including `JSONFileDataObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That, then, lets us start the `testCRUDOperations` test method by directly
    clearing the in-memory object cache, and removing any files in the storage location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `rmtree` function is from a Python package called `shutils`, and recursively
    deletes files and sub directories from a specified location, raising an error
    if the target location doesn't exist. The `os.path.exists` call, from the built-in
    `os` module, checks for the existence of a file or directory at the specified
    path, returning `True` if something exists there, and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need at least one object stored in the newly cleared caches to start
    our testing process, so the creation of a data object, and saving its state data,
    comes next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With one object created and saved, we can verify that the data-write and -read
    processes allow us to read the same data that we were expecting to be written.
    We can leverage the `matches` method of the class, since it's inherited from `BaseDataObject`,
    ultimately, and has been tested earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `matches` uses the `data dict` generated by `to_data_dict`, and that
    doesn''t include properties that don''t persist, such as `is_dirty` and `is_new`,
    those need to be checked separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A viable alternative, if any concerns arise about using `matches` as a data-structure-verification
    process, would be to explicitly check each property of the retrieved object against
    the corresponding property of the original. Using `matches` is a convenience,
    not a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will check to make sure that multiple objects are saved and read as
    expected. Since the files and the keys for the objects are both functions of the
    `oid` of the objects, and we now know that the files and in-memory copies of data
    objects work with the creation of one object, we just need to ensure that multiples
    don''t break anything. Creating two more objects also allows us to re-verify the
    entire collection later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to test that deletions behave as expected, removing the deleted
    object from the in-memory cache and deleting the applicable file. Before performing
    the deletion, we need to confirm that the file that''s going to be deleted exists,
    in order to avoid a false positive test result once the deletion executes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can delete the item and verify the deletion from both the memory and
    filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to verify that data writes of updated state data work. We can
    check that by changing the `is_active` and `is_deleted` flags of an existing object,
    then saving it, and retrieving a copy of it for comparison, and checking with
    `matches`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the event that other tests might be added to this test case class later,
    and in the interests of cleaning up files once they are no longer needed, we''ll
    repeat the process of clearing out the in-memory and on-disk object stores. If
    other tests, created later for whatever ends, need to start with the in-memory
    and on-disk stores in any particular state, they''ll have to make arrangements
    to get that state set up, but they won''t have to worry about clearing it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The original `test_file_store_dir` test method did not account for proving
    that derived classes will not allow themselves to be instantiated without a `_file_store_dir`
    class attribute that is set to something other than `None`. Revising that, and
    using another class derived from `JSONFileDataObject`, which is essentially a
    copy of the `JSONFileDataObjectDerived` class used for CRUD operations testing
    but without the attribute specification, allows that to be tested as part of the
    original test method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing hms_artisan.artisan_objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the initial unit test setup, there are 74 tests that need to be implemented,
    largely due to the overrides of properties and their setter and deleter methods
    from their `Base` counterpart classes in `hms_core`. Since the main difference
    between the properties and their overridden methods is the inclusion of an automatic
    change in the instance''s `is_dirty` property during a set or delete call, that
    might appear to be the only thing that the property-related tests at this level
    need to be concerned with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36de70e3-fbd5-4fbc-91ec-7c4b2f885d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: The tests for the properties are all close to the standard structure that has
    been used so far, essentially verifying that each property has the appropriate
    getter, setter, and deleter method associations. The only real difference is in
    which of those methods are being specified. Looking at the `testArtisan.testcontact_name`,
    which tests `Artisan.contact_name` as an example, the test assertions for the
    setter and deleter methods are structurally identical to their counterparts from
    the tests for `BaseArtisan` – they assert that the Artisan setter and deleter
    methods are associated with the property's set and delete actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The getter method assertion is where things get different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `Artisan` class provided overridden methods for each setter and deleter
    method, but not for the getter method, the assertion for that aspect of the property
    is pointing instead to the original getter method, in this case, the one defined
    in and inherited from `BaseArtisan`. The same basic pattern holds true even for
    properties without a local setter or deleter method, such as `Product.metadata`,
    tested by `testProduct.testmetadata`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests for the setter and deleter methods themselves can also be very simple,
    with a caveat. If the fundamental assumptions are that:'
  prefs: []
  type: TYPE_NORMAL
- en: All the properties inherited from a `Base` class in `hms_core.business_objects`
    will be tested (which is true as things stand right now)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those tests can be trusted to prove the predictable behavior of those properties
    when they are set or deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The local setter and deleter methods will always call back to their tested counterparts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then all that needs to be done in testing the local methods is checking that
    they set `is_dirty` accordingly. There may not be any way, realistically, to verify
    that those assumptions are in play as part of a unit-test set, though. It becomes
    a matter of knowing that these items are expected, standard procedure, and maintaining
    those procedures as new code is developed. If those principles and procedures
    can be counted upon, the tests for the derived class property-method overrides
    don''t need to go through the same level of effort/detail that their ancestors
    do, and can be as simple as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The data-dict methods (`to_data_dict` and `from_data_dict`) are common across
    all of the data objects, and show up in the list of tests to be implemented across
    all of the test case classes as a result. All of them have their own particular
    challenges to writing good, thorough unit tests. The variations of `to_data_dict` all
    follow a pretty consistent pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate over a (hopefully short) list of representative values for each property
    that should appear in the output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an expected dictionary value that can be used to compare the output against
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the expected dictionary and the results of `to_data_dict` are the
    same
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In theory, the best way to ensure that all possible good and bad value combinations
    get tested is to iterate over all those possible combinations, nesting loops within
    other loops so that, for example, all possible combinations of `name`, `street_address`,
    `city` values are tested. In practice, tests built using that strategy will take
    a long time to execute, with a large number of combinations to test (the number
    of `name` values × the number of `street_address` values × the number of `city`
    values, and so on). The class with the fewest properties that needs to appear
    in a data-dict representation is the `Order` class, with five local properties
    in addition to the ones that are inherited from other classes that are already
    tested. An incomplete start of the relevant `testto_data_dict` method, with only one of
    those properties included in the mix, comes to 72 lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each additional property that needs to be tested results in another loop inside
    the current loop, and the creation of a new test object, making sure to include
    the new property item/argument being tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Each sub-loop has to create its own `expected` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Each sub-loop also has to perform its own assertion to test `expected` against
    the actual value returned by the `test_object.to_data_dict` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are, at this point, four more properties that have to be tested, each
    of which will start with its own nested loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Forcing a failure, with a notation that the test-method is not complete, helps
    prevent false positives from sneaking in, and can also help to track down which
    test is being worked on in a large list of results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests for the various `from_data_dict` methods are similarly complex and
    deeply nested, for a variation of the same reason – they have to account for reasonable
    possibilities for all of the values that could be supplied. An incomplete start
    to testing that method in the `Order` class shows the pattern that''s started
    to take shape in 72 lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there should always be default `None` values for certain results in the
    expected values of each iteration segment, we can define them once, then add them
    to the expected at each point needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The collection of nested loops themselves is identical to the ones for testing
    `to_data_dict`, starting with variants of all of the required properties/arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Each loop segment needs to create a `data_dict` with the current values in
    it, and create a test object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ll also be testing `to_data_dict`, we can assume that it''s trustworthy
    for the purposes of comparison to the test object''s `data-dict`. If the `to_data_dict`
    tests fail, they will raise those failures on their own, and not allow the test
    run to pass until those failures are resolved, with the same net result tests
    failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Creation of the expected value is a bit more complicated. It starts with a
    copy of the preceding `defaults` values (since we don''t want test iterations
    to pollute the master defaults values). We also need to capture the expected values
    from the instance, as we''d expect them to appear in the final data dict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the `expected` value at this point, then, is simply a matter of updating
    it with the data dict and instance values. With that done, we can perform the
    actual test assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, each property/argument that needs to be tested requires its own
    nested loop, and a copy of the same process from the topmost loop. At each successive
    loop level, the `data_dict` value has to include more and more data to pass to
    the `from_data_dict` method, but the balance of each sub-loop is otherwise identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing the `matches` method turns out to be less complicated than might be
    expected at first glance. A complete test, after all, needs to test for both `True`
    and `False` results, across all the properties of an object instance, with criteria
    that might be 1 value or 12, or (theoretically) dozens or hundreds. Fortunately,
    by using the same nested loop structure that''s been used for `to_data_dict` and
    `from_data_dict` tests, but varying it to create the criteria being used for the
    test and determining what the expected value needs to be at every step along the
    way, it''s actually not that difficult. The test process starts by creating an
    object with known functional data in every attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The nested loop structure iterates over a range of numbers (`0` and `1`), and
    retrieves the test value from the appropriate list based on the type of value
    that the property in the loop relates to, creates or adds to the criteria, and
    determines whether the expected result should be `True` or `False` based on any
    previous expected value and the comparison of the loop''s criteria value against
    the corresponding object property. All that remains after that is the assertion
    that the expected value equals the actual value from calling the test object''s
    `matches` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason that each sub-loop pays attention to the `expected` value set in
    its parent is to make sure that `False` results at a higher loop level won''t
    get overridden by a potential `True` result at the current loop level. For example,
    at this point in the test iterations, if `name` results in a `False` result (because
    it doesn''t match `test_object.name`), even if `street_address` does match, it
    should still return a `False` result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern for each sub-loop is, apart from the name of the property value
    being added to the criteria, and the redefinition of the `expected` value, identical
    all the way down the tree of loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last remaining method that''s common to all of the new data objects is
    the `_load_objects` helper class method. Initial unit testing raised some syntax
    concerns that made it necessary to remove the abstraction on the method in `JSONFileDataObject`,
    and implement an overriding class method in each of the subordinate classes, all
    of which call the original class method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'That, in turn, started raising test-method requirements for the methods in
    the test runs. The implementation of those tests was not difficult, building to
    some extent on the original test method written for `JSONFileDataObject`, where
    it originated. The structure for that test against the `Order` class is the simplest
    example, and starts much the same way, but forcing the on-disk and in-memory data
    stores to clear, but after setting the on-disk location to a disposable directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, in order to test the loading process, it''s necessary to create and
    save some objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As each object is created, its presence in the in-memory and on-disk stores
    is verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s also necessary to clear the in-memory store, reload it, and verify that
    the newly created object is still there. This happens in each object-creation
    iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Verification that the deletion process removes in-memory and on-disk objects
    works by iterating over a list of instances, selecting one at random, deleting
    that instance, and verifying its removal the same way that the initial creation
    was verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of instances is updated at the end of each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, any files that might remain are deleted, just to be safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the balance of the test methods follow patterns established previously:'
  prefs: []
  type: TYPE_NORMAL
- en: The various properties and their getter, setter, and deleter methods use the
    structure noted at the beginning of this section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various `__init__` methods still create and assert argument-to-property
    settings for a reasonable subset of good values for all arguments/properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few outliers, though. First and foremost, the `sort` class method
    that was defined without implementation, as an abstract class method in `BaseDataObject`, has
    surfaced. At this point, we don''t even know whether we''re going to need it,
    let alone what shape it will need to take. Under the circumstances, deferring
    both its implementation and the testing of that implementation feels prudent.
    In order to allow the required unit test to be ignored, it can be decorated with
    `unittest.skip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Two more outliers surfaced in the Artisan class: `add_product` and `remove_product`,
    which had no testable concrete implementation before now. With the addition of
    the `Goodproducts` and `Badproducts` value lists to test with, `testadd_product`
    is very similar to previous test methods utilizing value lists to test against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for testing `remove_product` starts by using that same process
    to create a collection of products, then removes them one at a time, verifying
    the removal at each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `hms_artisan..Order` was built from the ground up, its property method
    tests needed to explicitly perform that same sort of `is_dirty` check noted earlier,
    but also had to implement any of several standard property tests. A typical deleter
    and setter method test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The final test-run report for all tests for the `hms_artisan` namespace shows
    that all the tests were run except the seven that were explicitly skipped, with
    no test failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/290e854c-1c7d-4088-a9f8-01f8281be892.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing the new hms_core Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After going through the usual setup process for the unit tests of a module
    (creating the test module, executing the test module, creating test case classes
    for each item reported as missing, executing the test module, and creating test
    methods for each item reported as missing), the initial results show far fewer
    tests in need of implementation than in previous unit test modules, with only
    11 tests that need to be populated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f61743e9-8d38-40f4-8d8c-af52dfab303b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a caveat to these results, though: they **do not** include tests of
    the data object methods required by `BaseDataObject` and `HMSMongoDataObject`,
    just of the properties and methods defined as part of the `Artisan` and `Product`
    classes that were created. Those, living in their own test module, add another
    33 tests that need to be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aedb6c7e-2e4e-4661-a292-bfa7ab1f351b.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing hms_core.data_storage.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bulk of the testing for the `DatastoreConfig` class follows testing patterns
    that''ve been established earlier. The noteworthy exception is in testing its
    `from_config` class method, which requires actual config files to be written to
    test against. Testing all of the good values by creating a config file full of
    them doesn''t look that much different from other test methods that involve creating
    an object instance from a `dict` value, though – the same sort of iteration over
    all the good test values starts it off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the temporary configuration file is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `from_config` is called, and the various assertions are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar approach/structure is used in testing the various bad values for
    each argument/property (`database`, `host`, `password`, `port`, and `user`). They
    all look much like the test of bad database values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Much of the testing processes for `HMSMongoDataObject` are also in the vein
    of previously established test-writing patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Because the class derives from `BaseDataObject`, there are many of the same
    required test methods that depend on abstract functionality being implemented,
    so a derived class is created to test against, if only to ensure that the dependent
    method calls are successful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tests of the `_create` and `_update` methods are essentially identical to
    those created while testing their `hms_artisan` counterparts, since they too simply
    raise `NotImplementedError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the functionality of any `HMSMongoDataObject`-derived class requires
    an operational MongoDB installation. Without one, the tests may raise errors (which
    would hopefully at least indicate what the problem is), or may just sit waiting
    for a connection to a MongoDB to resolve until the connection-effort times out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The local properties, since they all use actual deletion of their underlying
    storage attributes, and are lazily instantiated (created when they are needed
    if they aren''t already available), require a different approach than previous
    property tests. In the interests of keeping all of the related test code in one
    spot, the `test_del_` methods have been skipped, and the testing of the deletion
    aspects of the properties merged in with the `test_get_` methods. Using `test_get_connection`
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The process for each is similar:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `test_object` instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the tested property getter returns the common class attribute value
    when called (`HMSMongoDataObjectDerived._connection` in this case)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the deleter method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reassert that the common class attribute value is returned when the getter is
    called again
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It might also be a good idea to assert, between the deleter and getter method
    calls, that the class attribute value is deleted, but it's not really necessary
    so long as the final getter call assertion still passes.
  prefs: []
  type: TYPE_NORMAL
- en: There are several items in the test case class for `HMSMongoDataObject` that
    depend on an actual database connection in order to be even remotely useful. In
    addition, there are test methods that directly relate to that dependency that
    can be skipped, or whose implementation is noteworthy. Since we'll need a database
    connection, that has to be configured every time that the test case class runs.
    Ideally, it should not run for every test that needs a connection, though – it's
    not a big deal if it does, at least not at the scale of the system so far, but
    in larger-scale systems, creating a new database for every test method that needs
    it could slow things down. Maybe substantially.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the standard Python `unittest` module provides methods that can
    be used to both initialize the database connection data, and delete the database
    used for testing after all the tests are complete. Those are, respectively, the
    `setUp` and `tearDown` methods. `setUp` need do nothing more than configure the
    data access, since `HMSMongoDataObjects` will take care of creating the `connection`,
    `database`, and `collection` objects it needs when they are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`tearDown` is responsible for completely deleting the test database that will
    have been created for the test case class, and simply creates a `MongoClient`,
    then uses it to drop the database specified in the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setUp` and `tearDown` methods won''t behave the same way as a typical
    test method if we try to assert any expected values or behavior – any assertions
    made that fail will simply raise errors. That, then, means that while we could
    assert that configuration has completed accurately, it doesn''t really do anything
    useful from the perspective of reporting. In this case, if the configuration call
    doesn''t raise any errors, and the various test methods that rely on it pass,
    it can be taken as proof that configuration is doing what it''s expected to do.
    In that case, we can skip the relevant test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to fully test the `delete`, `get`, and `save` methods, we have to
    implement a throwaway derived class – `HMSMongoDataObjectDerived`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want some local properties that can be used to test `get`, in particular,
    but they don''t need to be anything more than simple attributes that are set during
    initialization and that appear in the results of a `to_data_dict` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the `delete` method, we need to first create and save some
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll want to test that we can delete multiple items and single items alike,
    so we''ll take the last half of the collection of objects created, delete those,
    then take the last half of the remaining items, and so on, until we''re down to
    a single object. In each iteration, we delete the current collection of `oid`,
    and verify that they don''t exist after they''ve been deleted. Finally, we verify
    that all of the created objects have been deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar approach is taken for testing `get` – creating several items with
    easily identifiable property values that can be used as `criteria`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can iterate over those same values, creating a `criteria` set to use,
    and verifying that the returned objects have the `criteria` values that we passed.
    One `criteria` value first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we test with multiple `criteria`, to assure that more than one `criteria`
    value behaves as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Between the tests of the `delete` and `get` methods, we''ve effectively already
    tested the `save` method as well – we had to save objects to get or delete them,
    after all – so `testsave` is arguably not really needed. In the interest of having
    an actual test, rather that an entry for another skipped test, we''ll implement
    it anyway, and use it to test that we can also get an object by its `oid` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The final test output, once everything is implemented and passes, shows 47
    tests, with five skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c22f40e6-92ce-4f9c-bc68-507be164440b.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit testing hms_core.co_objects.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Artisan` and `Product` classes in `co_objects`, like their counterparts
    in the `artisan_objects` module of `hms_artisan`, had to be overridden in order
    to provide the appropriate `is_dirty` behavior when any of those properties that
    are part of a state data record are altered. As a result, their corresponding
    test methods had to be created, just as happened when testing their counterparts
    in the `hms_artisan` package. Effectively, the same changes were made in both
    modules, and as a result the test classes and the test methods within them for
    classes that exist in both packages turned out to be identical.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests and trust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It was noted earlier that the real purpose of unit testing code is about ensuring
    that code behaves in a predictable fashion across all possible execution cases.
    In a very real way, it is also about establishing a measure of trust in a code
    base. In that context, there is a line that has to be drawn with respect to where
    that trust can simply be taken as a given. For example, the various unit tests
    in this iteration have focused on ensuring that the code created for data persistence
    gets everything that is necessary to and from the database engine. It has not
    been concerned with whether the library to connect to the database engine is trustworthy;
    for our purposes, we assume that it is, at least until we encounter a test failure
    that cannot be explained in any other way.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests provide that trust for others who might consume our code – knowing
    that everything that needs to be tested has been, and that all the tests have
    passed.
  prefs: []
  type: TYPE_NORMAL
- en: Building/distribution, demonstration, and acceptance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build process for the individual modules will not have changed much, though
    with unit tests now available, those can be added to the `setup.py` files that
    are used to package the individual Python packages. The `setup` function that's
    already in place can, with minimal changes, be used to execute the entire test
    suite simply by providing a `test_suite` argument that points to the root test
    suite directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be necessary to ensure that the path to the test suite directory has
    been added to `sys.path` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The current `setup` function call, then, includes `test_suite` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire test suite can then be executed with `python setup.py test`, which
    returns a line-by-line summary of the tests executed and their results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1b2a20c0-4b4f-41d7-b01b-63d65a66e9ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Packaging the code in a component project still uses `python setup.py sdist`
    from within the individual project directories, and still yields an installable
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6b72172-6fef-4178-b77b-8fef817def58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Demonstrating the new data-persistence functionality could be done in several
    ways, but requires the creation of disposable/temporary demo data objects in a
    disposable/temporary database. There''s code in the `test_co_objects` test module
    that does just that, so creating a minimal data object class based on that structure
    (calling it `ExampleObject` for demonstrative purposes), then running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes care of generating a dataset that can be examined. From that point,
    any tool – the command-line `mongo` client or a GUI, such as Robo3T – can be used
    to view and verify that data was, in fact, persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e59a1ff0-2bc4-42a8-bea5-4c6e3090b0a8.png)'
  prefs: []
  type: TYPE_IMG
- en: If more detailed acceptance examples are needed – such as examples for each
    of the business object types – a similar script could be written to create `Artisan`
    and `Product` instances and save them as well. Similarly, with respect to the
    `hms_artisan` data object classes, simply showing the files written for objects
    in an example/demo environment should suffice.
  prefs: []
  type: TYPE_NORMAL
- en: Operations/use, maintenance, and decommissioning considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no substantial change yet as these items are concerned:'
  prefs: []
  type: TYPE_NORMAL
- en: The packages, though there are now three of them, are still very simple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we've added an external dependency with the inclusion of the `pymongo`
    library, we're not yet at a point where we need to worry about how that dependency
    will be handled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will obviously need to be a MongoDB installation, but until the code is
    ready to be integrated to some shared environment, even that is a non-issue –
    local development can use local database engines for now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a decommissioning perspective, uninstalling the software hasn't really
    changed except that there are now three packages to uninstall – but the process
    for each is a variation of the process as it stood at the end of the last iteration
    (`pip uninstall HMS-Core`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there may be other data-access and data-persistence tweaks in later iterations,
    and there are a few data objects whose specific details aren't known yet because
    of integration concerns with other systems, the bulk of the data objects work
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, the development iterations against the `hms_sys` code bases have had
    most of their attention focused on what might be thought of as system functionality – ensuring
    that data structures are well formed, can be validated, and will live longer than
    a single user session or Python run. Interaction with system data from a user
    perspective hasn't been addressed yet at all. Before that can be addressed, though,
    there is another layer that needs to be at least analyzed, if not built – the
    Artisan Gateway service, which acts as a central point where data from remote
    artisans and Central Office staff comes together.
  prefs: []
  type: TYPE_NORMAL
