- en: An In-Depth Look at Dynamic Allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to work with dynamic memory allocation.
    This chapter is important because not all variables can be defined globally or
    on the stack (that is, from within a function), as global memory should be avoided
    where possible and stack memory is usually far more limited than heap memory (the
    memory that's used for dynamic memory allocations). The use of heap memory, however,
    has lead to numerous bugs over the years with respect to leaking and dangling
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you not only how this dynamic memory allocation works
    but also how to allocate memory from the heap correctly in a C++ Core Guideline
    compliant manner.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with why we use smart pointers as well as the difference between them,
    conversions, and other references, we will conclude this chapter with a brief
    explanation of how the heap works under Linux and why dynamic memory allocation
    is so slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing std::shared_ptr and std::unique_ptr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting from a unique_ptr into a shared_ptr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with circular references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typecasting with smart pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heap under a microscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To compile and run the examples in this chapter, you must have administrative
    access to a computer running Ubuntu 18.04 with a functional internet connection.
    Prior to running these examples, you must install Valgrind using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If this is installed on any operating system other than Ubuntu 18.04, then GCC
    7.4 or higher and CMake 3.6 or higher will be required.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter10](https://github.com/PacktPublishing/Advanced-CPP-CookBook/tree/master/chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing std::shared_ptr and std::unique_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about why the C++ Core Guidelines discourage the
    use of manually calling new and delete and why, instead, they recommend the use
    of `std::unique_ptr` and `std::shared_ptr`. We will also learn about the differences
    between a `std::unique_ptr` and a `std::shared_ptr` and why a `std::shared_ptr`
    should only be used in certain scenarios (that is, why `std::unique_ptr` is likely
    to be the smart pointer type that you should be using in most scenarios). This
    recipe is important as it will teach you how to properly allocate dynamic (heap)
    memory in modern C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In C++, there are three different ways to declare a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global variables**: These are variables that are globally accessible. On
    Linux, these usually exist in the `.data`, `.rodata`, or `.bss` sections of your
    executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack variables**: These are variables that you define inside functions and
    reside in your application''s stack memory, which is managed by the compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Heap variables**: These are variables that are created using `malloc()`/`free()`
    or `new()`/`delete()` and use heap memory that is managed by a dynamic memory
    management algorithm (for example, `dlmalloc`, `jemalloc`, `tcmalloc`, and so
    on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on the latter, that is, heap style memory allocation.
    You might already know that, in C++, memory is allocated using `new()` and `delete()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, an integer pointer (that is, a pointer that points to an integer)
    is allocated and then set to `42`. We use `new()` in C++ and not `malloc()` for
    the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`malloc()` returns `void *` and not the type that we care about. This can lead
    to allocation mismatch bugs (that is, you intend to allocate a car, and instead
    you allocate an orange). In other words, `malloc()` does not provide type safety.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malloc()` requires a size parameter. In order to allocate memory, we are required
    to know how many bytes to allocate for the type that we care about. This can lead
    to allocation size mismatch bugs (that is, you intend to allocate enough bytes
    for a car, but instead you only allocate enough bytes for an orange).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`malloc()` returns `NULL` on error, requiring `NULL` checks on every allocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `new()` operator addresses all of these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '`new()` returns `T*`. As shown in the preceding example, this even allows for
    the use of `auto`, preventing redundancy, as C++''s type system has enough information
    to properly allocate and track the desired type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new()` doesn''t take a size argument. Instead, you tell it what type you want
    to allocate, which already has the size information about the type implicitly.
    Once again, by simply stating what you want to allocate, you get what you want
    to allocate, including the proper pointer and size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new()` throws an exception if the allocation fails. This prevents the need
    for `NULL` checks. If the next line of code executes, you are guaranteed that
    the allocation succeeds (assuming you do not have exceptions disabled).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is, however, still one issue with the `new()` operator; `new()` doesn't
    track ownership. Like `malloc()`, the `new()` operator returns a pointer, and
    this pointer can be passed around from function to function with no concept of
    who actually owns the pointer, which means it should delete the pointer when it
    is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept of ownership is a key component of the C++ Core Guidelines (in
    addition to memory spans) that attempts to address common bugs in C++ that result
    in instability, reliability, and security bugs. Let''s take a look at an example
    of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we allocate an integer pointer and then delete the
    pointer twice. In the previous example, we never actually delete the integer pointer
    prior to exiting the program. Now, consider the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we allocate an integer pointer, delete it, and then
    use it. Although these examples seem simple and obvious to avoid, in large, complex
    projects, these types of bugs occur often enough that the C++ community has developed
    static and dynamic analysis tools to identify these type of bugs automatically
    for us (although they are not perfect), as well as the C++ Core Guidelines themselves,
    in an attempt to prevent these types of bugs in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C++11, the standards committee introduced `std::unique_ptr` to address this
    ownership issue with `new()` and `delete()`. Here is how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we allocate an integer pointer using the `std::make_unique()`
    function. This function creates a `std::unique_ptr` and gives it a pointer that's
    allocated using `new()`. Here, the resulting pointer (for the most part) looks
    and behaves like a regular pointer, with the exception that the pointer is deleted
    automatically when `std::unique_ptr` loses scope. That is to say, `std::unique_ptr`
    owns the pointer that was allocated using `std::make_unique()` and is responsible
    for the lifetime of the pointer itself. In this example, we don't need to run
    `delete()` manually as `delete()` is run for us when the `main()` function is
    complete (as that is when `std::unique_ptr` loses scope).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this simple trick of managing ownership, all of the bugs shown in the
    preceding code can be avoided (for the most part, which we will get to later).
    Although the following code is not C++ Core Guideline compliant (as the subscript
    operator is discouraged), you can also allocate arrays using `std::unique_ptr`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we allocate a C-style array of size `100` and
    then set the first element in the array. In general, the only pointer type that
    you will ever need is `std::unique_ptr`. There are, however, some issues that
    can still arise:'
  prefs: []
  type: TYPE_NORMAL
- en: Not tracking the lifetime of a pointer properly, for example, allocating `std::unique_ptr`
    in a function and returning the resulting pointer. Once the function returns, `std::unique_ptr`
    loses scope and thus deletes the pointer you just returned. `std::unique_ptr`
    *does not* implement automatic garbage collection. You are still required to understand
    the lifetime of the pointer and how that affects your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is still possible to leak memory (although far more difficult) by never providing `std::unique_ptr`
    with an opportunity to lose scope; for example, adding `std::unique_ptr` to a
    global list or allocating `std::unique_ptr` in a class that you manually allocate
    with `new()` and then leak. Once again, `std::unique_ptr` *does not* implement
    automatic garbage collection and you are still required to ensure `std::unique_ptr`
    loses scope when needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unique_ptr` is also not capable of supporting shared ownership. Although
    this is an issue, this type of scenario rarely occurs. In most scenarios, `std::unique_ptr`
    is all that you need to ensure proper ownership.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One question that is raised often is, *once the pointer is allocated, how do
    we safely pass this pointer to other functions?* The answer is, you use the `get()`
    function and pass the pointer as a regular, C-style pointer. `std::unique_ptr`
    defines ownership, not `NULL` pointer safety. `NULL` pointer safety is provided
    by the Guideline Support Library with the `gsl::not_null` wrapper and `expects()`
    macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'How these are used depends on your pointer philosophy:'
  prefs: []
  type: TYPE_NORMAL
- en: Some believe any function that takes a pointer as an argument should be checked
    for a `NULL` pointer. The advantage of this approach is a `NULL` pointer can be
    identified quickly and safely handled, while the disadvantage is the extra branch
    logic you are introducing to your code, which reduces performance and readability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some believe *public* functions that take a pointer as an argument should be
    checked for a `NULL` pointer. The advantage of this approach is an improvement
    in performance as not all functions need `NULL` pointer checks. The disadvantage
    of this approach is that the public interfaces still have extra branch logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some believe a function should simply document its expectations (called a contract).
    The benefit to this approach is that the `assert()` and `expects()` macros can
    be used to check for `NULL` pointers in debug mode to enforce this contract, while
    in release mode, there are no performance penalties. The disadvantage of this
    approach is that, in release mode, all bets are off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which approach you take will largely depend on the type of application you are
    writing. If you are writing the next Crush game, you will likely care more about
    the latter approach as it performs the best. If you are writing an application
    that will automatically pilot an aircraft, we all hope you are using the first
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how to pass a pointer using `std::unique_ptr`, let''s look at
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you have a super critical function that is executed as a thread, taking
    an integer pointer as an argument, and adding the provided integer to a global
    counter. The preceding implementation of this thread is an *all bets off*, cross
    your fingers, and hope for the best approach. This function can be implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function calls `std::terminate()` (not a very fault-tolerant
    approach) if the provided pointer is a `NULL` pointer. As we can see, this approach
    is hard to read as there is a lot of extra logic here. We could implement this
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This does the same thing as a `NULL` pointer check (depending on how you define
    `gsl::not_null` to work, as this could also throw an exception). You could also
    implement this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous example always checks for `NULL` pointers while the preceding approach
    uses the contract approach, allowing the check to be removed in release modes.
    You could also use `assert()` as well (if you are not using the GSL... which jokingly,
    of course, should never be the case).
  prefs: []
  type: TYPE_NORMAL
- en: 'It should also be noted that the C++ standards committee is working to add
    `expects()` logic as a core component of the language through the use of C++ contracts,
    a feature that was sadly removed from C++20, but will hopefully be added in future
    versions of the standard, as we might be able to write the preceding function
    as follows (and tell the compiler which approach we wish to use instead of having
    to manually write it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code example, we can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We allocate an integer pointer from the heap using `std::make_unique()`, which
    returns `std::unique_ptr()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an array of threads and execute each thread, passing the newly allocated
    pointer to each one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we wait for all of the threads to finish and output the resulting count.
    Since `std::unique_ptr` is scoped to the `main()` function, we must ensure that
    the threads finish prior to returning from the `main()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding example results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/174f4cca-9a24-4400-8cc9-193f3b2d646b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we mentioned previously, the preceding example defines `std::unique_ptr`
    as scoped to the `main()` function, which means we must ensure the threads are
    done before the `main()` function returns. This type of scenario is not always
    the case. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a function that adds to a count when given an integer pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the `main()` function is also identical to
    our previous example, with the exception that `std::unique_ptr` is created in
    its own scope, which is released before the threads are required to complete.
    This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf6bd321-786d-4be2-9694-3287c2c6229f.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, the resulting output is garbage as the
    threads attempted to read from memory that has been deleted (that is, the threads
    were given a dangling pointer).
  prefs: []
  type: TYPE_NORMAL
- en: Although this is a simple example, this type of scenario can occur in more complex
    scenarios and the root of the issue is shared ownership. In this example, each
    thread owns the pointer. In other words, no one thread attempts to take sole ownership
    of the pointer (including the main thread that allocates and executes the other
    threads). Although this type of issue usually occurs in multithreaded applications
    that have this no master thread design, this can also occur in asynchronous logic
    where the pointer is allocated and then passed to multiple, asynchronous jobs
    whose lifetime and point of execution are unknown.
  prefs: []
  type: TYPE_NORMAL
- en: To handle these specific types of issues, C++ provides `std::shared_ptr`. This
    is a wrapper around a managed object. Each time `std::shared_ptr` is copied, the
    managed object increases an internal counter, which is used to track how many
    owners the pointer (which the managed object stores) has. Each time `std::shared_ptr`
    loses scope, the managed object decreases the internal counter and deletes the
    pointer once this count reaches `0`. Using this approach, `std::shared_ptr` is
    capable of supporting a one-to-many ownership model, which can handle the scenarios
    we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we have the same thread function that increments
    a counter, but the difference is that it takes `std::shared_ptr` instead of a
    regular integer pointer. Now, we can implement our preceding example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the pointer is created in its own scope, which
    is removed before the threads are required to complete. Unlike the previous example,
    however, this code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/510ee43e-1a06-46ff-8411-882af9ebb984.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason the preceding code executes properly is the pointer's ownership is
    shared between all of the threads and the pointer itself is not deleted (even
    though the scope is lost) until all of the threads complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note: it might be tempting to use `std::shared_ptr` for all pointer
    types when `std::unique_ptr` should be used instead as it has nice typecasting
    APIs and, in theory, ensures that a function has a valid pointer. The reality
    is, regardless of the use of `std::shared_ptr` or `std::unique_ptr`, a function
    must perform its `NULL` checks as defined by your application''s needs as `std::shared_ptr`
    can still be created as a `NULL` pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::shared_ptr` also has added overhead, as it must store the deleter that
    it needs internally. It also requires an additional heap allocation for the managed
    object. Both `std::shared_ptr` and `std::unique_ptr` define pointer ownership.
    They do not provide automatic garbage collection (that is, they do not automatically
    handle pointer lifetime), nor do they guarantee a pointer is not `NULL`. `std::shared_ptr`
    should only be used when more than one thing must own the lifetime of a pointer
    to ensure the proper execution of your application; otherwise, use `std::unique_ptr`.'
  prefs: []
  type: TYPE_NORMAL
- en: Converting from a std::unique_ptr into a std::shared_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to convert from a `std::unique_ptr` into a
    `std::shared_ptr`. This recipe is important as it is often convenient to define
    an API as accepting `std::unique_ptr` when the API itself really needs `std::shared_ptr`
    for internal use. A good example of this is when creating a GUI API. You might
    pass a widget to the API to store and own, without knowing if, later on down the
    road, the implementation of your GUI might need to add threads, in which case `std::shared_pointer`
    might be a better option. This recipe will provide you with the skills to convert
    a `std::unique_ptr` into a `std::shared_ptr` if needed, without having to modify
    the API itself.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`std::shared_ptr` is used to manage a pointer when more than one thing must
    own the pointer for the application to execute properly. Suppose, however, that
    you provide an API that must accept an integer pointer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding API suggests that whoever calls this function owns the integer
    pointer. That is, whoever calls this function is required to allocate the integer
    pointer, as well as delete it once the function is complete. If, however, we intend
    for the preceding API to own the pointer, we really should write this API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This API says, *please allocate me an integer pointer, but I own it once it''s
    passed and will ensure it is deleted when needed.* Now, suppose this function
    will use this pointer in a one-to-many ownership scenario. What do you do? You
    could write your API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This would, however, prevent your API from optimizing the one-to-many relationship
    in the future (that is, if you were able to remove this relationship in the future,
    you would still be stuck with `std::shared_ptr`, even though it is suboptimal
    without having to modify the API's function signature).
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, the C++ APIs provide the ability to convert a `std::unique_ptr` into
    a `std::shared_ptr`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we have an internal function that, for now, takes an integer pointer
    as a `std::shared_ptr`, uses its value to increment `count`, and executes it as
    a thread. Then, we provide a public API for it to use this internal function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, our API claims ownership of a previously allocated
    integer pointer. Then, it creates a series of threads, executing each one and
    waiting for each thread to finish. The problem is that our internal function requires
    a `std::shared_ptr` (for example, maybe this internal function is used somewhere
    else in the code where there is a one-to-many ownership scenario that we cannot
    remove at the moment).
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the need to define our public API with `std::shared_ptr`, we can
    convert `std::unique_ptr` into `std::shared_ptr` by moving `std::unique_ptr` into
    a new `std::shared_ptr` and then calling our threads from there.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::move()` is required, as the only way to pass ownership of `std::unique_ptr`
    is through the use of `std::move()` (as only one `std::unique_ptr` can own the
    pointer at any given time).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can execute this public API as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3662afb6-a730-4b83-a259-0d9182ad87de.png)'
  prefs: []
  type: TYPE_IMG
- en: In the future, we might be able to remove the need for `std::shared_ptr` and
    pass `std::unique_ptr` to our internal function using the `get()` function, and,
    when that time comes, we won't have to modify the public API.
  prefs: []
  type: TYPE_NORMAL
- en: Working with circular references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to work with circular references. A circular
    reference occurs when we're using more than one `std::shared_ptr`, where each
    `std::shared_ptr` owns a reference to the other. This recipe is important as this
    type of circular reference can occur when we're working with circularly dependent
    objects (although this should be avoided whenever possible). If it does occur,
    the shared nature of `std::shared_ptr` results in a memory leak. This recipe will
    provide you with the skills to avoid said memory leak using `std::weak_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To work with circular references, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code for this
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although they should be avoided, circular references are likely to occur as
    your projects grow more and more complex and in size. If shared smart pointers
    are leveraged when these circular references occur, a hard to find memory leak
    can occur. To understand how this is possible, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, we start with two class prototypes. Circular
    references almost always start in this fashion as one class depends on another
    and vice versa, requiring the use of a class prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a `car` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, this is a simple class that stores a shared
    pointer to an `engine` and friends a function named `build_car()`. Now, we can
    define an `engine` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, an `engine` is similar to a `car` with the difference
    that the engine stores a shared pointer to a car. Both, however, friend a `build_car()`
    function. Both also create default constructed shared pointers, meaning their
    shared pointers are `NULL` pointers at the time of construction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `build_car()` function is used to complete the construction of each object,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we create each object and then set the car''s
    engine and vice versa. Since both the car and the engine are scoped to the `build_car()`
    function, we expect that these pointers will be deleted once the `build_car()`
    function returns. Now, we can execute this `build_car()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems like a simple program, but it has a hard to find memory leak. To
    demonstrate this, let''s run this application in `valgrind`, which is a dynamic
    memory analysis tool that''s capable of detecting memory leaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d039e626-58e3-4399-88f3-bb7b58a9d235.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, `valgrind` says that memory was leaked.
    If we run `valgrind` with `--leak-check=full`, it will tell us that the memory
    leaks are with the car and engine shared pointers. The reason this memory leak
    occurs is that the car holds a shared reference to an engine. This same engine
    holds a shared reference to the car itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we have added a call to `use_count()`, which
    outputs the number of owners `std::shared_ptr` contains. If this is executed,
    we''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fe8e3a7-4ec9-46f6-9e6f-14f91b815586.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason we can see two owners is because the `build_car()` function holds
    a reference to a car and an engine here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The car holds a second reference to an engine because of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also the same for the engine and the car. When the `build_car()` function
    completes, the following loses scope first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The engine, however, is not deleted because the car still holds a reference
    to the engine. Then, the car loses scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: However, the car is not deleted because the engine (which hasn't been deleted
    yet) also holds a reference to the car. This results in `build_car()` returning
    with neither the car nor the engine being deleted because both still hold a reference
    to each other, with no means of telling either object to remove their references.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of circular memory leak, although easy to identify in our example,
    can be extremely difficult to identify in complex code, which is one of many reasons
    why shared pointers and circular dependencies should be avoided (usually a better
    design can remove the need for both). If this cannot be avoided, `std::weak_ptr`
    can be used instead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we still define our car as holding a shared
    reference to an engine. We do this as we assume a car has a longer lifetime (that
    is, in our model, you can have a car without an engine, but you cannot have an
    engine without a car). The engine, however, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the engine now stores a weak reference to the
    car. Our `build_car()` function is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, the `build_car()` function doesn''t change.
    The difference now is that, when we execute this application using `valgrind`,
    we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ac121f9-776c-48ff-a5e0-fdbe56d97fa4.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, there are no memory leaks, and the `use_count()`
    for the car is `1`, while the `use_count()` for the engine is still `2` compared
    to the previous example. In the engine class, we use `std::weak_ptr`, which has
    access to the managed object `std::shared_ptr` manages, but doesn't increase the
    managed object's internal count when created. This provides `std::weak_ptr` with
    the ability to query whether `std::shared_ptr` is valid without having to hold
    a strong reference to the pointer itself.
  prefs: []
  type: TYPE_NORMAL
- en: The reason the memory leak is removed is that, when the engine loses scope,
    its use count is decreased from `2` to `1`. Once the car loses scope, which only
    has a use count of `1`, it gets deleted, which in turn decrements the engine's
    use count to `0`, which causes the engine to be deleted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason we use `std::weak_ptr` instead of a C-style pointer in the engine
    is because `std::weak_ptr` provides us with the ability to query the managed object
    to see if the pointer is still valid. For example, suppose we need to check whether
    the car still exists, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `expired()` function, we can test to see whether the car still exists
    before using it, which is something that isn''t possible with a C-style pointer.
    Now, we can write our `build_car()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we create an engine and then create a new scope that
    creates our car. Then, we create our circular reference and lose scope. This causes
    the car to be deleted as expected. The difference is that our engine isn''t deleted
    yet as we still hold a reference to it. Now, we can run our test function, which
    results in the following output when it''s run with `valgrind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37efcbf4-6ee5-4fef-b31a-150aa6c7b76f.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, there are no memory leaks. `std::weak_ptr`
    successfully removed the chicken and egg problem that was introduced by the circular
    reference. As a result, `std::shared_ptr` is able to function as expected, releasing
    memory in the right order. In general, circular references and dependencies should
    be avoided whenever possible, but, if they cannot be avoided, `std::weak_ptr`,
    as shown in this recipe, can be used to prevent memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting with smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to typecast using `std::unique_ptr` and `std::shared_ptr`.
    Typecasting allows you to convert one type into another. This recipe is important
    as it demonstrates the proper way of handling typecasting with `std::unique_ptr`
    and `std::shared_ptr` when attempting to convert the smart pointer's type (for
    example, when upcasting or downcasting with virtual inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see how typecasting works, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typecasting with smart pointers is not as straightforward as you might expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explain this better, let''s look at a simple example of how to typecast
    from a base class to a subclass using `std::unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a virtual base class, as shown in the preceding code, and then
    we subclass the base class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a `std::unique_ptr` in our `main()` function and pass the pointer
    to a `foo()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`std::unique_ptr` simply owns the lifetime of the pointer. Any use of the pointer
    requires the use of the `get()` function, which converts `std::unique_ptr` into
    a normal, C-style pointer from that point on. This is the intended use of `std::unique_ptr`,
    since it isn''t designed to ensure pointer safety and is designed to ensure who
    owns the pointer is well-defined, ultimately determining when the pointer should
    be deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `foo()` function can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the `foo()` function can treat the pointer as
    a normal C-style pointer, using `dynamic_cast()` to downcast from the base pointer
    back to the original subclass.
  prefs: []
  type: TYPE_NORMAL
- en: This same style of typecasting, which is standard C++, does not work with `std::shared_ptr`.
    The reason why is because the code that needs a typecast version of `std::shared_ptr`
    might also need to hold a reference to the pointer (that is, a copy of `std::shared_ptr`
    to prevent deletion).
  prefs: []
  type: TYPE_NORMAL
- en: That is, it is not possible to go from `base *b` to `std::shared_ptr<subclass>`
    because `std::shared_ptr` doesn't hold a reference to the pointer; instead, it
    holds a reference to a managed object, which stores the reference to the actual
    pointer. Since `base *b` doesn't store a managed object, there is no way to create
    a `std::shared_ptr` from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ does, however, provide `std::shared_ptr` versions of `static_cast()`, `reinterpret_cast()`,
    `const_cast()`, and `dynamic_cast()` to perform the typecasting of shared pointers,
    which preserves the managed object when typecasting. Let''s take a look at an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, we start with the same base and subclass. The
    difference occurs in our `foo()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Instead of taking `base *b`, it takes `std::shared_ptr<base>`. Now, we can use
    the `std::dynamic_pointer_cast()` function instead of `dynamic_cast()` to downcast
    `std::shared_ptr<base>` to a `std::shared_ptr<subclass>`. The `std::shared_ptr`
    typecast functions provide us with the ability to typecast while still maintaining
    access to a `std::shared_ptr` as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting `main()` function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b7d0aa2-1117-4b34-a220-0b1bba6777d6.png)'
  prefs: []
  type: TYPE_IMG
- en: It should be noted that we don't need to explicitly upcast as this can be done
    automatically (similar to regular pointers). We are only required to downcast
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The heap under a microscope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how the heap works in Linux. We will take a deeper
    look into how Linux actually provides heap memory when you use `std::unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Although this recipe is intended for those of you who have more advanced capabilities,
    it is important as it will teach you what your application does to allocate memory
    from the heap (that is, using `new()`/`delete()`), which, in turn, will show you
    why heap allocations should never be done from time critical code, since they
    are slow. This recipe will teach you the skills you'll need when heap allocations
    are safe to perform and when heap allocations should be avoided in your applications,
    even if some of the assembly code that we inspect is hard to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before beginning, please ensure that all of the technical requirements have
    been met, including installing Ubuntu 18.04 or higher and running the following
    in a Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, open a new Terminal. We will use this Terminal to download,
    compile, and run our examples.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try the code files for this chapter, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a new Terminal, run the following to download the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the source code, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code has been compiled, you can execute each example in this
    recipe by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will step through each of these examples and explain
    what each example program does and how it relates to the lessons being taught
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand the extent to which code has to execute so as to allocate
    a variable on the heap, we will start with the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding example, we allocate an integer using `std::unique_ptr()`.
    We use `std::unique_ptr()` as our starting point, as this is how most C++ Core
    Guideline code will allocate memory on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::make_unique()` function allocates a `std::unique_ptr` using the following
    pseudo logic (this is a simplified example as this doesn''t show how custom deleters
    are handled):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, the `std::make_unique()` function creates a
    `std::unique_ptr` and gives it a pointer that it allocates with the `new()` operator.
    Once `std::unique_ptr` loses scope, it will delete the pointer using `delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler sees the new operator, it replaces the code with a call to
    operator `new(unsigned long)`. To see this, let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we allocate a simple pointer using `new()`. Now,
    we can look at the resulting compiled assembly, which can be seen in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b091f70c-4180-4aa8-a75b-8d820a238fbb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the following screenshot, a call is made to `_Znwm`, which is mangled
    C++ code for `operator new(unsigned long)`, which is easy to demangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c027acee-fceb-4dbb-89c2-3bd138eecd8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `new()` operator itself looks like the following pseudocode (note that
    this doesn''t take into account the ability to disable exception support or provide
    support for a new handler):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can look at the new operator to see `malloc()` being called:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/837ddc0c-aa39-4480-a9dd-618520a38d5f.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, `malloc()` is called. If the resulting
    pointer is not `NULL`, the operator returns; otherwise, it enters its error state,
    which involves calling a new handler and eventually throwing `std::bad_alloc()`
    (at least by default).
  prefs: []
  type: TYPE_NORMAL
- en: The call to `malloc()` itself is far more complicated. When an application itself
    is started, the first thing it does is reserve heap space. The operating system
    gives every application a contiguous block of virtual memory to operate from,
    and the heap on Linux is the last block of memory in the application (that is,
    the memory that `new()` returns comes from the end of the application's memory
    space). Placing the heap here provides the operating system with a way to add
    additional memory to the application as it is needed (as the operating simply
    extends the end of the application's virtual memory).
  prefs: []
  type: TYPE_NORMAL
- en: The application itself uses the `sbrk()` function to ask the operating system
    for more memory when it runs out. When this function is called, the operating
    system allocates pages of memory from its internal page pool and maps this memory
    into the application by moving the end of the application's memory space. The
    map process itself is slow as the operating system not only has to allocate pages
    from the pool, which requires some sort of search and reservation logic, but it
    must also walk the application's page tables to add this additional memory to
    its virtual address space.
  prefs: []
  type: TYPE_NORMAL
- en: Once `sbrk()` has provided the application with additional memory, the `malloc()`
    engine takes over. As we mentioned previously, the operating system simply maps
    pages of memory into the application. Each page can be as small as 4k bytes to
    anywhere from 2 MB to even 1 GB, depending on the request. In our example, however,
    we allocated a simple integer, which is only `4` bytes in size. To convert pages
    into small objects without wasting memory, `malloc()` itself has an algorithm
    that breaks the memory provided by the operating system up into small blocks.
    This engine must also handle when these blocks of memory are freed so that they
    can be used again. This requires complex data structures to manage all of the
    application's memory, and each call to `malloc()`, `free()`, `new()`, and `delete()`
    has to exercise this logic.
  prefs: []
  type: TYPE_NORMAL
- en: A simple call to create a `std::unique_ptr` using `std::make_unique()` has to
    create `std::unique_ptr` with memory allocated from `new()`, which actually calls
    `malloc()`, which must search through a complex data structure to find a free
    block of memory that can eventually be returned, that is, assuming `malloc()`
    has free memory and doesn't have to ask the operating system for more memory using
    `sbrk()`.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, dynamic (that is, heap) memory is slow and should only be used
    when needed, and, ideally, not in time critical code.
  prefs: []
  type: TYPE_NORMAL
