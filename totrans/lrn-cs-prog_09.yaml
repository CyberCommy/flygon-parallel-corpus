- en: '*Chapter 9*: Resource Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed and worked with value types and reference
    types and have also seen how they differ. We also briefly talked about how the
    runtime is managing the allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will get into more details of this topic and look at the
    language features and best practices for managing memory and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be discussed in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finalizers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IDisposable interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `using` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform invoke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsafe code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to implement disposable
    types and how to dispose of objects when they are no longer needed. You will have
    also learned how to call native APIs and write unsafe code.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Common Language Runtime** (**CLR**) is responsible for managing the lifetime
    of objects and freeing memory when it's no longer used so that new objects can
    be allocated within the process. It does so through a component called the **garbage
    collector** (**GC**), which allocates objects on the managed heap in an efficient
    manner and clears memory by reclaiming objects that are no longer used. The garbage
    collector makes developing applications easier because you do not have to worry
    about manually freeing memory. This is what makes applications written for .NET
    to be known as *managed*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we discuss how all this happens, you need to understand the difference
    between **stack** and **heap**, as well as the differences between **types**,
    **objects**, and **references**.
  prefs: []
  type: TYPE_NORMAL
- en: A type (whether introduced with the `class` or `struct` keyword in C#) is a
    blueprint for constructing objects. It is described in the source code using language
    features. An object is an instantiation of a type and lives in memory. A reference
    is a sort of handle (basically, a storage location) that points to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss memory. The stack is a relatively small segment of memory
    allocated by the compiler that keeps track of the memory necessary for running
    the application. The stack has **Last In First Out (LIFO)** semantics and grows
    and shrinks as the program execution is invoking functions or returning from functions.
    The heap, on the other hand, is a large segment of memory that the program may
    use to allocate memory at runtime, and which, in .NET, is managed by the CLR.
  prefs: []
  type: TYPE_NORMAL
- en: Objects of value types may be stored in multiple locations. They are typically
    stored on the stack, but they can also be stored on CPU registers. Value types
    that are a part of a reference type are stored on the heap as part of the *enclosing
    object*. Objects of reference types are always stored on the heap, but references
    to objects are stored on the stack or CPU registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s consider the following short program, where
    `Point2D` is a value type and `Engine` is a reference type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Conceptually (because this is a very simplistic representation), the stack
    and heap will contain the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The conceptual representation of the stack and heap content
    during the execution of the preceding program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The conceptual representation of the stack and heap content during
    the execution of the preceding program
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack is managed by the compiler and, for the rest of this chapter, we
    will discuss the heap and how the runtime manages it. The .NET runtime divides
    objects into two groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large**: These objects are those objects that are larger than 85 KB; multidimensional
    objects are also included in this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Small**: These objects are all other objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The heap is composed of several memory segments called **generations**. There
    are three generations of memory – **0**, **1**, and **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: Generation 0 contains *small*, and usually *short-lived, objects,* such as local
    variables or objects instantiated for the lifetime of a function call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation 1 contains *small objects* that have survived a garbage collection
    of memory from generation 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation 2 contains *long-lived small objects* that have survived a garbage
    collection of memory from generation 1 and large objects (which are always allocated
    on this segment).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the runtime needs to allocate objects on the managed heap and there is
    not enough memory, it triggers a garbage collection. A garbage collection has
    three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the garbage collector builds a graph of all live objects in order to
    figure out what is still used and what may be deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, references to objects that will be compacted are updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, the dead objects are removed, and the surviving objects are compacted.
    Typically, the large object heap containing large objects is not compacted because
    moving large chunks of data incurs performance costs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the garbage collection starts, all the managed threads are suspended, with
    the exception of the thread that started the collection. The threads are resumed
    when the garbage collection ends. The garbage collection's first phase starts
    from the so-called **application roots**, which are storage locations that contain
    references to objects on the heap. Application roots include references to global
    objects, static objects, fields, local objects, objects passed as function arguments,
    objects waiting to be finalized, and CPU registers that contain references to
    objects on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: The CLR builds a graph of reachable heap objects; everything that is not reachable
    will be deleted. If all generation 0 objects have been evaluated, but the freed
    memory is not enough, the garbage collection proceeds to evaluate generation 1\.
    If more memory is required after this, the garbage collection proceeds to evaluate
    generation 2.
  prefs: []
  type: TYPE_NORMAL
- en: Objects that survived the garbage collection of generation 0 are assigned to
    generation 1, and objects that survived from generation 1 are assigned to generation
    2\. However, objects that survive the garbage collection of generation 2 remain
    in generation 2\. If the garbage collection process is finished and there is not
    enough memory on the large object heap (that's always part of generation 2) to
    allocate as requested, the CLR throws an exception of the `OutOfMemoryException`
    type. This does not necessarily mean there is no more memory, but that the uncompacted
    memory on this segment does not contain a chunk large enough for the new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base class library contains a class called `System.GC` that enables us
    to interact with the garbage collector. However, this is seldom the case, apart
    from implementing the disposable pattern that we will see later in this chapter,
    in the *The IDisposable interface* section. Here are several members of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_09_Table_1_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following program uses the `System.GC` class to show the current generation
    of the `Engine` object, as well as the estimated size of the managed heap, at
    the time of the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – A console screenshot showing the output of the preceding program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – A console screenshot showing the output of the preceding program
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about finalizers in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The garbage collector provides the automatic disposal of managed resources.
    However, there are cases when you have to work with unmanaged resources such as
    raw file handles, windows, or other operating system resources retrieved with
    **Platform Invocation Services** (**P/Invoke**) calls, as well as COM object references
    in some advanced scenarios. These resources need to be explicitly released before
    the object is destroyed by the garbage collector; otherwise, resource leaks occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every object has a special method called the `System.Object` class has a virtual
    and protected member called `Finalize()`, with an empty implementation. This is
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is a virtual method, you cannot actually override it directly.
    Instead, the C# language offers a syntax identical to the one for destructors
    in C++ to create a finalizer and override the `System.Object` method. However,
    this is only possible to implement for reference types; value types cannot have
    finalizers since they are not garbage collected. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason you cannot explicitly override the `Finalize()` method is that the
    C# compiler will add additional code to ensure that the base class implementation
    is actually called during finalization (this means the `Finalize()` method is
    called on all instances in the inheritance chain). Therefore, the code shown earlier
    for the finalizer is replaced by the compiler with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Although a class may have multiple constructors, it can only have *one finalizer*.
    Finalizers cannot, therefore, be overloaded or have modifiers and parameters;
    they also cannot be inherited. Finalizers are not called directly, but are invoked
    by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: The way the garbage collector invokes the finalizers is as follows. When an
    object that has a finalizer is created, the garbage collector adds a reference
    to it to an internal structure called the *finalization queue*. When proceeding
    with collecting objects, the garbage collector calls the finalizers on all the
    objects on the finalization queue, unless they have been exempted from finalization
    with a call to `GC.SupressFinalize()`. This is also done when the application
    domain is being unloaded, but only for .NET Framework; for .NET Core, this is
    not the case. The invocation of the finalizers is still non-deterministic. The
    exact moment of the call is undefined as well as the thread on which the invocation
    occurs. Also, the finalizers of two objects, even when referring to one another,
    is not guaranteed to happen in any particular order.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: Because finalizers incur a performance loss, make sure that you do not create
    empty finalizers. Implement a finalizer if, and only if, your object must dispose
    of an unmanaged resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HandleWrapper` class shown in the following code is a wrapper for a native
    handler. An actual implementation may be more complex; this is shown for teaching
    purposes only. The raw handle may be created in native code and passed to a managed
    application. This class takes ownership of the handle and therefore needs to release
    it when the object is no longer needed. This is done with a call to the `CloseHandle()`
    system API using *P/Invoke*. The class defines a finalizer to do so. Let''s take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is seldom the case when you actually need to create a finalizer. For scenarios
    such as the one mentioned previously, there are system wrappers available for
    handling unmanaged resources. You should use one of the following safe handles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SafeFileHandle`: A wrapper for a file handle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafeMemoryMappedFileHandle`, a wrapper for memory-mapped file handles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafeMemoryMappedViewHandle`, a wrapper for a pointer to a block of unmanaged
    memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafeNCryptKeyHandle`, `SafeNCryptProviderHandle`, and `SafeNCryptSecretHandle`,
    wrappers for cryptographic handles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafePipeHandle`, a wrapper for pipe handles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafeRegistryHandle`, a wrapper for a handle to a registry key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SafeWaitHandle`, a wrapper for a wait handle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As already mentioned, finalizers are still non-deterministic. To ensure the
    deterministic release of resources, either managed or unmanaged, a type should
    provide a `Close()` method or implement the `IDisposable` interface. In this case,
    the finalizer could be used only to free unmanaged resources in the event the
    `Dispose()` method was not called.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about the `IDisposable` interface in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The IDisposable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deterministic disposal of resources can be done by implementing the `System.IDisposable`
    interface. This interface has a single method called `Dispose()` that can be explicitly
    called by users when an object is no longer used and its resources can be disposed
    of. However, you should only implement this interface in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: The class has ownership of *unmanaged resources*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class has ownership of *managed resources* that are themselves disposable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The way this interface should be implemented depends on whether the class has
    ownership of unmanaged resources. The general pattern, when you have both managed
    and unmanaged resources, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From the `Dispose()` method of the `IDisposable` interface, we call a protected
    virtual method with the same name (although it can have any name) and a parameter
    specifying that the object is being destroyed. To ensure that the disposal of
    resources is done only once, a Boolean field (called `disposed` here) is used.
    The Boolean parameter to the overloaded `Dispose()` method indicates whether the
    method is being called in a deterministic manner by the user or in a non-deterministic
    manner by the garbage collector when the object is finalized.
  prefs: []
  type: TYPE_NORMAL
- en: In the former case, both managed and unmanaged resources should be disposed
    of and the finalization of the object should be suppressed with a call to `GC.SupressFinalize()`.
    In the latter case, only unmanaged resources must be disposed of, because the
    disposal was not invoked by the user, but by the garbage collector. The reason
    this function is virtual and protected is that it should be possible for derived
    classes to override it, but it should not be possible to call it directly from
    outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to implement this for different scenarios. For starters, we
    will consider the case where the class has only disposable managed resources.
    In the following example, the `Engine` class implements `IDisposable`. What it
    does exactly, what resources it manages, and how it disposes of them is not important.
    However, the `Car` class has an owning reference to an `Engine` object, which
    should be destroyed as soon as the `Car` object is destroyed. Moreover, this should
    be done in a deterministic manner, when the `Car` is no longer needed. In this
    case, the `IDisposable` interface must be implemented as follows in the `Car`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since this class does not have a finalizer, the overloaded `Dispose()` method
    is of little use here, and the code can be further simplified. However, a derived
    class can override it and dispose of further resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we implemented a class called `HandleWrapper` that
    had a finalizer to close the system handle that it owned. In the following listing,
    you can see a modified version of this class that implements the `IDisposable`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This class has both a `Dispose()` method (that can be called by the user) and
    a finalizer (called by the garbage collector in case the user did not call the
    `Dispose()` method). There are no managed resources to release in this example,
    so the Boolean parameter of the overloaded `Dispose()` method is basically unused.
  prefs: []
  type: TYPE_NORMAL
- en: The language provides us with a way to automatically dispose of objects that
    implement the `IDisposable` interface when they are no longer needed. We will
    learn about this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The using statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we introduce the `using` statement, let's see how explicit resource management
    is done in a proper manner. This will help you to better understand the need and
    workings of the `using` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Car` class we looked at in the previous section can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A `try-catch-finally` block (although `catch` is not explicitly shown here)
    should be used in order to ensure proper disposal of the object when it is no
    longer needed. However, the C# language provides a convenient syntax for ensuring
    the correct disposal of an object with the `using` statement. This has the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler transforms this into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `using` statement introduces a scope for the variable defined in the statement
    and ensures that the object is properly disposed of before the scope is exited.
    The actual disposal depends on whether the resource is a value type, a nullable
    value type, a reference type, or a dynamic type. The call to `resource.Dispose()`
    earlier is actually one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For the car example, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple objects can be instantiated into the same `using` statement, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, multiple `using` statements can be chained together, as
    shown here, which is equivalent to the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In C# 8, the `using` statement can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For more information about this, refer to [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*.
  prefs: []
  type: TYPE_NORMAL
- en: Platform invoke
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we implemented a handle wrapper class that used a Windows
    API function, `CloseHandle()`, to delete system handles when the object was disposed
    of. The way a C# program can invoke Windows APIs, but also any function exported
    from a native **dynamic-linked library (DLL)**, is done through **Platform Invocation
    Services**, also known as **Platform Invoke** or **P/Invoke**.
  prefs: []
  type: TYPE_NORMAL
- en: 'P/Invoke locates and invokes an exported function and marshals the arguments
    between the managed and unmanaged boundaries. In order to be able to call a function
    using P/Invoke, you must know the name and signature of the function, as well
    as the name of the DLL from where it is exported. Then, you must create a managed
    definition of the unmanaged function. To understand how this works, we will look
    at an example of the `MessageBox()` function, available in `user32.dll`. The function
    signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create the following manage definition for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: The signature of the managed definition must match the native one, using the
    equivalent managed types for the parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function must be defined as `static` and `extern`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function must be decorated with `DllImportAttribute`. This attribute defines
    the necessary information for the runtime to call the native function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DllImportAttribute` requires at least the name of the DLL from which the native
    function is exported. You can omit the name of the entry point in the DLL, in
    which case the name of the managed function is used to identify it. However, you
    can also specify it explicitly using the `EntryPoint` property of the attribute.
    The other properties you can specify are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BestFitMapping`: A Boolean flag that indicates whether best-fit mapping is
    enabled. This is used when converting from Unicode to ANSI characters. Best-fit
    mapping enables the interop marshaler to use close-matching characters when an
    exact match does not exist (for instance, the copyright character is replaced
    with *c*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CallingConvention`: The calling convention for an entry point. The default
    value is `Winapi`, which defaults to `StdCall`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharSet`: Specifies the marshaling behavior for string parameters. It is also
    used to specify the entry point name to invoke. For instance, for the message
    box example, Windows has two functions actually—`MessageBoxA()` and `MessageBoxW()`.
    The value of the `CharSet` parameter enables the runtime to choose between one
    or the other; more precisely, the name ending in `A` for `CharSet.Ansi` (which
    is the default for C#) and the name ending in `W` for `CharSet.Unicode`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EntryPoint`: The entry point name or ordinal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExactSpelling`: Indicates whether the `CharSet` field determines the CLR to
    search the unmanaged DLL for entry-point names other than the one that has been
    specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreserveSig`: A Boolean flag that indicates whether the `HRESULT` or `retval`
    values are translated directly (if `true`) or automatically converted into exceptions
    (if `false`). The default value is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetLastError`: Indicates, if `true`, that the callee calls `SetLastError()`
    before returning. In this case, the CLR calls `GetLastError()` and caches the
    value to prevent it from being overwritten, and therefore lost, by other Windows
    API calls. To retrieve the value, you can call `Marshal.GetLastWin32Error()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThrowOnUnmappableChar`: Indicates (when `true`) whether the marshaler should
    throw an error when converting a Unicode character into ANSI ''`?`''. The default
    value is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the data types in the Windows API and C-style functions,
    as well as their corresponding C# or .NET Framework types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_09_Table_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '[1] Decorate with `CharSet.Ansi` or use the `[MarshalAs(UnmanagedType.LPStr)]`
    attribute on the `string` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Decorate with `CharSet.Unicode` or use the `[MarshalAs(UnmanagedType.LPWStr)]`
    attribute on the `string` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to properly call the `MessageBox()` function we defined earlier,
    we should also define constants for the possible arguments and return values.
    A snippet is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this all set, we can call the `MessageBox()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Many Windows APIs require a buffer to be used to return data. For instance,
    the `GetUserName()` function from `advapi32.dll` returns the name of the user
    associated with the current thread of execution. The function signature is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is a pointer to an array of characters, which is used to
    receive the name of the user, while the second is a pointer to an unsigned integer,
    which is used to specify the size of the buffer. The buffer needs to be large
    enough to receive the username. Otherwise, the function returns `false`, sets
    the required size in the `pcbBuffer` argument, and sets the last error to `ERROR_INSUFFICIENT_BUFFER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you could allocate a buffer large enough to hold the result (some
    functions impose limits on the size of the return value), you cannot always be
    sure. Therefore, typically, you call such a function twice:'
  prefs: []
  type: TYPE_NORMAL
- en: First, with an empty buffer to get back the actual size required for the buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, after allocating the necessary memory, a second time with a buffer large
    enough to receive the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To see how this works, we will P/Invoke the `GetUserName()` function, whose
    managed definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we use `StringBuilder` for the buffer parameter. Although this
    can grow to any capacity, we will need to know what size to specify. Instead of
    specifying a random large size, we call the function twice, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `StringBuffer` object is created with an initial capacity,
    although this is not really necessary. You don't have to specify its capacity;
    it will grow to the required one and receive the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s summarize Platform Invocation Services using the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows calling functions exported from native DLLs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must create a managed definition for a function, with the same signature
    and the equivalent managed types for the native ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must specify at least the function entry point and the name of the exporting
    DLL when defining the managed function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some drawbacks when you use P/Invoke, so you should keep the following
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: If you use P/Invoke to call functions from the Windows API, then your application
    will only work on Windows. This is not a problem if you don't intend to make it
    cross-platform. Otherwise, you have to avoid that altogether.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to call functions from a C++ library, you must specify the decorated
    names in your import declarations, which can be troublesome. If you are also authoring
    the C++ library, you can export functions with the `extern "C"` linkage to prevent
    the linker from decorating the names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a slight overhead for marshaling between the managed and unmanaged
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may not be very intuitive at times; for instance, what types to use for
    pointers and handles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last section of this chapter, we will discuss unsafe code and pointer
    types, which is the third category of types in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we discuss the types of .NET Framework and C# language support, we refer
    to value types (structures) and reference types (classes). However, there is yet
    another type that is supported, and that is **pointer types**. If you are not
    familiar with the C or C++ programming languages and pointers in particular, then
    you should know pointers are like *references*—they are storage locations that
    contain the addresses of objects. A reference is basically a *safe pointer* that
    is managed by the CLR.
  prefs: []
  type: TYPE_NORMAL
- en: To work with pointer types, you must establish a so-called *unsafe context*.
    In CLR terms, this is called *unverifiable code* because the CLR cannot verify
    its safety. Unsafe code is not necessarily dangerous, but it's your entire responsibility
    to ensure that you do not introduce pointer errors or security risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In truth, there are very rare cases where you actually have to work with pointers
    in unsafe contexts in C#. There are two common scenarios when this could be the
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions exported from a native DLL or COM server that require pointer
    types as parameters. However, in most cases, you still can do this with a safe
    code using `System.IntPtr` and members of the `System.Runtime.InteropServices.Marshal`
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing particular algorithms where performance is critical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can define an unsafe context using the `unsafe` keyword. This can be applied
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Types (class, struct, interface, delegate), in which case the entire textual
    context of the type is considered unsafe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods, fields, properties, events, indexers, operators, instance and static
    constructors, and destructors, in which case the entire textual context of the
    member is considered unsafe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A statement (block), in which case the entire textual context of the block
    is considered unsafe:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in order to be able to compile code that uses unsafe contexts, you
    must explicitly use the `/unsafe` compiler switch. In Visual Studio, you can check
    the **Allow unsafe code** option from **Project properties** | **Build**, under
    the **General** section, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Visual Studio''s Project Properties page that allows enabling
    the Allow unsafe code option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Visual Studio's Project Properties page that allows enabling the
    Allow unsafe code option
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsafe code can only be executed from another unsafe context. For instance,
    if you have a method that is declared as `unsafe`, you may only call it from an
    unsafe context. This is shown in the following example, where the unsafe `Increment()`
    method (introduced previously) is called from an `unsafe` context. An attempt
    to do this from a safe context results in a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are familiar with C or C++, you know that the pointer symbol (`*`) can
    be put either next to the type, the variable, or in between. The following are
    all equivalent in C/C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in C#, you always put `*` next to the type, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Variables can be of two types—**fixed** and **movable**. Movable variables reside
    in storage locations that are controlled by the garbage collector and therefore
    can be moved or collected. Fixed variables reside in storage locations that are
    unaffected by the operations of the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: In unsafe code, you can take the address of a fixed variable using the `&` operator
    without restrictions. However, you can only do so with movable variables using
    a fixed statement. A fixed statement is introduced with the `fixed` keyword and
    is, in many aspects, similar to a `using` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of using a fixed statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `SetTransparency()` function changes the alpha value of a `Color` object
    using a pointer to the `Alpha` field. Although this is of the `byte` type, which
    is a value type, it resides on the managed heap because it is part of a reference
    type. The garbage collector may move or collect the `Color` object before the
    `Alpha` field is accessed. Therefore, the only possible way to retrieve its address
    is to use the `fixed` statement. This basically pins the managed object so that
    the garbage collector will not move or collect it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from `usafe` and `fixed`, there are two more keywords that can be used
    in unsafe contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stackalloc`, which is used to declare a variable that allocates memory on
    the call stack (similar to `_alloca()` in C):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`sizeof`, which is used to obtain the size in bytes of a value type. For primitive
    types and enum types, the `sizeof` operator can actually be called in safe contexts
    too:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s summarize the unsafe code by taking a look at the following key points:'
  prefs: []
  type: TYPE_NORMAL
- en: It can only be executed in unsafe contexts, introduced with the `unsafe` keyword
    when compiling with the `/unsafe` switch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types, members, and code blocks can be unsafe contexts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It introduces security and stability risks that you are solely responsible for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are very rare cases where you have to use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on the way the runtime (through the garbage collector)
    manages the lifetime of objects and resources. We learned how the garbage collector
    works and how to write finalizers to dispose of native resources. We have seen
    how to properly implement patterns for the deterministic release of objects with
    the `IDisposable` interface and `using` statements. We also looked at Platform
    Invocation Services, which enable us to make native calls from managed code, as
    well as writing unsafe code—which is code that the CLR cannot verify for safety.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter of this book, we will look at a different programming paradigm,
    functional programming, and see what its key concepts are in C# and what they
    enable us to do.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the stack and the heap? What is allocated on each?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the memory segments of the heap and what is allocated on each?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does garbage collection work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are finalizers? What is the difference between disposing and finalizing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `GC.SupressFinalize()` method do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `IDisposable` and when should it be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `using` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you invoke a function from a native DLL in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is unsafe code and what are the typical scenarios where it could be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What program elements can you declare as unsafe?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Garbage Collection: Automatic Memory Management in the Microsoft .NET Framework*,
    Jeffrey Richter – MSDN Magazine: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/november/garbage-collection-automatic-memory-management-in-the-microsoft-net-framework](https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/november/garbage-collection-automatic-memory-management-in-the-microsoft-net-framework)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Garbage Collection: Part 2: Automatic Memory Management in the Microsoft .NET
    Framework*, Jeffrey Richter – MSDN Magazine: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/december/garbage-collection-part-2-automatic-memory-management-in-the-microsoft-net-framework](https://docs.microsoft.com/en-us/archive/msdn-magazine/2000/december/garbage-collection-part-2-automatic-memory-management-in-the-microsoft-net-framework)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
