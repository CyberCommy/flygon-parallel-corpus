- en: Converting unittest suites to pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we have seen how the flexible pytest architecture has
    created a rich plugin ecosystem, with hundreds of plugins available. We learned
    how easy it is to find and install plugins, and had an overview of a number of
    interesting plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are proficient with pytest, you might be in a situation where you
    have one or more `unittest`-based test suites and want to start using pytest with
    them. In this chapter, we will discuss the best approaches to start doing just
    that, ranging from simple test suites that might require little to no modification,
    to large in-house-grown test suites that contain all kinds of customizations grown
    organically over the years. Most of the tips and advice in this chapter come from
    my own experience when migrating our massive `unittest`-style test suite at ESSS
    ([https://wwww.esss.co](https://www.esss.co)), where I work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using pytest as a test runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting asserts with `unittest2pytest`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling setup and teardown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing test hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring test utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migration strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using pytest as a test runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that surprisingly many people don't know is that pytest can run `unittest`
    suites out of the box, without any modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this using the `unittest` runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But the cool thing is that pytest also runs this test without any modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it really easy to just start using pytest as a test runner, which
    brings several benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use plugins—for example, `pytest-xdist`, to speed up the test suite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have several command-line options at your disposal: `-k` for selecting tests,
    `--pdb` to jump into the debugger on errors, `--lf` to run last failed tests only,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can stop writing `self.assert*` methods and go with plain `assert`s. pytest
    will happily provide rich failure information, even for `unittest`-based subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For completeness, here are the `unittest` idioms and features supported out
    of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setUp` and `tearDown` for function-level `setup`/`teardown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUpClass` and `tearDownClass` for class-level `setup`/`teardown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setUpModule` and `tearDownModule` for module-level `setup`/`teardown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip`, `skipIf`, `skipUnless`, and `expectedFailure` decorators, for functions
    and classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TestCase.skipTest` to imperatively skip inside tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following idioms are currently not supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`load_tests protocol`: This protocol allows users to completely customize which
    tests are loaded from a module ([https://docs.python.org/3/library/unittest.html#load-tests-protocol](https://docs.python.org/3/library/unittest.html#load-tests-protocol)).
    The collection concept used by pytest is not compatible with how `load_tests`
    protocol works, so no work is planned by the pytest core team to support this
    feature (see the `#992` ([https://github.com/pytest-dev/pytest/issues/992](https://github.com/pytest-dev/pytest/issues/992))
    issue if you are interested in the details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtests`: Tests using this feature can report multiple failures inside the
    same test method ([https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests](https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests)).
    This feature is similar to pytest''s own parametrization support, with the difference
    that the test results can be determined at runtime instead of collection time.
    In theory, this can be supported by pytest, and the feature is currently being
    tracked by issue `#1367` ([https://github.com/pytest-dev/pytest/issues/1367](https://github.com/pytest-dev/pytest/issues/1367)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surprises with** `pytest-xdist`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decide to use `pytest-xdist` in your test suite, be aware that it runs
    tests in an arbitrary order: each worker will run tests as they finish other tests,
    so the order the in which the tests are executed is not predictable. Because the
    default `unittest` runner runs tests sequentially and always in the same order,
    often this will bring to light concurrency problems to your test suite—for example,
    tests trying to create a temporary directory with the same name. You should see
    this as an opportunity to fix the underlying concurrency problems, as they should
    not be part of the test suite anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: Pytest features in unittest subclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although not designed to support all its features when running `unittest`-based
    tests, a few of the pytest idioms are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plain asserts**: pytest assertion introspect works just as well when subclassing
    `unittest.TestCase`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marks**: marks can be applied normally to `unittest` test methods and classes.
    Plugins that deal with marks should work normally in most cases (for example, `pytest-timeout`
    marks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Autouse** fixtures: autouse fixtures defined in modules or `conftest.py`
    files will be created/destroyed when executing `unittest` test methods normally,
    including  `unittest` subclasses in the case of class-scoped autouse fixtures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test selection**: `-k` and `-m` in the command line should work as normal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other pytest features do not work with `unittest`, especially:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixtures**: `unittest` test methods cannot request fixtures. Pytest uses
    `unittest`''s own result collector to execute the tests, which doesn''t support
    passing arguments to test functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parametrization**: this is not supported, for similar reasons as for fixtures:
    we need to pass the parametrized values, and this is not currently possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins that don't rely on fixtures may work normally, for example `pytest-timeout`or `pytest-randomly`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting asserts with unitest2pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have changed the test runner to pytest, you can take advantage of writing
    plain assert statements instead of `self.assert*` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Converting all the method calls is boring and error-prone, that's why the [`unittest2pytest`](https://github.com/pytest-dev/unittest2pytest) tool
    exists. It converts all `self.assert*` method calls to plain asserts, and also
    converts `self.assertRaises` calls to the appropriate pytest idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can now execute it on the files you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By default, it won't touch the files and will only show the difference in the
    changes it could apply. To actually apply the changes, pass `-wn` (`--write` and
    `--nobackups`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the previous example, it correctly replaced the `self.assert*`
    calls, `self.assertRaises`, and added the `pytest` import. It did not change the
    subclass of our test class, as this could have other consequences, depending on
    the actual subclass you are using, so `unittest2pytest` leaves that alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated file runs just as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Adopting pytest as a runner and being able to use plain assert statements is
    a great win that is often underestimated: it is liberating to not have to type
    `self.assert...` all the time any more.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, `unittest2pytest` doesn't handle the `self.fail("not
    implemented yet")` statement of the last test yet. So, we need to replace it manually
    with `assert 0, "not implemented yet"`. Perhaps you would like to submit a PR to
    improve the project? ([https://github.com/pytest-dev/unittest2pytest](https://github.com/pytest-dev/unittest2pytest)).
  prefs: []
  type: TYPE_NORMAL
- en: Handling setup/teardown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully convert a `TestCase` subclass to pytest style, we need to replace `unittest` with
    pytest's idioms. We have already seen how to do that with `self.assert*` methods
    in the previous section, by using `unittest2pytest`. But what can we do do about
    `setUp` and `tearDown` methods?
  prefs: []
  type: TYPE_NORMAL
- en: As we learned previously, autouse fixtures work just fine in `TestCase` subclasses,
    so they are a natural way to replace `setUp` and `tearDown` methods. Let's use
    the example from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'After converting the `assert` statements, the first thing to do is to remove
    the `unittest.TestCase` subclassing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to transform the `setup`/`teardown` methods into fixture equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the class-scoped `setUpClass` and `tearDownClass` methods will become a
    single class-scoped fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `yield` statement, we can easily write the teardown code in the
    fixture itself, as we've already learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some observations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pytest doesn''t care what we call our fixture, so we could just as well keep
    the old `setUpClass` name. We chose to change it to `setup_class` instead, with
    two objectives: avoid confusing readers of this code, because it might seem that
    it is still a `TestCase` subclass, and using a `_` prefix denotes that this fixture
    should not be used as a normal pytest fixture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We change `temp_dir` to a local variable because we don''t need to keep it
    around in `cls` any more. Previously, we had to do that because we needed to access
    `cls.temp_dir` during `tearDownClass`, but now we can keep it as a local variable
    instead and access it after the `yield` statement. That''s one of the beautiful
    things about using `yield` to separate setup and teardown code: you don''t need
    to keep context variables around; they are kept naturally as the local variables
    of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We follow the same approach with the `setUp` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This technique is very useful because you can get a pure pytest class from a
    minimal set of changes. Also, using a naming convention for fixtures, as we did
    previously, helps to convey to readers that the fixtures are converting the old
    `setup`/`teardown` idioms.
  prefs: []
  type: TYPE_NORMAL
- en: Now that this class is a proper pytest class, you are free to use fixtures and
    parametrization.
  prefs: []
  type: TYPE_NORMAL
- en: Managing test hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, it is common to need to share functionality in large test
    suites. Because `unittest` is based on subclassing `TestCase`, it is common to
    put extra functionality in your `TestCase` subclass itself. For example, if we
    need to test application logic that requires a database, we might initially add
    functionality to the start and connect to a database in our `TestCase` subclass
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This works well for a single test module, but often it is the case that we
    need this functionality in another test module sometime later. The `unittest`
    module does not contain built-in provisions to share common `setup`/`teardown`
    code, so what comes naturally for most people is to extract the required functionality
    in a superclass, and then a subclass from that, where needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The superclass usually not only contains `setup`/`teardown` code, but it often
    also includes utility functions that call `self.assert*` to perform common checks
    (such as `check_row` in the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with our example: some time later, we need completely different
    functionality in another test module, for example, to test a GUI application.
    We are now wiser and suspect we will need GUI-related functionality in several
    other test modules, so we start by creating a superclass with the functionality
    we need directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The approach of moving `setup`/`teardown` and test functionality to superclasses
    works `OK` and is easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem comes when we get to the point where we need two unrelated functionalities
    in the same test module. In that case, we have no other choice than to resort
    to multiple inheritance. Suppose we need to test a dialog that connects to the
    database; we will need to write code such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Multiple inheritance in general tends to make the code less readable and harder
    to follow. Here, it also has the additional aggravation that we need to call `setUp`
    and `tearDown` in the correct order, explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to be aware of is that `setUp` and `tearDown` are optional in
    the `unittest` framework, so it is common for a certain class to not declare a
    `tearDown` method at all if it doesn't need any teardown code. If this class contains
    functionality that is later moved to a superclass, many subclasses probably will
    not declare a `tearDown` method as well. The problem comes when, later on in a
    multiple inheritance scenario, you improve the super class and need to add a `tearDown`
    method, because you will now have to go over all subclasses and ensure that they
    call the `tearDown` method of the super class.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's say we find ourselves in the previous situation and we want to start
    to use pytest functionality that is incompatible with `TestCase` tests. How can
    we refactor our utility classes so we can use them naturally from pytest and also
    keep existing `unittest`-based tests working?
  prefs: []
  type: TYPE_NORMAL
- en: Reusing test code with fixtures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we should do is to extract the desired functionality into well-defined
    fixtures and put them into a `conftest.py` file. Continuing with our example,
    we can create `db_testing` and `gui_testing` fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can start to write new tests using plain pytest style and use the
    `db_testing` and `gui_testing` fixtures, which is great because it opens the door
    to use pytest features in new tests. But the cool thing here is that we can now
    change `DataBaseTesting` and `GUITesting` to reuse the functionality provided
    by the fixtures, in a way that we don''t break existing code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Our `DatabaseTesting` and `GUITesting` classes obtain the fixture values by
    declaring an autouse `_setup` fixture, a trick we have learned early in this chapter.
    We can get rid of the `tearDown` method because the fixture will take care of
    cleaning up after itself after each test, and the utility methods become simple
    proxies for the methods implemented in the fixture.
  prefs: []
  type: TYPE_NORMAL
- en: 'As bonus points, `GUIFixture` and `DataBaseFixture` can also use other pytest
    fixtures. For example, we can probably remove `DataBaseTesting.create_temporary_db()`
    and use the built-in `tmpdir` fixture to create the temporary database file for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using other fixtures can then greatly simplify the existing testing utilities
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth emphasizing that this refactoring will require zero changes to
    the existing tests. Here, again, one of the benefits of fixtures becomes evident:
    changes in requirements of a fixture do not affect tests that use the fixture.'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring test utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how test suites might make use of subclasses
    to share test functionality and how to refactor them into fixtures while keeping
    existing tests working.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to sharing test functionality through superclasses in `unittest`
    suites is to write separate utility classes and use them inside the tests. Getting
    back to our example, where we need to have database-related facilities, here is
    a way to implement that in a `unittest`-friendly way, without using superclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this approach, we separate our testing functionality in a class that receives
    the current `TestCase` instance as its first argument, followed by any other arguments,
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `TestCase` instance serves two purposes: to provide the class access to
    the various `self.assert*` functions, and as a way to register clean-up functions
    with `TestCase.addCleanup` ([https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup](https://docs.python.org/3/library/unittest.html#unittest.TestCase.addCleanup)).
    `TestCase.addCleanup` registers functions that will be called after each test
    is done, regardless of whether they have been successful. I consider them a superior
    alternative to the `setUp`/`tearDown` functions because they allow resources to
    be created and immediately registered for cleaning up. Creating all resources
    during `setUp` and releasing them during `tearDown` has the disadvantage that
    if any exception is raised during the `setUp` method, then `tearDown` will not
    be called at all, leaking resources and state, which might affect the tests that
    follow.'
  prefs: []
  type: TYPE_NORMAL
- en: If your `unittest` suite uses this approach for testing facilities, then the
    good news is that you are in for an easy ride to convert/reuse this functionality
    for pytest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this approach is very similar to how fixtures work, it is simple to
    change the classes slightly to work as fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We get rid of the dependency to the `TestCase` instance because our fixture
    now takes care of calling `teardown()`, and we are free to use plain asserts instead
    of `Test.assert*` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep the existing suite working, we just need to make a thin subclass to
    handle cleanup when it is used with `TestCase` subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this small refactoring, we can now use native pytest fixtures in new tests,
    while keeping the existing tests working exactly as before.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach works well, one problem is that unfortunately, we cannot
    use other pytest fixtures (such as `tmpdir`) in our `DataBaseFixture` class without
    breaking compatibility with `DataBaseTesting` usage in `TestCase` subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Migration strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to run `unittest`-based tests out of the box is definitely a very
    powerful feature, because it allows you to start using pytest right away as a
    runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, you need to decide what to do with the existing `unittest`-based
    tests. There are a few approaches you can choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert everything**: if your test suite is relatively small, you might decide
    to convert all tests at once. This has the advantage that you don''t have to make
    compromises to keep existing `unittest` suites working, and being simpler to be
    reviewed by others because your pull request will have a single theme.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Convert as you go**: you might decide to convert tests and functionality
    as needed. When you need to add new tests or change existing tests, you take the
    opportunity to convert tests and/or refactor functionality to fixtures using the
    techniques from the previous sections. This is a good approach if you don''t want
    to spend time upfront converting everything, while slowly but surely paving the
    way to have a pytest-only test suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New tests only**: you might decide to never touch the existing `unittest`
    suite, only writing new tests in pytest-style. This approach is reasonable if
    you have thousands of tests that might never need to undergo maintenance, but
    you will have to keep the hybrid approaches shown in the previous sections working
    indefinitely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose which migration strategy to use based on the time budget you have and
    the test suite's size.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed a few strategies and tips on how to use pytest in `unittest`-based
    suites of various sizes. We started with a discussion about using pytest as a
    test runner, and which features work with `TestCase` tests. We looked at how to
    use the `unittest2pytest` tool to convert `self.assert*` methods to plain assert
    statements and take full advantage of pytest introspection features. Then, we
    learned a few techniques on how to migrate `unittest`-based `setUp`/`tearDown`
    code to pytest-style in test classes, manage functionality spread in test hierarchies,
    and general utilities. Finally, we wrapped up the chapter with an overview of
    the possible migration strategies that you can take for test suites of various
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see a quick summary of what we have learned in
    this book, and discuss what else might be in store for us.
  prefs: []
  type: TYPE_NORMAL
