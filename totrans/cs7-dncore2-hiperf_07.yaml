- en: Securing and Implementing Resilience in .NET Core Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security and resilience are two important aspects that should be considered
    when developing applications of any scale. Security protects an application's
    secrets, performs authentication, and provides authorized access to secure content,
    whereas resiliency embraces the application if it fails so that it can degrade
    gracefully. Resiliency makes an application highly available and allows the application
    to function properly at the time when an error occurs or when it is in a faulty
    state. It is widely used with the microservices architecture, where an application
    is decomposed into multiple services and each service communicates with other
    services to perform an operation.
  prefs: []
  type: TYPE_NORMAL
- en: There are various techniques and libraries available in .NET Core that we can
    use to implement security and resiliency. In ASP.NET Core applications, we can
    use Identity to implement user authentication/authorization, a popular Polly framework
    to implement patterns such as circuit breaker, the retry pattern, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to resilient applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing health checks to monitor application performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the retry pattern in ASP.NET Core applications to retry operations
    on transient faults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing circuit breaker patterns to prevent calls that are likely to fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting ASP.NET Core applications and enabling authentication and authorization
    using the Identity framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using safe storage to store application secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to resilient applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing applications with resiliency as an important factor always makes
    your customers happy. Today, applications are distributed by nature and involve
    lots of communication over the wire. Problems arise when the service is down or
    not responding on time due to network failure, which eventually leads to a delay
    before the client operation is terminated. The purpose of resiliency is to make
    your application recover from a failure and make it responsive again.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity increases when you call one service and that service calls another
    service, and so on. In a long chain of operations, considering resiliency is important.
    This is the reason it is one of the most widely adopted principles in microservice
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Resilient policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Resilient policies are classified into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proactive policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will implement both reactive and proactive policies using
    the Polly framework, which can be used with .NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the reactive policy, we should instantly retry the service request
    if the request fails on its first attempt. To implement the reactive policy, we
    can use the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Retry**: Retries immediately when the request fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breaker**: Stops all requests to a service in a faulted state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fallback**: Returns a default response if the service is in a faulted state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the retry pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The retry pattern is used to retry the faulted service a number of times in
    order to get a response. It is widely used in scenarios involving intercommunication
    between services, where one service is dependent on another service to perform
    a particular operation. Transient faults occur when services are hosted separately
    and communicate over the wire, most likely over a HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents two services: a user registration service
    that registers and save the user''s record in a database, and an email service
    to send a confirmation email to the user so that they can activate their account.
    Suppose an email service does not respond. This will return some sort of error,
    and if a retry pattern is implemented, it will retry the request the number of
    times it has been implemented to do so, and will call the email service if it
    fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **User Registration Service** and the **Email Service** are ASP.NET Core
    Web API projects where user registration implements the retry pattern. We will
    use the Polly framework by adding it as a NuGet package in the user registration
    service. To add Polly, we can execute the following command from the NuGet package
    manager console window in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Polly framework is based on policies. You can define policies that contain
    specific configurations related to the pattern you are implementing and then invoke
    that policy by calling its `ExecuteAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `UserController` which contains a POST method that implements a
    retry pattern to invoke the email service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have used the `HttpClient` class to make a RESTful
    request to the email service API. The `HTTP POST` method receives a user object
    that contains the following five properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since the request will be sent in JSON format, we have to set the `Content-Type`
    header value to `application/json`. Then, we have to define the retry policy to
    wait and retry the operation every three seconds, with the maximum amount of retries
    being three. Finally, we call the `ExecuteAsync` method to invoke the `client.PostAsync`
    method so that it calls the email service.
  prefs: []
  type: TYPE_NORMAL
- en: After running the preceding example, if the email service is down or throws
    an exception, it will be retried three times to try and get the required response.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing the retry pattern is a good practice when calling services that
    are communicating over a network. However, the calling mechanism itself takes
    resources and bandwidth to execute the operation and delay the response. If the
    services are already in a faulted state, it is not always a good practice to retry
    it multiple times for every request. This is where circuit breaker plays its role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Circuit breaker works in three states, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Initially, the circuit breaker is in a **Closed State**, which means the communication
    between services are working and the target remote service is responding. If the
    target remote service fails, the circuit breaker changes to **Open State**. When
    the state becomes open, then all subsequent requests cannot invoke the target
    remote service for a particular, specified time, and directly returns the response
    to the caller. Once the time elapses, the circuit turns to **Half-open State**
    and tries to invoke the target remote service to get the response. If the response
    is received successfully, the circuit breaker changes back to **Closed State**,
    or if it fails, the state changes back to closed and remains closed for the time
    specified in the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the circuit breaker pattern, we will use the same Polly framework,
    which you can add from the NuGet package. We can add the circuit breaker policy
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Add the preceding circuit breaker policy inside the `ConfigureServices` method
    in the `Startup` class. The reason for defining it in the `Startup` class is to
    inject the circuit breaker object as a singleton object through **Dependency Injection**
    (**DI**). Therefore, all requests will share the same instance and the state will
    be maintained properly.
  prefs: []
  type: TYPE_NORMAL
- en: While defining the circuit breaker policy, we set the number of events allowed
    before breaking the circuit as three, which checks how many times the request
    has failed and breaks the circuit once it reaches the threshold value of three.
    It will keep the circuit break *Open* for 10 seconds and then change the state
    to *Half-Open* when the first request comes in after the time has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if the remote service is still failing ,the circuit state changes
    to the *Open* state again; otherwise, it is set as *Close*. We have also defined `OnBreak`,
    `OnReset`, and `OnHalfOpen` delegates that are invoked when the circuit state
    changes. We can log this information somewhere in the database or file system
    if required. Add these delegate methods in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add the `circuitBreakerPolicy` and `HttpClient` objects using
    DI in the `ConfigureServices` method in the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `UserController` that takes the `HttpClient` and `CircuitBreakerPolicy`
    object in the parameterized constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the `HTTP POST` method that uses the circuit breaker policy and
    invokes the email service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the classic circuit breaker example. Polly also comes with an advanced
    circuit breaker, which is more useful in cases where you have to break the circuit
    based on the percentage of failed requests in a particular amount of time. When
    working with big applications or applications that involve lots of transactions
    within a minute, there''s a chance that 2% to 5% of transactions will fail due
    to other non-transient failure issues, so we don''t want the circuit to break.
    In this case, we can implement the advanced circuit breaker pattern and define
    the policy in our `ConfigureServices` method, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter in the `AdvancedCircuitBreakerAsync` method contains a value
    of 0.1, which is the percentage of requests that have failed in the time frame,
    which is `60` seconds, as specified in the second parameter. The third parameter
    which, defines the value of `5`, is the minimum throughput of requests being served
    in that particular time, as specified in the second parameter which is 60 seconds.
    Finally, the fourth parameter defines the amount of time the circuit remains open
    if any request fails and tries to serve the request again once the time has elapsed.
    The Other parameters are just delegate methods that are called when each state
    is changed, which is the same as in the previous classic circuit breaker example.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the circuit breaker with retry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how circuit breaker and retry patterns can be used and
    implemented using the Polly framework. The retry pattern is used to retry the
    request if it fails for a specified amount of time, where circuit breaker keeps
    the state of the circuit and, based on the threshold of the requests being failed,
    makes the circuit open and stops calling the remote service for some time, as
    specified in the configuration to save network bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: With the Polly framework, we can use the retry and circuit breaker patterns
    in conjunction and wrap the circuit breaker with the retry pattern to open the
    circuit if the retry pattern reaches the count of the failed request threshold
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will develop a custom `HttpClient` class that provides methods
    such as `GET`, `POST`, `PUT`, and `DELETE`, and use retry and circuit breaker
    policies to make it resilient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `IResilientHttpClient` interface and add four methods for HTTP
    `GET`, `POST`, `PUT`, and `DELETE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new class called `ResilientHttpClient`, which implements the
    `IResilientHttpClient` interface. We will add a parameterized constructor to inject
    the circuit breaker policy and a `HttpClient` object, which will be used to make
    HTTP `GET`, `POST`, `PUT`, and `DELETE` requests. Here is the constructor implementation
    of the `ResilientHttpClient` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined the `CircuitBreakerPolicy<HttpResponseMessage>`
    and `HttpClient` objects, which are injected through DI. We have defined the retry
    policy and set the retry threshold to three times, where each retry will wait
    for three seconds before making a call to the service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will call this method from our GET, POST, PUT, and DELETE implementation
    and define the code that will be executed within the retry and circuit breaker
    policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation for the GET, POST, PUT, and DELETE methods, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our startup class, we will add the dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `UserController` class, we can inject our custom `ResilientHttpClient`
    object through DI and modify the POST method, which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this implementation, the circuit will be initially closed when the application
    starts. When the request is made to the `EmailService`, if the service does not
    respond, it will try to call the service three times, waiting for three seconds
    on each request. If the service doesn't respond, the circuit will become open
    and for all subsequent requests, will stop calling the email service and will
    return the exception to the user for 60 seconds, as specified in the circuit breaker
    policy. After 60 seconds, the next request will be made to the `EmailService`
    and the circuit breaker state will be changed to Half-open. If it responds, the
    circuit state becomes closed again; otherwise, it remains in an open state for
    the next 60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback policy with circuit breaker and retry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polly also provides a fallback policy that returns some default responses if
    the service is failing. It can be used in conjunction with both the retry and
    circuit breaker policies. The basic idea behind fallback is to send a default
    response to the consumer rather than returning the actual error in the response.
    The response should give some meaningful information to the user that is specific
    to the application's nature. This is very beneficial when your services are used
    by external consumers of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can modify the preceding example and add fallback policies for both the
    retry and circuit breaker exceptions. In the `ResilientHttpClient` class, we will
    add these two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the circuit breaker policy to handle the circuit breaker exception
    and return the `HttpResponseMessage` with our custom content message. Add the
    following code in the parameterized constructor of the `ResilientHttpClient` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add another fallback policy, which will wrap the circuit breaker
    to handle any other exceptions that are not circuit breaker exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will modify the `ExecuteWithRetryandCircuitBreaker` method and
    wrap both the retry and circuit breaker policy inside the fallback policies, which
    returns the general message with the 200 status code to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implementation, the user will not get any errors in response. The
    content contains the actual error, which is shown in the following snapshot, taken
    from Fiddler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Proactive policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the proactive policy, we should proactively respond to a request
    if it is leading towards a failure. We can use techniques such as timeout, caching,
    and health checks to proactively monitor application performance, and use them
    to proactively respond in the event of failure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeout**: If a request takes more than the usual time, it ends the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Caches previous responses and uses them for future requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health checks**: Monitor the application''s performance and invokes alerts
    in the event of failure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Timeout is a proactive policy, which is applicable in scenarios where the target
    service takes a long time to respond, and rather than letting the client wait
    for a response, we return a general message or response. We can use the same Polly
    framework to define the timeout policy, and it can also be used with the combination
    of retry and circuit breaker patterns we learned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, the user registration service is calling the email
    service to send emails. Now, if the email service does not respond in a particular
    amount of time, as specified in the timeout policy, the timeout exception will
    be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a timeout policy, declare a `_timeoutPolicy` variable in the `ResilientHttpClient`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following code to initialize the timeout policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will wrap the timeout policy and add it in `resiliencyPolicyWrap`.
    Here is the modified code of the `ExecuteWithRetryandCircuitBreaker` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Implementing caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When making a web request or calling a remote service, Polly can be used to
    cache the response from the remote service and improve the performance of the
    application's response time. The Polly cache is classified into two caches, known
    as the in-memory cache and the distributed cache. We will configure the in-memory
    cache in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add another `Polly.Caching.MemoryCache` package from NuGet.
    Once this is added, we will modify our `Startup` class and add the `IPolicyRegistry`
    as a member variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `ConfigurationServices` method, we will initialize the registry and
    add it as a singleton object through DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the configure method, we will define the cache policy that takes the cache
    provider and the time to cache the responses. Since we are using in-memory cache,
    we will initialize the memory cache provider and specify it in the policy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will add the `cachepolicy` to our registry, which is initialized
    in the `ConfigurationServices` method. We named our registry `cache`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify our `UserController` class and declare the generic `CachePolicy` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We will now modify our `UserController` constructor and add the registry, which
    will be injected through the DI. This registry object is used to get the cache
    defined in the `Configure` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the modified constructor of the `UserController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will define a `GET` method that calls another service to get the
    list of users and cache it in the memory. To cache the responses, we will wrap
    our custom resilient client GET method with the `Execute` method of the cache
    policy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When the request is returned, it will check whether the cache context is empty
    or expired, and the request will be cached for 10 minutes. All subsequent requests
    during that time will read the response from the in-memory cache store. Once the
    cache has expired, based on the set time limit, it will invoke the remote service
    again and cache the response.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing health checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Health checks are part of the proactive strategy, where the services' health
    can be monitored in a timely fashion. They also allow you to take actions proactively
    if any service is not responding or is in a failure state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASP.NET Core, we can easily implement health checks by using the `HealthChecks`
    library, which is available as a NuGet package. To use `HealthChecks`, we can
    just simply add the following NuGet package to our ASP.NET Core MVC or Web API
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have to add this package to the application that monitors the services and
    the services whose health needs to be monitored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in the `ConfigureServices` method of the `Startup` class
    of the application that is used to check the health of services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added two service endpoints to check the health
    status. These endpoints are defined in the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The health check library checks the health of the services specified using
    the `AddUrlCheck` method. However, the services whose health needs to be monitored
    by external applications or services need some modification in the `Startup` class.
    We have to add the following code snippet to all of the services to return their
    health status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If their health is good and the service is responding, it will return `Ok`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add the URI in the monitoring application, which will trigger
    the health check middleware to check the services'' health and display the health
    status. We have to add `UseHealthChecks` and specify the endpoint used to trigger
    the services'' health status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our monitoring application and access the URI, for example, `http://{base_address}/hc`
    to get the health status, if all the services are in working order, we should
    see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.gif)'
  prefs: []
  type: TYPE_IMG
- en: Storing sensitive information using Application Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application has some configuration holding sensitive information, such
    as database connection strings, the secret keys of some third providers, and other
    sensitive information usually stored in the configuration files or the database.
    It is always a better option to secure all sensitive information to protect these
    resources from intruders. Web applications are usually hosted on servers, and
    this information can be read by just navigating to the server's path and accessing
    files, even though servers always have protected access and only authorized users
    are eligible to access the data. However, keeping information in plain text is
    not a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET Core, we can use the Secret Manager tool to protect the sensitive information
    of an application. The Secret Manager tool allows you to store information in
    a `secrets.json` file, which is not stored within the application folder itself.
    Instead, that file is saved at the following path for different platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`{userSecretId}` is the unique ID (GUID) associated with your application.
    Since this is saved in the separate path, each developer has to define or create
    this file in their own directory under the `UserSecrets` directory. This restricts
    the developer from checking in the same file for the source control and keeps
    the information separate to each user. There are scenarios where a developer uses
    their own account credentials for database authentication and so this facilitates
    in keeping certain information isolated from other information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From Visual Studio, we can simply add the `secrets.json` file by right-clicking
    on the project and selecting the Manage User Secrets option, which is shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you select Manage User Secrets, Visual Studio creates a `secrets.json`
    file and opens it in Visual Studio to add configuration settings in JSON format.
    If you open the project file, you see the entry of the `UserSecretsId` stored
    in your project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, if you accidently close the `secrets.json` file, you can open it from the
    path where `UserSecretsId` is the subfolder inside the user secrets path, which
    is shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the sample content of the `secrets.json` file that contains the logging
    information, remote services URL, and the connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To access this in the ASP.NET Core application, we can add the following namespace
    in our `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inject the `IConfiguration` object and assign it to the `Configuration`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can access the variables using the `Configuration` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Protecting ASP.NET Core APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Securing web applications is an important milestone for any enterprise-grade
    application to protect not only the data, but also to protect it from different
    attacks from malicious sites.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various scenarios where security is an important factor for any web
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: The information sent over the wire contains sensitive information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs are exposed publicly and are used by users to perform bulk operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs are hosted on a server where the user can use some tools to do packet sniffing
    and read sensitive data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address the preceding challenges and to secure our application, we should
    consider the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: SSL (Secure Socket Layer)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add security at the transport or network level, where when, the data is sent
    from the client to the server, it should be encrypted. The **SSL** (**Secure Socket
    Layer**) is the recommended way of securing information sent over the wire. Use
    SSL in a web application to encrypt all of the data that is sent from the client's
    browser to the server over the wire where it is decrypted at the server level.
    Apparently, it seems like a performance overhead, but due to the specifications
    of the server resources we have in today's world, it seems quite negligible.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling SSL in an ASP.NET Core application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable SSL in our ASP.NET Core project, we can add filters in the `AddMvc`
    method defined in the `ConfigureServices` method of our `Startup` class. Filters
    are used to filter the HTTP calls and take certain actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This also modifies the `launchSettings.json` file and adds the SSL. Another
    way is to directly modify the port number from the `launchSetttings.json` file
    itself. Here is the `launchsettings.json` file that uses port `44326` for SSL,
    which has been added under `iisSettings`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The default HTTP port, which is shown in the preceding code, is set to `*3743*`.
    As in the `AddMvc` middleware, we have specified a filter to use SSL for all incoming
    requests. It will automatically redirect to the HTTPS and use port `44326`.
  prefs: []
  type: TYPE_NORMAL
- en: To host ASP.NET Core on IIS, please refer to the following link. Once the website
    is up and running, the HTTPS binding can be added through the Site bindings options
    in IIS: [https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/index?tabs=aspnetcore2x](https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/iis/index?tabs=aspnetcore2x)
  prefs: []
  type: TYPE_NORMAL
- en: Preventing CSRF (Cross-Site Request Forgery) attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSRF is an attack that executes unsolicited operations on a web application
    on behalf of the authenticated user. Since the attacker is unable to forge the
    response of the request, it is implicated mostly on `HTTP POST`, `PUT`, and `DELETE`
    methods, which are used to modify the insert, update, or delete data on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'ASP.NET Core provides a built-in token to prevent CSRF attacks, and you can
    do this yourself by adding the `ValidateAntiForgeryTokenAttribute` filter while
    adding MVC in the `ConfigureServices` method of the `Startup` class. Here is the
    code to add an anti-forgery token globally to your ASP.NET Core application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can also add `ValidateAntyForgeryToken` on specific controller
    action methods. In that case, we don’t have to add the `ValidateAntiForgeryTokenAttribute`
    filter in the `ConfigureServices` method of the `Startup` class. Here is the code
    to protect the `HTTP POST` action method from CSRF attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The second option is to enable `CORS (Cross-Origin Security)` for authenticated
    origins, headers, and methods. Setting CORS allows your APIs to be only accessible
    from configured origins. In ASP.NET Core, CORS can be easily set by adding middleware
    and defining its policy.
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidateAntiForgery` attribute tells ASP.NET Core to put the token in the
    form, and when it’s submitted, it validates and ensures that the token is valid.
    This prevents your application from CSRF attacks by validating the token for every
    `HTTP POST`, `PUT`, and other HTTP requests, and protects the forms from being
    posted maliciously.
  prefs: []
  type: TYPE_NORMAL
- en: Reinforcing security headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many modern browsers provide additional security features. These security features
    are automatically enabled by the browser running your site if the response contains
    those headers. In this section, we will discuss how we can add those headers in
    our ASP.NET Core application and enable additional security in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: To investigate which headers are missing in our application, we can use the  [www.SecurityHeaders.io](http://www.SecurityHeaders.io)
    site. However, to use this, we need our site to be publicly accessible on the
    internet.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can use `ngrok` to make a HTTP tunnel to our local application,
    which makes our site accessible from the internet. The `ngrok` tool can be downloaded
    from the following link: [https://ngrok.com/download](https://ngrok.com/download).
  prefs: []
  type: TYPE_NORMAL
- en: You can select the version of OS you have and download a particular installer
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `ngrok` is installed, you can open it and the run following command. Please
    note that your site should be running locally before executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can replace `localhost` with your server IP and `7204` to the port your
    application is listening on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding command will generate the public URL, as specified in
    the `Forwarding` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now use this public URL in [www.securityheaders.io](http://www.securityheaders.io), 
    which scans our site and gives us the result. It categorizes the site and provides
    an alphabet starting from A to F, where A is an excellent score that means the
    site contains all security headers, and F means that the site is not secure and
    does not contain security headers. Scanning the default ASP.NET Core site generated
    from the default template scored F, which is shown as follows. It also shows the
    missing headers, which are boxed in red:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First of all, we should enable HTTPS on our site. To enable HTTPS, please refer
    to the section related to SSL. Next, we will add the `NWebsec.AspNetCore.Middleware`
    package from NuGet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: NWebsec comes with various middleware that can be added to our application from
    the `Configure` method of the `Startup` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the HTTP strict transport security header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The strict transport security header is an excellent feature that strengthens
    the implementation of **TLS** (**Transport Level Security**) by getting the User
    Agent and forcing it to use HTTPS. We can add the strict transport security header
    by adding the following middleware to our `Configure` method of the `Startup`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This middleware enforces your site so that it can only be accessed over HTTPS
    for a year. This applies to subdomains as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the X-Content-Type-Options header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This header stops a browser from trying to `MIME-sniff` the content type and
    forces it to stick with the declared content-type. We can add this middleware
    as follows, in the `Configure` method of the `Startup` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Adding the X-Frame-Options header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This header allows the browser to protect your site from being rendered inside
    a frame. By using the following middleware, we can prevent our site from framing
    so that we can defend it against different attacks, where the most famous one
    is clickjacking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Adding the X-Xss-Protection header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This header allows the browser to stop pages from loading when they detect
    Cross Site scripting attacks. We can add this middleware in the `Configure` method
    of the `Startup` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Content-Security-Policy header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The *Content-Security-Policy* header protects your application by whitelisting
    the sources of approved content and preventing the browser from loading malicious
    resources. This can be added by adding the `NWebsec.Owin` package from NuGet and
    defining it in the `Configure` method of the `Startup` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have mentioned the `DefaultSources` and `ScriptSources`
    to load all the resources from the same origin. If there are any scripts or images
    that need to be loaded from external sources, we can define the custom sources
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: For the complete documentation on this topic, please refer to the following
    URL: [https://docs.nwebsec.com/en/4.1/nwebsec/Configuring-csp.html](https://docs.nwebsec.com/en/4.1/nwebsec/Configuring-csp.html).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the referrer-policy header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a user navigates the site and click links to other sites, the destination
    site usually receives information about the origin site the user came from. The
    referrer header lets you control what information should be present in the header,
    which can be read by the destination site. We can add the referrer policy middleware
    in the `Configure` method of the `Startup` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `NoReferrer` option means that no referrer information will be sent to the
    target site.
  prefs: []
  type: TYPE_NORMAL
- en: 'After enabling all of the preceding middleware in our ASP.NET Core application,
    when we scan through the [securityheaders.io](http://securityheaders.io) site,
    we will see that we have a security report summary with an A+, which means that
    the site is completely secured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling CORS in the ASP.NET Core application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CORS stands for Cross-Origin Resource Sharing, and it is restricted by browsers
    to prevent API requests across domains. For example, we have an SPA (Single-Page
    Application) running on a browser using a client-side framework like Angular or
    React to make calls to the Web APIs hosted on another domain, like my SPA site
    having a domain ([*mychapter8webapp.com*](http://mychapter8webapp.com)) and accessing
    the APIs of another domain ([appservices.com](http://appservices.com)), which
    is restricted. Making calls to the services hosted on some other server and domain
    is restricted by browsers, and users will not be able to call those APIs. Enabling
    CORS on the server-side level addresses this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable CORS in our ASP.NET Core project, we can add CORS support in the
    `ConfigureServices` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Configure` method, we can use CORS by calling the `UseCors` method
    and defining the policies to allow cross-domain requests. The following code allows
    requests to be made from any header, origin, or method, and also allows us to
    pass credentials in the request header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will allow CORS globally in the application. Alternatively,
    we can also define CORS policies and enable them on specific controllers depending
    on different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table defines the basic terminology used in defining CORS:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Terminology** | **Description** | **Sample** |'
  prefs: []
  type: TYPE_TB
- en: '| Header | Request header allowed to be passed within the request | Content-Type,
    Accept, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Method | HTTP verb of the request | GET, POST, DELETE, PUT, and so on |'
  prefs: []
  type: TYPE_TB
- en: '| Origin | Domain or request URL | [http://techframeworx.com](http://techframeworx.com)
    |'
  prefs: []
  type: TYPE_TB
- en: 'To define the policies, we can add a policy when adding CORS support in the
    `ConfigureServices` method. The following code shows two policies that have been
    defined while adding CORS support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The  `AllowOnlyGet` policy will only allow requests that are making a `GET`
    request; the `Techframeworx` policy will only allow requests that are being made
    from [techframeworx.com](http://www.techframeworx.com/)*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these policies on Controllers and Actions by using the `EnableCors`
    attribute and specifying the name of the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure APIs only allow access to authenticated users. In ASP.NET Core, we can
    use the ASP.NET Core Identity framework to authenticate users and provide authorized
    access to protected resources.
  prefs: []
  type: TYPE_NORMAL
- en: Using ASP.NET Core Identity for authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security, in general, is divided into two mechanisms, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the process of authenticating the user's access by getting
    their username, password, or authentication token and then validating it from
    the backend database or service. Once the user is authenticated, certain actions
    are done, which involves setting up a cookie in the browser or returning a token
    to the user so that it can be passed in the request message to access protected
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authorization is the process that is done after user authentication. Authorization
    is used to learn the permissions of the user accessing the resource. Even though
    the user is authenticated, it does not mean that all the protected or secured
    resources are accessible. This is where authorization comes into play and only
    allows the user to access resources that they are permitted to access.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication and authorization using the ASP.NET Core Identity
    framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET Core Identity is the security framework developed by Microsoft and is
    now contributed to by the open source community. This allows a developer to enable
    user authentication and authorization in an ASP.NET Core application. It provides
    the complete system of storing user identities, roles, and claims in a database.
    It contains certain classes for user identity, roles, and so on, which can be
    extended further to support more properties, depending on the requirements. It
    uses Entity Framework Core code for the first model to create the backend database
    and can be easily integrated with existing data models or the application's specific
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a simple application to add ASP.NET Core Identity
    from scratch and modify the `IdentityUser` class to define additional properties
    and use cookie-based authentication to validate requests and secure ASP.NET MVC
    controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an ASP.NET Core project, we can change the authentication option
    to Individual User Account authentication, which scaffolds all the security-specific
    classes and configures security in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This creates an `AccountController` and `PageModels` to register, login, forgot
    password, and other user management-related pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Startup` class also contains some entries related to security. Here is
    the `ConfigureServices` method, which adds some code that is specific to security:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`AddDbContext` uses the SQL server to create Identity tables in the database,
    as specified in the `DefaultConnection` key as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`services.AddIdentity` is used to enable Identity in our application. It takes
    `ApplicationUser` and `IdentityRole` and defines `ApplicationDbContext` to use
    as the Entity framework, which is used to store the created entities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddDefaultTokenProviders` is defined to generate tokens for reset passwords,
    changing email, changing telephone number, and two-factor authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `Configure` method, it adds the `UseAuthentication` middleware, which
    enables the authentication and protects the pages or controllers that are configured
    to authorize requests. Here is the `Configure` method that enables authentication
    in the pipeline. The middleware which is defined is executed in a sequence. Therefore,
    the `UseAuthentication` middleware is defined before the `UseMvc` middleware so
    that all of the requests that will be invoking the controllers will be authenticated
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Adding more properties in the user table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IdentityUser` is the base class, which contains properties such as email,
    password, and phone number, which are related to the user. When we create the
    ASP.NET Core application, it creates an empty `ApplicationUser` class that inherits
    from the `IdentityUser` class. In the `ApplicationUser` class, we can add more
    properties that will be created once the entity framework migration is run. We
    will add `FirstName`, `LastName`, and `MobileNumber` properties in our `ApplicationUser`
    class, which will be considered when the table is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Before running the migration, make sure that the `DefaultConnection` string
    specified in the `ConfigureServices` method of the `Startup` class is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the migration from the Package Manager Console in Visual Studio
    or through the *dotnet CLI* toolset. From Visual Studio, select the specific project
    and run the `Add-Migration` command, specifying  the migration name, which is
    Initial in our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding command creates the `{timestamp}_Initial` class file containing
    the `Up` and `Down` methods. The `Up` method is used to publish the changes in
    the backend database, whereas the `Down` method is used to revert the changes
    done in the database. To apply the changes to the backend database, we will run
    the `Update-Database` command, which creates a database that contains `AspNet`-related
    tables, which are part of the Identity framework. If you open the `AspNetUsers`
    table in design mode, you will see that the custom columns `FirstName`, `LastName`,
    and `MobileNumber` are there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can run the application and create users using the Register option. To protect
    our APIs, we have to add the `Authorize` attribute to the `Controller` or `Action`
    level. When the request comes and the user is authenticated, the method will be
    executed; otherwise, it redirects the request to the Login page.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about resiliency, which is a very important
    factor when developing highly performant applications in .NET Core. We learned
    about different policies and used the Polly framework to use those policies in
    .NET Core. We also learned about safe storage mechanisms and how to use them in
    a development environment in order to keep sensitive information separate from
    the project repository. At the end of this chapter, we learned about some core
    fundamentals, which included SSL, CSRF, CORS,  enabling security headers, and
    the ASP.NET Core Identity framework to protect ASP.NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about some key metrics and necessary tools
    to monitor the performance of .NET Core applications.
  prefs: []
  type: TYPE_NORMAL
