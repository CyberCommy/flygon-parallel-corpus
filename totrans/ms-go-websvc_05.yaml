- en: Chapter 5. Templates and Options in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the basics of our social networking web service fleshed out, it's time
    we take our project from a demo toy to something that can actually be used, and
    perhaps eventually in production as well.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we need to focus on a number of things, some of which we'll address
    in this chapter. In the last chapter, we looked at scoping out the primary functions
    of our social network application. Now, we need to make sure that each of those
    things is possible from a REST standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accomplish that, in this chapter, we''ll look at:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `OPTIONS` to provide built-in documentation and a REST-friendly explanation
    of our resources' endpoints purposes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considering alternative output formats and an introduction on how to implement
    them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and enforcing security for our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing user registration to utilize secure passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing users to authenticate from a web-based interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Approximating an OAuth-like authentication system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing external applications to make requests on behalf of other users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the implementation of these things, we will have the foundation of a service
    that will allow users to interface with it, either directly via an API or through
    a third-party service.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing our OPTIONS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've hinted a bit at the value and purpose of the `OPTIONS` HTTP verb as it
    relates to the HTTP specification and the best practices of REST.
  prefs: []
  type: TYPE_NORMAL
- en: As per RFC 2616, the HTTP/1.1 specification, responses to the `OPTIONS` requests
    should return information about what the client can do with the resource and/or
    requested endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the **HTTP/1.1** **Request for Comments** (**RFC**) at [https://www.ietf.org/rfc/rfc2616.txt](https://www.ietf.org/rfc/rfc2616.txt).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, in our early examples, calls to `/api/users` with `OPTIONS`
    should return an indication that `GET`, `POST`, `PUT`, and `DELETE` are presently
    available options at that REST resource request.
  prefs: []
  type: TYPE_NORMAL
- en: At present, there's no predefined format for what the body content should resemble
    or contain although the specification indicates that this may be outlined in a
    future release. This gives us some leeway in how we present available actions;
    in most such cases we will want to be as robust and informative as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a simple modification of our present API that includes
    some basic information about the `OPTIONS` request that we outlined earlier. First,
    we''ll add the method-specific handler for the request in our exported `Init()`
    function of the `api.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we''ll add the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this with cURL directly gives us what we''re looking for. In the following
    screenshot, you''ll notice the `Allow` header right at the top of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing our OPTIONS](img/1304OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This alone would satisfy most generally accepted requirements for the `OPTIONS`
    verb in the REST-based world, but remember that there is no format for the body
    and we want to be as expressive as we can.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way in which we can do this is by providing a documentation-specific package;
    in this example, it is called specification. Keep in mind that this is wholly
    optional, but it is a nice treat for any developers who happen to stumble across
    it. Let''s take a look at how we can set this up for self-documented APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then reference this directly in our `api.go` file. First, we''ll create
    a generic slice of interfaces that will encompass all the available methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can compile our various methods within our `UsersInfo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Your screen should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing our OPTIONS](img/1304OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementing alternative formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When looking at the world of API formats, you know by now that there are two
    big players: **XML** and **JSON**. As human-readable formats, these two have owned
    the format world for more than a decade.'
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case, developers and technologists rarely settle happily for
    something for long. XML was number one for a very long time before the computational
    complexity of encoding and decoding as well as the verbosity of schema pushed
    many developers towards JSON.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is not without its faults either. It's not all that readable by humans
    without some explicit spacing, which then increases the size of the document excessively.
    It doesn't handle commenting by default either.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of alternative formats that are sitting on the sideline.
    **YAML**, which stands for **YAML Ain''t Markup Language**, is a whitespace-delimited
    format that uses indentation to make it extremely readable for humans. An example
    document would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The indentation system as a method of simulating code blocks will look familiar
    to anyone with experience in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of YAML implementations for Go. The most noteworthy is `go-yaml`
    and this is available at [https://github.com/go-yaml/yaml](https://github.com/go-yaml/yaml).
  prefs: []
  type: TYPE_NORMAL
- en: '**TOML**, or **Tom''s Obvious, Minimal Language**, takes an approach that will
    look very familiar to anyone who has worked with the `.ini` style config files.'
  prefs: []
  type: TYPE_NORMAL
- en: Rolling our own data representation format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TOML is a good format to look at with regard to building our own data format,
    primarily because its simplicity lends itself to multiple ways of accomplishing
    the output within this format.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be immediately tempted to look at Go''s text template format when devising
    something as simple as TOML because the control mechanisms to present it are largely
    there inherently. Take this structure and loop, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And, when the structure is parsed against the text template, it will generate
    precisely what we want as follows:`{{.Name}}`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One big problem with this method is that you have no inherent system for unmarshalling
    data. In other words, you can generate the data in this format, but you can't
    unravel it back into Go structures the other way.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is that as the format increases in complexity, it becomes less
    reasonable to use the limited control structures in the Go template library to
    fulfill all of the intricacies and quirks of such a format.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to roll your own format, you should avoid text templates and look
    at the encoding package that allows you to both produce and consume structured
    data formats.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the encoding package closely in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing security and authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A critical aspect of any web service or API is the ability to keep information
    secure and only allow access to specific users to do specific things.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, there have been a number of ways to accomplish this and one of
    the earliest is HTTP digest authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Another common one is inclusion of developer credentials, namely an API key.
    This isn't recommended much anymore, primarily because the security of the API
    relies exclusively on the security of these credentials. It is, however, largely
    a self-evident method for allowing authentication and as a service provider, it
    allows you to keep track of who is making specific requests and it also enables
    the throttling of requests.
  prefs: []
  type: TYPE_NORMAL
- en: The big player today is OAuth and we'll look at this shortly. However, first
    things first, we need to ensure that our API is accessible only via HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing HTTPS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, our API is starting to enable clients and users to do some things,
    namely create users, update their data, and include image data for these users.
    We're beginning to dabble in things that we would not want to leave open in a
    real-world environment.
  prefs: []
  type: TYPE_NORMAL
- en: The first security step we can look at is forcing HTTPS instead of HTTP on our
    API. Go implements HTTPS via TLS rather than SSL since TLS is considered as a
    more secure protocol from the server side. One of the driving factors was vulnerabilities
    in SSL 3.0, particularly the Poodlebleed Bug that was exposed in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about Poodlebleed at [https://poodlebleed.com/](https://poodlebleed.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can reroute any nonsecure request to its secure counterpoint
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is our (temporarily) correct endpoint. It's not yet TSL (or SSL), so we're
    not actually listening for HTTPS connections, hence the message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is our redirection handler. You'll probably take note with the `http.StatusOK`
    status code—obviously we'd want to send a 301 Moved Permanently error (or an `http.StatusMovedPermanently`
    constant). However, if you're testing this, there's a chance that your browser
    will cache the status and automatically attempt to redirect you.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, why have we wrapped these methods in anonymous goroutines? Well, take them
    out and you''ll see that because the `ListenAndServe` function is blocking, we''ll
    never run the two simultaneously by simply calling the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you have options in this regard. You could simply set the first as
    a goroutine and this would allow the program to move on to the second server.
    This method provides some more granular control for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding TLS support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding example, we were obviously not listening for HTTPS connections.
    Go makes this quite easy; however, like most SSL/TLS matters, the complication
    arises while handling your certificates.
  prefs: []
  type: TYPE_NORMAL
- en: For these examples, we'll be using self-signed certificates, and Go makes this
    easy as well. Within the `crypto/tls` package, there is a file called `generate_cert.go`
    that you can use to generate your certificate keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'By navigating to your Go binary directory and then `src/pkg/crypto/tls`, you
    can generate a key pair that you can utilize for testing by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can then take those files and move them wherever you want, ideally in the
    directory where our API is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s remove our `http.ListenAndServe` function and change it to `http.ListenAndServeTLS`.
    This requires a couple of additional parameters that encompass the location of
    the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of being more explicit, let''s also modify our `secureRequest`
    handler slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this now and go to our browser, we''ll hopefully see a warning, assuming
    that our browser would keep us safe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding TLS support](img/1304OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assuming we trust ourselves, which is not always advisable, click through and
    we''ll see our message from the secure handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding TLS support](img/1304OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And of course, if we again visit `http://localhost:8080`, we should now be automatically
    redirected with a 301 status code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating self-signed certificates is otherwise fairly easy when you have access
    to an OS that supports OpenSSL.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a signed (but not verified) certificate for free through a number
    of services for a one-year period if you'd like to experiment with real certificates
    and not self-signed ones. One of the more popular ones is StartSSL ([https://www.startssl.com/](https://www.startssl.com/)),
    which makes getting free and paid certificates a painless process.
  prefs: []
  type: TYPE_NORMAL
- en: Letting users register and authenticate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall that as part of our API application we have a self-contained
    interface that allows us to serve a HTML interface for the API itself. Any discussion
    of security goes out the door if we don't lock down our users.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the absolute simplest way of implementing user authentication security
    is through the storage and use of a password with a hashing mechanism. It's tragically
    common for servers to store passwords in clear text, so we won't do that; but,
    we want to implement at least one additional security parameter with our passwords.
  prefs: []
  type: TYPE_NORMAL
- en: We want to store not just the user's password, but at least a salt to go along
    with it. This is not a foolproof security measure, although it severely limits
    the threat of dictionary and rainbow attacks.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll create a new package called `password` as part of our suite,
    which allows us to generate random salts and then encrypt that value along with
    the password.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `GenerateHash()` to both create and validate passwords.
  prefs: []
  type: TYPE_NORMAL
- en: A quick hit – generating a salt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting a password is simple, and creating a secure hash is also fairly easy.
    What we''re missing to make our authentication process more secure is a salt.
    Let''s look at how we can do this. First, let''s add both a password and a salt
    field to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, let''s take a look at our password package that will contain
    the salt and hash generation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our `GenerateSalt()` function produces a random string of characters within
    a certain set of characters. In this case, we want to start at 32 in the ASCII
    table and go up to 126.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we generate a hash based on a password and a salt. This is useful not
    just for the creation of a password but also for validating it. The following
    `ReturnPassword()` function primarily operates as a wrapper for other functions,
    allowing you to create a password and return its hashed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: On our client side, you may recall that we sent all of our data via AJAX in
    jQuery. We had a single method on a single Bootstrap tab that allowed us to create
    users. First, let's remind ourselves of the tab setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, the `userCreate()` function, wherein we''ve added a few things. First,
    there''s a password field that allows us to send that password along when we create
    a user. We may have been less comfortable about doing this before without a secure
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can modify our `.ajax` response to react to different HTTP status
    codes. Remember that we are already setting up a conflict if a username or an
    e-mail ID already exists. So, let''s handle this as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we get a response of 200, we know our API-side has created the user.
    If we get 409, we report to the user that the e-mail address or username is taken
    in the alert area.
  prefs: []
  type: TYPE_NORMAL
- en: Examining OAuth in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we briefly touched on in [Chapter 4](ch04.html "Chapter 4. Designing APIs
    in Go"), *Designing APIs in Go*, OAuth is one of the more common ways of allowing
    an application to interact with a third-party app using another application's
    user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: It's extraordinarily popular in social media services; Facebook, Twitter, and
    GitHub all use OAuth 2.0 to allow applications to interface with their APIs on
    behalf of users.
  prefs: []
  type: TYPE_NORMAL
- en: It's noteworthy here because while there are many API calls that we are comfortable
    leaving unrestricted, primarily the `GET` requests, there are others that are
    specific to users, and we need to make sure that our users authorize these requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s quickly review the methods that we can implement to enable something
    akin to OAuth with our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Given that we have a small, largely demonstration-based service, our risk in
    keeping access tokens active for a long time is minimal. Long-lived access tokens
    obviously open up more opportunities for unwanted access by keeping the said access
    open to clients, who may not be observing the best security protocols.
  prefs: []
  type: TYPE_NORMAL
- en: In normal conditions, we'd want to set an expiry on a token, which we can do
    pretty simply by using a memcache system or a keystore with expiration times.
    This allows values to die naturally, without having to explicitly destroy them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll need to do is add a table for client credentials, namely
    `consumer_key` and `consumer_token`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We'll check the details against our newly created database to verify credentials,
    and if they are correct, we'll return an access token.
  prefs: []
  type: TYPE_NORMAL
- en: An access token can be of any format; given our low security restrictions for
    a demonstration, we'll return an MD5 hash of a randomly generated string. In the
    real world, this probably wouldn't be sufficient even for a short-lived token,
    but it will serve its purpose here.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember, we implemented a random string generator as part of our `password`
    package. You can create a quick key and secret value in `api.go` by calling the
    following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you feed this key and secret value into the previously created table and
    associate it with an existing user, you'll have an active API client. Note that
    this may generate invalid URL characters, so we'll restrict our access to the
    `/oauth/token` endpoint to `POST`.
  prefs: []
  type: TYPE_NORMAL
- en: Our pseudo OAuth mechanism will go into its own package, and it will strictly
    generate tokens that we'll keep in a slice of tokens within our API package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our core API package, we''ll add two new functions to validate credentials
    and the `pseudoauth` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The functions that we'll add are `CheckCredentials()` and `CheckToken()`. The
    first will accept a key, a nonce, a timestamp, and an encryption method, which
    we'll then hash along with the `consumer_secret` value to see that the signature
    matches. In essence, all of these request parameters are combined with the mutually
    known but unbroadcasted secret to create a signature that is hashed in a mutually
    known way. If those signatures correspond, the application can issue either a
    request token or an access token (the latter is often issued in exchange for a
    request token and we'll discuss more on this shortly).
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we'll accept a `consumer_key` value, a nonce, a timestamp, and
    a signature and for the time being assume that HMAC-SHA1 is being used as the
    signature method. SHA1 is losing some favor do to the increased feasibility of
    collisions, but for the purpose of a development application, it will do and can
    be simply replaced later on. Go also provides SHA224, SHA256, SHA384, and SHA512
    out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the nonce and timestamp is exclusively added security. The nonce
    works almost assuredly as a unique identifying hash for the request, and the timestamp
    allows us to expire data periodically to preserve memory and/or storage. We're
    not going to do this here, although we will check to make sure that a nonce has
    not been used previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin authenticating the client, we look up the shared secret in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re taking the `consumer_key` value and looking up our shared `consumer_secret`
    token, which we''ll pass along to our `ValidateSignature` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find our request to be invalid (either due to incorrect credentials or
    an existing nonce), we''ll return an unauthorized error and a 401 status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we''ll return the access code in a JSON body response. Here''s the
    code for the `pseudoauth` package itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing too surprising here! We''ll need some crypto packages and `math/rand`
    to allow us to seed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a bit more here than what we''ll use at the moment, but you can see
    that we can create tokens with specific access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a rough approximation of how services like OAuth attempt to validate
    signed requests; a nonce, a public key, a timestamp, and the shared private key
    are evaluated using the same encryption. If they match, the request is valid.
    If they don't match, an error should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the timestamp later to give a short window for any given request
    so that in case of an accidental signature leak, the damage can be minimized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Making requests on behalf of users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to making requests on behalf of users, there is a critical middle
    step that is involved in the OAuth2 process, and that's authentication on the
    part of the user. This cannot happen within a consumer application, obviously,
    because it would open a security risk wherein, maliciously or not, user credentials
    could be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, this process requires a few redirects.
  prefs: []
  type: TYPE_NORMAL
- en: First, the initial request that will redirect users to a login location is required.
    If they're already logged in, they'll have the ability to grant access to the
    application. Next, our service will take a callback URL and send the user back
    along with their request token. This will enable a third-party application to
    make requests on behalf of the user, unless and until the user restricts access
    to the third-party application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store valid tokens, which are essentially permissive connections between
    a user and a third-party developer, we''ll create a database for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need a few pieces to make this work, first, a login form for users who
    are not presently logged in, by relying on a `sessions` table. Let''s create a
    very simple implementation in MySQL now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll need an authorization form for users who are logged in that allows
    us to create a valid API access token for the user and service and redirects the
    user to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template can be a very simple HTML template that can be placed at `/authorize`.
    So, we need to add that route to `api.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Requests to `POST` will check confirmation and if all is well, pass this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Go''s templating language is largely, but not completely, without logic. We
    can use an `if` control structure to keep both pages'' HTML code in a single template.
    For brevity, we''ll also create a very simple `Page` struct that allows us to
    construct very basic response pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We're not going to maintain login state for now, which means each user will
    need to log in anytime they wish to give a third party access to make API requests
    on their behalf. We'll fine-tune this as we go along, particularly in using secure
    session data and cookies that are available in the Gorilla toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first request will include a login attempt with a `consumer_key` value
    to identify the application. You can also include the full credentials (nonce,
    and so on) here, but since this will only allow your application access to a single
    user, it's probably not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: All requests will be posted to the same address, which will then allow us to
    validate the login credentials (remember `GenerateHash()` from our `password`
    package), and if they are valid, we will create the connection in `api_connections`
    and then return the user to the callback URL associated with the API credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the function that determines whether the login credentials are correct
    and if so, redirects to the callback URL with the `request_token` value that we
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With the `user_password` value, the `user_salt` value, and a submitted password
    value, we can verify the validity of the password by using our `GenerateHash()`
    function and doing a direct comparison, as they are Base64 encoded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After checking `expectedPassword` against the password in the database, we can
    tell whether the user authenticated correctly. If they did, we create the token
    and redirect the user back to the callback URL. It is then the responsibility
    of the other application to store the token for future use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the token on the third-party side, we can make API requests
    with that token and our `client_token` value to make requests on behalf of individual
    users, such as creating connections (friends and followers), sending automated
    messages, or setting status updates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We began this chapter by looking at ways to bring in more REST-style options
    and features, better security, and template-based presentation. Towards this goal,
    we examined a basic abstraction of the OAuth security model that allows us to
    enable external clients to work within a user's domain.
  prefs: []
  type: TYPE_NORMAL
- en: With our application now accessible via OAuth-style authentication and secured
    by HTTPS, we can now expand the third-party integration of our social networking
    application, allowing other developers to utilize and augment our service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look more at the client-side and consumer-side of
    our application, expanding our OAuth options and empowering more actions via the
    API that will include creating and deleting connections between users as well
    as creating status updates.
  prefs: []
  type: TYPE_NORMAL
