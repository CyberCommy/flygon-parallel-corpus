- en: Multimedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the type of a file—how to guess the type of a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting an image type—inspecting an image to understand what type of image
    it is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting an image size—inspecting an image to retrieve its size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing audio/video/images—playing audio, video, or showing images on desktop
    systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multimedia applications, such as videos, sounds, and games usually need to rely
    on very specific libraries to manage the formats used to store the data and the
    hardware needed to play their content.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the variety of formats for data storage, the continuous improvements
    in the field of video and audio storage that lead to new formats, and the heavy
    integration with native operating system functions and specific hardware programming
    languages, multimedia-related features are rarely integrated in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Having to maintain support for all the image formats that exist, when a new
    one is created every few months, requires a full-time effort that a dedicated
    library can tackle far better than the team maintaining the programming language
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, Python has relatively few multimedia-related functions, but
    some core ones are available and they can be very helpful in applications where
    multimedia is not the main focus, but maybe they need to handle multimedia files
    to properly work; for example, a web application that might need to check that
    the user-uploaded file is in a valid format supported by browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the type of a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we receive a file from our users, it's frequently necessary to detect its
    type. Doing so through the filename without the need to actually read the data
    can be achieved through the `mimetypes` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, the following steps are to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: While the `mimetypes` module is not bullet proof, as it relies on the name of
    the file to detect the expected type, it's frequently enough to handle most common
    cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Users will usually assign proper names to their files for their own benefit
    (especially Windows users, where the extension is vital for the proper working
    of the file), guessing the type with `mimetypes.guess_type` is often enough:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call `guess_file_type` against any file to get back its type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the type it''s unknown, `None` will be returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, note that the file itself doesn''t have to really exist. All you care
    about is it''s filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `mimetypes` module keeps a list of MIME types associated to each file extension.
  prefs: []
  type: TYPE_NORMAL
- en: When a filename is provided, only the extension is analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: If the extension is in a list of known MIME types, the associated type is returned.
    Otherwise `None` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `mimetypes.init()` also loads any MIME type registered in your system
    configuration, usually from `/etc/mime.types` on Linux systems and from the registry
    on Windows systems.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to cover far more extensions that might not be known by Python
    itself and to also easily support custom extensions if your system is configured
    to support them.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting image types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you know you are working with image files, it's frequently necessary to
    verify their type to ensure they are in a format your software is able to handle.
  prefs: []
  type: TYPE_NORMAL
- en: One possible use case is to ensure they are images in a format that a browser
    might be able to show back when they are uploaded to a website.
  prefs: []
  type: TYPE_NORMAL
- en: The type of a multimedia file can usually be detected by inspecting the file
    header, the initial part of a file that stores details about the content of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The header usually contains details about the kind of file, the size of the
    contained image, the number of bits per color, and so on. All these details are
    required to reproduce the content stored within the file itself.
  prefs: []
  type: TYPE_NORMAL
- en: By inspecting the header, it's possible to confirm the format of the stored
    data. This requires supporting the specific header format and the Python standard
    library has support for most common image formats.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `imghdr` module can help us understand what kind of image file we are facing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to detect the format of any image on disk or of a stream of
    bytes provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the provided filename is a string containing the path of a file, `imghdr.what`
    is called directly on it.
  prefs: []
  type: TYPE_NORMAL
- en: This just returns the type of the file or `None` if it's not supported.
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, a file-like object is provided (a file itself or a `io.BytesIO`,
    for example) then it will peak the first 32 bytes of it and detect the header
    based on those.
  prefs: []
  type: TYPE_NORMAL
- en: Given that most image types have a header with a size in the order of little
    more than 10 bytes, reading 32 bytes ensures that we should have more than enough
    to detect any image.
  prefs: []
  type: TYPE_NORMAL
- en: After reading the bytes, it will go back to the beginning of the file, so that
    any subsequent call is still able to read the file (otherwise, the first 32 bytes
    would be consumed and lost forever).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python standard library also provides a `sndhdr` module that behaves much
    like `imghdr` for audio files.
  prefs: []
  type: TYPE_NORMAL
- en: The formats recognized by `sndhdr` are usually very basic formats and thus it's
    usually mostly helpful when `wave` or `aiff` files are involved.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting image sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we know what kind of image we are facing, detecting the resolution is usually
    a matter of reading it from the image header.
  prefs: []
  type: TYPE_NORMAL
- en: For most image types, this is relatively simple, and as we can use `imghdr`
    to guess the right image type, we can then read the right part of the header,
    according to the detected type, to extract the size portion.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once `imghdr` detects the image type, we can read the content of the header
    with the `struct` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use the `ImageReader.get_size` class method to detect the size
    of any supported image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are four core parts of the `ImageReader` class that work together to provide
    support for reading image sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The first, the `ImageReader.get_size` method itself, is in charge of opening
    the image file and detecting the image type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is all related to opening the file in case it''s provided as
    a path in a string, as a `Path` object, or if it''s already a file object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If it's a string or a pathlike object (`os.PathLike` is only supported on Python
    3.6+), the file is opened and the `requires_close` variable is set to `True`,
    so that once we are finished, we will close the file.
  prefs: []
  type: TYPE_NORMAL
- en: If it's a `Path` object and we are on a Python version that doesn't support
    `os.PathLike`, then the file is opened through the path itself.
  prefs: []
  type: TYPE_NORMAL
- en: If, instead, the provided object was already an open file, we do nothing and
    `requires_close` remains `False`, so that we don't close the provided file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is opened, it gets passed to `imghdr.what` to guess the file
    type, and if it''s not one of the supported types, it gets rejected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we head back to the beginning of the file, so we can read the header
    and we call the relevant `cls._size_png, cls._size_jpeg` or `cls._size_gif` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each method is specialized in understanding the size of a specific file format,
    from the easiest one (GIF) to the most complex one (JPEG).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the GIF itself, all we have to do is skip the magic number (which only
    `imghdr.what` cared about; we already know it''s a GIF) and read the subsequent
    four bytes as unsigned shorts (16 bits number) in a little-endian byte ordering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`png` is nearly as complex. We skip the magic number and read the subsequent
    bytes as an `unsigned int` (32 bits number) in a big-endian order, followed by
    a four-bytes string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That gives us back the size of the image header followed by the image section
    name, which must be `IHDR`, to confirm we are reading an image header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know we are within the image header, we can just read the first two
    `unsigned int` numbers (still in big-endian) to extract the width and height of
    the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The last method is the most complex one, as JPEG has a far more complex structure
    than GIF or PNG. The JPEG header is composed of multiple sections. Each section
    is identified by `0xff` followed by an identifier of the section and by the section
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning, we just read the first two bytes and confirm that we face
    the **start of image** (**SOI**) section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then we look for a section that declares the JPEG as a baseline DCT, progressive
    DCT, or lossless frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is done by reading the first two bytes of each section and its size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know that each section starts with `0xff`, if we face a section that
    starts with a different byte, it means that the image is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If the section is valid, we can read its content. We know the size because
    it was specified as a two bytes unsigned short in a big-endian notation right
    after the two bytes marker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, before being able to read the width and height from the data we just read,
    we need to check that the section that we are looking at is actually a start of
    frame one, for baseline, progressive, or lossless. This means it must be one of
    the sections from `0xc0` to `0xcf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, we just skip this section and move to the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once we find one of the valid sections (depending on the kind of encoding the
    image has), we can read the size by looking at the first five bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first byte is the sample precision. We really don''t care about it so we
    can ignore it. Then the remaining four bytes are the height and the width of the
    image as two unsigned shorts in a big-endian notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Playing audio/video/images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python standard library provides no utilities to open images, and has limited
    support for playing audio files.
  prefs: []
  type: TYPE_NORMAL
- en: While it's possible to somehow play audio files in some formats by combining
    the `wave` and `ossaudiodev` or `winsound` modules, the OSS audio system has long
    been deprecated on Linux systems and neither of those is available on Mac systems.
  prefs: []
  type: TYPE_NORMAL
- en: For images, it would be possible to show an image using the `tkinter` module,
    but we would be constrained to very simple image formats as decoding the images
    would be on our own.
  prefs: []
  type: TYPE_NORMAL
- en: But there is one little trick we can use to actually display most image files
    and play most audio files.
  prefs: []
  type: TYPE_NORMAL
- en: On most systems, trying to open a file with the default web browser will by
    the way play the file, and we can rely on this trick and the `webbrowser` module
    to play most file types through Python.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a path that points to a supported file, we can build a `file:// url`
    out of it and then use the `webbrowser` module to open it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Opening an image should display it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, opening an audio file should play it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, we can use this method on most systems to show the content of a file to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `webbrowser.open` function does actually start the browser on Linux systems,
    but on macOS and Windows systems it does a fairly different job.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows and macOS systems, it will ask the system to open the specified path
    with the most suitable application.
  prefs: []
  type: TYPE_NORMAL
- en: If the path is an HTTP URL, the most suitable application is, of course, `webbrowser`,
    but if the path is a local `file://` URL, the system will look for a software
    able to handle that file type and will open the file with that software.
  prefs: []
  type: TYPE_NORMAL
- en: That is achieved by using an `os.startfile` on Windows systems and by running
    a small Apple script snippet through the `osascript` command on a macOS.
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to open image and audio files, and as most image and audio file
    formats are also supported by browsers, it will also work on Linux systems.
  prefs: []
  type: TYPE_NORMAL
