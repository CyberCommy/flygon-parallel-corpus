- en: Prepare Angular App for Production Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't ship it, it never happened. In the previous chapter, you created
    a local weather application that can retrieve current weather data. You have created
    some amount of value; however, if you don't put your app on the web, you end up
    creating zero value. Delivering something is difficult, delivering something to
    production is even more difficult. You want to follow a strategy that results
    in a reliable, high quality, and flexible release.
  prefs: []
  type: TYPE_NORMAL
- en: The app we created in [Chapter 2](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml), *Create
    a Local Weather Web Application*, is fragile, has failing unit and **end-to-end**
    (**e2e**) tests, and emits console errors. We need to fix the unit tests and harden
    the application by intentionally introducing errors so that you can see the side-effects
    of real-life conditions in action using debugging tools. We also need to be able
    to deliver the frontend app separately from the backend app, which is a very important
    decoupling to retain the flexibility of being able to push separate app and server
    updates. In addition, decoupling will ensure that as the various tools and technologies
    in your application stack inevitably falls out of support or favor, you will be
    able to replace your frontend or backend without a full rewrite of your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run Angular unit and e2e
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshoot common Angular errors using Chrome Developer Tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guard against null data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerize the app using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the app on the web using Zeit Now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Required software is as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Community Edition Version 17.12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zeit Now Account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just because your Angular app launches using `npm start` and seems to work fine,
    it doesn't mean it is error free or production ready. As covered earlier in [Chapter
    2](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml), *Create a Local Weather Web Application*,
    Angular CLI creates a unit test file as you create new components and services,
    such as `current-weather.component.spec.ts` and `weather.service.spec.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At their most basic, these unit default unit tests ensure that your new components
    and services can be properly instantiated in the test harness. Take a look at
    the following spec file and observe the `should create` test. The framework asserts
    that component of the `CurrentWeatherComponent` type to not be null or undefined,
    but be truthy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WeatherService` spec contains a similar test. However, you''ll note that
    both types of tests are set up slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the `WeatherService` spec's `beforeEach` function, the class under test is
    being configured as a provider and then injected into the test. On the other hand,
    the `CurrentWeatherComponent` spec has two `beforeEach` functions. The first,
    the `beforeEach` function declares and compiles the component's dependent modules
    asynchronously, while the second, the `beforeEach` function creates a test fixture
    and starts listening to changes in the component, ready to run the tests once
    the compilation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular CLI uses the Jasmine unit testing library to define unit tests and
    the Karma test runner to execute them. Best of it all, these testing tools are
    configured to be run out of the box. You may execute the unit tests with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The tests will be run by the Karma test runner in a new Chrome browser window.
    The main benefit of Karma is that it brings live-reloading capabilities similar
    to what Angular CLI achieves with WebPack when developing your application. You
    should observe the last message on the Terminal to be Executed 5 of 5 (5 FAILED)
    ERROR. This is normal, because we haven't been paying attention to the tests at
    all, so let's fix them all.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ca1b94c3-14d3-46ad-a89f-74bedca1c8bb.png)Karma Runner showing Jasmine
    Unit Test ResultsKeep the Karma Runner window open side-by-side with VS Code so
    that you can instantly see the results of your changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AppComponent should create the app test is failing. If you observe the error
    details, you'll see that `AppComponent` is failing to be created, because 'app-current-weather'
    is not a known element**.** Further, the error occurs if pointed out with a [ERROR
    ->] tag, and the last line spells things out for us, similar to the error originating
    from line 6 in AppComponent.html.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include `CurrentWeatherComponent` in the declarations of `app.component.spec.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll note that the number of errors didn't go down. Instead, `AppComponent` and
    `CurrentWeatherComponent` are failing to be created due to a missing provider
    for `WeatherService`. So, let's add the provider for `WeatherService` to the spec
    files for both components.
  prefs: []
  type: TYPE_NORMAL
- en: Provide the `WeatherService` in the declarations in `app.component.spec.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apply the same code change in `current-weather.component.spec.ts`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You may wonder why `AppComponent` is needing a provider, since the component
    constructor is not injected with the `WeatherService`. This is happening because `CurrentWeatherComponent` is
    a hard-coded dependency of `AppComponent`. It is possible to decouple the two
    components further in two ways: one way is to inject the component dynamically
    using an `ng-container`, and the other would be to leverage Angular Router and
    `router-outlet`. The latter option is how you will be structuring the vast majority
    of your applications and will be covered in the later chapters, and implementing
    the former option to properly decouple the components is left as an exercise for
    the reader.'
  prefs: []
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You still have errors remaining. Let's start by fixing the errors with the `WeatherService`
    error first, since it's a dependency of other components. The test is reporting
    a missing provider for `HttpClient`. However, we don't want our unit test to make
    calls over HTTP, so we shouldn't provide the `HttpClient`, like we did in the
    previous section. Angular provides a test double for `HttpClient` named `HttpClientTestingModule`.
    In order to leverage it, you must import it, and it will then be automatically
    provided to the service for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import `HttpClientTestingModule` below the providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `HttpClientTestingModule`, there's also a `RouterTestingModule` and
    a `NoopAnimationsModule` that are mock versions of the real services, so the unit
    tests can focus on only testing the component or service code that you write.
    In the later chapters, we will also cover how you can write your own mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should only see errors related to `AppComponent` and `CurrentWeatherComponent`.
    These components are failing even though you have provided their dependencies.
    To understand why this happens and how you can resolve it, you must also understand
    how to work with test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Test doubles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only the code in the class-under-test should be exercised. In case of the `CurrentWeatherComponent`,
    we need to ensure that the service code is not executed. For this reason, you
    should *never* provide the actual implementation of the service. This is also
    why we used `HttpClientTestingModule` in the previous section. Since this is our
    custom service, we must provide our own implementation of a test double.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will implement a fake of the service. Since the fake of the `WeatherService`
    will be used in tests for multiple components, your implementation should be in
    a separate file. For the sake of maintainability and discoverability of your code
    base, one class per file is a good rule of thumb to follow. Keeping classes in
    separate files will save you from committing certain coding sins, like mistakenly
    creating or sharing global state or standalone functions between two classes,
    keeping your code properly decoupled in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file `weather/weather.service.fake.ts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to ensure that APIs for the actual implementation and the test double
    don't go out of sync over time. We can accomplish this by creating an interface
    for the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `IWeatherService` to `weather.service.ts`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `WeatherService` so that it implements the new interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a basic fake in `weather.service.fake.ts`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We're leveraging the existing `ICurrentWeather` interface that our fake data
    is correctly shaped, but we must also turn it into an `Observable`. This is easily
    achieved using `of`, which creates an observable sequence, given the provided
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Now you're ready to provide the fake to `AppComponent` and `CurrentWeatherComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: Update providers for both components to use `WeatherServiceFake`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'so that the fake will be used instead of the actual service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As your services and components get more complicated, it''s easy to provide
    an incomplete or inadequate test double. You may see errors such as NetworkError:
    Failed to execute ''send'' on ''XMLHttpRequest'', Can''t resolve all parameters, or [object
    ErrorEvent] thrown. In case of the latter error, click on the Debug button in
    Karma to discover the view error details, which may look like Timeout - Async
    callback was not invoked within timeout specified by jasmine. Unit tests are designed
    to run in milliseconds, so it should be impossible to actually hit the default
    5-second timeout. The issue is almost always with the test setup or configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully resolved all configuration and setup related issues with
    our unit tests. Now, we need to fix the unit tests that were generated with the
    initial code.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine specs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two failing unit tests. In Jasmine lingo, unit tests are called specs,
    implemented by the `it` function; `it` functions are organized under the `describe`
    functions that contains helper methods that can execute before or after each test
    and handle the overall configuration needs of specs. Your app has five specs that
    have been generated for you, and two of them are now failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is `AppComponent should have as title ''app''`; however, we deleted
    this property from `AppComponent`, because we are not using it. In this rare case,
    we need to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `should have as title 'app'` unit test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The error message is descriptive enough to let you know what test is failing
    quickly. This happens, because the description provided to the `describe` function
    is `'AppComponent'` , and the description provided to the `it` function is `'should
    have as title "app"'`. Jasmine then appends any parent object's description to
    the description of the spec. As you write new tests, it is up to you to maintain
    readable descriptions for your specs.
  prefs: []
  type: TYPE_NORMAL
- en: The next error, `AppComponent` `should render title in a h1 tag`, is one that
    we must fix. We render the words `LocalCast Weather` in the `h1` tag now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `should render title in a h1 tag` test as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All unit tests are now successfully passing. We should be performing atomic
    commits, so let's commit the code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Commit your code changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to achieve effective unit test coverage, you should focus on testing
    the correctness of functions that contain business logic. This means that you
    should pay extra attention to adhering to the Single Responsibility and Open/Closed
    Principles, the S and O in SOLID principles.
  prefs: []
  type: TYPE_NORMAL
- en: Angular e2e tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to unit tests, Angular CLI also generates and configures e2e tests
    for your application. While unit tests focus on isolating the class-under-test,
    e2e tests are about integration testing. Angular CLI leverages Protractor along
    with WebDriver, so you can write **automated acceptance tests** (**AAT**) from
    the perspective of a user interacting with your application on a browser. As a
    rule of thumb, you should always write an order of magnitude more unit tests than
    AATs, because your app changes frequently and as a result, AATs are vastly more
    fragile and expensive to maintain compared to unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: If the term web driver sounds familiar, it's because it is an evolution of the
    canonical Selenium WebDriver. As of March 30th, 2017, WebDriver has been proposed
    as an official web standard at the W3C. You read more about it at [https://www.w3.org/TR/webdriver](https://www.w3.org/TR/webdriver).
    If you're familiar with Selenium from before, you will feel right at home, since
    a lot of the patterns and practices are near identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'The CLI provides e2e tests for the initial `AppComponent` and depending on
    the complexity and the feature set of your application, it is up to you to follow
    the provided pattern to better organize your tests. There two files generated
    per component under the `e2e` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`app.e2e-spec.ts` is written in Jasmine and implements acceptance tests. The
    spec is dependent upon the page object (`po`) file, which is defined beside the
    `spec` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The page object file encapsulates web driver implementation specifics from the
    `spec` file. AATs are the most. This results in easy-to-maintain, human-readable
    spec files. By separating concerns at this level, you isolate fragility of AATs
    to one location. By leveraging class inheritance, you can build a robust collection
    of page objects that can be easier to maintain over time.
  prefs: []
  type: TYPE_NORMAL
- en: e2e test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may execute the e2e tests with the following command in the terminal; ensure
    that the `npm test` process is not running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You will note that the test execution is different as compared to unit tests.
    While you can configure a watcher to continually execute unit tests with Karma,
    due to the user-driven and stateful nature of e2e tests, it is not a good practice
    to attempt a similar configuration with e2e tests. Running the tests once and
    stopping the test harness ensures a clean state with every run.
  prefs: []
  type: TYPE_NORMAL
- en: e2e spec
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After executing the e2e tests, you should see an error message similar to the
    one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This error is similar to the unit test you fixed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `spec` to expect the correct header as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the tests and they should be passing now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Commit your code changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Troubleshooting common Angular errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our unit tests and e2e tests are now working. In this section, you intentionally
    introduce an easy-to-make mistake so that you can become familiar with real-life
    errors that can be happen while developing your applications and gain a solid
    understanding of the tooling that makes make you an effective developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s pretend that we made an innocent mistake when copying and pasting the
    URL from the API documentation page on `OpenWeatherMap.org` and forgot to add
    `http://` in front of it. This is an easy mistake to make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Your app will compile successfully, but when you inspect the results in the
    browser, you won''t see any weather data. In fact, it seems like the `CurrentWeather`
    component is not rendering at all, as you can see in the image below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/702cc572-cc9a-42c5-9635-facae5ecfac5.png)CurrentWeather Does Not
    Render'
  prefs: []
  type: TYPE_NORMAL
- en: To find out why, you will need to debug your Angular app.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Chrome Developer Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, I use the Google Chrome browser because of its cross-platform
    and consistent developer tools with helpful extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Open Chrome Developer Tools (dev tools) on macOS by pressing *option* + ⌘ +
    *I* or on Windows by pressing *F12* or *Ctrl* + *Shift* + *I*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a best practice, I code with VS Code and the browser open side by side,
    while the dev tools are also open in the browser. There are several good reasons
    for practicing side-by-side development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast feedback loops**: With live-reloading, you see the end result of your
    changes very quickly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Laptops**: A lot of developers now do most of their development on a laptop
    and a second monitor is a luxury'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attention to responsive design**: As I have limited space to work with, I
    constantly pay attention to mobile-first development, fixing desktop layout issues
    after the fact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Awareness of network activity**: To enable me to quickly see any API call
    errors and also ensure that the amount of data that is being requested remains
    in line within my expectations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Awareness of console errors**: To enable me to quickly react and troubleshoot
    when new errors are introduced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Observe how side-by-side development looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8abe7631-fffb-459f-a67a-48885508448b.png)Side-by-side development
    with live-reloading runningUltimately, you should do what works best for you.
    With the side-by-side setup, I frequently find myself toggling VS Code''s Explorer
    on and off and resizing the dev tools pane to a larger or smaller size depending
    on the specific task at hand. To toggle VS Code''s Explorer, click on the Explorer
    icon circled in the preceding screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can do side-by-side development with live-reloading using `npm start`,
    you can get the same kind of fast feedback loops for unit testing using `npm test`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a7785cea-8818-426c-b393-7979d7c13f67.png)Side-by-side development
    with unit testing'
  prefs: []
  type: TYPE_NORMAL
- en: With the side-by-side unit testing setup, you can become very effective in developing
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Chrome Dev Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the side-by-side development with live-reloading to work well, you need
    to optimize the default dev tools experience.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/75d088f6-c4a3-481d-ad5d-ceb75fc7c11b.png)Optimized Chrome Developer
    Tools'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the preceding figure, you will note that numerous settings and information
    radiators are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: Have the Network tab open by default so that you can see network traffic flowing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the dev tools settings by clicking on the ![](Images/0934097c-46b9-40a7-a157-d5685f22e518.png) 
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the right-hand side icon so that dev tools dock on the right-hand side
    of Chrome. This layout gives more vertical space, so you can see more network
    traffic and console events at once. As a side benefit, the left-hand side takes
    the rough size and shape of a mobile device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle on large request rows and toggle off overview to see more of the URL
    and parameters for each request and gain more vertical space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the option to Disable cache, which will force reload every resource when
    you refresh a page while the dev tools are open. This prevents bizarre caching
    errors from ruining your day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will mostly be interested in seeing XHR calls to various APIs, so click
    on XHR to filter results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that you can glance the number of console errors in the upper-right corner
    as 12. The ideal number of console errors should be 0 at all times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the top item in the request row is indicating that there's an error
    with status code 404 Not Found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are debugging an Angular application, the Augury extension has been
    loaded. I will cover this tool in more detail in [Chapter 7](b35a976c-1709-4f43-9c4e-1cf957e7ca6c.xhtml),* Create
    a Router-First Line-of-Business App*, when you will be building a far more complicated
    app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With your optimized dev tools environment, you can now effectively troubleshoot
    and resolve the application error from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting network issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three visible issues with the app at this state:'
  prefs: []
  type: TYPE_NORMAL
- en: The component details aren't displaying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous console errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API call is returning a 404 not found error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Begin by inspecting any network errors, since network errors usually cause
    knock-on effects:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the failing URL in the Network tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Details pane that opens to the right of the URL, click on the Preview
    tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By just observing this error message, you will likely miss the fact that you
    forgot to add the `http://` prefix to the URL. The bug is subtle and certainly
    not glaringly obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hover over the URL and observe the full URL, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/b91c6120-fedf-41eb-af35-06e479b1bd40.png)Inspecting Network Errors'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, now the bug is glaringly obvious. In this view, we get to see
    the full URL, and it becomes clear that the URL defined in `weather.service.ts`
    is not fully qualified, so Angular is attempting to load the resource from its
    parent server, hosted on `localhost:5000`, instead of going over the web to the
    right server.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating console errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you fix this issue, it is worthwhile to understand the knock-on effects
    of the failing API call:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe the console errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/08e5a182-5e45-4fc3-8867-87745b5daf94.png)Dev Tools Console Error
    Context'
  prefs: []
  type: TYPE_NORMAL
- en: The first element of note here is the ERROR CONTEXT object, which has a property
    named DebugContext_. The DebugContext_ contains a detailed snapshot of the current
    state of your Angular application when the error happened. The information contained
    within DebugContext_ is light years ahead of the amount of mostly unhelpful error
    messages AngularJS generates.
  prefs: []
  type: TYPE_NORMAL
- en: Properties that have the value (...) are property getters, and you must click
    on them to load their details. For example, if you click on the ellipsis for componentRenderElement,
    it will be populated with the app-current-weather element. You can expand the
    element to inspect the runtime condition of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Now scroll to the top of the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe the first error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You have probably encountered the `TypeError` before. This error is caused by
    trying to access the property of an object that is not defined. In this case,
    `CurrentWeatherComponent.current` is not assigned to with an object, because the
    http call is failing. Since `current` is not initialized and the template blindly
    tries to bind to its properties like `{{current.city}}`, we get a message saying
    property 'city' of undefined cannot be read. This is the kind of knock-on effect
    that can create many unpredictable side-effects in your application. You must
    proactively code to prevent this condition.
  prefs: []
  type: TYPE_NORMAL
- en: Karma, Jasmine, and Unit Testing errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When running tests with the `ng test` command, you will encounter some high-level
    errors that can mask the root cause of the actual underlying errors.
  prefs: []
  type: TYPE_NORMAL
- en: The general approach to resolving errors should be inside out, resolving child
    component issues first and leaving parent and root components for last.
  prefs: []
  type: TYPE_NORMAL
- en: NetworkError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Network errors can be caused by a multitude of underlying issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Working inside out, you should implement test doubles of services and provide
    the fakes to the appropriate components, as covered in the previous section. However,
    in parent components, you may still encounter errors even if you correctly provided
    fakes. Refer to the section on dealing with generic error events to uncover the
    underlying issues.
  prefs: []
  type: TYPE_NORMAL
- en: Generic ErrorEvents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error events are generic errors that hide the underlying cause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To expose the root cause of a generic error, implement a new `test:debug` script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement `test:debug`, as shown, in `package.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Execute `npm run test:debug`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the Karma runner will likely reveal the underlying issue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, follow the stack trace to find the child component that may be
    causing the issue
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this strategy is not helpful, you may be able to glean more information on
    what's going wrong by break point debugging your unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Visual Studio Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also debug your Angular application, Karma, and Protractor tests from
    directly within Visual Studio Code. First, you need to configure the debugger
    to work with a Chrome debugging environment, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7da64ae5-7684-4230-a1e8-55bb8cb009c0.png)VS Code Debugging Setup'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Debug pane
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the No Configurations dropdown and click on Add Configuration...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Select Environment select box, select Chrome
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will create a default configuration in the `.vscode/launch.json` file.
    We will modify this file to add three separate configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents of `launch.json` with the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Execute the relevant CLI command like `npm start`, `npm test`, or `npm run e2e` beforeyou
    start the debugger
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Debug page, in the Debug dropdown, select npm start and click on the
    green play icon
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe that a Chrome instance has launched
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a break point on a `.ts` file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the action in the app to trigger the break point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all goes well, Chrome will report that the code has been Paused in Visual
    Studio Code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of publication, this method of debugging doesn't reliably work.
    I had to manually set a break point in Chrome Dev Tools | Sources tab, finding
    the same `.ts` file under the `webpack://.` folder, which correctly triggered
    the break point in VS Code. However, this renders the entire benefit of using
    VS Code to debug code useless. For more information, follow the Angular CLI section
    on VS Code Recipes on GitHub at [https://github.com/Microsoft/vscode-recipes](https://github.com/Microsoft/vscode-recipes).
  prefs: []
  type: TYPE_NORMAL
- en: Null guarding in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, the `undefined` and `null` values are a persistent issue that
    must be proactively dealt with every step of the way. There are multiple ways
    to guard against `null` values in Angular:'
  prefs: []
  type: TYPE_NORMAL
- en: Property Initialization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Safe Navigation Operator `?.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Null Guarding with `*ngIf`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Property initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In statically-typed languages such as Java, it is drilled into you that proper
    variable initialization/instantiation is the key to error free operation. So let''s
    try that in `CurrentWeatherComponent` by initializing current with default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of these changes will reduce console errors from 12 to 3, at which
    point you will only be seeing API call related errors. However, the app itself
    will not be in a presentable state, as you can see below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0b7f8993-abf1-455f-aeaf-9af5a22498e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Results of Property Initialization
  prefs: []
  type: TYPE_NORMAL
- en: To make this view presentable to user, we will have to code for default values
    on every property on the template. So by fixing the null guarding issue by initialization,
    we created a default value handling issue. Both the initialization and the default
    value handling are *O(n)* scale tasks for developers. At its best, this strategy
    will be annoying to implement and at its worst, highly ineffective and error prone,
    requiring, at minimum, *O(2n)* effort per property.
  prefs: []
  type: TYPE_NORMAL
- en: Safe navigation operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Angular implements the safe navigation operation `?.` to prevent unintended
    traversals of undefined objects. So, instead of writing initialization code and
    having to deal with template values, let''s just update the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we didn''t have to make up defaults, and we let Angular deal with
    displaying undefined bindings. You will note that just like the initialization
    fix, the errors have been reduced from 12 to 3\. The app itself is in a somewhat
    better shape. There''s no more confusing data being displayed; however, it still
    is not in a presentable state, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/47b9f913-c1ae-4553-bdc4-87ace908cfa1.png)Results of Safe Navigation
    Operator'
  prefs: []
  type: TYPE_NORMAL
- en: You can probably imagine ways where the safe navigation operator can come in
    handy, in far more complicated scenarios. However, when deployed at scale, this
    type of coding still requires, at minimum, *O(n)* level of effort to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Null guarding with *ngIf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea strategy will be to use `*ngIf`, which is a structural directive, meaning
    Angular will stop traversing DOM tree elements beyond a falsy statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CurrentWeather` component, we can easily check to see whether the `current`
    variable is null or undefined before attempting to render the template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the topmost `div` element with `*ngIf` to check whether `current` is
    an object, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now observe the console log and that no errors are being reported. You always
    ensure that your Angular application reports zero console errors. If you're still
    seeing errors in the console log, ensure that you have correctly reverted the
    `OpenWeather` URL to its correct state or kill and restart your `npm start` process.
    I highly recommend that you resolve any console errors before moving on. Once
    you've fixed all errors, ensure that you commit your code again.
  prefs: []
  type: TYPE_NORMAL
- en: Commit your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Containerizing the app using Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker [docker.io](http://docker.io) is an *open platform* for developing,
    shipping, and running applications. Docker combines a *lightweight* container
    virtualization platform with workflows and tooling that help manage and deploy
    applications. The most obvious difference between **Virtual Machines** (**VMs**)
    and Docker containers are that VMs usually are dozens of gigabytes in size and
    require gigabytes of memory, whereas containers are megabytes in disk and memory
    size requirements. Furthermore, the Docker platform abstracts away host **operating
    system** (**OS**) level configuration settings, so every piece of configuration
    that is needed to successfully run an application is encoded within the human-readable
    Dockerfile format, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding file describes a new container that inherits from a container
    named `duluca/minimal-node-web-server`, changes the working directory to `/usr/src/app`,
    and then copies the contents of `dist` folder from your development environment
    into the container''s `public` folder. In this case, the parent image is configured
    with an Express.js server to act as a web server to serve the content inside the
    `public` folder. Refer to the following diagram for a visual representation of
    what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1ed1c77e-c276-4cfb-aaec-b4adb09ef402.jpg)Context of a Docker Image'
  prefs: []
  type: TYPE_NORMAL
- en: At the base layer is our host OS, such as Windows or macOS that runs the Docker
    runtime, which will be installed in the next section. The Docker runtime is capable
    of running self-contained Docker images, which is defined by the aforementioned
    `Dockerfile`. `duluca/minimal-node-web-server` is based off of the lightweight
    Linux operating system Alpine. Alpine is a completely pared down version of Linux
    that doesn't come with any GUI, drivers or even most CLI tools you may expect
    from a Linux system. As a result, the OS is around only ~5 MB in size. The base
    package then installs Node.js, which itself is around ~10 MB in size and my custom
    Node.js-based Express.js web server, resulting in a tiny ~15 MB image. The Express
    server is configured to serve the contents of the `/usr/src/app` folder. In the
    preceding `Dockerfile`, we merely copy the contents of the `/dist` folder in our
    development environment and place it into the `/usr/src/app` folder. We will later
    build and execute this image, which will run our Express web server containing
    the output of our `dist` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-node-web-server`, read its `Dockerfile`, and trace
    its origins all the way back to the original base image that is the foundation
    of the web server. I encourage you to vet every Docker image you use in this manner
    to understand what exactly it brings to the table for your needs. You may find
    it either overkill or has features you never knew about that can make your life
    a lot easier. Note that the parent images require a specific version of `duluca/minimal-node-web-server` at `8.11.1`.
    This is quite intentional, and as the reader, you should choose the latest available
    version of a Docker image you find. However, if you don't specify a version number,
    you will always get the latest version of the image. As more versions of an image
    is published, you may pull a future version that may break your application. For
    this reason, always specify a version number for images you're depending on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such case is the HTTPS redirection support that is baked into `duluca/minimal-node-web-server`.
    You can spend countless hours trying to set up a nginx proxy to do the same thing,
    when all you need to do is add the following line to your Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml), *Highly-Available
    Cloud Infrastructure on AWS,* I mention the use of a lower footprint docker image
    based on Nginx. If you're comfortable configuring `nginx`, you can use `duluca/minimal-nginx-web-server`
    as your base image.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to be able to build and run containers, you must first install the
    Docker execution environment on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Windows support of Docker can be challenging. You must have a PC with a CPU
    that supports virtualization extensions, which is not a guarantee on laptops.
    You must also have a Pro version of Windows with Hyper-V enabled. On the flip
    side, Windows Server 2016 has native support for Docker, which is an unprecedented
    amount of support shown by Microsoft toward the industry initiative to adopt Docker
    and containerization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Docker by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Execute `docker -v` to verify the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up Docker scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s configure some Docker scripts that you can use to automated the
    building, testing, and publishing of your container. I have developed a set of
    scripts called **npm Scripts for Docker** that work on Windows 10 and macOS. You
    can get the latest version of these scripts at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker):'
  prefs: []
  type: TYPE_NORMAL
- en: Sign up for a Docker Hub account on [https://hub.docker.com/](https://hub.docker.com/)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a public (free) repository for your application
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfortunately, at the time of publication, Zeit doesn't support private Docker
    Hub repositories, so your only alternative is to publish your container publicly.
    If your image must remain private, I encourage you to set up an AWS ECS environment
    as described in [Chapter 11](ba073d6f-c0a0-4681-aea6-aeedac3cbc69.xhtml), *Highly-Available
    Cloud Infrastructure on AWS*. You can keep tabs on the issue by visiting Zeit
    Now's documentation at [zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `package.json` to add a new config property with the following configuration
    properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The namespace will be your DockerHub username. You will be defining what your
    repository is called during creation. An example image repository variable should
    look like `duluca/localcast-weather`. The image name is for easy identification
    of your container, while using Docker commands such as `docker ps`. I will call
    mine just `localcast-weather`. The port will define which port should be used
    to expose your application from inside the container. Since we use `5000` for
    development, pick a different one, like `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Add Docker scripts to `package.json` by copy-pasting the scripts from [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker).
    Here's an annotated version of the scripts that explains each function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that with npm scripts, the `pre` and `post` keywords are used to execute
    helper scripts, respectively, before or after the execution of a given script
    and scripts are intentionally broken into smaller pieces to make it easier to
    read and maintain them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:build` will build your Angular application in `pre`, then build
    the Docker image using the `docker image build` command and tag the image with
    a version number in post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the `latest` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:run` will remove any existing, prior version of an image and
    run the already built image using the `docker run` command. Note that the `imagePort`
    property is used as the external port of the Docker image, which is mapped to
    the internal port of the image that the Node.js server listens to, port `3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command. First, the versioned
    image is published, followed by one tagged with `latest` in post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:clean` will remove a previously built version of the image
    from your system, using the `docker rm -f` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a very useful tool when debugging
    your Docker instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:open:win` or `npm run docker:open:mac` will wait for 2 seconds
    and then launch the browser with the correct URL to your application using the
    `imagePort` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install two development dependencies that are needed to ensure cross-platform
    functionality of the scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Customize the pre-build script to execute unit and e2e tests before building
    the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `npm run build` is provided the `--prod` argument, which achieves
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Development time payload of ~2.5 MB is optimized down to ~73kb or less
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The configuration items defined in `src/environments/environment.prod.ts`
    is used at runtime
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `src/environments/environment.prod.ts` to look like using your own `appId`
    from `OpenWeather`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior. In addition `npm run build` is provided with `--output-path dist` to
    ensure that `index.html` is published at the root of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `Dockerfile` with no file-extensions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the `Dockerfile`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to inspect the contents of your `dist` folder. Ensure that `index.html`
    is at the root of `dist`. Otherwise ensure that your `Dockerfile` copies the folder
    that has `index.html` at its root.
  prefs: []
  type: TYPE_NORMAL
- en: Execute `npm run predocker:build` to ensure that your application changes have
    been successful
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `npm run docker:build` to ensure that your image builds successfully
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**npm run docker:debug **will test, build, tag, run, tail and launch your containerize
    app in a new browser window for testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**npm run docker:publish **will publish the image you just built and test to
    the online Docker repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute `docker:debug` in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You will note that the scripts display errors in the Terminal window. These
    are not necessarily indicators of a failure. The scripts are not polished, so
    they attempt both Windows and macOS compatible scripts parallelly, and during
    a first build, the clean command fails, because there's nothing to clean. By the
    time you read this, I may have published better scripts; if not, you're more than
    welcome to submit a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the terminal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, or if it is clashing with the existing images claiming the
    same port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute `docker:publish` in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You should observe a successful run in the Terminal window like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Over time, your local Docker cache may grow to a significant size, that is,
    on my laptop, roughly 40 GB over two years. You can use the `docker image prune`
    and `docker container prune` commands to reduce the size of your cache. For more
    detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look into an easier way to interact with Docker next.
  prefs: []
  type: TYPE_NORMAL
- en: Docker extension in VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `PeterJausovec.vscode-docker` Docker extension, as suggested
    in [Chapter 2](312e0dbe-54ac-45c6-97c7-f41c98723919.xhtml)*, Create a Local Weather
    Web Application*, you will see an expandable title named DOCKER in the Explorer
    pane of VS Code, as pointed out with an arrow in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b002db3c-9f9a-4476-b5bb-90c2085ac184.png)Docker extension in VS
    Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through some of the functionality provided by the extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images** contains a list of all the container snapshots that exist on your
    system'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-clicking on a Docker image brings up a context menu to run various operations
    on it, like run, push and tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Containers** list all executable Docker containers that exist on your system,
    which you start, stop or attach to'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Registries** display the registries that you''re configured to connect to,
    like DockerHub or AWS Elastic Container Registry'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the extension makes it easier to interact with Docker, **npm Scripts for
    Docker** automate a lot of the chores related to building, tagging and testing
    and image. They are cross-platform and will work equally well in a continuous
    integration environment.
  prefs: []
  type: TYPE_NORMAL
- en: You may find it confusing to interact with npm scripts in general through the
    CLI. Let's look at VS Code's npm script support next.
  prefs: []
  type: TYPE_NORMAL
- en: NPM Scripts in VS Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm script explorer, open VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named NPM
    SCRIPTS in the Explorer pane, as pointed out with an arrow here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ce308d57-171d-4d8b-a50f-1d11a1dcb2e9.png)NPM Scripts in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select Run to execute the script.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying containerized app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If delivering something to production is difficult from a coding perspective,
    it is extremely difficult to do it right from an infrastructure perspective. In
    the later chapters, I will cover how to provision a world-class AWS **Elastic
    Container Service** (**ECS**) infrastructure for your applications, but that won't
    help if you need to quickly demonstrate an idea. Enter, Zeit Now.
  prefs: []
  type: TYPE_NORMAL
- en: Zeit Now
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zeit Now, [https://zeit.co/now](https://zeit.co/now), is a multi-cloud service
    that enables real-time global deployments of applications directly from the CLI.
    Now works with applications that either correctly implement `package.json` or
    a `Dockerfile`. Even though we have done both, we will prefer to deploy our Docker
    image, because a lot more magic is applied behind the scenes to make a `package.json`
    deployment work, whereas your Docker image can be deployed anywhere, including
    AWS ECS.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Now CLI tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s configure Zeit Now to work on your repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Zeit Now by executing `npm i -g now`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure correct installation by executing `now -v`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder under `local-weather-app` called `now`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `Dockerfile` under the new `now` folder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the file to pull from the image you just published:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, execute the `now` command in your terminal and follow the instructions
    to the finish configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Deploying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying on Zeit Now is very easy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change your working directory to `now` and execute the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Terminal window, the tool will report its progress and the URL from
    which you can access your now published app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the URL listed on the second line and verify the publication of
    your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that if you've made a configuration error along the way, your browser may
    display an error saying This page is trying to load unsafe scripts, allow and
    reload to see your app.
  prefs: []
  type: TYPE_NORMAL
- en: You can explore Zeit Now's paid features, which allow for advanced features
    such as automated scaling for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you are app is live on the internet!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you mastered unit and e2e test configuration and setup. You
    optimized your troubleshooting tools and became aware of the common Angular errors
    you will encounter while developing applications. You learned how to best avoid
    Angular console errors by guarding against null data. You configured your system
    to work with Docker and successfully containerized your web application with its
    own dedicated web server. You configured your project with npm scripts for Docker
    that can be leveraged by any team member. Finally, you have successfully delivered
    a web application in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know what takes to build a production-ready Angular application that
    is reliable, resilient, and containerized to allow for a flexible deployment strategy.
    In the next chapter, we will improve the apps feature set and make it look great
    using Angular Material.
  prefs: []
  type: TYPE_NORMAL
