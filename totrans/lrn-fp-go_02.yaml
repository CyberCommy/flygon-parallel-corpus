- en: Manipulating Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling lists of items is a common occurrence in life as well as in programming
    languages. When a list has associated functions that help us manipulate the items
    in the list, we often call that object a collection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how high-order functions can be used to greatly
    simplify the task of manipulating collections. We'll see how we can code using functional
    programming techniques and open source functional packages to create elegant solutions
    that are not only insightful, but also performant in today's distributed processing
    environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through a collection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about intermediate and terminal functors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use predicates to filter items in a collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test using a Mocha-like BDD library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on Map functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grasp the breadth of the collection-manipulating functions in Itertools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage routines and channels to iterate through a collection
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how we can use Go to process big data collections
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a collection
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to implement a collection, we must provide a way to access each element
    in the collection, which can be accomplished using the int index value shown in
    the following code. We will implement a **first in, first out** (**FIFO**) order
    queue. We will provide a way to store the elements using a slice data structure.
    Lastly, we will implement a `Next()` method to provide a way to traverse the elements
    in the collection.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we define an interface for the `Iterator` object. It
    has one method, `Next()`, which will return the next element in the collection
    and a Boolean flag to indicate whether it''s OK to continue iterating:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we define a collection object that has two properties: an `int` index
    used to access the current element and a slice of strings, that is, the actual
    data in the collection:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we implement the collection''s `Next()` method to meet the `IntIterator`
    interface''s specification:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `newSlice` function is the constructor for the iterable collection `intCollection`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we implement the `main()` function to test our `Collection`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up a terminal window and use the `.init` toolset to run our simple
    Go application:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a83d65f5-90c5-4260-b7dc-78042af5eb3b.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: The `. init` ("Dot Init") toolset ensures that we have Go installed and that
    our `GOPATH` and `GOBIN` directories are properly configured. First, we source
    the init script by typing `.init`. Since we have no import statements, there is
    no need to run glide-update. To run our application, we type `go-run`. For more
    details about Dot Init, see the [Appendix](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=99&action=edit#post_7),
    *Miscellaneous Information and How-Tos*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this implementation is that we are mixing what we want to do
    with how we do it. We implement an explicit `for` loop to perform the mechanics
    of the iteration. We define and mutate the value of the index value in order to
    traverse the elements. We can immediately see that this is an imperative implementation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, we declare what to, rather than imperatively implementing
    each detail of each operation. We also avoid the sequential nature of `for` loops,
    which are difficult to fit into a concurrent programming model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Go is not a functional programming language, but it has a lot of functional
    features and we can leverage those features to write concise, expressive, and
    hopefully, bug-free code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: A pure functional language does not maintain a state. Function calls are often
    chained, where input is passed from function to function. Each function call transforms
    its input in some way. These functions do not need to be concerned about the external
    state and do not produce side effects. Each function call can be very efficient
    at what it does. This style of programming lends itself to efficient testing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how function chaining is a lot like piping output through Bash
    commands.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到函数链式调用非常类似于通过Bash命令传递输出。
- en: Piping Bash commands
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bash命令传递
- en: Executing a composition or chain of functions is very much like executing a
    series of Bash commands, where the output from one command is piped into the next
    command. For example, we might cat an input a file that contains a list of timestamps
    and IP addresses in an `awk` command. The `awk` command removes all but the seventh
    column. Next, we sort the list in descending order, and finally, we group that
    data by unique IP addresses.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行函数的组合或链非常类似于执行一系列Bash命令，其中一个命令的输出被传送到下一个命令。例如，我们可能在`awk`命令中输入一个包含时间戳和IP地址列表的文件。`awk`命令删除除第七列之外的所有内容。接下来，我们按降序对列表进行排序，最后，我们按唯一的IP地址对数据进行分组。
- en: 'Consider the following Bash command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Bash命令：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s give this command the following input:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这个命令以下输入：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following output:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is a very common pattern in functional programming. We often input a collection
    of data to a function, or chain of function calls, and get a result that has been
    transformed in some way.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数式编程中非常常见的模式。我们经常将数据集输入到函数或一系列函数调用中，并获得以某种方式转换的结果。
- en: Collections are used frequently. When we implement them in a concise manner,
    chaining function calls that explicitly declare what we want to accomplish, we
    greatly reduce code ceremony. The result is that our code is more expressive,
    concise, and easier to read.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 集合经常被使用。当我们以简洁的方式实现它们时，通过链式函数调用明确声明我们想要实现的目标，我们大大减少了代码的繁文缛节。结果是，我们的代码更具表现力、简洁，并且更易于阅读。
- en: Functors
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函子
- en: 'Go has three predeclared/raw data types: `bool`, `string`, numeric (`float`,
    `int64`, and so on). Other data types in Go require type declarations, that is,
    they require we use the `type` keyword. Functions fall in the later category of
    data types along with array, struct, pointer, interface, slice, map, and channel
    types. In Go, functions are first-class data types, which means that can be passed
    around as parameters and returned as values. Functions that can take functions
    as arguments and return functions are called high-order functions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Go有三种预声明/原始数据类型：`bool`、`string`、数值（`float`、`int64`等）。Go中的其他数据类型需要类型声明，也就是说，它们需要我们使用`type`关键字。函数属于后一类数据类型，与数组、结构、指针、接口、切片、映射和通道类型一起。在Go中，函数是头等数据类型，这意味着它们可以作为参数传递并作为值返回。可以接受函数作为参数并返回函数的函数称为高阶函数。
- en: We can write function factories--functions that return functions--and even function
    factory factories. We can also write functions that modify functions or create
    functions for specific purposes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写函数工厂--返回函数的函数--甚至函数工厂工厂。我们还可以编写修改函数或为特定目的创建函数的函数。
- en: '**Functors**: A functor is a collection of `X` variables that can apply a function,
    `f`, over itself to create a collection of `Y`, that is, `f (X) → Y`. (To see
    what we''re talking about here, take a quick look at the *Fingers times 10 functor*
    example in [Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**函子**：函子是一个包含`X`变量的集合，可以将函数`f`应用于自身，以创建一个`Y`的集合，即`f(X) → Y`。（要了解我们在这里谈论的是什么，请快速查看[第9章](../Text/Ch09.xhtml)中的*Fingers
    times 10 functor*示例，*函子、幺半群和泛型*）'
- en: Note that the Prolog software language defines a functor to simply be a function.
    The preceding definition comes from the *Category Theory* influence on functional
    programming. (For more details, see [Chapter 11](../Text/Ch11.xhtml), *Category
    Theory That Applies*.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Prolog软件语言将函子定义为简单的函数。前面的定义来自于函数式编程对*范畴论*的影响。（有关更多详细信息，请参见[第11章](../Text/Ch11.xhtml)，*适用的范畴论*。）
- en: Functions that modify functions
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改函数的函数
- en: Before we explore intermediate and terminal functions lets' clarify the phrase
    *functions that modify functions* using a few examples.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索中间和终端函数之前，让我们通过一些例子澄清短语*修改函数的函数*。
- en: A coding example of functions that modify functions
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数修改函数的编码示例
- en: 'The following is a snippet of the code we might write to build a section of
    a page with two drop down lists, one for makes and the other for models of cars:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可能编写的代码片段，用于构建一个页面部分，其中包含两个下拉列表，一个用于汽车制造商，另一个用于汽车型号：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that each http.Get is a separate API call. Each API call is a partial
    application. In order for renderPage to wait for each call to complete we must
    curry our API calls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个http.Get都是一个单独的API调用。每个API调用都是部分应用。为了使renderPage等待每个调用完成，我们必须对我们的API调用进行柯里化。
- en: 'Here''s what the resulting HTML might look like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成的HTML可能看起来像：
- en: '![](img/108dc35b-5d2a-48a3-a59f-1dbe93e674d5.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/108dc35b-5d2a-48a3-a59f-1dbe93e674d5.png)'
- en: A visual example of functions that modify functions
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数修改函数的视觉示例
- en: In the previous example we composed part of an HTML web page. In this example,
    let's immerse ourselves into a Railroading world and lay down some train tracks
    using function composition.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们组成了HTML网页的一部分。在这个例子中，让我们沉浸在一个铁路世界中，使用函数组合铺设一些火车轨道。
- en: '![](img/0f10db22-6848-4ac4-b2cc-7b6edc8ff6e5.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f10db22-6848-4ac4-b2cc-7b6edc8ff6e5.png)'
- en: Immersive Railroading World
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 沉浸式铁路世界
- en: The following is our toolbox of reusable components. We modify our world by
    adding items from our toolbox. Thus, our immersive railroading *world* function
    is modified by adding and connecting a bunch of smaller *component* functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的可重用组件工具箱。我们通过从工具箱中添加项目来修改我们的世界。因此，我们沉浸式铁路*世界*函数通过添加和连接一堆较小的*组件*函数来修改。
- en: '![](img/e9f7d447-6994-47df-8b0d-290b01cdc9a9.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9f7d447-6994-47df-8b0d-290b01cdc9a9.png)'
- en: 'Here''s Christian laying down a railroad switch:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Christian铺设铁路开关的一个例子：
- en: '![](img/b1bf5814-eaad-48aa-a4bb-d26eb1397e7b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1bf5814-eaad-48aa-a4bb-d26eb1397e7b.png)'
- en: Composition in Mindcraft
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Mindcraft中的组合
- en: We can find the source code for this Immersive Railroad application at [https://github.com/cam72cam/ImmersiveRailroading](https://github.com/cam72cam/ImmersiveRailroading).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Minecraft could have chosen to implement their world building UI exclusively
    with FP techniques by currying partial applications, but when we look closer we
    find more of an imperative implementation. Though generics are used:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tacit programming
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tacit programming is a style of programming where function definitions compose
    other functions and combinators manipulate the arguments. A combinator is a higher-order
    function that uses only function application and pre-defined combinators to define
    the result from its arguments. For more details, see the Moses Schonfinkel section
    in [Chapter 11](../Text/Ch11.xhtml), *Category Theory That Applies*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Tacit programming with Unix pipes
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following combinators are the functions in the pipeline, for example, `head`,
    `awk`, `grep`, and so on. Each combinator is a function that sends output to standard
    out and reads input from standard in. Note that arguments are not mentioned  in
    the command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Programming CMOS with Unix pipes
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unix pipes can also be used to model the flow control of NAND gates of a CMOS
    device.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Assuming nil represents and electron then, `/dev/zero` (aka VSS) provides an
    infinite supply of electrons and `/dev/null` (aka VDD) will consume every electron
    sent to it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c08dd33-3219-4653-983f-451d32b33aae.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: CMOS NAND gate
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In our model, the UNIX pipe acts like a wire. When the pipe is connected to
    Vss, its buffer fills up with nil-bytes and the pipe acts like a negatively charged
    metal plate. When it is connected to Vdd, the pipe's buffer is drained, and the
    pipe acts like a positively charged metal plate. Unix pipes are used to model
    flow control in our NAND logic gate.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: For more details, see [http://www.linusakesson.net/programming/pipelogic/index.php](http://www.linusakesson.net/programming/pipelogic/index.php).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Tacit programming with FP
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We'll use Haskell to demonstrate  a program that sums a list of integers. Both
    will be recursive, the second benefits from **Tail Call Optimization** (**TCO**).
    We would use Go, but currently Go does not support TCO.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: We loop over the list of numbers to accumulate the sum. In imperative programming,
    we would use a loop index to store the accumulated sum value. In functional programming,
    we implement loops using recursion where the accumulated sum is passed as a parameter
    to the next recursive call. What would be loop index variables/accumulator variables
    in an imperative language become *parameters* in the tail-recursive version.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Non-TCO recursive example
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we''ll look at the imperative example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that x:xs means we store the head of the list in x and the rest of the
    list is in xs.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5312a5a-329b-447d-a3f9-04a86b194eca.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: Each call to `rSum` needs to get the return value of the recursive call and
    add it to its x parameter before it can return. This means that each function
    must stay on the stack longer than the frame of any function that it calls. We
    had to create four stack frames to sum three numbers. Imagine the amount of RAM
    storage that this implementation will require when we process lists with a lot
    of values. Without TCO the our implementation will require **O**(n) of RAM storage
    space, based on the number of items in the list. (See Big-Oh notation in [Chapter
    10](../Text/Ch10.xhtml), *Monads, Type Classes, and Generics*)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: TCO recursive example
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In our  tail recursive function, our stack frames do not need to be preserved.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following diagram illustrates that unlike the previous example (`rSum`), no
    action needs to be taken in the context of a frame after `tSum` makes its recursive
    call. `rSum` created a stack frame for each member of the list. `tSum` only needs
    to create one stack frame, which it reuses.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c37ebf-a4a8-44a3-9a9e-38acf240fe79.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: TCO avoids creating a new stack frame when the last call in a recursion is the
    function itself. Go currently does not support TCO. What is the implication? Without
    TCO, we should avoid using recursion to process lists with a lot of elements,
    that is, over a few thousand; Otherwise, our program will likely run out of RAM
    and crash. Why not replace recursive functions with functions that implement imperative
    loops? In other words, what is the importance of recursion in functional programming?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The importance of recursion
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let's make sure we understand what recursion is. Let's think about how
    we pull apart Russian Dolls.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f685a5c3-86ee-4fdf-8ae6-6e6afe872654.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Recursion works like the process of finding the smallest doll. We repeat the
    same process, i.e., pulling apart the doll until we find a doll that is solid.
    Though our problems get smaller, the problem solving process is the same as the
    previous because the structure of the nesting dolls is the same. Each doll is
    a smaller than the previous one. Eventually, we get to a doll that's too small
    to have a doll inside it and we're done. That's the fundamental idea behind recursion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We also need to understand how to to write a tail recursive function because
    that's the kind of recursion that's a candidate for TCO. When our recursive function
    that calls itself as its last action, then we can reuse the stack frame of that
    function. The tSum function in the previous section is an example of tail recursion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Understanding recursion marks a transition for us from a programmer to a computer
    scientist. Recursion requires some mathematical sophistication to understand,
    but once  we master it we'll find that it opens up a plethora of ways to solve
    important problems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: A soccer coach would not have his player practice kicking balls down hill to
    a target; that scenario will never occur in a game. Similarly, we will not spend
    a lot of time pursuing recursive implementations in Go.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: A tail recursive function is the functional form of a loop, and with TCO it
    executes just as efficiently as a loop. Without recursion, we must implement most
    loops using imperative programming techniques. Thus, having TCO in Go would actually
    be more beneficial to FP than Generics. We'll learn more about Generics in [Chapters
    9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics* and [Chapter 10](../Text/Ch10.xhtml),
    *Monads, Type Classes, and Generics*. See the *How to Propose Changes To Go * section
    in the Appendix or jump directly to the discussion regarding adding TCO to Go
    at [https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Various intermediate and terminal functions
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the various intermediate and terminal functions in the following functor
    diagram. They are all functors. When a function, for example, `Map`, is provided
    with a set of values as input, it will apply a transformation on the elements
    and produce output that will be a different set of values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, given the same input, a given function will always
    return the same result set.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699a2988-487c-40d7-98ba-e99bc371c96a.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: In the first row of preceding functors, `Map` and `Sort`, take a collection,
    transform it in some way, and return a collection of equal size.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In the second row of functors, `Filter` and `GroupBy`, take a collection and
    transform it into another collection of smaller size.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In the third row, `Reduce` takes a collection, performs computations over its
    elements, and returns a single result value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Reduce example
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an implementation for reducing a collection, using the `alediaferia/go-collections`
    package, to find the maximum value:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Join` function takes two different collections and combines them into a
    single, larger collection.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic types of functors in functional programming: intermediate
    functions and terminal functions. They work together to transform the incoming
    collection into either another collection or a single value. Any number of intermediate
    functions can be chained together followed by the terminal function.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中有两种基本类型的函子：中间函数和终端函数。它们一起工作，将传入的集合转换为另一个集合或单个值。任意数量的中间函数可以链接在一起，然后是终端函数。
- en: Intermediate functions
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中间函数
- en: Intermediate functions are not evaluated until the terminal function has been
    processed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 中间函数在终端函数被处理之前不会被评估。
- en: '**Lazy evaluation** is an evaluation strategy that delays the processing of
    an intermediate function until its value is required. It can be combined with
    **memoization**, where the evaluation is first cached so that subsequent requests
    for that value return the cached value immediately without reevaluating the expression
    that originally created it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**惰性评估**是一种延迟处理中间函数的评估策略，直到需要其值为止。它可以与**记忆化**结合使用，其中首先对评估进行缓存，以便对该值的后续请求立即返回缓存的值，而无需重新评估最初创建它的表达式。'
- en: A few of the more popular intermediate functions include `map`, `filter`, and `sort`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一些更流行的中间函数包括`map`、`filter`和`sort`。
- en: We can create many other high-order functions to process the incoming stream,
    which is often a collection. We'll soon see functional programming libraries that
    provide a plethora of variations of these basic function types.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建许多其他高阶函数来处理传入的流，通常是一个集合。我们很快将看到提供这些基本函数类型各种变体的函数式编程库。
- en: Common intermediate functions
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见的中间函数
- en: 'Here''s a table that describes some of the more common intermediate functions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个描述一些常见的中间函数的表格：
- en: '| **Function** | **Gleam** | **Preserves type** | **Preserves count** | **Preserves
    order** | **Description** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **Gleam** | **保留类型** | **保留计数** | **保留顺序** | **描述** |'
- en: '| `map` | Yes | No | Yes | Yes | This transforms each element in the list into
    another element in the resulting list of the same size. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 是 | 否 | 是 | 是 | 这将列表中的每个元素转换为结果列表中大小相同的另一个元素。 |'
- en: '| `filter` | Yes | Yes | No | Yes | This calls a predicate function. If true,
    the current item is skipped and does not end up in the result list. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 是 | 是 | 否 | 是 | 这调用一个谓词函数。如果为真，则当前项目将被跳过，不会出现在结果列表中。 |'
- en: '| `sort` | Yes | Yes | Yes | Yes | This orders the result set by a criteria.
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | 是 | 是 | 是 | 是 | 这按照标准对结果集进行排序。 |'
- en: Map Example
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 映射示例
- en: 'Here''s an example of mapping a collection using the `alediaferia/go-collections`
    package:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`alediaferia/go-collections`包对集合进行映射的示例：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Terminal functions
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 终端函数
- en: Terminal functions are eagerly executed. They execute immediately and once executed,
    they execute all the previous intermediate, lazy functions in the call chain.
    Terminal functions either return a single value or produce a side effect. The
    reduce example, we saw earlier, returns a single value: `1`. The `ForEach` function
    does not return a value but can produce a side effect, such as printing out each
    item. The `Collect`, `Join`, and `GroupBy` functions group items in a collection.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 终端函数会被急切地执行。它们立即执行，一旦执行，它们会执行调用链中的所有先前的中间、惰性函数。终端函数要么返回单个值，要么产生副作用。前面我们看到的reduce示例返回一个单个值：`1`。`ForEach`函数不返回值，但可以产生副作用，比如打印出每个项目。`Collect`、`Join`和`GroupBy`函数将集合中的项目分组。
- en: Common terminal functions
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见的终端函数
- en: 'Here''s a table that describes some of the more popular terminal functions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个描述一些更流行的终端函数的表格：
- en: '| **Function** | **Gleam** | **Groups items** | **Creates side effects** |
    **Gathers results** | **Description** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **Gleam** | **分组项目** | **创建副作用** | **收集结果** | **描述** |'
- en: '| `Collect`, `Join`, and `GroupBy` | Yes | Yes |  |  | Produce another collection
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `Collect`、`Join`和`GroupBy` | 是 | 是 |  |  | 产生另一个集合 |'
- en: '| `ForEach` | Yes |  | Yes |  | Used for processing individual items |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `ForEach` | 是 |  | 是 |  | 用于处理单个项目 |'
- en: '| `Reduce` | Yes |  |  | Yes | Forces the required lazy expressions to fire
    and produce results |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `Reduce` | 是 |  |  | 是 | 强制要求延迟表达式触发并产生结果 |'
- en: Join example
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Join示例
- en: 'The following code shows an example of the `Join()` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`Join()`函数的示例：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: GroupBy example
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GroupBy示例
- en: 'The following code shows an example of the `GroupBy()` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`GroupBy()`函数的示例：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Reduce example
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Reduce示例
- en: 'Here''s an implementation for reducing a collection, using the `alediaferia/go-collections`
    package, to find the maximum value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`alediaferia/go-collections`包来减少集合以找到最大值的实现：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Predicates
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词
- en: We can use predicates to perform operations on input data. Predicates can be
    used to implement many of the functions that we apply to collections to transform
    input data into the result collection or value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用谓词对输入数据执行操作。谓词可用于实现我们应用于集合以将输入数据转换为结果集合或值的许多函数。
- en: The `predicate` function is a function that takes one item as input and returns
    either true or false, based on whether the item satisfies some condition. They
    are often used conditionally to determine whether to apply certain operations
    in the execution chain.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`predicate`函数是一个接受一个项目作为输入并根据项目是否满足某些条件返回true或false的函数。它们通常被条件地使用，以确定是否在执行链中应用某些操作。'
- en: Let's create some predicate functions that we can use to manipulate a collection
    of cars.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些谓词函数，以便我们可以用来操作一组汽车。
- en: 'The `All()` function returns `true` only if all the values in the collection
    satisfy the `predicate` condition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`All()`函数仅在集合中的所有值都满足`predicate`条件时返回`true`：'
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Any()` function returns `true` as long as any one of the values in the
    collection satisfies the `predicate` condition:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any()`函数只要集合中的任何一个值满足`predicate`条件就返回`true`：'
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Filter()` function returns a new, smaller, or equal-sized collection containing
    all the strings in the collection that satisfy the `predicate` condition:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Count()` function is a helper function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let's use a Mocha-like BDD Go testing framework, named `goblin`, to test
    our predicates.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the package and define the basic imports. We only need to define one
    function. Let''s call it `TestPredicateSucceed`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s wrap all our unit tests with a `Describe` block named `Predicate Tests`,
    where we define the `cars` variable to hold a list of our car models:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here''s our first test. It starts with a `Describe` block and contains one
    `It` block. Inside our `It` block, we assign our first-class function `bs`, the
    return value of calling the `Any()` function. Our predicate function is the function
    literal that calls the `strings.HasPrefix()` function. The last line of our unit
    test asserts that `bs` is `true`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our next unit test says `Highlander should be High` and asserts that it should
    be true. We pass the `strings.Contains()` function as our predicate to the `Filter()`
    function to return only those items in the list that contain the `High` substring:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This test counts the number of cars that contain the `High` substring and asserts
    that the count should be 1:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our last test asserts that not all cars contain the `High` substring:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's take a moment to reflect on this implementation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our implementation of predicates is performant but restrictive. Take the `Any()`
    function signature, for example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `Any` function only works for slices of `string`. What if we wanted to iterate
    over a tree or map structure? We'd have to write separate functions for each.
    This is a valid argument for requesting Go to support generics. If Go supported
    generics, our implementations would likely require much less code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: An alternative implementation could be to use empty interfaces. This would solve
    the problem of having to implement separate functions for each type of data we
    want to handle, given that an empty interface can take on a value of any type.
    To use a value of the `interface{}` type, you must use reflection or type assertion
    or a type switch to determine the type of value, and there will be a performance
    hit for any of those methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative implementation could be to use Goroutines and channels.
    Itertools uses empty interfaces, Goroutines, and channels.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/ahl5esoft/golang-underscore` is a package that uses a lot of
    reflection and empty interfaces to provide an underscore-like implementation of
    high-order functions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Combinator pattern
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Go supports passing functions around as values, we can create predicate
    combinators to build more complex predicates from simpler ones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Combinator pattern**: Creating systems by combining more primitive functions
    into more complex functions.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We'll dive deeper into the composition and the combinator pattern later in the
    book. Now, let's look a little closer at the `map` and `filter` functions.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Map and filter
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next code example demonstrates the use of a few standard intermediate functions: `map`
    and `filter`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: The code in this example can be copy/pasted into The Go playground, which is
    a service that takes your Go program, compiles, links, and runs your program with
    the latest version of Go inside a sandbox and then returns the output to the screen.
    You can find it at [https://play.golang.org/](https://play.golang.org/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Executable commands must always use `package main`. We can separate each import
    statement on a separate line for readability.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'External packages can be referenced using their remote GitHub repository path.
    We can preface long package names with a shorter alias. The `go_utils` package
    can now be referenced with the `u` letter. Note that if we aliased a package name
    with `_`, its exported functions can be referenced directly in our Go code without
    indicating which package it came from:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`iota`: A Go identifier used in `const` declarations that represents successive
    untyped integer constants. It is reset to 0 whenever the reserved word `const`
    appears:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`const (`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '`   SMALL = iota // 0`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '`   MEDIUM // 1`'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`   LARGE // 2`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '`)`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: We can apply expressions to iota to set increment values greater than `1`. We
    do this as discussed in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a type of ints called `WordSize` and use an `iota` expression
    to create an enumeration from our constants. The first `iota` elements are assigned
    values that start at 0 and then increase by 1\. Since we multiplied the `iota` element
    by `6`, the sequence will look like `0`, `6`, `12`, `18`, and so on. We explicitly
    assign the value of `50` to the last element in the enumeration:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `ChainLink` type allows us to chain function/method calls. It also keeps
    data internal to `ChainLink`, avoiding the side effect of mutated data:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Value()` method will return the value of the referenced element or link
    in the chain:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s define `stringFunc` as a function type. This first-class method is used
    in the following code as a parameter to the `Map` function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `Map` function uses `stringFunc` to transform (up-case) each string in
    the slice:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This line is worth repeating:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We execute the `fn()` function parameter against each element in the slice.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Filter` function uses embedded logic to filter the slice of strings. We
    could have chosen to use a first-class function, but this implementation is faster:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What's wrong, from a pure FP perspective, about our filter function in the preceding
    code?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We are using an imperative loop
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are saving the filtered results to the `Data` field our `ChainLink` structure
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not use recursion? We discussed this earlier. The short version is that
    until Go gets TCO we need to avoid recursion if our list of elements we're processing
    could be over a few thousand elements.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Why are we storing the filtered data rather than returning it? Good question.
    This implementation of the filter function serves as a learning lesson. It shows
    us how we can chain functions in a non-pure FP way. We''ll look at an improved
    filter implementation in the next chapter. Here''s sneak peek:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's display our constants using a here-doc with interpolation. Note that the first
    argument to the `fmt.Printf` statement is our here-doc, `constants`, and the remaining
    arguments are interpolated in `constants`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output will be as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s initialize `ChainLink` with our slice of words:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output will be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s filter our list of words:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output will be as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, let''s apply the `ToUpper` mapping to our small-sized words:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will be as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s apply a `MEDIUM` filter and the `ToUpper` filter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output will be as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, let''s apply our `XLARGE` filter and map then `ToUpper`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output will be as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s apply our `XXLARGE` filter and map with `ToUpper`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will be as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output will be as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we use the `Join()` function to join the items in the list to help with
    formatting our output:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output will be as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s compare our original collection of words with the value that we
    passed through our chain of functions to see whether there were side effects:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what your terminal console should look like:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aed12031-9b10-4174-9691-0b8f3cc23347.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: Contains
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider another common collection operation: `contains`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In Go, lists of things are often stored in a slice. Wouldn't it be nice if Go
    provided a `contains` method to tell us whether the item we are looking for is
    contained in the slice? Since there is no generic `contains` method for working
    with lists of items in Go, let's implement one to iterate over a collection of
    car objects.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a collection of cars
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s create a `Car` struct that we can use to define the `Cars` collection
    as a slice of `Car`. Later, we''ll create a `Contains()` method to try out on
    our collection:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here''s our `Contains()` implementation. `Contains()` is a method for `Cars`.
    It takes a `modelName` string, for example, `Highlander`, and returns `true` if
    it was found in the slice of `Cars`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`Contains()`实现。`Contains()`是`Cars`的一个方法。它接受一个`modelName`字符串，例如`Highlander`，如果在`Cars`的切片中找到了它，就返回`true`：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This seems simple enough to implement, but what happens when we are given a
    list of boats or boxes to iterate over? That's right, we'll have to reimplement
    the `Contains()` method for each one. That's ugly!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎很容易实现，但是当我们得到一个要迭代的船只或箱子列表时会发生什么？没错，我们将不得不为每一个重新实现`Contains()`方法。这太丑陋了！
- en: This is yet another situation where it would be nice to have generics.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个情况，如果有泛型将会很好。
- en: The empty interface
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 空接口
- en: 'Another alternative would be to use the empty interface like so:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是这样使用空接口：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: However, reflection or typecasting would be required and that would again adversely
    affect the performance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将需要反射或类型转换，这将再次对性能产生不利影响。
- en: The Contains() method
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Contains()方法
- en: 'Now, let''s exercise our `Contains()` method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来使用我们的`Contains()`方法：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output will be as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In order to understand how to make the leap from imperative programming to functional
    programming, let's look at pure functional programming languages and how to implement
    high-order functions such as `Map()` that manipulate collections.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何从命令式编程转向函数式编程，让我们看看纯函数式编程语言以及如何实现`Map()`这样的高阶函数来操作集合。
- en: 'With pure functional types, you had a function, `f`, that takes a cube and
    returns a heart, as shown in the following diagram:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数类型，你有一个函数`f`，它接受一个立方体并返回一个心形，如下图所示：
- en: '![](img/ee48a5f5-1cf3-4611-9741-d2fcdee1e086.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee48a5f5-1cf3-4611-9741-d2fcdee1e086.png)'
- en: If you pass `f` a list of cubes, you could use `f` to return a list of hearts.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给`f`传递一个立方体列表，你可以使用`f`来返回一个心形列表。
- en: 'In order to implement this in Go, we can replace the cube with a string and
    the heart with a `bool` value:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Go语言中实现这一点，我们可以用一个字符串替换立方体，用一个`bool`值替换心形：
- en: '[PRE62]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'First, we define a map of vowels that we later test for a key without retrieving
    the value, using an underscore in place of the first value:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个元音字母的映射，然后测试一个不检索值的键，使用下划线代替第一个值：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We define `isVowel` to be a literal function that takes a string and returns
    a `bool` result. We define letters to be a slice of strings (`a`, `b`,... `e`)
    and then call our `Map` function, passing our `isVowel` function and the list
    of strings to check.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`isVowel`为一个取一个字符串并返回一个`bool`结果的文字函数。我们定义letters为一个字符串切片（`a`、`b`、... `e`），然后调用我们的`Map`函数，传递我们的`isVowel`函数和要检查的字符串列表。
- en: 'This works well, but the problem is that we would have to rewrite our logic
    for every data type that we want to use. If we want to check whether a specific
    rune character exists in a list of runes, we would have to write a new `Map` function.
    We would have to be concerned about things such as this: does `len()` work with
    runes like it works with strings? If not, we would have to replace this logic. This
    would include a lot of effort and code, which would perform similar operations
    and would not be good style.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有效，但问题是我们必须为每种数据类型重新编写我们的逻辑。如果我们想要检查一个特定的符文字符是否存在于符文列表中，我们将不得不编写一个新的`Map`函数。我们将不得不关心这样的事情：`len()`是否像它在字符串中那样与符文一起工作？如果不是，我们将不得不替换这个逻辑。这将包括大量的工作和代码，执行类似的操作，这不是一个好的风格。
- en: This is yet another example of why having generics in Go would be a delight.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子，说明了在Go语言中拥有泛型将是一种乐趣。
- en: If Go had generics
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果Go语言有泛型
- en: 'If Go had generics, we could have written a function signature like the following
    to replace strings with runes, and we would not have to rewrite the inner logic:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go语言有泛型，我们可以编写一个函数签名，用以下内容替换字符串中的符文，而不必重写内部逻辑：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: However, Go does not have generics, so we can use empty interfaces and reflection
    to achieve the same result.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Go语言没有泛型，所以我们可以使用空接口和反射来实现相同的结果。
- en: Map function
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Map函数
- en: Let's create a `Map` function to transform the contents of a Collection.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`Map`函数来转换集合的内容。
- en: 'First, let''s define `Object` to be the empty interface type and create a `Collection`
    type to be a slice of objects:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义`Object`为空接口类型，并创建一个`Collection`类型作为对象的切片：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `NewCollection` function creates a new instance of the collection with
    the given size:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewCollection`函数创建一个给定大小的集合的新实例：'
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `Callback` type is a first-class function type that returns the calculated
    result:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callback`类型是一个一流函数类型，返回计算结果：'
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `Map` function returns a new collection where every element is the result
    of calling the `Callback` function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`函数返回一个新的集合，其中每个元素都是调用`Callback`函数的结果。'
- en: Testing our empty interface-based Map function
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们基于空接口的`Map`函数
- en: 'We''ll test our new empty interface-based `Map` function by defining a transformation
    function. This function will multiply every item in the collection by 10:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过定义一个变换函数来测试我们的新的基于空接口的`Map`函数。这个函数将把集合中的每个项目乘以10：
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We pass a collection of the numbers `1`, `2`, `3`, and `4` as well as the transformation
    function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了数字`1`、`2`、`3`和`4`的集合以及变换函数。
- en: 'The output will be as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, let''s pass our `Map` function a collection of strings:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把我们的`Map`函数传递给一个字符串集合：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This time we pass a collection of strings and transform each by calling `ToUpper`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们传递了一个字符串集合，并通过调用`ToUpper`来转换每个字符串。
- en: 'Here''s the output:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice how in each case, we had to cast each `curVal`? With `transformation10`,
    we can cast each item in the collection to an `int` variable; with `transformationUpper`,
    we can cast each item to a `string` variable. We could choose to use reflection
    to avoid explicit casting, but that is even worse for performance than casting.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在每种情况下，我们都必须转换每个`curVal`？使用`transformation10`，我们可以将集合中的每个项目转换为一个`int`变量；使用`transformationUpper`，我们可以将每个项目转换为一个`string`变量。我们可以选择使用反射来避免显式转换，但这对性能来说甚至更糟。
- en: As with our earlier example, we could pass the collection to a chain of transformation
    functions to arrive at the result, which could be another collection or a single
    terminal value.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Instead of reinventing the wheel each time, we need another high-order function;
    let's use any one of the number of Go packages available that easily enable the
    functional style of programming in Go.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Itertools
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Itertools is a Go package that provides many of the same high-order functions
    from the Python standard library.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the different types of high-order functions provided by Itertools.
    High-order functions provide the vocabulary for the declarative coding style.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Infinite iterator creators:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`Count(i)`: Infinite count from `i`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cycle(iter)`: Infinite cycling of `iter` (requires memory)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repeat(element [, n])`: Repeat the element `n` times (or infinitely)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterator destroyers:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '`Reduce(iter, reducer, memo)`: Reduce (or Foldl) across the iterator'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List(iter)`: Create a list from the iterator'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterator modifiers:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '`Chain(iters...)`: Chain together multiple iterators.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DropWhile(predicate, iter)`: Drop elements until predicate(el) == false.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeWhile(predicate, iter)`: Take elements until predicate(el) == false.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Filter(predicate, iter)`: Filter out elements when predicate(el) == false.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FilterFalse(predicate, iter)`: Filter out elements when predicate(el) == true.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slice(iter, start[, stop[, step]])`: Drop elements until the start (zero-based
    index). Stop upon stop (exclusive) unless not given. Step is 1 unless given.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More iterator modifiers:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '`Map(mapper func(interface{}) interface{}, iter)`: Map each element to mapper(el).'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiMap(multiMapper func(interface{}...)interface{}, iters...)`: Map all
    the iterators as variadic arguments to `multiMaper(elements...)`; stop at the
    shortest iterator.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiMapLongest(multiMapper func(interface{}...)interface{}, iters...)`: Same
    as `MultiMap`, except that here you need to stop at the longest iterator. Shorter
    iterators are filled with nil after they are exhausted.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Starmap(multiMapper func(interface{}...)interface{}, iter)`: If `iter` is
    an iterator of `[]interface{}`, then expand it to `multiMapper`.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zip(iters...)`: Zip multiple iterators together.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZipLongest(iters...)`: Zip multiple iterators together. Take the longest;
    shorter ones are appended with nil.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tee(iter, n)`: Split an iterator into n equal versions.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tee2(iter)`: Split an iterator into two equal versions.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go channels used by the New function
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `itertools.go` file, we see that the iterator uses Go channels to range
    over each element in the collection:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `New` function can be used as follows to take a list of values and turn
    it into a new iterable collection:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Testing itertool's Map function
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s test itertool''s `Map` function by passing it a collection of words of
    various lengths and a literal function to operate on each word to return its length:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let's not forget to run `go get -u github.com/yanatan16/itertools` to download
    the `itertools` package along with its dependencies.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Testing iterators for element equality
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s create the `testIterEq` function to test whether two collections
    are equivalent:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In our test function `TestMap`, we define a `mapper` function literal that
    is passed to our `Map` function to perform the transformation. The `mapper` function
    returns the length of each string passed to it:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s go to the directory with this test file and run the following to verify
    that the `Map` function works as we expect. Here''s what my console output looks
    like:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Functional  packages
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many other Go packages that provide the high-order functions (HOF)
    that we've come to expect when writing declarative code for manipulating collections.
    They typically use empty interfaces and reflection, which have negative performance
    impacts. A well known HOF implementation is  Rob Pike's `Reduce` package (see [https://github.com/robpike/filter](https://github.com/robpike/filter))
    where he states his preference for using for loops and clearly states, *don't
    use this*.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Another time of reflection
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are we frustrated yet? We learned how to code in a concise, declarative functional
    programming style only to learn that it would probably run too slow to be viable
    in production. We tried various techniques to speed it up, but nothing we've done
    thus far with pure functional programming can match the performance of old-school
    imperative programming.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to find a way to program using the declarative functional programming
    style in Go with performance numbers that meet or exceed expectations.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Go is awesome
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go is our favorite language for many reasons including:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast and easy deployment
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform support
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected source code
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent processing
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go is awesome, but
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Go was not designed to be a pure functional language and lacks generics,
    we must take a performance hit to force Go into a functional style of programming,
    right? (Keep the faith! There's hope around the corner.)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the core principles of implementing and using collections. You
    learned that in functional programming, a single function can take input and return
    a result and transformations to the collection that occurs inside the function.
    You learned that we can compose functions by chaining them together.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: If Go had generics that would simplify our implementation task, but more importantly,
    if Go were designed to perform **tail-call optimization** (**TCO**) and other
    performance-boosting optimizations, then it would be an easy decision to choose
    to program in the functional style in Go.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: One of Go's best features is its performance, and if we are developing a solution
    that runs on a single server and performance is more important to us than having
    concise, intuitive, and declarative code, then most likely we would not program
    Go in the functional style.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: The cure
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, if we are looking to implement a distributed computing solution using
    Go, then we're in luck.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the features of a new Go package for performing distributed
    **MapReduce** for data processing at scale.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Gleam - distributed MapReduce for Golang
  id: totrans-377
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"First, generics are needed. Of course, we can use reflection. But it is noticeably
    slower, to the point that I do not want to show the performance numbers. Second,
    dynamic remote code execution is also needed if we want to dynamically adjust
    the execution plan. We could pre-build all the execution DAGs first and choose
    one of them during runtime. But it is very limiting. As everyone else here, I
    enjoyed the beauty of Go. How to make it work for big data?"'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '- Chris Lu'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: That's the right question.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Chris resolved the performance issues of reflection and the lack of Generics
    using a scripting language named LuaJIT. Rather than building the entire **directed
    acyclic graph** (**DAG**) and then choosing one branch during runtime, the scripting
    nature of LuaJIT allows dynamic remote code execution, allowing us to dynamically
    adjust the execution plan during runtime.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: LuaJIT's FFI library
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'LuaJIT''s FFI library makes it easy to call C functions and C data structures
    by parsing C declarations:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Call the named C function. Simple!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Unix pipe tools
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gleam also leverages Unix pipe tools.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Gleam = Go + LuaJIT + Unix Pipes
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can use Gleam to process collections.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Processing Gleam collections
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how Gleam processes collections. The input we''ll use is a collection
    of lines that comprises words in the `/etc/paths` file:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Gleam reads the file content as lines and feeds each line into the flow. From
    this, it creates the stream through which the functions `Map` and `Reduce` are
    called to count the number of occurrences of each word:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s the output of this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Disappointed? Were you hoping that there was a practical use of pure functional
    programming in pure Go? (Where practical means the performance of using recursion
    is not an issue and where you can write your business logic and control flow logic
    in a declarative style, free from empty interfaces, downcasting/unboxing and those
    noisy if err != nil blocks?) Keep working through the book and you'll find a solution
    in the last unit.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We manipulate collections constantly in our code. We often start with a list
    of items and need to transform our initial list into another list of different
    items. Sometimes, we want to map our list to another list of equal size. Sometimes,
    we want to group and sort our list. Other times, we need to arrive at a single
    result value.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the different types (intermediate and terminal)
    of collection functors. We dived into a few key areas of collection manipulation,
    including iterators, the `map` function, the `contains` method, and chaining of
    functions.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: We looked at a few Go packages that provide a cadre of high-order functions
    that we can use in our new functional style of programming.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: We gained an appreciation for Unix pipes and discovered that a new distributed
    processing Go package, named Gleam, leverages pipe to deliver a lightweight Go-based functional
    solution.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive deeper into pipelining and see how it can improve
    performance.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
