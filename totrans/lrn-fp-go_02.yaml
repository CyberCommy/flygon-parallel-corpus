- en: Manipulating Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling lists of items is a common occurrence in life as well as in programming
    languages. When a list has associated functions that help us manipulate the items
    in the list, we often call that object a collection.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how high-order functions can be used to greatly
    simplify the task of manipulating collections. We'll see how we can code using functional
    programming techniques and open source functional packages to create elegant solutions
    that are not only insightful, but also performant in today's distributed processing
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate through a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about intermediate and terminal functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use predicates to filter items in a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test using a Mocha-like BDD library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on Map functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grasp the breadth of the collection-manipulating functions in Itertools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage routines and channels to iterate through a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how we can use Go to process big data collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through a collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to implement a collection, we must provide a way to access each element
    in the collection, which can be accomplished using the int index value shown in
    the following code. We will implement a **first in, first out** (**FIFO**) order
    queue. We will provide a way to store the elements using a slice data structure.
    Lastly, we will implement a `Next()` method to provide a way to traverse the elements
    in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we define an interface for the `Iterator` object. It
    has one method, `Next()`, which will return the next element in the collection
    and a Boolean flag to indicate whether it''s OK to continue iterating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a collection object that has two properties: an `int` index
    used to access the current element and a slice of strings, that is, the actual
    data in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we implement the collection''s `Next()` method to meet the `IntIterator`
    interface''s specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newSlice` function is the constructor for the iterable collection `intCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we implement the `main()` function to test our `Collection`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up a terminal window and use the `.init` toolset to run our simple
    Go application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a83d65f5-90c5-4260-b7dc-78042af5eb3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The `. init` ("Dot Init") toolset ensures that we have Go installed and that
    our `GOPATH` and `GOBIN` directories are properly configured. First, we source
    the init script by typing `.init`. Since we have no import statements, there is
    no need to run glide-update. To run our application, we type `go-run`. For more
    details about Dot Init, see the [Appendix](https://cdp.packtpub.com/learning_functional_programming_in_go/wp-admin/post.php?post=99&action=edit#post_7),
    *Miscellaneous Information and How-Tos*.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this implementation is that we are mixing what we want to do
    with how we do it. We implement an explicit `for` loop to perform the mechanics
    of the iteration. We define and mutate the value of the index value in order to
    traverse the elements. We can immediately see that this is an imperative implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, we declare what to, rather than imperatively implementing
    each detail of each operation. We also avoid the sequential nature of `for` loops,
    which are difficult to fit into a concurrent programming model.
  prefs: []
  type: TYPE_NORMAL
- en: Go is not a functional programming language, but it has a lot of functional
    features and we can leverage those features to write concise, expressive, and
    hopefully, bug-free code.
  prefs: []
  type: TYPE_NORMAL
- en: A pure functional language does not maintain a state. Function calls are often
    chained, where input is passed from function to function. Each function call transforms
    its input in some way. These functions do not need to be concerned about the external
    state and do not produce side effects. Each function call can be very efficient
    at what it does. This style of programming lends itself to efficient testing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how function chaining is a lot like piping output through Bash
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Piping Bash commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Executing a composition or chain of functions is very much like executing a
    series of Bash commands, where the output from one command is piped into the next
    command. For example, we might cat an input a file that contains a list of timestamps
    and IP addresses in an `awk` command. The `awk` command removes all but the seventh
    column. Next, we sort the list in descending order, and finally, we group that
    data by unique IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following Bash command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give this command the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a very common pattern in functional programming. We often input a collection
    of data to a function, or chain of function calls, and get a result that has been
    transformed in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Collections are used frequently. When we implement them in a concise manner,
    chaining function calls that explicitly declare what we want to accomplish, we
    greatly reduce code ceremony. The result is that our code is more expressive,
    concise, and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go has three predeclared/raw data types: `bool`, `string`, numeric (`float`,
    `int64`, and so on). Other data types in Go require type declarations, that is,
    they require we use the `type` keyword. Functions fall in the later category of
    data types along with array, struct, pointer, interface, slice, map, and channel
    types. In Go, functions are first-class data types, which means that can be passed
    around as parameters and returned as values. Functions that can take functions
    as arguments and return functions are called high-order functions.'
  prefs: []
  type: TYPE_NORMAL
- en: We can write function factories--functions that return functions--and even function
    factory factories. We can also write functions that modify functions or create
    functions for specific purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functors**: A functor is a collection of `X` variables that can apply a function,
    `f`, over itself to create a collection of `Y`, that is, `f (X) → Y`. (To see
    what we''re talking about here, take a quick look at the *Fingers times 10 functor*
    example in [Chapter 9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics*)'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Prolog software language defines a functor to simply be a function.
    The preceding definition comes from the *Category Theory* influence on functional
    programming. (For more details, see [Chapter 11](../Text/Ch11.xhtml), *Category
    Theory That Applies*.)
  prefs: []
  type: TYPE_NORMAL
- en: Functions that modify functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we explore intermediate and terminal functions lets' clarify the phrase
    *functions that modify functions* using a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: A coding example of functions that modify functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is a snippet of the code we might write to build a section of
    a page with two drop down lists, one for makes and the other for models of cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that each http.Get is a separate API call. Each API call is a partial
    application. In order for renderPage to wait for each call to complete we must
    curry our API calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the resulting HTML might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/108dc35b-5d2a-48a3-a59f-1dbe93e674d5.png)'
  prefs: []
  type: TYPE_IMG
- en: A visual example of functions that modify functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous example we composed part of an HTML web page. In this example,
    let's immerse ourselves into a Railroading world and lay down some train tracks
    using function composition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f10db22-6848-4ac4-b2cc-7b6edc8ff6e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Immersive Railroading World
  prefs: []
  type: TYPE_NORMAL
- en: The following is our toolbox of reusable components. We modify our world by
    adding items from our toolbox. Thus, our immersive railroading *world* function
    is modified by adding and connecting a bunch of smaller *component* functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9f7d447-6994-47df-8b0d-290b01cdc9a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s Christian laying down a railroad switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1bf5814-eaad-48aa-a4bb-d26eb1397e7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Composition in Mindcraft
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can find the source code for this Immersive Railroad application at [https://github.com/cam72cam/ImmersiveRailroading](https://github.com/cam72cam/ImmersiveRailroading).
  prefs: []
  type: TYPE_NORMAL
- en: 'Minecraft could have chosen to implement their world building UI exclusively
    with FP techniques by currying partial applications, but when we look closer we
    find more of an imperative implementation. Though generics are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tacit programming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tacit programming is a style of programming where function definitions compose
    other functions and combinators manipulate the arguments. A combinator is a higher-order
    function that uses only function application and pre-defined combinators to define
    the result from its arguments. For more details, see the Moses Schonfinkel section
    in [Chapter 11](../Text/Ch11.xhtml), *Category Theory That Applies*.
  prefs: []
  type: TYPE_NORMAL
- en: Tacit programming with Unix pipes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following combinators are the functions in the pipeline, for example, `head`,
    `awk`, `grep`, and so on. Each combinator is a function that sends output to standard
    out and reads input from standard in. Note that arguments are not mentioned  in
    the command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Programming CMOS with Unix pipes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unix pipes can also be used to model the flow control of NAND gates of a CMOS
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming nil represents and electron then, `/dev/zero` (aka VSS) provides an
    infinite supply of electrons and `/dev/null` (aka VDD) will consume every electron
    sent to it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c08dd33-3219-4653-983f-451d32b33aae.png)'
  prefs: []
  type: TYPE_IMG
- en: CMOS NAND gate
  prefs: []
  type: TYPE_NORMAL
- en: In our model, the UNIX pipe acts like a wire. When the pipe is connected to
    Vss, its buffer fills up with nil-bytes and the pipe acts like a negatively charged
    metal plate. When it is connected to Vdd, the pipe's buffer is drained, and the
    pipe acts like a positively charged metal plate. Unix pipes are used to model
    flow control in our NAND logic gate.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, see [http://www.linusakesson.net/programming/pipelogic/index.php](http://www.linusakesson.net/programming/pipelogic/index.php).
  prefs: []
  type: TYPE_NORMAL
- en: Tacit programming with FP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We'll use Haskell to demonstrate  a program that sums a list of integers. Both
    will be recursive, the second benefits from **Tail Call Optimization** (**TCO**).
    We would use Go, but currently Go does not support TCO.
  prefs: []
  type: TYPE_NORMAL
- en: We loop over the list of numbers to accumulate the sum. In imperative programming,
    we would use a loop index to store the accumulated sum value. In functional programming,
    we implement loops using recursion where the accumulated sum is passed as a parameter
    to the next recursive call. What would be loop index variables/accumulator variables
    in an imperative language become *parameters* in the tail-recursive version.
  prefs: []
  type: TYPE_NORMAL
- en: Non-TCO recursive example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we''ll look at the imperative example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that x:xs means we store the head of the list in x and the rest of the
    list is in xs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5312a5a-329b-447d-a3f9-04a86b194eca.png)'
  prefs: []
  type: TYPE_IMG
- en: Each call to `rSum` needs to get the return value of the recursive call and
    add it to its x parameter before it can return. This means that each function
    must stay on the stack longer than the frame of any function that it calls. We
    had to create four stack frames to sum three numbers. Imagine the amount of RAM
    storage that this implementation will require when we process lists with a lot
    of values. Without TCO the our implementation will require **O**(n) of RAM storage
    space, based on the number of items in the list. (See Big-Oh notation in [Chapter
    10](../Text/Ch10.xhtml), *Monads, Type Classes, and Generics*)
  prefs: []
  type: TYPE_NORMAL
- en: TCO recursive example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In our  tail recursive function, our stack frames do not need to be preserved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The following diagram illustrates that unlike the previous example (`rSum`), no
    action needs to be taken in the context of a frame after `tSum` makes its recursive
    call. `rSum` created a stack frame for each member of the list. `tSum` only needs
    to create one stack frame, which it reuses.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17c37ebf-a4a8-44a3-9a9e-38acf240fe79.png)'
  prefs: []
  type: TYPE_IMG
- en: TCO avoids creating a new stack frame when the last call in a recursion is the
    function itself. Go currently does not support TCO. What is the implication? Without
    TCO, we should avoid using recursion to process lists with a lot of elements,
    that is, over a few thousand; Otherwise, our program will likely run out of RAM
    and crash. Why not replace recursive functions with functions that implement imperative
    loops? In other words, what is the importance of recursion in functional programming?
  prefs: []
  type: TYPE_NORMAL
- en: The importance of recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let's make sure we understand what recursion is. Let's think about how
    we pull apart Russian Dolls.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f685a5c3-86ee-4fdf-8ae6-6e6afe872654.png)'
  prefs: []
  type: TYPE_IMG
- en: Recursion works like the process of finding the smallest doll. We repeat the
    same process, i.e., pulling apart the doll until we find a doll that is solid.
    Though our problems get smaller, the problem solving process is the same as the
    previous because the structure of the nesting dolls is the same. Each doll is
    a smaller than the previous one. Eventually, we get to a doll that's too small
    to have a doll inside it and we're done. That's the fundamental idea behind recursion.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to understand how to to write a tail recursive function because
    that's the kind of recursion that's a candidate for TCO. When our recursive function
    that calls itself as its last action, then we can reuse the stack frame of that
    function. The tSum function in the previous section is an example of tail recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding recursion marks a transition for us from a programmer to a computer
    scientist. Recursion requires some mathematical sophistication to understand,
    but once  we master it we'll find that it opens up a plethora of ways to solve
    important problems.
  prefs: []
  type: TYPE_NORMAL
- en: A soccer coach would not have his player practice kicking balls down hill to
    a target; that scenario will never occur in a game. Similarly, we will not spend
    a lot of time pursuing recursive implementations in Go.
  prefs: []
  type: TYPE_NORMAL
- en: A tail recursive function is the functional form of a loop, and with TCO it
    executes just as efficiently as a loop. Without recursion, we must implement most
    loops using imperative programming techniques. Thus, having TCO in Go would actually
    be more beneficial to FP than Generics. We'll learn more about Generics in [Chapters
    9](../Text/Ch09.xhtml), *Functors, Monoids, and Generics* and [Chapter 10](../Text/Ch10.xhtml),
    *Monads, Type Classes, and Generics*. See the *How to Propose Changes To Go * section
    in the Appendix or jump directly to the discussion regarding adding TCO to Go
    at [https://github.com/golang/go/issues/22624](https://github.com/golang/go/issues/22624).
  prefs: []
  type: TYPE_NORMAL
- en: Various intermediate and terminal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the various intermediate and terminal functions in the following functor
    diagram. They are all functors. When a function, for example, `Map`, is provided
    with a set of values as input, it will apply a transformation on the elements
    and produce output that will be a different set of values.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, given the same input, a given function will always
    return the same result set.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/699a2988-487c-40d7-98ba-e99bc371c96a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the first row of preceding functors, `Map` and `Sort`, take a collection,
    transform it in some way, and return a collection of equal size.
  prefs: []
  type: TYPE_NORMAL
- en: In the second row of functors, `Filter` and `GroupBy`, take a collection and
    transform it into another collection of smaller size.
  prefs: []
  type: TYPE_NORMAL
- en: In the third row, `Reduce` takes a collection, performs computations over its
    elements, and returns a single result value.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an implementation for reducing a collection, using the `alediaferia/go-collections`
    package, to find the maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Join` function takes two different collections and combines them into a
    single, larger collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic types of functors in functional programming: intermediate
    functions and terminal functions. They work together to transform the incoming
    collection into either another collection or a single value. Any number of intermediate
    functions can be chained together followed by the terminal function.'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Intermediate functions are not evaluated until the terminal function has been
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy evaluation** is an evaluation strategy that delays the processing of
    an intermediate function until its value is required. It can be combined with
    **memoization**, where the evaluation is first cached so that subsequent requests
    for that value return the cached value immediately without reevaluating the expression
    that originally created it.'
  prefs: []
  type: TYPE_NORMAL
- en: A few of the more popular intermediate functions include `map`, `filter`, and `sort`.
  prefs: []
  type: TYPE_NORMAL
- en: We can create many other high-order functions to process the incoming stream,
    which is often a collection. We'll soon see functional programming libraries that
    provide a plethora of variations of these basic function types.
  prefs: []
  type: TYPE_NORMAL
- en: Common intermediate functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''s a table that describes some of the more common intermediate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Gleam** | **Preserves type** | **Preserves count** | **Preserves
    order** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `map` | Yes | No | Yes | Yes | This transforms each element in the list into
    another element in the resulting list of the same size. |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | Yes | Yes | No | Yes | This calls a predicate function. If true,
    the current item is skipped and does not end up in the result list. |'
  prefs: []
  type: TYPE_TB
- en: '| `sort` | Yes | Yes | Yes | Yes | This orders the result set by a criteria.
    |'
  prefs: []
  type: TYPE_TB
- en: Map Example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here''s an example of mapping a collection using the `alediaferia/go-collections`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Terminal functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Terminal functions are eagerly executed. They execute immediately and once executed,
    they execute all the previous intermediate, lazy functions in the call chain.
    Terminal functions either return a single value or produce a side effect. The
    reduce example, we saw earlier, returns a single value: `1`. The `ForEach` function
    does not return a value but can produce a side effect, such as printing out each
    item. The `Collect`, `Join`, and `GroupBy` functions group items in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Common terminal functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''s a table that describes some of the more popular terminal functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Gleam** | **Groups items** | **Creates side effects** |
    **Gathers results** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Collect`, `Join`, and `GroupBy` | Yes | Yes |  |  | Produce another collection
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ForEach` | Yes |  | Yes |  | Used for processing individual items |'
  prefs: []
  type: TYPE_TB
- en: '| `Reduce` | Yes |  |  | Yes | Forces the required lazy expressions to fire
    and produce results |'
  prefs: []
  type: TYPE_TB
- en: Join example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code shows an example of the `Join()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: GroupBy example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The following code shows an example of the `GroupBy()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Reduce example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Here''s an implementation for reducing a collection, using the `alediaferia/go-collections`
    package, to find the maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use predicates to perform operations on input data. Predicates can be
    used to implement many of the functions that we apply to collections to transform
    input data into the result collection or value.
  prefs: []
  type: TYPE_NORMAL
- en: The `predicate` function is a function that takes one item as input and returns
    either true or false, based on whether the item satisfies some condition. They
    are often used conditionally to determine whether to apply certain operations
    in the execution chain.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create some predicate functions that we can use to manipulate a collection
    of cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `All()` function returns `true` only if all the values in the collection
    satisfy the `predicate` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Any()` function returns `true` as long as any one of the values in the
    collection satisfies the `predicate` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Filter()` function returns a new, smaller, or equal-sized collection containing
    all the strings in the collection that satisfy the `predicate` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Count()` function is a helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's use a Mocha-like BDD Go testing framework, named `goblin`, to test
    our predicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the package and define the basic imports. We only need to define one
    function. Let''s call it `TestPredicateSucceed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wrap all our unit tests with a `Describe` block named `Predicate Tests`,
    where we define the `cars` variable to hold a list of our car models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our first test. It starts with a `Describe` block and contains one
    `It` block. Inside our `It` block, we assign our first-class function `bs`, the
    return value of calling the `Any()` function. Our predicate function is the function
    literal that calls the `strings.HasPrefix()` function. The last line of our unit
    test asserts that `bs` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next unit test says `Highlander should be High` and asserts that it should
    be true. We pass the `strings.Contains()` function as our predicate to the `Filter()`
    function to return only those items in the list that contain the `High` substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This test counts the number of cars that contain the `High` substring and asserts
    that the count should be 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last test asserts that not all cars contain the `High` substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a moment to reflect on this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our implementation of predicates is performant but restrictive. Take the `Any()`
    function signature, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `Any` function only works for slices of `string`. What if we wanted to iterate
    over a tree or map structure? We'd have to write separate functions for each.
    This is a valid argument for requesting Go to support generics. If Go supported
    generics, our implementations would likely require much less code.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative implementation could be to use empty interfaces. This would solve
    the problem of having to implement separate functions for each type of data we
    want to handle, given that an empty interface can take on a value of any type.
    To use a value of the `interface{}` type, you must use reflection or type assertion
    or a type switch to determine the type of value, and there will be a performance
    hit for any of those methods.
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative implementation could be to use Goroutines and channels.
    Itertools uses empty interfaces, Goroutines, and channels.
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/ahl5esoft/golang-underscore` is a package that uses a lot of
    reflection and empty interfaces to provide an underscore-like implementation of
    high-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Combinator pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Go supports passing functions around as values, we can create predicate
    combinators to build more complex predicates from simpler ones.
  prefs: []
  type: TYPE_NORMAL
- en: '**Combinator pattern**: Creating systems by combining more primitive functions
    into more complex functions.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll dive deeper into the composition and the combinator pattern later in the
    book. Now, let's look a little closer at the `map` and `filter` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Map and filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next code example demonstrates the use of a few standard intermediate functions: `map`
    and `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: The code in this example can be copy/pasted into The Go playground, which is
    a service that takes your Go program, compiles, links, and runs your program with
    the latest version of Go inside a sandbox and then returns the output to the screen.
    You can find it at [https://play.golang.org/](https://play.golang.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Executable commands must always use `package main`. We can separate each import
    statement on a separate line for readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'External packages can be referenced using their remote GitHub repository path.
    We can preface long package names with a shorter alias. The `go_utils` package
    can now be referenced with the `u` letter. Note that if we aliased a package name
    with `_`, its exported functions can be referenced directly in our Go code without
    indicating which package it came from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`iota`: A Go identifier used in `const` declarations that represents successive
    untyped integer constants. It is reset to 0 whenever the reserved word `const`
    appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const (`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   SMALL = iota // 0`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   MEDIUM // 1`'
  prefs: []
  type: TYPE_NORMAL
- en: '`   LARGE // 2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`)`'
  prefs: []
  type: TYPE_NORMAL
- en: We can apply expressions to iota to set increment values greater than `1`. We
    do this as discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a type of ints called `WordSize` and use an `iota` expression
    to create an enumeration from our constants. The first `iota` elements are assigned
    values that start at 0 and then increase by 1\. Since we multiplied the `iota` element
    by `6`, the sequence will look like `0`, `6`, `12`, `18`, and so on. We explicitly
    assign the value of `50` to the last element in the enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChainLink` type allows us to chain function/method calls. It also keeps
    data internal to `ChainLink`, avoiding the side effect of mutated data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Value()` method will return the value of the referenced element or link
    in the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define `stringFunc` as a function type. This first-class method is used
    in the following code as a parameter to the `Map` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Map` function uses `stringFunc` to transform (up-case) each string in
    the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is worth repeating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We execute the `fn()` function parameter against each element in the slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Filter` function uses embedded logic to filter the slice of strings. We
    could have chosen to use a first-class function, but this implementation is faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: What's wrong, from a pure FP perspective, about our filter function in the preceding
    code?
  prefs: []
  type: TYPE_NORMAL
- en: We are using an imperative loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are saving the filtered results to the `Data` field our `ChainLink` structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not use recursion? We discussed this earlier. The short version is that
    until Go gets TCO we need to avoid recursion if our list of elements we're processing
    could be over a few thousand elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why are we storing the filtered data rather than returning it? Good question.
    This implementation of the filter function serves as a learning lesson. It shows
    us how we can chain functions in a non-pure FP way. We''ll look at an improved
    filter implementation in the next chapter. Here''s sneak peek:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let's display our constants using a here-doc with interpolation. Note that the first
    argument to the `fmt.Printf` statement is our here-doc, `constants`, and the remaining
    arguments are interpolated in `constants`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s initialize `ChainLink` with our slice of words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s filter our list of words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s apply the `ToUpper` mapping to our small-sized words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s apply a `MEDIUM` filter and the `ToUpper` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s apply our `XLARGE` filter and map then `ToUpper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s apply our `XXLARGE` filter and map with `ToUpper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `Join()` function to join the items in the list to help with
    formatting our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s compare our original collection of words with the value that we
    passed through our chain of functions to see whether there were side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what your terminal console should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aed12031-9b10-4174-9691-0b8f3cc23347.png)'
  prefs: []
  type: TYPE_IMG
- en: Contains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider another common collection operation: `contains`.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, lists of things are often stored in a slice. Wouldn't it be nice if Go
    provided a `contains` method to tell us whether the item we are looking for is
    contained in the slice? Since there is no generic `contains` method for working
    with lists of items in Go, let's implement one to iterate over a collection of
    car objects.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a collection of cars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s create a `Car` struct that we can use to define the `Cars` collection
    as a slice of `Car`. Later, we''ll create a `Contains()` method to try out on
    our collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our `Contains()` implementation. `Contains()` is a method for `Cars`.
    It takes a `modelName` string, for example, `Highlander`, and returns `true` if
    it was found in the slice of `Cars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This seems simple enough to implement, but what happens when we are given a
    list of boats or boxes to iterate over? That's right, we'll have to reimplement
    the `Contains()` method for each one. That's ugly!
  prefs: []
  type: TYPE_NORMAL
- en: This is yet another situation where it would be nice to have generics.
  prefs: []
  type: TYPE_NORMAL
- en: The empty interface
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another alternative would be to use the empty interface like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: However, reflection or typecasting would be required and that would again adversely
    affect the performance.
  prefs: []
  type: TYPE_NORMAL
- en: The Contains() method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s exercise our `Contains()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In order to understand how to make the leap from imperative programming to functional
    programming, let's look at pure functional programming languages and how to implement
    high-order functions such as `Map()` that manipulate collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'With pure functional types, you had a function, `f`, that takes a cube and
    returns a heart, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee48a5f5-1cf3-4611-9741-d2fcdee1e086.png)'
  prefs: []
  type: TYPE_IMG
- en: If you pass `f` a list of cubes, you could use `f` to return a list of hearts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement this in Go, we can replace the cube with a string and
    the heart with a `bool` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define a map of vowels that we later test for a key without retrieving
    the value, using an underscore in place of the first value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We define `isVowel` to be a literal function that takes a string and returns
    a `bool` result. We define letters to be a slice of strings (`a`, `b`,... `e`)
    and then call our `Map` function, passing our `isVowel` function and the list
    of strings to check.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works well, but the problem is that we would have to rewrite our logic
    for every data type that we want to use. If we want to check whether a specific
    rune character exists in a list of runes, we would have to write a new `Map` function.
    We would have to be concerned about things such as this: does `len()` work with
    runes like it works with strings? If not, we would have to replace this logic. This
    would include a lot of effort and code, which would perform similar operations
    and would not be good style.'
  prefs: []
  type: TYPE_NORMAL
- en: This is yet another example of why having generics in Go would be a delight.
  prefs: []
  type: TYPE_NORMAL
- en: If Go had generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If Go had generics, we could have written a function signature like the following
    to replace strings with runes, and we would not have to rewrite the inner logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: However, Go does not have generics, so we can use empty interfaces and reflection
    to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Map function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's create a `Map` function to transform the contents of a Collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define `Object` to be the empty interface type and create a `Collection`
    type to be a slice of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NewCollection` function creates a new instance of the collection with
    the given size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Callback` type is a first-class function type that returns the calculated
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `Map` function returns a new collection where every element is the result
    of calling the `Callback` function.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our empty interface-based Map function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll test our new empty interface-based `Map` function by defining a transformation
    function. This function will multiply every item in the collection by 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We pass a collection of the numbers `1`, `2`, `3`, and `4` as well as the transformation
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s pass our `Map` function a collection of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This time we pass a collection of strings and transform each by calling `ToUpper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Notice how in each case, we had to cast each `curVal`? With `transformation10`,
    we can cast each item in the collection to an `int` variable; with `transformationUpper`,
    we can cast each item to a `string` variable. We could choose to use reflection
    to avoid explicit casting, but that is even worse for performance than casting.
  prefs: []
  type: TYPE_NORMAL
- en: As with our earlier example, we could pass the collection to a chain of transformation
    functions to arrive at the result, which could be another collection or a single
    terminal value.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of reinventing the wheel each time, we need another high-order function;
    let's use any one of the number of Go packages available that easily enable the
    functional style of programming in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Itertools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Itertools is a Go package that provides many of the same high-order functions
    from the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the different types of high-order functions provided by Itertools.
    High-order functions provide the vocabulary for the declarative coding style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Infinite iterator creators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Count(i)`: Infinite count from `i`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cycle(iter)`: Infinite cycling of `iter` (requires memory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repeat(element [, n])`: Repeat the element `n` times (or infinitely)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterator destroyers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reduce(iter, reducer, memo)`: Reduce (or Foldl) across the iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List(iter)`: Create a list from the iterator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Iterator modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chain(iters...)`: Chain together multiple iterators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DropWhile(predicate, iter)`: Drop elements until predicate(el) == false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TakeWhile(predicate, iter)`: Take elements until predicate(el) == false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Filter(predicate, iter)`: Filter out elements when predicate(el) == false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FilterFalse(predicate, iter)`: Filter out elements when predicate(el) == true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slice(iter, start[, stop[, step]])`: Drop elements until the start (zero-based
    index). Stop upon stop (exclusive) unless not given. Step is 1 unless given.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More iterator modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Map(mapper func(interface{}) interface{}, iter)`: Map each element to mapper(el).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiMap(multiMapper func(interface{}...)interface{}, iters...)`: Map all
    the iterators as variadic arguments to `multiMaper(elements...)`; stop at the
    shortest iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultiMapLongest(multiMapper func(interface{}...)interface{}, iters...)`: Same
    as `MultiMap`, except that here you need to stop at the longest iterator. Shorter
    iterators are filled with nil after they are exhausted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Starmap(multiMapper func(interface{}...)interface{}, iter)`: If `iter` is
    an iterator of `[]interface{}`, then expand it to `multiMapper`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zip(iters...)`: Zip multiple iterators together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZipLongest(iters...)`: Zip multiple iterators together. Take the longest;
    shorter ones are appended with nil.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tee(iter, n)`: Split an iterator into n equal versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tee2(iter)`: Split an iterator into two equal versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go channels used by the New function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `itertools.go` file, we see that the iterator uses Go channels to range
    over each element in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The `New` function can be used as follows to take a list of values and turn
    it into a new iterable collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Testing itertool's Map function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s test itertool''s `Map` function by passing it a collection of words of
    various lengths and a literal function to operate on each word to return its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Let's not forget to run `go get -u github.com/yanatan16/itertools` to download
    the `itertools` package along with its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Testing iterators for element equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s create the `testIterEq` function to test whether two collections
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test function `TestMap`, we define a `mapper` function literal that
    is passed to our `Map` function to perform the transformation. The `mapper` function
    returns the length of each string passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go to the directory with this test file and run the following to verify
    that the `Map` function works as we expect. Here''s what my console output looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Functional  packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many other Go packages that provide the high-order functions (HOF)
    that we've come to expect when writing declarative code for manipulating collections.
    They typically use empty interfaces and reflection, which have negative performance
    impacts. A well known HOF implementation is  Rob Pike's `Reduce` package (see [https://github.com/robpike/filter](https://github.com/robpike/filter))
    where he states his preference for using for loops and clearly states, *don't
    use this*.
  prefs: []
  type: TYPE_NORMAL
- en: Another time of reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Are we frustrated yet? We learned how to code in a concise, declarative functional
    programming style only to learn that it would probably run too slow to be viable
    in production. We tried various techniques to speed it up, but nothing we've done
    thus far with pure functional programming can match the performance of old-school
    imperative programming.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to find a way to program using the declarative functional programming
    style in Go with performance numbers that meet or exceed expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Go is awesome
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go is our favorite language for many reasons including:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast and easy deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-platform support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protected source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go is awesome, but
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Go was not designed to be a pure functional language and lacks generics,
    we must take a performance hit to force Go into a functional style of programming,
    right? (Keep the faith! There's hope around the corner.)
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the core principles of implementing and using collections. You
    learned that in functional programming, a single function can take input and return
    a result and transformations to the collection that occurs inside the function.
    You learned that we can compose functions by chaining them together.
  prefs: []
  type: TYPE_NORMAL
- en: If Go had generics that would simplify our implementation task, but more importantly,
    if Go were designed to perform **tail-call optimization** (**TCO**) and other
    performance-boosting optimizations, then it would be an easy decision to choose
    to program in the functional style in Go.
  prefs: []
  type: TYPE_NORMAL
- en: One of Go's best features is its performance, and if we are developing a solution
    that runs on a single server and performance is more important to us than having
    concise, intuitive, and declarative code, then most likely we would not program
    Go in the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: The cure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, if we are looking to implement a distributed computing solution using
    Go, then we're in luck.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the features of a new Go package for performing distributed
    **MapReduce** for data processing at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Gleam - distributed MapReduce for Golang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '"First, generics are needed. Of course, we can use reflection. But it is noticeably
    slower, to the point that I do not want to show the performance numbers. Second,
    dynamic remote code execution is also needed if we want to dynamically adjust
    the execution plan. We could pre-build all the execution DAGs first and choose
    one of them during runtime. But it is very limiting. As everyone else here, I
    enjoyed the beauty of Go. How to make it work for big data?"'
  prefs: []
  type: TYPE_NORMAL
- en: '- Chris Lu'
  prefs: []
  type: TYPE_NORMAL
- en: That's the right question.
  prefs: []
  type: TYPE_NORMAL
- en: Chris resolved the performance issues of reflection and the lack of Generics
    using a scripting language named LuaJIT. Rather than building the entire **directed
    acyclic graph** (**DAG**) and then choosing one branch during runtime, the scripting
    nature of LuaJIT allows dynamic remote code execution, allowing us to dynamically
    adjust the execution plan during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: LuaJIT's FFI library
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'LuaJIT''s FFI library makes it easy to call C functions and C data structures
    by parsing C declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Call the named C function. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: Unix pipe tools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Gleam also leverages Unix pipe tools.
  prefs: []
  type: TYPE_NORMAL
- en: Gleam = Go + LuaJIT + Unix Pipes
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can use Gleam to process collections.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Gleam collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s see how Gleam processes collections. The input we''ll use is a collection
    of lines that comprises words in the `/etc/paths` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Gleam reads the file content as lines and feeds each line into the flow. From
    this, it creates the stream through which the functions `Map` and `Reduce` are
    called to count the number of occurrences of each word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Disappointed? Were you hoping that there was a practical use of pure functional
    programming in pure Go? (Where practical means the performance of using recursion
    is not an issue and where you can write your business logic and control flow logic
    in a declarative style, free from empty interfaces, downcasting/unboxing and those
    noisy if err != nil blocks?) Keep working through the book and you'll find a solution
    in the last unit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We manipulate collections constantly in our code. We often start with a list
    of items and need to transform our initial list into another list of different
    items. Sometimes, we want to map our list to another list of equal size. Sometimes,
    we want to group and sort our list. Other times, we need to arrive at a single
    result value.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the different types (intermediate and terminal)
    of collection functors. We dived into a few key areas of collection manipulation,
    including iterators, the `map` function, the `contains` method, and chaining of
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at a few Go packages that provide a cadre of high-order functions
    that we can use in our new functional style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: We gained an appreciation for Unix pipes and discovered that a new distributed
    processing Go package, named Gleam, leverages pipe to deliver a lightweight Go-based functional
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll dive deeper into pipelining and see how it can improve
    performance.
  prefs: []
  type: TYPE_NORMAL
