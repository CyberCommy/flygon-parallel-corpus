- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start with a discussion of some of the basic concepts
    and terminologies used in the basics of Java programs. You will learn all these
    concepts with the help of simple programs. You''ll learn about the all-important
    Java method. If you''re an experienced programmer, you''ve probably run across
    functions in the past. As you progress with these basic concepts, you will grasp
    more about advanced Java functions. The following are the topics that we plan
    to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of a Java function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Java functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating Java variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of Java functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, the terms "function" and "method" are basically used interchangeably,
    with "method" being the more technically correct term that you'll see in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Methods** are a tool that allow us to break the control flow of our program.
    They let us declare little **subroutines**, or sometimes we can think of them
    as smaller programs, that we can reference in our program so that we don''t have
    to write all of our program''s logical code in one single block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An example of a method is the `.next` method found in the `Scanner` class. Rather
    than having to teach our `Scanner` object how to acquire the next set of user
    inputs in this program I've written, I can simply call the `next` method from
    the class that someone else has written in the past. This turns what would probably
    be a couple of hundred lines of program into a total of 22 lines approximately,
    illustrated in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: By writing our own methods, we can tackle complicated challenges by breaking
    them into much smaller and easier-to-manage parts. Programs that are properly
    modular and make use of methods are also much more human-readable. This is because
    we can give our methods our own names so our program can be much more self-explanatory
    and make use of a lot more English(or whatever language you are native to) words.
    To show you the power of methods right from the start, I've planned a pretty complicated
    program for us to write today.
  prefs: []
  type: TYPE_NORMAL
- en: Temperature conversion program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our goal is to create a temperature conversion program, and I''ve set up the
    input portion of this program for us already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this program takes three pieces of information from the user. The first
    is the temperature type: `F` for Fahrenheit, `C` for Celsius, and `K` for Kelvin.
    Then it takes another temperature type. This is the type that our user would like
    us to convert to; once again, it could be Fahrenheit, Celsius, or Kelvin. Finally,
    we take the value of the initial temperature from the user. With these three pieces
    of input, our program will convert the given temperature value from Fahrenheit,
    Celsius, or Kelvin to the temperature type the user desires.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a challenging program for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: First, there are six possible control flow cases because there are two sets
    of three user input. This means in the worst-case scenario, we might have to write
    six `if...else` blocks, which will get unwieldy pretty quick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second challenge is doing the actual conversion. I''ve gone ahead and looked
    up the conversion math for three temperature conversions, namely Fahrenheit to
    Celsius, Celsius to Kelvin, and Kelvin to Fahrenheit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, while this isn't difficult math, it's certainly unwieldy and
    our programs are going to look pretty crazy if we start copying and pasting formula
    as shown in the preceding comments all over the place. You should also note that
    with the three conversions in the preceding comments section, we can make any
    of the possible conversions this program will be asked to do. This is because
    these three conversions create a circle of conversion, where we can get from a
    particular type to any other type by passing through one of the interim equations.
  prefs: []
  type: TYPE_NORMAL
- en: With all said and done, let's just jump right into writing our program.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is set up some control flow. As I mentioned before,
    there''s six possible cases, and it might be tempting to just set up six `if`
    statements for each possible pairing of input and output types. This would be
    a little unwieldy though, so I have a slightly different plan. Instead of handling
    a different case for each possible pairing of types, the first thing I''m going
    to do is convert whatever value our user has given as the initial temperature
    value to a Celsius value. After I''ve done this, we''ll convert that Celsius value
    to whatever type the user was originally looking for. This can be done using the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the control flow has the advantage of letting us deal with two pieces
    of user input in complete isolation. It makes our program more modular because
    we start and finish one task before we begin the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'So to do this initial conversion, where we take whatever the user has given
    us as input and convert it into a Celsius value, we need to utilize a `switch`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We'll be switching across the `inputType` character variable that tells us what
    type of temperature-Fahrenheit, Celsius, or Kelvin-our user has given us. Inside
    the `switch` statement, we'll manipulate `inputValue`, in which the value of that
    temperature would be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring separate cases - C, K, and F
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So I guess we''re going to need separate cases for each of the possible or
    valid input types, that is, capital `F` for Fahrenheit, `C` for Celsius, `K` for
    Kelvin. We should probably also handle a `default` case. Let''s start off by writing
    the `default` case. We''ll use `System.exit` and exit with `1`, which is technically
    an error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`System.exit` basically quits our program. It tells it to stop executing and
    passes to the operating system or whatever''s up in the hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the program will just stop. Because it's the `default` case, we
    only expect to enter it if the user has failed to enter `F`, `C`, or `K`, which
    are our valid input types. Now, let's go ahead and handle each of these input
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Celsius type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to use Celsius as our first point of conversion in all cases,
    so if our user has inputted a Celsius value, we can just go ahead and break out
    of this case because the value of `inputValue` is already OK with us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What if the user has given us a Fahrenheit value? Well, let''s scroll to the
    top of the code; you''ll see that we have an explicit conversion from Fahrenheit
    to Celsius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take the preceding block of code, which I''ve made pretty Java-friendly,
    and just change the value of this input variable to the conversion statement run
    on its value. So, we''ll replace the `t` placeholder with the input variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will properly store the Celsius equivalent of the original Fahrenheit value
    in this variable.
  prefs: []
  type: TYPE_NORMAL
- en: Kelvin type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can do something similar for the Kelvin case. We don''t have an explicit
    conversion from Kelvin to Celsius, but we do know how to convert Kelvin to Fahrenheit
    and then how to convert Fahrenheit to Celsius. So we can get away with doing something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we converted our Kelvin value to a Fahrenheit value,
    surrounding it in parentheses, and did our Fahrenheit to Celsius conversion on
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Now this is technically a functional line of code. If we run our program and
    enter a Kelvin input case, it will properly convert the Kelvin value to a Celsius
    value. But, let me say that if I'm a programmer and I'm at work and I run across
    a line of code like this, especially a line of code like this without any comments
    explaining it, I am not going to be very happy. There are a whole lot of magic
    numbers in here-numbers are really information in general; that's not in any way
    self-explanatory. Sure, we as the original programmer, at least when we write
    it, remember that our goal here is to convert a Kelvin value to a Celsius value;
    however, that's really not understandable to anyone else going through this program
    who doesn't really have time to sit down and look through the entire thing. So
    is there a better way to do this? Yes, there definitely is.
  prefs: []
  type: TYPE_NORMAL
- en: Fahrenheit type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s try to understand the Fahrenheit case. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code is a little better than our Kelvin case simply because
    it contains fewer numbers, but it's still not programmer-friendly by any sense
    of the word. So what if in our initial implementation of this program, we could
    provide communication that would really look a lot nicer to a programmer? What
    if instead of printing out the equation right there, we put the equation somewhere
    else in our program and call a Fahrenheit to Celsius function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We'll just type in `fToC` now to keep things short. This makes a lot more sense
    to someone looking at our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do something very similar down here for the Kelvin case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We could call a Kelvin to Celsius function (`kToC`) if we wanted to, or if we
    don't even want to write that, we can call a Kelvin to Fahrenheit function on
    our `inputValue` variable and then call the `fToC` function on top of that. That's
    what we did with all that math initially-conceptually-except that what we've done
    has abstracted away those numbers and put them somewhere else in our program.
    This is much more friendly to a programmer. Let's say we made a mistake in our
    math and another programmer wants to go through and check it. All they would need
    to do is find the functions that we're about to write, such as `fToC`, and `kToF`,
    and they can dive into all their dirty details there. So, of course, we do need
    to write these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a new function, we''re actually going to do it outside of the
    function or method that we''re currently in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Currently, we''re in our program''s `main` method, which is a special method
    where the program begins its execution. So, to write our Fahrenheit to Celsius
    function, we''re going to step out of that method and declare a brand new one;
    essentially, we''re teaching our program how to run a new program called `fToC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For now, go ahead and use the `public static` keywords in front of your methods.
    These keywords are going to be very important once we really jump into the object-oriented
    nature of Java, but for now, we'll utilize them on all the methods we declare.
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed explanation about what we plan to do next with our program,
    let's try to see things in much more detail by splitting the program further into
    two parts.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the first part of the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your standard Java method also has one more keyword before we actually give
    it a name, and that is the type of information this method is going to return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we would like to be able to call `fToC` on our Kelvin to Fahrenheit
    function. When we do this, we''re basically treating the result of our Kelvin
    to Fahrenheit function as a floating-point variable of its own. This is a good
    sign that the return type we''re looking for in these functions is a `float` data
    type. What this means is when these little programs finish executing, they''re
    going to throw out a floating-point value to our `main` method, which called them.
    After we name a function, we follow it with two parentheses in the function declaration
    preceding to it. Between these parentheses, we''re going to tell our program what
    information this function is going to require to run. We do this by basically
    creating some variables, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to want a variable that I''ll just call `fVal` because we''re
    starting with the Fahrenheit value. We also need to tell our program before each
    input variable what type of information that''s going to be; this way people won''t
    be able to improperly call our function and pass in something like a string, which
    wouldn''t make any sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we''re going to tell our function that in order to run, it needs to be
    called with a `float` piece of information given as input. In the functions that
    we wrote before, they actually existed in the program. You''ll see that we did
    this: we provided `inputValue`, or the value of the temperature the user initially
    gave us, as input to these functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need our `fToC` function, our Fahrenheit to Celsius function, to perform
    some computation on this `fVal` variable in the code, which will contain the user-inputted
    temperature value. Since we''re going from Fahrenheit to Celsius, we can just
    copy and paste the string from the top of the program again and substitute the
    `fVal` with `t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it may be tempting for us to ask our function to perform this operation
    to change the value of this variable. While we''re certainly allowed to do that,
    it''s not going to give us the result that we require. When our program hits the
    `inputValue = fToC(inputValue);` code line and runs our `fToC` function, giving
    `inputValue` as its input variable, this variable is not going to actually drop
    down to our function''s line of code. Rather, Java is simply going to copy the
    value of `inputValue` and store it in our new variable, as you can see in the
    following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So changes we make to this `fVal` variable will not map to our `inputValue`
    variable. Fortunately, we explicitly change the value of `inputValue` to be whatever
    this function we''re writing now returns. Once we''re ready to quit the execution
    of a function, we can have it throw out any value that''s equivalent to the value
    type that we told Java this function would return. We do this with the `return`
    keyword, followed by any statement that computes to, in our case, a floating-point
    value. So, when our `fToC` function runs on `inputValue`, it will print out a
    floating-point number equivalent to the Celsius value of our initial Fahrenheit
    value stored in the input variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve written one of these functions, writing other similar functions
    becomes pretty easy. To write our Kelvin to Fahrenheit function, we''re simply
    going to do the same thing, but in this case take our Kelvin to Fahrenheit conversion
    equation and change the name of our variable. We could call it `fVal` if we wanted
    to-`kVal` is just more explanatory-and return that result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So that's the first half of our program where we convert whatever the user has
    given us into a Celsius value. So far, this has been much more elegant than six
    `if` statements, but we have only written half of our program.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the second part of the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''re done with the Celsius conversion, we''ll use another `switch` statement.
    This time, we''ll use it on `outputType`, where the user has told us what temperature
    type they''d like to see the equivalent value of, or see the equivalent value
    in. Our cases are going to look very similar to the first half of our `switch`
    statement; however here instead of converting everything to Celsius, we''re always
    going to be converting from Celsius. Once again, that means case `C` can simply
    break in any instances where we''ve converted to Celsius and then we no longer
    need to convert from Celsius:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our explicit case here is the Celsius to Kelvin conversion. We know that
    formula, thanks to our nifty cheat sheet at the top of the code; we can build
    a function to do this pretty quick. We''ll call this function `cToK`; there''s
    our variable name, and there''s the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve declared our `cToK` function, we can call it on `inputValue` since
    `inputValue` now stores the modified original input value, which will be a Celsius
    number, to convert to a Kelvin value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the way we doubled up to convert from Kelvin to Fahrenheit to Celsius,
    when we make everything Celsius, we can get a Fahrenheit output by getting a Kelvin
    value from our Celsius value. Then, we can use the Kelvin to Fahrenheit function
    to convert this Kelvin value into a Fahrenheit one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the second half of our program. Still, only two real lines of code
    that might cause anyone to pause, and they''re pretty self-explanatory. Yet, all
    of the logic and functionality of our program is still accessible to a curious
    programmer who wants to reaccess them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Final touch to the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can finish up our program here using `println` to throw out `inputValue`,
    which should now contain the proper conversion. Let''s run this program and give
    some input and output to see how we did:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b90ab5d-c1a0-43a7-8c85-c9edc4df9cda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, when we run our program, it asks what `inputType` we''re going to give
    it. Let''s give it a Fahrenheit value. Now let''s say we would like to get a Celsius
    value as the output. Let''s see what the Celsius value of `32` degrees Fahrenheit
    is. We see that the output result of `0`. The `32` degrees Fahrenheit is `0` degrees
    Celsius, so that''s a good sign. Let''s try some more edge cases. If we attempt
    to convert Celsius to Celsius, we get the same value as shown in the following
    screenshot, which is what we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/470f1c0c-7f71-4fc9-a40f-09378870ebfa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see what the Fahrenheit value of `1` degrees Kelvin is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab570c83-a707-4b65-952f-471542ba6293.png)'
  prefs: []
  type: TYPE_IMG
- en: And the good news is that's also the expected value in the preceding screenshot.
    We've employed functions to make an otherwise very complex and difficult-to-read
    program much more manageable. The program we've written here is somewhat complicated.
    It does some math and multifunction statements, so if you weren't 100 percent
    with us the first time through, I encourage you to go back and check what tripped
    you up. There's also other ways to approach this problem, and if you had a stroke
    of inspiration, I encourage you to explore it.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Java functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, I''d like you to take a deeper look into Java methods and
    also learn some really valuable things about how programming languages think about
    and manipulate information. To help us do this, I''d like to run an experiment
    of sorts, and to start that experiment off, I''ve written a really basic Java
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At the core of this Java program is the `magic` method, which is user-defined
    following the `main` method. When we come across a new Java method, there''s three
    real things we should notice about it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we should ask, "what are its input values?". In the case of our `magic`
    method, it expects only a single integer as input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we probably want to ask, "what does this method return?". In our case,
    the method is marked to return `void`. Void methods don't actually return any
    values at all; they simply execute their code and finish. You'll notice that when
    we reference `magic` in the main portion of our program, we don't attempt to store
    its return value in any location. This is, of course, because there would be no
    return value to store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, the third thing to notice about our method is "what does it do?". In the
    case of our `magic` method, we simply take the value that we've gotten as `input`
    and increase that value by `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What I'd like to ask you to do right now is take a minute and just look at this
    program, and try and figure out exactly what the program's output will be when
    we reach this `println` statement. The challenging question here is what happens
    to the value of the variable `x` when we run the `magic(x)` line of code and call
    our `magic` method? Does the variable `x` remain unaffected when we pass it as
    a value to the `magic` method or does the variable `x` get modified by the input
    line of the code in the `magic` method such that instead of printing out `5`,
    we print out the value `15`?
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer this question, we simply have to run our program, and if we do this,
    we will see that we get the value of `5`, letting us know that running the `magic`
    method did not modify the value of the variable `x` within the context of our
    main method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0223233-6d3c-4f27-845e-94b6d995826e.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, we'll get the same output if we never run the `magic` method at all.
    So what does this tell us? This gives us a very important insight into how Java
    handles method input. To fully understand what's going on here, we need to take
    a deeper look into how Java variables operate.
  prefs: []
  type: TYPE_NORMAL
- en: Operating java variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a representation of the information stored by our variable
    `x`, that is, the variable in the `main` method of our Java program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c151dbad-8fa2-482a-8226-0c0cbddfbb44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll notice that this variable has three core components; let''s go through
    them quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left-hand side, I put this variable's name, which is the keyword that
    we use to reference it within the scope, and a memory location. Our variables
    point to a memory location, and in this memory location, we store the variable's
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can think of the name and memory location as being very static; they're not
    really going to change for this individual variable identifier throughout the
    course of our program's execution. However, we can, and often do, freely change
    the value stored in the variable's referenced memory location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So why is this important? Well, over the course of our program, we''re going
    to have to translate the information stored in our variable `x` into the information
    stored in the variable input that our `magic` method attempted to make use of.
    If we take a good look at how variables are set up, we quickly see that there''s
    two possible ways to go about doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we can simply create a brand new variable named `input` with its own
    unique memory location, then simply place the same value that we found in the
    memory location referenced by `x` as the value in that memory location:![](img/a1dc02e8-ffbb-4715-80f2-2b985061044c.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we pass the variable `x` to a method, which is the technique that Java
    uses to create the variable `input`, we can say that Java has passed our variable
    `x` by value. This is because only the value is preserved across the creation
    of the new variable.
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be for us to create a brand new variable `input`, but instead
    of simply copying the value from the variable `x` to the variable `input`, we
    could cause `input` to reference the same memory location as `x` does. This would
    be called passing the variable `x` by reference. In this case, because both `x`
    and `input` would share a memory location where they would store their values,
    modifying the value of the variable `input` would also modify the value of the
    variable `x`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, given what you've just learned about Java variables and taking into account
    that executing the `magic` method on `magic(x)` code line does not modify the
    value of the variable `x`, we can correctly conclude that Java chooses to pass
    variables to its methods by value rather than by reference.
  prefs: []
  type: TYPE_NORMAL
- en: However, that's not really the end of the story, or rather, this fact has implications
    that might not be immediately apparent to us. If we were to rewrite our program
    so that our `magic` method would take character input, boolean input, or really
    any other primitive type, we would see the same behavior that we've been seeing
    already. Even if we modify the value of this `input` variable within the scope
    of the `magic` method, it would not modify the value of the variable `x` within
    the scope of the `main` method. So, things are not always so simple.
  prefs: []
  type: TYPE_NORMAL
- en: Using variables in the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see this, let''s create a brand new method, and in its declaration, we''ll
    have it the same as our existing `magic` method. However, instead of taking a
    single integer as input, we''ll provide it as input in the integer array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Remember that our array will be named as a single variable, so all we need to
    do to let Java know that we'd like to pass an array to the function is inform
    it that the variable being given is an array of a certain type. You'll also notice
    that we now have two methods by the name of `magic` within our program. This is
    called **method overloading**, and it's perfectly legitimate to do this as long
    as Java has a way of telling the methods apart. In this case, Java can tell the
    methods apart because both the methods are going to be given different objects
    as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of our `magic` methods will execute if the input given to the `magic` call
    is a single integer, and our new `magic` method will execute if the input given
    to the method is an array of integers. Now, let''s write a quick `for` loop so
    that our new `magic` method will increment the value of every integer contained
    within our input array by `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is extremely similar to the `magic` method we wrote originally, except
    that instead of operating on a single integer, it's going to operate on any number
    of them. However, something that may appear weird is going to happen when we modify
    our `main` method to utilize this new implementation of the `magic` method. In
    order to make this happen, we need to make a few quick modifications to our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change our variable `x` from an integer to an integer array so that
    our program will know how to utilize the newly written `magic` method, which runs
    when we give an integer array as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to modify our `println` statement to make use of `Arrays.toString`
    so that we display the value stored in the `x` array properly. We''ll import `java.util`
    so that Java knows about the `Arrays` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to ask ourselves another question: when we run the `magic` function
    on an integer array, will we see the same results we saw when we ran the `magic`
    function on a single integer value, a primitive type? To answer this question,
    all we need to do is run our program, and we''ll very quickly see that the output,
    or the final values, stored in the `x` array are not the same values that we assigned
    to the `x` array initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0496807d-3c0e-4732-88a6-d5d773dc9050.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This lets us know that our `magic` method is indeed modifying these values.
    So this is kind of weird. Why would our `magic` method operate differently depending
    on whether we gave it a single primitive type as input or an array of primitive
    types as input? To answer this question, let''s take a look at the variable `x`
    when it''s declared to be an array of integers as opposed to just a single integer
    as we had it before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcccfc80-e74f-404e-8fa1-3c2a3a78c4da.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that `x` as an array of integers, as opposed to a single primitive type,
    still gets a name and memory location to identify it and a place where it can
    live; however, its value field looks drastically different than it did before.
    When `x` was just an integer, we could get away with simply storing an explicit
    integer in the value field of `x`, but as an array, `x` means to be able to reference
    a number of different values; that's what makes it a data structure. To make this
    happen, arrays-and really every other element more complicated than a primitive-point
    to a location in memory as opposed to a single explicit value. For arrays, all
    we need to do is point to the 0 index of the array in memory. Then, by following
    from that index, we can store a number of different values that our variable `x`
    knows how to access. So why is this important?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding passing parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, let''s take a look at what happens when we pass `x` to a method by value.
    As we know, when we pass a variable by value, we''re telling Java to create a
    new variable in the context of the method that''s going to have its own unique
    name and memory location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b8e10e2-4b1b-4d2e-83ab-b27a38e1475d.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this new variable-in our case, `input`-takes the value from the old
    variable as its own. When we were working with primitive types, these values were
    completely independent, but now both `input` and `x` have the values of the same
    location in memory. So, while modifying the value of input would not change the
    value of `x`, modifying the location of memory that input points to would still
    change that location of memory when `x` looks at it as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the context of a method, if we reference an input variable explicitly
    and then modify that variable, we''re going to be modifying only the variable
    within the context of the function, as we did in our first `magic` method. But,
    if we have to take an additional step to access the value that we''re modifying,
    as we have to do when declaring an index of an array, then we''ll probably have
    to modify it via a location of memory or by reference. In this instance, we will
    potentially affect the variable that provided the value for our function variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If our `magic` function that took an array simply attempts to set the value
    of our integer array to a brand new set of integer values with an all-new starting
    memory location, we would see that we would no longer be modifying the value of
    `x` when we run this function on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3917bd79-b30a-405d-94ea-38d819081037.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because the creation of a new integer array caused us to explicitly
    change the value of input. After this line of code, `input` and `x` no longer
    share a value anymore. Thank you very much for your time. I hope you learned something.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are you still with us? If so, congratulations. We started with some of the basic
    Java functions, such as methods, and then moved on to understand advanced Java
    functions. That's some complicated stuff we just went over. As you become a more
    experienced programmer, you'll begin to internalize concepts such as these and
    you won't have to really think about them explicitly when you're writing day-to-day
    code. For now, though, there's some logic shortcuts we can use to keep from getting
    too tripped up.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about modeling using object-oriented Java
    programs in detail.
  prefs: []
  type: TYPE_NORMAL
