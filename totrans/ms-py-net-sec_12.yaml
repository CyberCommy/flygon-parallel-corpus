- en: Extracting Geolocation and Metadata from Documents, Images, and Browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the main modules we have in Python for extracting information
    about geolocation IP address, extracting metadata from images and documents, and
    identifying the web technology used by a site in the frontend and backend. Also,
    we cover how to extract metadata for chrome and firefox browsers and information
    related to downloads, cookies, and history data stored in the sqlite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The `pygeoip` and `pygeocoder` modules for geolocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extract metadata from images with `Python Image` Library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extract metadata from PDF documents with `pypdf` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to identify technology used by a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extract metadata from web browsers such as chrome and firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 12` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install python distribution in your local machine with at least
    4 GB memory.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting geolocation information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review  how to extract geolocation information from an IP
    address or domain.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to geolocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One way to obtain geolocation from an ip address or domain is using a service
    that provides this kind of information. Among the services that provide this information,
    we can highlight hackertarget.com ([https://hackertarget.com/geoip-ip-location-lookup/](https://hackertarget.com/geoip-ip-location-lookup/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'With [hackertarget.com](http://hackertarget.com), we can get a geolocation
    from an ip address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04da526f-00a3-4154-b344-e4ec7d7f5970.png)'
  prefs: []
  type: TYPE_IMG
- en: This service also provides a REST API for obtaining a geolocation from an ip
    address: [https://api.hackertarget.com/geoip/?q=8.8.8.8](https://api.hackertarget.com/geoip/?q=8.8.8.8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another service is `api.hostip.info`, which provides a query by ip address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3ca09e55-c965-4e81-b66c-4f4bdd84e344.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next script, we are using this service and the `requests` module to obtain
    a json response with the information for geolocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`ip_to_geo.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the **output** of the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to Pygeoip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Pygeoip` is one of the modules available in Python that allows you to retrieve
    geographic information from an IP address. It is based on GeoIP databases, which
    are distributed in several files depending on their type (City, Region, Country,
    ISP). The module contains several functions to retrieve data, such as the country
    code, time zone, or complete registration with all the information related to
    a specific address.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Pygeoip` can be downloaded from the official GitHub repository: [http://github.com/appliedsec/pygeoip](http://github.com/appliedsec/pygeoip).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we query the help of the module, we see the main class that must be used
    to instantiate an object that allows us to make the queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0ee0956f-9aa4-4942-a081-23a5431e4c64.png)'
  prefs: []
  type: TYPE_IMG
- en: To build the object, we use a constructor that accepts a file as a database
    by parameter. An example of this file can be downloaded from: [http://dev.maxmind.com/geoip/legacy/geolite](http://dev.maxmind.com/geoip/legacy/geolite).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1062cdc6-46f3-4ce5-b7d2-713f98345e54.png)'
  prefs: []
  type: TYPE_IMG
- en: The following methods that we have available in this class allow you to obtain
    the name of the country from the IP address or the domain name.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `**geoip.py**` file in the `pygeopip`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also methods to obtain the organization and the service provider
    from the ip and host addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8926cf88-04bd-4d61-91aa-f29823539be8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an example of obtaining information for a specific organization from
    the ip address and domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also methods that allow us to obtain, in dictionary form, a structure
    with data about the country, city, latitude, or longitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b1cca883-a48c-4887-93eb-6da123e990bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an example of obtaining geolocation information from an ip address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see all the geolocation information returned by the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/971e5d90-8cd3-4b50-9499-d2a27403a429.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next script we have two methods, `geoip_city()` to obtain information
    about the location, and `geoip_country()` to obtain the country, both from the
    ip address.
  prefs: []
  type: TYPE_NORMAL
- en: In both methods, first instantiate a `GeoIP` class with the path of the file
    that contains the database. Next, we will query the database for a specific record,
    specifying the IP address or domain. This returns a record containing fields for
    city, `region_name`, `postal_code`, `country_name`, `latitude`, and `longitude`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `pygeoip_test.py` file in the `pygeopip`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the returned information is the same for both cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c071006-cd8a-48ea-8b8b-06e00dfdf1ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Introduction to pygeocoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pygeocoder` is a Python module that facilitates the use of Google''s geolocation
    functionality. With this module, you can easily find the addresses corresponding
    to the coordinates and vice versa. We can also use it to validate and format addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: The module is inside the official Python repository, so you can use `pip` to
    install it. In the [https://pypi.python.org/pypi/pygeocoder ](https://pypi.python.org/pypi/pygeocoder)URL,
    we can see the latest version of this module: `$ pip install pygeocoder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module uses the Google Geocoding API v3 services to retrieve the coordinates
    from a specific address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7360aef5-9517-48e7-a26e-29c8c7a9d535.png)'
  prefs: []
  type: TYPE_IMG
- en: The main class of this module is the `Geocoder` class, which allows queries
    to be made both from the description of a place and from a specific location.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this screenshot, we can see the return of the `help` command for the `GeoCoder`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/874c59b5-88f5-49f3-a0bf-a8b1b9f20865.png)'
  prefs: []
  type: TYPE_IMG
- en: Example where from a description in the form of a place, coordinates, latitude,
    longitude, country and postal code are obtained. You can also perform the reverse
    process, that is, starting from coordinates corresponding to latitude and longitude
    of a geographical point, it is possible to recover the address of said site.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `PyGeoCoderExample.py` file in the `pygeocoder`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see all the geolocation information returned by the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7c2b63cf-17e6-4c0b-8fd1-3fe517203204.png)'
  prefs: []
  type: TYPE_IMG
- en: The MaxMind database in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are other Python modules that are using the MaxMind database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**geoip2:** Provides access to the GeoIP2 web services and databases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/maxmind/GeoIP2-python](https://github.com/maxmind/GeoIP2-python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**maxminddb-geolite2:** Provides a simple MaxMindDB reader extension'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/rr2do2/maxminddb-geolite2](https://github.com/rr2do2/maxminddb-geolite2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next script, we can see an example of how to use the `maxminddb-geolite2`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `geolite2_example.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this screenshot, we can see the execution of the previous script using google.com
    as a hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '`python geolite2_example.py --hostname google.com`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This script will show an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/39c1d15f-fd21-4639-b49c-70fc88b615cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Extracting metadata from images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review how to extract EXIF metadata from images with the
    PIL module.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Exif and the PIL module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main modules that we find within Python for the processing and manipulation
    of images is `PIL`. The `PIL` module allows us to extract the metadata of images
    in `EXIF`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exif (Exchange Image File Format)** is a specification that indicates the
    rules that must be followed when we are going to save images and defines how to
    store metadata in image and audio files. This specification is applied today in
    most mobile devices and digital cameras.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PIL.ExifTags` module allows us to extract information from these tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f92bcdd3-de77-40ae-b712-31142fd3c023.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see the official documentation for the `exiftags` package inside the
    pillow module at [https://pillow.readthedocs.io/en/latest/reference/ExifTags.html](https://pillow.readthedocs.io/en/latest/reference/ExifTags.html).
  prefs: []
  type: TYPE_NORMAL
- en: ExifTags contains a dictionary  structure with constants and names for many
    well-known `EXIF tags`**.**
  prefs: []
  type: TYPE_NORMAL
- en: In this image, we can see all tags returned by `TAGS.values()` method**:**
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5d180f44-29e7-424e-b1c4-523fcc817f78.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting the EXIF data from an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we imported the `PIL` image and `PIL TAGS` modules. `PIL` is an image-processing
    module in Python. It supports many file formats and has a powerful image-processing
    capability. Then we iterate through the results and print the values. There are
    many other modules that support EXIF data extraction, such as `ExifRead`. In this
    example, to acquire the `EXIF` data, we can use the `_getexif()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `get_exif_tags.py` file in the `exiftags`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Exif Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To obtain the information of the `EXIF` tags of an image, the `_getexif()` method
    of the image object can be used. For example, we can have a function where, from
    the image path, we can return information from `EXIF` tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following functions are available in the `extractDataFromImages.py` file
    in the `exiftags` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This information can be improved by decoding the information we have obtained
    in a latitude-longitude values format, for them we can make a function that, given
    an `exif` attribute of the `GPSInfo` type, decodes that information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the previous script, we parsed the Exif data into an array, indexed by the
    metadata type. With the array complete, we can search the array to see whether
    it contains an `Exif` tag for `GPSInfo`. If it does contain a `GPSInfo` tag, then
    we will know the object contains GPS Metadata and we can print a message to the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following image, we can see that we have also obtained information in
    the `GPSInfo` object about the location of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0157494-f454-414c-a0bc-088c111e5445.png)'
  prefs: []
  type: TYPE_IMG
- en: Extracting metadata from web images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to build a script to connect to a Website, download
    all the images on the site, and then check them for `Exif` metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this task, we are using the `urllib` module from python3 that provides
    `parse` and `request` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.0/library/urllib.parse.html](https://docs.python.org/3.0/library/urllib.parse.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3.0/library/urllib.request.html](https://docs.python.org/3.0/library/urllib.request.html)'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the following code in the  `exif_images_web_page.py` file in the
    `exiftags` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script contains the methods for find images in a website with `BeautifulSoup`
    and the `lxml parser`, and download images in an images folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the function that extract metadata from images inside the images directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our main method that gets a url from parameter and calls the `findImages(url)`, `downloadImage(imgTags)`,and
    `printMetadata()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Extracting metadata from pdf documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review how to extract metadata from pdf documents with `pyPDF2`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to PyPDF2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the modules available in Python to extract data from PDF documents is
    `PyPDF2`. The module can be downloaded directly with the pip install utility since
    it is located in the official Python repository .
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [https://pypi.org/project/PyPDF2/](https://pypi.org/project/PyPDF2/) URL,
    we can see the last version of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/96634174-b564-4c43-a5db-ad1ba4d42650.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This module offers us the ability to extract document information, and encrypt
    and decrypt documents. To extract metadata, we can use the `PdfFileReader` class
    and the `getDocumentInfo()` method, which returns a dictionary with the data of
    the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/084b4e2a-7946-45d5-b287-cacaee766c70.png)'
  prefs: []
  type: TYPE_IMG
- en: The following function would allow us to obtain the information of all the PDF
    documents that are in the "`pdf`" folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the  `extractDataFromPDF.py` file in the
    `pypdf` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this part of code, we use the `getXmpMetadata()` method to obtain other
    information related to the document, such as the contributors, publisher, and
    pdf version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The "`walk`" function within the os (operating system) module is useful for
    navigating all the files and directories that are included in a specific directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this screenshot, we can see the output of the previous script that is reading
    a file inside the pdf folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/72fb6e0e-abf0-49bf-bbbb-9e77bd3b737d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another feature it offers is the ability to decode a document that is encrypted
    with a password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9e6c1da5-031c-45fe-8ef0-8206d186fcf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Peepdf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Peepdf` is a Python tool that analyzes PDF files and allows us to visualize
    all the objects in the document. It also has the ability to analyze different
    versions of a PDF file, sequences of objects and encrypted files, as well as modify
    and obfuscate PDF files: [http://eternal-todo.com/tools/peepdf-pdf-analysis-tool](http://eternal-todo.com/tools/peepdf-pdf-analysis-tool).'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the technology used by a website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review  how to identify the technology used by a website
    with builtwith and Wappalyzer.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the builtwith module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The type of technology used to build a website will affect the way you track
    it. To identify this information, you can make use of tools such as Wappalyzer
    and Builtwith ([https://builtwith.com](https://builtwith.com)). A useful tool
    to verify the type of technologies a website is built with the module is builtWith,
    which can be installed with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pip install builtwith`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This module has a method called `parse`, which is passed by the URL parameter
    and returns as a response the technologies used by the website. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The documentation is available at [https://bitbucket.org/richardpenman/builtwith](https://bitbucket.org/richardpenman/builtwith) and
    the module is available on the pypi repository at [https://pypi.org/project/builtwith/](https://pypi.org/project/builtwith/).
  prefs: []
  type: TYPE_NORMAL
- en: Wappalyzer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another tool for recovering this kind of information is Wappalyzer. Wappalyzer
    has a database of web application signatures that allows you to identify more
    than 900 web technologies from more than 50 categories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool analyzes multiple elements of the website to determine its technologies,
    it analyzes the following HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP response headers on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meta HTML tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript files, both separately and embedded in the HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific HTML content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML-specific comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`python-Wappalyzer` is a Python interface for obtaining this information from
    a Python script ([https://github.com/chorsley/python-Wappalyzer](https://github.com/chorsley/python-Wappalyzer)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`pip install python-Wappalyzer`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily use the wappalyzer module to obtain information about technologies
    used in frontend and backend layers in a website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8e3d7549-09c9-4ca7-97d8-7249430b6263.png)'
  prefs: []
  type: TYPE_IMG
- en: wig – webapp information gatherer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: wig is a tool developed in Python3 of information collection of web applications,
    which can identify numerous content-management systems and other administrative
    applications. Each detected CMS is displayed along with the most probable version
    of it. Internally, it obtains the operating system on the server from the 'server'
    and 'x powered-by' headers ([https://github.com/jekyc/wig](https://github.com/jekyc/wig)).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the options provided by wig script over the Python3 environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dab0ef28-bbd1-447e-83d9-c69820d648cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this image, we can see the technologies used by the [testphp.vulneb.com](http://testphp.vulneb.com)
    site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da6a018b-c973-400c-ba94-be4bd3af290b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this image, we can see how it detects the CMS version and other interesting
    files used by the [drupal.com](http://drupal.com) site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9305f9f7-6133-4d00-8e5c-b4f1643a74f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Extracting metadata from web browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review how to extract metadata from web browsers, such as
    chrome and firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox Forensics in Python with dumpzilla
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dumpzilla is a very useful, versatile, and intuitive tool dedicated to forensic
    analysis in Mozilla browsers. Dumpzilla has the ability to extract all the relevant
    information from the Firefox, Iceweasel, and Seamonkey browsers for further analysis
    in order to offer clues about suffered attacks, passwords, and emails. It runs
    under Unix systems and windows 32/64 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application works under the command line and we can access a large volume
    of valuable information, among which we can find:'
  prefs: []
  type: TYPE_NORMAL
- en: Cookies + DOM Storage (HTML 5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User preferences (domain permissions, Proxy settings)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View Download history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data of web forms (searches, emails, comments, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords saved in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extraction of the HTML5 Cache (Offline cache)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addons and extensions and the routes or urls they have used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL certificates added as exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To complete the forensic analysis of the browser, it is recommended to use a
    data-extraction application from the cache, such as MozCache ([http://mozcache.sourceforge.net](http://mozcache.sourceforge.net)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Requeriments:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.x version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unix systems (Linux or Mac) or Windows System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional `Python Magic` Module: [https://github.com/ahupp/python-magic](https://github.com/ahupp/python-magic)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dumpzilla command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Locate the browser profile directory to be audited. The profiles are located
    in different directories, depending your operating system. The first step is to
    know the directory where the information of the user profiles of the browser is
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the locations for each operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Win7 and 10 profiles: `''C:\Users\%USERNAME%\AppData\Roaming\Mozilla\Firefox\Profiles\xxxx.default''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MacOS profile: `''/Users/$USER/Library/Application Support/Firefox/Profiles/xxxx.default''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unix profile: `''/home/$USER/.mozilla/firefox/xxxx.default''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can download the `dumpzilla` Python script from the git repository and run
    the script with Python3 pointing it to the location of your browser profile directory: [https://github.com/Busindre/dumpzilla](https://github.com/Busindre/dumpzilla).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the options the script provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/e2a8fff8-a533-46c2-b5cb-2d367f649f00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This returns a report about internet browsing information, then shows a summary
    chart of information gathered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f56fbaef-b459-4144-9333-b27ca3cc2bbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Firefox forensics in Python with firefeed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firefed is a tool, run in command-line mode, that allows you to inspect Firefox
    profiles. It is possible to extract stored passwords, preferences, plugins, and
    history ([https://github.com/numirias/firefed](https://github.com/numirias/firefed)).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the options available for the `firefed` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/316eecbb-179b-4dff-be66-172f3b61937d.png)'
  prefs: []
  type: TYPE_IMG
- en: This tool reads the `profiles.ini` file that is located in your username firefox
    profile.
  prefs: []
  type: TYPE_NORMAL
- en: In window operating system this file is located in `C:\Users\username\AppData\Roaming\Mozilla\Firefox`.
  prefs: []
  type: TYPE_NORMAL
- en: Also you can detect this folder with the `%APPDATA%\Mozilla\Firefox\Profiles`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: More information can be found in the official documentation from the mozilla
    website: [https://support.mozilla.org/en-US/kb/profiles-where-firefox-stores-user-data#w_how-do-i-find-my-profile](https://support.mozilla.org/en-US/kb/profiles-where-firefox-stores-user-data#w_how-do-i-find-my-profile).
  prefs: []
  type: TYPE_NORMAL
- en: Chrome forensics with python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Google Chrome stores the browser history in a SQLite database in the following
    locations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows 7 and 10: `C:\Users\[USERNAME]\AppData\Local\Google\Chrome\`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: `/home/$USER/.config/google-chrome/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database file that contains the browsing history is stored under the Default
    folder as "History" and can be examined using any SQlite browser ([https://sqlitebrowser.org/](https://sqlitebrowser.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Windows machine, this database usually can be found under the following
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Users\<YOURUSERNAME>\AppData\Local\Google\Chrome\User Data\Default`'
  prefs: []
  type: TYPE_NORMAL
- en: For example, with windows OS in path `C:\Users\<username>\AppData\Local\Google\Chrome\User
    Data\Default\History` we can find the sqlite database that stores Chrome's web
    history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the tables for the History Database and the associated fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**downloads:** `id`, `current_path`, `target_path`, `start_time`, `received_bytes`,
    `total_bytes`, `state`, `danger_type`, `interrupt_reason`, `end_time`, `opened`,
    `referrer`, `by_ext_id`, `by_ext_name`, `etag`, `last_modified`, `mime_type`,
    `original_mime_type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**downloads_url_chains**: `id`, `chain_index`, `url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**keyword_search_terms:** `keyword_id`, `url_id`, `lower_term`, `term`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**meta:** `key`, `value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**segment_usage:**  `id`, `segment_id`, `time_slot`, `visit_count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**segments:** `id`, `name`, `url_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**urls:** `id`, `url`, `title`, `visit_count`, `typed_count`, `last_visit_time`,
    `hidden`, `favicon_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this image, we can see a screenshot of the SQlite browser with tables available
    in the History Database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/adc00515-d4fc-4183-aa0e-2c22b59573a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Chrome stores its data locally in a `SQLite database.` So all we need to do
    is write a Python script that would make a connection to the database, query the
    necessary fields, and extract the data from tables.
  prefs: []
  type: TYPE_NORMAL
- en: We can build a Python script that extracts information from the downloads table. Only
    you to need **`import the sqlite3`** module that comes with the Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `ChromeDownloads.py` file compatible
    with Python3.x:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the options that provide the script with the `-h` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '`python .\ChromeDownloads.py -h`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the previous script, we need pass as a parameter the location of
    your history file database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/26627db3-b833-4216-814a-422676282c04.png)'
  prefs: []
  type: TYPE_IMG
- en: Chrome forensics with Hindsight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hindsight is an open source tool for parsing a user’s Chrome browser data and allows
    you to analyze several different types of web artifacts, including URLs, download
    history, cache records, bookmarks, preferences, browser extensions, HTTP cookies,
    and local storage logs in the form of cookies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool is available in the GitHub and pip repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/obsidianforensics/hindsight](https://github.com/obsidianforensics/hindsight)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pypi.org/project/pyhindsight/](https://pypi.org/project/pyhindsight/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this screenshot, we can see the last version of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d756ebc5-251d-4a2f-814c-fd736f30110a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can install it with the `pip install pyhindsight` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have installed the module, we can download the source code from the
    GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/obsidianforensics/hindsight](https://github.com/obsidianforensics/hindsight)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a5bb0376-8c43-4192-a408-20ec966dec2b.png)'
  prefs: []
  type: TYPE_IMG
- en: We can execute it in two ways. The first one is using the `hindsight.py` script,
    and the second one is by launching the `hindsight_gui.py` script, which provides
    a web interface for entering the location where chrome profile is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'For execution with `hindsight.py`, we only need to pass as a mandatory parameter
    (**`-i`,**`--input`) the location of your chrome profile, depending your operating
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/99747764-86a9-46c2-a70e-e9069eefbfe9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the default locations for chrome profile that we need to know for
    setting the input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a369573f-47a5-45f5-89dc-8279e084dd7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second way is to run "`hindsight_gui.py`" and visit [http://localhost:8080](http://localhost:8080)
    in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34b8947b-9ba6-4b35-bc92-289def323701.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The only mandatory field is the profile path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/de7e2530-62f9-4383-be72-4ad4c5e50beb.png)'
  prefs: []
  type: TYPE_IMG
- en: If we try to run the script with the chrome browser process opened, it will
    block the process, since we need to close the chrome browser before running it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the error message when you try to execute the script with the chrome
    process running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b10ab9d9-ab8e-43d6-a1d4-80bdf11bd1bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the objectives of this chapter was to learn about the modules that allow
    us to extract metadata from documents and images, as well as to extract geolocation
    information from IP addresses and domain names. We discussed how to obtain domain,
    information such as how technologies and CMS are being used in a certain web page.
    Finally,we reviewed how to extract metadata from web browsers such as chrome and
    firefox. All the tools reviewed in this chapter allow us to get information that
    may be useful for later phases of our pentesting or audit process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [chapter](7ae7e7c7-4cfb-48fc-9e38-d52ff21d9c9d.xhtml), we will explore
    programming packages and Python modules for implementing cryptography and steganography.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which module available in Python allows us to retrieve geographic information
    from an IP address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module uses Google Geocoding API v3 services to retrieve the coordinates
    of a specific address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main class of the `Pygeocoder` module that allows queries to be
    made both from the description of a place and from a specific location?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method allows the reverse process to recover the address of said site
    from the coordinates corresponding to the latitude and longitude?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method within the `pygeoip` module allows us to obtain the value of the
    country name from the ip address passed by parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method within the `pygeoip` module allows us to obtain a structure in
    the form of a dictionary with the geographic data (country, city, area, latitude,
    longitude) from the ip address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method within the `pygeoip` module allows us to obtain the name of the
    organization from the domain name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which Python module allows us to extract metadata from PDF documents?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which class and method can we use to obtain the information of a PDF document?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module allows us to extract the image information from the tags in EXIF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these links, you will find more information about the tools mentioned in
    this chapter and their official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bitbucket.org/xster/pygeocoder/wiki/Home](https://bitbucket.org/xster/pygeocoder/wiki/Home)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://chrisalbon.com/python/data_wrangling/geocoding_and_reverse_geocoding/](https://chrisalbon.com/python/data_wrangling/geocoding_and_reverse_geocoding/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pythonhosted.org/PyPDF2](https://pythonhosted.org/PyPDF2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.dumpzilla.org](http://www.dumpzilla.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://tools.kali.org/forensics/dumpzilla](https://tools.kali.org/forensics/dumpzilla)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://forensicswiki.org/wiki/Google_Chrome](http://forensicswiki.org/wiki/Google_Chrome)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://sourceforge.net/projects/chromensics](https://sourceforge.net/projects/chromensics)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
