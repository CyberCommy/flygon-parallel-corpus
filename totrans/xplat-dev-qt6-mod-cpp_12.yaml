- en: '*Chapter 9*: Testing and Debugging'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and testing are essential parts of software development. In this chapter,
    you will learn how to debug Qt projects, about different debugging techniques,
    and about debuggers supported by Qt. Debugging is the process of discovering the
    root cause of an error or undesired behavior and resolving it. We will also discuss
    unit testing using the Qt Test framework. Qt Test is a unit testing framework
    for Qt-based applications and libraries. It has all of the features that most
    unit testing frameworks provide. Additionally, it provides support for testing
    **Graphical User Interfaces** (**GUIs**). This module helps in writing unit tests
    for Qt-based applications and libraries in a convenient way. You will also learn
    techniques to test a GUI using different GUI testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a C++ application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a Qt Quick application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with Google's C++ testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Qt Quick applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUI testing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with debugging and testing
    techniques for your Qt application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include minimum versions of Qt 6.0.0
    and Qt Creator 4.14.0 installed on the latest version of a desktop platform such
    as Windows 10, Ubuntu 20.04, or macOS 10.14\.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code used in this chapter can be downloaded from the following GitHub
    link: [https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter09](https://github.com/PacktPublishing/Cross-Platform-Development-with-Qt-6-and-Modern-Cpp/tree/master/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The screenshots used in this chapter are taken from the Windows platform. You
    will see similar screens based on the underlying platform on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, technical problems arise often. To address these issues,
    we must first identify and resolve all of them before releasing our application
    to the public to maintain quality and our reputation. Debugging is a technique
    for locating these underlying technological issues.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming sections, we will discuss popular debugging techniques used by
    software engineers to ensure their software's stability and quality.
  prefs: []
  type: TYPE_NORMAL
- en: Debuggers supported by Qt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt supports several different types of debuggers. The debugger you use can
    vary depending on the platform and compiler you''re using for your project. The
    following is a list of debuggers that are widely used with Qt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GNU Symbolic Debugger** (**GDB**) is a cross-platform debugger developed
    by the GNU Project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Console Debugger** (**CDB**) is a debugger from Microsoft for Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low Level Virtual Machine Debugger** (**LLDB**) is a cross-platform debugger
    developed by the LLVM Developer group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QML/JavaScript Debugger** is a QML and JavaScript debugger provided by the
    Qt company.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're using the MinGW compiler on Windows, you won't need to do any manual
    setup with GDB because it's typically included with your Qt installation. If you're
    using a different operating system, such as Linux, you may need to manually install
    it before linking it to Qt Creator. Qt Creator automatically detects the presence
    of the GDB and adds it to its debugger list.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `gdbserver` by specifying either `--vgdb=yes` or `--vgdb=full`.
    You can specify `--vgdb-error=number` to activate `gdbserver` after a certain
    number of errors are displayed. If you set the value to `0`, then `gdbserver`
    will be active at initialization, allowing you to set breakpoints before the application
    launches. It's worth noting that `vgdb` is included in the **Valgrind** distribution.
    It does not need to be installed separately.
  prefs: []
  type: TYPE_NORMAL
- en: If your favorite platform is Windows, you can install CDB on your machine. By
    default, the built-in debugger of Visual Studio won't be available. Therefore,
    you must install the CDB debugger separately by choosing debugging tools for Windows
    as an optional component when installing the Windows SDK. Qt Creator usually recognizes
    the existence of CDB and adds it to the debugger list under **Options**.
  prefs: []
  type: TYPE_NORMAL
- en: Android debugging is a little more challenging than debugging on a regular desktop
    environment. Different packages, such as JDK, Android SDK, and Android NDK, are
    required for Android development. On the desktop platform, you will need the **Android
    Debug Bridge** (**ADB**) driver to allow USB debugging. You must enable developer
    mode and accept USB debugging on the Android device to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The debugger used on macOS and iOS is **LLDB**. It is included with Xcode by
    default. Qt Creator will automatically detect its presence and link it with a
    kit. If you're familiar with debuggers and know what you're doing, you can also
    add non-GDB debuggers to your favorite IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The debugger plugin determines a suitable native debugger for each package
    based on what''s available on your machine. You can overcome this preference by
    adding new debuggers. You can find the available debuggers in the **Debuggers**
    tab present under the **Kits** settings under the **Options** menu as shown in
    *Figure 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Debuggers tab under the Kits selection screen showing the
    Add button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.1_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The Debuggers tab under the Kits selection screen showing the Add
    button
  prefs: []
  type: TYPE_NORMAL
- en: In the **Debuggers** tab, you can see **Add**, **Clone**, and **Remove** buttons
    on the right side. You can clone an existing debugger configuration and modify
    it to suit your requirements. Alternatively, if you are aware of the debugger's
    details and configuration, then you can create a new debugger configuration using
    the **Add** button. You can also remove a faulty or obsolete debugger configuration
    by clicking the **Remove** button. Don't forget to click the **Apply** button
    to save your changes. Please note that you can't modify auto-detected debugger
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about various supported debuggers. In the next section,
    we will discuss how to debug an application.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different debugging strategies to find the root cause of an issue.
    Before attempting to locate a bug in the application, it is critical to thoroughly
    understand the program or library. You can't find mistakes if you don't know what
    you're doing. Only if you have a thorough understanding of the system and how
    it operates will you be able to identify bugs in the application. Previous experience
    can aid in the detection of similar types of bugs as well as the resolution of
    bugs. The individual expert's knowledge determines how easily the developer can
    locate the bug. You can add debug print statements and breakpoints to analyze
    the flow of the program. You can do forward analysis or backward analysis to track
    the bug's location.
  prefs: []
  type: TYPE_NORMAL
- en: 'When debugging, the following steps are used to find the root cause and resolve
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resolve the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the side effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Regardless of the programming language or platform, the most important thing
    to know when debugging your application is which section of your code is causing
    the problem. You can find the faulty code in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: If the defect is raised by your QA team or a user, then inquire when the issue
    occurred. Look at the log files or any error messages. Comment out the suspected
    section of the code, then build and run the application again to see if the issue
    persists. If the issue is reproducible, do forward and backward analysis by printing
    messages and commenting out lines of code before you find the one that's causing
    the issue.
  prefs: []
  type: TYPE_NORMAL
- en: You can also set a breakpoint in the built-in debugger to search for variable
    changes within your targeted feature. If one of the variables has updated to an
    unexpected value or an object pointer has become an invalid pointer, then you
    can easily identify it. Inspect all of the modules you used in the installer and
    ensure that you and your users have the same version number of the application.
    If you are using a different version or different branch, then check out the branch
    with the specified version tag, then debug the code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how to debug your C++ code by printing
    debug messages and adding breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a C++ application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `QDebug` class can be used to print the value of a variable to the application
    output window. `QDebug` is similar to `std::cout` in the standard library, but
    it has the benefit of being part of Qt, which means it supports Qt classes out
    of the box and can display its value without the need for conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable debugging messages, we must include the `QDebug` header as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Qt provides several global macros for generating different types of debug messages.
    They can be used for different purposes, mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`qDebug()` provides a custom debug message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qInfo()` provides informational messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qWarning()` reports warnings and recoverable errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qCritical()` provides critical error messages and reports system errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`qFatal()` provides fatal error messages before exiting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see if your feature is working correctly by using `qDebug()`. After
    you''ve finished looking for the error, remove the line of code that contains
    `qDebug()` to avoid unwanted console logs. Let''s look at how to use `qDebug()`
    to print out variables to the output pane with an example. Create a sample `QWidget`
    application and add a function, `setValue(int value)`, and add the following code
    inside the function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will show the following output in the output window present
    at the bottom of Qt Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can figure out whether the value was changed by another function by looking
    at how many times the function is used and called inside the application. If the
    debug message is printed multiple times, then it is invoked from multiple places.
    Check if the correct value is sent to all calling functions. To eliminate unnecessary
    console logs in the output console window, remove the line of code that contains
    `qDebug()` once you have finished looking for the issue. Alternatively, you may
    implement conditional compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look further into debugging and debugging options in Qt Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: You can see a **Debug** menu in the menu bar. When you click on it, you will
    see a context menu with submenus as shown in *Figure 9.2*:![Figure 9.2 – Debug
    menu in Qt Creator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.2_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Debug menu in Qt Creator
  prefs: []
  type: TYPE_NORMAL
- en: To start debugging, press *F5* or click on the start **Debug** button at the
    bottom left of Qt Creator as shown here:![Figure 9.3 – The Start debugging button
    in Qt Creator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.3_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – The Start debugging button in Qt Creator
  prefs: []
  type: TYPE_NORMAL
- en: If Qt Creator complains about the debugger with an error message, then check
    to see if your project package has a debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the error persists, close Qt Creator and go to your project folder, where
    you can delete the `.pro.user` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then reload the project in Qt Creator. Your project will be reconfigured by
    Qt Creator, and the debug mode should now be functional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A great way to debug your application is to set a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: You will see a pop-up menu of three choices when you right-click on the line
    number of your script in Qt Creator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also click on the line number to add a breakpoint. Click on the line
    number to set a breakpoint. You will see a red dot appearing on the line number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, press the *F5* key on the keyboard or click on the start **Debug** button.
    Once you run the application in debug mode, you will notice a yellow arrow appearing
    on top of the first red dot:![Figure 9.4 –  Qt Creator showing debugging windows
    and breakpoints
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Qt Creator showing debugging windows and breakpoints
  prefs: []
  type: TYPE_NORMAL
- en: The debugger has come to a halt at the first breakpoint. The variable, along
    with its meaning and type, will now be displayed in the **Locals** and **Expression**
    windows on the right-hand side of your Qt Creator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This approach can be used to quickly examine the application. To remove a breakpoint,
    just click on the red dot icon once more or from the right-click context menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Context menu showing right-click options on a breakpoint marking'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.5_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Context menu showing right-click options on a breakpoint marking
  prefs: []
  type: TYPE_NORMAL
- en: It's important to remember that you must run your application in debug mode.
    This is because when you compile in debug mode, your application or library will
    have additional debugging symbols that allow your debugger to access information
    from the binary's source code, such as the names of identifiers, variables, and
    functions. This is the reason the application or library binaries are larger in
    file size when compiled in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn about more features and their usage in the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://doc.qt.io/qt-6/debug.html](https://doc.qt.io/qt-6/debug.html%20)'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Some anti virus applications prevent debuggers from retrieving information.
    One such anti virus is Avira. If it is installed on a production PC, the launching
    of the debugger could fail on the Windows platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss how to debug a Qt Quick application and
    locate issues inside a QML file.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Qt Quick application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we discussed how to debug your C++ code. But you are probably
    still wondering how to debug code written in QML. Qt also has a provision to debug
    your QML code. When you are developing a Qt Quick application, there are a lot
    of options to troubleshoot issues. In this section, we will discuss various debugging
    techniques related to QML and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `QDebug` class, there are different console APIs that are available
    for debugging in QML. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Log`: This is used to print general messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert`: This is used to verify an expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Timer`: This is used to measure the time spent between calls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Trace`: This is used to print a stack trace of a JavaScript execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Count`: This is used to find the number of calls made to a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Profile`: This is used to profile QML and JavaScript code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception`: It is used to print error messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Console API provides several convenient functions to print different types
    of debug messages such as `console.log()`, `console.debug()`, `console.info()`,
    `console.warn()`, and `console.error()`. You can print a message with the value
    of a parameter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check the creation of a component by adding the message inside
    `Components.onCompleted:{…}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that an expression is true, you can use `console.assert()`, such
    as the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You will find the time spent between calls is logged by `console.time()` and
    `console.timeEnd()`. The stack trace of the JavaScript execution at the stage
    where it was called is printed by `console.trace()`. The function name, filename,
    line number, and column number are all included in the stack trace details.
  prefs: []
  type: TYPE_NORMAL
- en: '`console.count()` returns the current number of times a piece of code has been
    executed, as well as a message. The QML and JavaScript profiling are activated
    when you use `console.profile()` and deactivated when `console.profileEnd()` is
    called. You can use `console.exception()` to print an error message along with
    the stack trace of the JavaScript execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a breakpoint in the same way we discussed in an earlier section,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To step into the code in the stack, click on the **Step Into** button on the
    toolbar or press *F11*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To step out, press *Shift* + *F11*. To hit the breakpoint, add a breakpoint
    at the end of the method and click **Continue**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open the QML debugger console output pane to run JavaScript commands in the
    current context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the issues and watch the values while running your Qt Quick application.
    It will help you to find the portion of the code that is causing unexpected behavior
    and requires modification.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about debugging in a QML environment. In the next
    section, we will discuss the testing framework in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit testing** is a way of testing a simple application, class, or function
    using an automated tool. We will discuss what it is and why we would like to do
    it before going over how to incorporate it into our approach using Qt Test. Unit
    testing is the process of breaking down an application into its smallest functional
    units and then testing each unit with real-world situations within the initiative''s
    framework. A unit is the smallest component of an application that can be tested.
    A unit test in procedural programming usually focuses on a function or process.'
  prefs: []
  type: TYPE_NORMAL
- en: A unit in object-oriented programming is usually an interface, a class, or a
    single function. Unit testing identifies issues early in the implementation process.
    This covers glitches in the programmer's implementation as well as defects in
    or incomplete portions of the unit's specification. During the creation process,
    a unit test is a short code fragment developed by the developer of the unit to
    be tested. There are many unit testing tools to test your C++ code. Let's explore
    the benefits and features of Qt's testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing in Qt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Qt Test is a unit testing platform for Qt-based applications and libraries.
    Qt Test includes all of the features present in traditional unit testing applications,
    as well as plugins for testing graphical user interfaces. It helps make writing
    unit tests for Qt-based programs and libraries even easier. *Figure 9.6* shows
    the **Testing** section under **Options**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Screenshot showing Qt Test preferences under the Qt Creator
    Options menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.6_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – Screenshot showing Qt Test preferences under the Qt Creator Options
    menu
  prefs: []
  type: TYPE_NORMAL
- en: Previously, unit testing may have been done manually, especially for GUI testing,
    but now there is a tool that allows you to write code to validate code automatically,
    which might seem counterintuitive at first, but it works properly. Qt Test is
    a specialized testing framework for unit testing based on Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to add `testlib` in your project file (`.pro`) to use Qt''s built-in
    unit testing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run `qmake` to add the module available for your project. In order for
    the test system to find and implement it, you must use the `QTest` header and
    declare the test functions as private slots. The `QTest` header contains all functions
    and statements related to Qt Test. To use the `QTest` features, simply add the
    following line to your C++ file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should write test cases for every possible scenario, and then run the tests
    every time your baseline code changes to ensure that the system continues to behave
    as intended. It is an extremely useful tool for ensuring that any programming
    updates made don't break existing features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple test application using Qt Creator''s built-in wizard.
    Select **Auto Test Project** from the **New Project** menu as shown in *Figure
    9.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – New auto test project option in the project wizard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.7_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – New auto test project option in the project wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the test project skeleton is generated, you can modify the generated files
    to suit your needs. Open the `.pro` file of your test project and add the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a C++ class named `TestClass`. We will add our test functions
    to this class. This class must be derived from `QObject`. Let''s have a look at
    `tst_testclass.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have declared two test functions to test sample strings
    and values. You need to implement the test functions with a test scenario for
    the declared test cases. Let''s compare two strings and do a simple arithmetic
    operation. You can use macros such as `QCOMPARE` and `QVERIFY` to test the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute all the test cases, you have to add macros such as `QTEST_MAIN()`
    at the bottom of the file. The `QTEST_MAIN()` macro expands to a simple `main()`
    method that runs all the test functions. The `QTEST_APPLESS_MAIN()` macro is useful
    for simple standalone non-GUI tests where the `QApplication` object is not used.
    Use `QTEST_GUILESS_MAIN()` if the GUI is not required but an event loop is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the test case a standalone executable, we have added the `QTEST_APPLESS_MAIN()`
    macro and the `moc` generated file for the class. You may use a number of other
    macros to test the application. For further information, please visit the following
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://doc.qt.io/qt-6/qtest.html#macros](http://doc.qt.io/qt-6/qtest.html#macros%20)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the preceding example, you will see the output with the test results
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that one test case failed as it did not meet the test criteria.
    Similarly, you can add more test cases and fetch parameters from another class
    to test the functionality. You can also run all tests with the **Run All Tests**
    option from the **Tests** context menu from the Qt Creator menu bar as shown in
    *Figure 9.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Tests option under the Tools menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.8_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Tests option under the Tools menu
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also view all test cases in the left side project explorer view. Select
    **Tests** from the project explorer dropdown. You can enable or disable certain
    test cases in this window. *Figure 9.9* displays the two test cases we wrote earlier.
    You can also see that we are not using other test frameworks for this test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Tests explorer option in the project explorer dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.9_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Tests explorer option in the project explorer dropdown
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use several `QTest` convenient functions to simulate GUI events such
    as keyboard or mouse events. Let''s look at their usage with a simple code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the test code simulates a keyboard text `Enter` event
    on a `lineedit` control and then verifies the entered text. You can also simulate
    mouse-click events using `QTest::mouseClick()`. You can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Qt's Test framework is also useful in **test-driven development** (**TDD**).
    In TDD, you write a test first, then code the actual logic. The test will initially
    fail as there is no implementation. You then write the bare minimum code required
    to pass the test before moving on to the next test. This is how you iteratively
    develop a feature before you have implemented the necessary functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create test cases and simulate GUI interaction
    events. In the next section, you will learn how to use Google's C++ testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Google's C++ testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GoogleTest** is a testing and mocking framework developed by Google. The
    **GoogleMock** project has been merged into GoogleTest. GoogleTest requires a
    compiler that supports at least C++11 standards. It is a cross-platform test framework
    and it supports major desktop platforms such as Windows, Linux, and macOS. It
    helps you write better C++ tests with advanced features such as mocking. You can
    integrate Qt Test with GoogleTest to get the best of both frameworks. If you intend
    to use both testing framework features, then you should use GoogleTest as the
    primary testing framework and inside the test cases, you can use Qt Test''s features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt Creator has built-in support for GoogleTest. You can find the **Google Test**
    tab in the **Testing** section on the **Options** screen and set your global GoogleTest
    preferences as shown in *Figure 9.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – The Google Test tab in the Testing section under the Options
    menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.10_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – The Google Test tab in the Testing section under the Options menu
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the GoogleTest source code from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/google/googletest](https://github.com/google/googletest%20)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about features and their usage in the following documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://google.github.io/googletest/primer.html](https://google.github.io/googletest/primer.html%20)'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you download the source code, build the libraries before creating a sample
    application. You can also build the unified GoogleTest source code along with
    your test project. Once you generate the libraries, follow these steps to run
    your GoogleTest application:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a simple GoogleTest application using Qt Creator's built-in wizard,
    select **Auto Test Project** from the **New Project** menu. Then follow through
    the screens until you come across **Project and Test Information**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Project and Test Information** screen, select **Google Test** for **Test
    framework**. Then add information for the **Test suite name** and **Test case
    name** fields as shown in *Figure 9.11*:![Figure 9.11 – Google Test option in
    the project creation wizard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.11_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Google Test option in the project creation wizard
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, you can fill in the `.pro` file.![Figure 9.12 – Option to
    add the GoogleTest source directory in the project creation wizard
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_9.12_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Option to add the GoogleTest source directory in the project creation
    wizard
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** and follow the instructions to generate the skeleton of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use GoogleTest, you have to add the header file into your test project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the main function has already been created by the wizard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a simple test case with the following syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'GoogleTest also provides macros such as `ASSERT_*` and `EXPECT_*` to check
    conditions and values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In most cases, it is a standard procedure to do some custom initialization
    work before running multiple tests. If you want to evaluate a test''s time/memory
    footprint, you''ll have to write some test-specific code. Test fixtures help in
    setting up specific testing requirements. The `fixture` class is derived from
    the `::testing::Test` class. Please note that instead of `TEST`, the `TEST_F`
    macro is used. You can allocate resources and do initializations in the constructor
    or in the `SetUp()` function. Similarly, you can deallocate in the destructor
    or in the `TearDown()` function. A test function inside a text fixture is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To create and use a test fixture, create a class derived from the `::testing::Test`
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a custom push button inside the `SetUp()`
    function. Then we tested two test functions to test the size and *Enter* key handling.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the preceding test, you will see the test results in the output
    window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GoogleTest builds a new test fixture at runtime for each test specified with
    `TEST_F()`. It instantly initializes by calling the `SetUp()` function and runs
    the test. Then it calls `TearDown()` to do the cleanup, and removes the test fixture.
    It is important to note that different tests within the same test suite can have
    different test fixture objects. Before building the next test fixture, GoogleTest
    always deletes the previous one. It does not reuse test fixtures for multiple
    tests. Any modifications done to the fixture by one test have no effect on the
    other tests.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to create a GoogleTest project with a simple test case and
    how to design a test fixture or test suite. Now you can create test cases for
    your existing C++ application. GoogleTest is a very mature test framework. It
    also integrates the mocking mechanism that was earlier available under GoogleMock.
    Explore different features and experiment with test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a ready-made GUI tool that integrates both test frameworks to
    test your Qt application. **GTest Runner** is a Qt-based automated test runner
    and GUI with powerful features for Windows and Linux platforms. However, the code
    is not actively maintained and is not upgraded to Qt 6\. You can learn more about
    features and usages of GTest Runner at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/nholthaus/gtest-runner](https://github.com/nholthaus/gtest-runner%20)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to use `QTest` and `GoogleTest` together. You
    have seen the features of both testing frameworks. You can create mock objects
    using the GoogleMock feature of the GoogleTest framework. Now you can write your
    own test fixtures for a custom C++ class or custom widget. In the next section,
    we will discuss testing in Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Qt Quick applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TestCase` QML type. Functions with names beginning with `test_` are identified
    as test cases that need to be executed. The test harness recursively searches
    for the required source directory for `tst_ *.qml` files. You can keep all test
    `.qml` files under one directory and define the `QUICK_TEST_SOURCE_DIR`. If it
    is not defined, then only `.qml` files available in the current directory will
    be included during test execution. Qt doesn''t ensure binary compatibility for
    the Qt Quick Test module. You have to use the appropriate version of the module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to add `QUICK_TEST_MAIN()` to the C++ file to begin the execution
    of the test cases, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to add the `qmltest` module to enable Qt Quick Test. Add the following
    lines of code to the `.pro` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a demo of a basic arithmetic calculation to see how the module works.
    We will do some calculations such as addition, subtraction, and multiplication
    and intentionally make some mistakes so that test cases will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Please note that `cleanupTestCase()` is called right after the test execution
    has been completed. This function can be used to clean up before everything is
    destructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also perform data-driven tests as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that the table data can be provided to a test using a function
    name that ends with `_data`. When you run the preceding example, you will see
    the output with the test results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run benchmark tests in QML. The Qt benchmark framework will run
    functions with names that begin with `benchmark_` several times, with an average
    timing value recorded for the runs. It is similar to the `QBENCHMARK` macro in
    the C++ version of `benchmark_once_` to get the effect of the `QBENCHMARK_ONCE`
    macro. Let''s have a look at the following benchmarking example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are creating a custom QML element. We want to measure
    how much time it takes to create the element. Hence, we wrote the preceding benchmark
    code. A normal benchmark test runs multiple times and shows the duration of the
    operation. Here, we have benchmarked the creation once. This technique is very
    useful in evaluating the performance of your QML code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the benchmark multiple times, you can remove the `once` keyword from
    the test case as follows: `function benchmark_create_component() {...}`. You can
    also test dynamically created objects using `Qt.createQmlObject()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a benchmarking tool named **qmlbench** for benchmarking the overall
    performance of a Qt application. It is a feature-rich benchmarking tool available
    under **qt-labs**. The tool also helps in measuring the refresh rate of the user
    interface. You can explore more about this tool at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/qt-labs/qmlbench](https://github.com/qt-labs/qmlbench%20)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a C++ implementation, you can also simulate keyboard events such as `keyPress()`,
    `keyRelease()`, and `keyClick()` in QML. The events are delivered to the QML object
    that is currently being focused on. Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the keyboard event is delivered after the QML viewing
    window has been displayed. Attempts to deliver events before that will be unsuccessful.
    To keep track of when the window is shown, the `when` and `windowShown` properties
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use `SignalSpy` to watch signal emission. In the following example,
    we have used `SignalSpy` to detect the `clicked` signal on a `Button`. When the
    signal is emitted, the `clickSpy` count is increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding example, you will see the output with the test results
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QUICK_TEST_MAIN_WITH_SETUP` macro is used to execute C++ code before any
    of the QML tests are run. This can be useful for setting context properties on
    the QML engine. A test application can include several `TestCase` instances. The
    application terminates after running all test cases. You can enable or disable
    test cases from the **Tests** explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The Tests explorer showing Quick Test with the available test
    cases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.13_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – The Tests explorer showing Quick Test with the available test
    cases
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed different testing approaches to test a QML object.
    In the next section, we will get familiar with GUI testing and learn about a few
    popular tools.
  prefs: []
  type: TYPE_NORMAL
- en: GUI testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can easily evaluate one or more classes as unit tests, but we have to manually
    write all of the test cases. GUI testing is an especially challenging task. How
    can we document user interactions such as mouse clicks without coding them in
    C++ or QML? This question has baffled developers. There are a number of GUI testing
    tools available on the market that help us do this. Some of them are expensive,
    some of them are open source. We will discuss a few such tools in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you may not need a complete GUI testing framework. Some issues can
    be figured out with simple tricks. For example, while working with the GUI, you
    may also have to inspect different properties such as the alignment and boundaries
    of visual elements. One of the easiest ways is to add a `Rectangle` to inspect
    the boundary as shown in the next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding code snippet, you will see the GUI with element
    boundaries in colors as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Output of the visual boundaries of GUI elements using Rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.14_B16231.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – Output of the visual boundaries of GUI elements using Rectangle
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you can see that the text element is placed centrally
    inside the rectangle with a blue border. Without the blue border, you might have
    wondered why it was not centrally placed in the GUI. You can also see the boundaries
    and margins of each element. When the text element width is less than the font
    width, then you will observe clipping. You can also find whether there are any
    overlapping regions between user interface elements. In this way, you can find
    issues in a specific element of the GUI without using the `SG_VISUALIZE` environment
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss a few GUI testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Desktop Testing Project (LDTP)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Linux Desktop Testing Project** (**LDTP**) provides a high-quality test
    automation infrastructure and cutting-edge tools for testing and improving Linux
    desktop platforms. LDTP is a GUI testing framework that runs on all platforms.
    It pokes around in the application's user interface using the accessibility libraries.
    The framework also includes tools for recording test cases depending on how the
    user interacts with the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To click on a push button, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the current slider value of the given object, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To use LDTP for your GUI application, you must add an accessible name to all
    your QML objects. You can use object names as the accessible names as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added an accessible name to the QML control
    so that the LDTP tool can find this button. The LDTP requires the window name
    of the user interface to locate the child control. Let''s say the window name
    is **Example**, then to generate a click event, use the following command on the
    LDTP script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding LDTP command locates the `quitButton` and generates a button-click
    event.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about its features and uses at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://ldtp.freedesktop.org/user-doc/](https://ldtp.freedesktop.org/user-doc/%20)'
  prefs: []
  type: TYPE_NORMAL
- en: GammaRay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: KDAB developed a software introspection tool named `QObject` introspection mechanism.
    This works on a local machine as well as a remote embedded target. It extends
    the capabilities of the instruction-level debugger while adhering to the same
    standards as the underlying frameworks. This is particularly useful for complex
    projects that use frameworks such as scene graphs, model/view, state machine,
    and so on. There are several tools available to inspect the objects and their
    properties. However, it stands out from other tools with its in-depth association
    with Qt's complex framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download GammaRay from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/KDAB/GammaRay/wiki/Getting-GammaRay](https://github.com/KDAB/GammaRay/wiki/Getting-GammaRay%20)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about its features and uses at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.kdab.com/development-resources/qt-tools/gammaray/](https://www.kdab.com/development-resources/qt-tools/gammaray/%20)'
  prefs: []
  type: TYPE_NORMAL
- en: Squish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Squish** is a cross-platform GUI test automation tool for desktop, mobile,
    embedded, and web applications. You can automate GUI testing for your cross-platform
    application written with Qt Widgets or Qt Quick. Squish is used by thousands of
    organizations around the world to test their GUI with functional regression tests
    and system tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the tool at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.froglogic.com/squish/](https://www.froglogic.com/squish/%20)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed various GUI testing tools. Explore them and try
    them with your project. Let's summarize our learning in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned what debugging is and how to use different
    debugging techniques to identify technical issues in a Qt application. Apart from
    that, we've looked at the various debuggers that Qt supports on various operating
    systems. Finally, we learned how to use unit testing to simplify some of the debugging
    measures. We discussed unit testing, and you learned how to use the Qt Test framework.
    You saw how to debug a Qt Quick application. We also discussed various other testing
    frameworks and tools supported by Qt. Now you can write unit tests for your custom
    classes. The unit tests will fail and automatically alert if someone accidentally
    modifies some specific logic.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B16231_10_Final_ASB_ePub.xhtml#_idTextAnchor240), *Deploying
    Qt Applications*, you will learn about deploying Qt applications on various platforms.
    It will help you in creating installable packages for your target platform.
  prefs: []
  type: TYPE_NORMAL
