- en: Common Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those new to software development tend to focus their efforts on mastering the
    programming language. Once that barrier is passed, it is time to embrace **design
    patterns**, as writing high-quality and complex software is hardly possible without
    them. Mostly attributed to experienced developer use, design patterns represent
    a well established solution to common challenges faced in our applications. Successfully
    applying design patterns is likely to lead to more extensible, reusable, maintainable,
    and adaptable code.
  prefs: []
  type: TYPE_NORMAL
- en: The examples within this chapter are not meant to be copied and pasted. They
    merely serve a purpose of representing one possible implementation of design patterns.
    After all, real-life applications are all about details. Furthermore, there are
    plenty of other design patterns out there, with new ones being invented as technology
    and programming paradigms shift.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at a few possible implementations of design
    patterns in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: Base patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The registry pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object pool pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lazy initialization pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chain of responsibility pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the coming section, we will take a look at the base pattern: the registry
    pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The registry pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The registry pattern is an interesting one. It allows us to store and retrieve
    objects for later use. The process of storing and retrieving is based on the keys
    we define. Depending on the data scope, the association of keys and objects is
    made global across a process, thread, or a session, allowing us to retrieve the
    objects from anywhere within the data scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible registry pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Registry` class implementation has three key methods: `get()`, `set()`,
    `remove()`. The `set()` method allows graceful behavior based on the `$graceful`
    parameter; otherwise, it triggers the `RuntimeException` for the existing key.
    We also defined a `__destruct` method, as a sort of a cleanup mechanism that removes
    each item in the registry when the `$registry` instance is destroyed.'
  prefs: []
  type: TYPE_NORMAL
- en: Creational patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at the creational patterns, such as the
    singleton, prototype, abstract factory, and builder patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The singleton is among the first design patterns most developers learn. The
    goal of this design pattern is to limit the number of class instantiations to
    only one. What this means is that using the `new` keyword on a class will always
    return one and the same object instance. This is a powerful concept that allows
    us to implement all sorts of application-wide objects, such as loggers, mailers,
    registries, and other bits of functionality that we may want to act as singletons.
    However, as we will soon see, we will avoid the `new` keyword altogether, and
    instantiate an object via the static class method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible singleton pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Logger` class uses the static member `$instance` to keep an instance of
    one `self`, as per the implementation of the `getInstance()` method. We defined `__construct` as
    `protected` in order to prevent new instance creation via the `new` operator.
    The `__clone()` method was defined as `private` in order to prevent instance cloning
    via the `clone` operator. Similarly, the `__wakeup()` method was also defined
    as private, in order to prevent instance unserializing via the `unserialize()`
    function. These few simple restrictions make for a class that acts as a singleton.
    In order to fetch an instance, all it takes is calling the `getInstance()` class
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype pattern is about creating new objects by means of cloning them.
    This is quite a concept, as we are no longer using the `new` keyword to create
    new objects. The PHP language provides a special `clone` keyword to assist with
    object cloning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible prototype pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Normally, all it takes to clone an object is to use an expression such as `$clonedObj
    = clone $obj;`. This, however, does not give us any control over the cloning process.
    PHP objects can be heavy, with lots of members and references. Sometimes, we would
    like to impose certain limitations on the cloned object. This is where the magic `__clone()`
    method comes in handy. The `__clone()` method triggers after the cloning process
    is done, which is something to keep in mind for possible cleanup code implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract factory encapsulates a group of individual factories that have a common
    functionality. It does so without specifying their concrete classes. This makes
    it easier to write portable code, because clients can interchange concrete implementations
    without changing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible abstract factory pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating two simple interfaces, `Button` and `FormFactory`.
    The `Button` interface defines a single `render()` method, which we then implement
    through two concrete class implementations, `LoginButton` and `RegisterButton`.
    The two `FormFactory` implementations, `LoginFactory` and `RegisterFactory`, then
    instantiate the corresponding button classes as part of their `createButton()`
    method implementation. The client uses only the `LoginFactory` and `RegisterFactory`
    instances, thus avoiding directly instantiating concrete button classes.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The builder pattern is quite a handy one, especially when it comes to large applications.
    It separates the construction of a complex object from its representation. This
    makes it possible for the same construction process to create numerous representations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible *builder *pattern implementation
    using the `Image` class as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We started off with a simple Image class that provides width and height properties
    and corresponding getters and setters. We then created the `ImageBuilderInterface`
    interface, which defines the image width and height setter methods, along with
    the `getResult()` method. We then created an `ImageBuilder` concrete class that
    implements the `ImageBuilderInterface` interface. The client instantiates the `ImageBuilder` class.
    Another concrete class, `ImageBuildDirector`, wraps the creation or builder code
    within its `build()` method by working with the instance of `ImageBuilder` passed through
    its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The object pool pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The object pool pattern manages class instances--objects. It is used in situations
    where we would like to limit unnecessary class instantiation due to resource-intense
    operations. The object pool acts much like a registry for objects, from which
    clients can pick up necessary objects later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible object pool pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Using nothing but an array and two methods, we were able to implement a simple object
    pool. The `save()` method adds the object to the `$instances` array, while the
    `load()` method returns it to the client. The client, in this case, is in charge
    of keeping track of the key under which the object is saved. Objects themselves
    aren't destroyed after their use, as they remain in the pool.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through the behavioral patterns such as strategy,
    observer, lazy initialization, and chain of responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy pattern comes in handy where we have multiple chunks of code performing
    similar operations. It defines an encapsulated and interchangeable family of algorithms. Imagine
    an order checkout process where we want to implement different shipment providers,
    such as UPS and FedEx.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible strategy pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We started off by defining a `ShipmentStrategy` interface with a `calculate()`
    method. We then defined the `UPSShipment` and `FedExShipment` classes which implement
    the `ShipmentStrategy` interface. With these two concrete shipment classes in
    place, we made a `Checkout` class that encapsulates the two shipment options in
    its `estimateShipment()` method. The client then calls the `estimateShipment()`
    method on the `Checkout` instance. Depending on the amount passed on, a different
    shipment calculation kicks in. Using this pattern, we are free to add new shipment
    calculations without changing the client.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern is quite a popular one. It allows for an event subscription type
    of behavior. We differentiate the subject and observer(s) type of objects. The
    observer is an object subscribed to subject object state change. When the subject
    changes its state, it notifies all of its observers automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible observer pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The PHP `\SplSubject` and `\SplObserver` interfaces allow an observer pattern
    implementation. Our checkout success example uses these interfaces to implement `CheckoutSuccess`
    as a class for the subject type of object, and `Mailer` and `Logger` as classes
    for the observer type of object. Using the `attach()` method of a `CheckoutSuccess`
    instance, we attached both observers to the subject. Once the subject `notify()`
    method is called, the individual observer `update()` methods get triggered. The
    `getSalesOrder()` method calls might come as a surprise, as there is no actual
    `getSalesOrder()` method on direct instances of the `SplSubject` object. However,
    the two `update(\SplSubject $subject)` method calls in our example will be receiving
    an instance of `CheckoutSuccess`. Otherwise, type-casting the `$subject` argument
    directly to `CheckoutSuccess` would give us a PHP fatal error as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The lazy initialization pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The lazy initialization pattern is useful for addressing objects whose instantiation
    is likely to be resource-intense. The idea is to delay the actual resource intense
    operation until its result is actually required. The PDF generation is an example
    of a light to moderately resource-intense operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible lazy initialization pattern implementation
    based on PDF generation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Depending on how the class is constructed, it might trigger the actual generation
    right after we call the `new` keyword, as we have done with the `new Pdf(...)`
    expression.  `new ProxyPdf(...)` expression behaves differently because it wraps
    around the `Pdf` class implementing the same `PdfInterface`, but providing a different `__construct()`
    method implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The chain of responsibility pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chain of responsibility pattern allows us to chain code in a sender-receiver manner,
    while the two are decoupled from each other. This makes it possible to have more
    than one object handle incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible chain of responsibility pattern
    implementation using the logger functionality as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We started off by creating an abstract `Logger` class with three methods: `logNext()`,
    `push()`, and `log()`. The `log()` method was defined as abstract, which means
    the implementation is left to child classes. The `logNext()` method is the key
    ingredient as it moves the objects down the chain. We then created three concrete
    implementations of the `Logger` class: `SystemLogger`, `ElasticLogger`, and `MailLogger`.
    We then instantiated one of the concrete logger classes and passed the other two
    instances down the chain using the `logNext()` method. Finally, we called the
    `push()` method to trigger the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Structural patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at a structural pattern: the decorator
    pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern is a simple one. It allows us to add new behavior to object
    instances without affecting other instances of the same class. It basically acts
    as a decorating wrapper around our object. We can imagine a simple use case with
    a Logger class instance, where we have a simple logger class that we would like
    to occasionally decorate, or wrap into a more specific error, warning, and notice
    level logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a possible decorator pattern implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we started off by defining a `LoggerInterface` interface and a concrete
    `Logger` class that implements that interface. We then created an `abstract` `LoggerDecorator`
    class that also implements  `LoggerInterface`. `LoggerDecorator` does not really
    implement the `log()` method itself; it defines it as `abstract` for future child
    classes to implement. Finally, we defined the concrete error, warning, and notice
    decorator classes. We can see their `log()` methods decorate the output according
    to their roles. The resulting output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we took an introductory hands-on approach with some
    of the most common design patterns used in PHP applications. The list is far from
    final, as there are other design patterns available. While some design patterns
    are quite general, others might be more suitable for GUIs or other areas of application
    programming. Understanding how to use and apply design patterns makes our code
    more extensible, reusable, maintainable, and adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will take a closer look at building web services using SOAP,
    REST, and Apache Thrift.
  prefs: []
  type: TYPE_NORMAL
