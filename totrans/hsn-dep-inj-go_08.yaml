- en: Dependency Injection by Config
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过配置进行依赖注入
- en: In this chapter, we will be looking at **dependency injection** (**DI**) by
    config. Config injection is not a completely different method but an extension
    of both constructor injection and method injection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过配置来看**依赖注入**（**DI**）。配置注入不是一种完全不同的方法，而是构造函数注入和方法注入的扩展。
- en: It intends to address potential issues with those methods, such as excessive
    or repeated injected dependencies, without sacrificing the UX of our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它旨在解决这些方法可能存在的问题，比如过多或重复注入的依赖项，而不牺牲我们代码的用户体验。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Config injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置注入
- en: Advantages of config injection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置注入的优点
- en: Applying config injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用配置注入
- en: Disadvantages of config injection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置注入的缺点
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It would be beneficial to be familiar with the code for our service as we introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to ACME
    Registration Service*. This chapter also assumes that you have read [Chapter 6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency
    Injection with Constructor Injection*, and [Chapter 7](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Dependency
    Injection with Method Injection*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉我们在[第4章](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml)中介绍的服务代码将是有益的，*ACME注册服务简介*。本章还假设您已经阅读了[第6章](89c75571-2952-40fc-ba19-221b3114461b.xhtml)，*构造函数注入的依赖注入*，和[第7章](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml)，*方法注入的依赖注入*。
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现阅读和运行本章的完整代码版本很有用，可在[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08)找到。
- en: Instructions to obtain the code and configure the sample service are available
    in the README here: [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码并配置示例服务的说明可在此处的README中找到：[https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch08/acme`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`ch08/acme`中找到我们的服务代码，并已应用了本章的更改。
- en: Config injection
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置注入
- en: Config injection is a specific implementation of method and parameter injection.
    With config injection, we combine multiple dependencies and system-level config
    and merge them into a `config` interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 配置注入是方法和参数注入的特定实现。通过配置注入，我们将多个依赖项和系统级配置合并到一个`config`接口中。
- en: 'Consider the following constructor:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下构造函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we are injecting multiple dependencies, including a logger,
    instrumentation, rate limiter, cache, and some configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在注入多个依赖项，包括记录器、仪器、速率限制器、缓存和一些配置。
- en: It is safe to assume that we would be likely to inject at least the logger and
    the instrumentation into most of our objects in this same project. This results
    in a minimum of two parameters for every constructor. Across an entire system,
    this adds up to a lot of extra typing. It also detracts from the UX of our constructors
    by making them harder to read, and this potentially hides the significant parameters
    among the common ones.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地假设我们很可能会将记录器和仪器注入到这个项目中的大多数对象中。这导致每个构造函数至少有两个参数。在整个系统中，这将增加大量额外的输入。它还通过使构造函数更难阅读来减少了我们的构造函数的用户体验，并且可能会隐藏重要参数。
- en: Consider for a moment—where are the values for timeout and the number of workers
    that are likely to be defined? They are probably defined from some central source,
    such as a `config` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下——超时和工作人数的值可能定义在哪里？它们可能是从某个中央来源定义的，比如一个`config`文件。
- en: 'By applying config injection, our example becomes the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用配置注入，我们的示例变成了以下内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have merged the common concerns and the configuration together into the config
    definition but left the significant parameters intact. In this manner, the function
    parameters are still informative without having to read the `config` interface
    definition. In a way, we have hidden or encapsulated the common concerns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将常见问题和配置合并到配置定义中，但保留了重要参数。这样，函数参数仍然具有信息性，而无需阅读`config`接口定义。在某种程度上，我们隐藏或封装了常见问题。
- en: There is another usability aspect to consider—the config is now an interface.
    We should think about what kind of object would implement such an interface. Does
    such an object already exist? What are its responsibilities?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的另一个可用性方面是配置现在是一个接口。我们应该考虑哪种对象会实现这样的接口。这样的对象是否已经存在？它的责任是什么？
- en: Often config comes from a single source and its responsibilities are to load
    the config and provide access to it. Even though we are introducing the config
    interface to decouple from the actual config management, leveraging the fact that
    it's a single source is still convenient.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，配置来自单一来源，其责任是加载配置并提供对其的访问。即使我们引入配置接口以解耦实际的配置管理，利用它是单一来源仍然很方便。
- en: 'Consider the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code indicates that all of the parameters are coming from the same place.
    This is a good indication that they can be merged.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码表明所有参数都来自同一位置。这表明它们可以合并。
- en: If you come from an object-oriented background, you may be familiar with the
    concept of a service locator. Config injection is intentionally very similar.
    Unlike typical service locator usage, however, we are only extracting configuration
    and a few shared dependencies.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Config injection takes this approach to avoid the service locator's *God object* and
    inherent coupling between usage and the God object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of config injection
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that config injection is an expanded form of constructor and method injections,
    the advantages of the other methods also apply here. In this section, we will
    discuss only the additional benefits that are specific to this method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s excellent for decoupling from a config package**—When we have a `config`
    package that loads from a single place, such as a file, then this package tends
    to become a dependency for many of the other packages in the system. When considering
    the *Single responsibility principle* section from [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, we recognize that the more users a package or object
    has, the more resistant and/or difficult it is to change.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: With config injection, we are also defining our requirements in a local interface
    and leveraging Go's implicit interfaces and the **dependency inversion principle**
    (**DIP**) to keep the packages decoupled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps also make it significantly easier to test our structs. Consider
    the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, see the same code with config injection:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Yes, the amount of code is greater. However, we no longer have to manage test
    configuration files, which can often be a pain. Our tests are entirely self-contained
    and should have no concurrency problems, as they might with a global config object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**It eases the burden of injecting common concerns—**In the previous example,
    we are using config injection to inject the logging and instrumentation objects.
    Common concerns such as this are an excellent use for config injection as they
    are frequently needed but are not informative regarding the purpose of the function
    itself. They can be considered environmental dependencies. Due to their shared
    nature, another approach would be to turn them into global singletons instead
    of injecting them. Personally, I prefer to inject them as this gives me the opportunity
    to validate their usage. This in itself might feel weird, but in many cases, we
    build system monitoring and alerts from the existence or lack of instrumentation
    data, thereby making instrumentation part of the features or contract of our code
    and something we might want to protect from regression with tests.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**It improves usability by reducing parameters**—Similar to the previous advantage,
    applying config injection can enhance the usability of methods, particularly constructors,
    but reduce the number of parameters. Consider the following constructor:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now. take a look at the same constructor with config injection:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the environmental dependencies removed from the constructor definition,
    we are left with significantly fewer parameters. Even more than that, the only parameters
    that remain are those that are specific to the purpose, hence making the method
    simpler to understand and use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency creation can be deferred until use**—Have you ever tried to inject
    a dependency, only to find that it didn''t exist or wasn''t ready yet? Have you
    ever had a dependency that was so expensive to start or run that you wanted to
    create it only when it was absolutely necessary?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: With config injection, dependency creation, and access only need to be resolved
    at the point of usage and not during injection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, I mentioned there were a couple of issues that I really wanted us
    to fix with our ACME registration service. In this section, we are going to use
    config injection to deal with two of them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The first is the fact that many of our packages depend on the `config` and `logging`
    packages, and other than being a substantial single responsibility principle violation,
    this coupling is likely to cause circular dependency problems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The second is our inability to test our calls to the exchange rate without actually
    calling the upstream service. So far, we have avoided adding any tests to this
    package for fear that our tests would then be affected (in terms of speed and
    stability) by that service.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s examine where we are. Our dependency graph currently looks as
    shown in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d30373a7-5e67-4c58-bb09-275f904f343b.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have four packages (`data`, `register`, `exchange`, and `main`) depending
    on the `config` package and five (`data`, `register`, `exchange`, `rest`, and
    `config`) that rely on the `logging` package. What is perhaps worse is how these
    packages depend on the `config` and `logging` packages. Currently, they directly
    access public singletons. This means that when we want to test our logger usage
    or swap out some configuration during testing, we would have to monkey patch and
    this would cause a data race instability in the tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: To address this, we are going to define one config for each of our objects.
    Each config will include the logger and any other configuration that it needs.
    Then, we replace any direct links to the global variables with references to the
    injected config.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This will result in a bit of shotgun surgery (a lot of little changes), but
    the code will be a lot better for it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We will go through only one set of changes here; if you wish to see all of them,
    please review the source code for this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection to the model layer
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Revisiting our `register` package, we see that it has references to both config
    and logging:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our first step is to define an interface that will supply the dependencies
    we need:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Do you see anything wrong with this? The first thing that jumps out is the fact
    that our `Logger()` method returns a pointer to a logger implementation. This
    will work, but it's not very future proof or testable. We could define a `logging`
    interface locally and decouple ourselves entirely from the `logging` package.
    This would mean, however, that we would have to define a `logging` interface in
    most of our packages. Theoretically, this is the best option, but it is not very
    practical. Instead, we could define one `logging` interface and have all of the
    packages depend upon that. While this will mean that we still remained coupled
    to the `logging` package, we will rely on an interface that seldom changes, rather
    than an implementation that is far more likely to change.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The second potential issue is the naming of the other method, `BasePrice()`,
    because it's somewhat generic, and a potential source of confusion later on. It
    is also the name of the field in the `Config` struct but Go will not allow us
    to have a member variable and method with the same name, so we will need to change
    that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'After updating our `config` interface, we have the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now apply config injection to our `Registerer`, giving us the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I have also added a convenience method, `logger()`, to reduce the code from
    `r.cfg.Logger()` to just `r.logger()`. Our service and tests are currently broken,
    so we have more changes to make.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the tests going again, we need to define a test configuration and update
    our tests. For our test configuration, we could use mockery and create a mock
    implementation, but we are not interested in validating our config usage or adding
    extra code to all of the tests in this package to configure the mock. Instead,
    we are going to use a stub implementation that returns predictable values. Here
    is our stub test config:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And add this test config to all of our `Registerer` tests, as shown in the
    following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our tests are running again, but strangely, while our service compiles, it
    would crash with a `nil` pointer exception if we were to run it. We need to update
    the creation of our `Registerer` from the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We change it to this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This leads us to the next problem. The `config.App` struct does not implement
    the methods we need. Adding these methods to `config`, we get the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With these changes, we have severed the dependency link between the `registration`
    package and the `config` package. In the `Logger()` method we have illustrated
    previously, you can see we are still using the logger as a singleton, but instead
    of being a global public variable, which would be prone to data races, it's now
    inside the `config` object. On the surface, this might not seem like it made any
    difference; however, the data races we were primarily concerned about were during
    testing. Our object now relies on an injected version of the logger and is not
    required to use the global public variable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we examine our updated dependency graph to see where to go next:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73430c51-07d8-429f-b4bb-5284a9955b5b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: We are down to three links into the `config` package; that is, those from the
    `main`, `data`, and `exchange` packages. The link from the `main` package cannot
    be removed, hence, we can ignore that. So, let's look into the `data` package.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection to the data package
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `data` package is currently based on functions, and as such, the changes
    are going to be a little different compared to the previous ones. Here is a typical
    function from the `data` package:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this function, we have references to the logger which we want to remove,
    and one configuration that we really need to extract. The config is required by
    the first line of the function from the previous code. Here is the `getDB()` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have a reference to the `DSN` to create the database pool. So, what do you
    think our first step should be?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous change, let''s first define an interface that includes
    all of the dependencies and configuration that we want to inject:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s update our functions to inject the `config` interface:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Unfortunately, this change is going to break a lot of things as `getDB()` is
    called by all of the public functions in the `data` package, which are in turn
    called by the model layer packages. Thankfully, we have enough unit tests to help
    prevent regression while working through the changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d like to ask you to stop for a moment and consider this: we are attempting
    to make what should be an insignificant change, but it''s causing a mass of small
    changes. Additionally, we are being forced to add one parameter to every public
    function in this package. How does this make you feel about the decision to build
    this package based on functions? Refactoring away from functions would be no small
    task, but do you think it would be worth it?'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The changes to the model layer are small, but interesting, thanks to the fact
    that we have already updated the model layer with config injection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only have two small changes to make:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We will add the `DataDSN()` method to our config
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to pass the config down to data package via the `loader()` call
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code with the changes applied:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sadly, we need to make these small changes in all of our model layer packages.
    After that is done, our dependency graph now looks as shown in the following diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25ae83b5-f5b4-4769-8d43-c4541008f54b.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Fantastic. There is only one unnecessary connection to the `config` package
    left, and it comes from the `exchange` package.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection to the exchange package
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can apply config injection to the `exchange` package as we have with the
    other packages, using the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Define an interface that includes the dependencies and config that we want to
    inject
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define/update the constructor to accept the `config` interface
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the injected config as a member variable
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the references (for example, to `config` and `logger`) to point to the
    member variable
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the other layer `config` interfaces to include anything new
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we have applied config injection to the `exchange` package, an unusual
    situation emerges. Our dependency graph shows that we have removed the link from
    the `exchange` to `config` packages, as can be seen in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/408cc23b-7cbb-43f5-8ec6-a07ba2ffd63f.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'For our tests to remain working, however, we still need to reference the config,
    as shown in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Stepping back for a moment, we notice that the tests we are referring to are
    not tests on the `exchange` package, but for its user, the `register` package.
    This is quite the red flag. We can quickly fix the first part of this problem
    by applying constructor injection to the relationship between these two packages.
    We can then mock or stub the calls to the exchanger.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also undo some of our earlier changes to the register `Config` interface,
    removing the `exchange` package related methods and bringing us back to this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This finally allows us to remove the link from our `register` tests to the `config`
    package and, perhaps more importantly, allows us to decouple our test from the
    external exchange rate service.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: When we started this section, we defined two goals. Firstly, to decouple from
    the `config` package and the `logging` package, and secondly, to be able to test
    without calling the external service. So far, we have managed to decouple from
    the `config` package completely. We have removed the usage of the global public
    logger from all packages except the `config` package, and we have also removed
    our dependence on the external exchange rate service.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Our service still depends on that external service, however, and we have absolutely
    no tests that verify that we call it correctly or that prove the service responds
    as we expect it to. These tests are called **boundary tests**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Boundary tests
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boundary tests come in two forms, each with their own goal—internal-facing and
    external-facing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Internal-facing boundary tests are designed to validate two things:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: That our code calls the external service in the way that we expect it to
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That our code reacts to all responses, happy path and errors, from the external
    service in the way that we expect it to
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As such, internal-facing boundary tests do not interact with the external service,
    but rather with a mock or stub implementation of the external service.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: External-facing boundary tests are the opposite. They interact with the external
    service and verify that the external service performs as we need it to. Please
    note that they do not validate the external service's API contract, nor does the
    service act as its owner expects it to. Instead, however, they focus only on our
    requirements. External boundary tests are, by nature, going to be slower and less
    reliable than unit tests. As such, we may prefer not to run them all the time.
    We can use Go's build flags to achieve this.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding external facing boundary tests to our service. We could
    write a test that contains HTTP calls to the external service in the format suggested
    by the service's documentation and then validates the responses. If we were unfamiliar
    with this service and had not yet built the code that calls the service, this
    is also an excellent way to learn about the external service.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, however, we have already written the code, so the faster option
    is to call that code with *live* config. Doing that returns a JSON payload that
    looks similar to the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While the format of the response is predictable, the `timestamp` and `quotes`
    values will change. So, what can we test? Perhaps, more importantly, what parts
    of the response do we depend on? After closer examination of our code, we realize
    that out of all of the fields in the response, the only one we use is the `quotes`
    map. Additionally, the only thing we require from the external service is that
    the currency we requested exists in that map and the value is of the `float64`
    type. Therefore, by only testing for these specific attributes, our tests will
    be as resilient to changes as possible.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a test that looks like the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To ensure that this test only runs when we want it to, we put the following
    build tag at the top of the file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, that let''s look at internal facing boundary tests. The first step is
    to make ourselves a mock implementation of the external service. We have the resulting
    payload, as mentioned previously. To do this, we will use the `httptest` package
    to create an HTTP server that returns our test payload, like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For now, it returns a fixed response and does nothing to validate the request.
    We can now build our internal-facing boundary test. Unlike the external-facing
    boundary test, the result is now entirely controlled by us and is therefore predictable.
    We can, therefore, test the exact result, as shown in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now have a basic internal facing boundary test. We are able to verify, without
    depending on the external service, that the external service returns the payload
    we expect and we are able to extract and use the result correctly. We can further
    extend our tests to cover more scenarios, including the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: A test that verifies our code and returns a sensible error when the external
    service is down or slow
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test that proves our code returns a sensible error when the external service
    returns an empty or invalid response
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test that validates the HTTP request that our code performs
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our internal-facing boundary tests in place, we finally have tests on our
    exchange rate code. We have managed to ensure that our code works as intended,
    with tests that are reliable and entirely controlled by us. Additionally, we have
    external boundary tests that we can occasionally run to inform us of any changes
    to the external service that will break our service.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of config injection
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, config injection can be used with both constructors and functions,
    It is, therefore, possible to build a system with only config injection. Unfortunately,
    config injection does have some disadvantages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing config instead of abstract dependencies leaks implementation details**—Consider
    the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this example, the `PeopleFilter` function is aware of the fact that `PersonLoader`
    is a database. This might not seem like a big deal, and if the implementation
    strategy never changes, it will have no adverse impact. Should we shift from a
    database to an external service or anything else, however, we would then have
    to change our `PersonLoader` database as well. A more future-proof implementation
    would be as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This implementation is unlikely to require changes should we change where our
    data is loaded from.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency life cycles are less predictable**—In the advantages, we stated
    that dependency creation can be deferred until use. Your inner critic may have
    rebelled against that assertion, and for a good reason. It is an advantage, but
    it also makes the life cycle of the dependency less predictable. When using constructor
    injection or method injection, the dependency must exist before it is injected.
    Due to this, any issues with the creation or initialization of the dependency
    surfaces at this earlier time. When the dependency is initialized at some unknown
    later point, a couple of issues can arise.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, if the issue is unrecoverable or causes the system to panic, this would
    mean the system initially seems healthy and then becomes unhealthy or crashes
    unpredictably. This unpredictability can lead to issues that are extremely hard
    to debug.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, if the initialization of the dependency includes the possibility
    of a delay, we have to be aware of, and account for, any such delay. Consider
    the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now compare this to an implementation that assumes the pool is ready before
    injection:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What would happen if this function were a part of an endpoint with a latency
    budget? If the startup delay is greater than the latency budget, then the first
    request would always fail.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Over-use degrades the UX**—While I strongly recommended that you only use
    this pattern for configuration and environmental dependencies such as instrumentation,
    it is possible to apply this pattern in many other places. By pushing the dependencies
    into a `config` interface, however, they become less apparent, and we have a larger
    interface to implement. Let''s re-examine an earlier example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Consider the rate limiter dependency. What happens if we merge that into the
    `Config` interface? It becomes less apparent that this object uses and relies
    on a rate limiter. If every similar function has rate limiting, then this will
    be less of a problem as its usage becomes more environmental.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The other less visible aspect is configuration. The configuration of the rate
    limiter is likely not consistent across all usages. This is a problem when all
    of the other dependencies and config are coming from a shared object. We could
    compose the config object and customize the rate limiter returned, but this feels
    like over-engineering.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '**Changes can ripple through the software layers** - This issue only applies
    when the config passed through the layers. Consider the following example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this structure, when we need to add a new configuration or dependency to
    the `Layer2Config` interface, we would also be forced to add it to the `Layer1Config`
    interface. `Layer1Config` would then be in violation of the interface segregation
    principle as discussed in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, which indicates that we might have a problem. Additionally,
    depending on the code's layering and level of reuse, the number of changes could
    be significant. In this case, a better option would be to apply constructor injection
    to inject `Layer2Object` into `Layer1Object`. This would completely decouple the
    objects and remove the need for the layered changes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have leveraged config injection, an extended version of
    constructor and method injection, to improve the UX of our code, primarily by
    handling the environmental dependencies and config separately from the contextually
    significant dependencies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: While applying config injection to our sample service, we have decoupled all
    possible packages from the `config` package, giving it more freedom to evolve
    over time. We also switched most of the logger usage from a global public variable
    to an injected abstract dependency by removing any possibility of a data race
    relating to the logger instance and enabling us to test logger usage without any
    messy monkey patching.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine another unusual form of dependency injection,
    called **Just-in-time** (**JIT**) **dependency injection**. With this technique,
    we will reduce the burden associated with dependency creation and injection between
    the layers without sacrificing our ability to test with mocks and stubs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does config injection differ from method or constructor injection?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we decide what parameters to move to config injection?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why don't we inject all dependencies via config injection?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we want to inject environmental dependencies (such as loggers) instead
    of using a global public variable?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are boundary tests important?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ideal use cases for config injection?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置注入的理想使用案例是什么？
