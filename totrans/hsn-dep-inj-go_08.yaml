- en: Dependency Injection by Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at **dependency injection** (**DI**) by
    config. Config injection is not a completely different method but an extension
    of both constructor injection and method injection.
  prefs: []
  type: TYPE_NORMAL
- en: It intends to address potential issues with those methods, such as excessive
    or repeated injected dependencies, without sacrificing the UX of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Config injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of config injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying config injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of config injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service as we introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to ACME
    Registration Service*. This chapter also assumes that you have read [Chapter 6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency
    Injection with Constructor Injection*, and [Chapter 7](4195d787-7029-4d99-aba4-ed93e8a30fda.xhtml), *Dependency
    Injection with Method Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch08).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to obtain the code and configure the sample service are available
    in the README here: [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/)
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch08/acme`.
  prefs: []
  type: TYPE_NORMAL
- en: Config injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Config injection is a specific implementation of method and parameter injection.
    With config injection, we combine multiple dependencies and system-level config
    and merge them into a `config` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are injecting multiple dependencies, including a logger,
    instrumentation, rate limiter, cache, and some configuration.
  prefs: []
  type: TYPE_NORMAL
- en: It is safe to assume that we would be likely to inject at least the logger and
    the instrumentation into most of our objects in this same project. This results
    in a minimum of two parameters for every constructor. Across an entire system,
    this adds up to a lot of extra typing. It also detracts from the UX of our constructors
    by making them harder to read, and this potentially hides the significant parameters
    among the common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Consider for a moment—where are the values for timeout and the number of workers
    that are likely to be defined? They are probably defined from some central source,
    such as a `config` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'By applying config injection, our example becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have merged the common concerns and the configuration together into the config
    definition but left the significant parameters intact. In this manner, the function
    parameters are still informative without having to read the `config` interface
    definition. In a way, we have hidden or encapsulated the common concerns.
  prefs: []
  type: TYPE_NORMAL
- en: There is another usability aspect to consider—the config is now an interface.
    We should think about what kind of object would implement such an interface. Does
    such an object already exist? What are its responsibilities?
  prefs: []
  type: TYPE_NORMAL
- en: Often config comes from a single source and its responsibilities are to load
    the config and provide access to it. Even though we are introducing the config
    interface to decouple from the actual config management, leveraging the fact that
    it's a single source is still convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code indicates that all of the parameters are coming from the same place.
    This is a good indication that they can be merged.
  prefs: []
  type: TYPE_NORMAL
- en: If you come from an object-oriented background, you may be familiar with the
    concept of a service locator. Config injection is intentionally very similar.
    Unlike typical service locator usage, however, we are only extracting configuration
    and a few shared dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Config injection takes this approach to avoid the service locator's *God object* and
    inherent coupling between usage and the God object.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of config injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that config injection is an expanded form of constructor and method injections,
    the advantages of the other methods also apply here. In this section, we will
    discuss only the additional benefits that are specific to this method.
  prefs: []
  type: TYPE_NORMAL
- en: '**It''s excellent for decoupling from a config package**—When we have a `config`
    package that loads from a single place, such as a file, then this package tends
    to become a dependency for many of the other packages in the system. When considering
    the *Single responsibility principle* section from [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, we recognize that the more users a package or object
    has, the more resistant and/or difficult it is to change.'
  prefs: []
  type: TYPE_NORMAL
- en: With config injection, we are also defining our requirements in a local interface
    and leveraging Go's implicit interfaces and the **dependency inversion principle**
    (**DIP**) to keep the packages decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps also make it significantly easier to test our structs. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, see the same code with config injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Yes, the amount of code is greater. However, we no longer have to manage test
    configuration files, which can often be a pain. Our tests are entirely self-contained
    and should have no concurrency problems, as they might with a global config object.
  prefs: []
  type: TYPE_NORMAL
- en: '**It eases the burden of injecting common concerns—**In the previous example,
    we are using config injection to inject the logging and instrumentation objects.
    Common concerns such as this are an excellent use for config injection as they
    are frequently needed but are not informative regarding the purpose of the function
    itself. They can be considered environmental dependencies. Due to their shared
    nature, another approach would be to turn them into global singletons instead
    of injecting them. Personally, I prefer to inject them as this gives me the opportunity
    to validate their usage. This in itself might feel weird, but in many cases, we
    build system monitoring and alerts from the existence or lack of instrumentation
    data, thereby making instrumentation part of the features or contract of our code
    and something we might want to protect from regression with tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '**It improves usability by reducing parameters**—Similar to the previous advantage,
    applying config injection can enhance the usability of methods, particularly constructors,
    but reduce the number of parameters. Consider the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now. take a look at the same constructor with config injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the environmental dependencies removed from the constructor definition,
    we are left with significantly fewer parameters. Even more than that, the only parameters
    that remain are those that are specific to the purpose, hence making the method
    simpler to understand and use.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency creation can be deferred until use**—Have you ever tried to inject
    a dependency, only to find that it didn''t exist or wasn''t ready yet? Have you
    ever had a dependency that was so expensive to start or run that you wanted to
    create it only when it was absolutely necessary?'
  prefs: []
  type: TYPE_NORMAL
- en: With config injection, dependency creation, and access only need to be resolved
    at the point of usage and not during injection.
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, I mentioned there were a couple of issues that I really wanted us
    to fix with our ACME registration service. In this section, we are going to use
    config injection to deal with two of them.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the fact that many of our packages depend on the `config` and `logging`
    packages, and other than being a substantial single responsibility principle violation,
    this coupling is likely to cause circular dependency problems.
  prefs: []
  type: TYPE_NORMAL
- en: The second is our inability to test our calls to the exchange rate without actually
    calling the upstream service. So far, we have avoided adding any tests to this
    package for fear that our tests would then be affected (in terms of speed and
    stability) by that service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s examine where we are. Our dependency graph currently looks as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d30373a7-5e67-4c58-bb09-275f904f343b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have four packages (`data`, `register`, `exchange`, and `main`) depending
    on the `config` package and five (`data`, `register`, `exchange`, `rest`, and
    `config`) that rely on the `logging` package. What is perhaps worse is how these
    packages depend on the `config` and `logging` packages. Currently, they directly
    access public singletons. This means that when we want to test our logger usage
    or swap out some configuration during testing, we would have to monkey patch and
    this would cause a data race instability in the tests.
  prefs: []
  type: TYPE_NORMAL
- en: To address this, we are going to define one config for each of our objects.
    Each config will include the logger and any other configuration that it needs.
    Then, we replace any direct links to the global variables with references to the
    injected config.
  prefs: []
  type: TYPE_NORMAL
- en: This will result in a bit of shotgun surgery (a lot of little changes), but
    the code will be a lot better for it.
  prefs: []
  type: TYPE_NORMAL
- en: We will go through only one set of changes here; if you wish to see all of them,
    please review the source code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection to the model layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Revisiting our `register` package, we see that it has references to both config
    and logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first step is to define an interface that will supply the dependencies
    we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Do you see anything wrong with this? The first thing that jumps out is the fact
    that our `Logger()` method returns a pointer to a logger implementation. This
    will work, but it's not very future proof or testable. We could define a `logging`
    interface locally and decouple ourselves entirely from the `logging` package.
    This would mean, however, that we would have to define a `logging` interface in
    most of our packages. Theoretically, this is the best option, but it is not very
    practical. Instead, we could define one `logging` interface and have all of the
    packages depend upon that. While this will mean that we still remained coupled
    to the `logging` package, we will rely on an interface that seldom changes, rather
    than an implementation that is far more likely to change.
  prefs: []
  type: TYPE_NORMAL
- en: The second potential issue is the naming of the other method, `BasePrice()`,
    because it's somewhat generic, and a potential source of confusion later on. It
    is also the name of the field in the `Config` struct but Go will not allow us
    to have a member variable and method with the same name, so we will need to change
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'After updating our `config` interface, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now apply config injection to our `Registerer`, giving us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I have also added a convenience method, `logger()`, to reduce the code from
    `r.cfg.Logger()` to just `r.logger()`. Our service and tests are currently broken,
    so we have more changes to make.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the tests going again, we need to define a test configuration and update
    our tests. For our test configuration, we could use mockery and create a mock
    implementation, but we are not interested in validating our config usage or adding
    extra code to all of the tests in this package to configure the mock. Instead,
    we are going to use a stub implementation that returns predictable values. Here
    is our stub test config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And add this test config to all of our `Registerer` tests, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our tests are running again, but strangely, while our service compiles, it
    would crash with a `nil` pointer exception if we were to run it. We need to update
    the creation of our `Registerer` from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This leads us to the next problem. The `config.App` struct does not implement
    the methods we need. Adding these methods to `config`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With these changes, we have severed the dependency link between the `registration`
    package and the `config` package. In the `Logger()` method we have illustrated
    previously, you can see we are still using the logger as a singleton, but instead
    of being a global public variable, which would be prone to data races, it's now
    inside the `config` object. On the surface, this might not seem like it made any
    difference; however, the data races we were primarily concerned about were during
    testing. Our object now relies on an injected version of the logger and is not
    required to use the global public variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we examine our updated dependency graph to see where to go next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73430c51-07d8-429f-b4bb-5284a9955b5b.png)'
  prefs: []
  type: TYPE_IMG
- en: We are down to three links into the `config` package; that is, those from the
    `main`, `data`, and `exchange` packages. The link from the `main` package cannot
    be removed, hence, we can ignore that. So, let's look into the `data` package.
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection to the data package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `data` package is currently based on functions, and as such, the changes
    are going to be a little different compared to the previous ones. Here is a typical
    function from the `data` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we have references to the logger which we want to remove,
    and one configuration that we really need to extract. The config is required by
    the first line of the function from the previous code. Here is the `getDB()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have a reference to the `DSN` to create the database pool. So, what do you
    think our first step should be?
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous change, let''s first define an interface that includes
    all of the dependencies and configuration that we want to inject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s update our functions to inject the `config` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this change is going to break a lot of things as `getDB()` is
    called by all of the public functions in the `data` package, which are in turn
    called by the model layer packages. Thankfully, we have enough unit tests to help
    prevent regression while working through the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d like to ask you to stop for a moment and consider this: we are attempting
    to make what should be an insignificant change, but it''s causing a mass of small
    changes. Additionally, we are being forced to add one parameter to every public
    function in this package. How does this make you feel about the decision to build
    this package based on functions? Refactoring away from functions would be no small
    task, but do you think it would be worth it?'
  prefs: []
  type: TYPE_NORMAL
- en: The changes to the model layer are small, but interesting, thanks to the fact
    that we have already updated the model layer with config injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only have two small changes to make:'
  prefs: []
  type: TYPE_NORMAL
- en: We will add the `DataDSN()` method to our config
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to pass the config down to data package via the `loader()` call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the code with the changes applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Sadly, we need to make these small changes in all of our model layer packages.
    After that is done, our dependency graph now looks as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25ae83b5-f5b4-4769-8d43-c4541008f54b.png)'
  prefs: []
  type: TYPE_IMG
- en: Fantastic. There is only one unnecessary connection to the `config` package
    left, and it comes from the `exchange` package.
  prefs: []
  type: TYPE_NORMAL
- en: Applying config injection to the exchange package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can apply config injection to the `exchange` package as we have with the
    other packages, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define an interface that includes the dependencies and config that we want to
    inject
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define/update the constructor to accept the `config` interface
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the injected config as a member variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the references (for example, to `config` and `logger`) to point to the
    member variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the other layer `config` interfaces to include anything new
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we have applied config injection to the `exchange` package, an unusual
    situation emerges. Our dependency graph shows that we have removed the link from
    the `exchange` to `config` packages, as can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/408cc23b-7cbb-43f5-8ec6-a07ba2ffd63f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For our tests to remain working, however, we still need to reference the config,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Stepping back for a moment, we notice that the tests we are referring to are
    not tests on the `exchange` package, but for its user, the `register` package.
    This is quite the red flag. We can quickly fix the first part of this problem
    by applying constructor injection to the relationship between these two packages.
    We can then mock or stub the calls to the exchanger.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also undo some of our earlier changes to the register `Config` interface,
    removing the `exchange` package related methods and bringing us back to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This finally allows us to remove the link from our `register` tests to the `config`
    package and, perhaps more importantly, allows us to decouple our test from the
    external exchange rate service.
  prefs: []
  type: TYPE_NORMAL
- en: When we started this section, we defined two goals. Firstly, to decouple from
    the `config` package and the `logging` package, and secondly, to be able to test
    without calling the external service. So far, we have managed to decouple from
    the `config` package completely. We have removed the usage of the global public
    logger from all packages except the `config` package, and we have also removed
    our dependence on the external exchange rate service.
  prefs: []
  type: TYPE_NORMAL
- en: Our service still depends on that external service, however, and we have absolutely
    no tests that verify that we call it correctly or that prove the service responds
    as we expect it to. These tests are called **boundary tests**.
  prefs: []
  type: TYPE_NORMAL
- en: Boundary tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boundary tests come in two forms, each with their own goal—internal-facing and
    external-facing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internal-facing boundary tests are designed to validate two things:'
  prefs: []
  type: TYPE_NORMAL
- en: That our code calls the external service in the way that we expect it to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That our code reacts to all responses, happy path and errors, from the external
    service in the way that we expect it to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As such, internal-facing boundary tests do not interact with the external service,
    but rather with a mock or stub implementation of the external service.
  prefs: []
  type: TYPE_NORMAL
- en: External-facing boundary tests are the opposite. They interact with the external
    service and verify that the external service performs as we need it to. Please
    note that they do not validate the external service's API contract, nor does the
    service act as its owner expects it to. Instead, however, they focus only on our
    requirements. External boundary tests are, by nature, going to be slower and less
    reliable than unit tests. As such, we may prefer not to run them all the time.
    We can use Go's build flags to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding external facing boundary tests to our service. We could
    write a test that contains HTTP calls to the external service in the format suggested
    by the service's documentation and then validates the responses. If we were unfamiliar
    with this service and had not yet built the code that calls the service, this
    is also an excellent way to learn about the external service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, however, we have already written the code, so the faster option
    is to call that code with *live* config. Doing that returns a JSON payload that
    looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While the format of the response is predictable, the `timestamp` and `quotes`
    values will change. So, what can we test? Perhaps, more importantly, what parts
    of the response do we depend on? After closer examination of our code, we realize
    that out of all of the fields in the response, the only one we use is the `quotes`
    map. Additionally, the only thing we require from the external service is that
    the currency we requested exists in that map and the value is of the `float64`
    type. Therefore, by only testing for these specific attributes, our tests will
    be as resilient to changes as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us a test that looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that this test only runs when we want it to, we put the following
    build tag at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, that let''s look at internal facing boundary tests. The first step is
    to make ourselves a mock implementation of the external service. We have the resulting
    payload, as mentioned previously. To do this, we will use the `httptest` package
    to create an HTTP server that returns our test payload, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, it returns a fixed response and does nothing to validate the request.
    We can now build our internal-facing boundary test. Unlike the external-facing
    boundary test, the result is now entirely controlled by us and is therefore predictable.
    We can, therefore, test the exact result, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a basic internal facing boundary test. We are able to verify, without
    depending on the external service, that the external service returns the payload
    we expect and we are able to extract and use the result correctly. We can further
    extend our tests to cover more scenarios, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A test that verifies our code and returns a sensible error when the external
    service is down or slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test that proves our code returns a sensible error when the external service
    returns an empty or invalid response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A test that validates the HTTP request that our code performs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With our internal-facing boundary tests in place, we finally have tests on our
    exchange rate code. We have managed to ensure that our code works as intended,
    with tests that are reliable and entirely controlled by us. Additionally, we have
    external boundary tests that we can occasionally run to inform us of any changes
    to the external service that will break our service.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of config injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, config injection can be used with both constructors and functions,
    It is, therefore, possible to build a system with only config injection. Unfortunately,
    config injection does have some disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing config instead of abstract dependencies leaks implementation details**—Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `PeopleFilter` function is aware of the fact that `PersonLoader`
    is a database. This might not seem like a big deal, and if the implementation
    strategy never changes, it will have no adverse impact. Should we shift from a
    database to an external service or anything else, however, we would then have
    to change our `PersonLoader` database as well. A more future-proof implementation
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is unlikely to require changes should we change where our
    data is loaded from.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency life cycles are less predictable**—In the advantages, we stated
    that dependency creation can be deferred until use. Your inner critic may have
    rebelled against that assertion, and for a good reason. It is an advantage, but
    it also makes the life cycle of the dependency less predictable. When using constructor
    injection or method injection, the dependency must exist before it is injected.
    Due to this, any issues with the creation or initialization of the dependency
    surfaces at this earlier time. When the dependency is initialized at some unknown
    later point, a couple of issues can arise.'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, if the issue is unrecoverable or causes the system to panic, this would
    mean the system initially seems healthy and then becomes unhealthy or crashes
    unpredictably. This unpredictability can lead to issues that are extremely hard
    to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, if the initialization of the dependency includes the possibility
    of a delay, we have to be aware of, and account for, any such delay. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare this to an implementation that assumes the pool is ready before
    injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What would happen if this function were a part of an endpoint with a latency
    budget? If the startup delay is greater than the latency budget, then the first
    request would always fail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Over-use degrades the UX**—While I strongly recommended that you only use
    this pattern for configuration and environmental dependencies such as instrumentation,
    it is possible to apply this pattern in many other places. By pushing the dependencies
    into a `config` interface, however, they become less apparent, and we have a larger
    interface to implement. Let''s re-examine an earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Consider the rate limiter dependency. What happens if we merge that into the
    `Config` interface? It becomes less apparent that this object uses and relies
    on a rate limiter. If every similar function has rate limiting, then this will
    be less of a problem as its usage becomes more environmental.
  prefs: []
  type: TYPE_NORMAL
- en: The other less visible aspect is configuration. The configuration of the rate
    limiter is likely not consistent across all usages. This is a problem when all
    of the other dependencies and config are coming from a shared object. We could
    compose the config object and customize the rate limiter returned, but this feels
    like over-engineering.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changes can ripple through the software layers** - This issue only applies
    when the config passed through the layers. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: With this structure, when we need to add a new configuration or dependency to
    the `Layer2Config` interface, we would also be forced to add it to the `Layer1Config`
    interface. `Layer1Config` would then be in violation of the interface segregation
    principle as discussed in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID
    Design Principles for Go*, which indicates that we might have a problem. Additionally,
    depending on the code's layering and level of reuse, the number of changes could
    be significant. In this case, a better option would be to apply constructor injection
    to inject `Layer2Object` into `Layer1Object`. This would completely decouple the
    objects and remove the need for the layered changes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have leveraged config injection, an extended version of
    constructor and method injection, to improve the UX of our code, primarily by
    handling the environmental dependencies and config separately from the contextually
    significant dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: While applying config injection to our sample service, we have decoupled all
    possible packages from the `config` package, giving it more freedom to evolve
    over time. We also switched most of the logger usage from a global public variable
    to an injected abstract dependency by removing any possibility of a data race
    relating to the logger instance and enabling us to test logger usage without any
    messy monkey patching.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will examine another unusual form of dependency injection,
    called **Just-in-time** (**JIT**) **dependency injection**. With this technique,
    we will reduce the burden associated with dependency creation and injection between
    the layers without sacrificing our ability to test with mocks and stubs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does config injection differ from method or constructor injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we decide what parameters to move to config injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why don't we inject all dependencies via config injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we want to inject environmental dependencies (such as loggers) instead
    of using a global public variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are boundary tests important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ideal use cases for config injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
