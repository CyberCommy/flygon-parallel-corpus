- en: Interacting with the Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes are covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the Golang version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing program arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a program interface with the flag package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting and setting environment variables with default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving the current working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the current process PID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling operating system signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an external process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving child process information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading/writing from the child process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shutting down the application gracefully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File configuration with functional options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every program, once it is executed, exists in the environment of the operating
    system. The program receives input and provides output to this environment. The
    operating system also needs to communicate with the program to let it know what's
    happening outside. And finally, the program needs to respond with appropriate
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will walk you through the basics of the discovery of the system
    environment, the program parameterization via program arguments, and the concept
    of the operating system signals. You will also learn how to execute and communicate
    with the child process.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the Golang version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While building a program, it is a good practice to log the environment settings,
    build version, and runtime version, especially if your application is more complex.
    This helps you to analyze the problem, in case something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the build version and, for example, the environmental variables, the
    Go version by which the binary was compiled could be included in the log. The
    following recipe will show you how to include the Go runtime version into such
    program information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install and verify the Go installation. The following steps could help:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Go on your machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that your `GOPATH` and `GOROOT` environmental variables are set properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your Terminal and execute `go version`. If you get output with a version
    name, then Go is installed properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a repository in the `GOPATH/src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing the `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/da28c809-195a-49c5-83ad-1c4ef2b86da1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `runtime` package contains a lot of useful functions. To find out the Go
    runtime version, the `Version` function could be used. The documentation states
    that the function returns the hash of the commit, and the date or tag at the time
    of the binary build.
  prefs: []
  type: TYPE_NORMAL
- en: The `Version` function, in fact, returns the `runtime/internal/sys` .The `Version` constant.
    The constant itself is located in the `$GOROOT/src/runtime/internal/sys/zversion.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: This `.go` file is generated by the `go dist` tool and the version is resolved
    by the `findgoversion` function in the `go/src/cmd/dist/build.go` file, as explained
    next.
  prefs: []
  type: TYPE_NORMAL
- en: The `$GOROOT/VERSION` takes priority. If the file is empty or does not exist,
    the `$GOROOT/VERSION.cache` file is used. If the `$GOROOT/VERSION.cache` is also
    not found, the tool tries to resolve the version by using the Git information,
    but in this case, you need to initialize the Git repository for the Go source.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing program arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most simple way to parameterize the program run is to use the command-line
    arguments as program parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Simply, the parameterized program call could look like this: `./parsecsv user.csv
    role.csv`. In this case, `parsecsv` is the name of the executed binary and `user.csv` and
    `role.csv` are the arguments, that modify the program call (in this case it refers
    to files to be parsed).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Build the binary by executing `go build -o test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the command `./test arg1 arg2`. (Windows users can run `test.exe arg1
    arg2`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2de10160-aead-4a1d-8f57-1d550b70c651.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library offers a few ways to access the arguments of the program
    call. The most generic way is to access the arguments by the `Args` variable from
    the OS package.
  prefs: []
  type: TYPE_NORMAL
- en: This way you can get all the arguments from the command line in a string slice. The
    advantage of this approach is that the number of arguments is dynamic and this
    way you can, for example, pass the names of the files to be processed by the program.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example just echoes all the arguments that are passed to the program.
    Finally, let's say the binary is called `test` and the program run is executed
    by the Terminal command `./test arg1 arg2`.
  prefs: []
  type: TYPE_NORMAL
- en: In detail, the `os.Args[0]` will return `./test`. The `os.Args[1:]` returns
    the rest of the arguments without the binary name. In the real world, it is better
    to not rely on the number of arguments passed to the program, but always check
    the length of the argument array. Otherwise, naturally, if the argument on a given
    index is not within the range, the program panics.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the arguments are defined as flags, `-flag value`, additional logic is needed
    to assign the value to the flag. In this case, there is a better way to parse
    these by using the `flag` package. This approach is part of the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a program interface with the flag package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe describes how to access the program arguments by a very
    generic approach.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will provide a way of defining an interface via the program flags.
    This approach dominates systems based on GNU/Linux, BSD, and macOS.  The example
    of the program call could be `ls -l` which will, on *NIX systems, list the files
    in a current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The Go package for flag handling does not support flag combining like `ls -ll`,
    where there are multiple flags after a single dash. Each flag must be separate.
    The Go flag package also does not differentiate between long options and short
    ones. Finally, `-flag` and `--flag` are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Build the binary by executing the `go build -o util`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the console, execute `./util -retry 2 -prefix=example -array=1,2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/24b5846a-4453-4fbc-9301-aa81704939ee.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the flag definition in code, the `flag` package defines two types of functions.
  prefs: []
  type: TYPE_NORMAL
- en: The first type is the simple name of the flag type such as`Int`*.* This function
    will return the pointer to the integer variable where the value of the parsed
    flag is.
  prefs: []
  type: TYPE_NORMAL
- en: The `XXXVar` functions are the second type. These provide the same functionality,
    but you need to provide the pointer to the variable. The parsed flag value will
    be stored in the given variable.
  prefs: []
  type: TYPE_NORMAL
- en: The Go library also supports a custom flag type. The custom type must implement
    the `Value` interface from the `flag` package.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's say the flag `retry` defines the retry limit for reconnecting
    to the endpoint, the `prefix` flag defines the prefix of each row in a log, and
    the `array` is the array flag that will be send as an payload to server. The program
    call from the Terminal will look like `./util -retry 2 -prefix=example array=1,2`.
  prefs: []
  type: TYPE_NORMAL
- en: The important part of the preceding code is the `Parse()` function which parses
    the defined flags from `Args[1:]`. The function must be called after all flags
    are defined and before the values are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code shows how to parse some data types from the command-line
    flags. Analogously, the other built-in types are parsed.
  prefs: []
  type: TYPE_NORMAL
- en: The last flag, `array`, demonstrates the definition of the custom type flag.
    Note that the `ArrayType` implements the `Value` interface from the `flag` package.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `flag` package contains more functions to design the interface with flags.
    It is worth reading the documentation for `FlagSet`.
  prefs: []
  type: TYPE_NORMAL
- en: By defining the new `FlagSet`, the arguments could be parsed by calling the `myFlagset.Parse(os.Args[2:])`.
    This way you can have flag subsets based on, for example, the first flag.
  prefs: []
  type: TYPE_NORMAL
- en: Getting and setting environment variables with default values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe, *Creating a program interface with the flag package,* describes
    how to use flags as program parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The other typical way of parameterization, especially for larger applications,
    is the configuration with the use of environment variables. Environment variables
    as a configuration option significantly simplify the deployment of the applications.
    These are also very common in cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the configuration of a database connection for a local and for an automated
    build environment is different.
  prefs: []
  type: TYPE_NORMAL
- en: If the configuration is defined by the environment variables, it is not necessary
    to change the application config files or even the application code. The exported
    environment variables (for example, `DBSTRING`) are all we need. It is also very
    practical to default the configuration if the environmental variable is not in
    place. This way, the life of the application developers is much easier.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will demonstrate how to read, set and unset the environment variable.
    It will also show you how to implement the default option if the variable is not
    set.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `get.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by calling `DB_CONN=db:/user@example && go run get.go` in the
    Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10deaa7c-c4af-4ceb-b13c-4d3fda3c7bb5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `lookup.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by calling `unset DB_CONN && go run lookup.go` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa749e9a-6241-4830-b558-2ff06a7506d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20b7ef63-0921-49c4-94f4-3c6f1498de02.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The environment variables are accessed by the `Getenv` and `Setenv` functions 
    in the `os` package. The names of the functions are self-explanatory and do not
    need any further description.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more useful function in the `os` package. The `LookupEnv` function
    provides two values as a result; the value of the variable, and the boolean value
    which defines if the variable was set or not in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of the `os.Getenv` function is that it returns an empty string,
    even in cases where the environment variable is not set.
  prefs: []
  type: TYPE_NORMAL
- en: This handicap could be overcome by the `os.LookupEnv` function, which returns
    the string as a value of the environment variable and the boolean value that indicates
    whether the variable was set or not.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the retrieval of the environment variable or the default one, use
    the `os.LookupEnv` function. Simply, if the variable is not set, which means that
    the second returned value is `false`, then the default value is returned. The
    use of the function is part of step 9.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the current working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful source of information for the application is the directory, where
    the program binary is located. With this information, the program can access the
    assets and files collocated with the binary file.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is using the solution for Go since version 1.8\. This one is the
    preferred one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Build the binary by the command `go build -o binary`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the binary by the Terminal call `./binary`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output. It should display the absolute path on your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a30ae134-4226-4698-8b10-4b85c626c9a3.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Go 1.8, the `Executable` function from the `os` package is the preferred
    way of resolving the path of the executable. The `Executable` function returns
    the absolute path of the binary that is executed (unless the error is returned).
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the directory from the binary path, the `Dir` from the `filepath` package
    is applied. The only pitfall of this is that the result could be the `symlink`
    or the path it pointed to.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this unstable behavior, the `EvalSymlinks` from the `filepath` package
    could be applied to the resultant path. With this hack, the returned value would
    be the real path of the binary.
  prefs: []
  type: TYPE_NORMAL
- en: The information about the directory where the binary is located could be obtained
    with the use of the `Executable` function in the `os` library.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the code is run by the command `go run`, the actual executable
    is located in a temporary directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the current process PID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting to know the PID of the running process is useful. The PID could be used
    by OS utilities to find out the information about the process itself. It is also
    valuable to know the PID in case of process failure, so you can trace the process
    behavior across the system in system logs, such as `/var/log/messages`, `/var/log/syslog`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe shows you how to use the `os` package to obtain a PID of the executed
    program, and use it with the operating system utility to obtain some more information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing the `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82b6a9e7-9050-4819-b33f-8b74fee5d4fb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The function `Getpid` from the `os` package returns the PID of a process. The
    sample code shows how to get more information on the process from the operating
    system utility `ps`.
  prefs: []
  type: TYPE_NORMAL
- en: It could be useful to print the PID at the start of the application, so at the
    time of the crash, the cause could also be investigated by the retrieved PID.
  prefs: []
  type: TYPE_NORMAL
- en: Handling operating system signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals are the elementary way the operating systems communicate with the running
    process. Two of the most usual signals are called `SIGINT` and `SIGTERM`. These
    cause the program to terminate.
  prefs: []
  type: TYPE_NORMAL
- en: There are also signals such as `SIGHUP`. `SIGHUP` indicates that the terminal
    which called the process was closed and, for example, the program could decide
    to move to the background.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides a way of handling the behavior in case the application received
    the signal. This recipe will provide an example of implementing the handling.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the `SIGINT` signal to the application by pressing *CTRL* + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f5a3b24-e84e-43fc-bc62-33181082f424.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an application, where the resources are acquired, a resource leak could happen
    in the case of an instant termination. It is better to handle the signals and
    take some necessary steps to release the resources. The preceding code shows the
    concept of how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: The `Notify` function from the `signal` package would be the one that helps
    us to handle the received signals.
  prefs: []
  type: TYPE_NORMAL
- en: If no signal is specified as an argument in a `Notify` function, the function
    will catch all possible signals.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Notify` function of the `signal` package is communicating with
    the `goroutine` by the `sChan` channel. `Notify` then catches the defined signals
    and sends these to `goroutine` to be handled. Finally, `exitChan` is used to resolve
    the exit code of the process.
  prefs: []
  type: TYPE_NORMAL
- en: The important information is that the `Notify` function will not block the signal
    if the assigned channel is not ready. This way the signal could be missed. To
    avoid missing the signal, it is better to create the buffered channel.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `SIGKILL` and `SIGSTOP` signals may not be caught by the `Notify`
    function, thus it is not possible to handle these.
  prefs: []
  type: TYPE_NORMAL
- en: Calling an external process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go binary could also be used as a tool for various utilities and with use
    of `go run` as a replacement for the bash script. For these purposes, it is usual that
    the command-line utilities are called.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the basics of how to execute and handle the child process will be
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test if the following commands work in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: Test if the `ls` (`dir` for Windows) command exists in your `$PATH`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to execute the `ls` (`dir` in Windows) command in your Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following steps cover the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `run.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run run.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/61af16dc-759a-4ebb-8383-bb6ce2456cc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `start.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run start.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4d9b6e4d-a10b-477b-9087-74a829c2257c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library provides a simple way of calling the external process.
    This could be done by the `Command` function of the `os/exec` package.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way is to create the `Cmd` struct and call the `Run` function.
    The `Run` function executes the process and waits until it completes. If the command
    exited with an error, the `err` value is not null.
  prefs: []
  type: TYPE_NORMAL
- en: This is more suitable for calling the OS utils and tools, so the program does
    not hang too long.
  prefs: []
  type: TYPE_NORMAL
- en: The process could be executed asynchronously too. This is done by calling the `Start`
    method of the `Cmd` structure. In this case, the process is executed, but the
    main `goroutine` does not wait until it ends. The `Wait` method could be used
    to wait until the process ends. After the `Wait` method finishes, the resources
    of the process are released.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is more suitable for executing long-running processes and services
    that the program depends on.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes how to simply execute the child process. There are *Retrieve
    child process information* and *Reading/writing from the child process* recipes
    in this chapter that also provide the steps on how to read from and write to the
    child process, and get useful information about the process.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving child process information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe *Calling an external process* describes how to call the child process,
    synchronously and asynchronously. Naturally, to handle the process behavior you
    need to find out more about the process.  This recipe shows how to obtain the
    PID and elementary information about the child process after it terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The information about the running process could be obtained only via the `syscall`
    package and it is highly platform-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test if the `sleep` (`timeout` for Windows) command exists in the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main_running.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main_running.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/359c90e1-e52d-49fa-83ca-ace5d98533b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2902d443-a9b7-4b4c-89aa-f127f2ea2095.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os/exec` standard library provides the way to execute the process. Using `Command`, the `Cmd` structure
    is returned. The `Cmd` provides the access to process the representation. When
    the process is running, you can only find out the PID.
  prefs: []
  type: TYPE_NORMAL
- en: There is only a little information that you can retrieve about the process.
    But by retrieving the PID of the process, you are able to call the utilities from
    the OS to get more information.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that it is possible to obtain the PID of the child process, even if
    it is running. On the other hand, the `ProcessState` structure of the `os` package
    is available, only after the process terminates.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are *Reading/writing from the child process* and *Calling an external
    process* recipes in this chapter that are related to process handling.
  prefs: []
  type: TYPE_NORMAL
- en: Reading/writing from the child process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every process, that is executed, has the standard output, input and error output.
    The Go standard library provides the way to read and write to these.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will walk through the approaches on how to read the output and write
    to the input of the child process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify if the following commands work in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: Test if the `ls` (`dir` for Windows) command exists in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to execute the `ls` (`dir` in Windows) command in your Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main_read_output.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main_read_output.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e44bc828-1856-44f6-9573-0c962c6bf1c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `main_read_stdout.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main_read_stdout.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ac6c977-1a10-4af7-a567-b2789426c601.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `main_read_read.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main_read.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ab239155-9b87-489a-a215-258b1dc5f984.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `sample.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/03b5fa95-0181-4d5e-b404-9f782fbdf5ad.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Cmd` structure of the `os/exec` package provides the functions to access
    the output/input of the process. There are a few approaches to read the output
    of the process.
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest ways to read the process output is to use the `Output` or `CombinedOutput` method
    of the `Cmd` structure (gets `Stderr` and `Stdout`). While calling this function,
    the program synchronously waits till the child process terminates and then returns
    the output to a byte buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `Output` and `OutputCombined` methods, the `Cmd` structure provides
    the `Stdout` property, where the `io.Writer` could be assigned. The assigned writer
    then serves as a destination for the process output. It could be a file, byte
    buffer or any type implementing the `io.Writer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The last approach to read the process output is to get the `io.Reader` from
    the `Cmd` structure by calling the `StdoutPipe` method. The `StdoutPipe` method
    creates the pipe between the `Stdout`, where the process writes the output, and
    provides `Reader` which works as the interface for the program to read the process
    output. This way the output of the process is piped to the retrieved `io.Reader`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a process `stdin` works the same way. Of all the options, the one
    with `io.Writer` will be demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'As could be seen, there are a few ways to read and write from the child process.
    The use of `stderr` and `stdin` is almost the same as described in steps 6-7\.
    Finally, the approach of how to access the input/output could be divided this
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Synchronous (wait until the process ends and get the bytes): The `Output` and
    `CombinedOutput` methods of `Cmd` are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IO: The output or input are provided in the form of `io.Writer/Reader`. The
    `XXXPipe` and `StdXXX` properties are the right ones for this approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The IO type is more flexible and could also be used asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Shutting down the application gracefully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servers and daemons are the programs that run for a long time (typically days
    or even weeks). These long-running programs usually allocate resources (database
    connections, network sock) at the start and keep these resources as long as they
    exist. If such a process is killed and the shutdown is not handled properly, a
    resource leak could happen. To avoid that behavior, the so-called graceful shutdown
    should be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Graceful, in this case, means that the application catches the termination signal,
    if possible, and tries to clean up and release the allocated resources before
    it terminates. This recipe will show you how to implement the graceful shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: The recipe, *Handling operating system signals* describes the catching of OS
    signals. The same approach will be used for implementing the graceful shutdown.
    Before the program terminates, it will clean up and carry out some other activities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *CTRL* + *C* to send a `SIGINT` signal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait until the Terminal output looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eef690db-8a92-41da-880d-4748b906c175.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `recipe11` folder should also contain a file called `test_XXXX.log`, which
    contains lines like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/84079936-5b28-4df9-9622-d0cb003b50dd.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reading from a `sigChan` is blocking so the program keeps running until
    the Signal is sent through the channel. The `sigChan` is the channel where the
    `Notify` function sends the signals.
  prefs: []
  type: TYPE_NORMAL
- en: The main code of the program runs in a new `goroutine`. This way, the work continues
    while the main function is blocked on the `sigChan`. Once the signal from operation
    system is sent to process, the `sigChan` receives the signal and the code below
    the line where the reading from the `sigChan` channel is executed. This code section
    could be considered as the cleanup section.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the step 7 terminal output contains the final log, `Application releasing
    all resources`, which is part of the cleanup section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A detailed description of how the signal catching works is in the recipe *Handling
    operating system signals*.
  prefs: []
  type: TYPE_NORMAL
- en: File configuration with functional options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is not directly related to the Go standard library but includes
    how to handle an optional configuration for your application. The recipe will
    use the functional options pattern in a real case with a file configuration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter01/recipe12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `main.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same folder, create the file `config.json` with content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by the command `CONN_DB=oracle://local:5921 go run main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0bba8cfd-8811-42fc-a255-28160367164c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core concept of the functional options pattern is that the configuration
    API contains the functional parameters. In this case, the `NewClient` function
    accepts a various number of `ConfigFunc` arguments, which are then applied one
    by one on the `defaultClient` struct. This way, the default configuration is modified
    with huge flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: See the `FromFile` and `FromEnv` functions, which return the `ConfigFunc`, that
    is in fact, accessing the file or environmental variables.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can check the output which applied both the configuration options
    and resulting `Client` struct that contains the values from the file and environmental
    variables.
  prefs: []
  type: TYPE_NORMAL
