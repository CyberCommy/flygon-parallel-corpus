- en: Chapter 7. Using NoSQL with Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **NoSQL** (short for **Not Only SQL**) database is any nonrelational data
    store. It usually focuses on speed and scalability. NoSQL has been taking the
    web development world by storm for the past 7 years. Huge companies, such as Netflix
    and Google, announced that they were moving many of their services to NoSQL databases,
    and many smaller companies followed this.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will deviate from the rest of the book in which Flask will not
    be the main focus. The focus on database design might seem odd in a book about
    Flask, but choosing the correct database for your application is arguably the
    most important decision while designing your technology stack. In the vast majority
    of web applications, the database is the bottleneck, so the database you pick
    will determine the overall speed of your app. A study conducted by Amazon showed
    that even a 100-ms delay caused a 1 percent reduction in sales, so speed should
    always be one of the main concerns of a web developer. Also, there is an abundance
    of horror stories in the programmer community of web developers about choosing
    a popular NoSQL database and then not really understanding what the database required
    in terms of administration. This leads to large amounts of data loss and crashes,
    which in turn means losing customers. All in all, it's no exaggeration to say
    that your choice of database for your application can be the difference between
    your app succeeding or failing.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the strengths and weaknesses of NoSQL databases, each type of
    NoSQL database will be examined, and the differences between NoSQL and traditional
    databases will be laid out.
  prefs: []
  type: TYPE_NORMAL
- en: Types of NoSQL databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL is a blanket term used to describe nontraditional methods of storing data
    in a database. To make matters more confusing, NoSQL may also mean the databases
    that are relational but did not use SQL as a query language, for example, **RethinkDB**.
    The vast majority of NoSQL databases are not relational, unlike RDBMS, which means
    that they cannot perform operations such as `JOIN`. The lack of a `JOIN` operation
    is a trade-off because it allows faster reads and easier decentralization by spreading
    data across several servers or even separate data centers.
  prefs: []
  type: TYPE_NORMAL
- en: Modern NoSQL databases include key-value stores, document stores, column family
    stores, and graph databases.
  prefs: []
  type: TYPE_NORMAL
- en: Key-value stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **key-value** NoSQL database acts much like a dictionary in Python. A single
    value is associated with one key and is accessed via that key. Also, like a Python
    dictionary, most key-value databases have the same read speed regardless of how
    many entries there are. Advanced programmers would know this as **O(1) reads**.
    In some key-value stores, only one key can be retrieved at a time, rather than
    multiple rows in traditional SQL databases. In most key-value stores, the content
    of the value is not *queryable*, but the keys are. Values are just binary blobs;
    they can be literally anything from a string to a movie file. However, some key-value
    stores give default types, such as strings, lists, sets, and dictionaries, while
    still giving the option of adding binary data.
  prefs: []
  type: TYPE_NORMAL
- en: Because of their simplicity, key-value stores are typically very fast. However,
    their simplicity makes them unsuitable as the main database for most applications.
    As such, most key-value store use cases are storing simple objects that need to
    expire after a given amount of time. Two common examples of this pattern are storing
    user's session data and shopping cart data. Also, key-value stores are commonly
    used as caches for the application or for other databases. For example, results
    from a commonly run, or CPU-intensive, query or function are stored with the query
    or function name as a key. The application will check the cache in the key-value
    store before running the query on the database, thereby decreasing page load times
    and stress on the database. An example of this functionality will be shown in
    [Chapter 10](ch10.html "Chapter 10. Useful Flask Extensions"), *Useful Flask Extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular key-value stores are **Redis**, **Riak**, and **Amazon DynamoDB**.
  prefs: []
  type: TYPE_NORMAL
- en: Document stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Document store** is one of the most popular NoSQL database types and what
    typically replaces an RDBMS. Databases store data in collections of key-value
    pairs called documents. These documents are schema-less, meaning no document must
    follow the structure of another document. Also, extra keys may be appended to
    the document after its creation. Most document stores store data in **JSON** (**JavaScript
    Object Notation**), a superset of JSON, or XML. For example, the following are
    two different post objects stored in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first document has no comments array. As stated before, documents
    are schema-less, so this format is perfectly valid. The lack of a schema also
    means that there are no type checks at the database level. There is nothing on
    the database to stop an integer from being entered into the title field of a post.
    Schema-less data is the most powerful feature of document stores and draws many
    to adopt one for their apps. However, it can also be considered very dangerous,
    as there is one less check stopping faulty or malformed data from getting into
    your database.
  prefs: []
  type: TYPE_NORMAL
- en: Some document stores collect similar objects in collections of documents to
    make querying objects easier. However, in some document stores, all objects are
    queried at once. Document stores store the metadata of each object, which allows
    all of the values in each document to be queried and return matching documents.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular document stores are **MongoDB**, **CouchDB**, and **Couchbase**.
  prefs: []
  type: TYPE_NORMAL
- en: Column family stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Column family stores**, also known as wide column stores, have many things
    in common with both key-value stores and document stores. Column family stores
    are the fastest type of NoSQL database because they are designed for large applications.
    Their main advantage is their ability to handle terabytes of data and still have
    very fast read and write speeds by distributing the data across several servers
    in an intelligent way.'
  prefs: []
  type: TYPE_NORMAL
- en: Column family stores are also the hardest to understand, due in part to the
    vernacular of column family stores, as they use many of the same terms as an RDBMS,
    with wildly different meanings. In order to understand what a column family store
    is clearly, let's jump straight to an example. Let's create a simple *user to
    posts* association in a typical column family store.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a user table. In column family stores, data is stored and accessed
    via a unique key, such as a key-value store, but the contents are unstructured
    columns, such as a document store. Consider the following user table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Jack | John |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Column** | **Full Name** | **Bio** | **Location** | **Full Name** | **Bio**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Value** | Jack Stouffer | This is my about me | Michigan, USA | John Doe
    | This is my about me |'
  prefs: []
  type: TYPE_TB
- en: 'Note that each key holds columns, which are key-value pairs as well. Also,
    it is not required that each key has the same number or types of columns. Each
    key can store hundreds of unique columns, or they can all have the same number
    of columns to make application development easier. This is in contrast to key-value
    stores, which can hold any type of data with each key. This is also slightly different
    to document stores, which can store types, such as arrays and dictionaries in
    each document. Now let''s create our posts'' table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Post/1 | Post/2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Column** | **Title** | **Date** | **Text** | **Title** | **Date** | **Text**
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Value** | Hello World | 2015-01-01 | Post text… | Still Here | 2015-02-01
    | Post text… |'
  prefs: []
  type: TYPE_TB
- en: There are several things to understand about column family stores before we
    continue. First, in column family stores, data can only be selected via a single
    key or key range; there is no way to query the contents of the columns. To get
    around this, many programmers use an external search tool with their database,
    such as **Elasticsearch**, that stores the contents of columns in a searchable
    format and returns matching keys to be queried on the database. This limitation
    is why proper *schema* design is so crucial in column family stores, and must
    be carefully thought through before storing any data.
  prefs: []
  type: TYPE_NORMAL
- en: Second, data cannot be ordered by the content of the columns. Data can only
    be ordered by key, which is why the keys to the posts are integers. This allows
    the posts to be returned in the order in which they were entered. This was not
    a requirement for the user table because there is no need to sequentially order
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, there are no `JOIN` operators and we cannot query for a column that
    would hold a user key. With our current schema, there is no way to associate a
    post with a user. To create this functionality, we need a third table that holds
    the user to post associations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Jack |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Column** | Posts | Posts/1 | Post/1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Value** |   | Posts/2 | Post/2 |'
  prefs: []
  type: TYPE_TB
- en: This is slightly different from the other tables we have seen so far. The `Posts`
    column is named a super column, which is a column that holds other columns. In
    this table, a super column is associated with our user key, which is holding an
    association of the position of a post to one post. Clever readers might ask why
    we wouldn't just store this association in our user table, much like how the problem
    would be solved in document stores. This is because regular columns and super
    columns cannot be held in the same table. You must choose one at the creation
    of each table.
  prefs: []
  type: TYPE_NORMAL
- en: To get a list of all the posts by a user, we would first have to query the post
    association table with our user key, use the returned list of associations to
    get all of the keys in the posts table, and query the post table with the keys.
  prefs: []
  type: TYPE_NORMAL
- en: If that query seems like a roundabout process to you that's because it is, and
    it is that way by design. The limiting nature of a column family store is what
    allows it to be so fast and handle so much data. Removing features such as searching
    by value and column name give column family stores the ability to handle hundreds
    of terabytes of data. It's not an exaggeration to say that SQLite is a more complex
    database for the programmer than a typical column family store.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, most Flask developers should steer clear of column family stores
    as it adds complexity to applications that isn't necessary. Unless your application
    is going to handle millions of reads and writes a second, using a column family
    store is like pounding in a nail with an atomic bomb.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular column family stores are **BigTable**, **Cassandra**, and **HBase**.
  prefs: []
  type: TYPE_NORMAL
- en: Graph databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designed to describe and then query relationships, graph databases are like
    document stores but have mechanisms to create and describe links between two **nodes**.
  prefs: []
  type: TYPE_NORMAL
- en: A node in a graph store is a single piece of data, usually a collection of key-value
    pairs or a JSON document. Nodes can be given labels to mark them as part of a
    category, for example, a user or a group. After your nodes have been defined,
    an arbitrary number of one-way relationships between the nodes, named **links**,
    can be created with their own attributes. For example, if our data had two user
    nodes and each of the two users knew each other, we would define two "knows" links
    between them to describe that relationship. This would allow you to query all
    the people that know one user or all the people that a user knows.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graph databases](img/B03929_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graph stores also allow you to query by the link's attributes. This allows you
    to easily create otherwise complex queries, such as all of the users that one
    user marked as known in October 2001\. Graph stores can follow links from node
    to node to create even more complex queries. If this example dataset had more
    groups, we could query for groups that people we know have joined but we haven't
    joined. Otherwise, we could query for people who are in the same groups as a user,
    but the user doesn't know them. Queries in a graph store can also follow a large
    number of links to answer complex questions, such as "which restaurants, that
    have a three-star rating or more, in New York, that serve burgers, have my friends
    liked?"
  prefs: []
  type: TYPE_NORMAL
- en: The most common use case for a graph database is to build a recommendation engine.
    For example, say we had a graph store filled with our friend data from a social
    networking site. Using this data, we could build a mutual friend finder by querying
    for users where more than two of our friends have marked them as a friend.
  prefs: []
  type: TYPE_NORMAL
- en: It is very rare for a graph database to be used as the primary data store of
    an application. Most uses of graph stores have each node acting as a representation
    of a piece of data in their main database by storing its unique identifier and
    a small amount of other identifying information.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular graph stores are **Neo4j** and **InfoGrid**.
  prefs: []
  type: TYPE_NORMAL
- en: RDBMS versus NoSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL is a tool, and like any tool is has specific use cases where it excels,
    and use cases where some other tool would be a better fit. No one would use a
    screwdriver to pound in a nail. It's possible, but using a hammer would make the
    job easier. One large problem with NoSQL databases is that people adopt them when
    an RDBMS would solve the problem just as well or better.
  prefs: []
  type: TYPE_NORMAL
- en: To understand which tool to be used when, we must understand the strengths and
    weaknesses of both systems.
  prefs: []
  type: TYPE_NORMAL
- en: The strengths of RDBMS databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the biggest strengths of an RDBMS is its maturity. The technology behind
    an RDBMS has existed for over 40 years and is based on the solid theory of relational
    algebra and relational calculus. Because of their maturity, they have a long,
    proven track record across many different industries of handling data in a safe
    and secure way.
  prefs: []
  type: TYPE_NORMAL
- en: Data safety
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Safety is also one of the biggest selling points of an RDBMS. A RDBMS has several
    methods in place to ensure that the data entered into the database will not only
    be correct, but that data loss is practically nonexistent. These methods combine
    to form what is known as **ACID**, which stands for Atomicity, Consistency, Isolation,
    and Durability. ACID is a set of rules for transactions that guarantee that the
    transaction is handled safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, atomicity requires that each transaction is all or nothing. If one part
    of the transaction fails, the entire transaction fails. This is much like the
    mentality in the Zen of Python: "Errors should never pass silently. Unless explicitly
    silenced." If there is a problem with the data changed or entered, the transaction
    should not keep operating because the proceeding operations most likely require
    that the previous operations were successful.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, consistency requires that any data the transaction modifies or adds
    follow the rules of each table. Such rules include type checks, user-defined constraints,
    such as `FOREIGN KEY`, cascade rules, and triggers. If any of the rules are broken,
    then by the atomicity rule, the transaction is thrown out.
  prefs: []
  type: TYPE_NORMAL
- en: Third, isolation requires that if the database runs transactions concurrently
    to speed up writes, that the outcome of the transactions would be the same if
    they were run serially. This is mostly a rule for database programmers and not
    something that web developers need to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, durability requires that once a transaction is accepted, the data must
    never be lost, barring a hard drive failure after the transaction is accepted.
    If the database crashes or loses power, the durability principle requires that
    any data written before the problem occurred still be present when the server
    is backed up. This essentially means that all transactions must be written to
    the disk once they are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Speed and scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common misconception is that the ACID principle makes an RDBMS unable to scale
    and slow. This is only half true; it is completely possible for an RDBMS to scale.
    For example, an Oracle database configured by a professional database administrator
    can handle tens of thousands of complex queries a second. Huge companies, such
    as Facebook, Twitter, Tumblr, and Yahoo!, are using MySQL to great effect, and
    PostgreSQL is emerging as a favorite of many programmers due to its speed advantage
    over MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: However, the largest weakness of an RDBMS is the inability to easily scale by
    splitting the data across several databases working in tandem. It's not impossible,
    as some detractors seem to imply, it's just harder than a NoSQL database. This
    is due to the nature of `JOIN`, which requires a scan of the entire data in a
    table, even if it is split across multiple servers. Several tools exist to help
    creation of a partitioned setup, but it is still mostly a job for professional
    database administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When evaluating a programming language, the strongest points for or against
    adopting it are the size and activity of its community. A larger and more active
    community means more help if you get stuck, and more open source tools are available
    to use in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: It's no different with databases. An RDBMS, such as MySQL or PostgreSQL, has
    official libraries for almost every language that is used in commercial environments
    and unofficial libraries for everything else. Tools, such as Excel, can easily
    download the latest data from one of these databases and allow the user to treat
    it like it was any other dataset. Several free desktop GUIs exist for each database,
    and some are officially supported by the databases' corporate sponsor.
  prefs: []
  type: TYPE_NORMAL
- en: The strengths of NoSQL databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main reason that many use NoSQL databases is its speed advantage over traditional
    databases. Out of the box, many NoSQL databases can outperform an RDBMS by a large
    amount. However, the speed comes at a cost. Many NoSQL databases, especially document
    stores, sacrifice consistency for availability. This means that they can handle
    many concurrent reads and writes, but those writes may be in conflict with one
    another. These databases promise "eventual consistency" rather than consistency
    checks on each write. In short, many NoSQL databases do not provide ACID transactions,
    or they are turned off by default. Once ACID checks are enabled, the speed of
    the database drops to near the performance of traditional databases. Every NoSQL
    database handles data safety differently, so it's important to read the documentation
    carefully before choosing one over another.
  prefs: []
  type: TYPE_NORMAL
- en: The second feature that pulls people to NoSQL is its ability to handle unformatted
    data. Storing data in XML or JSON allows an arbitrary structure for each document.
    Applications that store user-designed data have benefited greatly from the adoption
    of NoSQL. For example, a video game that allows players to submit their custom
    levels to some central repository can now store the data in a queryable format
    rather than in a binary blob.
  prefs: []
  type: TYPE_NORMAL
- en: The third feature that draws people to NoSQL is the ease of creating a cluster
    of databases working in tandem. Not having `JOIN`s or only accessing values via
    keys makes splitting the data across servers a rather trivial task when compared
    with an RDBMS. This is due to the fact that `JOIN`s requires a scan of the entire
    table, even if it is split across many different servers. `JOIN`s become even
    slower when documents or keys can be assigned to a server by an algorithm as simple
    as the starting character of its unique identifier. For example, everything that
    starts with the letters A-H is sent to server one, I-P to server two, and Q-Z
    to server three. This makes looking up the location of data for a connected client
    very fast.
  prefs: []
  type: TYPE_NORMAL
- en: What database to use when
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, each database has different uses. It was stated at the beginning of the
    section that the main problem when programmers choose a NoSQL database for their
    technology stack is that they choose it when an RDBMS would work just as well.
    This is born out of some common misconceptions. First, people try to use a relational
    mindset and data model and think that they will work just as well in a NoSQL database.
    People usually come to this misunderstanding because the marketing on websites
    for NoSQL databases is misleading and encourages users to drop their current database
    without considering if a nonrelational model would work for their project.
  prefs: []
  type: TYPE_NORMAL
- en: Second, people believe that you must use only one data store for their application.
    Many applications can benefit from using more than one data store. Using a Facebook
    clone as an example, it could use MySQL for holding user data, redis to store
    session data, a document store to hold the data for the quizzes and surveys that
    people share with each other, and a graph database to implement a find friends
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: If an application feature needs very fast writes, and write safety is not a
    primary concern, then use a document store database. If you need to store and
    query schema-less data, then you should use a document store database.
  prefs: []
  type: TYPE_NORMAL
- en: If an application feature needs to store something that deletes itself after
    a specified time, or the data does not need to be searched, then use a key-value
    store.
  prefs: []
  type: TYPE_NORMAL
- en: If an application feature relies on finding or describing complex relationships
    between two or more sets of data, then use a graph store.
  prefs: []
  type: TYPE_NORMAL
- en: If an application feature needs guaranteed write safety, each entry can fix
    into a specified schema, different sets of data in the database need to be compared
    using JOINs, or it needs constraints on the entered data, then use an RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB in Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is far and away the most popular NoSQL database. MongoDB is also the
    best-supported NoSQL database for Flask and Python in general. Therefore, our
    examples will focus on MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is a document store NoSQL database. Documents are stored in collections,
    which allow grouping of similar documents, but no similarities between documents
    are necessary to store a document in a collection. Documents are defined in a
    JSON superset named BSON, which stands for Binary JSON. BSON allows JSON to be
    stored in binary format rather than in string format, saving a lot of space. BSON
    also distinguishes between several different ways of storing numbers, such as
    32-bit integers and doubles.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the basics of MongoDB, we will use Flask-MongoEngine to cover
    the same functionality of Flask-SQLAlchemy in the previous chapters. Remember
    that these are just examples. There is no benefit in refactoring our current code
    to use MongoDB because MongoDB cannot offer any new functionality for our use
    case. New functionality with MongoDB will be shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install MongoDB, go to [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)
    and select your OS from the tabs under the heading "Download and Run MongoDB Yourself".
    Every OS that has a supported version has installation instructions listed next
    to the download button of the installer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run MongoDB, go to bash and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will run a server for as long as the window is open.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up MongoEngine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MongoEngine needs to be installed with pip before we can get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `models.py` file, a mongo object will be created that represents our
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like the SQLAlchemy object, our mongo object needs to be initialized on
    the app object in `__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before our app will run, our `DevConfig` object in `config.py` needs to set
    up the parameters of the mongo connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These are the defaults for a brand new MongoDB installation.
  prefs: []
  type: TYPE_NORMAL
- en: Defining documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoEngine is an ORM based around Python's object system, specifically for
    MongoDB. Unfortunately, there exists no SQLAlchemy style wrapper that supports
    all NoSQL drivers. In an RDBMS, the implementations of SQL are so similar that
    creating a universal interface is possible. However, the underlying implementations
    of each document store are different enough that the task of creating a similar
    interface would be more trouble than it is worth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each collection in your mongo database is represented by a class that inherits
    from mongo.Document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each class variable is a representation of a key belonging to a document, which
    is represented in this example of a Post class. The class variable name is used
    as the key in the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike SQLAlchemy, there is no need to define a primary key. A unique ID will
    be generated for you under the ID attribute. The preceding code would generate
    a BSON document that would resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Field types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a large number of fields such that each represents a distinct category
    of data in Mongo. Unlike the underlying database, each field provides a type check
    before the document is allowed to be saved or altered. The most used fields are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: BooleanField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DateTimeField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DictField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DynamicField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EmbeddedDocumentField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FloatField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IntField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ListField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ObjectIdField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReferenceField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: StringField
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a full list of fields and a detailed documentation, go to the MongoEngine
    website at [http://docs.mongoengine.org](http://docs.mongoengine.org).
  prefs: []
  type: TYPE_NORMAL
- en: The majority of these are named for the Python type they accept, and work the
    same as the SQLAlchemy types. However, there are some new types that have a counterpart
    in SQLAlchemy. `DynamicField` is a field that can hold any type of value and performs
    no type checks on values. `DictField` can store any Python dictionary that can
    be serialized by `json.dumps()`. The `ReferenceField` simply stores the unique
    ID of a document, and when queried, MongoEngine will return the referenced document.
    Counter to `ReferenceField`, `EmbeddedDocumentField` stores the passed document
    in the parent document, so there is no need for a second query. The `ListField`
    type represents a list of fields of a specific type.
  prefs: []
  type: TYPE_NORMAL
- en: This is typically used to store a list of references to other documents or a
    list of embedded documents to create a one-to-many relationship. If a list of
    unknown types is needed, `DynamicField` can be used. Each field type takes some
    common arguments, as shown in the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `primary_key` argument specifies that you do not want MongoEngine to autogenerate
    a unique key, but the value of the field should be used as the ID. The value of
    this field will now be accessible from both the `id` attribute and the name of
    the field.
  prefs: []
  type: TYPE_NORMAL
- en: '`db_field` defines what the key will be named in each document. If not set,
    it will default to the name of the class variable.'
  prefs: []
  type: TYPE_NORMAL
- en: If `required` is defined as `True`, then that key must be present in the document.
    Otherwise, the key does not have to exist for documents of that type. When a class
    defined, nonexistent key is queried, it will return None.
  prefs: []
  type: TYPE_NORMAL
- en: '`default` specifies the value that this field will be given if no value is
    defined.'
  prefs: []
  type: TYPE_NORMAL
- en: If `unique` is set to `True`, MongoEngine checks to make sure that no other
    documents in the collection will have the same value for this field.
  prefs: []
  type: TYPE_NORMAL
- en: When passed a list of field names, `unique_with` will make sure that when taken
    in combination the values of all the fields will be unique for each document.
    This is much like multicolumn `UNIQUE` indexes in an RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when given a list, the `choices` option limits the allowable values
    for that field to the elements in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Types of documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoEngine's method to define documents allows either flexibility or rigidity
    on a collection-by-collection basis. Inheriting from `mongo.Document` means that
    only the keys defined in the class can be saved to the database. Those keys defined
    in the class can be empty, but everything else will be ignored. On the other hand,
    if your class inherits `mongo.DynamicDocument`, any extra fields set will be treated
    as `DynamicFields` and will be saved with the document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To show the not recommended extreme, the following class is perfectly valid;
    it has no required fields and allows any fields to be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The last type of document is the `EmbeddedDocument`. The `EmbeddedDocument`
    is simply a document that is passed to an `EmbeddedDocumentField` and stored as
    is in the document as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Why use the `EmbeddedDocumentField` over the `DictField` when they seem to
    perform the same function? The end result of using each is the same. However,
    an embedded document defines a structure for the data, while a `DictField` can
    be anything. for better understanding, think of it this way: `Document` is to
    `DynamicDocument` as `EmbeddedDocument` is to `DictField`.'
  prefs: []
  type: TYPE_NORMAL
- en: The meta attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the `meta` class variable, many attributes of a document can be manually
    set. If you are working with an existing set of data and want to connect your
    classes to the collections, set the collection key of the `meta` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also manually set the max number of documents in the collection and
    how large each document can be. In this example, there can be only 10,000 documents,
    and each document can''t be larger than 2 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Indexes can also be set through MongoEngine. Indexes can be single field by
    using a string or multifield using a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The default ordering of a collection can be set through the `meta` variable
    with the **ordering key**. When `–` is prepended, it tells MongoEngine to order
    results by descending order of that field. If `+` is prepended, it tells MongoEngine
    to order results by ascending order of that field. This default behavior is overridden
    if the `order_by` function is specified in a query, which will be shown in the
    *CRUD* section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `meta` variable can also enable user-defined documents to be inherited
    from, which is disabled by default. The subclass of the original document will
    be treated as a member of the parent class and will be stored in the same collection
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: CRUD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated in [Chapter 2](ch02.html "Chapter 2. Creating Models with SQLAlchemy"),
    Creating Models with SQLAlchemy, there are four main forms of data manipulation
    that any data store must implement. They are creation of new data, reading existing
    data, updating existing data, and deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a new document, just create a new instance of the class and call the
    `save` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, the values can be passed as keywords in the object creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike SQLAlchemy, MongoEngine does not automatically save related objects
    stored in `ReferenceFields`. To save any changes to referenced documents along
    with the changes to the current document, pass `cascade` as `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you wish to insert a document and skip its checks against the defined parameters
    in the class definition, then pass validate as `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that these checks exist for a reason. Turn this off only for a very
    good reason
  prefs: []
  type: TYPE_NORMAL
- en: Write safety
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, MongoDB does not wait for the data to be written to disk before
    acknowledging that the write occurred. This means that it is possible for writes
    that were acknowledged to have failed, either by hardware failure or some error
    when the write occurred. To ensure that the data is written to disk before Mongo
    confirms the write, use the `write_concern` keyword. The **write concern** tells
    Mongo when it should return with an acknowledgement of the write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As stated in the RDBMS versus NoSQL section, it's very important that you understand
    how the NoSQL database that you are using treats writes. To learn more about MongoDB's
    write concern, go to [http://docs.mongodb.org/manual/reference/write-concern/](http://docs.mongodb.org/manual/reference/write-concern/).
  prefs: []
  type: TYPE_NORMAL
- en: Read
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access the documents from the database, the `objects` attribute is used.
    To read all of the documents in a collection, use the `all` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To limit the number of items returned, use the `limit` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This `limit` command is slightly different than the SQL version. In SQL, the
    `limit` command can also be used to skip the first results. To replicate this
    functionality, use the `skip` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, MongoDB returns the results ordered by the time of their creation.
    To control this, there is the `order_by` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you want only the first result from a query, use the `first` method. If your
    query returns nothing, and you expected it to, then use `first_or_404` to automatically
    abort with a 404 error. This acts exactly the same as its Flask-SQLAlchemy counterpart
    and is provided by Flask-MongoEngine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The same behavior is available for the `get` method, which expects the query
    will only return one result and will raise an exception otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paginate` method is also present and has the exact same API as its Flask-SQLAlchemy
    counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Also, if your document has a `ListField` method, the `paginate_field` method
    on the document object can be used to paginate through the items of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you know the exact value of the field you wish to filter by, pass its value
    as a keyword to the `objects` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike SQLAlchemy, we cannot pass truth tests to filter our results. Instead,
    special keyword arguments are used to test values. For example, to find all posts
    published after January 1, 2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__gt` appended to the end of the keyword is called an operator. MongoEngine
    supports the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ne`: not equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lt`: less than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lte`: less than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gt`: greater than'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gte`: greater than or equal to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not`: negate a operator, for example, `publish_date__not__gt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`: value is in list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nin`: value is not in list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod`: *value % a == b*, *a* and *b* are passed as (*a*, *b*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`all`: every item in list of values provided is in the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: the size of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exists`: value for field exists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MongoEngine also provides the following operators to test string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exact`: string equals the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iexact`: string equals the value (case insensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains`: string contains the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`icontains`: string contains the value (case insensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startswith`: string starts with the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`istartswith`: string starts with the value (case insensitive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`endswith`: string ends with the value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iendswith`: string ends with the value (case insensitive) `Update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These operators can be combined to create the same powerful queries that were
    created in the previous sections. For example, to find all of the posts that were
    created after January 1, 2015 that don''t have the word `post` in the title, the
    body text starts with the word `Lorem`, and ordered by the publish date with the
    latest one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if there is some complex query that cannot be represented by these
    tools, then a raw Mongo query can be passed as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To update objects, the `update` method is called on the results of a query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If your query should only return one value, then use `update_one` to only modify
    the first result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike traditional SQL, there are many different ways to change a value in
    MongoDB. Operators are used to change the values of a field in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set`: This sets a value (same as given earlier)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unset`: This deletes a value and removes the key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inc`: This increments a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dec`: This decrements a value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`: This appends a value to a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push_all`: This appends several values to a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop`: This removes the first or last element of a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: This removes a value from a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull_all`: This removes several values from a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_to_set`: This adds value to a list only if its not in the list already'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, if a `Python` value needs to be added to a `ListField` named tags
    for all `Post` documents that have the `MongoEngine` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The same write concern parameters to save exist for updates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Delete
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To delete a document instance, call its `delete` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Relationships in NoSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we created relationships in SQLAlchemy, we can create relationships between
    objects in MongoEngine. Only with MongoEngine, we will be doing so without `JOIN`
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two ways to create a one-to-many relationship in MongoEngine. The
    first method is to create a relationship between two documents by using a `ReferenceField`
    to point to the ID of another object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the property of the `ReferenceField` gives direct access to the referenced
    object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Unlike SQLAlchemy, MongoEngine has no way to access objects that have relationships
    to another object. With SQLAlchemy, a `db.relationship` variable could be declared,
    which allows a user object to access all of the posts with a matching `user_id`
    column. No such parallel exists in MongoEngine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A solution is to get the user ID for the posts you wish to search for and filter
    with the user field. This is the same thing as SQLAlchemy did behind the scenes,
    but we are just doing it manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to create a one-to-many relationship is to use an `EmbeddedDocumentField`
    with an `EmbeddedDocument`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the `comments` property gives a list of all the embedded documents.
    To add a new comment to the post, treat it like a list and append `comment` documents
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note that there was no call to a `save` method on the comment variable. This
    is because the comment document is not a real document, it is only an abstraction
    of the `DictField`. Also, keep in mind that documents can only be 16 MB large,
    so be careful how many `EmbeddedDocumentFields` are on each document and how many
    `EmbeddedDocuments` each one is holding.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The concept of a many-to-many relationship does not exist in document store
    databases. This is because with `ListFields` they become completely irrelevant.
    To idiomatically create the tag feature for the `Post` object, add a list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we wish to query for all of the `Post` objects that have a specific
    tag, or many tags, it is a simple query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For the list of roles on each user object, the optional choices argument can
    be given to restrict the possible roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Leveraging the power of NoSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, our MongoEngine code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This code implements the same functionality as the SQLAlchemy models. To show
    the unique power of NoSQL, let''s add a feature that would be possible with SQLAlchemy,
    but that is much more difficult: different post types, each with their own custom
    bodies. This will be much like the functionality of the popular blog platform,
    Tumblr.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, allow your post type to act as a parent class and remove the text
    field from the `Post` class as not all posts will have text on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Each post type will inherit from the `Post` class. Doing so will allow the
    code to treat any `Post` subclass as if it were a `Post`. Our blogging app will
    have four types of posts: a normal blog post, an image post, a video post, and
    a quote post.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Our post creation page needs to be able to create each of these post types.
    The `PostForm` object in `forms.py`, which handles post creation, will need to
    be modified to handle the new fields first. We will add a selection field that
    determines the type of post, an `author` field for the quote type, an `image`
    field to hold a URL, and a `video` field that will hold the embedded HTML iframe.
    The `quote` and `blog` post content will both share the `text` field as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new_post` view function in the `blog.py` controller will also need to
    be updated to handle the new post types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new.html` file that renders our form object will need to display the new
    fields added to the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our new inputs, we can add in some JavaScript to show and
    hide the fields based on the type of post:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `post.html` needs to be able to display our post types correctly.
    We have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the fundamental differences between NoSQL and traditional SQL
    systems were laid out. We explored the main types of NoSQL systems and why an
    application might need, or not need, to be designed with a NoSQL database. Using
    our app's models as a base, the power of MongoDB and MongoEngine was shown by
    how simple it was to set up complex relationships and inheritance. In the next
    chapter, our blogging application will be extended with a feature designed for
    other programmers who wish to use our site to build their own service, that is,
    RESTful endpoints.
  prefs: []
  type: TYPE_NORMAL
