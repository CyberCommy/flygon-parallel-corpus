- en: Attacking Integrity Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击完整性控制
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Sniffing on a wireless network
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在无线网络上嗅探
- en: Working with monitor mode and packet injection
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用监视模式和数据包注入
- en: Performing a data replay
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行数据重放
- en: Cracking WEP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破解WEP
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When working with any type of network or information one of the fundamental
    components that needs to be addressed is that of integrity. The integrity of data
    is essential as the receiver of a piece of information needs to have confidence
    that what they are receiving and relying on is faithful to the intent of the creator
    and sender of that data. If the integrity, and therefore confidence, in data is
    lost then data becomes essentially worthless.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何类型的网络或信息时，需要解决的基本组成部分之一是完整性。数据的完整性是至关重要的，因为信息的接收者需要确信他们接收和依赖的信息忠实于数据的创建者和发送者的意图。如果数据的完整性和信心丧失，那么数据基本上就变得毫无价值。
- en: If you have been in security long enough you have undoubtedly run into the well-known
    **CIA** triad, which is shorthand for **Confidentiality**, **Integrity**, and
    **Availability**. Simply put, the confidentiality refers to keeping information
    safe from unauthorized access or disclosure. Availability refers to the practice
    of keeping access to systems and data constant or near constant as possible (typically
    this is discussed in terms of uptime, such as 99.999% uptime). Finally, the integrity
    component is what we are addressing here in this chapter. Integrity of data ensures
    that the information is free from errors, corruptions, modifications, or anything
    done by an unauthorized third-party.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在安全领域工作了足够长的时间，您无疑会遇到著名的CIA三角，它是**保密性**、**完整性**和**可用性**的简称。简而言之，保密性是指保护信息免受未经授权的访问或披露。可用性是指保持对系统和数据的访问尽可能恒定或接近恒定（通常以正常运行时间来讨论，如99.999%的正常运行时间）。最后，完整性组件是我们在本章中要讨论的内容。数据的完整性确保信息没有错误、损坏、修改或任何未经授权的第三方所做的事情。
- en: Remember that when working with CIA, providing one does not imply you are doing
    anything to address the rest. For example, providing integrity controls does not
    in any way imply that there is confidentiality of information as well, as that
    is a separate type of control. In fact, in many cases you will provide protection
    for one aspect of CIA, but not the others. For example, you may want to ensure
    an email you send out is readable by everyone, but you may place controls on it
    to ensure that no one can alter it to make it look like you are saying something
    you are not.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在处理CIA时，提供一个并不意味着你正在解决其他问题。例如，提供完整性控制并不以任何方式意味着信息的保密性，因为这是一种不同类型的控制。事实上，在许多情况下，您可能会为CIA的一个方面提供保护，但不会为其他方面提供保护。例如，您可能希望确保您发送的电子邮件可以被所有人阅读，但您可能会对其进行控制，以确保没有人可以更改它，使其看起来像您说了一些您没有说的话。
- en: It is important for you to keep in mind that there is no magic bullet or formula
    stating the perfect balance of these three components for any organization or
    individual. You will have to perform a risk assessment or evaluation to determine
    the balance in your situation based on your unique threats and vulnerabilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，对于任何组织或个人来说，没有魔法子弹或公式来规定这三个组件的完美平衡。您将需要进行风险评估或评估，以确定根据您独特的威胁和漏洞在您的情况下的平衡。
- en: To compromise the integrity of data, an attacker needs to simply find a way
    to alter or corrupt data in such a way that it is called into question or cannot
    be used as originally intended. To perform integrity-based attacks, a malicious
    party will seek to gain access to a network (in our case, wireless) and impact
    the data stream and modify the data in some way. How they modify the data will
    depend on their specific goals and intentions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要破坏数据的完整性，攻击者只需找到一种改变或损坏数据的方法，使其受到质疑或无法按原始意图使用。为了执行基于完整性的攻击，恶意方将寻求访问网络（在我们的情况下是无线网络）并影响数据流并以某种方式修改数据。他们如何修改数据将取决于他们的具体目标和意图。
- en: If the malicious party seeks to make data worthless they can redirect it, corrupt
    it, or even prevent it from getting to where it's intended to go. If the malicious
    party seeks to change data in such a way to alter the results of a process, they
    may use any number of tools designed to alter the values or structure of data
    in such a way to achieve their result. For example, an attacker may intercept
    stock quotes and change the values of various stocks on the way to the recipient
    to induce them to buy or sell when they otherwise wouldn't. Finally, impacting
    the integrity of a network itself could also allow an attacker to break security
    and intercept information such as credentials and other valuable 'nuggets' of
    information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意方试图使数据变得毫无价值，他们可以重定向它、损坏它，甚至阻止它到达预定目的地。如果恶意方试图以某种方式改变数据以改变过程的结果，他们可能会使用任意数量的旨在改变数据的值或结构以实现其结果的工具。例如，攻击者可能会拦截股票报价并在传递给接收者时更改各种股票的价值，以诱使他们在本来不会买或卖时进行交易。最后，影响网络本身的完整性也可能允许攻击者突破安全性并拦截诸如凭证和其他有价值的信息。
- en: 'In wireless networks, attacks that impact integrity are broad and powerful
    and can take a number of different forms, each of which can be used independently
    or in combination to create a more robust attack solution. Some examples of integrity
    control mechanisms used in wireless are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在无线网络中，影响完整性的攻击是广泛而强大的，可以采取多种不同形式，每种形式可以独立使用或结合起来创建更强大的攻击解决方案。无线网络中使用的一些完整性控制机制的例子是：
- en: '**Encryption**: This is a very useful control or countermeasure to both confidentiality
    and integrity. In the case of integrity, data that is encrypted and hashed is
    more resistant to compromise either because it is undecipherable without the key
    or (as is the case with hashing) changes in the data will result in it becoming
    invalidated.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-Shared Key** (**PSK**) **systems**: This involves the use of systems
    where a common key is entered on each workstation or device that allows it to
    authenticate to the wireless access point. This type of protection usually comes
    in the form of non-enterprise WEP, WPA, or WPA2.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise authentication**: This type of system works in the same way as
    PSK-based environments, except that the key management is centralized through
    the use of systems such as RADIUS.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a short list of potential measures that can be deployed to enforce
    integrity, however there are many more that are available outside of the wireless
    environment that can supplement or replace what has been mentioned in this list.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Once network access is gained and the integrity of data called into question,
    the attacker may choose to alter things for whatever ends they so choose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Types of attack
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many integrity control attacks, and all are very effective when used
    by a skilled and practiced hand. The ones covered within the pages of this chapter
    represent some of the most effective and popular methods that can be deployed
    on and against wireless networks and their client devices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start exploring each one of our attacks, let''s first lay out the
    attacks that will be covered in this chapter:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data replays
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet injections
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of beacon frames
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing of beacon frames
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember these are just a few of the types of attacks that can be used to subvert
    the integrity of a wireless network; they should never be considered the only
    types of attacks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing on a wireless network
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sniffing is a technique that is used to observe the traffic on a network as
    it makes its way from sender to receiver (and back in many cases). Sniffing allows
    you to capture traffic either in real-time, and distill it through the use of
    filters, or it can be captured and saved to a file for later analysis and processing.
    Sniffing is a powerful technique for gaining information about a network and the
    devices on it, which in turn can be used as a foundation for later activities
    based on the results achieved.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I refer to sniffing in the first line of this paragraph as a technique
    for observing traffic moving across a network. This is an important detail that
    I feel may be subtle and needs to be pointed out accordingly. Sniffing itself
    should never be considered something used for performing attacks, lest we become
    stuck in our thinking that this is all it is good for. In fact, sniffing is a
    technique that is used every day for completely benign and productive means. Network
    administrators use sniffers to diagnose network problems, optimize performance,
    and for plenty of other beneficial means.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we are simply taking the ability of sniffing to capture information
    from a network and then acting upon what we discover. The benign or malicious
    use of this tool lies in what the intention to do with the results happens to
    be.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: How does sniffing work?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sniffing works by making use of or altering certain conditions. The goal of
    sniffing is to observe the traffic that happens to be moving by the system that
    is performing the sniffing, but under normal conditions of operation any system
    will only be allowed to see the information addressed directly to it or coming
    from it. This makes sense, as a system that has to process all the information
    that flowed by would be bogged down by inefficiency and poor performance - not
    to mention it would be a security risk as well.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In order to view all of the traffic flowing by, a network adapter needs to switch
    into what is known as promiscuous mode. To understand promiscuous mode, first
    understand that under normal conditions a network adapter does not run under this
    condition. In practice, an adapter running in non-promiscuous mode will filter
    out all traffic that is not intended for it and will only process those that are
    addressed to it. When a network card is switched into promiscuous mode, however,
    things change. In promiscuous mode, an adapter will no longer filter out traffic
    not intended for it and will allow all traffic to be viewed by software (that
    is designed to process this information) installed on the system. The following
    diagram shows an adapter in promiscuous mode placed on a network.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/819ea064-c7ae-483e-abee-83dd39062afe.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: A system setup to perform sniffing
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: In modern network environments, just about every network adapter can switch
    into promiscuous mode and needs only to be instructed to do so. However, in most
    situations, the switch into this mode is completely unnecessary for normal operations,
    as a device only need see the information intended for it. It is because of this
    that using methods designed to detect this mode in use on a system are effective
    at locating systems that may be running unauthorized sniffing activities. Do keep
    in mind that a card in promiscuous mode itself is not cause for alarm as there
    are legitimate reasons that a network adapter may run in this mode. One prime
    example is the case of **Network Intrusion Detection Systems** (**NIDS**), that
    are designed to detect and then alert the network administrator to the presence
    of suspect traffic or activities. By their very nature, these systems must run
    in promiscuous mode to be able to observe all traffic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In wireless networks we do not have promiscuous mode, however we have something
    that we mentioned in [Chapter 2](e5d8f3be-e22e-4d20-a76f-74951b0db836.xhtml), *Attacking
    Access Controls,* known as monitor mode. Monitor mode comes with some features
    that are different to the promiscuous model. First, a card switched into monitor
    mode can observe the data transmitted on a wireless network without having to
    associate with it first. Second, monitor mode prevents the card from transmitting
    data in most cases. Third, a card may be restricted to listening on one channel
    at a time, but this can vary depending on the device and driver involved.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'One other note: many network cards included in smartphones, tablets, and similar
    gadgets do not support promiscuous mode and must therefore make use of an external
    adapter to gain this ability.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In order to observe all the traffic on a network, once we are in promiscuous
    mode we must be able to see the traffic in the first place. In other words, you
    can't eavesdrop on a conversation if you are not in the same room with the people
    you wish to listen in on (bugging devices and NSA gadgets not included). In a
    network, this means that you must be on the same collision domain.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'On a traditional wired network, where all devices are connected through a hub,
    they are all effectively on the same collision domain. Think of the way a hub
    functions: traffic that is sent to one port on a hub is automatically sent to
    all ports on the hub. Since any station can transmit at any time collisions can
    and do happen, which leads to what is known as a collision domain. When this type
    of situation exists, it is possible to listen in on traffic on the network quite
    easily because every station shares the same logical transmission area. Basically,
    sniffing is effective when the observer and the victim exist such that each can
    see each other''s actions.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note that on modern networks the use of hubs is something that is frowned upon
    for many reasons, including what we are discussing here for sniffing. In modern
    networks, switches have utterly replaced hubs in production to avoid this sort
    of risk, as well as to optimize network performance and ease administration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the same type of situation exists for wireless networks, where
    traffic can be observed by other parties who happen to be set up to look for it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that traditional wired networks use a collision-based technology in
    their design known as **CSMA/CD**, which is short for **Carrier Sense Multiple
    Access** **with** **Collision Detection**. What this means in practice is that
    if two or more stations happen to transmit at one time they will cause a collision
    (think of it as two people talking at the same time). This technology will detect
    the collision and deal with it by forcing both stations to wait a random period
    of time before retransmitting and hopefully avoiding another collision. Collisions
    are a normal part of many networks and are not a problem until the collisions
    get excessive, in which case a network can be segmented to reduce the number to
    a better number.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In wireless networks, a technique known as **CSMA/CA** or **Carrier Sense Multiple
    Access** **with** **Collision Avoidance** is used. As you may guess, the process
    involves not detecting a collision, but rather avoiding a collision altogether.
    In practice, this means that a station will check to see if anyone is transmitting,
    and if they are not it will send out a signal saying it is ready to transmit to
    keep any other station from sending data. At this point, the device will transmit
    and signal when it is done transmitting so the network is released.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Some wired networks do use CSMA/CA, but this is not incredibly common.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The next component of performing a successful sniff is to have the software
    in the form of a network sniffer. In Kali Linux, we have a number of tools designed
    to do this very thing; some of the most popular tools are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Dsniff**: This is a suite of tools all revolving around the common theme
    of sniffing, with each designed to perform a specific type of sniffing very effectively
    and on a granular level. Many of the tools are centered around a specific protocol
    or purpose.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tcpdump**: This is one of the most used network sniffer/analyzers for Linux.
    Tcpdump is a command-line tool that is great for displaying header information.
    Tcpdump is available at [www.tcpdump.org](http://www.tcpdump.org/).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EtherApe**: This is a Linux/UNIX tool that is designed to graphically display
    the connections incoming and outgoing from a system in order to better visualize
    network activity.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wireshark**: One of the most widely known and used packet sniffers. Offers
    a tremendous number of features all designed to assist in the dissection and analysis
    of traffic.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kismet**: We saw this utility back in [Chapter 2](e5d8f3be-e22e-4d20-a76f-74951b0db836.xhtml), *Attacking
    Access Controls,* when we performed war driving. This utility is one that wears
    many hats, including that of a packet sniffer.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sniffers are utilities that are used to capture and scan traffic moving across
    a network. You will find sniffers to be a very valuable as tool in your arsenal
    for many different attacks, but why are they so powerful? One of the biggest reasons
    to use sniffers is to capture and dissect unencrypted network traffic, at least
    in our situation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'How successful sniffers are depends on the relative and inherent insecurity
    of certain network protocols. Protocols such as the tried and true TCP/IP were
    never designed with security in mind and therefore do not offer much in this area.
    Several protocols lend themselves to easy sniffing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '**Telnet/RLOGIN**: Keystrokes, such as those including usernames and passwords,
    that can be easily sniffed'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP**: Designed to send information in the clear without any protection
    and thus a good target for sniffing'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Mail Transfer Protocol** (**SMTP**): Commonly used in the transfer
    of email, this protocol is efficient, but it does not include any protection against
    sniffing'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network News Transfer Protocol** (**NNTP**): All communication, including
    passwords and data, is sent in the clear'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post Office Protocol** (**POP**): Designed to retrieve email from servers,
    this protocol does not include protection against sniffing because passwords and
    usernames can be intercepted'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File Transfer Protocol** (**FTP**): A protocol designed to send and receive
    files; all transmissions are sent in the clear'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet Message Access Protocol** (**IMAP**): Similar to SMTP in function
    and lack of protection'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the protocols listed here transmit their information in the clear to
    include passwords, usernames, keystrokes, and data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started, you will need to have the following items in place:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering promiscuous mode
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux with Wireshark installed
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireshark should be installed as part of your default installation of Kali Linux
    like it always has been. You should not have to install this software package,
    rather you should be able to just select it from the Sniffing menu under the Applications
    menu in Kali.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to get into the habit of saving your sniffing activities into PCAP
    files. These files are supported by a number of different sniffing utilities (as
    well as other applications) to support the saving of captured network activity
    for later or further analysis. Since network conditions can vary (dramatically
    at sometimes), and the situation you are observing and may be curious about may
    be unique, you may want to save the file for later reference and review.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Start Wireshark.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the interface from the following screen that you wish to perform sniffing
    with.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0cca468-0c7e-4a28-97e5-a4c6b2ae53c4.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: Select sniffing interface screen
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use Capture interface and tick the interface that matches
    your wireless adapter.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the Start button here and Wireshark will start capturing traffic. The
    Start button will look like a shark fin.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you should start observing traffic being captured in the main
    Wireshark window. At the level we are looking at here there is really no difference
    between sniffing wireless traffic and wired traffic. However, there are some things
    you can do to go further with sniffing in wireless, which we will explore next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Working with monitor mode and packet injection
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next item to introduce into the sniffing process is a mode known as monitor
    mode. Monitor mode is a special type of operation restricted specifically to wireless
    adapters. This mode is used to allow the wireless adapter to view traffic on wireless
    networks that it is not currently associated with. This mode allows us to use
    a sniffer to capture traffic from any wireless network in the area without restriction.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Monitor mode is supported on most modern wireless adapters, however it is not
    universally supported. On Linux, most wireless adapters can be switched to monitor
    mode with a few command line configurations. This is different than what you may
    have experienced on the Microsoft Windows platform, where monitor mode is normally
    only available through the use of external adapters such as AirPcap.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is important to make sure that you do not confuse monitor mode
    with promiscuous mode as they are not the same. Promiscuous mode is available
    on both wired and wireless networks and allows for the view of all traffic that
    is flowing past the sniffing machine whether it involves them or not. Monitor
    mode is exclusive to wireless and allows for the viewing of traffic on wireless
    networks that you are not currently associated with. They are very similar, but
    not the same.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux with Wireshark installed
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will switch a network card into monitor mode so it can be
    used to observe traffic from non-associated access points.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: In order to switch the network adapter into monitor mode we can use `ifconfig`
    to identify the wireless adapter if you don't know its name already. If you do
    know the name, then perform the following steps.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Open up a Terminal window.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Press *Enter* and this will bring the network adapter offline.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Press *Enter* to switch the card to monitor mode.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Press *Enter* to bring the network adapter back online.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These commands will put the wireless card into monitor mode.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To take advantage of the card being in monitor mode, we can issue the following
    command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Putting a card into monitor mode is very important as it allows us to proceed
    to later steps and perform them successfully. Under normal conditions a wireless
    adapter must be associated with a wireless access point to be able to view and
    observe traffic in the same way a sniffer would on a wired network. To perform
    attacks without being associated with an access point we would use monitor mode.
    Monitor mode will let us view the traffic associated with a wireless network or
    access point without actually being associated with it. In fact, we will use monitor
    mode several times in this book to perform tasks such as the recovering of keys
    in web and WPA, as well as other tasks.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: The exact procedure for enabling monitor mode will vary, in some cases dramatically,
    depending on the wireless card and associated drivers that you are using. In order
    to determine the driver that you are currently using, you can simply run the following
    command.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On a machine with a Ralink, an Atheros, and a Broadcom wireless card installed,
    the system responds as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae60705b-405d-4429-9ee7-97587aeb6743.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: The next tool that we will logically use to follow up our previous tasks is
    a tool known as `airodump-ng`; this tool makes it possible for us to capture packets
    as we need. In fact, this tool is so important that we will make use of it later
    when we perform password and key cracking against a wireless network..
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'We activate this tool by typing the `airodump-ng` command and the renamed monitor
    interface (`mon0`), as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `airodump-ng` command displays all of the access points within range with
    their BSSID (MAC address), their power, the number of beacon frames, the number
    of data packets, the channel, the speed, the encryption method, the type of cipher
    used, the authentication method used, and the ESSID.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Performing a data replay
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's take things up a notch by performing a follow-on attack to sniffing
    commonly known as a replay, or data replay. As the name suggests, information
    that is captured from the network is stored and then played back to the network
    device it was directed at. However, the attack can be much more dangerous if the
    right information is collected and little to no protective measures are used on
    the defensive side.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Information such as login credentials that could be captured during a victims'
    login process could simply be replayed at a server or another resource and access
    granted. This would be tremendously effective in environments where protocols
    that are not encrypted are in use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will perform a replay attack using the **Address Resolution
    Protocol** (**ARP**), but this attack could be modified to carry out other protocols
    and actions. Before we get too far, however, let's talk for a moment about ARP
    and what we are doing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: ARP is used for multiple purposes on a network, but the most common usage is
    associated with locating systems on a network. The protocol works at both layer
    2 and layer 3 of the **Open System Interconnect** (**OSI**) model . In practice,
    layer 2 is the level that switches reside and function at, and is also where MAC
    addresses are defined. The MAC address is an ID, typically assigned by the manufacturer
    and can be changed through software settings, specifically the `ifconfig` utility.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ARP在网络上用于多种目的，但最常见的用途与在网络上定位系统有关。该协议在**开放系统互连**（**OSI**）模型的第2层和第3层上运行。在实践中，第2层是交换机所在和功能的级别，也是MAC地址定义的地方。MAC地址是一种ID，通常由制造商分配，并且可以通过软件设置（特别是`ifconfig`实用程序）进行更改。
- en: On a subnet, IP addresses are not the main mechanism for identifying machines
    that wish to communicate; this is the function of the MAC address.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在子网上，IP地址不是用于识别希望通信的机器的主要机制；这是MAC地址的功能。
- en: If we consider a single subnet, and we consider two hosts on that subnet trying
    to communicate, we now have a situation where an MAC address will be used instead
    of an IP address. IP addresses would only be used in situations where traffic
    needs to be routed between different subnets or networks. On a local subnet MAC
    is the main mechanism used to get traffic from one point to another.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑单个子网，并且考虑在该子网上尝试通信的两个主机，那么现在将使用MAC地址而不是IP地址。只有在需要在不同的子网或网络之间路由流量的情况下才会使用IP地址。在本地子网上，MAC是将流量从一点传输到另一点的主要机制。
- en: Under normal operation, systems will keep in ARP lookup table or cashe where
    they store information about which IP addresses are associated with which MAC
    addresses. When trying to send data such as a packet to another host on a subnet,
    the sender will look at the IP address it is destined for and once it is found
    to be on the same subnet then an art broadcast will be sent. This broadcast will
    be sent out on the subnet and, in essence, will ask other clients on that subnet
    who owns a specific IP address and for that host to return its MAC address.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常操作下，系统将保留ARP查找表或缓存，其中存储有关哪些IP地址与哪些MAC地址相关联的信息。当尝试发送数据（例如数据包）到子网上的另一个主机时，发送方将查看其目的IP地址，一旦发现其位于相同的子网上，就会发送ARP广播。此广播将在子网上发送出去，并且实质上将询问该子网上的其他客户端谁拥有特定的IP地址，并要求该主机返回其MAC地址。
- en: It is worth noting that if a host has already talked to another host previously
    on the same subnet, the IP address and MAC address association will already be
    stored in the cache on the local system, which is also known as an ARP table.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果主机先前已经在同一子网上与另一个主机通信过，那么IP地址和MAC地址的关联将已经存储在本地系统的缓存中，这也称为ARP表。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To get things started you will need to have the following items in place:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要准备以下物品：
- en: A wireless card capable of entering monitor mode
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够进入监视模式的无线网卡
- en: Kali Linux
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kali Linux
- en: The items listed here are basic requirements and you could easily use more (or
    different) components if so desired. If you want enhanced range, for example,
    you could use a USB-based wireless card that has connection to an external antenna
    that could get better reception. You could also use a different wireless application
    instead of Kismet to complete this task, however since Kismet is very popular
    we will use it in this recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的物品是基本要求，如果需要，您可以轻松使用更多（或不同）组件。例如，如果您想要增强范围，可以使用具有连接到外部天线的USB无线网卡，以获得更好的接收。您还可以使用不同的无线应用程序来完成此任务，但是由于Kismet非常受欢迎，因此我们将在本文中使用它。
- en: 'In this recipe we will be using a set of tools from the `aircrack-ng` suite,
    which itself includes many different tools we will be encountering later in other
    chapters. The tools we will be using are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们将使用`aircrack-ng`套件中的一组工具，该套件本身包括我们将在其他章节中遇到的许多不同的工具。我们将使用的工具包括：
- en: '`airodump-ng`: this is used for sniffing traffic as it flows by on the network.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`airodump-ng`：这用于嗅探网络上流动的流量。'
- en: '`aireplay-ng`: which is used to generate traffic for the purpose of cracking
    shared keys or causing deauthentication situations, as we will see later. There
    are options that can cause deauthentications for the purpose of capturing WPA
    handshake data, fake authentications, interactive packet replay, hand-crafted
    ARP request injection, and ARP-request re-injection.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aireplay-ng`：用于生成流量以破解共享密钥或引起去认证情况，稍后我们将看到。有一些选项可以引起去认证，以捕获WPA握手数据，伪造认证，交互式数据包重放，手工ARP请求注入和ARP请求重注入。'
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: First, open a console to use `airodump-ng` to start sniffing for traffic. `aireplay-ng`
    and `airodump-ng` will run simultaneously, but in different consoles.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个控制台使用`airodump-ng`开始嗅探流量。`aireplay-ng`和`airodump-ng`将同时运行，但在不同的控制台中。
- en: 'To start `airodump`, use the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`airodump`，请使用以下命令：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Press *Enter, *It may take a few moments, but wait for the target network to
    show up in your list; an example is shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Enter*，可能需要一些时间，但等待目标网络出现在列表中；以下是示例：
- en: '![](img/49e6003e-66af-448f-bc37-1d955e2e7fac.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49e6003e-66af-448f-bc37-1d955e2e7fac.png)'
- en: Note the MAC addresses shown in the first column.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第一列中显示的MAC地址。
- en: 'Once your target shows up you can start `aireplay`. In a second console, enter
    the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的目标出现，您可以开始`aireplay`。在第二个控制台中，输入以下内容：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-b` specifies the target BSSID, `-h` the MAC of the connected client.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`-b`指定目标BSSID，`-h`指定连接的客户端的MAC。'
- en: 'Now you have to wait for an ARP packet to arrive. Usually you''ll have to wait
    for a few minutes. Once successful, you''ll see something similar to the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您必须等待ARP数据包到达。通常您需要等待几分钟。一旦成功，您将看到类似以下内容：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You must also start `airodump` to capture replies:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还必须启动`airodump`来捕获回复：
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next step is reusing the captured ARP packets saved in the file. You will
    notice that it said the ARP requests were being saved in `replay_arp-1001.cap`.
    So, rather than waiting for a new ARP, we simply reuse the old ones with the `-r`
    parameter:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The system responds:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Cracking WEP
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the unique characteristics of wireless networks over other networks is
    of course the fact they don't use traditional media and instead use radio waves
    to carry their information from point to point. This is what makes the networks
    so attractive and popular, in that a person can carry their device anywhere within
    range of the wireless network and still maintain that access without having to
    worry about cables and such. However, this strength comes at a price, and that
    is that radio signals are indiscriminate and anyone who is in a position to receive
    them will also be in a position to process the information they carry.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, the designers of wireless networks saw this as an issue
    and decided to build in protection to the initial specification of the IEEE 802.11b
    network design in the form of **Wired Equivalent Privacy** (**WEP**). At the time
    of release, WEP was viewed as a good feature, however it wasn't too long before
    problems emerged and subsequently snowballed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: WEP, is the oldest and arguably the weakest of the available encryption protocols.
    The WEP standard was introduced as the initial solution to wireless security but
    was quickly found to be flawed and highly vulnerable.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: WPA, or Wi-Fi Protected Access, was the successor to WEP and was intended to
    address many of the problems that plagued WEP. In many areas it succeeded and
    made for a much tougher security protocol. WPA uses TKIP, MIC, and AES encryption
    as its main mechanism for securing information.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: WPA2 is the upgrade or successor to WPA and was intended to address and replace
    the problems with WPA. WPA2 is much stronger and uses tougher encryption in the
    form of AES and CCMP. The standard also comes in a version that uses stronger
    systems such as EAP, TKIP, and AES (with longer keys).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the problems, however, let's see how WEP is supposed to work
    before moving on and looking at how to exploit its problems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: WEP is the oldest of the wireless encryption protocols and when originally introduced
    and integrated into the 802.11b standard, it was viewed as a way of providing
    security of data transmissions more or less on a par with that of wired networks.
    As designed, the WEP protocol made use of some existing technologies, including
    the RC4 encryption protocol.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'When it was designed and debuted it was intended to accomplish the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Defeat eavesdropping on communications and attempt to reduce unauthorized disclosure
    of data
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the integrity of data as it flows across the network
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a shared secret key to encrypt packets prior to transmission
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide confidentiality, access control, and integrity in a lightweight, efficient
    system
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Its problems arise from the following circumstances:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The protocol was designed without review from experienced cryptologists or the
    academic community, or even the public.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides no clearly-defined method for key distribution (such as centralized
    key management) other than pre-shared keys, which must be input manually into
    each station. As a result, the keys are cumbersome to change on a large scale;
    thus, rarely changed.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its design makes it possible to passively uncover the key using sniffing tools
    and cracking tools available freely in operating systems, such as the Linux-based
    Kali.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key generators used by different vendors are inconsistently and poorly designed,
    leading to vulnerabilities such as issues with the use of 40-bit keys.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithms used to perform key scheduling have been shown to be vulnerable
    to attack.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRC32 used in integrity checking is flawed, and with slight modifications packets
    may be modified consistently by an attacker to produce their desired results.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initialization Vectors** (**IVs**) are only 24-bits in length, meaning that
    an entire pool of IVs can be exhausted by a mildly active network in five hours
    or less.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is susceptible to known plaintext attacks through the analysis of packets.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys may be uncovered through the analysis of packets allowing for the creation
    of a decryption table.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is susceptible to denial of service attacks through the use of associate
    and disassociate messages, which are not authenticated by WEP.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are basic requirements and you could easily use more (or
    different) components if so desired. If you want enhanced range, for example,
    you could use a USB-based wireless card that has connections for an external antenna
    that could get better reception.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to crack the WEP key for an access point running the protocol, there
    is a process involved that requires the collection of what is known as **Initialization
    Vectors** (**IVs**). The problem with this process is that under normal conditions
    a network does not generate a lot of these items in a short period of time. Under
    normal conditions, this means we would have to wait a prolonged period of time
    to get enough IVs to retrieve the network key. However, we can speed up this process
    by utilizing the information from our previous recipe together with some new skills
    to retrieve the key. To put it simply, we will inject packets into the network
    in an effort to get the AP to generate a large number of packets in a substantially
    shorter period of time, which means that the ability to capture more packets with
    weak IVs is increased.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: With this process complete we can then use the captured traffic to retrieve
    the key.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the steps we will be looking at here in this recipe will be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Start the wireless interface in monitor mode on the specific AP channel.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the injection capability of the wireless device to the AP.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `aireplay-ng` to do a fake authentication with the access point.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `airodump-ng` on an AP channel with a `bssid` filter to collect the new
    unique IVs.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `aireplay-ng` in ARP request replay mode to inject packets.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `aircrack-ng` to crack the key using the IVs collected.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Phase one – configuring monitor mode
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step we need to perform for breaking WEP is to switch our card to
    monitor mode, as we did previously. We need to do this in order to allow the network
    interface to detect every packet that is being transmitted by nearby networks.
    To do this on a network interface named `wlan0`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '`airodump-ng` start `wlan0 9` (the `9` will lock the card to listening on channel
    `9`, but this can be changed to the channel on the access point you wish to observe.
    You can discover the channel of the access point you wish to target by running
    the command without the channel designator).'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter.*
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will notice that `ath0` is reported above as being put into monitor mode.
    To confirm the interface is properly set up, enter `iwconfig`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The system will respond:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the response above, you can see that `ath0` is in monitor mode on the `2.452
    GHz` frequency, which is channel 9, and the Access Point shows the MAC address
    of your wireless card. It is important to confirm the configuration of the adapter
    prior to continuing to avoid issues later on. Improper configuration can result
    in the cracking process not working properly or at all.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Phase two – packet injection
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to ensure that we can properly attack the network we need to ensure
    that we are close enough to perform a packet injection. In order to verify this,
    we would run the following commands:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`-e ganon`: This is the wireless network name'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a 00:28:6C:E4:40:80`: This is the access point MAC address'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The system should respond with:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The last line is important as we are looking for a value close to `100%`; if
    this value is low it indicates that you are too far away from the access point
    or not getting a good signal. If that is the case, try changing position.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Phase three – capturing IVs
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have come this far, we need to let her rip and start capturing those
    tasty IVs. We do this by using `airodump` to help us capture this precious information.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a second console session and leave the previous one open to capture the
    generated IVs. Then, enter:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'While the injection is being carried out, the screen will look similar to this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Phase four – performing a fake authentication
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next step in making this process work is to authenticate with the access
    point. This is important, as if we perform a packet injection without the association
    and with the access point present, the process will fail and the connection will
    be rejected. In fact, if the source MAC address which is being injected is not
    associated, the targeted API will ignore the packet and send out a deauthentication
    packet in cleartext to refuse the connection attempt. When this occurs, no new
    IVs are created because the AP is ignoring all the injected packets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The MAC you use for injection must be associated with the AP by either using
    fake authentication or by using an MAC from an already-associated client.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to associate a client with an access point, we will we use fake authentication:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`-1` means fake authentication'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` re-association timing in seconds'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e` ganon is the wireless network name'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a 00:14:6C:7E:40:80` is the access point MAC address'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h 00:0F:B5:88:AC:82` is our card MAC address'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Success looks like:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or another variation for picky access points:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`6000`: Reauthenticate every `6000` seconds. The long period also causes keep
    alive packets to be sent.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o 1`: Sends only one set of packets at a time. Default is multiple and this
    confuses some APs.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q 10`: Sends alive packets every `10` seconds.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Success looks like:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If authentication fails, however, the following would be the result:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that in this example a `Got a deauthentication packet` message occurred
    followed by a series of retries. If this occurs, it means you cannot continue
    successfully and you must try again to see if you can get a successful association.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Phase five – ARP replay mode
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Harkening back to a previous recipe, we will use `aireplay-ng` to listen for
    ARP requests and then use this captured information to re-inject packets back
    into the network. In this situation, we are making use of ARP request packets,
    mainly due to the fact that the AP will re-broadcast them and as a result generate
    a new IV. Since this is our main objective, to obtain a large number of IVs in
    a short period of time, we are proceeding with this action.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the injection, we need to open another console and enter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will start listening for ARP requests and when it hears one, `aireplay-ng`
    will immediately start to inject it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'If the process completes successfully, expect to see output similar to the
    following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can confirm that you are injecting by checking your `airodump-ng` screen.
    The data packets should be increasing rapidly. The `#/s` should be a decent number.
    However, decent depends on a large variety of factors. A typical range is `300`
    to `400` data packets per second. It can be as low as 100/second and as high as
    500/second.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Phase six – obtaining the WEP key
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have captured the traffic to a `.cap` file, we will now try to
    retrieve the key from the captured packets. To do this we do the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another new console session and enter:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`-b 00:14:6C:7E:40:80` selects the one access point we are interested in.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`.cap` selects all files starting with output and ending in `.cap`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: You can run this while generating packets. In a short time, the WEP key will
    be calculated and presented. You will need approximately 250,000 IVs for 64-bit
    and 1,500,000 IVs for 128-bit keys. Note that these values are rough guidelines
    and other variables can impact how much traffic and how many IVs you actually
    need to collect.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the process completes successfully, you should see something like the following:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that the key is not displayed as you would expect it to be. The characters
    next to Key Found between the square brackets are the passkey in hexadecimal.
    If you remove the colons and then paste the remaining characters into your wireless
    client when prompted to associate with the network, it will still work.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
