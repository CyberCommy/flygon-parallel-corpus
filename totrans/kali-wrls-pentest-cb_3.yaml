- en: Attacking Integrity Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing on a wireless network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with monitor mode and packet injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a data replay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking WEP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with any type of network or information one of the fundamental
    components that needs to be addressed is that of integrity. The integrity of data
    is essential as the receiver of a piece of information needs to have confidence
    that what they are receiving and relying on is faithful to the intent of the creator
    and sender of that data. If the integrity, and therefore confidence, in data is
    lost then data becomes essentially worthless.
  prefs: []
  type: TYPE_NORMAL
- en: If you have been in security long enough you have undoubtedly run into the well-known
    **CIA** triad, which is shorthand for **Confidentiality**, **Integrity**, and
    **Availability**. Simply put, the confidentiality refers to keeping information
    safe from unauthorized access or disclosure. Availability refers to the practice
    of keeping access to systems and data constant or near constant as possible (typically
    this is discussed in terms of uptime, such as 99.999% uptime). Finally, the integrity
    component is what we are addressing here in this chapter. Integrity of data ensures
    that the information is free from errors, corruptions, modifications, or anything
    done by an unauthorized third-party.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when working with CIA, providing one does not imply you are doing
    anything to address the rest. For example, providing integrity controls does not
    in any way imply that there is confidentiality of information as well, as that
    is a separate type of control. In fact, in many cases you will provide protection
    for one aspect of CIA, but not the others. For example, you may want to ensure
    an email you send out is readable by everyone, but you may place controls on it
    to ensure that no one can alter it to make it look like you are saying something
    you are not.
  prefs: []
  type: TYPE_NORMAL
- en: It is important for you to keep in mind that there is no magic bullet or formula
    stating the perfect balance of these three components for any organization or
    individual. You will have to perform a risk assessment or evaluation to determine
    the balance in your situation based on your unique threats and vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: To compromise the integrity of data, an attacker needs to simply find a way
    to alter or corrupt data in such a way that it is called into question or cannot
    be used as originally intended. To perform integrity-based attacks, a malicious
    party will seek to gain access to a network (in our case, wireless) and impact
    the data stream and modify the data in some way. How they modify the data will
    depend on their specific goals and intentions.
  prefs: []
  type: TYPE_NORMAL
- en: If the malicious party seeks to make data worthless they can redirect it, corrupt
    it, or even prevent it from getting to where it's intended to go. If the malicious
    party seeks to change data in such a way to alter the results of a process, they
    may use any number of tools designed to alter the values or structure of data
    in such a way to achieve their result. For example, an attacker may intercept
    stock quotes and change the values of various stocks on the way to the recipient
    to induce them to buy or sell when they otherwise wouldn't. Finally, impacting
    the integrity of a network itself could also allow an attacker to break security
    and intercept information such as credentials and other valuable 'nuggets' of
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In wireless networks, attacks that impact integrity are broad and powerful
    and can take a number of different forms, each of which can be used independently
    or in combination to create a more robust attack solution. Some examples of integrity
    control mechanisms used in wireless are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encryption**: This is a very useful control or countermeasure to both confidentiality
    and integrity. In the case of integrity, data that is encrypted and hashed is
    more resistant to compromise either because it is undecipherable without the key
    or (as is the case with hashing) changes in the data will result in it becoming
    invalidated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-Shared Key** (**PSK**) **systems**: This involves the use of systems
    where a common key is entered on each workstation or device that allows it to
    authenticate to the wireless access point. This type of protection usually comes
    in the form of non-enterprise WEP, WPA, or WPA2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enterprise authentication**: This type of system works in the same way as
    PSK-based environments, except that the key management is centralized through
    the use of systems such as RADIUS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is just a short list of potential measures that can be deployed to enforce
    integrity, however there are many more that are available outside of the wireless
    environment that can supplement or replace what has been mentioned in this list.
  prefs: []
  type: TYPE_NORMAL
- en: Once network access is gained and the integrity of data called into question,
    the attacker may choose to alter things for whatever ends they so choose.
  prefs: []
  type: TYPE_NORMAL
- en: Types of attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many integrity control attacks, and all are very effective when used
    by a skilled and practiced hand. The ones covered within the pages of this chapter
    represent some of the most effective and popular methods that can be deployed
    on and against wireless networks and their client devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start exploring each one of our attacks, let''s first lay out the
    attacks that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data replays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet injections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detection of beacon frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spoofing of beacon frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember these are just a few of the types of attacks that can be used to subvert
    the integrity of a wireless network; they should never be considered the only
    types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Sniffing on a wireless network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sniffing is a technique that is used to observe the traffic on a network as
    it makes its way from sender to receiver (and back in many cases). Sniffing allows
    you to capture traffic either in real-time, and distill it through the use of
    filters, or it can be captured and saved to a file for later analysis and processing.
    Sniffing is a powerful technique for gaining information about a network and the
    devices on it, which in turn can be used as a foundation for later activities
    based on the results achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I refer to sniffing in the first line of this paragraph as a technique
    for observing traffic moving across a network. This is an important detail that
    I feel may be subtle and needs to be pointed out accordingly. Sniffing itself
    should never be considered something used for performing attacks, lest we become
    stuck in our thinking that this is all it is good for. In fact, sniffing is a
    technique that is used every day for completely benign and productive means. Network
    administrators use sniffers to diagnose network problems, optimize performance,
    and for plenty of other beneficial means.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we are simply taking the ability of sniffing to capture information
    from a network and then acting upon what we discover. The benign or malicious
    use of this tool lies in what the intention to do with the results happens to
    be.
  prefs: []
  type: TYPE_NORMAL
- en: How does sniffing work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sniffing works by making use of or altering certain conditions. The goal of
    sniffing is to observe the traffic that happens to be moving by the system that
    is performing the sniffing, but under normal conditions of operation any system
    will only be allowed to see the information addressed directly to it or coming
    from it. This makes sense, as a system that has to process all the information
    that flowed by would be bogged down by inefficiency and poor performance - not
    to mention it would be a security risk as well.
  prefs: []
  type: TYPE_NORMAL
- en: In order to view all of the traffic flowing by, a network adapter needs to switch
    into what is known as promiscuous mode. To understand promiscuous mode, first
    understand that under normal conditions a network adapter does not run under this
    condition. In practice, an adapter running in non-promiscuous mode will filter
    out all traffic that is not intended for it and will only process those that are
    addressed to it. When a network card is switched into promiscuous mode, however,
    things change. In promiscuous mode, an adapter will no longer filter out traffic
    not intended for it and will allow all traffic to be viewed by software (that
    is designed to process this information) installed on the system. The following
    diagram shows an adapter in promiscuous mode placed on a network.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/819ea064-c7ae-483e-abee-83dd39062afe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A system setup to perform sniffing
  prefs: []
  type: TYPE_NORMAL
- en: In modern network environments, just about every network adapter can switch
    into promiscuous mode and needs only to be instructed to do so. However, in most
    situations, the switch into this mode is completely unnecessary for normal operations,
    as a device only need see the information intended for it. It is because of this
    that using methods designed to detect this mode in use on a system are effective
    at locating systems that may be running unauthorized sniffing activities. Do keep
    in mind that a card in promiscuous mode itself is not cause for alarm as there
    are legitimate reasons that a network adapter may run in this mode. One prime
    example is the case of **Network Intrusion Detection Systems** (**NIDS**), that
    are designed to detect and then alert the network administrator to the presence
    of suspect traffic or activities. By their very nature, these systems must run
    in promiscuous mode to be able to observe all traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In wireless networks we do not have promiscuous mode, however we have something
    that we mentioned in [Chapter 2](e5d8f3be-e22e-4d20-a76f-74951b0db836.xhtml), *Attacking
    Access Controls,* known as monitor mode. Monitor mode comes with some features
    that are different to the promiscuous model. First, a card switched into monitor
    mode can observe the data transmitted on a wireless network without having to
    associate with it first. Second, monitor mode prevents the card from transmitting
    data in most cases. Third, a card may be restricted to listening on one channel
    at a time, but this can vary depending on the device and driver involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other note: many network cards included in smartphones, tablets, and similar
    gadgets do not support promiscuous mode and must therefore make use of an external
    adapter to gain this ability.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to observe all the traffic on a network, once we are in promiscuous
    mode we must be able to see the traffic in the first place. In other words, you
    can't eavesdrop on a conversation if you are not in the same room with the people
    you wish to listen in on (bugging devices and NSA gadgets not included). In a
    network, this means that you must be on the same collision domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a traditional wired network, where all devices are connected through a hub,
    they are all effectively on the same collision domain. Think of the way a hub
    functions: traffic that is sent to one port on a hub is automatically sent to
    all ports on the hub. Since any station can transmit at any time collisions can
    and do happen, which leads to what is known as a collision domain. When this type
    of situation exists, it is possible to listen in on traffic on the network quite
    easily because every station shares the same logical transmission area. Basically,
    sniffing is effective when the observer and the victim exist such that each can
    see each other''s actions.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that on modern networks the use of hubs is something that is frowned upon
    for many reasons, including what we are discussing here for sniffing. In modern
    networks, switches have utterly replaced hubs in production to avoid this sort
    of risk, as well as to optimize network performance and ease administration.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, the same type of situation exists for wireless networks, where
    traffic can be observed by other parties who happen to be set up to look for it.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that traditional wired networks use a collision-based technology in
    their design known as **CSMA/CD**, which is short for **Carrier Sense Multiple
    Access** **with** **Collision Detection**. What this means in practice is that
    if two or more stations happen to transmit at one time they will cause a collision
    (think of it as two people talking at the same time). This technology will detect
    the collision and deal with it by forcing both stations to wait a random period
    of time before retransmitting and hopefully avoiding another collision. Collisions
    are a normal part of many networks and are not a problem until the collisions
    get excessive, in which case a network can be segmented to reduce the number to
    a better number.
  prefs: []
  type: TYPE_NORMAL
- en: In wireless networks, a technique known as **CSMA/CA** or **Carrier Sense Multiple
    Access** **with** **Collision Avoidance** is used. As you may guess, the process
    involves not detecting a collision, but rather avoiding a collision altogether.
    In practice, this means that a station will check to see if anyone is transmitting,
    and if they are not it will send out a signal saying it is ready to transmit to
    keep any other station from sending data. At this point, the device will transmit
    and signal when it is done transmitting so the network is released.
  prefs: []
  type: TYPE_NORMAL
- en: Some wired networks do use CSMA/CA, but this is not incredibly common.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next component of performing a successful sniff is to have the software
    in the form of a network sniffer. In Kali Linux, we have a number of tools designed
    to do this very thing; some of the most popular tools are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dsniff**: This is a suite of tools all revolving around the common theme
    of sniffing, with each designed to perform a specific type of sniffing very effectively
    and on a granular level. Many of the tools are centered around a specific protocol
    or purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tcpdump**: This is one of the most used network sniffer/analyzers for Linux.
    Tcpdump is a command-line tool that is great for displaying header information.
    Tcpdump is available at [www.tcpdump.org](http://www.tcpdump.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EtherApe**: This is a Linux/UNIX tool that is designed to graphically display
    the connections incoming and outgoing from a system in order to better visualize
    network activity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wireshark**: One of the most widely known and used packet sniffers. Offers
    a tremendous number of features all designed to assist in the dissection and analysis
    of traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kismet**: We saw this utility back in [Chapter 2](e5d8f3be-e22e-4d20-a76f-74951b0db836.xhtml), *Attacking
    Access Controls,* when we performed war driving. This utility is one that wears
    many hats, including that of a packet sniffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sniffers are utilities that are used to capture and scan traffic moving across
    a network. You will find sniffers to be a very valuable as tool in your arsenal
    for many different attacks, but why are they so powerful? One of the biggest reasons
    to use sniffers is to capture and dissect unencrypted network traffic, at least
    in our situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'How successful sniffers are depends on the relative and inherent insecurity
    of certain network protocols. Protocols such as the tried and true TCP/IP were
    never designed with security in mind and therefore do not offer much in this area.
    Several protocols lend themselves to easy sniffing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Telnet/RLOGIN**: Keystrokes, such as those including usernames and passwords,
    that can be easily sniffed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP**: Designed to send information in the clear without any protection
    and thus a good target for sniffing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Mail Transfer Protocol** (**SMTP**): Commonly used in the transfer
    of email, this protocol is efficient, but it does not include any protection against
    sniffing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network News Transfer Protocol** (**NNTP**): All communication, including
    passwords and data, is sent in the clear'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post Office Protocol** (**POP**): Designed to retrieve email from servers,
    this protocol does not include protection against sniffing because passwords and
    usernames can be intercepted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File Transfer Protocol** (**FTP**): A protocol designed to send and receive
    files; all transmissions are sent in the clear'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internet Message Access Protocol** (**IMAP**): Similar to SMTP in function
    and lack of protection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the protocols listed here transmit their information in the clear to
    include passwords, usernames, keystrokes, and data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started, you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering promiscuous mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux with Wireshark installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wireshark should be installed as part of your default installation of Kali Linux
    like it always has been. You should not have to install this software package,
    rather you should be able to just select it from the Sniffing menu under the Applications
    menu in Kali.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to get into the habit of saving your sniffing activities into PCAP
    files. These files are supported by a number of different sniffing utilities (as
    well as other applications) to support the saving of captured network activity
    for later or further analysis. Since network conditions can vary (dramatically
    at sometimes), and the situation you are observing and may be curious about may
    be unique, you may want to save the file for later reference and review.
  prefs: []
  type: TYPE_NORMAL
- en: Start Wireshark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the interface from the following screen that you wish to perform sniffing
    with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0cca468-0c7e-4a28-97e5-a4c6b2ae53c4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select sniffing interface screen
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can use Capture interface and tick the interface that matches
    your wireless adapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the Start button here and Wireshark will start capturing traffic. The
    Start button will look like a shark fin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, you should start observing traffic being captured in the main
    Wireshark window. At the level we are looking at here there is really no difference
    between sniffing wireless traffic and wired traffic. However, there are some things
    you can do to go further with sniffing in wireless, which we will explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Working with monitor mode and packet injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next item to introduce into the sniffing process is a mode known as monitor
    mode. Monitor mode is a special type of operation restricted specifically to wireless
    adapters. This mode is used to allow the wireless adapter to view traffic on wireless
    networks that it is not currently associated with. This mode allows us to use
    a sniffer to capture traffic from any wireless network in the area without restriction.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor mode is supported on most modern wireless adapters, however it is not
    universally supported. On Linux, most wireless adapters can be switched to monitor
    mode with a few command line configurations. This is different than what you may
    have experienced on the Microsoft Windows platform, where monitor mode is normally
    only available through the use of external adapters such as AirPcap.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is important to make sure that you do not confuse monitor mode
    with promiscuous mode as they are not the same. Promiscuous mode is available
    on both wired and wireless networks and allows for the view of all traffic that
    is flowing past the sniffing machine whether it involves them or not. Monitor
    mode is exclusive to wireless and allows for the viewing of traffic on wireless
    networks that you are not currently associated with. They are very similar, but
    not the same.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux with Wireshark installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we will switch a network card into monitor mode so it can be
    used to observe traffic from non-associated access points.
  prefs: []
  type: TYPE_NORMAL
- en: In order to switch the network adapter into monitor mode we can use `ifconfig`
    to identify the wireless adapter if you don't know its name already. If you do
    know the name, then perform the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Open up a Terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Press *Enter* and this will bring the network adapter offline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Press *Enter* to switch the card to monitor mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Press *Enter* to bring the network adapter back online.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These commands will put the wireless card into monitor mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To take advantage of the card being in monitor mode, we can issue the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Putting a card into monitor mode is very important as it allows us to proceed
    to later steps and perform them successfully. Under normal conditions a wireless
    adapter must be associated with a wireless access point to be able to view and
    observe traffic in the same way a sniffer would on a wired network. To perform
    attacks without being associated with an access point we would use monitor mode.
    Monitor mode will let us view the traffic associated with a wireless network or
    access point without actually being associated with it. In fact, we will use monitor
    mode several times in this book to perform tasks such as the recovering of keys
    in web and WPA, as well as other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The exact procedure for enabling monitor mode will vary, in some cases dramatically,
    depending on the wireless card and associated drivers that you are using. In order
    to determine the driver that you are currently using, you can simply run the following
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On a machine with a Ralink, an Atheros, and a Broadcom wireless card installed,
    the system responds as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae60705b-405d-4429-9ee7-97587aeb6743.png)'
  prefs: []
  type: TYPE_IMG
- en: The next tool that we will logically use to follow up our previous tasks is
    a tool known as `airodump-ng`; this tool makes it possible for us to capture packets
    as we need. In fact, this tool is so important that we will make use of it later
    when we perform password and key cracking against a wireless network..
  prefs: []
  type: TYPE_NORMAL
- en: 'We activate this tool by typing the `airodump-ng` command and the renamed monitor
    interface (`mon0`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `airodump-ng` command displays all of the access points within range with
    their BSSID (MAC address), their power, the number of beacon frames, the number
    of data packets, the channel, the speed, the encryption method, the type of cipher
    used, the authentication method used, and the ESSID.
  prefs: []
  type: TYPE_NORMAL
- en: Performing a data replay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's take things up a notch by performing a follow-on attack to sniffing
    commonly known as a replay, or data replay. As the name suggests, information
    that is captured from the network is stored and then played back to the network
    device it was directed at. However, the attack can be much more dangerous if the
    right information is collected and little to no protective measures are used on
    the defensive side.
  prefs: []
  type: TYPE_NORMAL
- en: Information such as login credentials that could be captured during a victims'
    login process could simply be replayed at a server or another resource and access
    granted. This would be tremendously effective in environments where protocols
    that are not encrypted are in use.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will perform a replay attack using the **Address Resolution
    Protocol** (**ARP**), but this attack could be modified to carry out other protocols
    and actions. Before we get too far, however, let's talk for a moment about ARP
    and what we are doing.
  prefs: []
  type: TYPE_NORMAL
- en: ARP is used for multiple purposes on a network, but the most common usage is
    associated with locating systems on a network. The protocol works at both layer
    2 and layer 3 of the **Open System Interconnect** (**OSI**) model . In practice,
    layer 2 is the level that switches reside and function at, and is also where MAC
    addresses are defined. The MAC address is an ID, typically assigned by the manufacturer
    and can be changed through software settings, specifically the `ifconfig` utility.
  prefs: []
  type: TYPE_NORMAL
- en: On a subnet, IP addresses are not the main mechanism for identifying machines
    that wish to communicate; this is the function of the MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: If we consider a single subnet, and we consider two hosts on that subnet trying
    to communicate, we now have a situation where an MAC address will be used instead
    of an IP address. IP addresses would only be used in situations where traffic
    needs to be routed between different subnets or networks. On a local subnet MAC
    is the main mechanism used to get traffic from one point to another.
  prefs: []
  type: TYPE_NORMAL
- en: Under normal operation, systems will keep in ARP lookup table or cashe where
    they store information about which IP addresses are associated with which MAC
    addresses. When trying to send data such as a packet to another host on a subnet,
    the sender will look at the IP address it is destined for and once it is found
    to be on the same subnet then an art broadcast will be sent. This broadcast will
    be sent out on the subnet and, in essence, will ask other clients on that subnet
    who owns a specific IP address and for that host to return its MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that if a host has already talked to another host previously
    on the same subnet, the IP address and MAC address association will already be
    stored in the cache on the local system, which is also known as an ARP table.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are basic requirements and you could easily use more (or
    different) components if so desired. If you want enhanced range, for example,
    you could use a USB-based wireless card that has connection to an external antenna
    that could get better reception. You could also use a different wireless application
    instead of Kismet to complete this task, however since Kismet is very popular
    we will use it in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe we will be using a set of tools from the `aircrack-ng` suite,
    which itself includes many different tools we will be encountering later in other
    chapters. The tools we will be using are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`airodump-ng`: this is used for sniffing traffic as it flows by on the network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`aireplay-ng`: which is used to generate traffic for the purpose of cracking
    shared keys or causing deauthentication situations, as we will see later. There
    are options that can cause deauthentications for the purpose of capturing WPA
    handshake data, fake authentications, interactive packet replay, hand-crafted
    ARP request injection, and ARP-request re-injection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, open a console to use `airodump-ng` to start sniffing for traffic. `aireplay-ng`
    and `airodump-ng` will run simultaneously, but in different consoles.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start `airodump`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Press *Enter, *It may take a few moments, but wait for the target network to
    show up in your list; an example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49e6003e-66af-448f-bc37-1d955e2e7fac.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the MAC addresses shown in the first column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your target shows up you can start `aireplay`. In a second console, enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-b` specifies the target BSSID, `-h` the MAC of the connected client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have to wait for an ARP packet to arrive. Usually you''ll have to wait
    for a few minutes. Once successful, you''ll see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You must also start `airodump` to capture replies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is reusing the captured ARP packets saved in the file. You will
    notice that it said the ARP requests were being saved in `replay_arp-1001.cap`.
    So, rather than waiting for a new ARP, we simply reuse the old ones with the `-r`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The system responds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Cracking WEP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the unique characteristics of wireless networks over other networks is
    of course the fact they don't use traditional media and instead use radio waves
    to carry their information from point to point. This is what makes the networks
    so attractive and popular, in that a person can carry their device anywhere within
    range of the wireless network and still maintain that access without having to
    worry about cables and such. However, this strength comes at a price, and that
    is that radio signals are indiscriminate and anyone who is in a position to receive
    them will also be in a position to process the information they carry.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, the designers of wireless networks saw this as an issue
    and decided to build in protection to the initial specification of the IEEE 802.11b
    network design in the form of **Wired Equivalent Privacy** (**WEP**). At the time
    of release, WEP was viewed as a good feature, however it wasn't too long before
    problems emerged and subsequently snowballed.
  prefs: []
  type: TYPE_NORMAL
- en: WEP, is the oldest and arguably the weakest of the available encryption protocols.
    The WEP standard was introduced as the initial solution to wireless security but
    was quickly found to be flawed and highly vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: WPA, or Wi-Fi Protected Access, was the successor to WEP and was intended to
    address many of the problems that plagued WEP. In many areas it succeeded and
    made for a much tougher security protocol. WPA uses TKIP, MIC, and AES encryption
    as its main mechanism for securing information.
  prefs: []
  type: TYPE_NORMAL
- en: WPA2 is the upgrade or successor to WPA and was intended to address and replace
    the problems with WPA. WPA2 is much stronger and uses tougher encryption in the
    form of AES and CCMP. The standard also comes in a version that uses stronger
    systems such as EAP, TKIP, and AES (with longer keys).
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into the problems, however, let's see how WEP is supposed to work
    before moving on and looking at how to exploit its problems.
  prefs: []
  type: TYPE_NORMAL
- en: WEP is the oldest of the wireless encryption protocols and when originally introduced
    and integrated into the 802.11b standard, it was viewed as a way of providing
    security of data transmissions more or less on a par with that of wired networks.
    As designed, the WEP protocol made use of some existing technologies, including
    the RC4 encryption protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it was designed and debuted it was intended to accomplish the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defeat eavesdropping on communications and attempt to reduce unauthorized disclosure
    of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the integrity of data as it flows across the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a shared secret key to encrypt packets prior to transmission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide confidentiality, access control, and integrity in a lightweight, efficient
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Its problems arise from the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol was designed without review from experienced cryptologists or the
    academic community, or even the public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides no clearly-defined method for key distribution (such as centralized
    key management) other than pre-shared keys, which must be input manually into
    each station. As a result, the keys are cumbersome to change on a large scale;
    thus, rarely changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its design makes it possible to passively uncover the key using sniffing tools
    and cracking tools available freely in operating systems, such as the Linux-based
    Kali.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key generators used by different vendors are inconsistently and poorly designed,
    leading to vulnerabilities such as issues with the use of 40-bit keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The algorithms used to perform key scheduling have been shown to be vulnerable
    to attack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CRC32 used in integrity checking is flawed, and with slight modifications packets
    may be modified consistently by an attacker to produce their desired results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initialization Vectors** (**IVs**) are only 24-bits in length, meaning that
    an entire pool of IVs can be exhausted by a mildly active network in five hours
    or less.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is susceptible to known plaintext attacks through the analysis of packets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys may be uncovered through the analysis of packets allowing for the creation
    of a decryption table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is susceptible to denial of service attacks through the use of associate
    and disassociate messages, which are not authenticated by WEP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get things started you will need to have the following items in place:'
  prefs: []
  type: TYPE_NORMAL
- en: A wireless card capable of entering monitor mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The items listed here are basic requirements and you could easily use more (or
    different) components if so desired. If you want enhanced range, for example,
    you could use a USB-based wireless card that has connections for an external antenna
    that could get better reception.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to crack the WEP key for an access point running the protocol, there
    is a process involved that requires the collection of what is known as **Initialization
    Vectors** (**IVs**). The problem with this process is that under normal conditions
    a network does not generate a lot of these items in a short period of time. Under
    normal conditions, this means we would have to wait a prolonged period of time
    to get enough IVs to retrieve the network key. However, we can speed up this process
    by utilizing the information from our previous recipe together with some new skills
    to retrieve the key. To put it simply, we will inject packets into the network
    in an effort to get the AP to generate a large number of packets in a substantially
    shorter period of time, which means that the ability to capture more packets with
    weak IVs is increased.
  prefs: []
  type: TYPE_NORMAL
- en: With this process complete we can then use the captured traffic to retrieve
    the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, the steps we will be looking at here in this recipe will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the wireless interface in monitor mode on the specific AP channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the injection capability of the wireless device to the AP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `aireplay-ng` to do a fake authentication with the access point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `airodump-ng` on an AP channel with a `bssid` filter to collect the new
    unique IVs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start `aireplay-ng` in ARP request replay mode to inject packets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `aircrack-ng` to crack the key using the IVs collected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Phase one – configuring monitor mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step we need to perform for breaking WEP is to switch our card to
    monitor mode, as we did previously. We need to do this in order to allow the network
    interface to detect every packet that is being transmitted by nearby networks.
    To do this on a network interface named `wlan0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`airodump-ng` start `wlan0 9` (the `9` will lock the card to listening on channel
    `9`, but this can be changed to the channel on the access point you wish to observe.
    You can discover the channel of the access point you wish to target by running
    the command without the channel designator).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Enter.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that `ath0` is reported above as being put into monitor mode.
    To confirm the interface is properly set up, enter `iwconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system will respond:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the response above, you can see that `ath0` is in monitor mode on the `2.452
    GHz` frequency, which is channel 9, and the Access Point shows the MAC address
    of your wireless card. It is important to confirm the configuration of the adapter
    prior to continuing to avoid issues later on. Improper configuration can result
    in the cracking process not working properly or at all.
  prefs: []
  type: TYPE_NORMAL
- en: Phase two – packet injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to ensure that we can properly attack the network we need to ensure
    that we are close enough to perform a packet injection. In order to verify this,
    we would run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`-e ganon`: This is the wireless network name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a 00:28:6C:E4:40:80`: This is the access point MAC address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The system should respond with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The last line is important as we are looking for a value close to `100%`; if
    this value is low it indicates that you are too far away from the access point
    or not getting a good signal. If that is the case, try changing position.
  prefs: []
  type: TYPE_NORMAL
- en: Phase three – capturing IVs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have come this far, we need to let her rip and start capturing those
    tasty IVs. We do this by using `airodump` to help us capture this precious information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a second console session and leave the previous one open to capture the
    generated IVs. Then, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'While the injection is being carried out, the screen will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Phase four – performing a fake authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next step in making this process work is to authenticate with the access
    point. This is important, as if we perform a packet injection without the association
    and with the access point present, the process will fail and the connection will
    be rejected. In fact, if the source MAC address which is being injected is not
    associated, the targeted API will ignore the packet and send out a deauthentication
    packet in cleartext to refuse the connection attempt. When this occurs, no new
    IVs are created because the AP is ignoring all the injected packets.
  prefs: []
  type: TYPE_NORMAL
- en: The MAC you use for injection must be associated with the AP by either using
    fake authentication or by using an MAC from an already-associated client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to associate a client with an access point, we will we use fake authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`-1` means fake authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` re-association timing in seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e` ganon is the wireless network name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a 00:14:6C:7E:40:80` is the access point MAC address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h 00:0F:B5:88:AC:82` is our card MAC address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Success looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Or another variation for picky access points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`6000`: Reauthenticate every `6000` seconds. The long period also causes keep
    alive packets to be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o 1`: Sends only one set of packets at a time. Default is multiple and this
    confuses some APs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q 10`: Sends alive packets every `10` seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Success looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If authentication fails, however, the following would be the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this example a `Got a deauthentication packet` message occurred
    followed by a series of retries. If this occurs, it means you cannot continue
    successfully and you must try again to see if you can get a successful association.
  prefs: []
  type: TYPE_NORMAL
- en: Phase five – ARP replay mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Harkening back to a previous recipe, we will use `aireplay-ng` to listen for
    ARP requests and then use this captured information to re-inject packets back
    into the network. In this situation, we are making use of ARP request packets,
    mainly due to the fact that the AP will re-broadcast them and as a result generate
    a new IV. Since this is our main objective, to obtain a large number of IVs in
    a short period of time, we are proceeding with this action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the injection, we need to open another console and enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will start listening for ARP requests and when it hears one, `aireplay-ng`
    will immediately start to inject it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the process completes successfully, expect to see output similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can confirm that you are injecting by checking your `airodump-ng` screen.
    The data packets should be increasing rapidly. The `#/s` should be a decent number.
    However, decent depends on a large variety of factors. A typical range is `300`
    to `400` data packets per second. It can be as low as 100/second and as high as
    500/second.
  prefs: []
  type: TYPE_NORMAL
- en: Phase six – obtaining the WEP key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have captured the traffic to a `.cap` file, we will now try to
    retrieve the key from the captured packets. To do this we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another new console session and enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`-b 00:14:6C:7E:40:80` selects the one access point we are interested in.'
  prefs: []
  type: TYPE_NORMAL
- en: '`.cap` selects all files starting with output and ending in `.cap`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can run this while generating packets. In a short time, the WEP key will
    be calculated and presented. You will need approximately 250,000 IVs for 64-bit
    and 1,500,000 IVs for 128-bit keys. Note that these values are rough guidelines
    and other variables can impact how much traffic and how many IVs you actually
    need to collect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the process completes successfully, you should see something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that the key is not displayed as you would expect it to be. The characters
    next to Key Found between the square brackets are the passkey in hexadecimal.
    If you remove the colons and then paste the remaining characters into your wireless
    client when prompted to associate with the network, it will still work.
  prefs: []
  type: TYPE_NORMAL
