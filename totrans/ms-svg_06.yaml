- en: JavaScript and SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've learned quite a bit in this book so far about SVG. You've spent a lot
    of time looking at the details of the SVG specification and the different ways
    in which SVG can interact with CSS and HTML. Hopefully, it's been as interesting
    for you as it is for me.
  prefs: []
  type: TYPE_NORMAL
- en: As interesting as it has all been, it's *this* chapter where we'll put *all *the
    tools together to really unlock the power of SVG. Adding JavaScript to the mix
    opens up a huge number of new possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Granted, there are many web developers and designers who will never do animation,
    dynamic visualizations, or other interactive work with SVG. For them, getting
    a full understanding of the way that SVG itself works as markup and how it fits
    in with other static web technologies is incredibly valuable. This is especially
    true of the intersection between SVG and CSS that we just learned about in detail.
  prefs: []
  type: TYPE_NORMAL
- en: That said, the most exciting thing about SVG is how easily it works with JavaScript
    to enhance the interactivity of your site. All of these open web technologies
    are designed to work together in ways that create something greater than the sum
    of the individual specifications. Even though there are separate experts working
    on all of these various technologies, they do so out in the open (for the most
    part) and are, generally, part of larger organizations such as Microsoft, Google,
    or Mozilla and therefore have a real desire to make sure that these technologies
    work together in the best possible way.
  prefs: []
  type: TYPE_NORMAL
- en: The intersection of SVG and JavaScript is definitely one such case.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about the low-level interface between JavaScript
    and SVG. This includes the DOM interface to SVG. This is important stuff, even
    though we're also going to learn about libraries and frameworks for working with
    SVG. Even if you've been doing web development for a while and are familiar with
    JavaScript and the DOM, the differences between the regular HTML DOM and the interface
    to SVG elements is important. If you're not so familiar with raw DOM manipulations
    (and many developers who started in the jQuery era and later are not), then this
    chapter will give you a whole set of useful skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic DOM interface to SVG-basic accessing and manipulating SVG elements
    in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SVG-specific DOM interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with SVG and CSS dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript Versions and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the code, I think it's important to go over different JavaScript
    Versions and how they'll be used in the book. I'd also like to go over how I'll
    present examples that require tooling.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may be aware, there's been a lot of work over the past few years around
    evolving the JavaScript programming language. Some of this work is really, really
    great. So great, in fact, that the dominant libraries and frameworks on the web
    right now are idiomatically written in versions and variations of JavaScript that
    aren't universally available in web browsers. Working in bleeding-edge versions
    of the language, including framework-specific extensions, is possible because
    of the use of a transpiler ([https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them](https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them)),
    a piece of software that takes software code written in one language (or in this
    case, a version of a language) and outputs code in another language (in this case
    an older, fully supported version of the language). This transpilation step allows
    us to write our applications in whatever flavor of JavaScript we prefer and then
    convert it into browser-standard JavaScript that can run anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: This section outlines the different Versions of JavaScript you will encounter
    in this book. The next section will talk a little bit about how we'll present
    the tooling required to use a transpiler in order to make your bleeding-edge code
    run in common web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: As a note, this is the broadest possible introduction to this topic. Additional
    details, as they arise, will be covered in the course of the book, but even that
    will only scratch the surface of this far-ranging topic.
  prefs: []
  type: TYPE_NORMAL
- en: While I have called and will continue to call the language JavaScript throughout
    the book, that trademarked name (trademarked by Oracle, which got the trademark
    from Sun Microsystems, who in turn got the trademark from Netscape) is not the
    official name of the language. The language is officially called **ECMAScript**,
    based on Ecma ([https://www.ecma-international.org/](https://www.ecma-international.org/)),
    the organization which hosts the standards body that writes the specification.
  prefs: []
  type: TYPE_NORMAL
- en: ECMAScript 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ECMAScript 5** (**ES5**) is the most fully supported version of the language
    in browsers today and is the version that is targeted by transpilers because it
    will run anywhere. Standardized in 2009, as of the time of writing this version
    has full support in over 90% of browsers out there and has partial support in
    around 97%. With the addition of ES5 polyfills ([https://github.com/es-shims/es5-shim](https://github.com/es-shims/es5-shim))
    you can get near-universal coverage targeting ES5\. Some code, specifically the
    Angular 1 and jQuery sections in [Chapter 7](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml),
    *Common JavaScript Libraries and SVG*, will be written directly as ES5\. This
    is because most people will be familiar with Angular 1 and jQuery as ES5 style
    interfaces. The comment at the top of the file, as follows, indicates this version
    is being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: ECMAScript 2015
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript 2015 was formerly known as **ECMAScript 6** (**ES6**). This version,
    finalized in 2015, is the version making its way into browsers now. It's got partial
    support across all the latest versions of the major browsers (Edge, Firefox, Chrome,
    and Safari.) In general, the JavaScript code written in this book, with the exception
    of the previously mentioned examples, will use ES6\. With the exception of the
    *React* section, which uses more advanced features and some React-specific extensions,
    the features used are all supported in the latest Versions of Chrome, Edge, and
    Firefox. So if you're using one of those browsers, you won't have to actually
    run a transpiler for these samples. If you're looking to move this code into production,
    that's another story, which is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The comment at the top of the file, as follows, indicates this version is being
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Angular ([https://angular.io/](https://angular.io/)) section will be written
    in TypeScript ([https://www.typescriptlang.org/](https://www.typescriptlang.org/)).
    Typescript is a superset of JavaScript that adds certain optional features, most
    notably static typing ([https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html)),
    through the use of type annotations. TypeScript is used by the Angular team to
    add some core features to the development environment for Angular. Because not
    everyone has experience in TypeScript, TypeScript language features in the examples
    will be pointed out, to keep confusion to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: The good news on that front is that once the script is up and running, the body
    of any Angular component can be written as plain old JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we haven't had to do much in terms of tooling. Almost all
    the examples will work when served off the local file system, as written.
  prefs: []
  type: TYPE_NORMAL
- en: That won't necessarily be the case going forward. In the simplest case, any
    examples that require making HTTP requests, for example, will rely on the node
    package serve ([https://www.npmjs.com/package/serve](https://www.npmjs.com/package/serve)) in
    order to set up a simple local server.
  prefs: []
  type: TYPE_NORMAL
- en: The React and Angular examples, in particular, require even more extensive tooling.
    At a minimum you will need to have Node.js ([https://nodejs.org/en/](https://nodejs.org/en/))
    installed and you'll have to follow a few steps to get set up. In the end you'll
    have a local web server running, and several processes which will watch for changes
    to your JavaScript or Typescript files. When you make changes, the related processes
    will catch the changes and perform actions (transpiling the code from Typescript
    to JavaScript, for example) to ensure that the code is updated on the local server.
  prefs: []
  type: TYPE_NORMAL
- en: There'll be instructions for getting up and running with the code samples in
    each of the respective sections.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, remember that all of the working code is available on GitHub ([https://github.com/roblarsen/mastering-svg-code](https://github.com/roblarsen/mastering-svg-code)).
  prefs: []
  type: TYPE_NORMAL
- en: After all of that, let's look at some code that doesn't require anything other
    than a newer web browser to run locally.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM interface to SVG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DOM is an API for accessing, updating, creating, and deleting the elements,
    properties, and content of XML-based documents. This includes documents in related,
    but not strict XML, grammars such as the latest HTML specification.
  prefs: []
  type: TYPE_NORMAL
- en: For the average developer, doing a ton of pure DOM manipulation is pretty rare
    these days. jQuery took care of that many years ago and it's never come back into
    fashion. I can say from experience that it's still useful to know how DOM manipulation
    works under the hood so that you can code yourself out of a bind when you run
    into something the library or framework you're using doesn't provide.
  prefs: []
  type: TYPE_NORMAL
- en: It also illustrates the possibilities of what's available when working with
    different technologies. It's one thing to have access to something that a library
    or framework author finds interesting, but if you're familiar with the underlying
    code, you're only limited by your imagination and what's available in your target
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The SVG DOM builds on the Dom Level 2 Specification ([https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html](https://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html)). It
    supports most of what anyone with DOM and HTML experience would expect and adds
    several sets of SVG-specific interfaces that you can use to manipulate SVG documents.
  prefs: []
  type: TYPE_NORMAL
- en: This section will go through the basic classes of SVG-specific DOM methods and
    illustrate their usage. Unless you're writing a library, you won't need to know
    everything about these lower-level tools. This chapter will serve as an introduction
    so you have a good introduction to them and know what to look for.
  prefs: []
  type: TYPE_NORMAL
- en: Initial exploration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, let's look at some DOM methods and properties that are available
    on an arbitrary (and common) SVG element, `rect`. To do this, you might go to
    the `SVGRectElement` element documentation ([https://developer.mozilla.org/en-US/docs/Web/API/SVGRectElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGRectElement)).
    That would be a good option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also inspect a `rect` element directly, using the developer tools
    of your browser of choice. That will look something like the following screenshot. 
    This will be the way many of you interface with the available methods and properties
    of SVG elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c5d8309-264d-45b1-bcb5-2ed63a3fdbd3.png)'
  prefs: []
  type: TYPE_IMG
- en: While these are common, you could also do something like the following, which
    is a nice step towards scripting SVG.
  prefs: []
  type: TYPE_NORMAL
- en: In this code sample we get access to the `rect` element with `document.getElementById` and
    store it in a variable, `rect`. `document.getElementById` is one of the common
    DOM accessor methods that you'll use to access DOM elements both in SVG and in
    HTML itself. You'll see more examples of its use throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that, we then loop through the properties of the `rect` loop using
    a simple `for...in` loop, writing the variables and properties out to the console
    using bracket notation where `prop` is the name of a property or method on the
    `rect` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output is shown in the following screenshot. You'll notice that the first
    few properties and methods are all SVG-specific. This list continues on for several
    screens past the ones in the following screenshot, but the first ones in the list
    are all SVG specific. This is because the `for...in` loop starts with the innermost
    properties of the `SVGRectElement` and then works its way up the prototype chain
    to the properties of the `SVGGeometryElement`, all the way up to `SVGElement`,
    `Element`, and `Node` (the most generic DOM interface). Of these properties, some
    are very obvious and immediately useful such as `x`, `y`, `width`, and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Others might not be as obviously useful, such as `getBBox` or `isPointInFill`
    (although you might be able to guess what they can do), but you can start to see
    that there''s a lot available for you to work with when you have access to an
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e8c0200-55c1-4a7d-bc41-ed89c3724924.png)'
  prefs: []
  type: TYPE_IMG
- en: Taking that basic foundation and the idea of exploration, let's start to build
    a small application that lets you manipulate an SVG canvas in simple ways.  The
    next section will focus on building out a small tool, step-by-step, that will
    allow you to add simple SVG elements to an SVG canvas (`text`, `rect`, and `circle`)
    and manipulate them in different ways. This small demo will be easy to digest
    and will demonstrate a number of different ways to interact with SVG.
  prefs: []
  type: TYPE_NORMAL
- en: The SVG DOM manipulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The app we're going to build will allow you to click and add three different
    kinds of SVG element to an SVG canvas. The interface will allow you to click on
    the item you want to add (`rect`, `circle`, or `text`) and then you will be able
    to click on the canvas and add that element to the screen at those particular
    `(x,y)` coordinates. With that element selected, you will then be able to edit
    it by changing several available properties.
  prefs: []
  type: TYPE_NORMAL
- en: This example will use Bootstrap to simplify laying out the different form fields
    and to create a simple modal to edit the properties. Because of that, jQuery will
    also be included, although, for this version of the demo at least, jQuery interactions
    will be kept to a minimum; we'll focus on raw DOM manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it''s complete, it will look as shown in the following screenshot, which
    shows the SVG canvas at the top of the screen, bordered in black. After that there
    are simple instructions and then at the bottom of the screen there are three buttons
    that allow you to select a rectangle, a circle, or a text element to add to the
    canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3719fc64-62cd-404d-9134-3b06ef2966b6.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, instead of adding the entire code sample at once and explaining the
    whole thing, as we've been doing so far in the book, we are going to build the
    sample and discuss each code block as we go through the example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the skeleton of the page. This initial state doesn't have any
    JavaScript in it at all, but it does provide us with some structure and some tools
    we'll use later.
  prefs: []
  type: TYPE_NORMAL
- en: In the `head` we link to Bootstrap from a **Content Delivery Network** (**CDN**),
    we link to the Raleway font from Google fonts and then set up some basic styles
    for our page, adding Raleway as the body font, putting a border around our canvas
    SVG element, and then changing the color of our SVG sprite buttons.
  prefs: []
  type: TYPE_NORMAL
- en: In the body, we set the page up to be responsive, using Bootstrap's utility
    classes to create a fluid layout that fills the entire screen width. The SVG element
    will scale to fit this Bootstrap container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The layout has two sections: the target SVG element, where the drawings will
    happen, and a second section for the UI controls. The UI controls, for now, are
    just three `button` elements wrapped around SVG sprites.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a hidden SVG element featuring a series of `symbol` elements,
    defining our sprites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we link out to some third party JavaScript in order to wire up some
    of the Bootstrap functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've taken a look at the basics of the page, let's start to add some
    interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have jQuery on the page, I'm not going to use it for any of the
    DOM manipulations so that we can look at the raw interactions. We will look at
    jQuery and SVG in [Chapter 7](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml), *Common
    JavaScript Libraries and SVG*, so don't fret.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll do is create a few event handlers to handle the different
    interactions. The first event handlers we'll add are `click` event handlers on
    the buttons. The idea is that you click on the button to load an SVG element onto
    your cursor, and then you click once more to place it on the canvas. This code
    doesn't yet handle adding the element to the SVG canvas, but it does illustrate
    a couple of wrinkles when working with SVG and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: This is an instance where some things you might know from old-school DOM manipulation
    might fail you. If you've been manipulating the HTML DOM directly for any length
    of time, you might be used to working with the `Element.className` property. On
    HTML elements, the `className` property is a `read/write` string that maps to
    the `class` attribute on the HTML element. In that context, you can manipulate
    the string and changes are reflected in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM interface `SVGElement` does have a `className` property, but it isn't
    a simple string. Its an `SVGAnimatedString` property with two string values, `AnimVal`
    and `BaseVal`. Because of that extra layer, and because the interface for my chosen
    alternative is modern and much clearer, I decided to use the `SVGElement.classList`
    property to manipulate the CSS classes instead. `classList` is a structured interface
    to the CSS classes on an element. Accessed directly, `classList` is `readonly`,
    but there are methods available to query and manipulate the list of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dive into this code to see how that works.
  prefs: []
  type: TYPE_NORMAL
- en: We start the whole thing by adding a function that fires on the `DOMContentLoaded`
    event. This event fires a function when the DOM has been read by the browser.
    This is the safest place to start to manipulate the DOM if you're looking to use
    an element on the page when the markup is read by the browser. Then we set two
    local references, one to `document` via the variable `doc` and the other to the
    SVG canvas itself, via the `canvas` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We create local references to DOM properties and elements because DOM lookups
    can be slow. Saving a local reference to DOM properties and elements is a common
    performance pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Then we get the collection of buttons, using `querySelectorAll`, and loop through
    each of them in turn, adding a click event handler to each button. Inside the
    body of the click event handlers, we initially set two local references, `classlist` as
    a reference to the target SVG element's `classList`, and a `const`, referencing
    the `type` of element that has been requested. This type is being passed in via
    a `data-*` attribute on the `use` element. `data-*` is a method for storing arbitrary
    data on a DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use that type and a simple `if...else` statement to ensure that the
    proper classes are on the target SVG element. In the first `if` block, we test
    to see if the current classes match the current type and that it has the `active`
    class. If they match the current type and the element has the active class, we
    remove the classes. This action is for cases where we''ve already loaded the cursor
    with a specific type and want to reset it by clicking on the same button. The
    next block checks to see if the cursor is active but isn''t the currently selected
    type. In that case, we remove all of the type classes to ensure we clear the selected
    type, and then add the currently selected one back in. In the final block, the
    cursor isn''t active, so we just add the `active` class and the type class, loading
    up the cursor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS for the active cursors is as follows. In the new CSS we simply pass
    a URL reference to a PNG to the cursor property for each of the active cursors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A cursor loaded with a circle element looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c46bf8db-e534-4b6b-be7d-fbef9eb946cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Next up we'll go through the process of adding elements on click to the target
    SVG element.  The function `add` is where the magic happens. In it we first set
    a number of variables. We start with five consts. The first is a reference to
    the `document`, stored as `doc`, the second is a reference to the target SVG element,
    stored as `canvas`, the third is the target SVG's `classList`, stored as `classes`,
    then there's a reference to the SVG namespace URL, stored as **namespace** (**NS**),
    and finally there's an `SVGpoint`, created and stored as `point`. The first three
    should be straightforward; the usage of the `NS` variable will be explained shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '`point` is used immediately. This is one major difference between regular DOM
    manipulation and working with the SVG DOM, so let''s take a look at what''s going
    on there. The basic purpose of this code is to transform the screen coordinates
    from the click event to the proper (potentially transformed or scaled) coordinates
    inside the SVG element. If you''ve been paying attention to the way that SVG scales,
    in general, and the way that transforms work with SVG elements, you should be
    able to see how, depending on the way the document is set up, the screen pixels
    may or may not match up to the user units within the  SVG document. Since we''ve
    got a static `viewbox` set to 500 user units and an SVG element that scales to
    fit the entire page, we are going to need to use some SVG tools to access the
    current transformation matrix and apply that matrix to the point of the click.'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we have a couple of steps that we need to go through. `point` is
    created via `createSVGPoint`, which is a method that returns a point in the current
    SVG coordinate system. The initial return value has two properties, `x` and `y`,
    set to zero. We immediately populate that variable with the mouse coordinates
    of the click event. These are available as part of the event object that's automatically
    passed in as an argument to the function as `event.offsetX` and  `event.offsetY`. Next
    we use the `getScreenCTM()` method to get the inverse of the **Current user unit
    Transformation Matrix** (**CTM**). The CTM represents the transformation steps
    required to convert from the screen coordinate system to the one in the SVG document.
    Calling the `inverse()` method returns the steps required to move from the SVG
    user unit coordinate system to the one on the screen. Applying that matrix to
    the `(x,y)` points defined in point, therefore, shifts the points to the correct
    place in the SVG document.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we create an empty variable, `elem`, which is going to be filled later
    with the element we're looking to add to the document.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we actually create the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the class active is on the target SVG element, then we''re going to add
    an element to it. No matter which type of element we''re trying to create, the
    pattern is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: We test which type of element is active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set a couple of properties on it before adding it to the DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, if you're familiar with DOM manipulations, then you'll notice some differences
    here. This is where the `NS` variable comes into play. Since this isn't pure HTML
    and is, in fact, an entirely different document definition, we need to supply
    that namespace in order to create the element properly. So, instead of `document.createElement`,
    we have to use `document.createElementNS` and we pass in a second argument referencing
    the SVG namespace via the `NS` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once the element is created, we set the relevant attributes using `elem.setAttribute`.
    For the `rect` we set `x`, `y`, `width`, and `height`. For the `circle` we set
    `r`, `cx`, and `cy`. For the `text` element we set `x`, `y` and then set the text
    content using `elem.textContent`, which is a new wrinkle if you're used to updating
    text and/or HTML nodes with `innerHTML`. As mentioned previously, there is no
    `innerHTML` of an SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `elem` is defined with the baseline attributes, we insert it into
    the document using the `appendChild` method. Finally, we remove the `"active"`
    class from the target SVG element, which will prevent further elements being added
    accidentally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a newly added square element on the SVG canvas as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2089ef8b-202f-45e8-8501-c7e7e74fdf34.png)'
  prefs: []
  type: TYPE_IMG
- en: While we now have events bound to the document and can add elements to the screen,
    this demo isn't done just yet. What we need to do to finish this off is to allow
    the user to update the elements that have been placed on the target SVG element.
    While we could do that in increasingly complicated ways (clicking and dragging,
    drawing new elements with the mouse or with your finger, copying and pasting elements)
    for the sake of this demo, we're simply going to allow the user to click on the
    SVG element and open up a small Bootstrap modal which will allow them to edit
    basic SVG properties. This will illustrate manipulating the underlying DOM properties
    without getting into too much depth on any one set of interactions. This is especially
    key since many of the most complicated interactions are better handled by a separate
    library or framework anyway. As you'll see, doing this stuff entirely by hand
    can be cumbersome even in the best of circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s get that started. The first thing we''ll do is update the `add` function
    with one line. This line adds the click event handler to `elem`, which will fire
    the `edit` function. So, looking at the bottom of the `add` function, we can see
    the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Before we look at the edit function, let's look at the modal markup. If you've
    worked with Bootstrap before, this should be familiar. If not, the basics are
    pretty straightforward. The pattern of the Bootstrap `modal` wrapper class and `modal-` classes
    adds the Bootstrap modal layout, and the classes also indicate that the Bootstrap
    JavaScript should bind Bootstrap-specific events to this particular element. We'll
    see one of these events in action shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the modals has an `id` to reference from our functions as well as specific
    form fields required to update the selected elements.
  prefs: []
  type: TYPE_NORMAL
- en: The first modal is used to edit the `rect` elements. It has an `input` of type
    `color` to allow the user to choose a new color for the background, two `inputs` of
    type `number` to update the `x` and `y` coordinates, and two `number` `inputs`
    to update the `height` and `width` of the element.
  prefs: []
  type: TYPE_NORMAL
- en: Inputs of type `number` and type `color` are newer, HTML5 input types.
  prefs: []
  type: TYPE_NORMAL
- en: The second modal is used to edit the `circle` elements. It provides a `color`
    `input` to change the background color, two `number` `inputs` to change the `cx`
    and `cy` attributes, and a final `number` `input` to change the radius of the
    circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final modal is used to edit the `text` elements. It provides a `color`
    `input` to change the color of the text, two `number` `inputs` to change the `x`
    and `y` positions of the element, and a `text` `input` to change the actual text
    of the `text` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now let's take a look at the `edit` function. Most of the interesting stuff
    here happens based on the `event argument`. `event` has references to all sorts
    of information about the event being fired. `edit` checks the `event.srcElement.nodeName`
    to see what kind of element has been clicked. The function then does three things
    for each of the element types.
  prefs: []
  type: TYPE_NORMAL
- en: It opens the correct editing modal using the `$().modal` method called with
    the `"show"` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It stores a reference to the current element using the jQuery `$().data()` method.
    `$().data` allows you to bind arbitrary data to an element. We'll look at more
    jQuery features in [Chapter 7](7b74eac8-2ea5-4931-b5fc-45a16c3ad0a0.xhtml), *Common
    JavaScript Libraries and SVG*, but since we are already using jQuery to get to
    the Bootstrap methods, let's use `$().data()` here for the sake of convenience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It loads up the current values from the clicked element and loads them into
    the form fields. There are multiple instances of this, but for the most part they
    follow the same pattern. The `form` field is referenced via `id` and the value
    is set using the current value accessed by `event.srcElement.getAttribute`. The
    one exception is the text value of the text element that is accessed by the `event.srcElement.textContent`
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, as soon as the element is clicked, the modal is opened and populated with
    the current values ready to be manipulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what an opened modal looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a256e53c-283b-4153-8488-27544cfe6e6b.png)'
  prefs: []
  type: TYPE_IMG
- en: To capture the changes, we need to add some more event handlers to the document
    and a few more functions to save the data. This is done by adding some click handlers
    to the three modals save buttons and defining three different functions to handle
    the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the next sample, the event handlers are straightforward.
    You get a reference to each of the save buttons with `document.getElementById`,
    and using `addEventListener` add the correct save handler to each of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The various save functions are also pretty straightforward. They all initially
    hide the opened modal using the `$.modal()` method with the `hide` argument passed
    in. After that the function stores a reference to the currently clicked element
    using the get signature of the `$().data()` method and stores it as a local variable
    `elem`. Then, depending on the type, the function accesses values from the form
    and sets the new values on the selected element. `rectSave` accesses the `fill`, `x`, `y`, `height`,
    and `width` attributes. `circleSave` accesses the `fill`, `cx`, `cy`, and `r` attributes.
    `text``Save` accesses the `fill`, `x`, `y`, and `text` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the edit function against a `text` element looks as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c013c260-996f-449f-8e11-e6e48bfa6965.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Applying those values produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86da3adf-b9df-4341-8580-65c8d1f2c132.png)'
  prefs: []
  type: TYPE_IMG
- en: While there are many, many more features we could add to this small SVG editing
    demo, this example is both simple enough to understand in a single chapter and
    also allows us to illustrate the basic patterns used to add, access, and update
    SVG elements on screen. If you've had some experience with raw DOM manipulations
    in the past, this should all be familiar to you. If you haven't, it's a useful
    set of skills to have, and the basic pattern you've seen here is the way that
    this all works in both the SVG and HTML realms. Once you have access to an element,
    you can then access and update its properties and call various methods on it to
    adjust it on the screen. With this foundation, you'll be able to solve problems
    that might not be easily solved by a library or framework in both SVG and HTML
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you created a small application that allows you to add and
    edit SVG elements on a target SVG canvas. Working your way through this application,
    you learned about a wide variety of DOM features and functionality, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Two different ways to access DOM elements, using `document.getElementById` and
    `document.querySelectorAll`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to insert SVG elements using `document.createElementNS` and `appendChild`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to bind events to HTML and SVG elements using `addEventListener`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get, set, and remove CSS classes from an SVG element using the `classList`
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manipulate common SVG properties using `getAttribute` and `setAttribute`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to convert between the browser coordinate system and the SVG element coordinate
    system by using the `getScreenCTM` method to get the inverse of the *C*urrent
    user unit *T*ransformation *M*atrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set the text content of an SVG text element using  `textContent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together with the lessons you've already learned in this book, the lessons you
    learned in this chapter will mean you are ready to work with SVG at a very high
    level across a large variety of tasks. If you're comfortable with the raw DOM
    interface, the patterns of creating, accessing, and manipulating DOM elements
    are all you need to build the most complicated web apps and visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Taking that foundation, we're going to now apply everything we've learned so
    far to other libraries and frameworks so that you can take advantage of the power
    and convenience that libraries such as jQuery, React, and D3, and frameworks such
    as Angular, provide on top of the raw DOM interface.
  prefs: []
  type: TYPE_NORMAL
