- en: The Software Development Life Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All software development, Python or otherwise, above a certain level of complexity
    follows repeatable patterns, or has a life cycle. A **Software** (or **System**)
    **Development Life-Cycle** (**SDLC**) might be used as its own distinct development
    methodology, providing a set of tasks and activities that apply to the development
    process. That is, even if there is no formal process wrapped around an SDLC, any
    or all of the activities that go on through one may still take place, and any
    or all of the artifacts that come out of them may be available during the development
    of a project.
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of the actual development, not all of the artifacts resulting
    from an SDLC, formal or otherwise, may be significantly useful, either, particularly
    those coming out of the first few phases of the life cycle's process. Even so,
    the more knowledge that is available during the development process, the less
    likely it is that development efforts will go in directions that run contrary
    to the intentions of the system on a longer-term basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fully explore what an SDLC might provide, we''ll use one of the
    more detailed ones that can be found on the internet. It breaks the life cycle
    down into ten phases, which would be executed in the following order, barring
    process alterations from a development methodology:'
  prefs: []
  type: TYPE_NORMAL
- en: Initial concept/vision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concept development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project management planning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements analysis and definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System architecture and design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development (writing code) and quality assurance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System integration, testing, and acceptance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation/installation/distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations/use and maintenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decommissioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these individual phases can be merged together, or might be broken out
    into smaller sub-phases, but this breakdown—these ten phases—is a useful grouping
    of similar activities with similar scopes.
  prefs: []
  type: TYPE_NORMAL
- en: The first three phases may all occur before any code is written, defining the
    high-level concepts and goals, and planning for how to accomplish those goals.
    The last three generally happen after code is complete, though as new features
    are thought of, or as bugs surface, code development may restart to address those
    items. The balance, phases 4 through 7, are loosely classifiable as **d****uring
    development**, though, except for the actual writing of code in phase 6, that
    classification may depend on what development processes or methodologies are in
    play, something that is likely decided during phase 3 if it isn't already determined
    by external policies or forces.
  prefs: []
  type: TYPE_NORMAL
- en: Different software development methodologies (Agile ones in particular) may
    well address these in more of an on-demand manner, grouping phase activities iteration
    by iteration, story by story, or out of the sequence they are listed in here.
    A deeper exploration of these variations can be found in [Chapter 4](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=28&action=edit), *Methodologies,
    Paradigms, and Practices.*
  prefs: []
  type: TYPE_NORMAL
- en: Pre-development phases of the SDLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the first line of code is written, there is the potential for a fair
    amount of thought and work going into a project. Not all of the work is going
    to be visible by the time development starts, and, realistically, not all of what
    could be produced pre-development will be, in many cases. Even those artifacts
    that are created may not have any formal structure or documentation around them,
    or may not be as complete or detailed as might be desired. Despite all of that,
    knowing what might be available that is of use or interest during development
    can at least help answer questions that can arise during the actual writing-of-code
    portion of a system/project.
  prefs: []
  type: TYPE_NORMAL
- en: Initial concept/vision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very first thing that happens in a project's or system's life is its conception.
    Behind the scenes, that usually involves the recognition of some unfulfilled need,
    or something that isn't working the way it should, though other variations might
    occur as well. As part of that realization, there will frequently be a collection
    of capabilities that the conceived system will provide, benefits or functionality
    that will drive the system's development, and determine when that development
    is complete. At this initial, very high-level overview, there may not be much
    in the way of detail—we need a better way to manage inventory, maybe for the entire
    vision, for example—but it's possible that more detail will enter the picture,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept and the benefits might come from anyone with a stake in the system:
    business staff who are looking for a better way of doing things, developers who
    perhaps recognize that an existing system isn''t as effective as it could be,
    or maybe that it''s difficult to maintain. System administrators might have concerns
    about how easily managed an in-place system is and want a newer, better approach
    taken, or the initial vision might be for something completely new, at least in
    the context of the business setting—we need a way to keep track of fuel efficiency
    across our delivery truck fleet, maybe. What about if our customers could order
    our products online?'
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, if off-the-shelf solutions or products are available that meet parts
    of these needs, those options will have been investigated in some detail—maybe
    even to the point where the vision owner would be able to point to some feature
    set(s) of those products and say, "We want something like this." Having examples
    of functionality that's close to what's actually wanted can be a significant time-saver
    during pre-development design and development alike, and it's almost always worth
    asking if there are examples of what's wanted as the design and development processes
    move along. If that sort of investigation was undertaken and no options were found
    that were even close, that, too, has useful information embedded in it—what was
    missing? What did product X do that wasn't meeting the needs in the concept? If
    no investigation was undertaken, or if nothing came out of an investigation, it's
    quite possible that the initial concept would be no more than a sentence or two.
    That's alright, though, since more detail will be extracted later on as the concept
    development gets underway.
  prefs: []
  type: TYPE_NORMAL
- en: The "no investigation was undertaken" scenario, in the author's experience,
    happens more frequently than might be expected, particularly in businesses that
    are heavily invested in the development of their own products, or where there
    is a desire to own all the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In more formal processes, other analyses may also take place, looking for things
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specific user needs**: What users must be able to do within the system, and
    probably what they should be able to do. There may also be a collection of nice-to-have
    features—things that users would like to be able to do, but that are not a functional
    necessity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Specific functional needs**: What problems the system needs to solve, or
    at least mitigate in a significant fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risks**: Usually business-process-related risks, but those may also serve
    to guide design and development in later phases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Costs**: Both in money and resources. Odds are that this information won''t
    yield much use from a development process perspective, but it''s not impossible
    for an occasional significant nugget of information to come out of this either.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operational feasibility**: Examining how well the conceptual system addresses
    the needs it''s been thought up to address. Like with cost analysis, the odds
    are good that there won''t be much that comes out of this that''s directly useful
    for development purposes, but it might identify operational or design areas where
    there is doubt about feasibility, and those doubts, in turn, may well shape design
    and/or implementation by the time the system is in development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At best, then, given either a formal process, or sufficient attention to detail
    in an informal one, the initial concept might produce information or documentation
    about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Benefits or functionality expected from the system (usually at a high level,
    at least to start with):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of specific, high-level functional needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of specific user needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific features or functionality that were not provided by an off-the-shelf
    system (thus justifying custom development effort)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific risks to mitigate against
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific functional or feasibility concerns to address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these have at least some value once development is underway and will
    hopefully make their way into design or requirements, and from there into development.
  prefs: []
  type: TYPE_NORMAL
- en: Concept development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concept development is concerned mostly with fleshing out some of the high-level
    details that come out of the initial concept, providing details and direction
    for efforts later in the life cycle. One of the more significant aspects of this
    step is the generation of various System Modeling artifacts—and there's enough
    involved in those efforts that they'll be covered in a separate chapter. The balance
    of the development-related information that comes out of this phase is probably
    focused more on marrying business processes and system functionality, and providing
    some detail around system goals. There is also room here for a definition of at
    least a basic user experience and/or user interface, especially as they connect
    to the process/functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the business processes embedded in a system includes identifying the
    business objects that the system keeps track of, the actions that can be taken
    with respect to those objects, and the outcomes of those actions, at a minimum.
    Applying of the sort of questioning described earlier in [Chapter 1](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=25&action=edit),
    *Programming versus Software Engineering,* can yield a fair bit of that information,
    if more detail is needed.
  prefs: []
  type: TYPE_NORMAL
- en: This same system concept will be revisited in [Chapter 3](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=27&action=edit),
    *System Modeling*, to illustrate how fleshing out the high-level technical design
    aspects of a system might progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of example, consider a system whose concept begins with the knowledge
    that they need a way to keep track of fuel efficiency across their delivery truck
    fleet. Working out the business objects and activities from there could answer
    some very basic questions, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the system keeping track of?**: The individual trucks in the fleet,
    the mileage on the odometers of those trucks at irregular intervals, and the refueling
    of those trucks, at a minimum.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What does a refueling look like?**: A fuel quantity and the odometer reading
    at the time of refueling, to start with. Those two data points would allow for
    the calculation of fuel efficiency, which is calculated in whatever units each
    uses (gallons or liters for fuel, miles or kilometers for the odometer). Fuel
    efficiency becomes a calculation of any given refueling for any given truck, and
    the current odometer reading for any given truck can be retrieved from the odometer
    reading at its last refueling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How many refuelings should be kept for any given truck?**: If one of the
    goals of the system is to detect when a truck''s fuel efficiency has dropped,
    in order to flag it for maintenance, perhaps, or to trigger a review of the delivery
    scheduling associated with it, then there is an obvious need to keep track of
    more than one such refueling—maybe all of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Who will be using the system, how, and where?**: There would need to be at
    least two types of physical access point: one from mobile devices (when fueling
    a truck), and one from in-office computers (for reporting purposes, if nothing
    else). That set of use cases tells us that we''re looking at either a web application,
    or some sort of dedicated phone and computer application set, with access to some
    common data stores, possibly through a service layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There may be other questions that could be asked, but these four alone probably
    give enough information to make the most of major concept design decisions, though
    the latter may require a bit more exploration before they can be finalized. Similar
    questioning, asking things such as What can (a specific type of user) do with
    the system until there aren''t any more users and activities, can also yield more
    specific system goals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Various users can log refuelings, providing the current odometer reading, and
    the quantity of fuel involved:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivery drivers (at local fuel stations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fleet maintenance staff (at the main office, where there is a company fuel station)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fleet maintenance staff will be alerted when a truck's calculated fuel efficiency
    drops to lower than 90% of its average, so that the truck can be scheduled for
    an examination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Office staff will also be alerted when a truck's calculated fuel efficiency
    drops to lower than 90% of its average, so that the truck's delivery rounds can
    be examined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The question of how and where users will interact with the system may well
    spark some discussion and design decisions around user experience and interface
    design as well. In this case, perhaps after discussion about whether the system
    is a web application or dedicated phone and desktop application, the decision
    is made to make it a web application and to use the **Clarity Design System**
    for the UI, because the primary stakeholder in the system''s vision likes the
    way it handles on-screen cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8816e272-9acf-4a26-beb4-4b90b1e9267f.png)'
  prefs: []
  type: TYPE_IMG
- en: Project management planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This phase of the life cycle is where all of the conceptual items come together,
    hopefully in a form or fashion that''s ready for  the actual creation of code
    to start. If there is a formal PMP document as a result, its outline might look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Business purpose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objectives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Goals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's included
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's excluded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key assumptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project organization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles and responsibilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stakeholders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risks, issues, and dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preliminary schedule of deliverables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk and issue management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Developers won''t need all of these items, but knowing where to look for various
    bits and pieces of the information they will need (or, in some cases, who to contact
    for information) is advantageous, so:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Business purpose**, **Objectives**, and **Goals** sections should, ideally,
    collect all of the original vision information (from the initial concept/vision
    phase) with whatever details have been added or changes made after the concept design
    was complete. These will, in all probability, include the starting points for
    the **Requirements analysis and definition** efforts that go on during the development-specific
    phases of the life cycle. In addition, the **What's included**, **What's excluded**, and
    **Key assumptions** sections, between them, should expose what the actual scope
    of development looks like, as well as providing high-level design decisions and
    any relevant high-level system modeling information. **Risks, issues,** and **dependencies**
    may provide specific items of concern or other interests that will help shape
    the development efforts. Finally, **Change management** will set expectations
    (at a high level, at least) for what processes are expected or planned for as
    changes to the system are made.
  prefs: []
  type: TYPE_NORMAL
- en: People in a position to answer questions or make decisions about the system's
    implementation that fall outside the scope of pure development will probably be
    listed in the **Roles and responsibilities** and/or **Stakeholders** sections,
    though there may be specific established processes for raising those questions
    in the **Communication** section.
  prefs: []
  type: TYPE_NORMAL
- en: Even without formal documentation around project management expectations, much
    of the information noted previously should still be made known to development
    staff—the less time spent having to track down who can answer a question, the
    more time can be devoted to actually writing code, after all.
  prefs: []
  type: TYPE_NORMAL
- en: Development – specific phases of the SDLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the advent of Agile methodologies, and the widespread adoption of many
    of them, the specific shapes of the development-specific phases of an SDLC can
    vary substantially. Different methodologies make different decisions about what
    to prioritize or emphasize, and those differences can, in turn, yield significantly
    different processes and artifacts to accomplish the goals of formal SDLC phases
    that focus directly on developer needs and activities. Whole books have been written
    about several of the Agile processes, so a complete discussion of them is well
    beyond the scope of this book, but all of them address the following activities.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements analysis and definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Requirements analysis and definition are concerned with discovering and detailing
    the specific requirements of a system—what the system needs to allow users to
    do with it. Users obviously includes end users, ranging from office workers using
    the system to conduct day-to-day business, to external end users such as customers.
    Less obviously, users should also include system administrators, staff who receive
    data from the system through some reporting processes, and perhaps any number
    of other people who interact with the system in any fashion, or who are acted
    upon by it—including the developers themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements are, first and foremost, about those interactions, and developers
    have to know what is expected of the system in order to write code to provide
    those capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: System architecture and design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If requirements analysis and definition are about what a system provides, system
    architecture and design are primarily about how those capabilities work. The differences
    in how various development methodologies deal with architecture and design is
    less about that how and more about when they are defined. Essentially, given a
    set of requirements (the intentions behind the system, or the why), the implementation
    details (the how) will almost certainly be determined more by those requirements
    and the specifics of how best to implement them in the programming language than
    by when they are identified, consolidated, or formalized.
  prefs: []
  type: TYPE_NORMAL
- en: Developers need to know how best to implement the required functionality, and
    that is what this phase is concerned with.
  prefs: []
  type: TYPE_NORMAL
- en: Development and quality assurance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The development part of this phase probably requires the least explanation:
    it''s when the actual code gets written, using the defined requirements to determine
    what the goals of the code are, and the architecture/design to determine how to
    write the code. An argument could probably be made that the quality assurance
    part of this phase should be broken out into its own grouping, if only because
    many of the activities involved are substantially different—there''s less code
    authoring going on, if there is any at all, in executing a manual test plan, after
    all. That said, the concept of automated testing, which may be able to replace
    a lot of the old-style manual test plan execution activities, does require a substantial
    amount of code, at least at first. Once those test suites are established, regression
    testing becomes much simpler and less time-consuming. Development methodologies''
    concerns with the QA aspects of this phase are usually centered around when QA
    activities take place, while the actual expectations of those activities are usually
    a combination of development standards and best practices.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers need to know what quality assurance efforts are expected of them,
    and plan (and perhaps write code) accordingly during development.Automated testing
    is also a critical foundation for increasingly popular Continuous Integration
    (CI) and Continuous Delivery/Deployment (CD) practices.
  prefs: []
  type: TYPE_NORMAL
- en: System integration, testing, and acceptance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a system is above a certain size or degree of complexity, it's just a matter
    of time before new code coming out of development efforts will have to be incorporated
    into the larger system environment. Attention may also need to be paid to interactions
    with other systems, and any of the implications that are raised in those scenarios.
    In smaller, less complex systems, this integration may be achievable during development.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, the integration of new (or modified) functionality needs to
    be tested to assure that it hasn't broken anything, both in the local system and
    in any other systems that interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Developers need to know how and where their code fits into the larger system,
    and thus how to integrate it. As with the Quality Assurance portion of the previous
    phase, developers also need to know what testing efforts are expected of them,
    for much the same reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Post-development phases of the SDLC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The portions of the SDLC that happen after the core code of a system is written
    can still have significant impacts on the development cycle. Historically, they
    might not involve a lot of real development effort—some code may be written as
    a one-off for various specific purposes such as packaging the system's code, or
    facilitating its installation on a target environment, for example. If the structure
    of the system's code base or, rarely, the language that the system is written
    in doesn't somehow prevent it, most of any code that was written in support of
    post-development activities would probably be created very early on in the development
    process in order to meet some other need.
  prefs: []
  type: TYPE_NORMAL
- en: As a case in point, packaging the code-base, and/or the creation of some installation
    mechanism is pretty likely to be undertaken the first time the code-base needs
    to be installed on an environment for user acceptance testing. If that expectation
    is known ahead of time—and it should be, at some level—then efforts to write the
    packaging process in order to write the installer may well start before any real
    code is created. After that point, further efforts will usually happen infrequently,
    as new components need to be added to a package structure, or changes to an installation
    process need to be undertaken. Changes at that level will often be minor, and
    typically needed with less and less frequency as the process matures and the code
    base installation. This sort of process evolution is at least a starting point
    for DevOps and some Continuous Delivery practices.
  prefs: []
  type: TYPE_NORMAL
- en: Developers will need to know how the system is supposed to be distributed and
    installed so that they can plan around those needs, writing code to facilitate
    them as required.
  prefs: []
  type: TYPE_NORMAL
- en: The last two phases of the SDLC, concerned with the day-to-day use of the system
    and with its eventual retirement, will have less relevance to the core development
    process in general. The most likely exception to that would be re-entry into the
    development cycle phases in order to handle bugs or add new features or functionality
    (the *Use and Maintenance* part of the *Operations/Use and Maintenance* phase).
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of system administrators, the staff responsible for the
    execution of activities in those phases, developers are contributors to the knowledge
    and processes they need in much the same way that all of the pre-development contributors
    to the system's development were with respect to developer knowledge and processes.
    System administration and maintenance staff will be looking for and using various
    artifacts that come out of the development process in order to be able to execute
    their day-to-day efforts with respect to the system. The odds are good that those
    artifacts will mostly be knowledge, in the form of documentation, and perhaps
    the occasional system administration tool.
  prefs: []
  type: TYPE_NORMAL
- en: Developers will need to know what kind of information is needed for post-development
    activities in order to be able to provide the relevant documentation or to write
    code to facilitate common or expected tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with respect to the process of decommissioning a system, taking it
    offline, presumably never to be used again: someone, probably at a business decision
    level, will have to provide direction, or even formal business policies and procedures
    around what needs to happen. At a minimum, those will likely include the following'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements for preserving and archiving system data (or how it should be disposed
    of, if it's sensitive data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements for notifying users of the system's decommissioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may well be more, even a lot more—it's very dependent on the system itself,
    both structurally and functionally, as well as any business policies that might
    apply.
  prefs: []
  type: TYPE_NORMAL
- en: Developers will need to know what should happen when the system is finally shut
    down for good so that they can plan and document accordingly.Knowing how things
    will be handled during a complete and permanent shutdown may give significant
    insight into how system processes and data can or should be handled when normal
    data deletion is executed during normal system operation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if there is no formal SDLC in place, a lot of the information that would
    come out of one is still advantageous for developers to have access to. If enough
    of it is available, and if it's sufficiently detailed, readily accessible, and,
    above all, accurate, it can certainly help make the difference between a project
    just being programmed and being well-engineered software.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant contributor to making that difference is the availability
    of similar information about the system itself, in any or all of several *System
    Model* artifacts. Those provide more implementation-oriented details that should
    be at least as useful as the policy and procedure-level information from the various
    SDLC artifacts. We’ll take a look at those next.
  prefs: []
  type: TYPE_NORMAL
