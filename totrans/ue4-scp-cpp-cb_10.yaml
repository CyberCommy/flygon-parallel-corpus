- en: Chapter 10. AI for Controlling NPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The role of **Artificial Intelligence** (**AI**) in your game is quite important.
    In this chapter, we''ll cover the following recipes for controlling your **NPC**
    characters with a bit of AI:'
  prefs: []
  type: TYPE_NORMAL
- en: Laying down a Navigation Mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting a Behavior Tree to a Character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing Task nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Decorators for conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using periodic services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Composite nodes – Selectors, Sequences, and Simple Parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AI for a Melee Attacker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AI includes many aspects of a game's NPC as well as player behavior. The general
    topic of AI includes pathfinding and NPC behavior. Generally, we term the selection
    of what the NPC does for a period of time within the game as behavior.
  prefs: []
  type: TYPE_NORMAL
- en: AI in UE4 is well supported. A number of constructs exist to allow basic AI
    programming from within the editor. If the AI provided inside the engine doesn't
    suit your needs, custom AI programming from C++ can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: Laying down a Navigation Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Navigation Mesh (also known as a **Nav Mesh**) is basically a definition of
    areas that an AI-controlled unit considers passable (that is, areas which the
    "AI-controlled" unit is allowed to move into or across). A Nav Mesh does not include
    geometry that would block the player if the player tried to move through it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructing a Nav Mesh based on your scene's geometry is fairly easy in UE4\.
    Start with a project that has some obstacles around it, or one that uses a terrain.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To construct your Nav Mesh, simply perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Modes** | **Volumes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Nav Mesh Bounds Volume** onto your viewport.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Press the *P* key to view your Nav Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Scale the Nav Mesh out to cover the area that the actors that use the Nav Mesh
    should be allowed to navigate and pathfind in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Nav Mesh doesn't block the player pawn (or other entities) from stepping on
    certain geometry, but it serves to guide AI-controlled entities regarding where
    they can and cannot go.
  prefs: []
  type: TYPE_NORMAL
- en: Following behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic AI-controlled follow behavior is available as a simple function
    node. All you have to do is perform the steps that follow to get one AI-controlled
    unit to follow a unit or object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a UE4 project ready with a simple landscape or set of geometry on the ground—
    ideally, with a *cul-de-sac* somewhere in the geometry for testing out AI movement
    functions. Create a Nav Mesh over this geometry so that the `AIMoveTo` function
    will work as described in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Nav Mesh for your level's geometry as described in the preceding recipe,
    *Laying down a Navigation Mesh*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Blueprint class deriving from `Character` by finding the `Character`
    class in the **Class Viewer**, right-clicking on it, and selecting **Create Blueprint
    Class…**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your Blueprint class `BP_Follower`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the `BP_Follower` class to edit its Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Tick` event, add an `AIMoveTo` node, which moves towards the player
    pawn (or any other unit) as follows:![How to do it…](img/00244.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AIMoveTo` node will automatically use a Nav Mesh if one is available. If
    a Nav Mesh is not available, then the NPC unit won't move.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you do not want the unit to move with pathfinding using the Nav Mesh, then
    simply use a **Move To Location or Actor** node.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/00245.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A **Move To Location or Actor** node works even without a Nav Mesh on the geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a Behavior Tree to a Character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `BehaviorTree` chooses a behavior to be exhibited by an AI-controlled unit
    at any given moment in time. Behavior Trees are relatively simple to construct,
    but there is a lot of setting up to do to get one running. You also have to be
    familiar with the components available for constructing your **Behavior Tree**
    to do so effectively.
  prefs: []
  type: TYPE_NORMAL
- en: A Behavior Tree is extremely useful for defining NPC behavior that is more varied
    than simply moving towards an opponent (as shown in the previous recipe with `AIMoveTo`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The process of setting up a Behavior Tree to control a character is fairly complicated.
    The first thing we need is a Blueprint of a `Character` class derivative to control.
    We then need to create a custom AI Controller object that will run our Behavior
    Tree to control our Melee attacker character. The `AIController` class inside
    our Blueprint will run our Behavior Tree.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00246.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Behavior Tree itself contains a very important data structure called a **Blackboard**.
    The Blackboard is like a chalkboard for containing variable values for the Behavior
    Tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Behavior Tree hosts six different types of node, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task**: Task nodes are the purple nodes in the Behavior Tree that contain
    Blueprint code to run. It''s something that the AI-controlled unit has to do (code-wise).
    Tasks must return either `true` or `false`, depending on whether the task succeeded
    or not (by providing a `FinishExecution()` node at the end).![Getting ready](img/00247.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Decorator**: A decorator is just a Boolean condition for the execution of
    a node. It checks a condition, and is typically used within a Selector or Sequence
    block.![Getting ready](img/00248.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Service**: Runs some Blueprint code when it ticks. The tick interval for
    these nodes is adjustable (can run slower than a per-frame tick, for example,
    every 10 seconds). You can use these to query the scene for updates, or a new
    opponent to chase, or things like that. The Blackboard can be used to store queried
    information. Service nodes do not have a `FinishExecute()` call at the end. There
    is an example Service node in the Sequence node in the preceding diagram.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Selector**: Runs all subtrees from left to right until it encounters a success.
    When it encounters a success, execution returns back up the tree.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Sequence**: Runs subtrees from left to right until it encounters a failure.
    When a failure is encountered, execution goes back up the tree.![Getting ready](img/00249.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Selector nodes attempt to execute nodes until success (after which it returns),
    while Sequence nodes execute all until a failure is encountered (after which it
    returns).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if your Tasks do not call `FinishExecute()`, neither Selectors
    nor Sequences will be able to run more than one of them in succession.
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Parallel**: Runs a single task (purple) in parallel with a subtree
    (gray).![Getting ready](img/00250.jpeg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Begin by creating a Blueprint for your Melee unit inside UE4\. You should do
    so by deriving a custom Blueprint from `Character`. To do so, go to the **Class
    Viewer**, type `Character`, and right-click. Select **Create Blueprint…** from
    the context menu that appears and name your Blueprint class `BP_MeleeCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To use a Behavior Tree, we need to start by setting up a custom AI Controller
    for our `Character` class derivative. Go to **Content Browser** and derive a Blueprint
    from the `AIController` class—be sure to turn off **Filters** | **Actors only**
    first!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Non-actor class derivatives are not shown by default in the **Class Viewer**!
    To make the `AIController` class show, you need to go to the **Filters** menu
    and uncheck the **Actors only** menu option.
  prefs: []
  type: TYPE_NORMAL
- en: Create your Behavior Tree and Blackboard objects by right-clicking in **Content
    Browser** and selecting **Artificial Intelligence** | **Behavior Tree** and **Artificial
    Intelligence** | **Blackboard**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Behavior Tree** object, and under **Blackboard Asset** in the **Details**
    panel, select the Blackboard that you've created. Blackboards contain keys and
    values (named variables) for your Behavior Tree to use.![How to do it...](img/00251.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your `BP_AIMeleeController` class derivative and go to the Event Graph.
    Under **Event BeginPlay**, select and add a **Run Behavior Tree** node to the
    graph. Under `BTAsset`, be sure to select your `BehaviorTree_FFA_MeleeAttacker`
    asset.![How to do it...](img/00252.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Behavior Tree is connected to an AI Controller, which in turn is connected
    to a Blueprint of a Character. We will control the behavior of `Character` through
    the Behavior Tree by entering Task and Service nodes to the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing Task nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Task nodes are like function blocks. Each Task node you construct will allow
    you to bundle up some Blueprint code for execution when certain conditions in
    your Behavior Tree are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks have three distinct events: Receive Tick (with AI version), Receive Execute
    (AI), and Receive Abort (AI). You can respond to any of these three events in
    the Task''s Blueprint. Usually, you should respond to the Receive Execute (AI
    version) of the Task.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a Task node, you should already have a Behavior Tree ready and attached
    to an appropriate AI Controller and Blueprinted Character (see previous recipe).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To construct a Task node with an executable Blueprint code inside it, you must
    select **New Task** from the menu bar from our **Behavior Tree** Blueprint editor.
    From the drop-down menu that appears, select to base your **New Task** on `BTTask_BlueprintBase`.![How
    to do it…](img/00253.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike Behavior Tree or Blackboard creation, there isn't a way to create a **New
    Task** directly from the **Content Browser**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Double-click and open the Behavior Tree task that you''ve just created to edit
    it. Override any of the available events (listed in the **Functions** subheading
    under the **My Blueprint** tab):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Receive Tick AI**: The AI version of the `Tick` event for the Behavior Tree
    Task. You should override this function when you need your task to `Tick` with
    the actor that contains it. Do not override this function if you only want your
    task to execute when it is called by the Behavior Tree (not when the game engine
    ticks).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Receive Execute AI**: The main function that you want to override. Receive
    Execute AI allows you to run some Blueprint code whenever the Task node is invoked
    from the Behavior Tree diagram.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Receive Abort AI**: An abortion on a Behavior Tree task is called when the
    task is being aborted (by a `FinishAbort()` node call from the Blueprints diagram).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are non-AI versions of the preceding functions, which have just differing
    arguments: In the `*AI` version, the owner object is cast as a `Pawn`, and there
    is an Owner Controller passed along to the event call.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Decorators for conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Decorators** are nodes that allow you to enter a conditional expression on
    evaluation of another node. They are fairly oddly named, but they are called Decorators
    because they tend to *dress up* execution nodes with conditions for execution.
    For example, in the following diagram, the `MoveTo` function is only executed
    when the Decorators condition is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Decorators for conditions](img/00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There are several pre-packaged Decorators that come with UE4, including Blackboard
    (variable checks), **Compare Blackboard Entries**, **Cone Check**, **Cooldown**,
    **Does Path Exist**, and so on. In this recipe, we explore the use of some of
    these conditionals to control the execution of different branches of a Behavior
    Tree.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to create a Decorator is only available from the menu bar of an
    existing **Behavior Tree**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **New Decorator** button is in the Menu bar of an existing **Behavior Tree**,
    so to find it, you must have an existing **Behavior Tree** open.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Menu bar of an existing **Behavior Tree**, select **New Decorator**.
    Base it on the existing Blueprint, `BTDecorator_BlueprintBase`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assemble your Blueprints diagram determining whether or not the Decorator's
    condition is successful under the `PerformConditionCheck` function override.![How
    to do it…](img/00256.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Internals of a Decorator checking if the follow target from the Blackboard is
    inside a bounding sphere of certain radius. Return `true` if the Decorator's condition
    is met (and the block dependent on the Decorator executes), or return `false`
    if the Decorator's condition is not met (and the block dependent on the Decorator
    does not execute).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decorators are just like `if` statements; the only difference is that they place
    a condition to execute the node directly beneath them in a Behavior Tree.
  prefs: []
  type: TYPE_NORMAL
- en: Using periodic services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Services** are nodes that contain Blueprint code to be executed periodically.
    Services are a lot like Tasks, but they do not have a `FinishExecute()` call at
    the end.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding Services to your Behavior Tree is essential for periodic checks of things
    such as if there are any new enemy units within range, or if your current target
    left focus. You can create your own Services. In this recipe, we'll assemble a
    Service that will check if the opponent you are following is still the closest
    within a visibility cone. If not, then the opponent changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main events for a Service node (other than Tick):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Receive Activation AI**: Triggers when the Behavior Tree starts and the node
    is first activated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Receive Search Start AI**: Triggers when the Behavior Tree enters the underlying
    branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Receive Tick AI**: Triggers each frame where the Service is invoked. The
    bulk of the work is performed here.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Receive Deactivation AI**: Triggers when the Behavior Tree closes and the
    node is deactivated.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, add a **New Service** to your **Behavior Tree** via the **New Service**
    button in the **Behavior Tree** Menu Bar:![How to do it…](img/00257.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your Service something that describes what it does, such as `BehaviorTree_Service_CheckTargetStillClosest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on your Service to begin editing its Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the editor, add a Receive Tick AI node, and perform any updates to the Blackboard
    that you need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service nodes execute some Blueprint code at some regularly spaced time-intervals
    (with the option of deviation). Inside a Service node, you will usually update
    your Blackboard.
  prefs: []
  type: TYPE_NORMAL
- en: Using Composite nodes – Selectors, Sequences, and Simple Parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composite nodes form tree nodes inside the Behavior Tree, and contain more
    than one thing to execute within them. There are three types of Composite nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selectors**: Go through children from left to right looking for a successful
    node. If a node fails, it tries the next one. When successful, the node is completed
    and we can go back up the tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence**: Execute from left to right, until a node fails. If the node is
    successful, do the next one. If the node fails, go back up the tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple Parallel**: Single task (purple) in parallel with some subtree (gray).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using composite nodes is fairly straightforward. You only need a Behavior Tree
    to get started with them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click anywhere on the blank space in your Behavior Tree diagram.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Composites** | **Selector or Composites** | **Sequence**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Selectors**: Will execute all tasks in series until one succeeds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sequence**: Will execute all tasks in series until one fails'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append to the node a chain of Tasks or other Composite nodes, as desired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AI for a Melee Attacker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a Behavior Tree to construct an NPC with melee attack behavior.
    The Melee Attacker will have the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Search for the best opponent to attack every 10 seconds. The best opponent to
    attack is going to be the closest opponent within a `SearchRadius`. We will achieve
    this using a Service. Chalk the opponent we are attacking into the Melee Attacker's
    Behavior Tree Blackboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move towards the opponent we are attacking (indicated by the Blackboard).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are within `AttackRadius` units of the opponent, damage the opponent we
    are attacking every `AttackCooldown` seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is just one way to attack an opponent using a `BehaviorTree`. You will
    find you can also attack inside an attack animation for the Melee Attacker, in
    which case you could just indicate to Play Animation when within `AttackRadius`
    of the opponent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have a Blueprint of a Melee Attacker Character ready. I called mine `BP_Melee`.
    Prepare the `BP_Melee` Character's AI Controller to use a new Behavior Tree that
    we will create next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the root, we want a node that returns immediately if it fails. Create a
    new Sequence node with a Service called `BehaviorTree_Service_FindOpponent` inside
    it. Put the interval at 10 seconds for the node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build out the `BehaviorTree_Service_FindOpponent` node as follows:![How to do
    it...](img/00258.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside another Behavior Tree node, indicate a per-frame motion towards the follow
    target:![How to do it...](img/00259.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we'd like to damage the opponent when in `AttackRadius` of him. When
    the player is within `AttackRadius`, you can begin playing the attack animation
    (which could kick off damage events to the opponent), run a Damage Service (every
    `AttackCooldown` seconds), or simply **Cooldown** and **Damage Opponent** as shown
    in the following screenshot:![How to do it...](img/00260.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
