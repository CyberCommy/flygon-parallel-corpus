- en: Generating System Reports and System Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting data and generating recurring system reports are essential tasks
    for any system administrator, and automating these tasks can help us to discover
    issues early on, in order to provide solutions for them. In this chapter, we will
    see some proven methods for automating data collection from servers and generating
    that data into formal reports. We will learn how to manage new and existing users,
    using Python and Ansible. Also, we will dive into log analysis and monitoring
    the system **Key Performance Indicators** (**KPIs**). You can schedule the monitoring
    scripts to run on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting data from Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users in Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting data from Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Native Linux commands provide useful data about the current system status and
    health. However, each one of those Linux commands and utilities are focused on
    getting data from only one aspect of the system. We need to leverage Python modules
    to get those details back to the administrator and generate useful system reports.
  prefs: []
  type: TYPE_NORMAL
- en: We will divide the reports into two parts. The first one is getting general
    information about the system by using the `platform` module, while the second
    part is exploring the hardware resources in terms of the CPU and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by leveraging the `platform` module, which is a built-in library
    inside of Python. The `platform` module contains many methods that can be used
    to get details about the system that Python operates on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00157.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the same script on a Windows machine will result in different outputs,
    reflecting the current system. So, when we run it on a Windows PC, we will get
    `Windows` as the output from the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00158.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Another useful function is `uname()`, which does the same job as the Linux
    command (`uname -a`): retrieving the machine''s hostname, architecture, and kernel,
    but in a structured format, so that you can match any value by referring to its
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00159.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first value is the system type, which we get using the `system()` method,
    and the second value is the hostname of the current machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore and list all of the available functions inside the `platform`
    module by using autocomplete in PyCharm; you can check the documentation for each
    function by pressing *CTRL *+ *Q*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00160.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The second part of designing our script is using the information made available
    by the Linux files to explore the hardware configuration in the Linux machine.
    Remember that the CPU, memory, and network information could be accessible from
    under `/proc/`; we will read this information and access it using standard `open()`
    function in Python. You can get more information about the available resources
    by reading and exploring `/proc/`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Script:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first step for importing the `platform` module. It''s needed only
    for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet contains the functions used in this exercise; we will design two
    functions - `check_feature()` and `get_value_from_string()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following is the main body of the Python script, which contains
    the Python logic to get the required information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This part is used to print the information obtained from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the following steps were performed:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we opened `/proc/cpuinfo` and read its contents, then stored the result
    in `cpu_data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of processors inside the file could be found by counting the keyword
    `processor` using the `count()` String function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we needed to get the options and features available for each processor.
    For that, we got only one processor entry (since they're usually identical to
    each other) and passed it the `check_feature()` function. This method accepts
    the feature that we want to search in one argument, and the other is the processor
    data, which will return `True` if the feature is available in the processor data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The processor data is available in key-value pairs. So, we designed the `get_value_from_string()`
    method, which accepts the key name and will search for its corresponding value
    by iterating over the processor data; then, we will  split on the `:`  delimiter
    for every returned key value pair to get the value only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of these values are added to the `cpu_feature` list using the `append()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then repeated the same operation with the memory information to get the total,
    free, and swap memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we used the platform's built-in methods, such as `system()`, `uname()`,
    and `python_version()`, to get information about the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end, we printed the report that contains the preceding information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The script output can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00161.jpeg)Another way to represent the generated data is to
    leverage the `matplotlib` library that we used in [Chapter 5](part0087.html#2IV0U0-9cfcdc5beecd470bbeda046372f0337f),
    *Extracting Useful Data for Network Devices*, to visualize data over time.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending generated data through email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The report generated in the previous section provides a good overview of the
    resources currently on the system. However, we can tweak the script and extend
    its functionality to send us an email with all of the details. This is  very useful
    for a **Network Operation Center** (**NoC**) team, which can receive emails from
    a monitored system based on specific incidents (HDD failure, high CPU, or dropped
    packets). Python has a built-in library called `smtplib`, where it leverages the
    **Simple Mail Transfer Protocol** (**SMTP**) that is responsible for sending and
    receiving emails from mail servers.
  prefs: []
  type: TYPE_NORMAL
- en: This requires that you have local email servers on your machine, or that you
    use one of the free online email services, such as Gmail or Outlook. For this
    example, we will log in to [http://www.gmail.com](http://www.gmail.com) using
    the SMTP and send email with our data.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, we will modify our script and add the SMTP support to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will import the required modules into Python. Again, `smtplib` and `platform`
    are needed for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the part of the function that contains both the `check_feature()` and
    `get_value_from_string()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the main body of the Python script is as follows, containing the Python
    logic to get the required information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end, we need to populate the variables with some values to properly
    connect to the `gmail` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part is the same as the original example, but instead of printing
    the data to the terminal, we add it to the `Data_Sent_in_Email` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Header` variable represents the email header containing the sender's address,
    the recipient's address, and the email's subject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `SMTP()` class inside of the `smtplib` module to connect to the public
    Gmail SMTP server and negotiate the TTLS connection. This is the default method
    when connecting to Gmail servers. We hold the SMTP connection in the `server`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we log in to the server by using the `login()` method, and finally, we
    use the `sendmail()` function to send the email. `sendmail()` accepts three arguments:
    the sender, the recipient, and the email body.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we close the connection with the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Script output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00162.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the time and date modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great; so far, we have been able to send custom data generated from our servers
    through email. However, there might be a difference in time between the generated
    data and the email's delivery time, due to network congestion or a failure in
    the mail system, or any other reason. So, we can't depend on the email to correlate
    the delivery time with the actual event time.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, we will use the Python `datetime` module to follow the current
    time on the monitored system. This module can format the time in many attributes,
    such as year, month, day, hour, and minute.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from that, the `datetime` instance from the `datetime` module is actually
    a standalone object in Python (like int, string, boolean, and so on); hence, it
    has its own attributes inside of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the `datetime` object to a string, you can use the `strftime()`
    method, which is available as an attribute inside of the created object. Also,
    it provides a method for formatting the time by using the following directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directive** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Returns the year, from 0001 to 9999 |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Returns the month number |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Returns the day of the month |'
  prefs: []
  type: TYPE_TB
- en: '| `%H` | Returns the hour number, 0-23 |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Returns the minutes, 0-59 |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | Returns the seconds,0-59 |'
  prefs: []
  type: TYPE_TB
- en: 'So, we will tweak our script and add the following snippet to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First, we imported the `datetime` class from the `datetime` module. Then, we
    created the `time_now` object using the `datetime` class and the `now()` function,
    which returns the current time on the running system. Finally, we used `strftime()`,
    with a directive, to format the time in a specific format and convert it to a
    string for printing (remember, the object has a `datetime` object).
  prefs: []
  type: TYPE_NORMAL
- en: 'The script''s output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00163.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Running the script on a regular basis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A final step in the script is to schedule the script to run at a time interval.
    This can be daily, weekly, hourly, or at a specific time. This can be done using
    the `cron` job on Linux systems. `cron` is used to schedule a repeated event,
    such as cleaning up directories, backing up databases, rotating logs, or anything
    else you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the current jobs scheduled, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To edit `crontab`, use the `-e` switch. If this is the first time you are running `cron`,
    you will be prompted to use your favorite editor (`nano` or `vi`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical `crontab` consists of five stars, each one representing a time entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| Minutes | 0-59 |'
  prefs: []
  type: TYPE_TB
- en: '| Hours | 0-23 |'
  prefs: []
  type: TYPE_TB
- en: '| Day of the month | 1-31 |'
  prefs: []
  type: TYPE_TB
- en: '| Month | 1-12 |'
  prefs: []
  type: TYPE_TB
- en: '| Day of the week | 0-6 (Sunday - Saturday) |'
  prefs: []
  type: TYPE_TB
- en: 'For example, if you need to schedule a job to run every Friday at 9:00 P.M.
    you will use the following entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to have a command every day at 12:00 A.M. (a backup, for example),
    use the following `cron` job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can schedule the `cron` to run at *every* specific interval. For
    example, if you need to run a job every `5` minutes, use this `cron` job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to our script; we can schedule it to run every day at 7:30 AM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, remember to save the `cron`  job before exiting.
  prefs: []
  type: TYPE_NORMAL
- en: It's better to provide a full command path to Linux, rather than a relative
    path, to avoid any potential issues.
  prefs: []
  type: TYPE_NORMAL
- en: Managing users in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will discuss how to manage users in different systems.
  prefs: []
  type: TYPE_NORMAL
- en: Linux systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides powerful user management modules to manage different tasks
    on a system. We have a chapter dedicated to discussing Ansible ([Chapter 13](part0168.html#506UG0-9cfcdc5beecd470bbeda046372f0337f), *Ansible
    for System Administration*), but in this chapter, we will explore its power for
    managing user accounts across a company's infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, companies allow root access to all users, to get rid of the headache
    of user management; this is not a good solution in terms of security and auditing.
    It's the best practice to give the right permissions to the right users, and to
    revoke them once users leave the company.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible provides an unmatched way to manage users across multiple servers, through
    either password or password-less (SSH key) access.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other things that need to be taken into consideration when creating
    users in a Linux system. The user must have a shell (such as Bash, CSH, ZSH, and
    so on) in order to log in to the server. Also, the user should have a home directory
    (usually under `/home`). Finally, the user must be in a group that determines
    its privileges and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first example will be creating a user with an SSH key in the remote server,
    using the ad hoc command. The key source is at the `ansible` tower, while we execute
    the command on `all` servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The second example is creating a user using the Playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the task''s parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: In our tasks, we use a user module that contains several parameters, such as
    `name`, that set the username for the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is `password`, where we set the user's password, but in
    a crypted format. You need to use the `mkpasswd` command, which prompts you for
    the password and will generate the hash value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups` is a list of groups that the user belongs to; hence, the user will
    inherit the permissions. You can use comma-separated values in this field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` is used to tell Ansible whether the user will be created or deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define the user shell used for remote access in the `shell` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createhome` and `home` are parameters used to specify the user''s home location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another parameter is `ssh_key_file`, which specifies the SSH filename. Also,
    the `ssh_key_passphrase` will specify the passphrase for the SSH key.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides the `win_user` module to manage local Windows user accounts.
    This is very useful when creating users on active directory domains or Microsoft
    SQL databases (`mssql`), or when creating default accounts on normal PCs. The
    following example will create a user called `bassem` and give it the password
    `access123`. The difference here is that the password is given in plain text and
    not in the crypted value, as in the Unix-based system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `password_never_expires` parameter will prevent Windows from expiring the
    password after a specific time; this is useful when creating admin and default
    accounts. On the other hand, `password_expired`, if set to `yes`, will require
    the user to enter a new password and change it upon first login.
  prefs: []
  type: TYPE_NORMAL
- en: The `groups` parameter will add the user from a listed value or comma-separated
    list of groups. This will depend on the `groups_action` parameter, and could be
    `add`, `replace`, or `remove`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the state will tell Ansible what should be done to the user. This parameter
    could be `present`, `absent`, or `query`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about collecting data and reports from Linux machines
    and alerting through email using time and date modules. We also learned how to
    manage users in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to interact with DBMS using Python connectors.
  prefs: []
  type: TYPE_NORMAL
