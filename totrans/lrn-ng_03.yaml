- en: Introducing TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built our very first component and we used TypeScript
    to shape the code scripts, which gave form to it. All the examples included in
    this book use its syntax. As we will see later in this book, writing our scripts
    in TypeScript and leveraging its static typing will give us a remarkable advantage
    over the other scripting languages.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not a thorough overview of the TypeScript language. We will
    just focus on the core elements of the language and study them in detail on our
    journey through Angular. The good news is that TypeScript is not all that complex,
    and we will manage to cover most of its relevant parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the background and rationale behind TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discover online resources to practice while we learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recap on the concept of typed values and how to represent them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build our own types, based on classes and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to better organize our application architecture with modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the case for TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The natural evolution of the early JavaScript-driven small web applications
  prefs: []
  type: TYPE_NORMAL
- en: into thick monolithic clients unveiled the shortcomings of the ECMAScript 5
    JavaScript specification. In a nutshell, large-scale JavaScript applications suffered
    from serious maintainability and scalability problems as soon as they grew in
    size and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This issue became more relevant as new libraries and modules required seamless
    integration onto our applications. The lack of good mechanisms for interoperability
    led to really cumbersome solutions that never seemed to fit the bill.
  prefs: []
  type: TYPE_NORMAL
- en: As a response to these concerns, ECMAScript 6 (also called as ES6 or ES2015)
    promised to solve these maintainability and scalability issues by introducing
    better module loading functionalities, an improved language architecture for better
    handling of scope, and a wide variety of syntactic sugar to better manage types
    and objects. The introduction of class-based programming turned into an opportunity
    to embrace a more OOP approach when building large-scale applications.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft took on the challenge and spent nearly two years building a superset
    of the language, combining the conventions of ES6 and borrowing some proposals
    from ES7\. The idea was to launch something that helped out with building enterprise
    applications with a lower error footprint by means of static type checking, better
    tooling, and code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: After two years of development led by Anders Hejlsberg, lead architect of C#
    and creator of Delphi and Turbo Pascal, TypeScript 0.8 was finally introduced
    in 2012 and it reached Version 1.0 two years later. TypeScript was not only running
    ahead of ECMAScript 6, but it also implemented the same features and provided
    a solid environment for building large-scale applications by introducing, among
    other features, optional static typing through type annotations, thereby ensuring
    type checking at compile time. This contributes to catching errors in earlier
    stages of the development process. The support for declaration files also gives
    developers the opportunity to describe the interface of their modules, so other
    developers can better integrate them into their code workflow and tooling.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following infographic provides a bird's eye view of the different features
    that
  prefs: []
  type: TYPE_NORMAL
- en: distinguish ECMAScript 6 from ECMAScript 5, and then differentiates TypeScript
    from the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a superset of ECMAScript 6, one of the main advantages of embracing TypeScript
    in your next project is the low entry barrier. If you know ECMAScript 6, you are
    pretty much all set, since all the additional features in TypeScript are optional.
    You can pick and introduce in your practice the features that help you to achieve
    your goal. All in all, there is a long list of strong arguments for advocating
    for TypeScript in your next project and all of them obviously apply to Angular
    as well. Here is a short rundown of arguments, just to name a few:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotating our code with types ensures a consistent integration of our different
    code units and improves code readability and comprehension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript's built-in type-checker will analyze your code at runtime and
    help you prevent errors even before executing your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of types ensures consistency across your applications. In combination
    with the previous two, the overall code errors footprint gets minimized in the
    long run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript extends classes with longtime demanded features such as class fields,
    private members, enums, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of decorators opens the door to extend our classes and implementations
    in unparalleled ways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating interfaces and type definition files (which we will not cover in this
    book) ensures a smooth and seamless integration of our libraries in other systems
    and codebases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript support across the different IDEs on store is terrific, and we can
    benefit from code highlighting, real-time type checking, and automatic compilation
    at no cost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TypeScript syntax will definitely please developers coming from other backgrounds
    such as Java, C#, C++, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing TypeScript resources in the wild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are going to take a look at where we can get further support to learn
    and test-drive our new knowledge of TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript official site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Obviously, our first stop is the official site for the language: [http://www.typescriptlang.org](http://www.typescriptlang.org).
    There, we can find a more extensive introduction to the language and links to
    IDEs and corporate supporters of this project. Nevertheless, the most important
    sections that we will definitely revisit more often are the learn section and
    the play sandbox.'
  prefs: []
  type: TYPE_NORMAL
- en: The learn section gives us access to a quick tutorial to get up to speed with
    the language in no time. It might be interesting as a recap on what we discussed
    in the previous chapter, but we would suggest you skip it in favor of the sample
    pages and the language spec, the latter being a direct link to the full extensive
    documentation of the language at GitHub. This is a priceless resource for both
    new and experienced users.
  prefs: []
  type: TYPE_NORMAL
- en: The play section offers a convenient sandbox, including some readymade code
    examples, covering some of the most common traits of the language. We encourage
    you to leverage this tool to test out the code examples we will see throughout
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript official wiki
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We made a reference to the TypeScript wiki in the previous chapter when speaking
    about the most basic parameters we need to know when executing commands with the
    TypeScript compiler API.
  prefs: []
  type: TYPE_NORMAL
- en: The code for TypeScript is fully open sourced at GitHub, and the Microsoft team
    has made a good effort at documenting the different facets of the code in the
    wiki available on the repository site. We encourage you to go take a look at it
    any time you have a question or want to delve deeper into any of the language
    features or form aspects of its syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The wiki is located at: [https://github.com/Microsoft/TypeScript/wiki](https://github.com/Microsoft/TypeScript/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: Types in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with TypeScript or any other coding language means basically working
    with data, and such data can represent different sorts of content. This is what
    we know as types, a noun used to represent the fact that such data can be a text
    string, an integer value, or an array of these value types, among others. This
    is nothing new to JavaScript, since we have always been working implicitly with
    types, but in a flexible manner. This means that any given variable could assume
    (or return, in the case of functions) any type of value. Sometimes, this leads
    to errors and exceptions in our code because of type collisions between what our
    code returned and what we expected it to return type-wise. While this flexibility
    can still be enforced by means of any type that we will see later on in this chapter,
    statically typing our variables gives us and our IDEs a good picture of what kind
    of data we are supposed to find on each instance of code. This becomes an invaluable
    way to help debug our applications at compile time before it's too late. To investigate
    how a language feature works, I suggest you use a playground for two reasons.
    The first reason is to learn how the feature works. The second reason is to know
    the corresponding ES5 code it produces. I suggest using the following playground
    for this: [https://www.typescriptlang.org/play/.](https://www.typescriptlang.org/play/)
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably one of the most widely used primitive types in our code will be the
    string type, where we populate a variable with a piece of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Check out the type assignation next to the variable name, which is separated
    by a colon symbol. This is how we annotate types in TypeScript, as we already
    saw in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the string type, we can use either single or double quotes, and it
    is same as ECMAScript6\. We can define multiline text strings with support for
    text interpolation with placeholder variables by using the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Declaring our variables – the ECMAScript 6 way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript, as a superset of ECMAScript 6, supports expressive declaration nouns
    such as `let`, which informs us that the variable is scoped to the nearest enclosing
    block (either a function `for` loop or any enclosing statement). On the other
    hand, `const` is an indicator that the values declared this way are meant to always
    feature the same type or value once populated. For the rest of this chapter, we
    will enforce the traditional `var` notation for declaring variables, but do remember
    to use`let` and `const` where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The let keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a lot of cases in the code, I have been using `var` to declare objects,
    variables, and other constructs. It is really discouraged when starting with ES6
    or TypeScript. There is a reason for that and it''s because ES5 only have method
    scope. For most developers coming from another language and start using JavaScript,
    this comes as a bit of a shock. So firstly, what do we mean with function scope?
    We mean that a variable is unique within the context of a function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There can be no other variable `a` in that function. If you do declare more
    of it, then you will effectively redefine it. OK, so that''s good, but when is
    the scoping not there? It is not there in `for`-loops, for example. In Java you
    would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, you would know that the variable `i` would never leak outside of the `for`-loop
    and you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And know that the variable `i` outside of the `for`-loop would not affect the
    variable `i` inside the `for`-loop, they would be separated or scoped, as it is
    called. OK, so users of ES5 JavaScript have had this language flaw for a long
    time and recently a fix for this has been added to ES6 and Typescript respectively,
    namely the `let` keyword. Use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason this works is that the TypeScript compiler translates this to the
    following ES5 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The compiler essentially renames the variable within the `for`-loop, so that
    a name collision doesn't happen. So remember, no more `var`, just use the `let` keyword
    when in doubt.
  prefs: []
  type: TYPE_NORMAL
- en: Const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `const` keyword is a way for you to convey that this data should never
    be changed. As a code base grows, it is easy that changes happen by mistake; such
    a mistake might be costly. To get compile time support for this, the `const` keyword
    is there to help you. Use it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler will even indicate that this is not allowed with the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A word of caution here: this works only on the top level. You need to be aware
    of this if you declare objects as `const`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring the `obj` const does not freeze the entire object from being edited,
    but rather what `obj` points to. So, the following would not be allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we actively change what `obj` points to, not one of its child properties,
    therefore it is not allowed and you get the same compile error as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Number is probably the other most widespread primitive data type along with
    string and boolean. The same as in JavaScript, number defines a floating point
    number. The number type also defines hexadecimal, decimal, binary, and octal literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Boolean type defines data that can be `True` or `False`, representing the
    fulfillment of a condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assigning wrong member types to arrays and handling exceptions that arise by
    that can be now easily avoided with the `Array` type, where we describe an array
    containing certain types only. The syntax just requires the `postfix []` in the
    type annotation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we try to add a new member to the `childrenAges` array with a type other
    than number, the runtime type checker will complain, making sure our typed members
    remain consistent and our code is error-free.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing with the any type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it is hard to infer the data type out of the information we have
    at some point, especially when we are porting legacy code to TypeScript or integrating
    loosely typed third-party libraries and modules. Don''t worry, TypeScript supplies
    us with a convenient type for these cases. The `any` type is compatible with all
    the other existing types, so we can type any data value with it and assign any
    value to it later on. This great power comes with a great responsibility, though.
    If we bypass the convenience of static type checking, we are opening the door
    to type errors when piping data through our modules, and it will be up to us to
    ensure type safety throughout our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The null and undefined JavaScript literals require special mention. In a nutshell,
    they are typed under the `any` type. This makes it possible later on to assign
    these literals to any other variable, regardless of its original type.
  prefs: []
  type: TYPE_NORMAL
- en: Custom type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Typescript, you are able to come up with your own type if you need to, by
    using the `type` keyword in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have created now is a type with *x* number of allowed values. Let''s
    create a variable from this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly allowed as `Cheetah` is one of the allowed values, and works
    as intended. The interesting part happens when we give our variable a value it
    does not expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enum is basically a set of unique numeric values that we can represent by assigning
    friendly names to each one of them. The use of enums goes beyond assigning an
    alias to a number. We can use them as a way to list, in a convenient and recognizable
    way, the different variations that a specific type can assume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enums are declared using the `enum` keyword, without `var` or any other variable
    declaration noun, and they begin numbering members starting at 0 unless explicit
    numeric values are assigned to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the value of `myCar` will return `1` (which is the index held by
    `Cadillac` in the `enum`). As we mentioned already, we can assign custom numeric
    values in the `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting `myTruck` will yield `2`, since the first enumerated value was set
    as `1` already. We can extend value assignation to all the `enum` members as long
    as such values are integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'One last trick worth mentioning is the possibility to look up the enum member
    mapped to a given numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It should be mentioned that from TypeScript 2.4 it is possible to assign string
    values to Enums.
  prefs: []
  type: TYPE_NORMAL
- en: Void
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `void` type definitely represents the absence of any type and its use is
    constrained to annotating functions that do not return an actual value. Therefore,
    there is no return type either. We already had the chance to see this with an
    actual example in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typing our data is optional since TypeScript is smart enough to infer the data
    type of our variables and function return values out of context with a certain
    level of accuracy. When no type inference is possible, TypeScript will assign
    the dynamic any type to the loosely typed data at the cost of reducing type checking
    to a bare minimum.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of inferring at work can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This holds the same effect, that is, it will lead to a compilation error if
    you try to assign a non-compatible data type to it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Functions, lambdas, and execution flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The same as in JavaScript, functions are the processing machines where we analyze
    input, digest information, and apply the necessary transformations to the data
    provided to either transform the state of our application or return an output
    that will be used to shape our application's business logic or user interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in TypeScript are not that different from regular JavaScript, except
    for the fact that functions, just as everything else in TypeScript, can be annotated
    with static types and thus, they better inform the compiler of the information
    they expect in their signature and the data type they aim to return, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating types in our functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example showcases how a regular function is annotated in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can clearly see two main differences from the usual function syntax in regular
    JavaScript. First, we annotate with type information the parameters declared in
    the function signature. This makes sense since the compiler will want to check
    whether the data provided when executing the function holds the correct type.
    In addition to this, we also annotate the type of the returning value by adding
    the postfix string to the function declaration. In these cases, where the given
    function does not return any value, the type annotation void will give the compiler
    the information it requires to provide a proper type checking.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, the TypeScript compiler is smart enough
    to infer types when no annotation is provided. In this case, the compiler will
    look into the arguments provided and the return statements to infer a returning
    type from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in TypeScript can also be represented as expressions of anonymous
    functions, where we bind the function declaration to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is a downside to this syntax. Although typing function expressions
    this way is allowed, thanks to type inference, the compiler is missing the type
    definition in the declared variable. We might assume that the inferred type of
    a variable that points to a function typed as a string is obviously a string.
    Well, it''s not. A variable that points to an anonymous function ought to be annotated
    with a function type. Basically, the function type informs about both the types
    expected in the function payload and the type returned by the function execution,
    if any. This whole block, in the form of `(arguments: type) =>` returned type,
    becomes the type annotation our compiler expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Why such a cumbersome syntax, you might ask? Sometimes, we will declare variables
    that might depend on factories or function bindings. Then, it is always a good
    practice to provide as much information to the compiler as we can. This simple
    example might help you to understand better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This way, we also ensure that later function assignations conform to the type
    annotations set when declaring variables.
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters in Typescript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to the type checking performed by the compiler, function parameters require
    special attention in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Optional parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parameters are a core part of the type checking applied by the TypeScript compiler.
    TypeScript offers an optional functionality by adding the `?` symbol as a postfix
    to the parameter name we want to make optional. This allows us to leave out the
    second parameter in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will attempt to print out the greeting variable as well as produce
    a proper greeting. Running this code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So, an optional parameter doesn''t really get set unless you explicitly make
    it so. It is more of a construct so that you can get help with deciding what parameters
    are mandatory and which ones are optional. Let''s exemplify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can invoke this function in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Both versions are allowed. Using optional parameters in your function signature
    forces you to place them last, like the previous example. The following example
    illustrates what not to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This would create a situation where both parameters would be mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Even the compiler would complain and say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember, optionals are great, but place them last.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript gives us another feature to cope with the scenario depicted earlier
    in the form of default parameters, where we can set a default value that the parameter
    will assume when not explicitly populated upon executing the function. The syntax
    is pretty straightforward, as we can see when we refactor the previous example
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with optional parameters, default parameters must be put right after
    the non-default parameters in the function signature. There is a very important
    difference, which is that default parameters are always safe to use. Why they
    are safe to use, is indicated by the ES5 code below. The ES5 code below is the
    resulting code from compiling the above TypeScript to ES5\. The following code
    indicates that the compiler adds an IF clause that checks whether the variable `greeting` is
    undefined and if so gives it a starter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the compiler adds an `if`-clause investigating your value and
    if it is not set, it adds the value you provided earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The type is inferred when you are dealing with default parameters as you assign
    a value to them. In the preceding code snippet, greeting is inferred to be a string
    by it being assigned the string value `'Hello'`.
  prefs: []
  type: TYPE_NORMAL
- en: Rest parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the big advantages of the flexibility of JavaScript when defining functions
    is the functionality to accept an unlimited non-declared array of parameters in
    the form of the arguments object. In a statically typed context such as TypeScript,
    this might not be possible, but it actually is by means of the REST parameter''s
    object. Here, we can define, at the end of the arguments list, an additional parameter
    prefixed by ellipsis (`...`) and typed as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to note that the Rest parameters must be put at the end of
    the arguments list and can be left out whenever not required. Let''s have a look
    at the resulting ES5 code to understand what the TypeScript compiler produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can see here is that the built-in arguments array is being used. Also,
    that its content is copied over into the `names` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It really makes perfect sense when you think about it. So, Rest parameters is
    your friend when you don't know the number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Overloading the function signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method and function overloading is a common pattern in other languages such
    as C#. However, implementing this functionality in TypeScript clashes with the
    fact that JavaScript, which TypeScript is meant to compile to, does not implement
    any elegant way to integrate this functionality out of the box. So, the only workaround
    possibly requires writing function declarations for each of the overloads and
    then writing a general-purpose function that will wrap the actual implementation
    and whose list of typed arguments and returning types are compatible with all
    the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are exposing three different function signatures
    and each of them feature different type annotations. We could even define different
    returning types if there was a case for that. For doing so, we should have just
    annotated the wrapping function with an any return type.
  prefs: []
  type: TYPE_NORMAL
- en: Better function syntax with and scope handing with lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECMAScript 6 introduced the concept of fat arrow functions (also called lambda
    functions in other languages such as Python, C#, Java, or C++) as a way to both
    simplify the general function syntax and also to provide a bulletproof way to
    handle the scope of the functions that are traditionally handled by the infamous
    scope issues of tackling with the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first impression is its minimalistic syntax, where, most of the time, we
    will see arrow functions as single-line, anonymous expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The function computes the double of a given number, `x`, and returns the result,
    although we do not see any function or return statements in the expression. If
    the function signature contains more than one argument, we just need to wrap them
    all between braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes this syntax extremely convenient when developing functional operations
    such as `map`, `reduce`, and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrow functions can also contain statements. In this case, we will want to
    wrap the whole implementation in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, what does this have to do with scope handling? Basically, the value
    of this can point to a different context, depending on where we execute the function.
    This is a big deal for a language that prides itself on an excellent flexibility
    for functional programming, where patterns such as callbacks are paramount. When
    referring to `this` inside a callback, we lose track of the upper context and
    that usually forces us to use conventions such as assigning the value of `this`
    to a variable named self or that, which will be used later on within the callback.
    Statements containing interval or timeout functions make a perfect example of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the preceding script, we won''t get the expected `Hello Peter`
    alert, but an incomplete string highlighting a pesky greeting to `Mr. Undefined!`Basically,
    this construction screws the lexical scoping of this when evaluating the function
    inside the timeout call. Porting this script to arrow functions will do the trick,
    though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Even if we break down the statement contained in the arrow function into several
    lines of code wrapped by curly braces, the lexical scoping of this will keep pointing
    to the proper context outside the `setTimeout` call, allowing a more elegant and
    clean syntax.
  prefs: []
  type: TYPE_NORMAL
- en: General features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some general features in TypeScript that don't really apply specifically
    to either classes, functions, or parameters, but rather makes coding more efficient
    and fun. The idea is that the fewer lines of code you have to write, the better
    it is. It's not only about fewer lines, but also about making things clearer.
    There are a ton of such features in ES6 that TypeScript has also implemented,
    but here, I will just name a few that are likely to occur in your Angular project.
  prefs: []
  type: TYPE_NORMAL
- en: Spread parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A spread parameter is using the same syntax `...` ellipsis as the REST parameters,
    but it is used differently. It's not used as a parameter inside of a function,
    but rather inside the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s illustrate what that means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: What we do here is add an item to an existing array without changing the old
    array. The `oldArray` variable still contains `1,2`, but the `newArray` contains
    `1,2,3`. This general principle is called *immutability*, which essentially means
    don't change, but rather create a new state from the old state. It's a principle
    used in functional programming both as a paradigm, but also for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a REST parameter on objects; yes, really. You would write
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The result from running this code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A merge between the two objects. Just like with the example of the list, we
    would not change the previous variable, `oldPerson`. A `newPerson` variable would
    take the information from `oldPerson`, but add its new values to it. Looking at
    the ES5 code you can see why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What's happening here is that an `assign` function is being defined. Said function
    loops the keys of `oldPerson` variables and assigns those to a new object and
    lastly adds the content of the`newPerson` variable. If you look at the preceding
    function, it either defines a function that does this or it uses `Object.assign`,
    which is part of ES6 standard, if available.
  prefs: []
  type: TYPE_NORMAL
- en: Template strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template string is all about making your code clearer. Imagine the following
    scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what''s wrong with this? The answer is readability. It''s hard to imagine
    what the resulting string will look like, but it is also very easy for you to
    edit the previous code by mistake, and suddenly, the result will not be what you
    want. Most languages use a format function for this and that is exactly what template
    strings is, a format function. It is used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This is a much more condensed expression and so it is much easier to read, so
    use it, always.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generics is an expression for saying that we have a general code behavior that
    we can employ regardless of data type. Generics are very often used to operate
    on collections as collections often have similar behavior regardless of types.
    Generics can however be used on constructs such as methods. The idea is also that
    Generics should indicate if you are about to mix types in a way that isn''t allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `T` is not decided until you actually use the
    method. As you can see, the type of `T` varies from number to `String` depending
    on how you call it. It also ensures that you are inputting the correct type of
    data. This can be seen in the following row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we clearly specify that `T` should be a string, but we insist on feeding
    it a value of type number. The compiler clearly states that this is not OK.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, however, be more specific on what `T` should be. By typing the following,
    you ensure that `T` is of type `Array`, so any type of value you input must adhere
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we decide that `T` should be either of type `Person` or `A` and
    we also see that the input needs to be of type array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So, inputting a single object is not OK. So why do we do this? In this case,
    we want to ensure that certain methods are available such as `.length` and that
    we, in a given moment, don't care if we operate on something of type `A` or `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also decide that your type `T` should adhere to an interface like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line limits what `T` can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Generics is quite powerful to use if you have a common behavior
    that many different data types can relate to. You most likely won't be writing
    your own generic code, at least not initially, but it's good to know what is going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, interfaces, and class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have overviewed the most relevant bits and pieces of TypeScript,
    it's time to see how everything falls into place to build TypeScript classes.
    These classes are the building blocks of TypeScript and Angular applications.
  prefs: []
  type: TYPE_NORMAL
- en: Although the noun class was a reserved word in JavaScript, the language itself
    never had an actual implementation for traditional POO-oriented classes as other
    languages such as Java or C# did. JavaScript developers used to mimic this kind
    of functionality, leveraging the function object as a constructor type, which
    would be later on instanced with the new operator. Other common practices such
    as extending our function objects were implemented by applying prototypal inheritance
    or by using composition.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have an actual class functionality, which is flexible and powerful enough
    to implement the functionality our applications require. We already had the chance
    to tap into classes in the previous chapter. Let's look at them in more detail
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a class – constructors, properties, methods, getters, and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following piece of code illustrates how a class could be. Please note that
    the class property members come first and then we include a constructor and several
    methods and property accessors. None of them features the reserved word function
    and all the members and methods are properly annotated with a type except constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This class layout will probably remind us of the component class we built back
    in [Chapter 1](17474bca-f7f9-41ec-ab4c-5f7ac741c0c9.xhtml), *Creating Our Very
    First Component in Angular*. Basically, the class statement wraps several elements
    that we can break down into:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**: Any instance of the `Car` class will feature two properties -color
    typed as string, and `distanceRun` typed as a number and they will only be accessible
    from within the class itself. If we instance this class, `distanceRun`, or any
    other member or method marked as private, it won''t be publicly exposed as part
    of the object API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constructor**: The constructor function is executed right away when an instance
    of the class is created. Usually, we want to initialize the class members here,
    with the data provided in the constructor signature. We can also leverage the
    constructor signature itself to declare class members, as we did with the `isHybrid`
    property. To do so, we just need to prefix the constructor parameter with an access
    modifier such as private or public. Same as we saw when analyzing functions in
    the previous sections, we can define rest, optional, or default parameters as
    depicted in the previous example with the color argument, which fallbacks to red
    when it is not explicitly defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods**: A method is a special kind of member that represents a function
    and therefore, can return, or not, a typed value. Basically, it is a function
    that becomes part of the object API. Methods can be private as well. In this case,
    they are basically used as helper functions within the internal scope of the class
    to achieve the functionalities required by other class members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static members**: Members marked as static are associated with the class
    and not with the object instances of that class. This means that we can consume
    static members directly, without having to instantiate an object first. In fact,
    static members are not accessible from the object instances and thus, they cannot
    access other class members using this. These members are usually included in the
    class definition as helper or factory methods in order to provide a generic functionality
    not related to any specific object instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property accessors**: In ES5, we could define custom setters/getters in a
    very verbose way with `Object.defineProperty`. Now, things have become quite simpler.
    In order to create property accessors (usually pointing to internal private fields
    as in the example provided), we just need to prefix a typed method named as the
    property we want to expose with set (in order to make it writable) and get (in
    order to make it readable).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a personal exercise, why don''t you copy the preceding piece of code at
    the playground page ([http://www.typescriptlang.org/Playground](http://www.typescriptlang.org/Playground))
    and execute it? We can even see an instance object of the `Car` class in action
    by appending this snippet right after the class definition and running the code
    and inspecting the output in the browser''s developer tools console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We can even perform an additional test and append the following illegal statements
    to our code, where we attempt to access the private property `distanceRun` or
    even apply a value through the distance member, which does not have a getter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Right after inserting these code statements in the playground text field, a
    red underline will remark that we are attempting to do something that is not correct.
    Nevertheless, we can carry on and transpile and run the code, since ES5 will honor
    these practices. All in all, if we attempt to run the `tsc` compiler on this file,
    the runtime will exit with the following error trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Constructor parameters with accessors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally, when creating a class, you need to give it a name, define a constructor,
    and create one or more backing fields, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'For every field you need to add to the class you normally need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an entry to the constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an assignment in the constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the backing field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is really boring and not very productive. TypeScript have made it so,
    so that you don''t need to type the backing fields by us using accessors on the
    constructor parameters. We can now type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Giving a parameter a public accessor means it will create a public field and
    giving it a private accessor means it creates a private field for us like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And trying to access said fields would be like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES5, we don''t have the concept of fields so that disappears, but assignment
    in the constructor is still there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'But, you don''t have to do any of it in TypeScript, ever again. So, the preceding
    code using the constructor accessor approach only becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, more than half of the code disappears; this is really a selling
    point for TypeScript, as it saves you from typing quite a lot of tedious code.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As applications scale and more classes and constructs are created, we need to
    find ways to ensure consistency and rules compliance in our code. One of the best
    ways to address the consistency and type validation issue is to create interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, an interface is a code blueprint defining a certain field's schema
    and any types (either classes, function signatures) implementing these interfaces
    are meant to comply with this schema. This becomes quite useful when we want to
    enforce strict typing on classes generated by factories, when we define function
    signatures to ensure that a certain typed property is found in the payload, or
    other situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get down to business! Here, we define the `Vehicle` interface. `Vehicle`
    is not a class, but a contractual schema that any class that implements it must
    comply with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Any class implementing the `Vehicle` interface must feature a member named
    `make`, which must be typed as a string according to this example. Otherwise,
    the TypeScript compiler will complain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces are therefore extremely useful to define the minimum set of members
    any type must fulfill, becoming an invaluable method for ensuring consistency
    throughout our codebase.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that interfaces are not used just to define minimum
    class schemas, but any type out there. This way, we can harness the power of interfaces
    for enforcing the existence of certain fields and methods in classes and properties
    in objects used later on as function parameters, function types, types contained
    in specific arrays, and even variables. An interface may contain optional members
    as well and even members.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an example. To do so, we will prefix all our interface types with
    an `I` (uppercase). This way, it will be easier to find its type when referencing
    them with our IDE code autocompletion functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define an `Exception` interface that models a type with a mandatory
    message property member and an optional `id` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define interfaces for array elements as well. To do so, we must define
    an interface with a sole member, defining index as either a number or string (for
    dictionary collections) and then the type what we want that array to contain.
    In this case, we want to create an interface for arrays containing `Exception`
    types. This is a type comprising of a string message property and an optional
    ID number member, as we said in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define the blueprint for our future class, with a typed array and a
    method with its returning type defined as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define interfaces for standalone object types. This is quite useful
    when it comes to defining a templated constructor or method signatures, which
    we will see later in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, in the following class, we will implement all these interface
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Basically, we are defining an error handler class here that will manage an internal
    array of exceptions and expose a method to log new exceptions by saving them into
    the aforementioned array. These two elements are defined by the `ErrorHandler`
    interface and are mandatory. The class constructor expects the parameters defined
    by the `ExceptionHandlerSettings` interface and uses them to populate the exception
    member with items typed as `Exception`. Instancing the `ErrorHandler` class without
    the `logAllExceptions` parameter in the payload will trigger an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, I''ve been explaining interfaces as we are used to seeing them in other
    high level languages, but interfaces in TypeScript are on steroids; let me exemplify
    that by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we declare an interface, but we also create an instance from an interface
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'This is interesting because there are no classes involved here. That means
    writing a mocking library is a piece of cake*.* Let''s explain a bit what we mean
    with a mock library*.* When you are developing code you might think in interfaces
    before your start thinking in concrete classes. This is because you know what
    methods needs to exist but you might not have decided exactly how the methods
    should carry out a task. Imagine that you are building an order module. You have
    logic in your order module and you know that you at some point need to talk to
    a database service that will help you persist your order. You come up with a contract
    for said database service, an interface. You defer implementation of said interface
    until later. At this point a mocking library come in and is able to create a mock
    instance from an interface. Your code at this point might looking something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'So mocking at this point gives us the ability to defer implementation of `DatabaseService`
    until we are done writing the `OrderProcessor`. It also makes the test experience
    of `OrderProcessor` a whole lot better. Where we in other languages needed to
    bring in mock library as 3rd party dependency we can now utilize a built in construct
    in TypeScript by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This will give us an instance of `DatabaseService`. A word of warning though,
    you are responsible for adding a `process()`method to your instance. Your instance
    starts out as an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: This would not raise any problems with the compiler; this means that it is a
    powerful feature, but it leaves it to you to verify that what you create is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Let's emphasize how powerful this TypeScript feature really is by looking at
    some more code cases, where it pays off to be able to mock away things. Let's
    reiterate that the reason for mocking anything in your code is to make it easier
    to test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume your code looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'A better way to test this is to make sure that the `Stuff` class relies on
    abstractions, which means that the `AuthService` should be created elsewhere and
    that we talk to an interface of `AuthService` rather than the concrete implementation.
    So, we would modify our code to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this class, we would normally need to create a concrete implementation
    of `AuthService` and use that as a parameter in the `Stuff` instance, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'It would, however, become quite tedious to have to write a mock version of
    every dependency that you wanted to mock away. Therefore, mocking frameworks exist
    in most languages. The idea is to give the mocking framework an interface that
    it would create a concrete object from. You would never have to create a mock
    class, as we did previously, but that would be something that would be up to the
    mocking framework to do internally. Using said mock framework it would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already stated so far how easy it is to create an instance from an
    interface, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This means creating a mocking framework is then as easy as typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'And using it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Let's wrap up this section about interfaces by highlighting that classes can
    implement more than one interface, but also that interfaces are supercharged and
    facilitates testing quite a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes with class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like a class can be defined by an interface, it can also extend the members
    and functionality of other classes as if they were its own. We can make a class
    inherit from another by appending the keyword `extends` to the class name, including
    the name of the class we want to inherit its members from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, we extend from a parent class, `Car`, which already exposed a make member.
    We can populate the members already defined by the parent class and even execute
    their own constructor by executing the `super()` method, which points to the parent
    constructor. We can also override methods from the parent class by appending a
    method with the same name. Nevertheless, we will still be able to execute the
    original parent's class methods as it will be still accessible from the super
    object. Coming back to the interface, they can also inherit definition from other
    interfaces. Simply put, an interface can inherit from another interface.
  prefs: []
  type: TYPE_NORMAL
- en: As a word of caution, ES6 and TypeScript do not provide support for multiple
    inheritance. So, you may want to use composition or middleman classes instead,
    in case you want to borrow functionalities from different sources.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorators are a very cool functionality, originally proposed by Google in AtScript
    (a superset of TypeScript that finally got merged into TypeScript back in early
    2015) and also a part of the current standard proposition for ECMAScript 7\. In
    a nutshell, decorators are a way to add metadata to class declarations for use
    by dependency injection or compilation directives ([http://blogs.msdn.com/b/somasegar/archive/2015/03/05/typescript-lt-3-angular.aspx](http://blogs.msdn.com/b/somasegar/archive/2015/03/05/typescript-lt-3-angular.aspx)).
    By creating decorators, we are defining special annotations that may have an impact
    on the way our classes, methods, or functions behave or just simply altering the
    data we define in fields or parameters. In that sense, decorators are a powerful
    way to augment our type's native functionalities without creating subclasses or
    inheriting from other types.
  prefs: []
  type: TYPE_NORMAL
- en: This is, by far, one of the most interesting features of TypeScript. In fact,
    it is extensively used in Angular when designing directives and components or
    managing dependency injection, as we will see from [Chapter 5](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml),
    *Enhancing our Components with Pipes and Directives*, onwards.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators can be easily recognized by the `@` prefix to their name, and they
    are usually located as standalone statements above the element they decorate,
    including a method payload or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define up to four different types of decorators, depending on what element
    each type is meant to decorate:'
  prefs: []
  type: TYPE_NORMAL
- en: Class decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each of them!
  prefs: []
  type: TYPE_NORMAL
- en: Class decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class decorators allow us to augment a class or perform operations over any
    of its members, and the decorator statement is executed before the class gets
    instanced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a class decorator just requires defining a plain function, whose signature
    is a pointer to the constructor belonging to the class we want to decorate, typed
    as function (or any other type that inherits from the function). The formal declaration
    defines a `ClassDecorator`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, it is really difficult to grasp what this gibberish means, right? Let''s
    put everything in context through a simple example, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have gained a `banana()` method that was not originally defined
    in the `FruitBasket` class just by properly decorating it with the `Banana` decorator.
    It is worth mentioning though that this won''t actually compile. The compiler
    will complain that `FruitBasket` does not have a `banana()` method, and rightfully
    so. TypeScript is typed. In ES5, we could do anything we wanted and any wrong
    doing would be discovered in runtime. So at this point, we need to tell the compiler
    that this is OK. So, how do we do that? One way is that when we create our basket
    instance, we give it the type any like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'What we did here is actively give the variable basket the `any` type and thereby
    fight the TypeScript compilers urge to infer the type to be `FruitBasket`. By
    being of type any TypeScript has no idea of knowing whether what we have done
    to it is correct or not. Another way of essentially accomplishing the same effect
    is to type like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are doing a conversion on the fly with the `as`-operator and thereby
    we tell the compiler that this is OK.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the class decorator function signature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we might need to customize the way our decorator operates upon instancing
    it. No worries! We can design our decorators with custom signatures and then have
    them returning a function with the same signature we defined when designing class
    decorators with no parameters. As a rule of thumb, decorators taking parameters
    just require a function whose signature matches the parameters we want to configure.
    Such a function must return another function, whose signature matches that of
    the decorator we want to define.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following piece of code illustrates the same functionality as the previous
    example, but it allows developers to customize the greeting message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Property decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Property decorators are meant to be applied on class fields and can be easily
    defined by creating a `PropertyDecorator` function, whose signature takes two
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target**: This is the prototype of class we want to decorate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key**: This is the name of the property we want to decorate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible use cases for this specific type of decorator may encompass from logging
  prefs: []
  type: TYPE_NORMAL
- en: 'the value assigned to class fields when instancing objects of such a class
    and even reacting to data changes on such fields. Let''s see an actual example
    that encompasses both of these behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The same logic for parameterized class decorators applies here, although the
    signature of the returned function is slightly different in order to match that
    of the parameter-less decorator declaration we already saw.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example depicts how we can log changes on a given class property
    and trigger a custom function when this occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Method decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These special decorators can detect, log, and intervene in how methods are
    executed. To do so, we just need to define a `MethodDecorator` function whose
    payload takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target**: This is typed as an object and represents the method being decorated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key**: This is a string that gives the actual name of the method being decorated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Value**: This is a property descriptor of the given method. In fact, it''s
    a hash object containing, among other things, a property named value with a reference
    to the method itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how we can leverage the `MethodDecorator` function in an actual
    example. The syntax to this has changed in later TypeScript versions. The idea,
    however, is to intercept before and after the execution of the method. So, why
    would you want to do that? Well, there are a couple of interesting cases:'
  prefs: []
  type: TYPE_NORMAL
- en: You want to know more of how a method is called, what `args`, what were the
    results, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to know how long it took for a certain method to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a decorator for each of these cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are talking to the `descriptor.value`, which contains our actual function
    and as you can see, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a reference to the old method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We redefine the method by replacing what `descriptor.value` points to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside of our new function we execute the old method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We log to the console what args was used and what the result became
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So far, we have explained how to add logging information to a method, but there
    was another scenario we wanted to describe as well, namely measuring execution
    time. We can use a very similar approach to the previous one, but with some subtle
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We still do much of the same, but let''s summarize it in a few bullet points:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a reference to the old method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redefine `descriptor.value`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start a timer before method execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the timer after method execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that decorator functions are scoped within the class represented in
    the target parameter, so we can take advantage of that for augmenting the class
    with our own custom members. Be careful when doing this, since this might override
    the already existing members. For the sake of this example, we won't apply any
    due diligence over this, but handle this with care in your code in the future.
    Method decorators are quite a powerful thing, but do not use them all the time,
    but rather in cases like the previous where they shine.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our last round of decorators will cover the `ParameterDecorator` function,
    which taps into parameters located in function signatures. This sort of decorator
    is not intended to alter the parameter information or the function behavior, but
    to look into the parameter value and then perform operations elsewhere, such as,
    for argument''s sake, logging or replicating data. The `ParameterDecorator` function
    takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target**: This is the object prototype where the function, whose parameters
    are decorated, usually belongs to a class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key**: This is the name of the function whose signature contains the decorated
    parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameter index**: This is the index in the parameters array where this decorator
    has been applied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows a working example of a parameter decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: You have probably noticed the weird assignation of the `functionLogged` variable.
    This is because the value of the target parameter will vary depending on the function
    whose parameters are being decorated. Therefore, it is different if we decorate
    a constructor parameter or a method parameter. The former will return a reference
    to the class prototype and the latter will just return the constructor function.
    The same applies for the key parameter, which will be undefined when decorating
    the constructor parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the beginning of this section, parameter decorators are not
    meant to modify the value of the parameters decorated or alter the behavior of
    the methods or constructors where these parameters live. Their purpose is usually
    to log or prepare the container object for implementing additional layers of abstraction
    or functionality through higher-level decorators, such as method or class decorators.
    Usual case scenarios for this encompass logging component behavior or managing
    dependency injection, as we will see in [Chapter 5](3df2cad2-baa6-4076-a6ab-d84247af7817.xhtml),
    *Enhancing Our Components with Pipes and Directives*.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing our applications with modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our applications scale and grow in size, there will be a time when we will
    need to better organize our code to make it sustainable and more reusable. Modules
    are the response for this need, so let's take a look at how they work and how
    we can implement them in our application. Modules can be either internal or external.
    In this book, we will mostly focus on external modules, but it is a good idea
    to overview the two types now.
  prefs: []
  type: TYPE_NORMAL
- en: Internal modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a nutshell, internal modules are singleton wrappers containing a range of
    classes, functions, objects, or variables that are scoped internally, away from
    the global or outer scope. We can publicly expose the contents of a module by
    prefixing the keyword `export` to the element we want to be accessible from the
    outside, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Greetings` module contains two classes that will be accessible from outside
    the module by importing the module and accessing the class we want to use by its
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'After looking at the preceding code, we can conclude that internal modules
    are a good way to group and encapsulate elements in a namespace context. We can
    even split our modules into several files, as long as the module declaration keeps
    the same name across these files. In order to do so, we will want to reference
    the different files where we have scattered objects belonging to this module with
    reference tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The major drawback of internal modules though is that in order to put them
    to work outside the domain of our IDE, we need to have all of them in the same
    file or application scope. We can include all the generated JavaScript files as
    script inserts in our web pages, leverage task runners such as Grunt or Gulp for
    that, or even use the `--outFile` flag in the TypeScript compiler to have all
    the `.ts` files found in your workspace compiled into a single bundle using a
    bootstrap file with reference tags to all the other modules as the starting point
    for our compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This will compile all the TypeScript files following the trail of dependent
    files referenced with reference tags. If we forget to reference any file this
    way, it will not be included in the final build file, so another option is to
    enlist all the files containing standalone modules in the compiling command or
    just add a `.txt` file containing a comprehensive list of the modules to bundle.
    Alternatively, we can just use external modules instead.
  prefs: []
  type: TYPE_NORMAL
- en: External modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'External modules are pretty much the solution we need when it comes to building
    applications designed to grow. Basically, each external module works at a file
    level, where each file is the module itself and the module name will match the
    filename without the .js extension. We do not use the module keyword anymore and
    each member marked with the export prefix will become part of the external module
    API. The internal module depicted in the previous example would turn into this
    once conveniently saved in the `Greetings.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Importing this module and using its exported classes would require the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the require function is not supported by traditional JavaScript,
    so we need to instruct the compiler about how we want that functionality to be
    implemented in our target JavaScript files. Fortunately, the TypeScript compiler
    includes the `--module` parameter in its API, so we can configure the dependency
    loader of choice for our project: `commonjs` for node-style imports, `amd` for RequireJS-based
    imports, `umd` for a loader implementing the Universal Module Definition specification,
    or system for SystemJS-based imports. We will focus on the SystemJS module loader
    throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The resulting file will be properly shimmed, so modules can load dependencies
    across files using our module loader of choice.
  prefs: []
  type: TYPE_NORMAL
- en: ES6 like modules per TypeScript > 1.5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The way you will be using modules in your Angular projects is by using external
    modules with ES6 syntax, so let''s go through the basics of what that means. As
    mentioned before in this section, there is one file per module and we can export
    it by using the export keyword. How you consume dependencies, however, differs
    syntactically; let''s illustrate this by creating an ES6 module `service.ts` and
    another module `consumer.ts`, which is meant to consume the former:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Two things to notice here is in the `consumer.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Importing with curly brackets `{}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the from keyword to find our file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The curly bracket `{}` gives us the opportunity to pick and choose what construct
    we actually want to import. Imagine if `service.ts` was more complicated like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'As a consumer, we could now choose to import `Service` and/or `PI` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'It is however possible to use an alternate syntax to export your constructs.
    So far, we have been typing `export` for each thing we wanted to export; we could
    type it like this instead in the third installment of our `service.ts` called
    `service-v3.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The third way of doing exports is default `export`. There is such a thing as
    a `default` keyword, which means we don''t have to use the curly braces `{}` when
    importing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was definitely a long read, but this introduction to TypeScript was absolutely
    necessary in order to understand the logic behind many of the most brilliant parts
    of Angular. It gave us the chance to not only introduce the language syntax, but
    also explain the rationale behind its success as the syntax of choice for building
    the Angular framework. We reviewed its type architecture and how we can create
    advanced business logic designing functions with a wide range of alternatives
    for parameterized signatures, and we even discovered how to bypass issues related
    to scope by using the powerful new arrow functions. Probably the most relevant
    part of this chapter encompassed the overview of classes, methods, properties,
    and accessors and how we can handle inheritance and better application design
    through interfaces. Modules and decorators were some other major features explored
    in this chapter and, as we will see very soon, having a sound knowledge of these
    mechanisms is paramount to understand how dependency injection works in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: With all this knowledge at our disposal, we can now resume our investigation
    of Angular and confront the relevant parts of component creation, such as style
    encapsulation, output formatting, and so on with confidence. [Chapter 4](41335dde-9066-4998-a0a9-3c42f97cdd9e.xhtml),
    *Implementing Properties and Events in Our Components*, will expose us to advanced
    template creation techniques, data-binding techniques, directives, and pipes.
    All these features will allow us to put into practice all this newly gained knowledge
    of TypeScript.
  prefs: []
  type: TYPE_NORMAL
