- en: Learning About Curses by Building a Snake Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever any developer writes games or applications, it is likely that they
    need to reuse some parts of the code repeatedly. For example, when we want a player
    to move within the game console, they use the left and right arrow keys multiple
    times. Thus, we need the code that can handle such events and process them. Writing
    the same code multiple times to handle the same action does not support **don't
    repeat yourself** (**DRY**) principles, so we need to use functions that can be
    called multiple times to perform the same action time and again.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate this, these functions are bundled into containers known as modules.
    As you may recall from the preceding chapter, we have used modules in most of
    our programs. For example, by using the `random` module functions, we were able
    to get a random number between the specific range; math modules, on the other
    hand, allowed us to perform different mathematical computations. In this chapter,
    we are going to cover another module, known as curses. It will provide us with
    an interface where we can handle the curses library, which contains functions
    that directly interact with the Python terminal. This means we can make a simple
    Terminal-based game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding curses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the curses application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User input with curses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a Snake game with curses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will require the following to get the full benefit of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python** **IDLE** (**integrated development kit**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code assets for this book, which can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2oG1CVO](http://bit.ly/2oG1CVO)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding curses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Curses is a Terminal controller library that allows us to write text-based applications.
    The word Terminal is independent to any platform, and so curses can be used on
    any operating system. With curses, developers will be able to write applications
    directly without interacting with the Terminals. The curses library is the medium
    that sends the commands in the form of control characters while determining the
    operating system or Terminal it should be executed on.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we have two libraries called windows-curses and unicurses. Both of
    these libraries provide the functions that can set up the desired look for the
    output Terminal screen. They are updated using control sequences. In short, developers
    will design the appearance of the output window screen and call the functions
    to make curses do its work. Thus, in curses-based applications, we won't get output
    that's a user-friendly as we expect it to be because we will be only able to write
    text-based applications with the curses library. Thus, any game you write with
    curses will run in the Terminal, that is, the command prompt of Windows or the
    Terminal of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Python's *curses* library will allow us to write text-based user interfaces
    and control the screen with user inputs. The library that we are using in this
    chapter will help us control the screen movements and handle user events or inputs.
    The programs that will be built from curses will not have features that will resemble
    modern GUI applications or Android applications, which have widgets such as text
    view, label, slider, graphs, and templates. Instead, it will provide simple widgets
    and tools such as the **command-line interface** (**CLI**), most of which are
    found in text-only applications.
  prefs: []
  type: TYPE_NORMAL
- en: The curses module of Python is an adaptation of the curses of the C-programming
    language. The only difference is using Python; everything can be done without
    us having deep knowledge of low-level routines. We can call the interfaces to
    invoke functions that will, in turn, call the curses to handle user operations.
  prefs: []
  type: TYPE_NORMAL
- en: While dealing with curses, the window screen is considered a character matrix.
    Each window interface is set up by the programmers, and includes height, width,
    and border. After setting such coordinates, the programmer will invoke Python
    curses to update that screen. Working with widgets such as the text view, button,
    and label is also done in the same manner; that is, we will initialize the coordinates
    where it should be placed in the window and call curses to update it accordingly.
    To handle user input from curses, we have to import it. We can easily import actions
    such as RIGHT, LEFT, UP, and DOWN and handle their behavior according to the program's
    needs. In most games, these events are going to provide movement to the game characters.
    The game we are going to cover at the end of this chapter will be the Snake game,
    and the snake itself will be our main character. This means that actions such
    as LEFT, RIGHT, UP, and DOWN will move the snake to a new position. The Windows
    version of Python does not have an inbuilt curses module and is not available
    with the same name. However, there's are two compatible modules available that
    do the same thing. These are called unicurses and windows-curses. We are going
    to use the latter in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start learning about curses by making a simple application. We will make
    a simple `hello` program that's printed in the curses Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the curses application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to build the application using a module that does not come pre-packaged
    with Python. Therefore, we have to install that package manually on our machine.
    With the installation of Python, a package management system should have been
    installed automatically on your machine known as pip. This management tool is
    used to install and organize the libraries that are written with Python. Thus,
    if you want to use any third-party libraries or dependencies on your program,
    you have to install them using the pip tool. The method to install any package
    is simple. You simply have to write the `pip install` command, followed by the
    name of the library you wish to install. The name of the library is case-sensitive,
    and so no mistakes should be made while writing the name of the library. If you
    want to check the code that is written inside the library, simply search for the
    documentation of that library. You will get information about the library, as
    well as the functions that are available to be used inside your programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the windows-curses library to write text-based programs,
    and so we have to install that package using the `pip` command. The pip command
    should be executed in the command prompt if your machine is Windows, and in the
    Terminal of your machine if you''re using Mac OS X or Linux. The following screenshot
    shows how we need to execute the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16064870-3492-408d-8aae-cd282362fb42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, to install curses in your Linux machine, you can open your Terminal
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will be able to write programs using the curses module. At this point,
    the curses module that we have installed will be available in the same way that
    other built-in modules such as math or random and available. Similar to built-in
    modules, we can simply import the curses module and start invoking the functions
    that are defined within it. The following steps explain the roadmap for creating
    any curses applications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing curses and seeing if it was installed properly or
    not. The command we use to import any module is `import` followed by the module''s
    name. Our module name is curses. Thus, the command would be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can conclude that it is imported successfully as the Python parser hasn''t
    thrown an error. Now, we can use this module to write programs. Let''s write a
    simple program to observe the working procedure of the curses module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We cannot run any curses applications directly from Python IDLE. To run it,
    you have to navigate to the folder where you have stored the Python file and double-click
    on that file to open it. You will get a blank screen with a cursor at the top,
    which will remain there for 10 seconds. After 10 seconds, the same blank window
    screen will pop out from the screen. That screen will yield the text-based application
    that can be written with curses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our preceding code and uncover the interesting functions of
    curses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, as always, we imported the module that we wanted to use in our
    program. We imported two modules here: curses and time. The curses module has
    different functions available for us which can be used to write text-based applications,
    while the time module has different functions available that can be used to update
    our output screen behavior. In this program, we called the `sleep` method of the
    `time` module, which will hold the output of the screen for the amount of time
    that was passed within its parenthesis (10 seconds, in our case). After 10 seconds,
    our output screen will disappear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before writing any code with curses, it should be initialized. The invocation
    of the `initscr()` function is going to initialize curses. Thus, for any curses
    application, we should initialize curses at the first line of the code. This initialization
    code is going to return us a window object that represents the output screen of
    our program. Here, this initialization is captured by the window object named
    `window_screen`, which represents the screen of our output Terminal. Thus, any
    function call to the curses API should be done with `window_screen`. The first
    invocation is done with the `clear()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We successfully created a game screen and held it with a method call. However,
    the current screen is not modifiable enough. We, as programmers, may want to customize
    the screen by specifying the height and width explicitly. Fortunately, Python's
    curses module provides another method to accomplish this, that is, the `newwin`
    method. We will learn about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: New screen and window objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The window object that's returned from the invocation of the `initscr()` function
    represents the entire screen of the output window. This window object also supports
    different methods that can display text to the window, alter it, take events from
    the user and update positions, and so on. The only demerit with this `initscr()`
    function is that we cannot a pass custom height or width of the screen to it.
    It only represents the default whole screen of the output Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we might want the screen of the game to be customized so that it
    has a height of 20 and a width of 60, for example. Here, height and width can
    be considered as column and row, where each unit represents a line within that
    matrix. Since we have passed a width of 60, there will be 60 horizontal lines.
    The same goes for our height of 20; there will be 20 vertical lines. You can represent
    them as pixels too. To create a new screen, which is probably what we are going
    to do while making a curses application since the `initscr()` function isn''t
    going to do this for us, we have to call the new function. This function is going
    to divide the bigger window screen into a new one based on the coordinates specified.
    The name of this function is `newwin()`, which literally means new window, and
    it takes four arguments, that is, **Height**, **Width**, **Y**, and **X.** The
    order these are passed in is **Y**, **X** which is unusual compared to other libraries.
    The **Y** value is for the column''s position while the **X** value is for the
    row''s position. Take a look at the following diagram, which explains the values
    of **Y** and **X**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1df0dbbc-8aca-4b5e-93bc-0e9e14718431.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, by increasing the value of **Y**, we are going downward, which is the
    same as the column in a matrix. Similarly, by increasing the value of **X**, we
    are toward the right-hand side of the screen, which is the same as the row in
    a matrix. As we can see, curses stores a window screen in the form of the character
    matrix. We can use those coordinates to represent the position of the game's display,
    as well as the game characters. For example, if you want to make your player move
    in the position of (5,0), as shown in the preceding diagram, you would call the
    `move(5,0)` function to achieve that. Remember the order in which the argument
    is passed. The value of **Y** is followed by **X**, which may confuse you if you
    have a background in game programming from any other library.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we are going to create a program where we will make a new screen
    inside a big screen using the `newwin()` function. The four arguments inside this
    function are `height`, `width`, `y`, and `x`. Remember this order as we have to
    pass it in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time to write a simple program that can add some text to our curses
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s observe the preceding code line by line and learn about each of the
    methods we used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we imported the two important modules: curses and time. After
    that, we initialized the window object with the `initscr()` function. The `noecho()` function
    will turn off the automatic echoing process in our application. This is essential
    because while the user is playing the game, we don''t want them to show us what
    they pressed; instead, we want them to perform an action based on that event.
    The next function call is `cbreak()`. This mode will help our program react instantly
    to the user''s input. For example, in the case of the `input()` method of Python,
    until and unless we are going to press *Enter* on our keyboard, this method won''t
    perform any action. However, in the case of the `cbreak()` function, it is going
    to help the application react to any input keys instantly without the need for
    pressing *Enter*. This is important because we have to make a game where the user
    will get a response without any delay. For example, if the user presses the DOWN
    key, the character of the game must move in downward instantly. This is different
    to a buffered input function, which is going to take all the input and store it
    in a buffer that''s going to react only if the user presses *Enter*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next function call is the `keypad()` function. We have enabled keypad mode
    by passing True as an argument. Whenever we press any key in the Terminal, it
    returns data in the form of a multibyte escape sequence. For example, `Esc` sends
    `\x1b`. That is 1 byte. `Page Up` sends `\x1b[H`. That is 3 bytes. To handle such
    data that is returned by the Terminal, curses uses a special value that can be
    imported manually. For example, to handle the DOWN key being pressed on the keyboard,
    we can import it as `curses.KEY_DOWN`. This is done by enabling keypad mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we called the `addstr()` function. This function will add a string
    to the output screen in the position specified during its call. We passed three
    arguments to it. Remember that the first two arguments are in the order y, x.
    The last argument that's passed is a string that needs to be added to the position
    of (y,x). We have passed a value of (0,0), which means the string will be added
    to the uppermost left corner of the output window. The next method that we called
    was `refresh()`, which is going to update the character matrix of the window object
    *screen*. If you take a look at the code carefully, you will see that whenever
    we are adding or refreshing the content of the screen, we are doing it using a
    window curses object, which was initialized using the `initscr()` function. However,
    the behavior of the Terminal has been altered by the curses module. For example,
    to change the default echoing behavior of the Terminal, we made a direct call
    to the `noecho()` function from the curses module instead of from the window cursor
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s run our code to observe the result. Make sure you run your application
    from your Terminal or command prompt with `filename.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f76bd343-3e09-41ef-8a3e-956e4c65c004.png)'
  prefs: []
  type: TYPE_IMG
- en: You can change the position from (0,0) to any other value, for example, (5,5),
    to observe the windows and padding format.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have made our first program with curses. Now, it's time to explore
    another feature of curses, which is based on the ability to handle user input.
  prefs: []
  type: TYPE_NORMAL
- en: User input with curses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any game, user input is one of the most crucial pieces of information that
    needs to be handled properly. We cannot make any delay while handling these types
    of actions. In the case of curses, we have two ways to take input from the user.
    These two methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getch()`: If you have any programming background of languages such as C or
    C++, this should not be new to you. The `getch()` function, just like in C, is
    used to make a listener that will listen to the user key continuously. It returns
    an integer from 0 to 255 which represents the ASCII code of the key that was pressed.
    For example, the ASCII code for `a` is `097`. Values that are greater than 255
    are special keys, for example, the *Page Up* and navigation keys, that is, UP,
    DOWN, LEFT, and RIGHT. We can compare the values of such keys with constants stored
    in curses; for example, `curses.UP`, `curses.DOWN`, `curses.LEFT`, and `curses.RIGHT`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getkey()`: `getch` and `getkey` do the same thing, but the `getkey` function
    converts the returned integer into a string. Normal keys such as a-z or A-Z will
    be returned as a 1 character string that can be compared with the `ord()` function.
    However, special keys or functional keys will be returned as a longer string containing
    a key and representing the type of action, such as `KEY_UP`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write a program that can handle keyboard events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We discussed this code when we talked about using a True loop. Make sure you
    revise the preceding topics if you are confused about any of these commands. One
    strange thing you might observe in this code is that we have imported curses and
    gave it an alias of c. This is the process of renaming your module. Now, instead
    of using `curses.method_name` at every method call, we can simply call it using `c.method_name()`,
    which certainly removes the overhead of writing the same module name every time.
    Inside the loop, we used the `getch()` function to take input from the user. After
    that, the character is retrieved in the `char` variable and we compare it with
    the returned value of the `ord` function. Remember that the `getch` function was
    going to return a value in Unicode? The same is done by the `ord` function. It
    takes an argument as a character and returns the Unicode value of that character.
    We use conditionals to make a condition. So, if the user presses *q* on their
    keyboard, we will end the program, and if the user presses *p* on their keyboard,
    we will print `Hello World` to the output window at the position of (y,x). Let''s
    run our Python file, `C:\User\Desktop> python program3.py`, and take a look at
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/935843ba-c5f4-4c19-96c2-0b28b7fe7a6e.png)'
  prefs: []
  type: TYPE_IMG
- en: Press *q* on your keyboard to terminate the loop and close the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note that *q* is not the same as *Q* because the ASCII code for these characters
    isn't the same.
  prefs: []
  type: TYPE_NORMAL
- en: Our code is running perfectly but is becoming lengthier, even though the application
    is so simple. We are calling so many methods already, such as `noecho()`, `cbreak()`,
    `keypad()`, and `endwin()`. To remove the overhead of calling so many functions,
    we can use the wrapper function from the curses module. All of these functions,
    including the initialization of curses objects, is done automatically by the wrapper
    function. Just remember that the wrapper function as a call to the bundle that
    wraps all of these methods inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can also handle mouse events using the curses module. Let''s
    make a program using the wrapper function and handle the events of the mouse buttons
    in the same program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start from the last line, where we called the wrapper function with
    some callable object as an argument. We've already learned about the objectives
    of `wrapper()`; it eliminates multiple function calls such as `initscr()`, `noecho()`,
    and so on. Thus, debugging is easier using the wrapper function. Not only that,
    but this function also handles exceptions internally by using try and catch blocks.
    Whenever you run into an unknown exception that you might not have caught, you
    can always trust the wrapper function to do so. This will identify the bugs of
    your program and provide you with an exception message without crashing the application.
    The argument to the wrapper function will be a callable object, which, in this
    case, is the main function. This main function has a *screen* argument, which
    is the curses window object. We didn't initialize the curses object anywhere in
    the program with the `initscr()` function because this was done internally by
    the wrapper function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the scope of the main function, we made a call to two methods: `curs_set(0)`,
    which is going to hide the cursor in the output screen, and `mousemask(1)`, which
    is going to accept the mouse events. Here, mouse events will be special symbols
    or functional characters that will be different from normal alphabetical characters.
    Thus, curses has made constants to address those functional characters. This is
    the same for the UP keyboard key; we have the `KEY_UP` constant; in the case of
    mouse events, we have the `KEY_MOUSE` constant. These should be invoked from the
    curses module, for example, `curses.KEY_MOUSE`. After we get such mouse events,
    we are going to print `Mouse is clicked` to the output Terminal. The `getch()`
    method is going to input any events that can be either mouse-related or keyboard
    buttons. Let''s run our program to achieve the following output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/29bbc122-b640-411f-a973-606a7ff98269.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have gained enough knowledge to make games using curses, let's proceed
    to the next section, which will give us an idea about how gaming logic is made
    under the hood. We will be making a simple Snake game.
  prefs: []
  type: TYPE_NORMAL
- en: Making a snake game with curses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that the process of writing games is not as easy as it seems.
    We have to follow many procedures to make a game playable because, while exposing
    the game to the environment, we can be overwhelmed by many unwanted and unexpected
    exceptions. Thus, following the proper order of execution is always essential,
    even if it may take more time than usual. In this section, we are going to create
    a Sake game using curses. We will be modifying it into a more appealing game in
    the upcoming chapters. A good game does not always mean a good user interface
    because the interface provides value to the user but not the programmer. We have
    to make a habit of writing proper code along with making good interfaces, which
    requires us to follow each of the steps we will go over in this section. We are
    going to use the curses module to make the initial Snake game. Then, in the next
    chapter, we will modify it using object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: Before we code, we have to gather information about the model and the interface
    of the game. While modeling, we have to extract critical information, such as *how
    to render the game characters into the screen*, *how to make an event listener*,
    and *how to make logic that will allow the game characters to move*. We will cover
    all of this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Brainstorming and information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have been doing up until now, the first step is to brainstorm and gather
    critical information about the game layouts and game models. In the Snake game,
    we have two characters: the snake (the player) and its food. Whenever the snake
    eats food, its length should be increased. That''s the basic idea, anyway. Now,
    let''s revise the resources that are available to us. Obviously, the resources
    that are provided by Python are more abundant, but we haven''t learned how to
    make graphical characters and use them in our game yet. All we''ve learned to
    do is make games with text-based Terminals. We can use characters such as A-Z
    to specify game objects. For example, we can make the snake `XXXXXXX`, which is
    a combination of Xs. The food can be represented by `O`. Let''s see what this
    would look like in our game console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a3df7678-7e01-4124-bec7-1a9f24c72335.png)'
  prefs: []
  type: TYPE_IMG
- en: We also have to decide on the screen for the game. The `initscr()` method is
    going to create the entire screen as a curses object. We don't want that; instead,
    we want to make a game screen that can be customized by the height, width, and
    y, x positions. As you may recall, we can divide the screen into a new one, using
    the `newwin()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to remember is to track the coordinates because we
    have to make a boundary for our gameplay. We can make certain rules that specify
    the boundary position of the game character and, if they touch that boundary,
    we can terminate our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to make logic for two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the snake eats the food, we have to generate new food in a new position.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the snake eats the food, we have to increase the speed of the snake
    to make the game more difficult. We should also track collisions between the snake's
    head and its body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In terms of the former point, we can use the random module, which provides a
    random coordinate position of (y, x) that we can assign food to. For the latter
    point, we have to use a curses method called timeout. We have to pass the value
    of the delay as an argument to that function. According to Python's official documentation,
    the timeout function sets blocking or non-blocking read behavior for the window.
    If *delay* is negative, a blocking read is used (which will wait indefinitely
    for the input). If *delay* is zero, then a non-blocking read is used, and -1 will
    be returned by `getch()` if no input is waiting. If *delay* is positive, then
    `getch()` will block for *delay* milliseconds and return -1 if there is still
    no input at the end of that time. Thus, we can change the speed of the game based
    on the delay when it is zero or positive.
  prefs: []
  type: TYPE_NORMAL
- en: So, in terms of the `curses.timeout(delay)` command, if you make delay negative,
    your snake will move at a rapid pace. However, we need to remember that we have
    some constraints here; the speed of the snake should be increased, along with
    the length of the snake. First of all, what is a snake? How it is made in our
    game? We learned about lists in the previous chapter. Let's use that to make a
    snake. We have already seen the structure of our snake, which is a bunch of X
    characters. But at the beginning of the game, we should only provide a small length
    for the snake, maybe a length of 3, that is, `XXX`. We will store each of these
    X's in the list, which represents coordinates such as [[4,10], [4,9], [4,8]].
    Here, each of these lists represents one X, that is, at the position of [4,10],
    we will have one X and another X at 4,9\. Remember that these should be y, x positions
    and that they should be next to each other because they represent the body of
    the snake.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say our delay is 100 which would be constant. Thus, our command to represent
    speed will be `curses.timeout(100)`, which will be the snake's constant speed
    throughout the game. However, we can change the speed of the game by incrementing
    the length of the snake. For now, let's proceed to the next section, where we
    will make a boundary for our game.
  prefs: []
  type: TYPE_NORMAL
- en: Inception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will start writing the code for our game. We will use the
    curses module to do this. First, we will initialize the screen for the game and
    make some game characters. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new in the preceding code. You can also eliminate all of the
    function calls using the `wrapper()` function. We can see that we have two list
    variables, `snake` and `food`, which contain the coordinates that represent their
    positions in our game console. We also made a call to the `addch` function. It
    will work in a similar fashion to the `addstr` function. We passed the position
    of the food and added the `O` character to that position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making computer games require two steps: the first step is to make a visual
    that must be naturally attractive, while the second step is to make the player
    interact with the game. To make games interactive, we have to handle the events
    provided by the player. This is what we will do in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling user key events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve started to build the basic layout of our game. Now, let''s write some
    code that can handle user keyboard events. Snake is a simple game. We can make
    it work by handling only four keys of the keyboard, that is, UP, DOWN, LEFT, and
    RIGHT. We can use `getch()` to get user input. But remember, these are not alphabetical
    characters, they are functional characters. Thus, we have to import constants
    such as `KEY_UP`, `KEY_DOWN`, `KEY_LEFT`, and `KEY_RIGHT` to fetch those ASCII
    values. Let''s start writing the code that will handle user events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that we have written may seem complicated, but all of these things
    have been covered already. Let''s take a look at what we''ve done:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first statement, we made the default key `KEY_RIGHT`. This is important
    because we don't want to make the snake move if the user hasn't pressed a key.
    So, our snake character will move right automatically when the game is started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we made a game loop. This loop is going to be executed until we
    press *Esc* since the ASCII value for *Esc* is 27\. Inside the loop, we made a
    call to the timeout method, which will represent the speed of our snake character.
    In the next line, we get the event of the user using the `getch()` method. Remember
    that, if you press any key event, its value is going to be -1\. Thus, we can compare
    it and put the key that was pressed by the user into the key variable. However,
    the key can be anything, such as an alphabetical character or a special symbol
    such as [!,@,#,$], and so we have to filter them with the appropriate keys, for
    example, LEFT, RIGHT, UP, and DOWN. If the key that's pressed by the user is not
    among these, we are going to make the key have a default value of `KEY_RIGHT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can communicate our program with input devices such as a keyboard or
    joystick. It's time to move on to the next section, where we will create our first
    logic to update the **head position** of the snake characters when the user presses
    the LEFT, RIGHT, UP, and DOWN keys.
  prefs: []
  type: TYPE_NORMAL
- en: Game logic – updating the head position of the snake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we were able to handle user events using constants
    provided by curses. Just like movement, the head of the snake can also be changed.
    We have to make brand new logic that will update the position of the snake''s
    head. Our snake is a composition of coordinates that are stored in the list. The
    first element of that nested list is the position of the snake''s head. Thus,
    we only need to update the first element of the list. Let''s see how we are going
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This may seem like it's a little difficult to understand, so let me make this
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `snake` variable is a list. Thus, we can use the `insert()` method to manipulate
    that list element. The `insert()` method will take two arguments: one will be
    the index and the other will be the element to be inserted. In the preceding code,
    index is 0, which means we want to insert an element in the first element of the
    list, which represents the head of the snake. The next argument is the element,
    which needs to be added to index 0\. We can see a comma (`,`) in-between two statements:
    `snake[0][0] + (key == KEY_DOWN and 1) + (key == KEY_UP and -1)` and `snake[0][1]
    + (key == KEY_LEFT and -1) + (key == KEY_RIGHT and 1)`. The first statement represents
    the y coordinate of the snake''s head, while the second statements represents
    the x coordinate of the snake''s head. In the y part of the snake''s head, which
    can be represented as a column, we can have two movements: either DOWN or UP.
    While going down, we have to add 1 to the current head position y element and
    while going up, we have to decrease 1 in the current y position. For the x part
    of the snake''s head, we have the LEFT and RIGHT movements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On pressing the LEFT key, we are going to decrease the coordinate of x with
    1 and on pressing the RIGHT key, we are going to add 1 to x. Still confused? Taking
    a look at the following diagram should make things clearer for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/20279a9a-0c1a-41ba-a180-c0b02331e9f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that this update has to be done in the order of (y,x). For every **UP**
    and **DOWN** key that's pressed, a decrement or increment of 1 is done in the
    coordinate of y, which is snake[0][0] for the head. For x, this is snake[0][1],
    which is the same increment and decrement that we used previously, but for when
    the user presses the **RIGHT** and **LEFT** keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have made some logic to update the position of the snake, we need
    to make the snake eat the food. The logic we are going to cover is simple: when
    the snake''s head position is the same as the food''s position, we can say that
    the snake ate the food. Let''s go over this now.'
  prefs: []
  type: TYPE_NORMAL
- en: Game logic – when the snakes eats the food
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make the next bit of logic for our game. In this section, we are going
    to make the snake eat the food. This is quite simple to implement. Whenever the
    snake''s head touches the food, we will assume that the snake has eaten the food.
    Thus, the snake''s head coordinates and the food''s coordinates will be the same.
    We also have to make some logic that will generate food in the next location as
    soon as the snake eats the current piece of food. The location for the next piece
    of food should be random. We can use the `random` module to create such an arbitrary
    location. Let''s start writing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a new way of importing any function from the module. While calling
    this function, we don''t have to write something like `random.randint()`. Instead,
    we can call it directly in our program. The arguments inside the `randint()` method
    must be the range of values. For example, `randint(2,8)` returns a number between
    2 to 8, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Inside the if part of the code, we have added the logic that will put the food
    in a new position. Remember that, at the beginning of the game, we initialized
    the new window height to be 20 and the width to be 60\. Thus, we can only generate
    food within this boundary. In the else part of the code, we pop out the last element
    if the user is unable to eat the food. In the second to last line, we added the
    snake's head position with the `'X'` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our game and see what it looks like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b1eacf8b-662a-45a1-883f-f68146d1edf9.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, our game is playable enough. We learned about so many things while making
    this game, such as how to make game logic while working with the methods and coordinates
    of the game console. Now, let's proceed to the next section, where we will learn
    how to test and modify our game.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing and modification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To uncover the deficit of any program, its always a good idea to run and test
    it. Just like our previous games, we can also make modifications to the Snake
    game. The following points explain some of the modifications we could make to
    our game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the game, the first thing you will notice is that our game does
    not have logic to decide whether the snake has collided with itself or not. If
    it does collide with another part of its body, we have to stop the game. Let''s
    add that logic inside the while loop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, snake[0] represents the head of the snake while snake[1:]
    represents the body of the snake. Thus, the preceding condition means that the
    head coordinates are inside the body of the snake, which means a collision occurred.
    In this case, we use a `break` statement to get out of the loop and terminate
    the game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say we want to add the score of the player. Adding a score is simple;
    the number of food that has been eaten by the snake is equivalent to the player''s
    score. We can initialize the value of the score as 0 to start with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have added some statements with the `addstr` method
    that will provide the score of the player at the specified position. Now, let''s
    run our game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9358081e-0e9b-4242-ab0e-0e7a30cc3cd5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After running the game, you can see that we are able to play within the interface
    of curses. However, you will encounter an exception as soon as your snake hits
    the boundary line, and your game will be terminated automatically. We will learn
    how to handle boundary collisions in the upcoming chapters in detail (to be specific, [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*), but, for now, let''s learn about the easiest method we can use
    to handle and get rid of triggering an exception. First of all, observe the dimension
    of the boundary screen and take note of the actual height and width at which the
    boundary resides. Consider looking at the `win` variable to get an idea about
    the size of the boundary screen. Now, looking at the height of 20, we might assume
    that whenever the snake touches the top boundary, that is, he head position of
    the snake at 0, the snake''s head must enter through the own boundary, which has
    a y coordinate of 19\. Remember that, in the upper and lower boundaries, only
    the y-coordinate changes. The code for this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we have to address the case where the snake hits either the right
    or left boundary. Since the height remains the same for either case, we are only
    interested in the width (x-position). Since the width of the screen that''s declared
    by the win variable is 60, we can expect the snake hitting a boundary at around
    0 (for the right) and 59 (for the left) to cause the snake to be regenerated accordingly.
    You have to add the following line of code to handle collisions that occur at
    the left and right boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have completed the snake game. It is appealing enough to make any
    user play this game. We also learned how to create programs with our own brand
    new logic. This was the first simple module we have used to make text-based games.
    Even though it''s playable, we haven''t added any graphics to it, and so it looks
    quite bland. We will make it more scintillating by learning about a new Python
    paradigm named Object Oriented Programming. We have successfully made some modifications
    to our game. Now, it''s time to learn about the most important concept of Python:
    object-oriented programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started to uncover the world of game programming with curses.
    Obviously, it wasn''t the perfect game as it had no amazing animations or a fantastic
    interface. We barely touched on these topics since curses provides applications
    that are text-based and run on a plain Terminal. Even the game characters, such
    as snake and food for the Snake game were made out of alphabetical letters. Even
    though we didn''t put extra effort in to make the game more appealing, we have
    learned about how to make the game logic. Two of the pieces of logic that we made
    in the Snake game were important: the first was the interaction of the coordinates
    of the game console with the player''s positions, and the second was making the
    characters collide. The coordinate system''s order that''s supported by curses
    was strange. In most libraries, such as pygame and pyopengl, we have a coordinate
    system represented in the order (x,y), but in curses, it''s (y,x). The collision
    between two characters is confirmed if they are in the same coordinate point (y,x).
    To do this, we have to check the collision between the snake''s head and its body.
    This logic might sound simple, but it will come in handy in the long run. For
    example, in upcoming games such as Flappy Bird or Angry Birds, we are going to
    check the collision between the characters with the same logic.'
  prefs: []
  type: TYPE_NORMAL
- en: The code that we've written for the Snake game is meticulous and thorough because
    the game was written with procedural programming in mind. In the next chapter,
    we will learn about the most important concept of Python, object-oriented programming,
    and modify our code accordingly, which will make our code more readable and reusable.
  prefs: []
  type: TYPE_NORMAL
