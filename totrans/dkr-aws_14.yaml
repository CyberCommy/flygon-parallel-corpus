- en: Fargate and ECS Service Discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have spent a considerable amount of time focused on
    building infrastructure that supports your ECS clusters, detailing how to build
    custom Amazon machine images for your ECS container instances and how to create
    EC2 Auto Scaling groups that can dynamically add or remove ECS container instances
    to your ECS cluster, with chapters dedicated to managing the life cycle and capacity
    of your clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine not having to worry about ECS clusters and ECS container instances.
    Imagine that somebody else managed them for you, to the extent that you didn't
    even really know they existed. For some use cases, having a strong level of control
    over hardware selection, storage configuration, security posture, and other infrastructure
    related concerns, is very important; by now, you should have a pretty strong understanding
    of exactly how ECS provides such capabilities. However, in many cases, having
    that level of control is not necessary, and being able to leverage a service that
    manages your ECS cluster patching, security configuration, capacity, and everything
    else, would be of significant benefit, lowering your operational overhead and
    allowing you to focus on delivering whatever it is your organization is striving
    to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that this is actually possible, thanks to a service called
    **AWS Fargate**, which was launched in December of 2017\. Fargate is a completely
    managed service, wherein you simply define ECS task definitions and ECS services,
    and then let Fargate take care of the rest of the ECS cluster and container instance
    management that you have become accustomed to in this book. In this chapter, you
    will learn how to deploy container applications using AWS Fargate, using the **infrastructure
    as code** (**IaC**) approach of CloudFormation that we have been adopting throughout
    this book. To make this chapter a little bit more interesting, we will add support
    for an AWS service called X-Ray, which provides distributed tracing for your applications
    running in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to use X-Ray with your container applications, you need to implement
    what is referred to as an X-Ray daemon, which is an application that collects
    tracing information from your container applications and publishes it to the X-Ray
    service. We will extend the todobackend application to capture tracing information
    for incoming requests, and will add an X-Ray daemon to your AWS environment by
    leveraging the AWS Fargate service, which will collect the tracing information
    and forward it to the X-Ray service.
  prefs: []
  type: TYPE_NORMAL
- en: As an added bonus, we will also implement a feature called ECS service discovery,
    which allows your container applications to be published and discovered automatically,
    using DNS. This feature is very useful for the X-Ray daemon, which is a UDP-based
    application that cannot be serviced by the various load balancing services that
    are available for frontending your TCP and HTTP-based applications. ECS includes
    built-in support for service discovery, taking care of service registration and
    de-registration as your ECS tasks start and stop, allowing you to creating highly
    available services that other applications can easily discover.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: When to use Fargate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding support for AWS X-Ray to applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an X-Ray daemon Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring ECS service discovery resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an ECS task definition for Fargate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring an ECS service for Fargate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and testing the X-Ray daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Administrator access to an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local AWS profile, configured as per the instructions in Chapter 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI version 1.15.71 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker 18.06 CE or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose 1.22 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Make 3.82 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter continues on from Chapter 13, so it requires that you have successfully
    completed all of the configuration tasks defined in Chapter 13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14)
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2Lyd9ft](http://bit.ly/2Lyd9ft)'
  prefs: []
  type: TYPE_NORMAL
- en: When to use Fargate?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the introduction to this chapter, AWS Fargate is a service that
    allows you to deploy your container-based applications, without requiring you
    to deploy any ECS container instances, auto-scaling groups, or any of the associated
    operational requirements that come with managing ECS cluster infrastructure. This
    positions AWS Fargate as a serverless technology that sits somewhere between running
    Functions as a Service using AWS Lambda and running your own infrastructure using
    traditional ECS clusters and ECS container instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Fargate is a great technology, it is important to understand that
    Fargate is very young (at least at the time of writing this book), and it does
    come with some limitations that may make it unsuitable for some use cases, outlined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Persistent Storage**: Fargate does not currently support persistent storage,
    so if your applications need to use persistent Docker volumes, you should use
    an alternative service, such as the traditional ECS service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pricing**: Pricing is always subject to change; however, the initial pricing
    set for Fargate is viewed as expensive by many, as compared to the regular EC2
    instance pricing that you get with ECS. For example, the smallest Fargate configuration that
    you can buy has 0.25v CPU and 512 MB of memory, and costs $14.25 USD per month.
    As a comparison, a t2.nano with 0.5v CPU and 512 MB of memory costs substantially
    less, at $4.75 USD (all prices are based upon `us-east-1 region`),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment Times**: So far, in my experience, the ECS tasks running on Fargate
    typically take longer to provision and deploy, which may affect the length of
    time your application deployments take (this will also affect auto scaling actions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and Control**: With Fargate, you don''t get to control anything
    about the underlying hardware or instances that are running your containers. If
    you have strict security and/or compliance requirements, then Fargate may not
    offer you the assurances or necessary controls to meet your specific requirements.
    It is important to note, however, that Fargate is listed by AWS as both HIPAA
    and PCI Level 1 DSS compliant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Isolation:** At the time of writing this book, Fargate does not support
    the use of an HTTP proxy for ECS agent and CloudWatch logs communication. This
    requires you to either place your Fargate tasks in a public subnet with internet
    connectivity, or in a private subnet with a NAT gateway, similar to the approach
    you learned about in the chapter *Isolating Network Access*. To allow access to
    the public AWS API endpoints, this does require you to open up outgoing web access,
    which may violate the security requirements of your organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Availability**: At the time of writing this book, Fargate is only
    available in the US East (Virginia), US East (Ohio), US West (Oregon), and EU
    (Ireland) regions; however, I would expect Fargate to become widely available
    across most regions reasonably quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you can live with the current limitations of Fargate, then Fargate will significantly
    reduce your operational overheads and make life simpler for you. For example,
    when it comes to auto-scaling, you can simply auto-scale your ECS services using
    the application auto-scaling approach that we discussed toward the end of the
    *ECS Auto-Scaling* chapter, and Fargate will take care of ensuring that there
    is sufficient cluster capacity. Similarly, you won't need to worry about the patching
    and life cycle management of your ECS clusters - Fargate takes care of all of
    the above for you.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be deploying an AWS X-Ray daemon service to support
    application tracing for the todobackend application. This type of service is well-suited
    to Fargate, given it is a background service that does not require persistent
    storage, does not affect the availability of the todobackend application (if it
    goes down), and does not process end user data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for AWS X-Ray to applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can use the AWS X-Ray service, your applications need to support collecting
    and publishing tracing information to the X-Ray service. The X-Ray **software
    development kit (SDK)** includes support for a variety of programming languages
    and popular application frameworks, including Python and Django, which both power
    the todobackend application.
  prefs: []
  type: TYPE_NORMAL
- en: You can locate the appropriate SDK documentation for your language of choice
    at [https://aws.amazon.com/documentation/xray/](https://aws.amazon.com/documentation/xray/),
    but for our use case, [https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/frameworks.html](https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/frameworks.html)
    provides the relevant information on how to configure Django to automatically
    create traces for each incoming request to your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the todobackend repository, you first need to add the X-Ray SDK package
    to the `src/requirements.txt` file, which will ensure that the SDK is installed
    alongside the other dependencies of the todobackend application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to add a Django X-Ray middleware component, which is included
    in the SDK, to the `MIDDLEWARE` configuration element in the release settings
    file for the Django project located in `src/todobackend/settings_release.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This configuration does vary from the [X-Ray documentation for Django](https://docs.aws.amazon.com/xray-sdk-for-python/latest/reference/frameworks.html),
    however in general you only want to run X-Ray in your AWS environments, and using
    the standard approach can cause X-Ray configuration issues in your local development
    environment.  Because we have a separate release settings file that imports the
    base settings file, we can simply insert the X-Ray middleware component at the
    beginning of the base `MIDDLEWARE` list using the `insert()` function as shown. 
    This approach ensures we will run X-Ray in our AWS environments that use the release
    settings, but not use X-Ray in a local development setting.
  prefs: []
  type: TYPE_NORMAL
- en: It is important that the X-Ray middleware component is specified first in the
    `MIDDLEWARE` list, as this ensures that X-Ray can start tracing incoming requests
    before any other middleware components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the Python X-Ray SDK includes tracing support for a number of popular
    packages, including the `mysql-connector-python` package, which is used by the
    todobackend application to connect to its MySQL database. In Python, X-Ray wraps
    calls made by supported packages using a technique referred to as patching, which
    allows X-Ray to intercept calls made by the package and capture tracing information.
    For our use case, patching the `mysql-connector-python` package will enable us
    to trace database calls made by the application, which can be very useful for
    troubleshooting performance issues. To patch this package, you need to add a few
    lines of code to your application entry point, which, for Django, is located in
    the file `src/todobackend.wsgi.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `xray_recorder` configuration will add a service name to each trace segment,
    which is required otherwise you will observe SegmentNameMissingException errors. 
    At this point, you have added support at an application level to start tracing
    incoming requests, and you should be able to run the make workflow (running `make
    test` and `make release`) successfully before committing and pushing your changes
    to GitHub. Because you now have a continuous delivery pipeline in place, this
    will trigger that pipeline, which ensures that your application changes will be
    published to ECR once the pipeline build stage completes. If you haven't completed
    the previous chapter, or if you have removed your pipeline, then you will need
    to manually publish the new image by using the `make login` and `make publish`
    commands after running `make test` and `make release`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an X-Ray daemon Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before our application can publish X-Ray tracing information, you must deploy
    an X-Ray daemon that your application can send this information to. Our goal is
    to run the X-Ray daemon using AWS Fargate, but before we can do that, we need
    to create a Docker image that will run the daemon. AWS provides examples of how
    to build an X-Ray daemon image, and we will following a similar approach to what
    is documented by AWS by creating a file called `Dockerfile.xray` in the root of
    the `todobackend-aws` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now build this image locally by using the `docker build` command, as
    demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With our image now built, we need to publish it to ECR. Before you can do this,
    you need to create a new repository for the X-Ray image, which we can add to the
    existing `ecr.yml` file at the root of the `todobackend-aws` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example*,* you created a new repository with the name `docker-in-aws/xray`,
    which will result in a fully qualified repository name of `<account-id>.dkr.ecr.<region>.amazonaws.com/docker-in-aws/xray` (for
    example, `385605022855.dkr.ecr.us-east-1.amazonaws.com/docker-in-aws/xray`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now create the new repository by running the `aws cloudformation deploy`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once deployment has completed, you can log in to ECR, and then tag and publish
    the image that you created earlier with the fully qualified name of the new ECR
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Configuring ECS service discovery resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ECS service discovery is a feature that allows your client applications to discover
    ECS services in a dynamic environment, where container-based endpoints come and
    go. To date, we have used AWS application load balancers to perform this function,
    where you configure a stable service endpoint that your applications can connect
    to, with connections then load balanced across an ECS-managed target group that
    includes each of the ECS tasks associated with your ECS service.  Although this
    is generally my recommended best practice approach, for applications that don't
    support load balancers (for example, UDP-based applications), or for very large
    microservice architectures where it is more efficient to have direct communication
    with a given ECS task, ECS service discovery may be a better approach than using
    load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: ECS service discovery also supports AWS load balancers, where ECS will publish
    the IP address of the load balancer listener if a load balancer is associated
    with a given ECS service.
  prefs: []
  type: TYPE_NORMAL
- en: ECS service discovery uses DNS as its discovery mechanism, which is useful,
    given that in its most basic form, DNS is universally supported by any application
    client. The DNS namespace that your ECS services are registered in is referred
    to as a**service discovery namespace**, which simply corresponds to a Route 53
    DNS domain or zone, and each service that you register in the namespace is referred
    to as a **service discovery**. For example, you might configure `services.dockerinaws.org`
    as a service discovery namespace, and, if you have an ECS service called `todobackend`,
    then you will connect to that service using the DNS name `todobackend.services.dockerinaws.org`.
    ECS will automatically manage address (`A`) records registered against the DNS
    record for your service, dynamically adding the IP address associated with each
    active and healthy ECS task of your ECS service, as well as removing any ECS tasks
    that exit or become unhealthy. ECS service discovery supports both public and
    private namespaces, and for our example of running the X-Ray daemon, a private
    namespace is suitable, given that this service only needs to support internal
    application tracing communications from the todobackend application.
  prefs: []
  type: TYPE_NORMAL
- en: ECS service discovery supports the provisioning of DNS service (SRV) records,
    which include both IP address and TCP/UDP port information about a given service
    endpoint. You typically use address (`A`) records when using static port mapping
    or **awsvpc** networking mode (as is the case with Fargate), and SRV records when
    using dynamic port mapping, given that SRV records can include the dynamic port
    information for the port mapping that is created. Note that application support
    for SRV records is somewhat limited, so I typically recommend using the tried
    and true approach of using `A` records for ECS service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a service discovery namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most AWS resources, you can configure service discovery resources using
    the AWS console, AWS CLI, any one of the various AWS SDKs, or CloudFormation.
    Given our infrastructure as code approach throughout this book, we will naturally
    adopt CloudFormation in this chapter; because the X-Ray daemon is a new service
    (and would typically be considered a shared service, which each of your applications
    publishes trace information to), we will create a new stack, in a file called
    `xray.yml`, at the root of the `todobackend-aws` repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates creating the initial template and creating
    a service discovery namespace resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example*,* we created a private service discovery namespace
    that simply requires the DNS name of the namespace, an optional description, and
    the VPC ID that the associated private Route 53 zone will be linked to. To keep
    things simple, I have also hardcoded an appropriate value for the VPC ID related
    to my AWS account, which you would typically inject via a stack parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the intention of a service discovery namespace is to support multiple
    services, you would typically create the namespace in a separate CloudFormation
    stack, such as a dedicated network stack that creates shared network resources.
    However, in the interest of keeping things simple, we are creating the namespace
    in the X-Ray stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now deploy the initial stack to CloudFormation by using the `aws cloudformation
    deploy` command, which should create a service discovery namespace and the associated
    Route 53 private zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, once your stack successfully deploys, you will use
    the `aws servicediscovery list-namespaces` command to verify that a private namespace
    was created, while the `aws route53 list-hosted-zones` command shows that a Route
    53 zone was also created, with a zone name of `services.dockerinaws.org`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a service discovery service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you have a service discovery namespace in place, the next step is
    to create a service discovery service, which has a one-to-one relationship with
    each ECS service, meaning that you need to create a service discovery service
    that represents the X-Ray ECS service that you will create later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, you added a new resource, called `ApplicationServiceDiscoveryService`,
    and configured the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: Defines the name of the service. This name will be used to register
    the service in the associated namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DnsConfig`: Specifies the namespace that the service is associated with (as
    defined by the `NamespaceId` property), and defines the DNS record type and time-to-live
    (TTL) that should be created. Here, you specify an address record (type `A`) and
    a TTL of 60 seconds, meaning that clients will only cache the record for a maximum
    of 60 seconds. Generally, you should set the TTL to a low value, to ensure that
    your clients pick up DNS changes when new ECS tasks are registered to the service
    or existing ECS tasks are removed from the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HealthCheckCustomConfig`: This configures ECS to manage health checks that
    determine whether or not an ECS task can be registered. You can also configure
    Route 53 health checks (see [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html#service-discovery-concepts](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html#service-discovery-concepts));
    however, for our use case, given that X-Ray is a UDP-based application and Route
    53 health checks only support TCP-based services, you must use the `HealthCheckCustomConfig`
    configuration shown in the preceding example. The `FailureThreshold` specifies
    the number of `30` second intervals the service discovery will wait to change
    the health of a given service instance, after receiving a custom health check
    update (in this scenario, ECS provides custom health checks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can now deploy your updated stack to CloudFormation using the `aws cloudformation
    deploy` command, which should create a service discovery service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a DNS record set for `xray.services.dockerinaws.org`, which
    won't have any address (`A`) records associated with it until we configure ECS
    service discovery support for the X-Ray ECS service that we will create later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an ECS task definition for Fargate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now ready to start defining your ECS resources, which you will configure
    to use the AWS Fargate service and leverage the service discovery resources that
    you created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'When configuring ECS task definitions to support Fargate, there are some key
    considerations that you need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Launch type:** An ECS task definition includes a parameter called `RequiresCompatibilities`,
    which defines the compatible launch types for the definition. The current launch
    types include EC2, which refers to ECS tasks launched on traditional ECS clusters,
    and FARGATE, which refers to ECS tasks launched on Fargate. By default, the `RequiresCompatibilities` parameter
    is configured as EC2, meaning that you must explicitly configure this parameter
    if you want to use Fargate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network mode**: Fargate only supports the `awsvpc` network mode, which we
    discussed in Chapter 10 - *Isolating Network Access*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Execution role**: Fargate requires you to configure an **execution role**,
    which is an IAM role assigned to the ECS agent and Fargate runtime that manages
    the life cycle of ECS tasks, based from your Fargate task definition. This is
    a separate role from the IAM roles for tasks feature that you configured back
    in Chapter 9 - *Managing Secrets*, which you use to grant IAM permissions to the
    application running in your ECS task. The execution role is typically configured
    with similar permissions to those that you would configure for an EC2 IAM instance
    role associated with a traditional ECS container instance, granting, at a minimum,
    permissions for the ECS agent and Fargate runtime, to pull images from ECR and
    write logs to CloudWatch logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU and Memory**: Fargate requires you to define CPU and memory requirements
    at the task definition level, as this determines the underlying target instance
    that ECS tasks based from your task definition will run on. Note that this is
    separate from the per-container definition CPU and memory settings that you configured
    in the ECS task definition for the todobackend application, back in Chapter 8
    - *Deploying Applications using ECS*; you can still configure per-container definition
    CPU and memory settings, but you need to ensure that the total CPU/memory allocated
    to your container definitions does not exceed the overall CPU/memory allocated
    to the ECS task definition. Fargate currently supports only a limited set of CPU/memory
    allocations, which you can read more about in the *Task CPU and Memory* section
    at [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging**: At the time of writing, Fargate only supports the `awslogs` logging
    driver, which forwards your container logs to CloudWatch logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the preceding considerations in mind, let''s now define a task definition
    for our X-Ray daemon service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, notice that the `RequiresCompatibilities` parameter
    specifies `FARGATE` as the supported launch type, and that the `NetworkMode` parameter
    is configured as the required `awsvpc` mode. The `Cpu` and `Memory` settings are
    configured as 256 CPU units (0.25 vCPUs) and 512 MB, respectively, which represents
    the smallest available Fargate CPU/memory configuration.  For the `ExecutionRoleArn`
    parameter, you reference an IAM role called `ApplicationTaskExecutionRole`, which
    we will configure shortly, separate from the role configured for the `TaskRoleArn`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you define a single container definition called `xray`, which references
    the ECR repository that you created earlier in this chapter; notice that you specify
    the `-o` flag for the `Command` parameter. This will append `-o` to the command
    specified in the `ENTRYPOINT` directive that you configured in the X-Ray daemon
    image back in the previous example, which stops the X-Ray daemon from attempting
    to query EC2 instance metadata, as this is not supported when you use Fargate.
  prefs: []
  type: TYPE_NORMAL
- en: The log configuration for the container definition is configured to use the
    `awslogs` driver, as required for Fargate, which references the `ApplicationLogGroup`
    CloudWatch logs group resource configured under the task definition. Finally,
    you specify the X-Ray daemon port (`UDP port 2000`) as a container port mapping,
    and you configure a single environment variable, called `AWS_REGION`, that references
    the region in which you deploy the stack, which is required for the X-Ray daemon
    to determine the regional X-Ray service endpoint that the daemon should publish
    trace data to.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring IAM roles for Fargate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, your ECS task definition refers to a task execution
    role (as defined by the `ExecutionRoleArn` parameter) and a task role (as defined
    by the `TaskRoleArn` parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed previously, the task execution role defines the IAM permissions
    that will be assigned to the ECS agent and Fargate runtime, and typically includes
    permissions to pull the require ECR images to run the containers defined in your
    task definition, as well as permissions to write to the CloudWatch log groups
    referenced in your container logging configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The task role defines any IAM permissions that the applications running from
    your ECS task definition may require. For our use case, the X-Ray daemon requires
    permissions to publish traces to the X-Ray service, as demonstrated in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example*,* you grant the `xray:PutTraceSegments` and `xray:PutTelemetryRecords`
    permission to the X-Ray daemon, which allows the daemon to publish application
    traces captured from your applications to the X-Ray service. Notice that for both
    the `ApplicationTaskExecutionRole` and `ApplicationTaskRole` resources, the trusted
    entity in the `AssumeRolePolicyDocument` section must be configured as the `ecs-tasks.amazonaws.com`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an ECS service for Fargate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have defined an ECS task definition for Fargate, you can create
    an ECS service that will reference your ECS task definition and deploy one or
    more instances (ECS tasks) for your service.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, when configuring ECS services to support Fargate, there
    are some key considerations that you need to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Launch type**: You must specify Fargate as the launch type for any ECS service
    that you want to run using Fargate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform version**: AWS maintains different versions of the Fargate runtime
    or platform, which will evolve over time, and may at some point introduce breaking
    changes for your ECS services. You can optionally target a specific platform version
    for your ECS service, or simply omit configuring this property, to use the latest
    platform version available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network configuration**: Because Fargate requires the use of **awsvpc** networking
    mode, your ECS services must define a network configuration that defines the subnets
    your ECS service will run in, the security groups assigned to your ECS service,
    and also, whether or not your service is assigned a public IP address. At the
    time of writing this book, when using Fargate, you must either assign a public
    IP address or use a NAT gateway, as discussed in the chapter *Isolating Network
    Access*, to ensure that the ECS agent that manages your ECS service can communicate
    with ECS, pull images from ECR, and publish logs to the CloudWatch logs service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although you can't interact with the ECS agent, it is important to understand
    that all ECS agent communications use the same network interface as your container
    applications running in Fargate. This means that you must consider the communication
    requirements of the ECS agent and Fargate runtime when attaching security groups
    and determining the network placement of your ECS service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates configuring an ECS service for Fargate and
    ECS service discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example*,* the first point to note is that although you don't
    run any ECS container instances or other infrastructures when using Fargate, you
    are still required to define an ECS cluster when configuring ECS services for
    Fargate, which you will then reference in your ECS service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ECS service configuration is similar to the configuration you defined when
    running the todobackend application using ECS task networking in the *Isolating
    Network Access* chapter, although there are a few key configuration properties
    to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LaunchType`: This must be specified as `FARGATE`. It is important to ensure
    that you place your ECS services in a public subnet and configure the `AssignPublicIp`
    property in the networking configuration as `ENABLED`, or, alternatively, place
    your services in a private subnet with a NAT gateway. In the preceding example,
    note that I have hardcoded the `Subnets` property to public subnets within my
    VPC; you need to change these to the appropriate values for your environment,
    and you would typically inject these values via a stack parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ServiceRegistries`: This property configures your ECS service to use the ECS
    service discovery feature that we configured earlier in this chapter, and here,
    you reference the ARN of the service discovery service that you configured back
    in the previous example. With this configuration in place, ECS will automatically
    register/de-register the IP address of each of your ECS service instances (ECS
    tasks) in the DNS record set created for the linked service discovery service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At this point, there is one final resource to configure—you need to define
    the `ApplicationSecurityGroup` resource referenced by your ECS service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, again, note that I am using hardcoded values where
    I would typically use stack parameters, to keep things simple and to the point.
    The security group permits ingress access to UDP port 2000 from any host within
    the VPC, while the egress security rules allow access to DNS, HTTP, and HTTPS,
    which is required to ensure that the ECS agent can communicate with ECS, ECR,
    and CloudWatch logs, and that the X-Ray daemon can communicate with the X-Ray
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and testing the X-Ray daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have completed the configuration of our CloudFormation template
    that will deploy the X-Ray daemon to AWS using the Fargate service with ECS service
    discovery enabled; you can deploy the changes to your stack by using the `aws
    cloudformation deploy` command, including the `--capabilities` parameter, given
    that our stack is now creating IAM resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the deployment has completed, if you open the ECS dashboard in the AWS
    console and select Clusters, you should see a new cluster called xray-daemon-cluster,
    with a single service and two running tasks, in the FARGATE section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c46789ab-3cb2-4a26-b6bc-229781c40131.png)X-Ray daemon cluster'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the cluster and click on the **xray-daemon-application-service**,
    you should see the ECS service discovery configuration in place on the Details
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b005f475-d3a7-4e40-a393-cf610c7882a4.png)X-Ray daemon service details'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the service discovery namespace, you should now find two address records
    attached to the `xray.services.dockerinaws.org` record set, which you can view
    by navigating to the Route 53 dashboard, selecting Hosted zones from the left-hand
    menu, and selecting the `services.dockerinaws.org` zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fdcda94e-f9c6-49e2-87b9-b843c2465b05.png)Service discovery DNS records'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are two `A` records present, one for each ECS task that supports
    our ECS service. If you were to stop one of these ECS tasks, ECS would automatically
    remove the record from DNS, and then add a new `A` record once ECS restored the
    ECS service count to its desired count and started a replacement ECS task. This
    ensures that your service is highly available, and that applications that rely
    on your service can dynamically resolve an appropriate instance of your service.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the todobackend stack for X-Ray support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our X-Ray daemon service in place, we can now add support for X-Ray to
    the `todobackend-aws` stack. At the beginning of this chapter, you configured
    support for X-Ray in the todobackend application, and if you committed and pushed
    your changes, the continuous delivery pipeline you created in the last chapter
    should have already published an updated Docker image to ECR (if this is not the
    case, run the `make publish` command in the todobackend repository). The only
    other configuration that you need to perform is to update the security rules attached
    to your todobackend cluster instances to allow X-Ray communications, and to ensure
    that the Docker environment is configured with the appropriate environment variables
    that enable correct X-Ray operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates adding a security rule to the `ApplicationAutoscalingSecurityGroup`
    resource in the `todobackend-aws` stack, which allows for X-Ray communications
    with the X-Ray daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example demonstrates configuring the environment settings for
    the todobackend container definition, within the `ApplicationTaskDefinition` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you added a variable called `AWS_XRAY_DAEMON_ADDRESS`,
    which references the `xray.services.dockerinaws.org` service endpoint of our X-Ray
    daemon service and must be expressed in the format `<hostname>:<port>`.
  prefs: []
  type: TYPE_NORMAL
- en: You can override the service name used in your X-Ray traces be setting the `AWS_XRAY_TRACE_NAME`
    environment variable.  This would be important in our scenario where we have a
    dev and production instance of the todobackend application in the same account,
    and want to ensure each application environment has its own set of traces.
  prefs: []
  type: TYPE_NORMAL
- en: If you now commit and push all of your changes to the `todobackend-aws` repository,
    the continuous delivery pipeline from the previous chapter should detect the change
    and deploy your updated stack automatically, or alternatively you can run the
    `make deploy/dev` command to deploy your changes from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the X-Ray service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After your changes have deployed successfully, browse to the todobackend URL
    for your environment and perform a few interactions with the application, such
    as adding a `todo` item.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you next open the X-Ray dashboard from the AWS console (Services | Developer
    Tools | X-Ray) and select Service map from the left-hand menu, you should see
    a very simple map that includes the todobackend application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51bba37a-3dbf-4f06-8d4f-ecc168183a1c.png)X-Ray service map'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, I have clicked on the todobackend service, which
    displays the Service details pane on the right, showing information such as the
    response time distribution and response status responses. Also, notice that the
    service map includes the todobackend RDS instance, given that we configured our
    application to patch the `mysql-connector-python` library back in the previous
    example in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the View traces button, the traces for that service will be
    displayed; notice that the X-Ray middleware for Django includes URL information
    that allows your traces to be grouped by URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d25b61ac-61ec-4621-8b3d-99a298865260.png)X-Ray traces'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot*,* notice that 85% of traces are hitting an IP address
    URL, which corresponds to the ongoing application load balancer health checks.
    If you click on the Age column in the Trace list to sort traces from newest to
    oldest, you should be able to see the requests that you made to the todobackend
    application, which, in my case, was a `POST` request to create a new `todo` item.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view more details for the `POST` trace in the following screenshot*,*
    by clicking on the ID link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9eaf6820-622f-422a-bbc3-6c5e41b1d710.png)X-Ray trace details'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that the response took 218 ms to complete,
    in total, and that two database calls were made, which each took less than 2 ms.
    If you were using other libraries supported by the X-Ray SDK, you could also see
    trace information for calls made by those libraries; for example, any AWS service
    calls made via the boto3 library, such as copying a file to S3 or publishing a
    message to a Kinesis stream, would also be captured. Obviously, this type of information
    is very useful when troubleshooting performance issues for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to deploy Docker applications using the AWS
    Fargate service. To make things more interesting, you also learned how you can
    leverage ECS service discovery to automatically publish service reachability information
    for your application endpoints, which is an alternative to the more traditional
    approach of publishing your application endpoints behind a load balancer. And,
    to cap off what I'm sure you found to be a fun and interesting chapter, you added
    support for the AWS X-Ray service to the todobackend application and deployed
    an X-Ray daemon service, using Fargate to capture application traces.
  prefs: []
  type: TYPE_NORMAL
- en: First, you learned how to add support for X-Ray to a Python Django application,
    which simply requires you to add an X-Ray middleware component that intercepts
    incoming requests, and to also patch support packages, such as the mysql-connector-python
    and boto3 libraries, which allows you to capture MySQL database calls and any
    AWS service calls that your application might make. You then created a Docker
    image for the X-Ray daemon, which you published to the Elastic Container Registry,
    to make it available for deployment in your AWS environment.
  prefs: []
  type: TYPE_NORMAL
- en: The, you learned how to configure the supporting elements required for ECS service
    discovery, adding a service discovery namespace that creates a public or private
    DNS zone where service discovery service endpoints are maintained, and then creating
    a service discovery service for the X-Ray daemon, allowing your todobackend application
    (and other applications) to discover all active and healthy X-Ray daemon instances
    via logical DNS names.
  prefs: []
  type: TYPE_NORMAL
- en: With these components in place, you proceeded to creating an X-Ray daemon service
    using Fargate, creating an ECS task definition and an ECS service. The ECS task
    definition had a few specific requirements for supporting Fargate, including defining
    a separate task execution role that grants privileges to the underlying ECS agent
    and Fargate runtime, specifying Fargate as a supported launch type and ensuring
    that the awsvpc networking mode was configured. The ECS service that you created
    required you to configure a network configuration to support the awsvpc networking
    mode of your ECS task definition. You also added support for ECS service discovery
    by referencing the service discovery service that you created earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you configured your existing ECS task definitions in the todobackend
    stack, to specify the service discovery service name as the `AWS_XRAY_DAEMON_ADDRESS`
    variable; after deploying your changes, you learned how to use X-Ray traces to
    analyze the performance of incoming requests to your application, with the ability
    to profile individual calls to the todobackend application database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about another AWS service that supports
    Docker applications, called Elastic Beanstalk. It provides a **platform-as-a-service
    (Paas)** approach to deploying and running your container-based applications in
    AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True/false: Fargate requires you to create an ECS cluster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When configuring Fargate, what networking modes are supported?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: Fargate separates ECS agent **control plane** network communications
    from ECS task **data plane** network communications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You deploy a new ECS service using Fargate, which fails, with an error indicating
    that the ECR image specified in the task definition cannot be pulled. You verify
    that the image name and tag are correct, and that the IAM role referenced on the
    `TaskRoleArn` property of the task definition permits access to the ECR repository.
    What is the most likely cause of this error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are determining the best technology to deploy your container-based applications
    in AWS. Your organization deploys Splunk to collect logs for all applications,
    and uses New Relic to collect performance metrics. Is Fargate a suitable technology,
    based on these requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: ECS service discovery uses Consul to publish service registration
    information.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which service discovery resource creates a Route 53 zone?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You configure an ECS task definition to use Fargate, and specify that the task
    should be allocated 400 CPU units and 600 MB of memory. When you deploy an ECS
    service that uses the task definition, the deployment fails. How can you resolve
    this issue?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, which network protocol and port are used for AWS X-Ray communications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: When you add X-Ray support to your container-based applications,
    they will publish traces to the AWS X-Ray service.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Fargate on Amazon ECS: [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS_Fargate.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon ECS Task Execution IAM Role: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ECS Service Discovery: [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS X-Ray Developer Guide: [https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html](https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS X-Ray Python SDK: [https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-python.html](https://docs.aws.amazon.com/xray/latest/devguide/xray-sdk-python.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the X-Ray Daemon on Amazon ECS: [https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-ecs.html](https://docs.aws.amazon.com/xray/latest/devguide/xray-daemon-ecs.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Service Discovery Public Namespace Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-publicdnsnamespace.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-publicdnsnamespace.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Service Discovery Private Namespace Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-privatednsnamespace.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-privatednsnamespace.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation Service Discovery Service Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-service.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-servicediscovery-service.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation ECS Task Definition Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFormation ECS Service Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
