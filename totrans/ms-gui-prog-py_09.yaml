- en: Working with Audio-Visual Using QtMultimedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether in games, communications, or media production applications, audio and
    video content is often a crucial part of modern applications. When working with
    native APIs, even the simplest **audio-visual** (**AV**) applications can be quite
    complicated, especially when supporting multiple platforms. However, fortunately
    for us, Qt provides us with a simple cross-platform multimedia API in the form
    of `QtMultimedia`. With `QtMultimedia`, we can easily work with audio content,
    video content, or devices such as cameras and radios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll use `QtMultimedia` to explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple audio playback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playing audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording and playing video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the basic PyQt setup described in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt,* you will need to make sure the `QtMultimedia` and
    `PyQt.QtMultimedia` libraries are installed. If you installed PyQt5 using `pip`,
    then it should already be installed. Linux users who are using their distro's
    package manager should check that these packages are installed.
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to download the code from our GitHub repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter07](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter07),
    which contains not only the example code but the audio data used for these examples.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create your own audio files to work with, you might want to install
    the free Audacity sound editor at [https://www.audacityteam.org/](https://www.audacityteam.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will get the most out of this chapter if your computer has a working
    audio system, microphone, and webcam. If it does not, then some of the examples
    will not work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2Mjr8vx](http://bit.ly/2Mjr8vx)
  prefs: []
  type: TYPE_NORMAL
- en: Simple audio playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Quite often, applications need to playback sounds in response to GUI events,
    as you might do in a game or just to provide audio feedback for user actions.
    For this application, `QtMultimedia` offers the `QSoundEffect` class. `QSoundEffect`
    is limited to playing back uncompressed audio, so it works with **Pulse Code M****odulation** (**PCM**), **Waveform
    data** (**WAV**) files but not MP3 or OGG files. The trade-off is that it is low-latency
    and very efficient with resources, so while it's not useful as a general-purpose
    audio player, it is perfect for fast playback of sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate `QSoundEffect`, let's build a phone dialer. Copy the application
    template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building
    Applications with QMainWindow,* into a new file called `phone_dialer.py` and open
    it in your editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the `QtMultimedia` library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Importing `QtMultimedia` will be a necessary first step for all the examples
    in this chapter, and we will consistently use `qtmm` as an alias for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also import a `resources` library containing the necessary WAV data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This `resources` file contains a collection of **Dial Tone Multi-Frequency** (**DTMF**)
    tones. These are the tones generated by telephones when dialing, and we've included `0`
    through to `9`, `*`, and `#`. We've included this file in the example code; alternatively,
    you can create your own `resources` file from your own audio samples (you can
    refer to [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt
    Applications,* for information on how to do this).
  prefs: []
  type: TYPE_NORMAL
- en: You can generate DTMF tones using the free Audacity sound editor. To do so,
    select Generate | DTMF from Audacity's main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that''s in place, we''re going to create a `QPushButton` subclass that
    plays a sound effect when it is clicked on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've modified the constructor to take a sound file path as
    an argument. This value is converted to `QUrl` and passed into our `QSoundEffect`
    object using the `setSource()` method. Finally, the `QSoundEffect.play()` method
    triggers playback of the sound, so we've connected it to the button's `clicked`
    signal. This is all it takes to create our `SoundButton` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `MainWindow.__init__()` method, let''s create some `SoundButton`
    objects and arrange them in the GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We've set up the resource file so that each DTMF tone can be accessed by its
    symbol under the `dtmf` prefix; for example, `':/dtmf/1.wav'` refers to the DTMF
    tone for 1\. In this way, we can just iterate through a string of symbols and
    create a `SoundButton` object for each, which we add to a three-column grid.
  prefs: []
  type: TYPE_NORMAL
- en: That's all there is to it; run this program and push the buttons. It should
    sound just like dialing a phone!
  prefs: []
  type: TYPE_NORMAL
- en: Recording and playing audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QSoundEffect` is adequate for dealing with simple event sounds, but for more
    advanced audio projects we''re going to need something with more capabilities.
    Ideally, we want the ability to load more formats, control various aspects of
    the playback, and record new sounds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we''re going to focus on two classes that provide these features:'
  prefs: []
  type: TYPE_NORMAL
- en: The `QMediaPlayer` class, which is like a virtual media player device that can
    load audio or video content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `QAudioRecorder` class, which manages the recording of audio data to a disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To see these classes in action, we're going to build a sampling soundboard.
  prefs: []
  type: TYPE_NORMAL
- en: The initial setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, make a fresh copy of the application template and call it `soundboard.py`.
    Then, import `QtMultimedia` as you did for the last project, and let's layout
    the main interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `MainWindow` constructor, add in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All we're doing here is creating an empty central widget, adding a grid layout,
    and then filling it with `3` rows and `3` columns of `SoundWidget` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing sound playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `SoundWidget` class is going to be a `QWidget` object that manages a single
    sound sample. When finished, it will allow us to load or record an audio sample,
    play it back looped or as a one-shot, and control its volume and playback position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `MainWindow` constructor, let''s create the class and give it a layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we've added is a label that will display the name of the sample
    file the widget has loaded. The next thing we need is a button to control the
    playback. Instead of just a plain push button, let's apply some of our styling
    skills to create a custom button that can switch between being a Play button and
    a Stop button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a `PlayButton` class above the `SoundWidget` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `SoundWidget` class, we''ll add a `PlayButton` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a control button, we need to create the `QMediaPlayer` object
    that will play the sample, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can think of `QMediaPlayer` as the software equivalent to a hardware media
    player such as a CD or Blu-ray player. Just like a hardware media player has Play,
    Pause, and Stop buttons, the `QMediaPlayer` object has `play()`, `stop()`, and
    `pause()` slots to control the playback of the media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s connect our dual-function `PlayButton` object to the player. We''ll
    do this by way of an instance method called `on_playbutton()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how `SoundWidget.on_playbutton()` will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method examines the player object's `state` property, which returns a constant
    indicating whether the player is playing, has paused, or has stopped. If the player
    is currently playing, we stop it—if not, we ask it to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our button is switching between a play and stop button, let''s update
    its label and appearance. `QMediaPlayer` emits a `stateChanged` signal when its
    state changes, which we can send to our `PlayButton` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the `PlayButton` class, let''s handle that signal, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `stateChanged` passes along the new state of the media player, which we
    use to set the button to its play or stop appearance.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as a hardware media player requires a CD, a DVD, or a Blu-ray disc loaded
    into it to actually play anything back, our `QMediaPlayer` also needs some kind
    of content loaded before it can play any audio. Let's explore how to load a sound
    from a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding a button to the `SoundWidget` layout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This button calls to the `get_file()` method, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method simply calls `QFileDialog` to retrieve a file URL and then passes
    it along to another method, `set_file()`, which we'll write next. We've set the
    filter to look for five common audio file types, but feel free to add more if
    you have audio in a different format—`QMediaPlayer` is quite flexible in what
    it can load.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're calling `getOpenFileUrl()`, which returns a `QUrl` object rather
    than a file path string. `QMediaPlayer` prefers working with `QUrl` objects so
    this will save us a conversion step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `set_file()` method is where we''ll finally load our media into the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Before we can pass the URL to our media player, we have to wrap it in a `QMediaContent`
    class. This provides the player with the API it needs to playback the content.
    Once wrapped, we can use `QMediaPlayer.setMedia()` to load it up, and then it's
    ready for playback. You can visualize this process as putting audio data onto
    a CD (the `QMediaContent` object), and then loading that CD into a CD player (using
    `setMedia()`).
  prefs: []
  type: TYPE_NORMAL
- en: As a last touch, we've retrieved the filename of the loaded file and put it
    in the label.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the playback position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, our soundboard can load and play samples, but it would be nice
    to see and control the position of playback, particularly for long samples. `QMediaPlayer`
    allows us to retrieve and control the playback position through signals and slots,
    so let's look into that from our GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `QSlider` widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`QSlider` is a widget that we haven''t looked at yet; it''s just a slider control
    that can be used to input integers between a minimum and maximum value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now connect the slider and player, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `QMediaPlayer` class reports its position in integers representing the number
    of milliseconds from the start of the file so that we can connect the `positionChanged`
    signal to the slider's `setSliderPosition()` slot.
  prefs: []
  type: TYPE_NORMAL
- en: However, we also need to adjust the slider's maximum position so that it matches
    the duration of the sample, otherwise, the slider won't know what percentage the
    value represents. Therefore, we've connected the player's `durationChanged` signal
    (which is emitted whenever new content is loaded into the player) to the slider's
    `setMaximum()` slot.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'd like to be able to control the playback position using the slider,
    so we set the `sliderMoved` signal to the player's `setPosition()` slot. Note
    that we definitely want to use `sliderMoved` and not `valueChanged` (which `QSlider`
    emits when the value is changed by the user *or* by an event), because the latter
    would create a feedback loop when the media player changes the position.
  prefs: []
  type: TYPE_NORMAL
- en: These connections are all we need for our slider to work. Now you can run the
    program and load up a long sound; you'll see that the slider tracks the playback
    position and can be moved around before or during playback to alter the position.
  prefs: []
  type: TYPE_NORMAL
- en: Looping the audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playing our samples in one-shots is neat, but we'd also like to loop them. Looping
    audio in a `QMediaPlayer` object requires a slightly different approach. Instead
    of loading a `QMediaContent` object directly, we need to first add it to a `QMediaPlayList`
    object. We can then tell the playlist to loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `set_file()` method, we need to make the following changes to our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A playlist can, of course, have multiple files loaded, but, in this case, we
    only want one. We load the `QMediaContent` object into the playlist using the
    `addMedia()` method and then point the playlist to that file using the `setCurrentIndex()`
    method. Note that the playlist won't automatically point to any item by default.
    This means that if you skip this last step, then nothing will happen when you
    try to play the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the media player's `setPlaylist()` method to add the playlist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our content is in a playlist, we''ll create a checkbox to switch looping
    on and off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re connecting the checkbox''s `stateChanged` signal to
    a callback method; the method will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `playbackMode` property of the `QMediaPlaylist` class is very similar to
    the track mode button on a CD player, which can be used to switch between repeat,
    shuffle, or sequential play. There are five playback modes, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CurrentItemOnce` | Play the current track once and stop. |'
  prefs: []
  type: TYPE_TB
- en: '| `CurrentItemInLoop` | Play the current item repeatedly. |'
  prefs: []
  type: TYPE_TB
- en: '| `Sequential` | Play all the items in the order and then stop. |'
  prefs: []
  type: TYPE_TB
- en: '| `Loop` | Play all the items in the order and then repeat. |'
  prefs: []
  type: TYPE_TB
- en: '| `Random` | Play all the items in a random order. |'
  prefs: []
  type: TYPE_TB
- en: In this method, we're switching between `CurrentItemOnce` and `CurrentItemInLoop`
    depending on whether the checkbox is checked. Since our playlist only has one
    item, the remaining modes aren't meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final touch, we''ll clear the checkbox on loading a new file. So, add
    this to the end of `set_file()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should be able to run the program and loop the sample. Note
    that looping audio using this method may not guarantee a seamless loop; depending
    on your platform and system capabilities, there may be a small gap between iterations
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our final playback feature will be volume control. To allow us to control the
    playback level, `QMediaPlayer` has a `volume` parameter that accepts values from
    `0` (muted) to `100` (full volume).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll simply add another slider widget to control the volume, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: After setting the minimum and maximum values accordingly, we just need to connect
    `sliderMoved` to the media player's `setVolume()` slot. That's all there is to
    it!
  prefs: []
  type: TYPE_NORMAL
- en: For smoother volume control, the Qt documentation recommends converting the
    slider's linear scale to a logarithmic scale. We recommend that you read [https://doc.qt.io/qt-5/qaudio.html#convertVolume](https://doc.qt.io/qt-5/qaudio.html#convertVolume)
    and see whether you can do this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing recording
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The audio recording in Qt is facilitated by the `QAudioRecorder` class. Just
    as the `QMediaPlayer` class was analogous to a media playback device, the `QAudioRecorder` class
    is analogous to a media recording device such as a digital audio recorder (or,
    if you're of the author's generation, a tape recorder). The recorder is controlled
    using the `record()`, `stop()`, and `pause()` methods, much like the media player
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a recorder object to our `SoundWidget`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To control the recorder, we''ll create another dual-function button class that
    is similar to the play button that we previously created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the `PlayButton` class, we're switching the appearance of the button
    whenever a new `state` value is received from the recorder's `stateChanged` signal.
    In this case, we're looking for the recorder's `RecordingState` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `RecordButtoon()` method to our widget, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We've connected the `clicked` signal to an `on_recordbutton()` method, which
    will handle the starting and stopping of the audio recording.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that we'll do is check the state of the recorder. If it's currently
    recording, then we'll stop it by calling `recorder.stop()`, which not only stops
    the recording but writes the recorded data to an audio file on a disk. We can
    then get the location of that file by calling the recorder's `actualLocation()`
    method. This method returns a `QUrl` object, which we can pass directly to `self.set_file()`
    to set our playback to the newly recorded file.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you use `actualLocation()` to get the location of the file. The
    recording location can be configured using `setLocation()`, and this value is
    available from the `location()` accessor. However, Qt may fall back to a default
    setting if the configured location is invalid or non-writable. `actualLocation()`
    returns the URL where the file was actually saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''re not currently recording, we''ll tell the recorder to start recording
    by calling `recorder.record()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When `record()` is called, the audio recorder begins recording audio in the
    background and will continue to do so until `stop()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can playback our recorded files, we need to make one fix to `set_file()`.
    At the time of writing, the `QAudioRecorder.actualLocation()` method neglects
    to add a scheme value to the URL, so we''ll need to specify this manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In `QUrl` terms, the `scheme` object indicates the protocol of the URL, such
    as HTTP, HTTPS, or FTP. Since we're accessing local files, the scheme should be
    `'file'`.
  prefs: []
  type: TYPE_NORMAL
- en: If the default settings of `QAudioRecorder` work correctly on your system, then
    you should be able to record and playback audio. However, that's a big *if*; it
    is more than likely that you'll need to do some configuration on the audio recorder
    object to get things working. Let's look at how to do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Examining and configuring the recorder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if the `QAudioRecorder` class worked well for you, you might wonder whether
    there's a way to control the type and quality of the audio that it records, what
    source it records the audio from, and what location it writes the audio files
    to.
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure these things, we first have to know what your system supports,
    as support for different audio recording features can be dependent on hardware,
    drivers, or operating system capabilities. `QAudioRecorder` has methods that can
    provide information about the capabilities that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script will display information about supported audio features
    on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this script on your system and get a list of the supported `Inputs`,
    `Codecs`, `Sample Rates`, and `container` formats. For instance, on a typical
    Microsoft Windows system, your results will probably be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure the input source for a `QAudioRecorder` object, you need to pass
    the name of the audio input to the `setAudioInput()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The actual name of the input may be different on your system. Unfortunately,
    `QAudioRecorder` will not throw an exception or register an error when you set
    an invalid audio input—it will simply fail to record any audio. So, if you decide
    to customize this attribute, take pains to ensure that the value is valid first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the output file that is recorded, we need to call `setOutputLocation()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that `setOutputLocation()` requires a `QUrl` object and not a file path.
    Once set, Qt will try to use this location for recording audio. However, as mentioned
    previously, it will revert to a platform-specific default if this location is
    not available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container format is the type of file that holds the audio data. For example,
    `audio/x-wav` is the container used for WAV files. We can set this value in the
    record object using the `setContainerFormat()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The value of this property should be a string returned by `QAudioRecorder.supportedContainers()`.
    Using an invalid value will result in an error when you try to record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the codec, sample rate, and quality requires a new object called a
    `QAudioEncoderSettings` object. The following example demonstrates how to create
    and configure a `settings` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've configured our audio to high-quality encoding at `44100`
    Hz using the PCM codec.
  prefs: []
  type: TYPE_NORMAL
- en: Understand that not all codecs are compatible with all container types. If you
    pick two incompatible types, Qt will print errors to the console and the recording
    will fail, but it will not otherwise crash or throw an exception. It's up to you
    to do the proper research and testing to make sure that you are picking compatible
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the codec chosen, there may be other settings you can set on your
    `QAudioEncoderSettings` object. You can consult the Qt documentation at [https://doc.qt.io/qt-5/qaudioencodersettings.html](https://doc.qt.io/qt-5/qaudioencodersettings.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring audio settings can be very tricky, especially as support varies
    widely from system to system. It's best to let Qt use its default settings when
    you can, or let the user configure these settings using values obtained from the support
    detection methods of `QAudioRecorder`. Whatever you do, don't hardcode settings
    or options if you cannot guarantee that the systems running your software will
    support them.
  prefs: []
  type: TYPE_NORMAL
- en: Recording and playing video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you understand how to work with audio in Qt, working with video is only
    a small step up in terms of complexity. Just as with audio, we'll use a player
    object to load and playback content, and a recorder object to record it. However,
    with video, we'll need to add in a few extra components to handle the visualization
    of the content and to initialize the source device.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how it works, we're going to build a video-logging application.
    Copy the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* to a new file called `captains_log.py`
    and we'll start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Building the basic GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Captain's Log** application will allow us to record videos from a webcam
    to a timestamped file in a preset directory and play them back. Our interface
    will feature a list of past logs on the right and a preview/playback area on the
    left. We'll have a tabbed interface so that the user can swap between playback
    and recording mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `MainWindow.__init__()`, start laying out the basic GUI as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a toolbar to hold the transport controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We want our application to only display log videos, so we need to isolate our
    recordings to a unique directory rather than using the record''s default location.
    Using `QtCore.QDir`, we''ll create and store a custom location in a cross-platform
    way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This creates the `captains_log` directory under your home directory (if it doesn't
    exist) and sets the `self.video_dir` object to point to that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need a method to scan this directory for videos and populate the list
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`QDir.entryList()` returns a list of the contents of our `video_dir`. This
    first argument is a list of filters for common video file types so that non-video
    files won''t be listed in our log list (feel free to add whatever formats your
    OS prefers), and the second is a set of flags that will limit the entries returned
    to readable files. Once retrieved, these files are sorted and added to the list
    widget.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, let''s call this function to refresh the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You may want to drop a video file or two in that directory to make sure they're
    being read and added to the list widget.
  prefs: []
  type: TYPE_NORMAL
- en: Video playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our old friend `QMediaPlayer` can handle video playback as well as audio. However,
    just as a Blu-ray player needs to be connected to a TV or monitor to display what
    it's playing, `QMediaPlayer` needs to be connected to a widget that will actually
    display the video. The widget we need is the `QVideoWidget` class, which is found
    in the `QtMultimediaWidgets` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, we''ll need to import `QMultimediaWidgets`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect our `QMediaPlayer()` method to a `QVideoWidget()` method, we set
    the player''s `videoOutput` property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is easier than hooking up your Blu-ray player, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add the video widget to our GUI and connect the transport to our
    player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As a final touch, we've added a connection to switch back to the Play tab whenever
    the Play button is clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do to enable playback is to connect the selecting
    of a file in the file list to the loading and playing of the video in the media
    player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll do that in a callback called `on_file_selected()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The callback receives `QListWidgetItem` from `file_list` and extracts the `text`
    parameter, which should be the name of the file. We pass this to the `filePath()`
    method of our `QDir` object to get a full path to the file and build a `QUrl`
    object from this (remember that `QMediaPlayer` works with URLs, not file paths).
    Finally, we wrap the content in a `QMediaContent` object, load it into the player,
    and hit `play()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, let''s connect this callback to our list widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're connecting `itemDoubleClicked`, which passes the item that's been
    clicked on to the slot just as our callback expects. Note that we're also connecting
    the action to a `lambda` function to switch to the video widget. This is so that
    if the user double-clicks on a file while on the Record tab, they will be able
    to watch it without manually switching back to the Play tab.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your player is capable of playing videos. Drop a few video files
    in your `captains_log` directory if you haven't already and see if they play.
  prefs: []
  type: TYPE_NORMAL
- en: Video recording
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To record videos, we first need a source. In Qt, this source must be a subclass
    of `QMediaObject`, which can include an audio source, a media player, a radio,
    or—as we'll be using in this program—a camera.
  prefs: []
  type: TYPE_NORMAL
- en: Qt 5.12 currently does not support video recording on Windows, only macOS, and
    Linux. For more information about the current state of multimedia support on Windows,
    please see [https://doc.qt.io/qt-5/qtmultimedia-windows.html](https://doc.qt.io/qt-5/qtmultimedia-windows.html).
  prefs: []
  type: TYPE_NORMAL
- en: Cameras themselves are represented as `QCamera` objects in Qt. To create a working
    `QCamera` object, though, we need to first get a `QCameraInfo` object.  The `QCameraInfo` object
    contains information about a physical camera attached to the computer. A list
    of these objects can be obtained from the `QtMultimedia.QCameraInfo.availableCameras()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put this together into a method that will find a camera on your system
    and return a `QCamera` object for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`availableCameras()` should return a list of `QCameraInfo` objects if you have
    one or more cameras attached to your system. If it does not, then we''ll display
    an error and return nothing; if it does, then we pass the info object to the `QCamera`
    constructor and return an object representing the camera.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, we''ll use the following function to acquire a camera
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If there is no camera, then none of the remaining code in this method will work,
    so we'll just show the window and return.
  prefs: []
  type: TYPE_NORMAL
- en: Before we use our camera, we need to tell it what we want it to capture. Cameras
    can capture still images or video content, which are configured by the camera's
    `captureMode` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we set it to video using the `QCamera.CaptureVideo` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Before we hit record, we'd like to be able to preview what the camera is capturing
    (after all, the captain needs to make sure their hair looks good for posterity).
    `QtMultimediaWidgets` has a special widget just for this purpose called `QCameraViewfinder`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add one and connect our camera to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The camera is now created and configured, so we need to activate it by calling
    the `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program at this point, you should see a real-time display of
    what your camera is capturing on the Record tab.
  prefs: []
  type: TYPE_NORMAL
- en: The final piece of this puzzle is the recorder object. In the case of video,
    we use the `QMediaRecorder` class to create a video recording object. This class
    is actually the parent of the `QAudioRecorder` class we used in our soundboard
    and works much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our recorder object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that we pass in our camera object to the constructor. You must pass `QMediaObject`
    (of which `QCamera` is a subclass) whenever you are creating a `QMediaRecorder` property.
    This property cannot be set later, nor can the constructor be called without it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with our audio recorder, we can configure various settings about the
    video we capture. This is done by creating a `QVideoEncoderSettings` class and
    passing it to the recorder''s `videoSettings` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to understand that if you set a configuration that your camera
    doesn''t support, then the recording will likely fail and you may see errors in
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that this doesn''t happen, we can query our recorder object to
    see which settings are supported just as we did with the audio settings. The following
    script will print supported codecs, frame rates, resolutions, and containers to
    the console for each detected camera on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that, on some systems, the results returned may be empty. When
    in doubt, it may be best to either experiment or accept whatever the default settings
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our recorder is ready, we need to connect the transport and enable
    it to record. Let''s start by writing a callback method for recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This callback has two jobs—to create and set the filename to record to, and
    to start the recording. We're using our `QDir` object again in conjunction with
    a `QDateTime` class to generate a filename containing the date and time when the
    record was pressed. Note that we don't add a file extension to the filename. This
    is because `QMediaRecorder` will do this automatically based on the type of file
    it has been configured to create.
  prefs: []
  type: TYPE_NORMAL
- en: The recording is started by simply calling `record()` on the `QMediaRecorder`
    object. It will record video in the background until the `stop()` slot is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, let''s finish things up by wiring in the transport controls
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We're connecting the record action to our callback and to a lambda function,
    which switches to the recording tab. We're then connecting the pause and stop
    actions directly to the recorder's `pause()` and `stop()` slots. Finally, when
    the video stops recording, we will want to refresh the file list to display the
    new file, so we connect `stop_act` to the `refresh_video_list()` callback.
  prefs: []
  type: TYPE_NORMAL
- en: And that's all we need; dust your webcam's lens, fire up this script, and start
    keeping track of your stardates!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the capabilities of the `QtMultimedia` and `QMultimediaWidgets`
    modules. You learned how to play back low-latency sound effects with `QSoundEffect`,
    and how to play and record a variety of media formats using `QMediaPlayer` and
    `QAudioRecorder`. Finally, we created a video recording and playback application
    using `QCamera`, `QMediaPlayer`, and `QMediaRecorder`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll connect to the wider world by exploring Qt's networking
    features. We'll work with low-level networking with sockets and higher-level networking
    with the `QNetworkAccessManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `QSoundEffect`, you've written a utility for a call center that allows
    them to review recorded phone calls. They're moving to a new phone system that
    stores the audio calls as MP3 files. Do you need to make any changes to your utility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cool_songs` is a Python list containing path strings to your favorite songs.
    What do you need to do to play these songs back in a random order?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have installed the `audio/mpeg` codec on your system, but the following
    code isn''t working. Find out what''s wrong with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Run `audio_test.py` and `video_test.py` on several different Windows, macOS,
    and Linux systems. How is the output different? Are there any items supported
    across all systems?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The properties of the `QCamera` class include several control objects, which
    allow you to manage different aspects of the camera. One of these is `QCameraFocus`.
    Investigate `QCameraFocus` in the Qt documentation at [https://doc.qt.io/qt-5/qcamerafocus.html](https://doc.qt.io/qt-5/qcamerafocus.html)
    and write a simple script that shows a viewfinder and lets you adjust the digital
    zoom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You've noticed the audio being recorded to your **Captain's Log** video log
    is quite loud. You want to add a control to adjust it; how would you do this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a dock widget in `captains_log.py` that allows you to control as many
    aspects of the audio and video recording as you can. You can include things such
    as focus, zoom, exposure, white balance, frame rate, resolution, audio volume,
    audio quality, and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following references for further information:'
  prefs: []
  type: TYPE_NORMAL
- en: You can get an overview of the Qt Multimedia system and its capabilities at [https://doc.qt.io/qt-5/multimediaoverview.html](https://doc.qt.io/qt-5/multimediaoverview.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official PyQt `QtMultimedia` and `QtMultimediaWidgets` examples can be found
    at [https://github.com/pyqt/examples/tree/master/multimedia](https://github.com/pyqt/examples/tree/master/multimedia)
    and [https://github.com/pyqt/examples/tree/master/multimediawidgets](https://github.com/pyqt/examples/tree/master/multimediawidgets).
    They provide more example code of using PyQt for media capture and playback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
