- en: Chapter 8. Contract Programming with Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with complex scenarios in which we will have
    to use instances that belong to more than one blueprint. We will take advantage
    of the interfaces to work with contract programming. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about interfaces in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how interfaces work in combination with classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare interfaces in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare classes that implement interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take advantage of the multiple inheritance of interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine class inheritance with interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how interfaces work in combination with classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine we have to develop a Web Service in which we have to work with
    two different types of character: comic and game characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A comic character must be drawable in a comic strip. A comic character must
    be able to provide a nickname and perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Draw a speech balloon, also known as speech bubble, with a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a thought balloon, also known as thought bubble, with a message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw a speech balloon with a message and another comic character, drawable in
    a comic strip, as a destination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A game character must be drawable in a game scene. A game character must be
    able to provide a full name and its current score. In addition, a game character
    must be able to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Set its desired location to a specific 2D position indicated by the *x* and
    *y* coordinates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the value for its *x* coordinate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the value for its *y* coordinate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw itself at its current position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether it intersects with another game character, drawable in a game
    scene
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to be able to work with objects that can be both a comic character and
    a game character; that is, they are both drawable in a comic strip and drawable
    in a game scene. However, we will also work with objects that will just be either
    a comic or game character; that is, they are drawable in a comic strip or drawable
    in a game scene.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to code a generic way of performing the previously described tasks.
    We want to make sure that many classes are capable of performing these tasks with
    a common interface. Each object that declares itself as drawable in a comic strip
    must define the tasks related to speech and thought balloons. Each object that
    declares itself as drawable in a game scene must define how to set its desired
    2D position, draw itself, and check whether it intersects with another game character,
    drawable in a game scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**SpiderDog** is a comic character, drawable in a comic strip, that has a specific
    way of drawing speech and thought balloons. **WonderCat** is both a comic and
    game character, drawable in a comic strip and also in a game scene. Thus, WonderCat
    must define all the tasks required by both character types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'WonderCat is a very versatile character, and it can use different costumes
    to participate in either games or comics with different names. WonderCat can also
    be hideable, powerable, or fightable:'
  prefs: []
  type: TYPE_NORMAL
- en: A hideable character is capable of being hidden. It can provide a specific number
    of eyes and must be able to show and hide itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A powerable character is capable of being powered. It can provide a spell power
    score value and use this spell power to make a hideable character disappear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fightable character is able to fight. It has a sword and can provide both
    the sword power and weight values. In addition, a fightable character can unsheathe
    his sword with or without a hideable character as a target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's imagine that Java 9 provides support for multiple inheritance. We need
    base blueprints to represent a comic character and a game character. Then, each
    class that represents any of these types of character can provide its implementation
    of the methods. In this case, comic and game characters are very different, and
    they don't perform similar tasks that might lead to confusion and problems for
    multiple inheritance. Thus, we can use multiple inheritance to create a `WonderCat`
    class that implements both comic and game character blueprints. In some cases,
    multiple inheritance is not convenient because similar blueprints might have methods
    with the same names, and it can be extremely confusing to use multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can use multiple inheritance to combine the `WonderCat` class
    with `Hideable`, `Powerable`, and `Fightable`. This way, we will have a `Hideable`
    + `WonderCat`, a `Powerable` + `WonderCat`, and a `Fightable` + `WonderCat`. We
    would be able to use any of them, `Hideable` + `WonderCat`, `Powerable` + `WonderCat`,
    or `Fightable` + `WonderCat`, as either a comic or game character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goals are simple, but we face a little problem: Java 9 doesn''t support
    the multiple inheritance of classes. Instead, we can use multiple inheritance
    with interfaces or combine interfaces with classes. So, we will use interfaces
    and classes to fulfill our previous requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we have been working with abstract classes and concrete
    classes. When we coded the abstract classes, we declared constructors, instance
    fields, instance methods, and abstract methods. The abstract classes had concrete
    instance methods mixed with abstract methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we don't need to provide implementation for any method; we just
    have to make sure that we provide the appropriate methods with specific names
    and arguments. You can think of an **interface** as a group of related abstract
    methods that a class must implement to be considered a member of the type identified
    with the interface name. Java 9 doesn't allow us to specify requirements for constructors
    or instance fields in interfaces. It is also important to take into account that
    an interface is not a class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In other programming languages, interfaces are known as protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a `Hideable` interface that specifies the following
    parameterless methods with empty bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getNumberOfEyes()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`appear()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disappear()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we define an interface, we create a new type. Hence, we can use the interface
    name to specify the required type for an argument. This way, instead of using
    classes as types, we will use interfaces as types, and we can use an instance
    of any class that implements the specific interface as an argument. For example,
    if we use `Hideable` as the required type for an argument, we can pass an instance
    of any class that implements the `Hideable` interface as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can declare interfaces that inherit from more than one interface; that is,
    interfaces support multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you must take into account some limitations for interfaces compared
    with abstract classes. Interfaces cannot specify requirements for constructors
    or instance fields because interfaces have to do with methods and signature. Interfaces
    can declare requirements for the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: Class constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java 8 added the possibility to add default methods to interfaces. They allow
    us to declare methods that actually provide an implementation. Java 9 keeps this
    feature alive.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is time to code the necessary interfaces in Java 9\. We will code the following
    five interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DrawableInComic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawableInGame`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hideable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Powerable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Fightable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some programming languages, such as C#, use `I` as a prefix for interfaces.
    Java 9 doesn't use this naming convention for interface names. Thus, if you see
    an interface named `IDrawableInComic`, it was probably coded by someone who has
    C# experience and transferred the naming convention to the Java land.
  prefs: []
  type: TYPE_NORMAL
- en: The following UML diagram shows the five interfaces that we will code with their
    required methods included in the diagram. Notice that we include the **<<interface>>**
    text before the class name in each diagram that declares an interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![Declaring interfaces](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines show the code for the `DrawableInComic` interface. The `public`
    modifier, followed by the `interface` keyword and the interface name, `DrawableInComic`,
    composes the interface declaration. As it happens with class declarations, the
    interface body is enclosed in curly brackets (`{}`). The code file for the sample
    is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The members declared in an interface have an implicit `public` modifier, and
    therefore, there is no need to specify `public` for each method declaration.
  prefs: []
  type: TYPE_NORMAL
- en: The `DrawableInComic` interface declared a `getNickName` method requirement,
    a `drawSpeechBalloon` method requirement overloaded twice, and a `drawThoughtBalloon`
    method requirement. The interface includes only the method declaration because
    the classes that implement the `DrawableInComic` interface will be responsible
    for providing the implementation of the `getNickName` method, the `drawThoughtBalloon`
    methods and the two overloads of the `drawSpeechBalloon` method. Note that there
    is no method body, as happened when we declared abstract methods for abstract
    classes. There is no need to use the `abstract` keyword to declare the methods
    because they are implicitly abstract.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the `DrawableInGame` interface. The code
    file for the sample is included in the `java_9_oop_chapter_08_01` folder, in the
    `example08_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DrawableInGame` interface declaration includes seven method requirements:
    `getFullName`, `getScore`, `getX`, `getY`, `setLocation`, `draw`, and `isIntersectingWith`.'
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the `Hideable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Hideable` interface declaration includes three method requirements: `getNumberOfEyes`,
    `show`, and `hide`.'
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the `Powerable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Powerable` interface declaration includes two method requirements: `getSpellPower`
    and `useSpellToHide`. As it happened in other method requirement declarations
    included in the previously declared interface, we use an interface name as the
    type of an argument within a method declaration. In this case, the `hideable`
    argument for the `useSpellToHide` method declaration is `Hideable`. Hence, we
    will be able to call the method with any class that implements the `Hideable`
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for the `Fightable` interface. The code file
    for the sample is included in the `java_9_oop_chapter_08_01` folder, in the `example08_01.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Fightable` interface declaration includes four method requirements: `getSwordPower`,
    `getSwordWeight`, and the two overloads of the `unsheathSword` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring classes that implement interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will declare a concrete class that specifies that it implements the
    `DrawableInComic` interface in its declaration in JShell. Instead of specifying
    a superclass, the class declaration includes the name of the previously declared
    `DrawableInComic` interface after the class name (`SiperDog`) and the `implements`
    keyword. We can read the class declaration as "the `SpiderDog` class implements
    the `DrawableInComic` interface." The code file for the sample is included in
    the `java_9_oop_chapter_08_01` folder, in the `example08_02.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java compiler will generate an error because the `SpiderDog` class is declared
    as a concrete class and doesn''t override all the abstract methods declared in
    the `DrawableInComic` interface. JShell displays us the following error, indicating
    that the first method declaration in the interface isn''t overridden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will replace the previous declaration of the empty `SuperDog` class
    with a class that tries to implement the `DrawableInComic` interface, but it still
    doesn't achieve its goal. The following lines show the new code for the `SuperDog`
    class. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Java compiler will generate many errors because the `SpiderDog` concrete
    class doesn't implement the `DrawableInComic` interface. JShell displays us the
    following error messages, indicating that the interface required many methods
    to be declared as `public` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The public `DrawableInComic` interface specified methods that are implicitly
    public. Thus, when we declare a class that doesn't declare the required members
    as `public`, the Java compiler generates errors and indicates that we cannot attempt
    to assign a weaker access privilege than the one required by the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we declare a class that specifies that it implements an interface,
    it must fulfill all the requirements specified in the interface. If it doesn't,
    the Java compiler will generate errors indicating which requirements aren't fulfilled,
    as it happened in the previous example. When we work with interfaces, the Java
    compiler makes sure that the requirements specified in them are honored in any
    class that implements them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will replace the previous declaration of the `SpiderDog` class with
    a class that really implements the `DrawableInComic` interface. The following
    lines show the new code for the `SpiderDog` class. The code file for the sample
    is included in the `java_9_oop_chapter_08_01` folder, in the `example08_04.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `SpiderDog` class declares a constructor that assigns the value of the required
    `nickName` argument to the `nickName` immutable protected field. The class implements
    the `getNickName` method that just returns the `nickName` immutable protected
    field. The class declares the code for the two versions of the `drawSpeechBalloon`
    method. Both methods call the protected `speak` method that prints a message with
    a specific format that includes the `nickName` value as a prefix. In addition,
    the class declares the code for the `drawThoughtBalloon` method that invokes the
    protected `think` method that also prints a message including the `nickName` value
    as a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: The `SpiderDog` class implements the methods declared in the `DrawableInComic`
    interface. The class also declares a constructor, a `protected` immutable field,
    and two `protected` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As long as we implement all the members declared in the interface or interfaces
    listed in the class declaration after the `implements` keyword, we can add any
    desired additional member to the class.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will declare another class that implements the same interface that the
    `SpiderDog` class implemented, that is, the `DrawableInComic` interface. The following
    lines show the code for the `WonderCat` class. The code file for the sample is
    included in the `java_9_oop_chapter_08_01` folder, in the `example08_04.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `WonderCat` class declares a constructor that assigns the value of the required
    `nickName` and `age` arguments to the `nickName` and `age` immutable fields. The
    class declares the code for the two versions of the `drawSpeechBalloon` method.
    The version that requires only a `message` argument uses the value of the `age`
    property to generate a different message when the `age` value is greater than
    `2`. In addition, the class declares the code for the `drawThoughtBalloon` and
    `getNickName` methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `WonderCat` class implements the methods declared in the `DrawableInComic`
    interface. However, the class also declares an additional immutable field, `age`,
    and a `getAge` method that aren't required by the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interfaces in Java 9 allow us to make sure that the classes that implement them
    define all the members specified in the interface. If they don't, the code won't
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of the multiple inheritance of interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 9 doesn't allow us to declare a class with multiple superclasses or base
    classes, so there is no support for multiple inheritance of classes. A subclass
    can inherit from just one class. However, a class can implement one or more interfaces.
    In addition, we can declare classes that inherit from a superclass and implement
    one or more interfaces. Hence, we can combine class-based inheritance with the
    implementation of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We want the `WonderCat` class to implement both the `DrawableInComic` and `DrawableInGame`
    interfaces. We want to be able to use any `WonderCat` instance as both a comic
    character and a game character. In order to do so, we must change the class declaration
    and add the `DrawableInGame` interface to the list of interfaces that the class
    implements and declare all the methods included in this added interface within
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the new class declaration that specifies that the `WonderCat`
    class implements both the `DrawableInComic` and the `DrawableInGame` interfaces.
    The class body remains without changes, and therefore, we don't repeat the code.
    The code file for the sample is included in the `java_9_oop_chapter_08_01` folder,
    in the `example08_05.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After we change the class declaration, the Java compiler will generate many
    errors because the new version of the `WonderCat` concrete class doesn't implement
    the `DrawableInGame` interface. JShell displays us the following error message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The new constructor assigns the value of the additional required `fullName`,
    `score`, `x`, and `y` arguments to the fields with the same names. Hence, we will
    need to specify these additional arguments whenever we want to create an instance
    of the `AngryCat` class. In addition, the class added the implementation of all
    the methods specified in the `DrawableInGame` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Combining class inheritance and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can combine class inheritance with the implementation of interfaces. The
    following lines show the code for a new `HideableWonderCat` class that inherits
    from the `WonderCat` class and implements the `Hideable` interface. Note that
    the class declaration includes the superclass (`WonderCat`) after the `extends`
    keyword and the implemented interface (`Hideable`) after the `implements` keyword.
    The code file for the sample is included in the `java_9_oop_chapter_08_01` folder,
    in the `example08_07.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result of the previous code, we have a new class named `HideableWonderCat`
    that implements the following three interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DrawableInComic`: This interface is implemented by the `WonderCat` superclass
    and inherited by `HideableWonderCat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DrawableInGame`: This interface is implemented by the `WonderCat` superclass
    and inherited by `HideableWonderCat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hideable`: This interface is implemented by `HideableWonderCat`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The constructor defined in the `HideableWonderCat` class adds a `numberOfEyes`
    argument to the argument list defined in the constructor declared in the `WonderCat`
    superclass. In this case, the constructor calls the constructor defined in the
    superclass by using the `super` keyword and then initializes the `numberOfEyes`
    immutable field with the value received in the `numberOfEyes` argument. The class
    implements the `getNumberOfEyes`, `show`, and `hide` methods required by the `Hideable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for a new `PowerableWonderCat` class that
    inherits from the `WonderCat` class and implements the `Powerable` interface.
    Note that the class declaration includes the superclass (`WonderCat`) after the
    `extends` keyword and the implemented interface (`Powerable`) after the `implements`
    keyword. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_07.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As it happened with the `HideableWonderCat` class, the new `PowerableWonderCat`
    class implements three interfaces. Two of these interfaces are implemented by
    the `WonderCat` superclass and inherited by `HideableWonderCat`: `DrawableInComic`
    and `DrawableInGame`. The `HideableWonderCat` class adds the implementation of
    the `Powerable` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor defined in the `PowerableWonderCat` class adds a `spellPower`
    argument to the argument list defined in the constructor declared in the `WonderCat`
    superclass. In this case, the constructor calls the constructor defined in the
    superclass by using the `super` keyword and then initializes the `spellPower`
    immutable field with the value received in the `spellPower` argument. The class
    implements the `getSpellPower` and `useSpellToHide` methods required by the `Powerable`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `hide` method receives a `Hideable` as an argument. Hence, any instance
    of `HideableWonderCat` would qualify as an argument for this method, that is,
    any instance of any class that conforms to the `Hideable` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines show the code for a new `FightableWonderCat` class that
    inherits from the `WonderCat` class and implements the `Fightable` interface.
    Note that the class declaration includes the superclass (`WonderCat`) after the
    `extends` keyword and the implemented interface (`Fightable`) after the `implements`
    keyword. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_07.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As it happened with the two previously coded classes that are inherited from
    the `WonderCat` class and implemented interfaces, the new `FightableWonderCat`
    class implements three interfaces. Two of these interfaces are implemented by
    the `WonderCat` superclass and inherited by `FightableWonderCat`: `DrawableInComic`
    and `DrawableInGame`. The `FightableWonderCat` class adds the implementation of
    the `Fightable` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor defined in the `FightableWonderCat` class adds the `swordPower`
    and `swordWeight` arguments to the parameters list defined in the constructor
    declared in the `WonderCat` superclass. In this case, the constructor calls the
    constructor defined in the superclass by using the `super` keyword and then initializes
    the `swordPower` and `swordWeight` immutable fields with the value received in
    the `swordPower` and `swordWeight` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The class implements `getSpellPower`, `getSwordWeight`, and the two versions
    of the `unsheathSword` method required by the `Fightable` interface. The two versions
    of the `unsheathSword` method call the protected `printSwordInformation` method
    and the overloaded version that receives a `Hideable` instance as an argument
    prints an additional message with the number of eyes of the `Hideable` instance
    that the sword has as a target.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes the interfaces that each of the classes we created
    implements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class name | Implements the following interfaces |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SpiderDog` | `DrawableInComic` |'
  prefs: []
  type: TYPE_TB
- en: '| `WonderCat` | `DrawableInComic` and `DrawableInGame` |'
  prefs: []
  type: TYPE_TB
- en: '| `HideableWonderCat` | `DrawableInComic`, `DrawableInGame`, and `Hideable`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `PowerableWonderCat` | `DrawableInComic`, `DrawableInGame`, and `Powerable`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FightableWonderCat` | `DrawableInComic`, `DrawableInGame`, and `Fightable`
    |'
  prefs: []
  type: TYPE_TB
- en: The following simplified UML diagram shows the hierarchy tree for the classes
    and their relationship with interfaces. The diagram doesn't include any members
    for the interfaces and classes to make it simpler to understand the relationships.
    The dashed lines that end with an arrow indicate that the class implements the
    interface indicated by the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining class inheritance and interfaces](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following UML diagram shows the interfaces and the classes with all their
    members. Notice that we don''t repeat the members declared in the interfaces that
    the classes implement to make the diagram simpler and to avoid repeating information.
    We can use the diagram to understand all the things that we will analyze with
    the next code samples based on the usage of these classes and the previously defined
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining class inheritance and interfaces](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines create one instance of each of the previously created classes.
    The code file for the sample is included in the `java_9_oop_chapter_08_01` folder,
    in the `example08_08.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the instance name and its class name for the
    instances we have created with the previous code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Instance name | Class name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `spiderDog1` | `SpiderDog` |'
  prefs: []
  type: TYPE_TB
- en: '| `wonderCat1` | `WonderCat` |'
  prefs: []
  type: TYPE_TB
- en: '| `hideableWonderCat1` | `HideableWonderCat` |'
  prefs: []
  type: TYPE_TB
- en: '| `powerableWonderCat1` | `PowerableWonderCat` |'
  prefs: []
  type: TYPE_TB
- en: '| `fightableWonderCat1` | `FightableWonderCat` |'
  prefs: []
  type: TYPE_TB
- en: Now, we will evaluate many expressions that use the `instanceof` keyword to
    determine whether the instances are an instance of the specified class or of a
    class that implements a specific interface. Note that all the expressions are
    evaluated to `true` because the type specified at the right-hand side after the
    `instanceof` keyword for each instance is its main class, its superclass, or an
    interface that the main class implements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `powerableWonderCat1` is an instance of `PowerableWonderCat`.
    In addition, `powerableWonderCat1` belongs to `WonderCat` because `WonderCat`
    is the superclass of the `PowerableWonderCat` class. It is also true that `powerableWonderCat1`
    implements three interfaces: `DrawableInComic`, `DrawableInGame`, and `Powerable`.
    The superclass of `PowerableWonderCat`, `WonderCat`, implements the following
    two interfaces: `DrawableInComic` and `DrawableInGame`. Hence, `PowerableWonderCat`
    inherits the implementation of the interfaces. Finally, the `PowerableWonderCat`
    class not only inherits from `WonderCat`, but also implements the `Powerable`
    interface.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0033_split_000.html#VF2I1-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 3. Classes and Instances"), *Classes and Instances*, we learned that
    the `instanceof` keyword allows us to test whether an object is of the specified
    type. This type can be either a class or an interface. If we execute the following
    lines with many expressions in JShell, all of them will print `true` as a result
    of their evaluation. The code file for the sample is included in the `java_9_oop_chapter_08_01`
    folder, in the `example08_08.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two screenshots show the results of evaluating the previous expressions
    in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining class inheritance and interfaces](img/00083.jpeg)![Combining class
    inheritance and interfaces](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class can implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only one interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or more interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A maximum of two interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When a class implements an interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can also inherit from a superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It cannot inherit from a superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can inherit only from an abstract superclass but not from concrete superclasses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can inherit from a superclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cannot inherit from either a superclass or another interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can inherit from another interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines declares a class named `WonderDog` that implements
    the `Hideable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class WonderDog extends Hideable {`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class WonderDog implements Hideable {`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`public class WonderDog: Hideable {`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An interface is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An abstract class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the declaration and combination of multiple
    blueprints to generate a single instance. We declared interfaces that specified
    the required methods. Then, we created many classes that implemented single and
    multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We combined class inheritance with the implementation of interfaces. We realized
    that a single class can implement multiple interfaces. We executed code in JShell
    to understand that a single instance belongs to class types and to interface types.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about interfaces and the basics for contract programming,
    we are ready to work with advanced contract programming scenarios, which is the
    topic we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
