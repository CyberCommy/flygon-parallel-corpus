- en: Android Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we started working with concurrency mechanisms in Android.
    We made great progress. However, our journey to Android concurrency mechanisms
    is not over yet. We have to present, perhaps, the most important part of the Android
    Framework--Android services. In this chapter, we will explain what are services,
    and when and how to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Service categorization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of Android services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the main application service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the intent service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service categorization
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we define the Android service categorization and dive deeper into each
    type, we must answer the question of what Android service really is. Well, **Android
    service** is a mechanism provided by the Android Framework by which we can move
    the execution of long running tasks to the background. Android service provides
    some nice additional features that can make a developer's work more flexible and
    easier. To explain how it will make our development easier, we will create a service
    by extending our Journaler application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Android service is an application component that does not have any UI. It can
    be started by any Android application component and continue running as long as
    it's needed, even if we leave our application or kill it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main types of Android services:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Foreground
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bound
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Foreground Android services
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A foreground service performs tasks that are noticeable to the end user. These
    services must display a status bar icon. They continue running even when there
    is no interaction with the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Background Android services
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike foreground services, background services perform tasks that aren't noticed
    by the end user. For example, we will perform synchronization with our backend
    instance. The user does not need to know about our progress. We decided not to
    bother the user with that. Everything will be performed silently in the background
    of our application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Bound Android services
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application components can bind to a service and trigger different tasks
    to be executed. Interacting with a service in Android is very simple. A component
    binds to a service and, as long there is at least one such component, the service
    keeps running. When there are no components bound to a service, the service is
    destroyed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create a background service that is running in the background
    and have the ability to bind to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Android service basics
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define Android service, you have to extend the `Service` class. We must
    override some of the following methods so the service is functioning:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '`onStartCommand()`: This method is executed when the `startService()` method
    is triggered by some Android component. After the method is executed, Android
    service is started and can run in the background indefinitely. To stop this service,
    you must execute the `stopService()` method that has an opposite functionality
    to the `startService()` method.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBind()`: To bind to the service from another Android component, use the
    `bindService()` method. After we bind, the `onBind()` method is executed. In your
    service implementation of this method, you must provide an interface that clients
    use to communicate with the service by returning an `Ibinder` class instance.
    Implementing this method is not optional, but if you don''t plan to bind to the
    service, just return `null`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onCreate()`: This method is executed when the service is created. It is not
    executed if the service is already running.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onDestroy()`: This method is executed when the service is destroyed. Override
    this method and perform all cleanup tasks for your service here.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onUnbind()`: This method is executed when we unbind from the service.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring your service
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare your service, you need to add its class to the Android Manifest.
    The following code snippet explains what the service definition in Android Manifest
    should look like:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we defined the `MainService` class that extends the `Service`
    class and it's located under the `service` package. The exported flag is set to
    `false`, which means that the `service` will run in the same process as our application.
    To run your  `service` in a separate process, set this flag to `true`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to note that the `Service` class is not the only one you can
    extend. The `IntentService` class is also available. So, what do we get when we
    extend it? `IntentService` represents a class derived from the `Service` class.
    `IntentService` uses the worker thread to process requests one by one. We must
    implement the `onHandleIntent()` method for that purpose. This is what it looks
    like when the `IntentService` class is extended:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s go back on extending the `Service` class and focus on it. We will override
    `onStartCommand()` method to look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, what does the `START_STICKY` return result mean? If it happens that our
    service is killed by the system, or we kill the application to which the service
    belongs, it will start again. Opposite of this is `START_NOT_STICKY`; in that
    case, the service will not be recreated and restarted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Starting the service
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start the service, we need to define the intent that will represent it.
    This is an example on how the service can be started:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `ctx` represents any valid instance of the Android `Context` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the service
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To stop the service, execute the `stopService()` method from the Android `Context`
    class like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Binding to Android service
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **bound service** is the service that allows Android components to bind to
    it. To perform binding, we must call the `bindService()` method. When you want
    to interact with the service from activities or other Android components, service
    binding is necessary. For bind to work, you must implement the `onBind()` method
    and return an `IBinder` instance. If there are no interested parties anymore,
    and all of them are unbound, Android destroys the service. For this type of service,
    you do not need to perform the stop routine.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the service
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already mentioned that `stopService` will stop our service. Anyway, we can
    achieve the same by calling `stopSelf()` within our service implementation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Service lifecycle
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered and explained all important methods that are executed during the
    lifetime of an Android service. Service has its own lifecycle as all other Android
    components. Everything we mentioned so far is represented in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38a59665-0d7e-433a-8e7a-5188c64ad0cd.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Now, as we have a basic understanding of the Android services, we will create
    our own service and extend the Journaler application. This service will be repeatedly
    extended later in other chapters with more code. So, pay attention to every line
    as it can be crucial.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Defining the main application service
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you already know, our application is dealing with Notes and Todos. The current
    application implementation keeps our data locally stored in the SQLite database.
    This data will be synchronized with the backend instance running on some remote
    server. All operations related to the synchronization will be performed silently
    in the background of our application. All responsibility will be given to the
    service, which we will define now. Create a new package called `service` and a
    new class `MainService` that will extend the Android `service` class. Make sure
    your implementation looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s explain our main service. As you already know, we will extend Android''s
    `Service` class to get all service functionality. We also implemented the `DataSynchronization`
    interface that will describe the main functionality of our service, which is synchronization.
    Please refer to the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, we defined the implementation for the `synchronize()` method that will actually
    simulate real synchronization. Later, we will update this code to perform real
    backend communication.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: All important lifecycle methods are overridden. Pay attention to the `bind()`
    method! This method will return an instance of binder that is produced by calling
    the `getServiceBinder()` method. Thanks to the `MainServiceBinder` class, we will
    expose our `service` instance to the end user that will be able to trigger the
    synchronize mechanism whenever it is needed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization is not triggered just by the end user, but also automatically
    by the service itself. We trigger synchronization when a service is started and
    when it is destroyed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important point for us is the starting and stopping of `MainService`.
    Open your `Journaler` class that represents your application and apply this update:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the Journaler application is created, `MainService` will be started. We
    will also add one small optimization. If it happens that our application gets
    low on memory, we will stop our `MainService` class. Since the service is started
    as sticky, if we explicitly kill our application, the service will restart.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: So far, we covered the service starting and stopping and its implementation.
    As you probably remember our mockup, at the bottom of our application drawer,
    we planned to put one more item. We planned to have the synchronize button. Triggering
    this button would do synchronization with the backend.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add that menu item and connect it with our service. Let''s do some
    preparation first. Open the `NavigationDrawerItem` class and update it as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We introduced the `enabled` parameter. Like this, some of our application drawer
    items can be disabled if needed. Our synchronize button will be disabled by default
    and enabled when we bind to the `main` service. These changes must affect `NavigationDrawerAdapter`
    too. Please refer to the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we will update our `MainActivity` class as follows, so the synchronization
    button can trigger synchronization:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will bind or unbind the `main` service whether our main activity status is
    active or not. To perform binding, we need the `ServiceConnection` implementation
    as it will enable or disable the synchronization button depending on the binding
    state. Also, we will maintain the `main` service instance depending on the binding
    state. The synchronization button will have access to the `service` instance and
    trigger the `synchronize()` method when clicked.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Defining the intent service
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have our `main` service running and responsibility defined. We will now make
    more improvements to our application by introducing one more service. This time,
    we will define the `intent` service. The `intent` service will take over the responsibility
    for the execution of the database CRUD operations. Basically, we will define our
    `intent` service and perform refactoring of the code we already have.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new class inside the `service` package called `DatabaseService`.
    Before we put the whole implementation, we will register it in the Android Manifest
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The service will receive intents, obtain the operation, and note the instance
    from it. Depending on the operation, the proper CRUD operation will be triggered.
    To pass a `Note` instance to `Intent`, we must implement `Parcelable` so that
    the data is passed efficiently. For example, comparing to `Serializable`, `Parcelable`
    is much faster. The code, for this purpose, is heavily optimized. We will perform
    explicit serialization without using reflection. Open your `Note` class and update
    it as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Note` class will be serialized and deserialized efficiently when passed
    via `intent` to `DatabaseService`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of puzzle is changing the code, which currently performs CRUD
    operations. Instead of directly accessing the `Db` class from our `NoteActivity`
    class, we will create `intent` and fire it so our service handles the rest of
    the work for us. Open `NoteActivity` class and update the code like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the change was really simple. Build your application and run
    it. As you create or update your `Note` class, you will notice logs about the
    database operation we perform. Also, you will notice the `DatabaseService` lifecycle
    methods being logged.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，改变真的很简单。构建你的应用程序并运行它。当你创建或更新你的`Note`类时，你会注意到我们执行的数据库操作的日志。此外，你还会注意到`DatabaseService`的生命周期方法被记录下来。
- en: Summary
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You mastered Android services and improved the application
    significantly! In this chapter, we explained what Android services are. We also
    explained each type of Android service and gave examples of use. Now, when you
    did these implementations, we encourage you to think about at least one more service
    that can take over some existing part of the application or to introduce something
    completely new. Play with the services and try to think about the benefits they
    can give you.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你掌握了Android服务并显著改进了应用程序！在本章中，我们解释了什么是Android服务。我们还解释了每种类型的Android服务，并举例说明了它们的用途。现在，当你完成这些实现时，我们鼓励你至少考虑一个可以接管应用程序的某个现有部分或引入全新内容的服务。玩转这些服务，并尝试思考它们能给你带来的好处。
