- en: Chapter 5. Building a Canvas Games Masterclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored some basic canvas context drawing APIs
    and created a game named Untangle. In this chapter, we are going to enhance the
    game by using some other context drawing APIs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Fill our game objects with gradient color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill text in the canvas with custom webfont
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw images in Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animate a sprite sheet image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And build multiple canvas layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot is a preview to the final result that we are going
    to build through this chapter. It is a canvas-based Untangle game with an animated
    game guideline and several subtle details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Canvas Games Masterclass](img/1260_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So let's get on with it...
  prefs: []
  type: TYPE_NORMAL
- en: Filling shapes with gradient color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered filling solid color in the last chapter. Canvas can do far more when
    filling shapes. We can fill the shape with both linear and radial gradient.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Drawing a gradient color background to the Untangle game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's improve the black solid background we have now. How about drawing a gradient
    from top to bottom?
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Untangle game we created in the last chapter as a starting point.
    Open the `html5games.untangle.js` JavaScript file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code in the `gameloop` function after clearing the canvas
    to draw the **gradient** background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Save the files and preview the `index.html` in the browser. The background should
    be a linear gradient with black on top which gradually becomes grey at the bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Drawing a gradient color background to the Untangle game](img/1260_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just filled a rectangle with a **linear gradient** color. To fill linear
    gradient color, all we need to do is set the starting point and ending point of
    the gradient. Then we add several color stops between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we use the linear gradient function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x1 | The starting point of the gradient. |'
  prefs: []
  type: TYPE_TB
- en: '| y1 |   |'
  prefs: []
  type: TYPE_TB
- en: '| x2 | The ending point of the gradient. |'
  prefs: []
  type: TYPE_TB
- en: '| y2 |   |'
  prefs: []
  type: TYPE_TB
- en: Adding color stops in the gradient color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is not enough to just have the starting and ending point. We also need to
    define what color we use and how it is applied to the gradient. It is called a
    **color stop** in gradient. We can add a color stop to the gradient by using the
    following `gradient` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| position | A floating number between 0 and 1. | Position 0 means the color
    stops at the starting point and 1 means it stops at the ending point. Any number
    between 0 and 1 means it stops in between the starting and ending point.For example,
    0.5 means a half and 0.33 means 30 percent away from the starting point. |'
  prefs: []
  type: TYPE_TB
- en: '| color | The color style of that color stop. | The color style shares the
    same syntax from the CSS color styling. We may use the HEX expression, such as
    #FFDDAA. Or other color styles such as RGBA color name. |'
  prefs: []
  type: TYPE_TB
- en: 'The follow screenshot shows a side-by-side comparison between a linear gradient
    setting and the result drawing. The starting point and ending point defines the
    scope and the angle of the gradient. The color stops define how the color mixes
    between the gradient scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding color stops in the gradient color](img/1260_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Adding color stop with opacity**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set an opacity value to the color stop by using the RGBA function. The
    following code tells the gradient to start by using red color with half opacity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gradient.addColorStop(0, "rgba(255, 0, 0, 0.5)")`;'
  prefs: []
  type: TYPE_NORMAL
- en: Filling radial gradient color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two types of gradients in the Canvas drawing API. The one we just
    used is called linear gradient. The other one is **radial gradient**. The radial
    gradient fills the gradient from one circle to another circle.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Filling the circles with radial gradient color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that we now fill our dragging circles to radial gradient. We will change
    the solid yellow circles to white-yellow gradient:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5game.untangle.js` JavaScript file. We are going to modify the
    code we used to draw the circle in the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we draw the circle path with the `arc` function and before we fill it
    we replace the original solid color style setting to the following radial gradient
    color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save the modified file and preview the `index.html` in a web browser. The circles
    are now filled with radial gradient color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following screenshot I''ve scaled up the drawing to 200 percent to better
    demonstrate the radial gradient in the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action Filling the circles with radial gradient color](img/1260_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just made the dragging circles look more realistic by filling a radial gradient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we create a radial gradient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x1, y1 | The center of the starting circle in x and y in the canvas coordinate.
    |'
  prefs: []
  type: TYPE_TB
- en: '| r1 | The radius of the starting circle. |'
  prefs: []
  type: TYPE_TB
- en: '| x2, y2 | The center of the ending circle in x and y in the canvas coordinate.
    |'
  prefs: []
  type: TYPE_TB
- en: '| r2 | The radius of the ending circle. |'
  prefs: []
  type: TYPE_TB
- en: 'The following screenshot shows a side-by-side comparison between a radial gradient
    setting and the final result drawing in canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/1260_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The radial gradient blends the color from the starting circle to the ending
    circle. In this gradient circle, the starting circle is a small circle in the
    center and the ending circle is the outermost circle. There are three color stops.
    A white color stops at both the starting and ending circle; another dark color
    stops 90 percent away from the starting circle.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero Filling gradients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We add color stops to the gradients to define how the colors blend. What happens
    if we forget to add any color stops to the gradient and fill a rectangle? What
    if we only define one color stop? Try experimenting with the color stop settings.
  prefs: []
  type: TYPE_NORMAL
- en: In the radial gradient example, the small starting circle is inside the bigger
    ending circle. What happens if the starting circle is bigger than the ending one?
    How about if the starting circle is not inside the ending circle? That is, what
    happens if the two circles do not overlap?
  prefs: []
  type: TYPE_NORMAL
- en: Drawing text in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now we want to show the progress level directly inside the canvas. Canvas
    provides us with methods to draw text inside canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Displaying the progress level text inside the canvas element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue using our Untangle game. Open the `html5games.untangle.js`
    JavaScript file in text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let''s make the level progress percentage a global variable so we can
    use it in different places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code after the canvas drawing code in the `gameloop` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and preview the `index.html` in a web browser. We will see that
    the text is now drawn inside the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Displaying the progress level text inside the canvas element](img/1260_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have just drawn the title and the level progress text in our canvas-based
    game. We draw text in canvas by using the **fillText** function. The following
    table shows how we use the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| string | The text that we are going to draw. |'
  prefs: []
  type: TYPE_TB
- en: '| x | The x coordinate that the text draws. |'
  prefs: []
  type: TYPE_TB
- en: '| y | The y coordinate that the text draws. |'
  prefs: []
  type: TYPE_TB
- en: This is the basic setting to draw a text. There are several more drawing context
    properties to set up the text drawing.
  prefs: []
  type: TYPE_NORMAL
- en: '| Context properties | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `context.font` | The font style of the text. | It shares the same syntax
    we used to declare font style in CSS. For example, the following code sets the
    font style to 20 pixels bold with Arial typeface:ctx.font = "bold 20px Arial";
    |'
  prefs: []
  type: TYPE_TB
- en: '| `context.textAlign` | The text alignment. | The **alignment** defines how
    the text aligns. It can be one of the following values:startendleftrightcenterFor
    instance, if we are going to place a text on the right edge of the canvas. Using
    `left` alignment means we need to calculate text width in order to know the x
    coordinate of the text.When using right alignment in this case, all we need to
    do is set the x position directly to the canvas width. The text will then automatically
    be placed on the right edge of the canvas. |'
  prefs: []
  type: TYPE_TB
- en: '| `context.textBaseline` | The text baseline. | The following lists the common
    value of a **textBaseline:**topmiddlebottomalphabetSimilar to the text alignment,
    the `bottom` **baseline** is useful when we want to place our text at the bottom
    of the canvas. The y position of the `fillText` function is based on the bottom
    baseline of the text instead of the top.The `alphabet` baseline aligns the y position
    based on the lower case alphabet. The following screenshot shows our text drawing
    with **alphabet** baseline. |'
  prefs: []
  type: TYPE_TB
- en: '![What just happened?](img/1260_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please beware that the text drawing in canvas is treated as bitmap image data.
    That means visitors cannot select the text; search engines cannot index the text;
    we cannot search them. For this reason, we should think carefully whether we want
    to draw the text inside a canvas or just place them directly in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz Drawing text in canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are going to draw a text close to the bottom rightcorner of the canvas
    which alignment and baseline setting is better?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Left alignment, bottom baseline.
  prefs: []
  type: TYPE_NORMAL
- en: b. Center alignment, alphabet baseline.
  prefs: []
  type: TYPE_NORMAL
- en: c. Right alignment, bottom baseline.
  prefs: []
  type: TYPE_NORMAL
- en: d. Center alignment, middle baseline.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to make a realistic book with a flipping effect with the latest
    open web standard. Which of the following settings is better?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Draw the realistic book in canvas, including all the text and the flipping
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: b. Put all text and content in DOM and draw the realistic page-flipping effect
    in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Using embedded web font inside canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used custom font in our memory matching game in the previous chapter. The
    custom font embedding also worked in the canvas. Let's conduct an experiment on
    drawing a custom font in our Untangle game in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Embedding Google Web Font into the canvas element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s draw the canvas texts with a handwriting style font:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, go to the Google Font Directory and choose a handwriting style font.
    I used the font **Rock Salt** and you can get it from the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Google font directory provides a CSS link code that we can add to our game
    in order to embed the font. Add the following CSS link to the head of `index.html:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing is to use the font. We open the `html5games.untangle.js` JavaScript
    file and modify the context `font` property to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is time to open our game in the web browser to test the result. The text
    drawn in the canvas now is using the font we choose in the Google font directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Embedding Google Web Font into the canvas element](img/1260_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just chose a web font and embedded it into the canvas when drawing text.
    It shows that we can style the font family of the filled text in canvas just like
    other DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes the width of the text varies in different font families although
    they have the same word count. In this case, we can use the `measureText` function
    to get the width of the text we draw. The following link to the Mozilla Developer
    Network explains how we can use the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText()](http://https://developer.mozilla.org/en/Drawing_text_using_a_canvas#measureText())'
  prefs: []
  type: TYPE_NORMAL
- en: Drawing images in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have drawn some text inside canvas. What about drawing an image? Yes. Drawing
    images and image manipulation is one big feature that canvas has.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Adding graphics to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to draw a blackboard background to the game:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the graphic files from the code example bundle or the following URL.
    The graphics files include all graphics that we need in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Put the newly downloaded graphics files into a folder named `images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will load an image and loading means it may take a while until the image
    is loaded. Ideally, we should not start the game until all game assets are loaded.
    In this case, we can prepare a splash screen with loading words to let the player
    know the game is going to start later. Add the following code in the jQuery `ready`
    function after clearing the canvas context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it is time to really load the image. There is a `board.png` in the graphics
    file we just downloaded. It is a blackboard graphics we will draw to the canvas
    as background. Add the following code after the code we just added in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `gameloop` function, we draw the image into the canvas after clearing
    the context and before drawing anything else. Since the image loading takes time,
    we also need to ensure it is loaded before drawing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We had set up a `levels` array to store the level data including the initial
    circles position. Some circles are now overlapped with the border of the background
    image so we may want to alter the circles position. Update the circles array of
    level 2 with the following new values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Also we need to adjust the position of the level progress text. Modify the
    `fill text` function calling as the following code with a different position value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, we do not want a background color set to the canvas now because we have
    a PNG background with a transparent border. Open the `untangle.css` file and remove
    the background property in canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now save all files and open the `index.html` in the web browser. The background
    should be there and the handwritten fonts should match our blackboard theme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Adding graphics to the game](img/1260_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just drew an image inside the canvas element.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common ways to draw an image on canvas. We can either reference
    an existing `img` tag or load the image on the fly in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how we reference the existing image tag in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we have the following `img` tag in HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can draw the image in canvas by using the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another code snippet to load the image without attaching the `img`
    tag into DOM. If we load the image inside JavaScript, we need to make sure the
    image is loaded before drawing it on canvas. Therefore, we draw the image after
    the `onload` event of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The order meters when setting the onload event handler and assigning the
    image src**'
  prefs: []
  type: TYPE_NORMAL
- en: When we assign the `src` property to the image and if the image is cached by
    the browser, some browsers fire the `onload` event immediately. If we place the
    `onload` event handler after assigning the `src` property, we may miss it because
    it is fired before we set the event handler.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we used the latter approach. We create an Image object and load
    the background. When the image is loaded, we start the game loop and thus start
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another event that we should handle when loading the image is the `onerror`
    event. It is especially useful when we are accessing extra network data. We have
    the following code snippet to check the error in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The error loading now only displays a message in the console. The console is
    normally not viewed by players. How about designing an alert dialog or some other
    approaches to tell players that the game failed to load the game assets?
  prefs: []
  type: TYPE_NORMAL
- en: Using the drawImage function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three behaviors to draw an image in the canvas. We can draw the image
    without any modification on a given coordinate, we can also draw the image with
    a scaling factor on a given coordinate, or we can even crop the image and draw
    only the clipping region.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drawImage` function accepts several arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| image | The image reference that we are going to draw. | We either get the
    image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  prefs: []
  type: TYPE_TB
- en: '| x | The x position to place the image in canvas coordinate. | The x and y
    coordinate is where we place the image with respect to its top-left corner. |'
  prefs: []
  type: TYPE_TB
- en: '| y | The y position to place the image in canvas coordinate. |   |'
  prefs: []
  type: TYPE_TB
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| image | The image reference that we are going to draw. | We either get the
    image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  prefs: []
  type: TYPE_TB
- en: '| x | The x position to place the image in canvas coordinate. | The x and y
    coordinate is where we place the image with respect to its top-left corner. |'
  prefs: []
  type: TYPE_TB
- en: '| y | The y position to place the image in canvas coordinate. |   |'
  prefs: []
  type: TYPE_TB
- en: '| width | The width of the final drawn image. | We are applying scale to the
    image if the width and height is not the same as the original image. |'
  prefs: []
  type: TYPE_TB
- en: '| height | The height of the final drawn image. |   |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| Argument | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| image | The image reference that we are going to draw. | We either get the
    image reference by getting an existing `img` element or creating a JavaScript
    `Image` object. |'
  prefs: []
  type: TYPE_TB
- en: '| sx | The x coordinate of the top-left corner of the clipping region. | The
    clipping x, y, width, height together defines a rectangular clipping area. The
    given image is clipped by this rectangle. |'
  prefs: []
  type: TYPE_TB
- en: '| sy | The y coordinate of the top-left corner of the clipping region. |  
    |'
  prefs: []
  type: TYPE_TB
- en: '| sWidth | The width of the clipping region. |   |'
  prefs: []
  type: TYPE_TB
- en: '| sHeight | The height of the clipping region. |   |'
  prefs: []
  type: TYPE_TB
- en: '| Argument | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| dx | The x position to place the image in canvas coordinate. | The x and
    y coordinate is where we place the image with respect to its top-left corner.
    |'
  prefs: []
  type: TYPE_TB
- en: '| dy | The y position to place the image in canvas coordinate. |   |'
  prefs: []
  type: TYPE_TB
- en: '| width | The width of the final drawn image. | We are applying scale to the
    clipped image if the width and height is not the same as the clipping dimension.
    |'
  prefs: []
  type: TYPE_TB
- en: '| height | The height of the final drawn image. |   |'
  prefs: []
  type: TYPE_TB
- en: Have a go hero Optimizing the background image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example, we draw the blackboard image as background in every call of
    the `gameloop` function. Since our background is static and does not change along
    the time, clearing it and redrawing it again and again is wasting CPU resources.
    How can we optimize this performance issue?
  prefs: []
  type: TYPE_NORMAL
- en: Decorating the canvas-based game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have enhanced the canvas game with gradients and images. Before moving forward,
    let's decorate the web page of our canvas game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Adding CSS styles and images decoration to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to build a center-aligned layout with a game title:'
  prefs: []
  type: TYPE_NORMAL
- en: We embed another font from the Google font directory to style the normal body
    text. Add the following CSS link within the `head` in `index.html:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is easier for us to style the layout with one grouping DOM element. We put
    all the elements inside the body into a section with `id` page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s apply CSS to the page layout. Replace existing content in the `untangle.css`
    file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the header text in the ribbon. Showing the title again in canvas
    seems redundant. Let''s remove the following line of code which draws the title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It is time to save all the files and preview it in the web browser. We should
    see a title ribbon and a well-styled layout that is center-aligned. The following
    screenshot shows the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Adding CSS styles and images decoration to the game](img/1260_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just decorated the web page that contains our canvas-based game. Although
    our game is based on canvas drawing, it does not restrict us from decorating the
    whole web page with graphics and CSS styles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Default background of the canvas element
  prefs: []
  type: TYPE_NORMAL
- en: The default background of the canvas element is transparent. If we do not set
    any background CSS style of the canvas, it will be transparent. It is useful when
    our drawing is not a rectangle. In this example, the textured layout background
    shows within the canvas region.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz Styling a canvas background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we set the canvas background to be transparent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a. Set the background color to #ffffff.'
  prefs: []
  type: TYPE_NORMAL
- en: b. Do nothing. It is transparent by default.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a sprite sheet in canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first used **sprite sheet** images in Chapter 3, *Building a Memory Matching
    Game in CSS3*, when displaying a deck of playing cards.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Making a game guide animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a graphics file named `guide_sprite.png` in the images folder. It is
    a game guideline graphic that contains each step of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action Making a game guide animation](img/1260_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's draw this guide into our game with **animations:**
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.untangle.js` JavaScript file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the jQuery `ready` function add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the following function to move the current frame to the next frame every
    500 meters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the `gameloop` function, we draw the guide animation according to the current
    frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s watch the animation in the web browser by opening the `index.html`.
    The following screenshot demonstrates the animation of the game guideline. The
    guideline animation will play and loop until the player levels up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Making a game guide animation](img/1260_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can draw only a region of an image when using the `drawImage` context function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the process of the animation step by
    step. The rectangle is the clipping region. We used a variable named `guideFrame`
    to control which frame to show. The width of each frame is 80\. Therefore, we
    get the x position of the clipping region by multiplying the width and the current
    frame number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `guideFrame` variable is updated every 500 meters by the following `guideNextFrame`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![What just happened?](img/1260_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Animating a sprite is a commonly used technique when developing games. There
    are some benefits of using sprite animation when developing games in traditional
    video games. The reasons may not apply to the web game development but we have
    other benefits of using sprite sheet animation:'
  prefs: []
  type: TYPE_NORMAL
- en: All frames are loaded as one file so the whole animation is ready once the sprite
    file is loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting all frames into one file means we can reduce the HTTP request from the
    web browser to the server. If each frame is a file, the browser requests the file
    many times while now it just requests one file and uses one HTTP request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting different images into one file also helps reduce the duplicate file's
    header, footer, and meta data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting all frames into one image means we can easily clip the image to display
    any frame without the complex code to change the image source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is usually used in character animation. The following screenshot is a **sprite
    animation** of an angry cat that I used in an HTML5 game named Neighbours ([http://gamedesign.cc/html5games/neighbours/](http://gamedesign.cc/html5games/neighbours/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/1260_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We built the sprite sheet animation by clipping the frame and setting up the
    timer ourselves in this example. When working with a lot of animations, we may
    want to use some third party sprite animation plugin or create our own canvas
    sprite animation to better reuse and manage the logic code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sprite animation** is an important topic in HTML5 games development and there
    are many online resources discussing this topic. The following links are some
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: The sprite animation tutorial ([http://codeutopia.net/blog/2009/08/21/using-canvas-to-do-bitmap-sprite-animation-in-javascript/](http://codeutopia.net/blog/2009/08/21/using-canvas-to-do-bitmap-sprite-animation-in-javascript/))
    from CodeUtopia discusses how we can make a sprite object from scratch and use
    it to animate a sprite.
  prefs: []
  type: TYPE_NORMAL
- en: The sprite animation demo ([http://www.johnegraham2.com/web-technology/html-5-canvas-tag-sprite-animation-demo/](http://www.johnegraham2.com/web-technology/html-5-canvas-tag-sprite-animation-demo/))
    by John Graham provides another sprite object to animate a sprite in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The Spritely ([http://www.spritely.net/](http://www.spritely.net/)), on the
    other hand, provides sprite animation over the DOM element with CSS. It is useful
    when we want to animate a sprite without using canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multi-layers canvas game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now all things are drawn into the context and it has no other state to distinguish
    the drawn items. We may split the canvas game into different layers and code the
    logic to control and draw each layer at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action Dividing the game into four layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to separate our Untangle game into four layers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `index.htm`, we changed the canvas HTML to the following code. It contains
    several canvases within a section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to apply some styles to the canvas so they overlap with each other
    to create the multiple layers effect. Also we have to prepare a `fadeout` class
    and `dim` class to make the target transparent. Add the following code into the
    `untangle.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `html5games.untangle.js` JavaScript file, we modify the code to support
    the layers feature. First, we add an array to store the context reference of each
    canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get the context reference and store them in the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Since now the game canvas are overlapped together, the mouse event listener
    we had in the `game` canvas does not fire anymore. We can listen to the event
    from the parent `layers` DIV which has the same position and dimension of the
    canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to separate the drawing part into different functions for different
    layers. In the following `drawLayerBG` function, it is only in charge of drawing
    the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We draw the background layer when the background image is loaded. Add the following
    highlighted code into the `onload` event of the background:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We divide the game loop into three different functions for the specified layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We put the guideline animation into a dedicated canvas now so we can easily
    apply CSS style to fade out the guideline later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `drawLayerGame` keeps all the drawing code we used in the gameplay.
    Most of the code is from the original `gameloop` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The level progress text is now placed in the UI layer and drawn by the `drawLayerUI`
    function. It uses a dedicated layer so we can easily dim the opacity when the
    text is overlapped with the game objects, such as circles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all the files and check our big code changes in the web browser. The game
    should be displayed as if we haven''t changed anything. Try dragging the circle
    down close to the bottom edge of the blackboard. The level progress text should
    dim to a low opacity. When you finish the first level, the guideline animation
    will fade out gracefully. The following screenshot shows the level progress in
    half opacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action Dividing the game into four layers](img/1260_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are four canvases in total now. Each canvas is in charge of one layer.
    The layers are divided into background, game guideline, game itself, and the user
    interface showing the level progress.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the canvases, like other elements, are placed one after the other.
    In order to overlap all canvases to construct the layer effect, we applied the
    `absolute` position to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshots show the four layers setting now in our game. By
    default, the later added DOM is on top of the one added before. Therefore, `bg`
    canvas is at the bottom and `ui` is on the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/1260_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mixing CSS technique with Canvas drawing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are creating a canvas-based game but we are not restricted to use only a
    canvas drawing API. The level progress information is now in another canvas with
    ID `ui`. In this example, we mixed the CSS technique we discussed in Chapter 3,
    *Building a Memory Matching Game in CSS3.*
  prefs: []
  type: TYPE_NORMAL
- en: When we drag the circles around the canvas, they may overlap the level information.
    When drawing the UI canvas layer, we check whether any circle's coordinate is
    too low and is overlapping the text. We then fade the UI canvas CSS opacity so
    it does not distract the player from the circles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also fade out the guideline animation after the player levels up. This is
    done by fading out the whole `guide` canvas with CSS transition easing to 0 opacity.
    Since the `guide` canvas is only in charge of that animation, hiding that canvas
    does not affect other elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Clearing only the changed region to boost canvas performance**'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `clear` function to only clear part of the canvas context. This
    will give the performance some boost because it avoids redrawing the entire canvas
    context every time. This is achieved by marking the 'dirty' region of the context
    which has changed state since last drawn.
  prefs: []
  type: TYPE_NORMAL
- en: In the guide canvas layer in our example, we may consider clearing only the
    region of the sprite sheet image drawing instead of the whole canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We may not see significant differences in simple canvas examples but it helps
    boost the performance when we have a complex canvas game that includes many sprite
    images animations and complex shape drawings.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We fade out the guide when the players advance to level 2\. How about we fade
    out the guide animation once the player drags any circles? How can we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about drawing gradients, text, and images in
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Filling shapes with either linear or radial gradient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filling text in canvas with font-face embedding and other text styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing images into canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a sprite sheet by the `clipping` function when drawing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dividing the game into several layers by stacking several canvas elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing the CSS transition animation in a canvas-based game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One thing we haven't mentioned in this book is the bitmap manipulation in canvas.
    Canvas context is a bitmap data where we can apply an operation on each pixel.
    For instance, we may draw an image in the canvas and apply Photoshop-like filters
    to the image. We will not cover that in the book because image manipulation is
    an advanced topic and the application may not relate to game development.
  prefs: []
  type: TYPE_NORMAL
- en: There are some good canvas games examples on the Internet. The Canvas Demo ([http://www.canvasdemos.com/type/games/](http://www.canvasdemos.com/type/games/))
    links the latest canvas games from other websites. The Game On 2010 gallery ([https://gaming.mozillalabs.com/games/](https://gaming.mozillalabs.com/games/))
    from Mozilla lists a bundle of game entries for their gaming development competition.
    Some of them are made in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about building games in canvas and making animation for
    game objects, such as game character, we are ready to add audio components and
    sound effects to our games in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will get back to canvas-based games in [Chapter 9](ch09.html "Chapter 9. Building
    a Physics Car Game with Box2D and Canvas"),
  prefs: []
  type: TYPE_NORMAL
