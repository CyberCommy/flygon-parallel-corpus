- en: Optimizing Test-Driven React Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps, one of the most important tools in the React ecosystem is Jest—a test
    runner and unit test library for testing your React components. Jest was designed
    to overcome challenges faced with other test frameworks like Jasmine, and was
    created with React development in mind. With powerful testing tools like Jest,
    you''re better equipped to let your unit tests influence the design of your React
    components. In this chapter, you''ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: The overarching design philosophy of Jest and what this means for React developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Jest unit tests in a `create-react-app` environment and in a standalone
    React environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing effective unit tests and suites using the Jest API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Jest unit tests in your code editor and integrating tests into your
    development server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The driving philosophy of Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned that the `create-react-app` tool was created
    to make developing React applications easier. It does so by eliminating upfront
    configuration—you go straight to building components. Jest was created with the
    same purpose in mind, eliminating the upfront boilerplate that you would typically
    have to create just to start writing tests. In addition to removing the initial
    unit test configuration factor, Jest has some other tricks up its sleeve. Let's
    go over some of the driving principles of testing with Jest.
  prefs: []
  type: TYPE_NORMAL
- en: Mock everything except the application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last thing you want to spend time on is testing someone else''s code. Yet,
    sometimes you''re forced to do exactly that. For example, let''s say that you
    want to test a function that makes a `fetch()` call to some HTTP API. Another
    example: your React component uses some library to help set and manipulate its
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: In both of these examples, there's code that you didn't implement that's being
    run when your unit tests run. You definitely don't want to reach out to an external
    system over HTTP. You definitely don't want to make sure that the state of your
    component is being set correctly based on the output of functions from another
    library. For the code that we don't want to test, Jest provides a powerful mock
    system. But you need to draw a line somewhere—you can't mock every little thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an illustration of a component and its dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/409c52f1-1a46-4eae-a4d0-0c6cc1957722.png)'
  prefs: []
  type: TYPE_IMG
- en: There are three libraries that this component requires in order to function.
    You probably don't want to unit test this component as is, because you would also
    be testing the functionality of three other libraries. The libraries that you
    don't want to run during unit testing can be mocked using Jest. You don't have
    to mock every library, and for some, mocking them may be more trouble than they're
    worth.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that **Lib C** in this scenario is a date library.
    Do you really need to mock it, or could you actually use the values it produces
    in component tests? A date library is pretty low level, so it''s probably stable
    and it probably poses very little risk to the functioning of your unit test. On
    the other hand, the higher the level of the library and the more work that it
    does, the more problematic it is for your unit tests. Let''s take a look at how
    this looks if you decided to use Jest to mock **Lib A** and **Lib B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0b3ee051-6f68-4083-8f0e-8f8f1952a0f3.png)'
  prefs: []
  type: TYPE_IMG
- en: If you tell Jest that you want to mock implementations of **Lib A** and **Lib
    B**, it can use the actual modules and automatically create an object that your
    tests can use. So, with very little effort on your part, you can mock dependencies
    that pose challenges to testing your code.
  prefs: []
  type: TYPE_NORMAL
- en: Isolate tests and run in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest makes it easy to isolate your unit tests in a sandboxed environment. In
    other words, side-effects from running one test cannot impact the results of other
    tests. Each time a test run completes, the global environment is automatically
    reset for the next. Since tests are standalone and their execution order doesn't
    matter, Jest runs tests in parallel. This means that even if you have hundreds
    of unit tests you can run them frequently without the fear of having to wait.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an illustration of how Jest runs tests in parallel, in their own isolated
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fe1e3a8d-c7d8-499f-b765-972d6212107a.png)'
  prefs: []
  type: TYPE_IMG
- en: The best part is that Jest handles scaling processes up for you. For example,
    if you're just starting out and your project only has a handful of unit tests,
    Jest isn't going to spawn, for example, eight parallel processes. It will just
    run them in a single process. The key thing for you to remember is that unit tests
    are their own universe with no interference from other universes.
  prefs: []
  type: TYPE_NORMAL
- en: Tests should feel natural
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest makes it easy to get started with running your tests, but what about writing
    tests? The API exposed by Jest makes it easy to write tests that don't have a
    lot of moving parts. The API documentation ([https://facebook.github.io/jest/docs/en/api.html](https://facebook.github.io/jest/docs/en/api.html))
    is organized into sections that make it easy to find what you need. For example,
    if you're writing a test and you need to validate an expectation, you can find
    the functions that you need in the *Expect* section of the API docs. Or, you might
    need help configuring a mock function—the *Mock Functions* section of the API
    docs has everything you need on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Another area where Jest really stands out is when you need to test asynchronous
    code. This typically involves working with promises. The Jest API makes it easy
    to expect specific values from resolved or rejected promises without having to
    write a ton of async boilerplate. It's the little things like this that make writing
    unit tests for Jest feel like a natural extension of the actual application code.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jest command-line tools are all you need to run your unit tests. There are
    a number of ways that the tool can be used. First, you'll learn how to invoke
    the test runner from a `create-react-app` environment and how to use the interactive
    watch mode options. Then, you'll learn how to run Jest in a standalone environment
    without the help of `create-react-app`.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests using react-scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create your React application using `create-react-app`, you're ready
    to run tests right away. In fact, as part of the boilerplate code that's created
    for you, a unit test for the `App` component is created. This test is added so
    that Jest will find a test that it can run. It doesn't actually test anything
    meaningful in your application, so you'll probably delete it once more tests are
    added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `create-react-app` adds the appropriate script to your `package.json`
    file to run your tests. You can just run the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will actually invoke the `test` script from `react-scripts`. This will
    invoke Jest, which runs any tests that it finds. In this case, since you''re working
    with a fresh project, it will only find the one test that `create-react-app` creates.
    Here''s what the output of running this test looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The test that was run lives in the `App.test.js` module—all Jest tests should
    have `test` somewhere in their filename. A good convention to follow is `ComponentName.test.js`.
    Then, you can see a list of tests that were run in this module, how long they
    took, and whether they passed or failed.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom, Jest prints out summary information of the run. This is often
    a good starting point because if all your tests are passing, you might not care
    about any other output. On the other hand when a test fails, the more information,
    the better.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test` script from `react-scripts` invokes Jest in watch mode. This means
    that you can choose which tests are actually run when files are changed. Here''s
    what the menu looks like on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When Jest is running in watch mode, the process doesn't exit as soon as all
    tests complete. Instead, it watches your test and component files for changes
    and runs tests when changes are detected. These options allow you to fine-tune
    which tests are run when changes take place. The `p` and `t` options are only
    useful if you have thousands of tests and many of them are failing. These options
    are useful to drill down and find the offending component as it's developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, when a change is detected by Jest, only associated tests are run.
    For example, changing the test or the component will result in the test being
    run again. With `npm test` running in your Terminal, let''s open up `App.test.js`
    and make a small change to the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can just change the name of the test so that it looks like the following,
    and then save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, take a look at your Terminal where you left Jest running in watch mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Jest detected the change in your unit test and ran it, producing the updated
    console output. Now let''s introduce a new component and a new test and see what
    happens. First, you''ll implement a `Repeat` component that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This component takes a `times` property, which is used to determine how many
    times to repeat the `value` property. Here''s how the `Repeat` component is used
    by the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to view this application, you would see the string `React!` rendered
    five times on the page. Your component works as expected, but let''s make sure
    that we add a unit test before committing your new component. Create a `Repeat.test.js`
    file that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually the same unit test used for the `App` component. It doesn''t
    test much other than that the component can render without triggering some sort
    of error. Now Jest has two component tests to run: one for `App` and the other
    one for `Repeat`. If you look at the console output for Jest, you''ll see that
    both tests are run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the last line in this output. The default watch mode of Jest
    is to look for files that haven''t been committed to source control and that have
    been saved. By ignoring components and tests that have been committed, you know
    that they haven''t changed, so running those tests would be pointless. Let''s
    try changing the `Repeat` component and see what happens (you don''t actually
    have to change anything, just saving the file is enough to trigger Jest):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Why is the `App` test running? It's committed and hasn't been changed. The issue
    is that since `App` depends on `Repeat`, changes to the `Repeat` component could
    cause `App` tests to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s introduce another component and test, except that this time we won''t
    introduce any dependencies importing the new component. Create a `Text.js` file
    and save it with the following component implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This `Text` component will just render whatever child element or text that
    is passed to it. It''s a contrived component, but that doesn''t matter. Now let''s
    write a test that will verify that the component returns the value as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toEqual()` assertion passes when the value returned by `Text()` is equal
    to the `children` value. When you save this test, take a look at the Jest console
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a test that doesn't have any dependencies, Jest will run it
    on its own. The other two tests are checked into Git, so it knows that these tests
    do not need to run. You would never commit something that doesn't pass a unit
    test, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make this test fail now and see what happens. Change the `Test` component
    so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fail the test because it is expecting the component function to return
    the value passed to the `children` property. Now if you go back to the Jest console,
    the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The test failed, as you knew it would. What's interesting is that once again,
    this was the only test that was run because nothing else has changed according
    to Git. The benefit to you is that once you have hundreds of tests, you don't
    need to wait for all of them to run before a failing test for the component that
    you're currently working can run.
  prefs: []
  type: TYPE_NORMAL
- en: Running tests using standalone Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `test` script from `react-scripts` that you just learned about in the previous
    section is a great tool to have running in the background while you're building
    your application. It gives you immediate feedback as you implement components
    and unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Other times, you just want to run all tests and have the process exit as soon
    as the result output is printed. For example, if you're integrating Jest output
    into a continuous integration process or if you just want to see test results
    run once, you can run Jest directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try running Jest on its own. Make sure that you''re in your project
    directory still and that you''ve stopped the `npm test` script from running. Now
    just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than running Jest in watch mode, this command simply attempts to run
    all of your tests, prints the result output, and then exits. However, there seems
    to be a problem with this approach. Running Jest like this results in errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `test` script from `react-scripts` sets up a lot of things
    for us, including all of the Jest configuration necessary to parse and execute
    JSX. Given that we have this tool available to us, let's just use it rather than
    go through the headache of trying to configure Jest from scratch. Remember, your
    goal is to run Jest once—not in watch mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the `test` script from `react-scripts` is ready to handle
    continuous integration environments. If it finds a `CI` environment variable,
    it won''t run Jest in watch mode. Let''s try this out by exporting this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run `npm test`, everything works as expected. The process exits
    when everything is finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then unset this environment variable when you''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, you'll probably just use Jest in watch mode. But in case you
    need to quickly run your tests in a short-lived process, you can temporarily enter
    continuous integration mode.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Jest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to run Jest, let's write some unit tests. We'll cover
    the basics as well as the more advanced features of Jest available for testing
    React apps. We'll start organizing your tests into suites and the basic assertions
    available in Jest. Then, you'll create your first mock module and work with asynchronous
    code. Lastly, we'll use Jest's snapshotting mechanism to help test React component
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing tests using suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suites are the main organizational unit of your tests. Suites aren''t a Jest
    requirement—the test that `create-react-app` creates does not include a suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `it()` function declares a unit test that passes or fails. When you''re
    just getting your project started and you only have a few tests, there''s no need
    for suites. Once you have several tests, it''s time to start thinking about organization.
    Think of a suite as a container that you can put your tests in. You can have several
    of these containers that organize your tests however you see fit. Typically, a
    suite corresponds to a source module. Here''s how you declare suites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `describe()` function is used here to declare a suite called `BasicSuite`.
    Within the suite, we have several unit tests declared. Using `describe()`, you
    can organize your tests so that related tests are grouped together in the test
    result output.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, your tests will grow unwieldy fast if suites are the only mechanism
    available to organize your tests. The reason is that you will typically have more
    than one test per class, method, or function located within a module. So you need
    a way to say which part of code the test actually belongs to. The good news is
    that you can nest calls to `describe()` to provide the necessary organization
    for your suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The outermost `describe()` call declares the test suite, which corresponds to
    some top-level unit of code, such as a module. The inner calls to `describe()`
    correspond to smaller code units, such as methods and functions. This way, you
    can easily write several unit tests for a given piece of code while avoiding confusion
    about what's actually being tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some detailed output for the test suite that you''ve
    just created. To do so, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first set of double dashes tells `npm` to pass any arguments that follow
    to the `test` script. Here''s what you''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Under `NestedSuite`, you can see that `state` is the code that's being tested
    and that two tests have passed. Same is the case with `props` and `render()`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assertions in your unit tests are created using Jest's expectation API. These
    functions trigger unit test failures when the expectations of your code aren't
    met. The output of test failures when using this API shows you what was expected
    to happen in addition to what actually happened. This seriously cuts down the
    amount of time you spend chasing down values.
  prefs: []
  type: TYPE_NORMAL
- en: Basic equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can assert that two values are the same by using the `toBe()` expectation
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the first test, you're expecting `true` to equal `true`. Then, you're negating
    this expectation in the next line using the `.not` property. If this were a real
    unit test, you wouldn't have to prove the opposite of an assertion that you've
    just made like this—I'm doing this to illustrate some of your options.
  prefs: []
  type: TYPE_NORMAL
- en: In the second test, we're performing the same assertions but with `false` as
    the expectation value. The `toBe()` method uses strict equality to compare its
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Approximate equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times where checking for the exact value of something in your code
    makes no difference and could be more work than is worthwhile. For example, you
    might only need to make sure that a value is present. You might also need to perform
    the inverse—to make sure that there is no value. Something versus nothing in JavaScript
    terminology is **truthy** versus **falsy**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for truthy or falsy values in your Jest unit tests, you would use
    the `isTruthy()` or `isFalsy()` methods respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The value `1` isn't true, but it evaluates to `true` when used in the context
    of a Boolean comparison. Likewise, an empty string evaluates to `false`, so it's
    considered falsy.
  prefs: []
  type: TYPE_NORMAL
- en: Value equality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with objects and arrays, checking for equality can be painful.
    You typically can't use strict equality because you're comparing references, which
    are always different. If it's the values that you're trying to compare, you need
    to iterate over the object or collection and compare the values, keys, and indexes
    individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since no one in their right mind wants to do all of this work to perform a
    simple test. Jest provides the `toEqual()` method, which compares object properties
    and array values for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Every object and array in this example are unique references. Yet, the two objects
    and the two arrays are equal in terms of their properties and values. The `toEqual()`
    method checks for value equality. After this, I'm showing that `toBe()` is not
    what you want—this returns `false` because it's comparing references.
  prefs: []
  type: TYPE_NORMAL
- en: Values in collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are way more assertion methods available in Jest than I have room to
    cover in this book. I encourage you to take a look at the *Expect* section of
    the Jest API docs: [https://facebook.github.io/jest/docs/en/expect.html](https://facebook.github.io/jest/docs/en/expect.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two assertion methods I want to go over with you are `toHaveProperty()`
    and `toContain()`. The former tests that an object has a given property while
    the latter checks that an array contains a given value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `toHaveProperty()` method is useful when you need to check if an object
    has a particular property value. The `toContain()` method is useful when you need
    to check if an array has a particular value.
  prefs: []
  type: TYPE_NORMAL
- en: Working with mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write unit tests, you're testing your own code. At least that's the
    idea. In reality, this is more difficult than it sounds because your code will
    inevitably use a library of some sort. This is code that you do not want to test.
    The problem with writing unit tests that call other libraries is that they often
    need to reach out to the network or the filesystem. You definitely don't want
    false positives as a result of side-effects from other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Jest provides a powerful mocking mechanism that's easy to use. You give Jest
    the path to a module that you want to mock, and it handles the rest. In some cases,
    you don't need to provide a mock implementation. In other cases, you need to handle
    parameters and return values in the same way as the original module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you''ve created a `readFile()` function that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function requires the `readFile()` function from the `fs` module. It returns
    a promise that is resolved when the callback function that's passed to `readFile()`
    is called, unless there's an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you would like to write a unit test for this function. You want to make
    assertions like:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it call `fs.readFile()`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the returned promise resolve with the correct value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the returned promise reject when the callback passed to `fs.readFile()`
    receives an error?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can perform all of these assertions without relying on the actual implementation
    of `fs.readFile()` by mocking it with Jest. You don't have to make any assumptions
    about external factors; you only care that your code works the way that you expect
    it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s take a shot at implementing some tests for this function that use
    a mocked `fs.readFile()` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The mocked version of the `fs` module is created by calling `jest.mock('fs')`.
    Note that you actually import the real `fs` module before mocking it and that
    it's mocked before any tests actually use it. In each test, we're creating a custom
    implementation of `fs.readFile()`. By default, functions mocked by Jest won't
    actually do anything. Rarely will this suffice for testing most things. The beauty
    of mocks is that you control the outcome of the library that your code uses, and
    your test assertions make sure that your code handles everything accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: You provide the implementation by passing it as a function to the `mockImplementation()`
    method. But before you do this, always make sure that you call `mockReset()` to
    clear any stored information about the mock, like how many times it was called.
    For example, the first test has the assertion `expect(fs.readFile).toHaveBeenCalled()`.
    You can pass a mock function to `expect()` and Jest provides methods that know
    how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same pattern can be followed for similar functions. Here''s the counterpart
    to `readFile()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s two important differences between `readFile()` and `writeFile()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `writeFile()` function accepts a second parameter for the data to write
    to the file. This parameter is also passed to `fs.writeFile()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `writeFile()` function doesn't resolve a value whereas `readFile()` resolves
    the file data that's been read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two differences have implications for the mock implementations that you
    create. Let''s take a look at them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `data` parameter needs to be part of the mock implementation now; otherwise,
    there'd be no way to access the `cb` parameter and call the callback.
  prefs: []
  type: TYPE_NORMAL
- en: In both the `readFile()` and `writeFile()` tests, you have to deal with asynchronicity.
    This is why we're performing assertions within a `then()` callback. The `done()`
    function that is passed in from `it()` is called when we're done with the test.
    If you forget to call `done()`, the test will hang and eventually timeout and
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jest comes with built-in support for test coverage reporting. It''s nice to
    have this included as part of your test framework because not all of them have
    this support. If you want to see what your test coverage looks like, simply pass
    the `--coverage` option when starting Jest as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When you do this, tests are run as normal. Then, the coverage tool inside Jest
    will figure out how well your tests cover your source, and will produce a report
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to bring your coverage numbers up, take a look at the `Uncovered
    Lines` column in the report. The other columns tell you what type of code is covered
    by tests: statements, branches, and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest anticipates that you'll have asynchronous code to test. This is why it
    provides APIs to make this aspect of writing unit tests feel natural. In the previous
    section, we wrote tests that performed assertions within a `then()` callback and
    called `done()` when all of the asynchronous testing was completed. In this section,
    we're going to look at another approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jest allows you to return promise expectations from your unit test functions
    and will handle them accordingly. Let''s refactor the `readFile()` tests that
    you wrote in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now the tests return promises. When a promise is returned, Jest will wait for
    it to resolve before the results of the test are captured. You can also pass `expect()`
    a promise and use the `resolves` and `rejects` objects to perform your assertions.
    This way, you don't have to rely on the `done()` function to indicate that the
    asynchronous portion of your test is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The `rejects` object is particularly valuable here. It's important to make sure
    that functions reject as expected. But without `rejects`, it's impossible to do
    this. In the previous version of this test, if your code resolved for some reason
    when it was supposed to reject, there's no way to detect this. Now if this happens,
    using `rejects` causes the test to fail.
  prefs: []
  type: TYPE_NORMAL
- en: React component snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components render output. Naturally, you want part of your component unit
    tests to ensure that the correct output is created. One approach is to render
    the component to a JS-based DOM, and then to perform individual assertions on
    the rendered output. This would be a painful test writing experience to say the
    least.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing allows you to generate a *snapshot* of rendered component output.
    Then, each time your test runs, the output is compared to the snapshot. If something
    looks different, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the default test for the `App` component that `create-react-app`
    adds for you to make it use snapshot testing. Here''s what the original test looked
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This test isn''t actually verifying anything about the content that''s rendered—just
    that an error isn''t thrown. If you were to make a change that resulted in something
    unexpected, you would never know about it. Here''s the snapshotting version of
    the same test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Before this test would run, I had to install the `react-test-renderer` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Maybe this will be added to `create-react-app` some day. In the meantime, you'll
    have to remember to install it. Then, your test can import the test renderer and
    use it to create a JSON tree. This is a representation of the rendered component
    content. Next, you expect the tree to match the snapshot that is created the first
    time this test runs, using the `toMatchSnapshot()` assertion.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the first time the test is run, it will always pass because
    this is when the snapshot is first created. Snapshot files are artifacts that
    should be committed to your project's source control system, just like the unit
    test source itself. This way, other folks who work on the project will have a
    snapshot file to work with when they run your tests.
  prefs: []
  type: TYPE_NORMAL
- en: What's misleading about snapshot testing is that it gives the impression that
    you can't actually change components to produce different output. Well, this is
    in fact true—changing the output produced by components will result in failed
    snapshot tests. This isn't a bad thing, though, as it forces you to look at what
    your components are rendering with every change you make.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `App` component so that it adds emphasis to the word `started`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you run your test, you get a failure that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! This is useful. A unified diff shows you exactly what changed with the
    component output. You can look at this output and decide that this is exactly
    the change that you expected to see, or that you''ve made a mistake and you need
    to go fix it. Once you''re happy with the new output, you can update the stored
    snapshot by passing an argument to the `test` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This will update the stored snapshot before running your tests and any failed
    snapshot tests will now pass since they meet their output expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Jest tells you that a snapshot was updated before running any tests, the result
    of passing the `--updateSnapshot` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Jest. You learned that the key driving principles
    of Jest are creating effective mocks, test isolation and parallel execution, and
    ease of use. You then learned that `react-scripts` makes running your unit tests
    even easier by providing some basic configuration to use with Jest.
  prefs: []
  type: TYPE_NORMAL
- en: When running Jest, you saw that watch mode is the default when running Jest
    via `react-scripts`. Watch mode is especially useful when you have lots of tests
    that don't need to run every time you make a source change—only relevant tests
    are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you performed some basic assertions in your unit tests. Then, you created
    a mock for the `fs` module and performed assertions on the mocked functions to
    ensure that they're being used as expected. You then evolved these tests to make
    use of the inherent asynchronous capabilities of Jest. Unit test coverage reporting
    is built into Jest, and you learned how to view this report by passing an additional
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to create type-safe components using Flow.
  prefs: []
  type: TYPE_NORMAL
