- en: Compile Time Evaluations in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go authors have written the language in a way that minimizes dependencies
    and each file declares its own dependencies. Regular syntax and module support
    also helps a developer improve compile times, as well as interface satisfaction.
    In this chapter, we will see how runtime evaluations help make Go compilation
    quicker, alongside using containers for building Go code and utilizing the Go
    build cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The Go runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GCTrace`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOGC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOMAXPROCS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GOTRACEBACK`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Go build cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeepAlive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumCPU`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReadMemStats`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all valuable topics for understanding how the Go runtime works and
    how you can use it to write performant code.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Go runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the Go source code, we can see the runtime source by looking at [https://golang.org/src/runtime/](https://golang.org/src/runtime/).
    The runtime package contains operations that interact with the Go runtime. This
    package is used to control things such as goroutines, garbage collection, reflection,
    and scheduling, which are all functions that are essential to the operation of
    the language. Within the runtime package, we have many environment variables that
    help us change the runtime behavior of Go executables. Let's review some of the
    most important environment variables we can talk about with respect to the Go
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: GODEBUG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GODEBUG` is the controller of the variables and is used for debugging within
    the Go runtime. This variable contains a list of `name=val` key-value pairs, separated
    by commas. These named variables are used to tune the output of the debugging
    information the binary will return. One of the nice things about this variable
    is that the runtime allows you to apply this directly to a precompiled binary,
    rather than invoking it at build time. This is nice because it allows you to debug
    a binary that has already been built (and potentially already causing harm in
    a production environment). The variables you can pass to `GODEBUG` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **GODEBUG variables** | **Enable value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `allocfreetrace` | 1 | Used in order to profile every allocation. A stack
    trace is printed for each object''s allocation and is freed. Each stack trace
    contains the memory block, size, type, goroutine ID, and stack trace of the individual
    element. |'
  prefs: []
  type: TYPE_TB
- en: '| `clobberfree` | 1 | The GC clobbers the content of an object with bad content
    when it frees the object. |'
  prefs: []
  type: TYPE_TB
- en: '| `cgocheck` | 0 – Disabled 1 (default) – Cheap checks 2 – Expensive checks
    | Checks for packages that use cgo for incorrectly passed go pointers to non-Go
    code.  Set 0 for disabled, 1 for cheap checks that may miss some errors (default),
    or 2 for expensive checks that will slow your program down. |'
  prefs: []
  type: TYPE_TB
- en: '| `efence` | 1 | The allocator will ensure each object is allocated on a unique
    page and that memory addresses aren''t recycled. |'
  prefs: []
  type: TYPE_TB
- en: '| `gccheckmark` | 1 | Verifies the GC''s current mark phase by doing a second
    mark pass. The world is stopped during this second mark pass. If the second pass
    finds an object that wasn''t found by the concurrent mark, the GC will panic.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gcpacertrace` | 1 | Prints information about the concurrent pacer''s internal
    state with respect to the garbage collector. |'
  prefs: []
  type: TYPE_TB
- en: '| `gcshrinkstackoff` | 1 | Moving goroutines cannot move onto smaller stacks.
    A Goroutine''s stack only grows in this mode. |'
  prefs: []
  type: TYPE_TB
- en: '| `gcstoptheworld` | 1 – Disables GC 2 – Disables GC and concurrent sweeping
    | 1 disables concurrent garbage collection. This turns each GC event into a stop
    the world situation. 2 disables GC and disables concurrent sweeping after the
    completion of garbage collection. |'
  prefs: []
  type: TYPE_TB
- en: '| `gctrace` | 1 | See the `GCTrace` header on the subsequent page. |'
  prefs: []
  type: TYPE_TB
- en: '| `madvdontneed` | 1 | Returns memory to the kernel with `MADV_DONTNEED` instead
    of `MADV_FREE` on Linux. Using this flag makes for less efficient memory utilization,
    but also makes RSS memory values drop more quickly. |'
  prefs: []
  type: TYPE_TB
- en: '| `memprofilerate` | 0 – Turn of profiling 1 – Include every allocated block
    X – Updates the value of `MemProfileRate` | Controls memory allocation fractions
    that are reported and recorded within the memory profile. Changing X controls
    the fraction of memory allocations that are recorded. |'
  prefs: []
  type: TYPE_TB
- en: '| `invalidptr` | 0 – Disables this check 1 – Crashes if an invalid pointer
    is found | The garbage collector and stack copier will crash if a value for an
    invalid pointer is found where a pointer is stored. |'
  prefs: []
  type: TYPE_TB
- en: '| `sbrk` | 1 | Swaps in a trivial allocator from the OS that doesn''t reclaim
    memory, instead of using the default memory allocator and garbage collector. |'
  prefs: []
  type: TYPE_TB
- en: '| `scavenge` | 1 | The heap scavenger debugging mode is enabled. |'
  prefs: []
  type: TYPE_TB
- en: '| `scheddetail` | 1 (in conjunction with schedtrace=X) | The scheduler returns
    information that pertains to the scheduler, processor, thread, and goroutine processes
    every X milliseconds. |'
  prefs: []
  type: TYPE_TB
- en: '| `schedtrace` | X | A single line is emitted to STDERR every X milliseconds
    with a scheduler state summary. |'
  prefs: []
  type: TYPE_TB
- en: '| `tracebackancestors` | N | Tracebacks of where goroutines are crated with
    their associated stacks are extended, reporting N ancestor goroutines. No ancestry
    information is returned if N = 0. |'
  prefs: []
  type: TYPE_TB
- en: Other packages also have variables that are able to be passed to `GODEBUG`.
    These are usually very well-known packages that may need runtime performance tweaks,
    such as `crypto/tls` and `net/http`. Packages should contain documentation if
    they have `GODEBUG` flags that are available at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: GCTRACE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GCTRACE` is utilized during runtime to view a single line that''s been printed
    to stderr showing the total memory collected and the length of the pause during
    each collection. At the time of writing, this line is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instrument a simple HTTP server to provide an example of how this works.
    First, we write a simple HTTP server with a simple response of `Hello Gophers`
    to the root of `localhost:8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can build and run this simple web server, and then we can use Apache
    bench ([https://httpd.apache.org/docs/2.4/programs/ab.html](https://httpd.apache.org/docs/2.4/programs/ab.html))
    to simulate some load to the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4adaae82-8d0b-472f-b9a2-4adba426c69d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After we see this output from Apache bench, showing that our test has completed,
    we will see some garbage collection statistics in our Terminal where we initially
    instantiated our simple HTTP daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30586da4-f98c-4ad0-ad04-36a39dc1756e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s break down the garbage collection output of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Output** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| gc 1 | The garbage collection number. This number is incremented at each
    garbage collection. |'
  prefs: []
  type: TYPE_TB
- en: '| @6.131s | This garbage collection occurred 6.131 s after the program was
    started. |'
  prefs: []
  type: TYPE_TB
- en: '| 0% | The percentage of time spent in GC since the program was started. |'
  prefs: []
  type: TYPE_TB
- en: '| 0.016+2.1+0.023 ms clock | The wallclock/CPU times that occur for the phases
    of the GC. This can be expressed as *Tgc = Tseq + Tmark + Tsweep.* **Tseq**: User
    Go routines time stop (stop the world sweep termination).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tmark**: The heap making time (concurrent mark and scan time).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tsweep**: Heap sweeping time (sweep the world mark termination). |'
  prefs: []
  type: TYPE_NORMAL
- en: '| 4->4->3 MB | GC start, GC end, and live heap sizes. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 MB goal | The goal heap size. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 P | 4 processors being used. |'
  prefs: []
  type: TYPE_TB
- en: 'If we wait a couple of moments, our Terminal should produce an output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an output that occurs using `gctrace > 0`. It produces a summary whenever
    the Go runtime releases memory back to the system, also known as **scavenging**. 
    At the time of writing, this output follows the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Output** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| scvg1: 57 MB released | The scavenge cycle number. This number is incremented
    at each scavenge. This data point also lets us know the size of the memory block
    that is released back to the OS. |'
  prefs: []
  type: TYPE_TB
- en: '| inuse: 1 | The size in MB of memory used in our program (this can also indicate
    partially used spans). |'
  prefs: []
  type: TYPE_TB
- en: '| idle: 61 | The size in MB of spans pending scavenging. |'
  prefs: []
  type: TYPE_TB
- en: '| sys: 3 | The size in MB of memory that''s been mapped from the system. |'
  prefs: []
  type: TYPE_TB
- en: '| released: 57 | The size in MB of memory released to the system. |'
  prefs: []
  type: TYPE_TB
- en: '| consumed: 5 | The size in MB of memory allocated from the system. |'
  prefs: []
  type: TYPE_TB
- en: Both the garbage collection and scavenging output examples are important—they
    can tell us the current state of memory utilization in our system in a simple
    to read manner.
  prefs: []
  type: TYPE_NORMAL
- en: GOGC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `GOGC` variable allows us to tune the intensity of the Go garbage collection
    system. The garbage collector (instantiated at [https://golang.org/src/runtime/mgc.go](https://golang.org/src/runtime/mgc.go)) 
    reads the `GOGC` variable and determines the value of the garbage collector. A
    value of `off` sets the garbage collector off. This is often useful for debugging
    but not sustainable in the long term as the program needs to free memory that
    is collected within the executable''s heap. Setting this value to less than the
    default value of 100 will cause the garbage collector to execute more frequently.
    Setting this value larger than the default value of 100 will cause the garbage
    collector to execute less frequently. Very often for multi-core large machines,
    garbage collection happens too frequently and we can improve performance if we
    have garbage collection happen less frequently. We can use a compilation of the
    standard library to see how changing garbage collection will influence compile
    times. In the following code sample, we can see examples of the build of the standard
    library and their respective timings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output shows us the respective timings of the Go standard library compile
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e31273d-884b-4f09-93e3-c24e027f8b1a.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that there is a vast difference in compile times by tuning the garbage
    collection. This will vary greatly, depending on your architecture, system specs,
    and Go version. It is important to recognize this is a knob we can turn for our
    Go programs. This knob is often turned for build times or highly monitored, latency-sensitive
    binaries that need to squeeze out more performance during their execution time.
  prefs: []
  type: TYPE_NORMAL
- en: GOMAXPROCS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GOMAXPROCS` is a variable that can be tuned to allow us to control the number
    of threads that our operating system will allocate to our goroutines within our
    Go binary. By default, `GOMAXPROCS` is equal to the number of cores available
    to the application. This is dynamically configurable via the runtime package.
    It is important to note that as of Go 1.10, `GOMAXPROCS` will have no upper bound
    limit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a function that is CPU-intensive and parallelized (such as goroutine
    sorting strings), we will see some serious improvements if we adjust the number
    of `GOMAXPROCS` we have.  In the following code example, we are going to test
    building the standard library with a different number set for `GOMAXPROCS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In our results, we can see what happens when we manipulate the total number
    of `GOMAXPROCS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23351ad2-7dae-4807-a55f-ac54de7cd6fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Realistically, we should never set `GOMAXPROCS` manually. There are rare occasions
    where you might want to limit CPU utilization for a particular binary based on
    the resources you have available to you on a system, or you may really need to
    optimize based on the resources you have on hand. For most cases, however, the
    default `GOMAXPROCS` value is sane.
  prefs: []
  type: TYPE_NORMAL
- en: GOTRACEBACK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`GOTRACEBACK` allows you to control the generated output from a Go program
    with unexpected runtime conditions or unrecovered panic states. Setting a `GOTRACEBACK`
    variable will allow you to see more or less granular information about the goroutines
    that are instantiated for your specific error or panic. An example of panic from
    a channel/goroutine interrupt is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we tweak the `GOTRACEBACK` variable in our output, we will see different
    varying levels of stack trace. Setting `GOTRACEBACK=none` or `GOTRACEBACK=0` gives
    us a minimal amount of information about this panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d1ad4f0-7faa-4444-b8a1-c25fdae2d3df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting `GOTRACEBACK=single` (the default option in the Go runtime) will emit
    a single stack trace for the current goroutine for our particular request, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/454b7684-81a2-4e21-aeaf-d3f083bb190b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Setting `GOTRACEBACK=all` or `GOTRACEBACK=1` will send us back the stack traces
    for all of the goroutines that were created by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e56929fc-6e24-45c6-8c70-6cc8df1c46c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting `GOTRACEBACK=system` or `GOTRACEBACK=2` will add all of the runtime
    stack frames for functions and goroutines that are created by the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can set `GOTRACEBACK=crash`. This functions similarly to the system
    but allows the operating system to trigger a core dump.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the default of `GOTRACEBACK=single` gives us enough information
    about the current context in order to make an informed decision about why our
    program ended in a way that we did not expect.
  prefs: []
  type: TYPE_NORMAL
- en: Go build cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've discussed a couple of ways to optimize the runtime for
    Go builds. We also have the ability to improve Go build times with a couple of
    simple tweaks. Go's team has been optimizing for runtime, not for build time.
    Go has the ability to cache build time dependencies, which helps to reuse common
    artifacts from previous builds. These artifacts are kept in `$GOPATH/pkg/`. We
    can keep these intermediate results by using the `-i` flag while calling go build
    in order to reutilize those artifacts. If we want to debug what is happening during
    our build, we can run our build with a `-x` flag in order to produce a more verbose
    output from the Go build system.
  prefs: []
  type: TYPE_NORMAL
- en: Vendoring dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vendoring is also a popular choice for improving build consistency and quality.
    Within the project structure, the authors of the language were receptive to the
    feedback of keeping support for vendoring dependencies. Keeping your dependencies
    within your repository makes it very large, but it can help with keeping third
    party dependencies available locally during build time. When we are using Go version
    1.11 or greater, we can use Go modules flagging to allow vendored builds. We can
    use `go mod vendor` to capture all of the dependencies in the `vendor/` directory,
    followed by using `go build -mod vendor` at build time.
  prefs: []
  type: TYPE_NORMAL
- en: Caching and vendoring improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to see the improvements we can make with built and cached assets,
    let''s build a project with a third-party dependency.  Prometheus [[https://prometheus.io/](https://prometheus.io/)]
    is a popular time-series database (also written in Go) that is commonly used for
    metrics gathering and collection. We may want to start up a Prometheus metrics
    server in any of our applications in order to learn more about our current running
    binary, from a systems perspective. To do this, we can import the Prometheus library
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After we instantiate our `prometheus` server in a basic binary, we can build
    our binary and execute it. To perform a force rebuild of packages that are already
    up to date, we can use the `-a` flag with `go build`. If you're curious as to
    what's taking forever in our super long build time, you can also add the `-x`
    flag – it'll give you a very verbose output as to what's happening during the
    build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, newer versions of Golang will define a `GOCACHE`. You can see where
    it''s located using `go env GOCACHE`. Using a combination of `GOCACHE` and mod
    vendor, we can see that our build time has significantly improved. Our first build
    in the list is a cold build, forcing packages to be rebuilt so they''re up to
    date. Our second build, which has some items stored from the mod vendor stanza,
    is much quicker. Our third build, which should have most build elements cached,
    is very quick in comparison. The following screenshot illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86acab39-2724-46f6-9fd2-3d35324715af.png)'
  prefs: []
  type: TYPE_IMG
- en: Debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The debug package within the runtime gives us many functions and types that
    are available for debugging.  We have the ability to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Force a garbage collection using `FreeOSMemory()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the stack trace that was generated at runtime. Stack to stderr using `PrintStack()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read our garbage collection stats using `ReadGCStats()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set our garbage collection percentage using `SetGCPercent()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set our max stack size for a single goroutine using `SetMaxStack()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set our maximum number of OS threads using `SetMaxThreads()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the runtime behavior while faulting on an unexpected address using `SetPanicOndefault()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the amount of traceback using `SetTraceback()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the stack trace of a goroutine using `Stack()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a heap dump using `WriteHeapDump()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PProf/race/trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will cover the details of profiling and tracing Go programs in [Chapter 12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml),
    *Profiling Go Code*, and [Chapter 13](ec12b9e7-c528-45c2-b0b8-dea297659b3e.xhtml),
    *Tracing Go Code*, respectively. It is prudent to know that the runtime library
    is a key driver in these utilities. Being able to use pprof/race/trace can help
    you debug your code in a meaningful way and be able to find nascent errors  In
    the next section, we will learn about runtime functions and how they are prudent
    to the Go runtime library.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go runtime library also has functions that you can inject into your program's
    runtime to emit runtime data. Let's run through a couple of prime examples. A
    full list of all of the available runtime functions can be found at [https://golang.org/pkg/runtime/#pkg-index](https://golang.org/pkg/runtime/#pkg-index). 
    Many of the functions that are available in this package are also included in
    the `runtime/pprof` package, which we will investigate in more detail in [Chapter
    12](3ad3f76b-80c3-4992-8201-c025ece696b7.xhtml), *Profiling Go Code*.
  prefs: []
  type: TYPE_NORMAL
- en: KeepAlive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `runtime.KeepAlive()` function expects `interface{}` and ensures that the
    object passed to it isn't freed and that its finalizer (as defined by `runtime.SetFinalizer`)
    is not run. This keeps the argument passed to `KeepAlive` reachable. The compiler
    sets up `OpKeepAlive`, as defined in the **static single assignment** (**SSA**)
    package ([https://golang.org/src/cmd/compile/internal/gc/ssa.go#L2947](https://golang.org/src/cmd/compile/internal/gc/ssa.go#L2947))
    – this allows the compiler to know the state of the interface as a variable and
    allows the keep alive context to be kept.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, we should not call `KeepAlive` in normal implementations.
    It's used to ensure that the garbage collector doesn't reclaim memory from a *no
    longer* referenced value within a function.
  prefs: []
  type: TYPE_NORMAL
- en: NumCPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `NumCPU` function returns the usable number of logical CPUs of the current
    process. When the binary is invoked, the runtime validates the number of CPUs
    that are available at startup. A simple example of this can be found in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can see the number of CPUs currently available to the process. In my
    case, this value ended up being `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc16f4e3-913e-4afb-8526-9aeae8522d04.png)'
  prefs: []
  type: TYPE_IMG
- en: With this, we can see that my computer has 4 CPUs available for use.
  prefs: []
  type: TYPE_NORMAL
- en: ReadMemStats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ReadMemStats()` function reads memory allocator statistics and populates
    them into a variable, say, `m`. The `MemStats` struct has a lot of really valuable
    information about in-flight memory utilization. Let''s take a deep look into what
    values it can produce for us. An HTTP handler function that allows us to see the
    memory utilization of the binary may be helpful as we make more requests in our
    system and wish to see where our memory allocation is utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can instantiate the program and the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can print all of the values of the individual memory statistics that
    the runtime provides us with. Let''s start with `Alloc`, `Mallocs`, and `Frees`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at heap information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we look at stack/span/cache/bucket allocations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we look at garbage collection information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at garbage collection interruption information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we instantiate a simple HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can use our Apache bench tool to generate a bit of load on our memory
    allocator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can see some active HTTP server information, along with a response,
    by making a request to `localhost:1234`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8fd2707-0f29-4394-9e95-fb667b359d75.png)'
  prefs: []
  type: TYPE_IMG
- en: The definitions for all of the `MemStats` values can be found in the documentation
    at [https://golang.org/pkg/runtime/#MemStats](https://golang.org/pkg/runtime/#MemStats).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the `GODEBUG`, `GCTRACE`, `GOGC`, `GOMAXPROCS`,
    and `GOTRACEBACK` runtime optimizations.  We also learned about the `GOBUILDCACHE`
    and Go vendoring dependencies. Lastly, we learned about debugging and calling
    runtime functions from code. Using these techniques while troubleshooting your
    Go code will help you spot your problems and bottlenecks more easily.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the proper way to deploy Go code effectively.
  prefs: []
  type: TYPE_NORMAL
