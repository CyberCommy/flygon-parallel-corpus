- en: Chapter 7. Building User Registration, Login, and Logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Always plan ahead. It wasn't raining when Noah built the ark - Richard C. Cushing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From this chapter onwards, we will get our hands dirty with professional PHP
    projects. We will design and develop a web applicaton where users can register
    themselves, and after registraton they can login to the applicaton, view, and
    update their own profle, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will work out the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User login and logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User profile view and update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Project planning is always signified as planning for the future, which means
    that a project should be planned, as it can be extended easily or can be reusable,
    more modular, and even scalable. For this project, we will design the application
    architecture in a realistic manner, so the user registration, login, and logout
    application can also be easily used in our future projects.
  prefs: []
  type: TYPE_NORMAL
- en: We will design the **Application Programming Interface** (**API**) and build
    the application using that API. The API will facilitate the application for any
    sort of user signup or signin related tasks, so that the core of the project is
    the API. Once we have the API ready, we can easily build a number of applications
    using that API.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's think about the API design. Remember that we will use some
    architectural pattern, that is the **Data Access Object** (**DAO**) pattern for
    our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is strongly recommended for this project to have prior knowledge of **Object
    Oriented Programming** (**OOP**) concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the application architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The architecture needs to be built up in layers in data storage, data access,
    application services, and the application. This is depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the application architecture](graphics/5801_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each layer can be designated as a group of analogous logical tasks, as the data
    storage layer acts as a data source, such as a relational database, a filesystem,
    or any other data source. The **data access layer** communicates with the data
    source to get or store data from the **storage layer**, and provides a nice abstraction
    in the data source to be delivered to the **service layer**. The service layer
    is a medium of data persistence with the **application layer**, and also offers
    other services, such as a validation service. The **data access objects** reside
    in the data access layer, and the **business objects** reside in the **service
    layer**. Finally, the **applications** reside in the application layer, which
    directly deals with end users. So, the service layer could be the surface tier
    for our API, in such a layered design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consider particular functionalities, such as registration, login,
    validation, and data abstraction into each unit or module. So, each layer will
    have compulsory units, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the application architecture](graphics/5801_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can easily understand that each layer contains its appropriate modules. For
    example, the DAO module resides in the data access layer, the service layer has
    its service units such as Validation, and the user service module and application
    layer contain user login, user registration, user profile, and admin modules.
    For our project to grasp the architectural concepts quickly, we will try to keep
    each module as a simple PHP class with associated codes.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's have a quick look at what we will be building finally.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot represents the **User Registration** screen with **Name,
    Email, Password**, and **Phone** fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the application architecture](graphics/5801_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot represents the **User Login** screen with the **Remember
    me next time** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the application architecture](graphics/5801_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot represents the **User Profile** view with the **Logout**
    and **Edit Account** menus at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the application architecture](graphics/5801_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the DAO pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DAO is used to abstract and encapsulate all access to the data source. The
    DAO manages the connection with the data source, to obtain and store the data.
  prefs: []
  type: TYPE_NORMAL
- en: '"The DAO implements the access mechanism required to work with the data source.
    The data source could be a persistent store like an RDBMS, an external service
    like a B2B exchange, a repository like an LDAP database, or a business service
    or low-level sockets. The business component that relies on the DAO uses the simpler
    interface exposed by the DAO for its clients.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The DAO completely hides the data source implementation details from its clients
    (data client). Because the interface exposed by the DAO to clients does not change
    when the underlying data source implementation changes, this pattern allows the
    DAO to adapt to different storage schemes without affecting its clients or business
    components. Essentially, the DAO acts as an adapter between the component and
    the data source. The pattern originates from the core J2EE pattern."
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html](http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The purpose of using DAO is relatively simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be used in a large percentage of applications, wherever data storage
    is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It hides all the details of the data storage from the rest of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It acts as an intermediary between your application and the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows ripple effects from the possible changes to the persistence mechanism
    to be confined to a specific area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing OOP issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s have a look at a few object-oriented programming keywords for access
    modifiers or properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Public:` This property or method can be used from anywhere in the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Private:` This property or method can be used only by the class or object
    it is part of; it cannot be accessed elsewhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protected:` This property or method can be used only by code in the class
    it is part of, or by children of that class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Final:` This method, or class, cannot be overridden in subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Abstract:` This method or class cannot be used directly, and you have to subclass
    this; it cannot be instantiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Static:` This property or method belongs to the class itself and not to any
    instance of it. You can also think of static properties as global variables that
    sit inside a class, but are accessible from anywhere via the class. Static members
    can be accessed using the `::` operator after the class name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '"A namespace (sometimes also called a name scope) is an abstract container
    or environment created to hold a logical grouping of unique identifiers or symbols
    (i.e., names). An identifier defined in a namespace is associated only with that
    namespace. The same identifier can be independently defined in multiple namespaces."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '- Wikipedia'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Namespaces** were introduced into PHP from version 5.3 onwards. In PHP, a
    namespace is defined using a namespace block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the PHP world, namespaces are designed to solve two problems, which authors
    of libraries and applications encounter when creating reusable code elements,
    such as classes or functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Ability to avoid name collisions between the code you create, and internal PHP
    classes/functions/constants or third-party classes/functions/constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to alias (or shorten) extra-long names designed to alleviate the first
    problem, improving the readability of the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PHP namespaces provide a way to group related classes, interfaces, functions,
    and constants. Here is an example of a namespace''s usage in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use classes of the same name and reference with the PHP namespace, in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use `My` as a common root namespace for the whole application, `My\Dao`
    for our data access layer classes, and `My\Service` for our Service layer classes.
  prefs: []
  type: TYPE_NORMAL
- en: The API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In object-oriented languages, an API usually includes a description of a set
    of class definitions, with a set of behaviors associated with those classes. A
    behavior is a set of rules for how an object, derived from that class, will act
    in a given circumstance. This abstract concept is associated with the real functionalities
    exposed or made available by the classes, which are implemented in terms of class
    methods (or more generally, by all its public components, hence all public methods,
    but also possibly including any internal entity made public, such as fields, constants,
    and nested objects).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a class representing a stack can simply expose two methods publicly—`push()`
    (to add a new item to the stack), and `pop()` (to extract the last item, ideally
    placed on top of the stack).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the API can be interpreted as two methods—`pop()` and `push()`.
    More generally, the idea is, one can use methods of the `Stack` class that implements
    the behavior of a stack (pile exposing its top to add/remove elements).
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good. We have the concepts about our project, and we know NetBeans
    features very well. Now, let's get down to the development...
  prefs: []
  type: TYPE_NORMAL
- en: Designing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will design our MySQL database. Since we learned how to
    create a database connection, new database, new table, and how to run a MySQL
    query inside NetBeans in [Chapter 3](ch03.html "Chapter 3. Building a Facebook-like
    Status Poster using NetBeans"), *Building a Facebook-like Status Poster Using
    NetBeans*, we won't discuss them again, but we'll have a look at the database
    schema definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have `id` (auto incremented with each entry) as the primary
    key and `useremail` as the unique key in the `users` table. We have a `password`
    field to store the user's password to up to 32 characters; `userhash` of 32 characters
    will store the user's login session identifier; `userlevel` to define the user's
    access level, for example, a normal user as `1`, an admin user as `9`, and so
    on; a `username` field to support maximum 100 characters; a `phone` field to store
    a user's contact number; and a `timestamp` field to keep track of a user's registration
    time. The database engine chosen is **InnoDB**, as it supports transactions and
    foreign keys over the **MyISAM** engine, to avoid table locking during `insert`
    and `update` operations by any user.
  prefs: []
  type: TYPE_NORMAL
- en: So, all you need to do is to create a new database named `user`, just type in
    the MySQL query inside the NetBeans query editor, and run the query to have your
    table ready in the `user` database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a NetBeans PHP project and start the User API development along
    with the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data access layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data access layer will consist of a User DAO class to provide database abstraction
    and an abstract Base DAO class to provide abstract methods, which is required
    for the User DAO class to be implemented. Also, we will create the abstract class
    to provide abstract methods for DAO classes to be created in our future projects.
    Note that we will use PHP namespace, `My\Dao`, for the data access layer classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the BaseDao abstract class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract class will be used to provide a basic framework for subclasses
    to implement methods. Simply, the basic database operations are `CRUD` or `create,
    read, update`, and `delete`. So, the abstract class will provide these types of
    abstract methods along with methods that will be required in every subclass. The
    `BaseDao` abstract class will contain the `final` method for database connectivity,
    so the subclasses don't need to write it again. To understand this better, we
    will keep our DAO classes in a separate directory named `Dao` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — creating the BaseDao class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use with a database connection, we will keep the database access credentials
    as their own class constants. Also, we will use PDO for all sorts of database
    operations. To create the `Base` class, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new PHP file inside the `Dao` directory named `BaseDao.php`, and type
    in the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this class `uses namespace My\Dao;`, and there is also an `abstract`
    keyword before the class name, which defines the class as abstract. This means
    that the class cannot be instantiated or has at least a single abstract method
    inside. Also, you can see the added class constants, which contain the database
    information and a private class variable `$db` to hold the database connection.
    You may modify those constants as per your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following `getDb()` method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `protected final function getDb()` function connects with the MySQL database
    using PDO. The private variable of the class stores the PDO instance that can
    be used for database connectivity. Moreover, the `getDb()` method is `final` and
    `protected`, so the subclasses inherit this method and unable to override it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$dsn` variable contains the **Data Source Name (DSN)**, which contains
    the information required to connect to the database. The following line creates
    a PDO instance to represent a connection to the requested database and returns
    a PDO object on its success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that the DSN throws a `PDOException` exception, if the attempt to connect
    to the requested database fails. We prefixed PDO with the backslash \, so PHP
    knows it's in the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `abstract` methods to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the methods to be implemented by the subclasses are denoted
    as `abstract protected,` and the `get()` method will be used to select a single
    entry from the table based on a unique table key, `insert()` will insert a row
    into the table, `update()` will be used to update a row in the table, and `delete()`
    will be used to delete an entry. So, all these methods have been kept abstract
    (without the method body), as they will be implemented by using the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the `BaseDao` abstract class ready to be inherited by the DAO classes.
    The PDO instance is created and returned from the method, so all the subclasses
    will have the `getDb()` method, and can have this returned instance to perform
    some sort of database tasks using PDO. Finally, subclasses will implement the
    `abstract` methods as per their demand. For example, in the next tutorial, the
    User DAO class will implement the `get()` method to select and return a single
    user registration information matching the user's e-mail address from the `users`
    table, or the Product DAO class will implement the `get()` method to select and
    return single product information from the `products` table matching the product
    ID. Hence, the intention to practice such an abstract class is to deliver the
    basic framework for the Dao classes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the biggest advantages of using PDO is that if we want to migrate into
    other SQL solutions, all we need is to adjust the DSN parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the User DAO class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, we will create the User DAO class, which will provide all
    sorts of database tasks inside it. This class will keep the database hidden from
    the consecutive layers, that is the Service layer class. So, all the consecutive
    layer classes will call methods from this class and have all the necessary database
    work done by this class, while the data storage details are completely hidden
    to them. So, this class will act as an intermediary between the database and the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — creating the User Dao class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep the relevant user constants as class constants. We will write
    the implementation of the methods from the `BaseDao` abstract class in this class.
    Simply, we will add the body of those abstract methods and our own methods required
    into the class. So, follow the steps listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new PHP file inside the `Dao` directory named `UserDao.php`, and type
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the class is under the `My\Dao` namespace and extends to the
    `BaseDao` class, so the class will have methods inherited from the parent. The
    Dao class has its own private `$db`, which stores the PDO instance returned by
    the inherited `getDb()` method; as you can see, this `$db` variable is assigned
    to the class constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might have noticed that the `UserDao` class has been instantiated
    at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the implementation of the `get()` method (add the method to the class),
    so that it looks similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `prepare()` method prepares the SQL statement to be executed
    by the `PDOStatement::execute()` method. As you can see, the following statement
    query is used to select all the columns of a row from the `users` table, while
    the given e-mail address in `:useremail` (parameter bound with `bindParam()`)
    matches the `useremail` column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if a matching row is found, fetch the array containing the user details
    and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the implementation of the `insert()` method, so that it looks similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The method takes the user info passed in an array, prepares the MySQL `insert`
    query for the `users` table, and executes the query. Note that we have kept the
    field names in the `$fields` array and field values in the `$vals` array extracted
    from the keys and values of passed arrays respectively. We have used ? in place
    of all the given values for the prepared statement, which will be replaced with
    the corresponding value bound with the `PDOStatement::bindValue()` method. `bindValue()`
    binds a value to a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the implementation of the `update()` method, so that it looks similar
    to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It prepares the MySQL `UPDATE` query statement in the same way as *step 3*,
    and executes the query to update the corresponding column values in the row with
    the given ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may leave the other implementation as an empty enclosing body, as follows,
    or you can add your own code, as required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we may implement the method to delete a user in future, we have left the
    `delete()` method's body empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need some additional methods to be written in the class. While registering
    a user with any e-mail address, we can check our database to see if the e-mail
    address already exists in the table or not. Type in the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `useremailTaken()` method takes an e-mail address as the parameter to check
    whether that e-mail ID exists or not. It does the task by running a `SELECT` query
    with the given e-mail address in the `WHERE` clause. If any row is found, then
    it means that the e-mail address already exists, and hence the method returns
    `true`, or otherwise `false`. With this method, we can ensure that one e-mail
    address can be used only once in the system, and duplicate e-mail addresses are
    not allowed as this is a unique field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm the user''s password during login, type in the following `checkPassConfirmation()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The method takes `$useremail` and `$password` as the parameter, and selects
    the `password` column for matching the user's e-mail. Now, if no row is found
    matching the criteria, then it means that the user's e-mail does not exist in
    the table, and `false 1` is returned; and if a matching row is found, then the
    array is fetched from the result to obtain the password. Finally, the fetched
    password from the database is compared with the given password in the second parameter.
    If they match, then `true` is returned. So, we can use this method to confirm
    the password for the given corresponding user's e-mail, while the user attempts
    to log in with them and can easily track the status with returned Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we have already added a field in the `users` table named `userhash`.
    The field stores a hash value (random alphanumeric string) for each login session,
    so we want to confirm that `userhash`, in order to verify if the user is currently
    logged in. Type in the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `checkHashConfirmation()` method is the same as the previous method in *step
    7* and takes `$useremail` and `$useremail` as parameters, fetches `useremail`
    for the given e-mail address, and compares itself with the given `useremail`.
    So, the method that can be used to compare the `useremail` is the same for both
    the session and the database. If it is the same, it means that the user is currently
    logged in, because each new login updates the corresponding `useremail` in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `PDO::prepare()` and `PDOStatement::execute()` for statements, which
    will be issued multiple times with different parameter values, optimizes the performance
    of your application, by allowing the driver to negotiate the client and/or server-side
    caching of the query plan and meta information, and helps to prevent SQL injection
    attacks, by eliminating the need to manually quote the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the User DAO class ready, and the DAO layer is also complete inside
    the `Dao` directory in our NetBeans project. So, the User DAO class is ready to
    provide the required sort of database operations. The database operations can
    be dealt with in a way such as we have done, so that other subsequent classes
    don't need to access or rewrite database functionalities, and hence abstraction
    around the database has been achieved. We can add any sort of database-related
    methods in this class, to make them available for the Service classes. Now, the
    instantiated object will serve as a data access object, which means this object
    has access to the data in the data source, and anyone can read or write data via
    this object.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz — reviewing PDO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which one is correct for the `bindValue()` and `bindParam()` methods of PDO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can only pass variables, not values using `bindParam`, and you can pass
    both with `bindValue`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can only pass values using `bindParam`, and you can pass only variables
    with `bindValue`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can pass variables using `bindParam`, and you can pass values with `bindValue`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both are the same
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's create the Service layer for our API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Service layer contains classes to serve applications, or simply provides
    a framework for the application. The application layer will communicate with this
    layer to have all sorts of application services, such as user authentication,
    user information registration, login session validation, and form validation.
    For a better understanding, we will keep our service classes inside a separate
    directory named `Service` and use the namespace `My\Service`, for the classes
    of this layer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ValidatorService class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class will perform validation tasks, such as form validation and login
    information validation, and also save to deliver form error messages and field
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — creating the ValidatorService class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will keep some validation constants in the class itself, and the class will
    use `My\Service` as its namespace. Follow these steps to create the `ValidatorService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory named `Service` under your project directory. The Service
    classes will be inside this directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new PHP file inside the `Service` directory named `ValidatorService.php`,
    and type in the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the class is under the `My\Service` namespace and imports the `My\Dao\UserDao`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: You can see the class variable `$values`, which holds the submitted form values;
    `$errors`, which holds the submitted form error messages; `$statusMsg`, which
    holds the submitted status message that is success or temporary information; and
    `$num_errors,` which holds the number of errors in submitted form.
  prefs: []
  type: TYPE_NORMAL
- en: We also added class constants for validation purposes. We keep the username
    length within 5 and 100 characters and the `password` field length between 8 and
    32 characters.
  prefs: []
  type: TYPE_NORMAL
- en: As the class is dependent on the UserDao class, we injected the `$userDao` object
    inside, using a `setter` method `setUserDao()`; the `$userDao` object passed is
    stored in a class variable, so that the DAO can be used in other methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, fill in the class constructor, so that it looks similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that both `$_SESSION[''value_array'']` and `$_SESSION[''error_array'']`
    have been checked initially. If they have some value set, then assign them to
    the corresponding class variables, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Also, `num_errors` has been adjusted with the count of the `errors` array. Note
    that values in `$_SESSION['value_array']` and `$_SESSION['error_array']` will
    be set by the application class from where this service API will be used. These
    session variables have been unset immediately after grabbing their values to make
    them prepare for the next form submission. If these variables haven't been set,
    `num_errors` should be `0` (zero).
  prefs: []
  type: TYPE_NORMAL
- en: It also checks the `$_SESSION['statusMsg']` variable. If any status message
    has been set, grab the message into appropriate class variables and unset it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type in the form and error handler methods into the class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In these class methods, you can see that `setValue($field, $value)` and `getValue($field)`
    methods are used to set and get the value of a single corresponding field, respectively.
    Similarly, `setError($field, $errmsg)` and `getError($field)` set and get the
    error message for a corresponding form field value while validating, while at
    the same time, setError increases the `num_errors` value. Finally, `getErrorArray()`
    returns the complete error messages array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type in the value validation methods of the form field as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The validation methods can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate($field, $value)` is the entry function for validation. Methods for
    input validation, such as empty string checking, correct input format, or input
    size range, can be called from this method, and it also returns `true` if the
    validation passes, or `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isEmpty($field, $value)` checks whether the string is empty or not, then sets
    the error message for that field and returns `false` or `true` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkFormat($field, $value)` tests fields'' values against appropriate regular
    expressions written for each field format, sets an error (if any), and returns
    `false`, or otherwise `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkSize($field, $value, $minLength, $maxLength)` checks whether the input
    is within the given minimum size and maximum size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We want to validate the login credentials to check whether the user e-mail
    exists or whether the password belongs to the user matching that user e-mail.
    So, add the `validateCredentials()method` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The method takes `$useremail` and `$password` for login credentials validation.
    You can see that the following line uses `user Dao` for confirming the password
    associated with the `useremail`. The Dao `checkPassConfirmation()` method returns
    `true` as the confirmation and `false` for either e-mail address or password is
    incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When a user wants to register into our application, we can validate the e-mail
    address for its pre-existence. If the e-mail is not already registered in the
    database, then the user is free to register with that e-mail. So, type in the
    following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the method uses `userDao` in `$this->userDao->useremailTaken($useremail);`
    to check whether the user e-mail is already taken or not. If it's taken, set the
    error, and return `true` as the e-mail exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Password confirmation is again required when the user wants to update the current
    password. So, let''s add another method for validating the current password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the validator service class ready for supporting the form, login credentials,
    and password validations, or even communicating with the database via `userDao`.
    Also, the validator service allows the application to retrieve temporary status
    messages for the guest or the user, and error messages for form input fields as
    well. So, it deals with all sorts of validation tasks, and the validator methods
    set errors if found, and return `true` on success or `false` on failure, respectively.
    Such error messages can be viewed, besides the corresponding form fields, as well
    as field values. Hence, it also helps to create the data persistence form.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero — adding multibyte encoding support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, our validator service doesn't have the ability to support multibyte
    character encoding. To enable the application with different character encodings
    such as UTF-8, you can implement the multibyte support in validation methods,
    such as set internal encoding, regular expression match for a multibyte string,
    and the use of `mb_strlen()` instead of `strlen()`. Multibyte string functions
    can be found at [http://php.net/manual/en/ref.mbstring.php](http://php.net/manual/en/ref.mbstring.php).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UserService class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UserService` class supports all the application tasks, such as login, register,
    or updating user details. It corresponds with the `UserDao` class for any sort
    of data-related functions and with the `ValidatorService` service class for any
    sort of validation functions. Asked by the application for tasks, such as login
    or register, it first calls for validation and then performs the task, while it
    may use DAO as required. Finally, it returns with `true` if the task has been
    accomplished, or `false` for any failure, such as a validation fail or any other
    ambiguity. Simply, applications will call the methods from the `UserService` class
    to login, register, and so on, and can know the status of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — creating the UserService class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use `My\Service` as the namespace for this class, and keep any constants
    in the class. The `UserService` class attributes will contain the user information,
    such as the user e-mail, user ID, username, or phone, and the constructor checks
    for logged in user and class variables loaded with the user details from the session.
    Also, the class will make use of PHP cookies to store the user's login data. The
    class will act as the login session manager. So initially, the class will check
    for the login data in sessions or in cookies that the user is logged into.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you are familiar with PHP sessions and cookies for this
    tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s go through the following steps, in order to create the `UserService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new PHP file inside the `Service` directory named `UserService.php`,
    and type in the following class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the class uses `namespace My\Service;`, and the Service User
    class may be accessed using `\My\Service\UserService.`
  prefs: []
  type: TYPE_NORMAL
- en: Check out the class variable, which stores the user data. `$logged_in` is `true`
    if the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: To distinguish among users, the user-related constants have been added. Update
    `ADMIN_EMAIL` with your own; the administrator among the users will be defined
    by `ADMIN_EMAIL` and `ADMIN_LEVEL` equal to `9`. The general registered users
    will be defined as `USER_LEVEL` equal to 1, and non-registered users will be defined
    as `GUEST_LEVEL` equal to `0` or `GUEST_NAME` as Guest. So, the user who registers
    with an e-mail address as `<[admin@mysite.com](mailto:admin@mysite.com)>` will
    have admin access when we implement admin features.
  prefs: []
  type: TYPE_NORMAL
- en: At the cookie constant's section, `COOKIE_EXPIRE` has the cookie expiration
    time set to `100` days (8640000 seconds) by default, and `COOKIE_PATH` says that
    the cookie will be available for the whole application domain.
  prefs: []
  type: TYPE_NORMAL
- en: The cookie (a text file on the user's computer) will be used to store `useremail`
    as `cookname` and `userhash` as `cookid`. These cookies will be set in the case
    of a user-enabled option `Remember Me`. So, we will initially check to see if
    cookies are found on the user's local computer that match with the database, and
    if so, we will consider the user as a logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the constructor is injected with the `UserDao` and `ValidatorService`
    objects, so the class can use these dependencies inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the line `$this->logged_in = $this->isLogin();` the constructor checks
    whether the user is logged in or not. The `private` method `isLogin()` checks
    for login data and if found then returns as `true`, or `false` otherwise. Actually,
    `isLogin()` checks the session and cookies for a user's login data, and if the
    data is available, it loads the class variables.
  prefs: []
  type: TYPE_NORMAL
- en: Non-logged-in users will be guest users, so `useremail` and `userlevel` are
    set to `Guest` and `Guest Level 0`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `isLogin()` method, so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If `$_SESSION` has `useremail, userhash,` and `useremail` not as guest, then
    it means that the user has already logged in to the data. If so, we want to confirm
    `userhash` and the associated `useremail` for security with the `checkHashConfirmation()`
    method of `UserDao`. If not confirmed, then unset the `$_SESSION` variable, and
    consider it as not logged in, by returning it as `false.`
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if all is well, load the logged-in user's details using `Dao` at `$userinfo
    = $this->userDao->get($_SESSION['useremail']);;` load the class and session variables,
    and return it as true.
  prefs: []
  type: TYPE_NORMAL
- en: Again, if `$_SESSION` doesn't have the logged-in data, then we'll choose to
    check into cookies also, as the user may have enabled the `Remember Me` option.
    These cookies are set if the user is asked to remember him when he logs in. So,
    if the necessary data is found in cookie variables, then the class and session
    variables are loaded from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the login service for the applications as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method takes login details, such as `useremail, password,` and `rememberme`,
    and passes them in the `$values` array from the application. It calls for validation
    of the given input, returns as false if an error is found, and validates the association
    of access credentials afterwards. If all the cases have passed the validation,
    it will load the user information from the Dao. Note that in the following line,
    `md5(microtime())` creates a random string of alphanumeric characters and is assigned
    to the class variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, for new login sessions to be initiated, update the corresponding user's
    `userhash` in the table that will be the identifier for the current session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So, `$_SESSION userhash` and database `userhash` should be the same for an active,
    logged-in session.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you can see, if `$rememberme` is `true`, then the cookie is set using
    PHP's `setcookie()` method, and the cookie is set with a name, value, and its
    expiration time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the user registration service method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the user details for registration, passes them in the `$values`
    array, and validates them. If validation gets passed, it packages the user registration
    details into an array, and saves them to the database using the `insert()` method
    of User Dao.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the user level is determined by comparing a registrant's e-mail address
    with `ADMIN_EMAIL.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `getUser()` method as follows, to provide user information matching
    a given `useremail` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that `useremail` is validated before delivering user information. So, the
    application will use this method whenever any user information is required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, add the `update()` method for the user's details modification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the method validates the given information (if any) first. If it passes
    the validation criteria, the corresponding column(s) value changes into the database
    table via User Dao.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logout()` method can be added as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `logout` method unsets all the cookies and session variables, sets `$this->logged_in`
    to `false`, and the user becomes a guest user again.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now check if a user is logged in or not and whether the user is asked
    to remember the login details, so the user doesn't want to log in with the `Remember
    Me` option again. The class serves for login, logout, user registration, and update
    or retrieval of the user information to the application layer. It uses the validator
    service before proceeding with the Dao layer. So, the class ensures the data security
    as well, which makes the `UserService` class ready at the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have our API ready to work, and by using this API, we can build
    an application for user registration, user profile update, login, and logout.
    We have our data access layer and the service layer operational. Now, let's have
    a look at our NetBeans project directory.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](graphics/5801_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For a better understanding, we have used a separate directory and a separate
    namespace for each layer. Now, we will include the API in our application file,
    and by using the User Service object, we will be achieving our application's goals.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz — using namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which features does the PHP namespace support?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aliasing a class name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aliasing an interface name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Aliasing a namespace name
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Importing a function or constant
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which one will import a global class named `foo?`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: namespace foo;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: use foo;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: import foo;
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: None of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this tutorial, we will build the application that is capable of dealing with
    the user registration tasks, such as registration form handling, saving user data
    via API, or displaying error messages, and user login and logout tasks. In our
    next section, we will build the PHP application, and then add the application
    user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding, keep in mind that all we have is the service layer classes.
    We'll choose to build the application in such a way that our application stands
    on top of the service layer. For this section, we don't need to think about the
    underlying database or Dao, rather we need to think from the application developer's
    perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — creating the user application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will integrate the API into our user application file, which will be the
    main application file; there might be interfaces or view files for each application
    purpose. Let''s go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new PHP file inside the project directory named `UserApplication.php`,
    and type in the following `UserApplication` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the file, you can see that after the constructor declarations,
    the PHP session started with `session_start()`. The API files have been included,
    and the class constructor has been injected with the `User` and `Validator Service`
    objects, so these objects become available throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that appropriate methods are called from the constructor depending
    on the user''s request, such as `$this->login();` is called if `$_POST[''login'']`
    is set. So, all the methods are called from the constructor, and shall have the
    following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`login()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`register()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logout()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom of the file, we have the line `$userApp = new \My\Application\UserApplication($userService,
    $validator);`, which instantiates the `UserApplication` class along with the dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the following `login()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the method calls the user service with the login credentials
    posted from the user interface in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If the login attempt is successful, it sets the success status message in the
    `$_SESSION['statusMsg']` session variable, and if it fails, it sets the `$_POST`
    array posted by the user into `$_SESSION['value_array'],` with an error array
    obtained from the validator object into `$_SESSION['error_array']`. Finally, it
    is redirected to the `index.php` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the following `register()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can see that if the registration attempt fails, it resets the corresponding
    session variables and is redirected to the `register.php` page, which is the user
    registration page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the following `update()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can see that if the user profile update attempt fails, then it resets the
    corresponding session variables and is redirected to the `profileedit.php` page,
    which is the profile edit page, or is redirected to `profile.php` on success.
    So, these pages will be our user profile view and update page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the following `logout()` method that simply calls the logout service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now our main application class is ready and the functionalities are as well.
    So we can register, log in, update, and log out a user using the application.
    Note that our application is just communicating via service objects, and you can
    feel that the application is not interested in the data sources; all it is doing
    is utilizing the service designed for it. In this fashion, we may write more interesting
    applications for the users, such as registered user list viewing; develop admin
    features, such as update any user or remove any user and even promote a user from
    normal to admin by just updating `userlevel`. It will be fun to add more features
    in terms of methods in different layers, to obtain a specific application.
  prefs: []
  type: TYPE_NORMAL
- en: In our next and final section, we will just add user interfaces or pages for
    a particular functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will create simple user interfaces and forms for user registration and login.
    Also, we will provide some user menus for viewing the user profile, updating the
    profile, and to log out. We shall integrate `UserApplication.php` at the very
    top of our interface files. Our interface files will consist of simple HTML with
    PHP code integrated inside.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — creating the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will integrate the user application file at the very beginning of each interface
    file. So, follow these steps to create various user interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `index.php` and integrate the `UserApplication` class so that it looks
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And all the interface codes can be inside the body tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a logged-in user menu that shows the status message (if
    any), logged-in username, and menus at the top of each page. Create a new PHP
    file named `menu.php`, and type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that if `$validator->statusMsg` is available, then we displayed
    it inside the colored `span` tag. Also, if the user is logged in, then it displays
    the user name inside the `<h2>` tag and displays `anchor` tags for profile view,
    edit profile, and logging out. Now, in our pages, we will include this menu inside
    the `<body>` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the user registration page, `register.php`, and type in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You can see the user registration form displayed when the user is not logged
    in. `Number of errors` shows before the form with `$validator->num_errors`, if
    it has any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following line, you can see that the form will be posted to the UserApplication.php
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The form consists of four input boxes for name, e-mail, password, and phone
    number, and a submit button for form submission. The form comes with a hidden,
    input field that has a preloaded value. This hidden field value will be used to
    identify the login task by the `UserApplication` class constructor, in order to
    call the appropriate method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look into an input field as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the field value has been dumped (if available using `$validator->getValue("name")`)
    at the `value` attribute. The field value can be found at the `validator` method
    using the field name during form validation. Also, by using `$validator->getError("name")`,
    any error associated with the `name` field will be displayed. So, the rest of
    the fields are designed to be alike.
  prefs: []
  type: TYPE_NORMAL
- en: To test form validation, point your browser with `register.php`; click on the
    **Register** button to submit the form without filling any field. The form looks
    similar to the following screenshot with an error indicated beside each field.![Time
    for action — creating the user interface](graphics/5801_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that the form is displayed with errors for each field, and at the
    top of the form, the number of errors has been displayed. So, our validator and
    user services are working. Hence, you can test the registration form for written
    validation cases, and finally fill-in the form to register yourself and check
    the database table for your submitted information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the login form inside the `index.php` file, at the `<body>`
    tag with the `Remember me` option, so that the body tag contains the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Check out the login form; the fields have been organized in the same way as
    the registration form. The form contains a hidden field name `login` and `value`
    set to `1`. So when the form is posted, the application class can identify that
    the login form has been submitted, and hence the application login method has
    been called. The login form page looks similar to the following:![Time for action
    — creating the user interface](graphics/5801_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the login form with your registered data and log in. After a successful
    login, you will be redirected to the same page, as follows:![Time for action —
    creating the user interface](graphics/5801_07_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see the green-colored, **Successful login** status at the top of the
    page, and as the user is logged in, the login form is no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the `profile.php` profile page (you can create the file from any
    interface page by selecting **File | Save As...** from menu and modify it inside
    the body tag), as it is supposed to have the following code inside the `body`
    tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, you can see that the logged-in user''s profile information
    is dumped, which looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — creating the user interface](graphics/5801_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, create the profile edit page, `profileedit.php`, and type in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This form contains the user profile update fields, such as name, password,
    and phone; note that if any field such as password remains blank, then the field
    won''t be updated. Finally, while testing, the form looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action — creating the user interface](graphics/5801_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can test the logout feature. Check out the menu file for the logout,
    `anchor` tag, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can see that it has directly anchored the `UserApplication.php` file with
    a `logout=1` URL segment, so the `UserApplication` constructor finds that logout
    has been called with `$_GET['logout'],` and calls the application logout. Logging
    out redirects you to the index page.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created and tested our newly built user interfaces. The test was fun
    while registering the user, logging in, or updating the user profile. Keep in
    mind that we can use this login application in our upcoming projects, or can easily
    integrate new features with minimal cost. Our goal to create a layered architecture
    and build the application according to that design has been achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The complete project source code for this chapter can be downloaded from the
    Packt Publishing website. Also you can fork an extended version of this project
    at GitHub: [https://github.com/mahtonu/login-script](http://https://github.com/mahtonu/login-script).'
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz — the application architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How many layers do we have in our application architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Database abstraction is achieved in which layer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data storage layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data access layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstraction layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the above
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our application, which method directly communicates with the database for
    e-mail address existence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`useremailTaken()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`emailExists()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`checkEmail()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`confirmEmail()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero — creating admin features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have already noticed, we have created a database table column to define
    the admin user. So, implement admin features in the user service, such as a method
    to determine whether a user is the admin or not; if he/she is the admin, then
    add the admin page/interface method to get all user lists from user Dao, and display
    these user details, and so on. Again, you can implement the admin feature to promote
    a general user to the admin user, by updating the `userlevel` column.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed the user registration, login, and logout
    application with a layered design. We are now confident with enterprise system
    architecture, and can easily add or remove features into or from the developed
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have specially worked on:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing application architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the DAO pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the DAO classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the service classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the application for user registration, login, and logout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we have entered into professional PHP project development and practices
    of IDE features, which has helped us tremendously. We may use this project in
    our future web applications, where the user login facility is required; this is
    the advantage of "developing once, updating little, and using all the time".
  prefs: []
  type: TYPE_NORMAL
