- en: Chapter 7. User Access Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'User-based web applications, like our TrackStar application, typically need
    to control access to certain functionality based on who is making the request.
    When we speak of *user access control*, we are referring, at a high level, to
    some questions the application needs to ask when requests are being made. These
    questions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Who is making the request?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does that user have the appropriate permission to access the requested functionality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The answers to these questions help the application respond appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The work completed in [Chapter 6](ch06.html "Chapter 6. User Management and
    Authentication"), *User Management and Authorization* provides our application
    with the ability to answer the first of these questions. The application now allows
    users to establish their own authentication credentials and validates the username
    and password when a user logs in. After a successful login, the application knows
    exactly who is making subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on helping the application answer the second
    question. Once the user has provided appropriate identification, the application
    needs a way to determine if they also have permission to perform the requested
    action. We'll extend our basic authorization model by taking advantage of Yii's
    user access control features. Yii provides both a **simple access control filter**
    as well as a more sophisticated **Role Based Access Control** (**RBAC**) implementation
    as a means to help us address our user authorization requirements. We'll take
    a closer look at both of these as we work to implement the user access requirements
    for the TrackStar application.
  prefs: []
  type: TYPE_NORMAL
- en: Feature planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we first introduced our TrackStar application back in [Chapter 3](ch03.html
    "Chapter 3. The TrackStar Application"), *The TrackStar Application*, we mentioned
    the application has two high-level user states, namely anonymous and authenticated.
    This simply makes a distinction between a user that has successfully logged in
    (authenticated), and one who has not (anonymous). We also introduced the idea
    of authenticated users having different roles within a project. Within a specific
    project, a user can be in one of the following three roles:'
  prefs: []
  type: TYPE_NORMAL
- en: A **project owner** has *all* administrative access to the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **project member** has *some* administrative access, but has more limited
    access compared to the project owner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **project reader** has *read-only* access. Such users cannot change the content
    of a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The focus of this chapter is to implement an approach to manage the access control
    granted to application users. We need a way to create and manage our roles and
    permissions, assign them to users, and enforce the access control rules we want
    for each user role.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve the goals outlined earlier, we will focus on the following
    throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement a strategy to force the user to log in before gaining access to any
    project or issue-related functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create user roles and associate those roles with a specific permission structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the ability to assign users to roles (and their associated permissions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure our role and permission structure exists on a per-project basis (that
    is, allow users to have different permissions within different projects)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the ability to associate users to projects and at the same time to
    roles within that project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the necessary authorization access checking throughout the application
    to appropriately grant or deny access to the application user based on their permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily, Yii comes with a lot of built-in functionality to help us implement
    these requirements. So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Access control filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first introduced *filters* back in [Chapter 5](ch05.html "Chapter 5. Managing
    Issues"), *Managing Issues* when we enforced a valid project context before allowing
    issue functionality to be used. If you recall, we added a class method filter
    `filterProjectContext()` to the `IssueController` class as a way to ensure we
    had a valid project context before we performed any actions on an Issue entity.
    Yii provides a similar approach for handling simple access control on an action-by-action
    basis within controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Yii framework provides a filter called `accessControl` *.* This filter
    can be directly used in controller classes to provide an authorization scheme
    to verify whether or not a user can access a specific controller action. In fact,
    the astute reader will remember that when we were implementing the `projectContext`
    filter back in [Chapter 5](ch05.html "Chapter 5. Managing Issues"), *Managing
    Issues*, we noticed that this access control filter was already included in the
    filters list for both our `IssueController` and `ProjectController` classes, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This was included in the autogenerated code produced by using the Gii CRUD code
    generator tool. The autogenerated code also overrides the `accessRules()` method,
    which is necessary in order to use the access control filter. It is in this method
    where you define the actual authorization rules.
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation for our CRUD actions is set up to allow anyone to
    view a list of existing issues and projects. However, it restricts the access
    of creating and updating to authenticated users, and further restricts the delete
    action to a special *admin* user. You might remember that when we first implemented
    CRUD operations on projects, we had to log in before we were able to create new
    ones. The same was true when dealing with issues and again with users. The mechanism
    controlling this authorization and access is exactly this access control filter.
    Let's take a closer look at this implementation within the `ProjectController.php`
    class file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods relevant to access control in the `ProjectController`
    class: `filters()` and `accessRules()`. The `filters()` method configures the
    filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `accessRules()` method, which is used to define the authorization rules
    used by the access filter, is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `filters()` method is already familiar to us. It is where we specify all
    the filters to be used in the controller class. In this case, we have only one,
    `accessControl`, which refers to a filter provided by the Yii framework. This
    filter uses the other method, `accessRules()`, which defines the rules that drive
    the access restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: In the `accessRules()` method, there are four rules specified. Each rule is
    represented as an array. The first element of the array is either *allow* or *deny*.
    These indicate the granting or denying of access respectively. The rest of the
    array consists of `name=>value` pairs specifying the remaining parameters of the
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the first rule defined earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This rule allows the `actionIndex()` and `actionView()` controller actions to
    be executed by any user. The asterisk (`*`), used in the value for the `'users'`
    element, is a special character used to specify any user (anonymous, authenticated,
    or otherwise).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the second rule defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This allows for any authenticated user to access the `actionCreate()` and `actionUpdate()`
    controller actions. The `@` special character is a way to specify any authenticated
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third rule is defined in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This rule specifies that a specific user, named `admin`, is allowed access to
    the `actionAdmin()` and `actionDelete()` controller actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s have a closer look at the fourth rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This rule denies all users access to all controller actions. We'll elaborate
    on this one a little more in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access rules can be defined using a number of context parameters. The rules
    mentioned earlier are specifying actions and users to create the rule context,
    but there are several other parameters you can use. A few of these are given as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Controllers**: Specifies an array of controller IDs to which the rule should
    apply.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roles**: Specifies a list of authorization items (roles, operations, and
    permissions) to which the rule applies. This makes use of the RBAC feature we
    will be discussing in the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPs**: Specifies a list of client IP addresses to which this rule applies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verbs**: Specifies which HTTP request types (GET, POST, and so on) apply
    to this rule.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expression**: Specifies a PHP expression whose value indicates whether or
    not the rule should be applied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: Specifies the action method, by use of the corresponding action
    ID, to which the rule should match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Users**: Specifies the users to which the rule should apply. The current
    application user''s name attribute is used for matching. The following three special
    characters can also be used here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*****: any user'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**?**: anonymous users'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**@**: authenticated users'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no users are specified, the rule will apply to all users.
  prefs: []
  type: TYPE_NORMAL
- en: The access rules are evaluated one by one in the order they are specified. The
    first rule that matches the current pattern determines the authorization result.
    If this rule is an allow rule, the action can be executed; if it is a `deny` rule,
    the action cannot be executed; if none of the rules match the context, the action
    can still be executed. It is for this reason that the fourth rule mentioned earlier
    is defined. If we did not define a rule that denied all actions to all users at
    the end of our rules list, then we would not achieve our desired access restrictions.
    As an example, take the second rule. It specifies that authenticated users are
    allowed access to the `actioncreate()` and `actionUpdate()` actions. However,
    it does not stipulate that anonymous users be denied access. It says nothing about
    anonymous users. The fourth rule mentioned earlier ensures that all other requests
    that do not match one of the first three specific rules be denied access.
  prefs: []
  type: TYPE_NORMAL
- en: With this already in place, altering our application to deny access to all project,
    issue, and user related functionality for anonymous users is a snap. All we have
    to do is change the special character "`*`" of the users array value to the "`@`"
    special character. This will only allow authenticated users to access the `actionIndex()`
    and `actionView()` controller actions. All other actions are already restricted
    to authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we could make this change, three times, in each of our project, issue,
    and user controller class files. However, we have a base controller class from
    which each of these extend, namely the `Controller` class in the file `protected/components/Controller.php`.
    So, we can add our CRUD access rules in this one file, and then remove it from
    each of the child classes. We can also take advantage of the `controllers` context
    parameter when defining our rules so that it will only apply to these three controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add the necessary method to our base controller class. Open up
    `protected/components/Controller.php` and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code in the previous code snippet shows the changes we made.
    We have added the `controllers` parameter to each of our rules and changed the
    users for the index and view actions to only allow authenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can remove this method from each of the specified controllers. Open up
    all three of the `ProjectController.php`, `IssueController.php`, and `UserController.php`
    files and remove their respective `accessRules()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: After making these changes, the application will require a login prior to accessing
    any of our *project*, *issue*, or *user* functionality. We still allow anonymous
    user access to the `SiteController` class action methods, which we kept because
    this is where our login actions are located. We obviously have to be able to access
    the login page if we are not already logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Role based access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have used the simple access control filter to limit access to authenticated
    users, we need to turn focus to meeting some more specific access control needs
    of our application. As we mentioned, users will play certain roles within a project.
    The project will have users of type *owner*, who can be thought of as project
    administrators. They will be granted all access to manipulate the project. The
    project will also have users of type *member*, who will be granted some access
    to project functionality, but a proper subset of what owners are able to perform.
    Finally, the project can have users of type *reader*, who are only able to view
    project-related content and not alter it in any way. To achieve this type of access
    control based on the role of a user, we turn to the Role Based Access Control
    feature of Yii, also referred to more simply as RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC is an established approach in computer systems security to managing the
    access permissions of authenticated users. In short, the RBAC approach defines
    roles within an application. Permissions to perform certain operations are also
    defined and then associated with roles. Users are then assigned to a role and
    through the role association, acquire the permissions defined for that role. There
    is plenty of documentation available for the curious reader about the general
    RBAC concept and approach. Wikipedia, for example, [http://en.wikipedia.org/wiki/Role-based_access_control](http://en.wikipedia.org/wiki/Role-based_access_control).
    We'll focus on the specifics of Yii's implementation of the RBAC approach.
  prefs: []
  type: TYPE_NORMAL
- en: Yii's implementation of RBAC is simple, elegant, and powerful. At the foundation
    of RBAC in Yii is the idea of the **authorization item** . The authorization item
    is simply a permission to do things in the application. These permissions can
    be categorized as *roles*, *tasks*, or *operations*, and, as such, form a permission
    hierarchy. Roles can consist of tasks (or other roles), tasks can consist of operations
    (or other tasks), and operations are the most granular permission level.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in our TrackStar application, we need a role of type *owner*. So,
    we would create an authorization item of type *role* and call it "owner". This
    role could then consist of tasks such as a "user management" and "issue management".
    These tasks could then further consist of the atomic operations that make up these
    tasks. Continuing the example, the "user management" task could consist of the
    operations "create new user", "edit user", and "delete user". This hierarchy allows
    for inheritance of these permissions so that, given this example, if a user is
    assigned to the owner role, they inherit the permission to perform create, edit,
    and delete operations on the user.
  prefs: []
  type: TYPE_NORMAL
- en: Typically in RBAC, you assign a user to one or more roles and the user inherits
    the permissions that have been assigned to those roles. This holds true for RBAC
    in Yii as well. However, in Yii, we can associate users to any authorization item,
    not just the ones of type *role*. This allows us the flexibility to associate
    a specific permission to a user at any level of granularity. If we only want to
    grant the "delete user" operation to a specific user, and not give them all the
    access that an owner role would have, we can simply associate the user to this
    atomic operation. This makes RBAC in Yii very flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the authorization manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can establish an authorization hierarchy, assign users to roles, and
    perform access permission checking, we need to configure the authorization manager
    application component, `authManager`. This component is responsible for storing
    the permission data and managing the relationships between permissions. It also
    provides the methods to check whether or not a user has access to perform a particular
    operation. Yii provides two types of authorization managers `CPhpAuthManager`
    and `CDbAuthManager`. `CPhpAuthManager` uses a PHP script file to store the authorization
    data. `CDbAuthManager`, as you might have guessed, stores the authorization data
    in a database. The `authManager` is configured as an application component. Configuring
    the authorization manager consists simply of specifying which of these two types
    to use and then setting its initial class property values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use the database implementation for our application. To make this configuration,
    open up the main configuration file, `protected/config/main.php`, and add the
    following to the application components array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This establishes a new application component named `authManager`, specifies
    the class type to be `CDbAuthManager`, and sets the `connectionID` class property
    to be our database connection component. Now we can access this anywhere in our
    application using `Yii::app()->authManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RBAC database tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned, the `CDbAuthManager` class uses database tables to store the permission
    data. It expects a specific schema. That schema is identified in the framework
    file `YiiRoot/framework/web/auth/schema.sql`. It is a simple, yet elegant, schema
    consisting of three tables, `AuthItem`, `AuthItemChild`, and `AuthAssignment`.
  prefs: []
  type: TYPE_NORMAL
- en: The `AuthItem` table holds the information defining the authorization item that
    is the role, task, or operation. The `AuthItemChild` table houses the parent/child
    relationships that form our hierarchy of authorization items. Finally, the `AuthAssignment`
    table is an association table that holds the association between a user and an
    authorization item.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to add this table structure to our database. Just as we have done
    previously, we''ll use database migrations to make these changes. From the command
    line, navigate to the `/protected` directory of the TrackStar application, and
    create the migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new migration file under the `protected/migrations/` directory
    named according to the migration file naming conventions (for example, `m120619_015239_create_rbac_tables.php`).
    Implement the `up()` and `down()` migration methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After you save these changes, run the migration to create the needed structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once the necessary structure is created, you will see a message `Migrated up
    successfully` on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we stayed with our database table naming conventions, we need to alter
    our `authManager` component configuration to specify our specific table names.
    Open up `/protected/config/main.php`, and add the table name specification to
    the `authManager` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now the authorization manager component will know exactly which tables we want
    it to use to manage our authorization structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a reminder on how to use Yii database migrations, refer back to
    [Chapter 4](ch04.html "Chapter 4. Project CRUD"), *Project CRUD* where this concept
    was first introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RBAC authorization hierarchy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After adding these tables to our `trackstar` database, we need to populate
    them with our roles and permissions. We will do this using the API provided by
    the `authmanager` component. To keep things simple, we are going to only define
    roles and basic operations. We will not set up any formal RBAC tasks for now.
    The following diagram displays the basic hierarchy we wish to define:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the RBAC authorization hierarchy](graphics/8727_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The diagram shows the top-down inheritance. So, owners have all the permissions
    listed in the Owner box, plus they inherit all the permissions from both the member
    and reader roles. Likewise, member inherits permissions from reader. What we now
    need to do is establish this permission hierarchy in the application. As previously
    mentioned, one way to do this is to write code to utilize the `authManager` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of using the API, the following code creates a new role and a
    new operation, and then adds the relationship between the role and the permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Walking through this code, we first get an instance of the `authManager`. We
    then use its `createRole()`, `createOperation()`, and `addChild()` API methods
    to create a new `owner` role, and a new operation named `createProject`. We then
    add the permission to the owner role. This only demonstrates the creation of a
    small part of our needed hierarchy; all of the remaining relationships we outlined
    in the previous diagram need to be created in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: We could create a new database migration, and place our code there in order
    to populate our permission hierarchy. However, we are going to take a different
    approach in order to demonstrate using console commands in your Yii applications.
    We are going to write a simple shell command to be executed at the command line.
    This will extend the command options of the `yiic` command-line tool we used to
    create our initial application.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a console application command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduced the `yiic` command-line tool back in [Chapter 2](ch02.html "Chapter 2. Getting
    Started"), *Getting Started*, when we created a new "Hello, World!" application,
    and again in [Chapter 4](ch04.html "Chapter 4. Project CRUD"), *Project CRUD*
    when we used it to initially create the structure of our TrackStar web application.
    We have continued to use it when creating and running our database migrations.
  prefs: []
  type: TYPE_NORMAL
- en: The `yiic` tool is a console application in Yii that executes tasks in the form
    of commands. We have used the `webapp` command to create new applications, and
    the `migrate` command to create new migration files and execute our database migrations.
    Console applications in Yii are easily extended by writing custom commands, and
    this is exactly what we are going to do. We are going to extend the `yiic` command
    tool set by writing a new command-line tool to allow us to build our RBAC authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a new command for a console application is quite simple. A command is
    simply a class that extends from `CConsoleCommand`. It works similarly to a controller
    class in that it will parse the input command-line options and dispatch the request
    to the specified action within the command class, the default being `actionIndex()`.
    The name of the class should be exactly the same as the desired command name,
    followed by "Command". In our case, our command will simply be "Rbac", so we'll
    name our class `RbacCommand`. Lastly, in order to make this command available
    to the `yiic` console application, we need to save our class into the `/protected/commands/`
    directory, which is the default location for console commands.
  prefs: []
  type: TYPE_NORMAL
- en: So, create a new file `/protected/commands/RbacCommand.php`. The contents for
    this file are too long to be included, but can be easily obtained from the downloadable
    code for this chapter, or from [gist.github.com/jeffwinesett](http://gist.github.com/jeffwinesett).
    The individual snippet for this is available at [https://gist.github.com/3779677](https://gist.github.com/3779677).
  prefs: []
  type: TYPE_NORMAL
- en: The comments in the downloadable code should help tell the story of what is
    happening here. We override the base class implementation of `getHelp()`to add
    an additional description line. We'll show how to display the help in a minute.
    All of the real action happens in the two actions we added, `actionIndex()` and
    `actionDelete()`. The former creates our RBAC hierarchy, and the latter removes
    it. They both ensure the application has a vaild `authManager` application component
    defined. Then both actions allow the user to have a last chance to cancel the
    request before proceeding. If the user of this command indicates they want to
    continue, the request will proceed. Both of our actions will proceed to clear
    all previously entered data in the RBAC tables and the `actionIndex()` method
    will create a new authorization hierarchy. The hierarchy that is created here
    is exactly the one we discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that, even based on our fairly simple hierarchy, there is still a
    significant amount of code needed. Typically, one would need to develop a more
    intuitive **Graphical User Interface** (**GUI**) wrapped around these authorization
    manager APIs to provide an easy interface to manage roles, tasks, and operations.
    The approach we have taken here is a great solution for establishing a quick RBAC
    permission structure, but not ideal for the long-term maintenance of a permission
    structure that might change significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real-world application, you will most likely need a different, more interactive
    tool to help maintain the RBAC relationships. The Yii extension library ([http://www.yiiframework.com/extensions/](http://www.yiiframework.com/extensions/))
    does provide some packaged solutions for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this file in place, if we now ask the `yiic` tool for help, we''ll see
    our new command as one of the available options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a console application command](graphics/8727_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our `rbac` does show up in the list. However, before we can try to execute
    it, we need to configure the `authManager` for our console application. As you
    may recall, when running console applications, a different configuration file
    is loaded, namely `/protected/config/console.php`. We need to add the same `authManager`
    component to this file as we did previously to the `main.php` configuration file.
    Open up `console.php` and add the following to the components list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can now try out our new command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a console application command](graphics/8727_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is exactly the help text that we added to our `getHelp()` method in our
    command class. You can certainly be more verbose and add more detail as desired.
    Let''s actually run the command. Since `actionIndex()` is the default, we don''t
    have to specify the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a console application command](graphics/8727_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our command has completed and we have added the appropriate data to our new
    database tables to generate our authorization hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we also added an `actionDelete()` method to remove our hierarchy, you
    can try that one out as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Once you are done trying these out, make sure you run the command again to add
    the hierarchy, as we need it to be in place as we continue.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning users to roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everything we have done thus far establishes an authorization hierarchy, but
    it does not yet assign permissions to users. We accomplish this by assigning users
    to one of the three roles we created, *owner*, *member*, or *reader*. For example,
    if we wanted to associate the user whose unique user ID is `1` with the `member`
    role, we would execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these relationships are established, checking a user''s access permission
    is a simple matter. We simply ask the application user component whether or not
    the current user has the permission. For example, if we wanted to check whether
    or not the current user is allowed to create a new issue, we could do so with
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we assigned user ID `1` to the role of `member` and since in
    our authorization hierarchy the member role inherits the `createIssue` permission,
    this `if()` statement would evaluate to `true`, assuming we were logged in to
    the application as user `1`.
  prefs: []
  type: TYPE_NORMAL
- en: We will be adding this authorization assignment logic as part of the business
    logic executed when adding a new member to a project. We'll be adding a new form
    that allows us to add users to projects, and the ability to choose a role as part
    of the process. But first we need to address one other aspect of how user roles
    need to be implemented within this application, namely, they need to apply on
    a per-project basis.
  prefs: []
  type: TYPE_NORMAL
- en: Adding RBAC roles to users on a per-project basis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a basic RBAC authorization model in place, but these relationships
    apply to the application as a whole. Our needs for the TrackStar application are
    slightly more complex. We need to assign roles to users within the context of
    projects, not just globally across the application. We need to allow users to
    be in different roles, depending on the project. For example, a user may be in
    the `reader` role of one project, a `member` of a second project, and an `owner`
    of some third project. Users can be associated with many projects, and the role
    they are assigned needs to be specific to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RBAC framework in Yii does not have anything built-in that we can take
    advantage of to meet this requirement. The RBAC model is only intended to establish
    relationships between roles and permissions. It does not know (nor should it)
    anything about our TrackStar projects. In order to achieve this extra dimension
    to our authorization hierarchy, we need to alter our database structure to contain
    an association between a user, project, and role. If you recall from back in [Chapter
    5](ch05.html "Chapter 5. Managing Issues"), *Managing Issues* we have already
    created a table, `tbl_project_user_assignment`, to hold the association between
    a user and a project. We can alter this table to also contain the role assigned
    to the user within the project. We''ll add a new migration to alter our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open up the newly created migration file and implement the following `up()`
    and `down()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally run the migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding RBAC roles to users on a per-project basis](graphics/8727_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will see the message `Migrated up successfully` at the end of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now our table is set up to allow us to make the role association along with
    the association between a user and a project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding RBAC business rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While the database table shown earlier will hold the basic information to answer
    the question as to whether a user is assigned to a role within the context of
    a particular project, we still need our RBAC `auth` hierarchy to answer questions
    concerning whether or not a user has permission to perform a certain functionality.
    Although the RBAC model in Yii does not know about our TrackStar projects, it
    does have a very powerful feature of which we can take advantage. When you create
    authorization items or assign an item to a user, you can associate a snippet of
    PHP code that will be executed during the `Yii::app()->user->checkAccess()` call.
    When defined, this bit of code must return `true` before the user would be granted
    that permission.
  prefs: []
  type: TYPE_NORMAL
- en: One example of the usefulness of this feature is in the context of applications
    that allow users to maintain personal profile information. Often in this case,
    the application would like to ensure that a user has the permission to update
    only their own profile information and no one else's. In this case we could create
    an authorization item called "updateProfile", and then associate a business rule
    that checks if the current user's ID is the same as the user ID associated with
    the profile information.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are going to associate a business rule with the role assignment.
    When we assign a user to a specific role, we will also associate a business rule
    that will check the relationship within the context of the project. The `checkAccess()`
    method also allows us to pass in an array of additional parameters for the business
    rule to use to perform its logic. We'll use this to pass in the current project
    context so that the business rule can call a method on the `Project` AR class
    in order to determine whether or not the user is assigned to that role within
    that project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The business rule we''ll create will be slightly different for each role assignment.
    For example, the one we''ll use when assigning a user to the owner role will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The ones for the roles `member` and `reader` will be similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also have to pass in the project context when we call the `checkAccess()`
    method. So now when checking if a user has access to, for example, the `createIssue`
    operation, the code would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the `$project` variable is the `Project` AR class instance
    associated with the current project context (remember that almost all functionality
    in our application occurs within the context of a project). This class instance
    is what is used in the business rule. The business rule calls a method, `Project::isUserInRole()`,
    in order to determine if the user is in the role for the specific project.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the new project AR methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have altered our database structure to house the relationship between
    user, role, and project, we need to implement the required logic to manage and
    verify the data in this table. We will be adding public methods to the project
    AR class to handle adding and removing data from this table as well as verifying
    the existence of rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the public method to the `Project` AR class that will take in
    a role name and a user ID and create the association between role, user, and project.
    Open up the `protected/models/Project.php` file and add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the Yii framework query builder approach to directly insert
    into the database table, rather than using the active record approach. Since `tbl_project_user_assignement`
    is just an association table, and does not represent a main domain object of our
    model, it is sometimes easier to manage the data in these types of tables in a
    more direct manner than using the active record approach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on using Query Builder in Yii, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.yiiframework.com/doc/guide/1.1/en/database.query-builder](http://www.yiiframework.com/doc/guide/1.1/en/database.query-builder)'
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need to be able to remove a user from a project, and in doing so,
    remove the association between a user and the project. So, let's also add a method
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the `Project` AR class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This simply deletes the row from the table that houses the association between
    the role, the user, and the project.
  prefs: []
  type: TYPE_NORMAL
- en: We have now implemented the methods for adding and removing our associations.
    We need to add functionality to determine whether or not a given user is associated
    with a role within the project. We will also add this as a public method to our
    `Project` AR class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following method to the bottom of the `Project` AR model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This method is showing how to execute the SQL directly, rather than using the
    query builder. The query builder is very useful, but for simple queries, it is
    sometimes easier to just execute the SQL directly, utilizing Yii's Data Access
    Objects (DAO).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on Yii''s Data Access Objects and directly executing SQL
    in Yii, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.yiiframework.com/doc/guide/1.1/en/database.dao](http://www.yiiframework.com/doc/guide/1.1/en/database.dao)'
  prefs: []
  type: TYPE_NORMAL
- en: Adding users to projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we need to put all of this together. In [Chapter 6](ch06.html "Chapter 6. User
    Management and Authentication"), *User Management and Authorization* we added
    the ability to create new users of the application. However, we do not yet have
    a way to assign users to specific projects, and further, assign them to roles
    within these projects. Now that we have our RBAC approach in place, we need to
    build this new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of this functionality involves several coding changes. However,
    we have provided similar examples of the type of changes needed, and have covered
    all of the related concepts when implementing functionality in previous chapters.
    Consequently, we will move pretty quickly through this, and pause only briefly
    to highlight just a few things we have not yet seen. At this point, the reader
    should be able to make all of these changes without much help, and is encouraged
    to do so as a hands-on exercise. To further encourage this exercise, we'll first
    list everything we are going to do to fulfill this new feature requirement. You
    can then close the book and try some of these out yourself before looking further
    down at our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this goal we will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a public static method called `getUserRoleOptions()` to the `Project` model
    class that returns a valid list of role options using the `auth` manager's `getRoles()`
    method. We will use this to populate a roles selection drop-down field in the
    form, so that we can select the user role when adding a new user to a project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new public method called `isUserInProject($user)` to the `Project` model
    class to determine if a user is already associated with a project. We will use
    this in our validation rules upon form submission so that we don't attempt to
    add a duplicate user to a project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new form model class called `ProjectUserForm`, extending from `CFormModel`
    for a new input form model. Add to this form model class three attributes, namely
    `$username`, `$role`, and `$project`. Also add validation rules to ensure that
    both the username and the role are required input fields, and that the username
    should further be validated via a custom `verify()` class method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This verify method should attempt to create a new UserAR class instance by finding
    a user matching the input username. If the attempt was successful, it should continue
    to associate the user to a project using the `assignUser($userId, $role)`method
    that we already added earlier. We will also need to associate the user to the
    role in our RBAC hierarchy implemented earlier in this chapter. If no user was
    found matching the username, it needs to set and return an error. (If needed,
    review the `LoginForm::authenticate()`method as an example of a custom validation
    rule method.)
  prefs: []
  type: TYPE_NORMAL
- en: Add a new view file under views/project called `adduser.php` to display our
    new form for adding users to projects. This form only needs two input fields,
    *username* and *role*. The role should be a drop-down choice listing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new controller action method called `actionAdduser()` to the `ProjectController`
    class and alter its `accessRules()` method to ensure it is accessible by authenticated
    members. This new action method is responsible for rendering the new view to display
    the form and handle the post back when the form is submitted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, we encourage the reader to attempt these changes on their own first.
    We list our code changes in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the project model class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To the `Project` class, we add two new public methods, one of them static so
    it can be called without the need for a specific class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Adding the new form model class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as it was used in the approach for the login form, we are going to create
    a new form model class as a central place to house our form input parameters and
    to centralize the validation. This is a fairly simple class that extends from
    the Yii class `CFormModel` and has attributes that map to our form input fields,
    as well as one to hold the valid project context. We need the project context
    to be able to add users to projects. The entire class is too long to list here,
    but can be easily obtained from the downloadable code that accompanies this chapter.
    The standalone snippet is available at [https://gist.github.com/3779690](http://
    https://gist.github.com/3779690).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we have listed just the parts we have not seen
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For simplicity, in the `createUsernameList()` method, we are selecting *all*
    users from the database to use for the username list. If there are a large number
    of users, this may result in suboptimal performance. To optimize performance,
    you may need to filter and limit this in cases where there are a large number
    of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The part of the downloadable code that we listed above is the `assign()` method
    where we are adding a bizRule to the association between the user and role in
    RBAC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of the `Authmanager` class that we used to establish the
    assignment of the user to the role. However, before we make that assignment, we
    create the business rule. The business rule uses the `$params` array by first
    checking the existence of a `project` element in the array, and then calls the
    `isUserInRole()` method on the project AR class, which is the value of that array
    element. We explicitly pass in the role name to this method. We then call the
    `AuthManager::assign()` method to make the association between the user and the
    role.
  prefs: []
  type: TYPE_NORMAL
- en: We have also added a simple public method, `createUsernameList()`, to return
    an array of all the usernames in the database. We will use this array to populate
    the data of one of Yii's UI widgets, `CJuiAutoComplete`, which we will use for
    the username input form element. As its name suggests, as we type in the input
    form field, it will provide choice suggestions based on the elements in this array.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new action method to the project controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We need a controller action to handle the initial request to display the form
    for adding a new user to a project. We placed this in the `ProjectController`
    class and named it `actionAdduser()`. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is all pretty familiar to us at this point. It handles both the initial
    `GET` request to display the form as well as the `POST` request after the form
    is submitted. It follows very much the same approach as our `SiteController::actionLogin()`
    method. The highlighted code in the previous code snippet is, however, something
    we have not seen before. If the submitted form request is successful, it sets
    what is called a **flash message**. A flash message is a temporary message stored
    briefly in the session. It is only available in the current and the next requests.
    Here we are using the `setFlash()` method of our `CWebUser` application user component
    to store a temporary message that the request was successful. When we talk about
    the view in the next section, we will see how to access this message and display
    it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other change we have to make is to the base controller class method `Controller::accessRules()`.
    As you recall, we added our access rules to this base class so that they apply
    to each of our user, issue, and project controller classes. We need to add in
    this new action name to the basic access rules list so that a logged in user is
    allowed to access this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Adding the new view file to display the form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our new action method is calling `->render(''adduser'')` to render a view file,
    so we need to get that created. The following is the full listing of our implementation
    for `protected/views/project/adduser.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have seen most of this before. We are defining active labels and active form
    elements that tie directly to our `ProjectUserForm` form model class. We populate
    our dropdown using the static method we implemented earlier on the project model
    class. We populate our Zii library autocomplete widget (`CJuiAutoComplete`) data
    with the method `createUsernameList()` we added to the project user form model
    class. We also added a simple link to the menu options to take us back to the
    project details page.
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted code in the previous code snippet is new to us. This is an example
    of using the flash message that we introduced and used in the `actionAdduser()`
    method. We access the message we set using `setFlash()` by asking the same user
    component if it has a flash message, using `hasFlash('succcess')`. We feed the
    `hasFlash()` method the exact name we gave it when we set the message. This is
    a nice way to present the user with some simple feedback about their previous
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other small change we made was to add a simple link from the project details
    page so we could access this from the application. The following highlighted line
    was added to the project `view.php` view file''s menu array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This gives us access to the new form when viewing the details of a project.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With all of these changes in place, we can navigate to our new form by viewing
    one of the project details pages. For example, when viewing project ID #1 via
    `http://localhost/trackstar/index.php?r=project/view&id=1`, in the right-hand
    side column menu of operations is a hyperlink **[Add User To Project]** and clicking
    on that link should display the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](graphics/8727_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can use the forms we have built previously to create new projects and users
    to ensure you have a few of them added to the application. Then you can play around
    with adding users to projects. As you type in the **Username** field, you will
    see suggestions for autocompletion. If you attempt to add a user that is not in
    the user database table, you should see an error telling you so. If you attempt
    to enter a user that has already been added to the project, you will receive an
    error telling you so. And upon successful additions, you will see a short flash
    message indicating success.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the ability to assign users to projects and add them to our
    RBAC authorization hierarchy, we should alter our logic for when we are adding
    a new project. When a new project is added, it should assign the user who is adding
    the project as the `owner` of the project. This way, the creator of the project
    will have full administrative access to the project. I will leave this as homework
    for the reader. You can view a solution to this exercise by downloading the available
    source code for the TrackStar application that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: Checking authorization level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we need to do to complete what we set out to do in this chapter
    is to add the authorization checks for the different functionality we have implemented.
    Earlier in this chapter we outlined, and then implemented, the RBAC authorization
    hierarchy for the different roles we have. Everything is in place to allow or
    deny access to functionality based on the permissions that have been granted to
    users within projects, with one exception. We have not yet implemented the authorization
    checks necessary when attempting to request functionality. The application is
    still using the simple access filter that is defined on each of our project, issue,
    and user controllers. We'll do this for one of our permissions and then leave
    the remaining implementation as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see from looking back at our authorization hierarchy that only project owners
    should be able to add new users to a project. So, let''s add this authorization
    check. We''ll hide the link for adding a user on the project details page unless
    the current user is in the *owner* role for that project (before implementing,
    you should make sure you have added at least one owner and one member or reader
    to a project so you can test them when complete). Open up the `protected/views/project/view.php`
    view file where we placed the link in the menu items for adding a new user. Remove
    that array element from the menu array items, and then push it on the end of the
    array only if the `checkAccess()` method returns `true`. The following code shows
    how the menu items should be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This implements the same approach we discussed earlier in the chapter. We call
    `checkAccess()` on the current user and send in the name of the permission we
    want to check. Also, since our roles are within the context of projects, we send
    in the project model instance as an array input. This will allow the business
    rule to execute, which has been defined in the authorization assignment. Now if
    we log in as a project owner for a particular project and navigate to that project
    details page, we'll see the menu option for adding a new user to the project.
    Conversely, if we log in as a user in the `member` or `reader` role of that same
    project, and again navigate to the details page, this link will not display.
  prefs: []
  type: TYPE_NORMAL
- en: 'This, of course, will not prevent a savvy user from gaining access to this
    functionality by navigating using the URL directly. For example, even while logged
    in to the application as a user in the `reader` role for, say, project #1, if
    I navigate directly to `http://localhost/trackstar/index.php?r=project/adduser&id=1`
    I can still access the form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this, we need to add our access check directly to the action method
    itself. So, in the `ProjectController::actionAdduser()` method in the project
    controller class, we can add the check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now when we attempt to access this URL directly, we will be denied access unless
    we are in the project *owner* role for the project.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go through implementing the access checks for all of the other functionality.
    Each would be implemented in a similar manner. We leave this as an exercise for
    the reader. This implementation is not necessary in order to continue to follow
    along with the remaining code examples throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter. First we were introduced to the basic
    access control filter that Yii provides as one method to allow and deny access
    to specific controller action methods. We used this approach to ensure that users
    be logged in to that application before gaining access to any of the main functionality.
    We then took a detailed walk through Yii's RBAC model, which allows for a much
    more sophisticated approach to access control. We built an entire user authorization
    hierarchy based on application roles. In the process, we were introduced to writing
    console applications in Yii, and to some of the benefits of this wonderful feature.
    We then built in new functionality to allow the addition of users to projects
    and being able to assign them to appropriate roles within those projects. Finally,
    we discovered how to implement the needed access checks throughout the application
    to utilize the RBAC hierarchy to appropriately grant/deny access to feature functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to add even more functionality for users,
    one of which is the ability to leave comments on our project issues.
  prefs: []
  type: TYPE_NORMAL
