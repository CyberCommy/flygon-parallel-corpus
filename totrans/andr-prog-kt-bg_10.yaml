- en: Chapter 10. Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discover that, in Kotlin, classes are fundamental to
    just about everything and, in fact, just about everything is a class.
  prefs: []
  type: TYPE_NORMAL
- en: We have already talked about reusing other people's code, specifically the Android
    API, but in this chapter, we will really get to grips with how this works and
    learn about **object-oriented programming** (**OOP**) and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to OOP and the three key topics of encapsulation, polymorphism,
    and inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic classes, including how to write our first class including adding **properties**
    for data/variable encapsulation and functions to get things done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore **visibility modifiers** that further aid and refine encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about **constructors** that enable us to quickly prepare our classes to
    be turned into usable objects/instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code a Basic Classes mini app to put in to practice everything we have learned
    in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you try to memorize this chapter (or the next), you will have to make a lot
    of room in your brain, and you will probably forget something really important
    in its place.
  prefs: []
  type: TYPE_NORMAL
- en: A good goal will be to try and just about get it. This way, your understanding
    will become more rounded. You can then refer to this chapter (and the next) for
    a refresher when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It doesn't matter if you don't completely understand everything in this chapter
    or the next straight away! Keep on reading and be sure to complete all the apps.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Getting Started with Android and Kotlin"),
    *Getting Started with Android and Kotlin,* we mentioned that Kotlin was an object-oriented
    language. An object-oriented language requires us to use OOP; it isn't an optional
    extra, it's part of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out a little bit more.
  prefs: []
  type: TYPE_NORMAL
- en: What is OOP exactly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  prefs: []
  type: TYPE_NORMAL
- en: Each chunk is self-contained, and potentially reusable, by other programs, while
    working together as a whole with the other chunks.
  prefs: []
  type: TYPE_NORMAL
- en: These chunks are what we have been referring to as objects. When we plan/code
    an object, we do so with a class. A class can be thought of as the blueprint of
    an object.
  prefs: []
  type: TYPE_NORMAL
- en: We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint – you can't live in it, but you can build a house
    from it; so, you build an instance of it. Often, when we design classes for our
    apps, we write them to represent real-world things.
  prefs: []
  type: TYPE_NORMAL
- en: However, OOP is more than this. It is also a way of doing things – a methodology
    that defines best practices.
  prefs: []
  type: TYPE_NORMAL
- en: The three core principles of OOP are **encapsulation**, **polymorphism**, and
    **inheritance**. These might sound complex but, taken a step at a time, are reasonably
    straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Encapsulation** means keeping the internal workings of your code safe from
    interference from the code that uses it, by allowing only the variables and functions
    you choose to be accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that your code can always be updated, extended, or improved without
    affecting the programs that use it, provided that the exposed parts are still
    accessed in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall this line of code from[Chapter 1](ch01.html "Chapter 1. Getting
    Started with Android and Kotlin"), *Getting Started with Android and Kotlin*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With proper encapsulation, it doesn't matter if the satellite company or the
    Android API team need to update the way their code works. If the `getLastKnownLocation`
    function signature remains the same, we don't have to worry about what goes on
    inside. Our code, as written before the update, will still work after the update.
  prefs: []
  type: TYPE_NORMAL
- en: If the manufacturer of a car gets rid of the wheels and makes it an electrically-powered
    hover car, if it still has a steering wheel, accelerator, and brake pedal, driving
    it should not be a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the classes of the Android API, we are doing so in the way the Android
    developers designed their classes to allow us to.
  prefs: []
  type: TYPE_NORMAL
- en: We will dig deeper into encapsulation in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Polymorphism** allows us to write code that is less dependent on the types
    we are trying to manipulate, making our code clearer and more efficient. Polymorphism
    means **many forms**. If the objects that we code can be more than one type of
    thing, then we can take advantage of this. Some future examples will make this
    clear. An analogy will give you a more real-world perspective. If we have car
    factories that can make vans and small trucks just by changing the instructions
    given to the robots and the parts that go onto the production line, then the factory
    is polymorphic.'
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn't it be useful if we could write code that can handle different types
    of data without starting again? We will see some examples of this in [Chapter
    11](ch11.html "Chapter 11. Inheritance in Kotlin"), *Inheritance in Kotlin*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also find out more about polymorphism in [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting Our Kotlin to the UI and Nullability*.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like it sounds, **inheritance** means we can harness all the features
    and benefits of other peoples'' classes (including encapsulation and polymorphism)
    while further refining their code specifically to our situation. Actually, we
    have done this already, every time we used the `:` operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `AppCompatActivity` class itself inherits from `Activity`. So, we inherited
    from `Activity` every time we created a new Android project. We can go further
    than this, and we will see how it is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if the strongest man in the world gets together with the smartest woman
    in the world. There is a good chance that their children will have serious benefits
    from gene inheritance. Inheritance in Kotlin lets us do the same thing with another
    person's code and our own.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at inheritance in action in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Why do it like this?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When used carefully, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained (encapsulated) nature means less, or perhaps even
    zero, consequences for other parts of the program. This is the encapsulation part.
  prefs: []
  type: TYPE_NORMAL
- en: You can use other people's code (such as the Android API) without knowing or
    perhaps even caring how it works. Think about the Android lifecycle, `Toast`,
    `Log`, all the UI widgets, listening to satellites, and so on. We don't know,
    and we don't need to know, how they work internally. As a more detailed example,
    the `Button` class has nearly 50 functions – do we really want to write all that
    ourselves, just for a button? It would be much better to use someone else's `Button`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: OOP allows you to write apps for highly complex situations without breaking
    a sweat.
  prefs: []
  type: TYPE_NORMAL
- en: You can create multiple similar, yet different, versions of a class without
    starting the class from scratch by using inheritance, and you can still use the
    functions intended for the original type of object with your new object because
    of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: It makes sense really. And Kotlin was designed from the start with all of this
    in mind, so we are forced into using all this OOP – however, this is a good thing.
    Let's have a quick class recap.
  prefs: []
  type: TYPE_NORMAL
- en: Class recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class is a container for a bunch of code that can contain functions, variables,
    loops, and all the other Kotlin syntax we have learned already. A class is part
    of a Kotlin package, and most packages will normally have multiple classes. Most
    often, although not always, each new class will be defined in its own `.kt` code
    file with the same name as the class, as with all of our activity-based classes
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have written a class, we can use it to make as many objects from it
    as we want. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the plan, just as the object isn't the class –
    it is an object made from the class. An object is a reference variable, just like
    a string and, later, we will discover exactly what being a reference variable
    means. For now, let's look at some actual code.
  prefs: []
  type: TYPE_NORMAL
- en: Basic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two main steps involved with classes. First, we must declare our class,
    and then we can bring it to life by instantiating it into an actual useable object.
    Remember, the class is just a blueprint, and you must use the blueprint to build
    an object before you can do anything with it.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes can be of varying sizes and complexities depending upon what its purpose
    is. Here is the absolute simplest example of a class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we most often declare a new class in a file of its own with the
    same name as the class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will cover some exceptions to the rule throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at three examples of declaring a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we will do a full working project to practice at the end of this chapter.
    There are also completed classes for all the theoretical examples throughout this
    chapter in the `Chapter10/Chapter Example Classes` folder of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note in the previous code is that I have lumped together
    three class declarations. In real code, each declaration would be contained in
    its own file with the same name as the class and the `.kt` file name extension.
  prefs: []
  type: TYPE_NORMAL
- en: To declare a class, we use the `class` keyword followed by the name of the class.
    Therefore, we can work out that, in the previous code, we declared a class called
    `Soldier`, a class called `Message`, and a class called `ParticleSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that classes can, and often do, model real-world things. It
    would, therefore, be safe to assume that the three hypothetical classes will model
    a soldier (perhaps from a game), a message (perhaps from an email or text messaging
    app), and a particle system (perhaps from a scientific simulation app).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A particle system is a system that contains individual particles that act as
    a part of that system. In computing, they are used to model/simulate/visualize
    things such as chemical reactions/explosions and particle behavior, perhaps smoke.
    In [Chapter 21](ch21.html "Chapter 21. Threads and Starting the Live Drawing App"),
    *Threads and Starting the Live Drawing App* we will build a cool drawing app that
    uses particle systems to make the user's drawings appear to come alive.
  prefs: []
  type: TYPE_NORMAL
- en: It is plain, however, that a simple declaration like the three we have just
    seen does not contain enough code to achieve any useful functionality. We will
    expand on class declarations in a moment. First, let's see how to go about using
    the classes that we have declared.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a usable object from our classes, we would turn to another code file.
    So far throughout the book we have used the `onCreate` function in the `AppCompatActivity`
    class to demonstrate different concepts. While you can instantiate a class from
    virtually anywhere in Android, because of the lifecycle functions, it is quite
    common to use `onCreate` to instantiate objects/instances of our classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code. I have highlighted the new code to focus
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code we instantiated an instance (made a usable object) from
    each of our three previously declared classes. Let''s examine the syntax more
    closely. Here is the line of code that instantiated an instance of the `Soldier`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First, we decide whether we need to change our instance. As with regular variables,
    we then choose `val` or `var`. Next, we name our instance. In the preceding code,
    the object/instance is called `soldier`, but we could have called it `soldierX`,
    `marine`, `john117`, or even `squashedBanana`. The name is arbitrary, but, as
    with variables, it makes sense to call them something meaningful. Also, as with
    variables, it is convention, but not required, to use a lowercase letter at the
    start of the name and an uppercase letter for any subsequent words in the name.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The distinction between `val` and `var` when using them to declare instances
    of classes is much more nuanced and significant. We will initially learn the details
    about classes, and in [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin
    to the UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*
    we will revisit `val` and `var` to see what is going on under the hood of our
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: The final part of the code contains the assignment operator, `=`, followed by
    the class name, `Soldier`, and an opening and closing set of brackets `()`.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator tells the Kotlin compiler to assign the result of the
    right-hand side of the code to the variable on the left. Type inference establishes
    that `soldier` is of the `Soldier` type.
  prefs: []
  type: TYPE_NORMAL
- en: The curious, but perhaps familiar looking `()` after the class name implies
    that we are calling a function. We are – and it is a special function called a
    **constructor** that is provided by the Kotlin compiler. There is much to discuss
    about constructors, so we will defer the conversation to a little later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, all we need to know is that this next line of code creates a usable
    object of the `Soldier` type, called `soldier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that one of the goals of OOP is that we get to reuse our code. We
    are not limited to just one object of the `Soldier` type. We can have as many
    as we choose. Have a look at this next block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `soldier1`, `soldier2`, and `soldier3` instances are all separate, distinct
    instances. It is true they are all the same type – but that is their only connection.
    You and your neighbor might both be human, but you are not the same human. If
    we do something to, or change something about `soldier1`, that something is only
    done to/about `soldier1`. The `soldier2` and `soldier3` instances remain unaffected.
    It is, indeed, possible to instantiate a whole army of `Soldier` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The power of OOP is slowly revealing itself, but the elephant in the room at
    this stage of our discussion is that our classes don't actually *do* anything
    at all. Furthermore, our instances hold no values (data), so there is nothing
    we can change about them either.
  prefs: []
  type: TYPE_NORMAL
- en: Classes have functions and variables (kind of)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I will explain the slightly cryptic **(kind of)** heading shortly when we get
    to the *Class variables are properties* section later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Any of the code that we learned about throughout our discussion on Kotlin can
    be used as part of a class. This is how we make our classes meaningful and our
    instances genuinely useful. Let's expand on the class declaration and add some
    variables and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using the variables of a class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will add some variables to our empty `Soldier` class, like in this
    next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember, all the preceding code would go in a file named `Soldier.kt`. Now
    that we have a class declaration with some member variables, we can use them as
    shown in this next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code, if placed in the `onCreate` function, would produce the following
    output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we instantiated an instance of the `Soldier` class in
    the usual way. But now, because the `Soldier` class has some variables with values,
    we can access those values using **dot syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could access the values by using this specific example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To be clear, we use the instance name, not the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, there are some exceptions and variations that we will cover as we
    proceed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to change the value of a variable, we can use the exact same dot
    syntax. Of course, if you remember back to [Chapter 7](ch07.html "Chapter 7. Kotlin
    Variables, Operators, and Expressions"), *Kotlin Variables, Operators, and Expressions*,
    variables that can be changed need to be declared as `var`, not `val`. Here is
    the `Soldier` class reworked so that we can use it slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can manipulate the value of the variables as if they are regular `var`
    variables by using the dot syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would produce the following output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, first we see the same three lines as before, and then
    we see three more lines indicating that Ryan is no longer missing, and has been
    promoted to `Private First Class`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the functions and variables of a class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we can give our classes data, it is time to make them even more useful
    by giving them things that they can do. To achieve this, we can give our classes
    functions. Have a look at this expanded code for the `Soldier` class. I have reverted
    the variables to `val` and highlighted the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The code in the `getStatus` function declares a new `String` variable called
    `status`, and initializes it using the values contained in `rank` and `name`.
    It then checks the value in `missing` with an `if` expression, and appends either
    `is missing` or `ready for duty` depending upon whether missing is `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use this new function as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we create an instance of the `Soldier` class and then use dot syntax
    on that instance to call the `getStatus` function. The preceding code would produce
    the following output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we changed the value of `missing` to `false`, the following output would
    be produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that functions in classes can take any form that we discussed in [Chapter
    9](ch09.html "Chapter 9. Kotlin Functions"), *Kotlin Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: If you are thinking that all this class stuff is great, but at the same time
    seems a little bit rigid and inflexible, you would be correct. What is the point
    of having multiple, hundreds, or thousands of `Soldier` instances if they are
    all called Ryan and they are all missing? Certainly, we have seen we can use `var`
    variables and then change them, but this could still be awkward and long-winded.
  prefs: []
  type: TYPE_NORMAL
- en: We need ways to better manipulate and initialize data in each instance. And,
    if we think back to the start of the chapter when we briefly discussed the topic
    of encapsulation, then we will also realize that we need to not only allow code
    to manipulate our data, but also control when and how this manipulation takes
    place.
  prefs: []
  type: TYPE_NORMAL
- en: To gain this knowledge, we need to learn more about variables in classes, then
    a little more detail about encapsulation and visibility, and finally reveal what
    is going on with those function-like brackets `()` that we have seen at the end
    of the code when we instantiate an instance of our class.
  prefs: []
  type: TYPE_NORMAL
- en: Class variables are properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It turns out that in Kotlin class variables are more than just plain old variables
    that we have already learned about. They are **properties**. Everything we have
    learned about how to use variables so far still holds true, but a property has
    more to it than just a value. It has **getters**, **setters**,and a special class
    variable called a **field** hidden behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters can be thought of as special functions that are automatically
    generated by the compiler. In fact, we have already used them without knowing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the dot syntax on a property/variable declared in a class, Kotlin
    uses the getter to "get" the value. And when we use dot syntax to set the value,
    Kotlin uses the setter.
  prefs: []
  type: TYPE_NORMAL
- en: The field/variable itself isn't accessed directly when we use the dot syntax
    we have just seen. The reason for this abstraction is to aid encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: If you have previously done some programming in another object-oriented language
    (perhaps Java or C++) this could be confusing, but if you have used a more modern
    OOP language (perhaps C#), then this won't be entirely new to you. If Kotlin is
    your first language, then you are probably at an advantage compared to someone
    with previous experience, as you don't carry the baggage of previous learning.
  prefs: []
  type: TYPE_NORMAL
- en: And, as you might guess, if the variable is `var` then a getter and a setter
    is provided, but if it is `val`, then just a getter is provided. Therefore, when
    the variables (which we will call properties most of the time from now on) in
    the `Soldier` class were `var` we could get and set them, but when they were `val`
    we could only get them.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin gives us the flexibility to **override** these getters and setters in
    order to change what happens when we get and set the value of properties and their
    associated fields.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a property uses a field, it is called a **backing field**. As we will see,
    some properties don't require a backing field, as they can rely on the logic of
    the code in the getters and setters to make them useful.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, some examples using fields will make things clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Examples using properties with their getters, setters, and fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the getters and setters to control the range of values that can
    be assigned to its backing field. For example, consider this next code being added
    to the `Soldier` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds a new `var` property called `bullets`, and initializes
    it to 100\. Then we see some new code. The getter and the setter are overridden.
    Strip out the code from the getter and setter to see this in action in its simplest
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To be clear, the code in the getter and setter execute when we are accessing
    the value of bullet through an instance of the `Soldier` class. Take a look at
    how this might happen in this next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first create an instance of the `Soldier` class, and
    then we get the value stored in the `bullet` property and print the value. This
    triggers the getter code to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we decrement (reduce by one) the value stored by the `bullet` property.
    Any action that attempts to change the value held by the property will trigger
    the code in the setter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding four lines of code, we will get the following output
    in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After we create a `Soldier` instance called `soldier`, we use `Log.i` to print
    the value to the logcat window. As this code accesses the value stored by the
    property, the getter code runs and prints out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter then returns the value to the `Log.i` function using this next line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`return field`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created the property, Kotlin created a backing field. The way that
    we access the backing field in the getter or setter is to use the name `field`.
    Therefore, the preceding line of code works the same way it would in a function
    and returns the value allowing the `Log.i` call in the calling code to print the
    value, and we will get this next line of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line of code is perhaps the most interesting. Here it is again for
    easy reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We might guess that this simply triggers the setter to execute, but if we examine
    the next two lines of output in the logcat, we can see that the following two
    lines of output have been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The action of decrementing (or incrementing) requires the use of the getter
    (to know what to decrement) and then the setter to change the value.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the setter has a parameter named `value` that we can refer to in
    the setter's body just like a regular function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the instance is used to output the value held by the `bullets` property,
    and we can see that again the getter is used, and the output is generated from
    both the getter code in the class followed by the code using the instance (outside
    the class). The final two lines of output are shown again next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we can look at another example of using getters and setters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As already mentioned, sometimes properties do not need a backing field at all.
    It is sometimes enough to allow the logic in the getters and setters to handle
    the value accessed via the property. Examine this following code that we could
    add to the `Soldier` class that demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create three properties: a `var` property called
    `packWeight`, which we will change using the instance we will soon create, a `val`
    property called `gunWeight`, which we will never need to change, and another `var`
    property called `totalWeight`, which is initialized to `packWeight + gunWeight`.
    The interesting part is that we override the getter for `totalWeight` so that
    it recalculates its value using `packWeight + gunWeight`. Next, look at how we
    might use these new properties with an instance of the `Soldier` class, and then
    we will look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we create a `Soldier` instance called `strongSoldier`.
    Next, we print the value of `totalWeight` to the logcat. The third line of code
    changes the value of `packWeight` to `300`, and then the final line of code prints
    out the value of `totalWeight`, which will use our overridden getter. Here is
    the output from those four lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the output that the `totalWeight` value is entirely dependent
    on the values stored in `packWeight` and `gunWeight`. The first line of output
    is the starting value of `packWeight` (`150`) added to the value of `gunWeight`
    (`30`), and the second line of output is equal to the new value of `packWeight`
    added to `gunWeight`.
  prefs: []
  type: TYPE_NORMAL
- en: Just like functions, this enormously flexible system of properties will raise
    some questions.
  prefs: []
  type: TYPE_NORMAL
- en: When to use overridden getters and setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When to utilize these different techniques comes with practice and experience;
    there are no hard rules about exactly when it is appropriate for a specific technique.
    At this stage, it is just necessary to understand that variables declared in the
    body of a class (outside of a function) are actually properties, and properties
    are accessed via getters and setters. These getters and setters are not transparent
    to the user of the instance, and they are provided by default by the compiler
    unless overridden by the programmer of the class. This is the essence of encapsulation;
    the programmer of the class controls how that class works. Properties provide
    indirect access to its related value (called a backing field), although sometimes
    this backing field is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is OK (and I sometimes do so) to simplify a discussion by referring to a
    property as a variable. This is especially so when the getters, setters, and field
    are not relevant to the discussion at hand.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we will see more ways that we can use getters and setters,
    so let's move on to discuss visibility modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visibility modifiers are used to control the access/visibility of variables,
    functions, and even whole classes. As we will see, it is possible to have variables,
    functions, and classes with different levels of access depending upon where in
    the code the access is being attempted from. This allows the designers of a class
    to practice good encapsulation and make just the functionality and data they choose
    available to users of the class. As a slightly contrived but useful example, the
    designers of a class used to talk to a satellite and get GPS data wouldn't allow
    access to the `dropOutOfTheSky` function.
  prefs: []
  type: TYPE_NORMAL
- en: These are the four access modifiers in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Public
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Declaring classes, functions, and properties as `public` means that they are
    not hidden/encapsulated at all. In fact, the default visibility is `public` and
    everything we have seen and used so far is, therefore, public. We could make this
    explicit by using the `public` keyword before all our class, function, and property
    declarations, but it is not necessary. When something is declared `public` (or
    left at the default) no encapsulation is used. This is only occasionally what
    we want. Often the functions of a class that expose the core functionality of
    the class will be declared public.
  prefs: []
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next access modifier we will discuss is `private`. Properties, functions,
    and classes can be declared `private` by prefixing the `private` keyword before
    the declaration, as shown in this next hypothetical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SatelliteController` class is declared as `private`, which means that
    it is only available (can be instantiated) from within the same file. An attempt
    to instantiate an instance, perhaps from `onCreate`, would cause the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Private](img/B12806_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This raises the question of whether the class can be used at all. Declaring
    a class as `private` is much less common than using one of the remaining modifiers
    that we will go on to discuss, but it does happen, and there are various techniques
    that make it a viable tactic. It is more likely, however, that a `SatelliteController`
    class would be declared with the much more accessible `public` visibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we have a `private` property called `gpsCoordinates`. Assuming we
    change the `SatelliteController` class to public, we can then instantiate it and
    continue our discussion. Even when `SatelliteController` is declared (or left
    at the default) to be `public`, the private `gpsCoordinates` property is still
    not visible to instances of the class, as shown in this next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Private](img/B12806_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the `gpsCoordinates` property is
    inaccessible because it is `private`, and, as we saw from our discussion of properties
    earlier in this chapter, when the property is left at its default it is accessible.
    The point of these access modifiers is that the designer of the class can choose
    when and what to expose. It is likely that a GPS satellite would want to share
    GPS coordinates. However, it is also very likely that it wouldn't want users of
    the class to play any part whatsoever in calculating the coordinates. This suggests
    that we would want users of the class to be able to read the data but not write/change
    it. This is an interesting situation, because a first reaction might be to make
    the property a `val` property. This way the user could get the data but couldn't
    change it. The problem with this is that GPS coordinates obviously do change,
    and it needs to be a `var` property, just not a `var` property that is changeable
    from outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we declare a property as `private`, Kotlin automatically makes the getter
    and the setter `private` too. We can change this behavior by overriding the getter
    and/or the setter. To solve our problem of needing a `var` property that is not
    changeable from outside the class, readable outside the class, and changeable
    from within the class, we would leave the default setter so it can never change
    externally, and override the getter so it can be read externally. Look at this
    re-writing of the `SatelliteController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `SatelliteController` class and the `gpsCoordinates`
    property are `public`. Furthermore, `gpsCoordinates` is a `var` property, and
    therefore is mutable. However, look closely at the line of code after the property
    declaration, because it sets the setter to `private`, which means that code outside
    of the class can't access it to change it; but because it is a `var` property,
    code within the class can do whatever it likes to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could now write the following code in the `onCreate` function to use the
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now that the setter is made private by the code, we cannot change the value
    from an instance, but we can happily read it, as demonstrated in the preceding
    code. Note that setters cannot have their visibility changed, but can (as we saw
    when first discussing properties) have their functionality overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to discuss the function of the `dropOutOfSky` function, this is `private`
    and totally inaccessible. Only code within the `SateliteController` class can
    call that function. If we want users of the class to have access to a function,
    as we have already seen, we would simply leave it at the default visibility. The
    `SatelliteController` class might have functions that look something like this
    next code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, a public `updateCoordinates` function was added. This
    allows the instance of the class to use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would then trigger the execution of the `updateCoordinates`
    function, which will cause the class to internally update the property, which
    can then be accessed and provide the new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This begs the question: what data should be private? The level of visibility
    that should be used can be learned partly with common sense, partly through experience,
    and partly by asking the question, "who really needs to access this data and to
    what extent?" We will be practicing these three things throughout the rest of
    the book. Here is some more hypothetical code that shows some private data and
    more private functions for the `SatelliteController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there is a new private `Boolean` property called `bigProblem`.
    It can only be accessed internally. It cannot even be read externally. There are
    three new functions, one public property called `runMaintenance`, which runs the
    two private functions, `doDiagnostics` and `calibrateSensors`. These two functions
    could access and change the value of `bigProblem` if needed. In the `runMaintenance`
    function, a check is done to see if `bigProblem` is true, and, if so, the `dropOutOfTheSky`
    function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Obviously, in the code for a real satellite, solutions other than dropping out
    of the sky would likely be sought first.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the final two visibility modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Protected
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `protected` visibility modifier is used, its effects are more nuanced
    than `public` and `private`. When a function or property is declared as `protected`,
    it is almost private – but not quite. The other key OOP topic of inheritance that
    we will explore in the next chapter allows us to write classes, and then write
    another class that inherits the functionality of that class. The `protected` modifier
    would allow functions and properties to be visible to such classes but hidden
    from all other code.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore this further throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Internal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The internal modifier is nearer to public than the others. It would expose the
    property/function to any code within the same package. If you consider that some
    apps only have one package, then this is quite a loose visibility. We won't use
    it much, I just wanted to let you know about it for the sake of completeness.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility modifiers summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have covered, despite being several pages long, is only scratching the
    surface of visibility modifiers. The point is that they exist, and their purpose
    is to aid encapsulation and make your code less prone to bugs and more reusable.
    Combined with properties, functions, getters, and setters, Kotlin is immensely
    flexible, and we could go on all day with more examples of when and where to use
    each visibility modifier and when, where, and how to override getters and setters
    in different ways. It is much more useful to use the techniques to build working
    programs. This is what we will do throughout the book, and I will often refer
    to why we use a specific visibility modifier or why we used a getter/setter in
    a specific way. I also encourage you to do the basic classes demo app at the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter we have been instantiating objects (instances of classes)
    and we have gone into some depth about the various syntax. There is one small
    part of the code we have been ignoring until now. This next code we have seen
    several times before, but I have highlighted a small part of it so we can discuss
    it further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The brackets on the end of the code that initialize the object looks just like
    code from the previous chapter when we called a function (without any parameters).
    That is, in fact, exactly what is happening. When we declare a class, Kotlin provides
    (behind the scenes) a special function called a **constructor** that prepares
    the instance.
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we have declared and initialized all our instances in
    a single line each. Often, we will need to use some more logic in initialization,
    and often we will need to allow the code that initializes an instance of a class
    to pass in some values (just like a function). This is the reason for constructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, this default constructor is all we need, and we can forget all about
    it, but sometimes we need to do more work to set up our instance so that it is
    ready for use. Kotlin allows us to declare our own constructors and gives us three
    main options: primary constructors, secondary constructors, and `init` blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A primary constructor is one that is declared with the class declaration. Look
    at this next code, which defines a constructor that allows the user of the class
    to pass in two values. As we have come to expect, this code would go in a file
    named `Book.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have declared a class called `Book` and provided a
    constructor that takes two parameters. It requires an immutable `String` value
    and a mutable `Int` value passed to it when it is initialized. Providing a constructor
    like this and then using it to instantiate an instance declares and initializes
    the `title` and `copiesSold` properties. There is no need to declare or initialize
    them in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this next code, which shows how you could instantiate an instance of
    this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, an object called `book` is instantiated using the primary
    constructor and the properties, `title` and `copiesSold`, are initialized to `Animal
    Farm` and `20000000` (twenty million) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with functions, you can shape constructors to have any combinations,
    types, and number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The potential downfall of primary constructors is that the properties take their
    values from the passed in arguments without any flexibility. What if we needed
    to do some calculations with the passed in values before assigning them to the
    properties? Fortunately, there are ways we can handle this.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A secondary constructor is one that is declared separately from the class declaration,
    but is still within the class body. A couple of things to note about secondary
    constructors is that you can''t declare properties in the parameters, and you
    must also call the primary constructor from the code of the secondary constructor.
    The advantage to a secondary constructor is that you can write some logic (code)
    to initialize your properties. Look at the following code, which shows this in
    action. We will also introduce a new keyword at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we declare a class called `Meeting`. The primary constructor
    declares two properties, one called `day` and one called `person`. Next, a property
    called `time` is declared and initialized to the value of `To be decided`.
  prefs: []
  type: TYPE_NORMAL
- en: What follows is the secondary constructor. Notice that the parameters are preceded
    by the `constructor` keyword. You will also notice that the secondary constructor
    contains three parameters, the same two as the primary constructor and one more
    called `time`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `time` parameter is not the same entity as the `time` property
    that was previously declared and initialized. The secondary constructor contains
    only "throw-away" parameters, they do not become persistent properties like those
    of the primary constructor. This allows us to firstly call the primary constructor
    passing in `day` and `person`, and secondly (in the body of the secondary constructor)
    assign the value passed in via the `time` parameter to the `time` property.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can have multiple secondary constructors provided that the signatures are
    all different. The appropriate secondary constructor will be called by matching
    the parameters of the calling/instantiating code.
  prefs: []
  type: TYPE_NORMAL
- en: We need to talk about this
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Literally, I mean, we need to talk about the `this` keyword. When we use `this`
    inside a class it has the effect of referring to the current instance – so it
    acts on itself.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore the `this(day, person)` code calls the primary constructor that initializes
    the `day` and `person` properties. Furthermore, the `this.time = time` code has
    the effect of assigning the value passed in via the `time` parameter to the actual
    `time` property (`this.time`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just to mention in case it isn't obvious; the `Meeting` class would need additional
    functions to make it worthwhile, such as `setTime`, `getMeetingDetails`, and probably
    others to.
  prefs: []
  type: TYPE_NORMAL
- en: Users of our class can create instances of the `Meeting` class when they don't
    know the time (via the primary constructor) or when they do know the time (via
    the secondary constructor).
  prefs: []
  type: TYPE_NORMAL
- en: Using the Meeting class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We would instantiate our instances by calling either of our constructors, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we initialize two instances of the `Meeting` class, one
    called `meeting` and the other called `anotherMeeting`. With the first instantiation
    we called the primary constructor because we didn't know the time and with the
    second, we called the secondary constructor because we did know the time.
  prefs: []
  type: TYPE_NORMAL
- en: We can have more than one secondary constructor if required, provided that they
    all call the primary constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Init blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kotlin was designed to be a succinct language, and often there is a more succinct
    way to initialize our properties. If the class is not depending upon multiple
    different signatures, then we can stick to the more succinct primary constructor
    and provide any required initialization logic in an `init` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: That is probably enough theory; let's use everything we have been talking about
    in a working app. Next, we will write a small app that uses classes, including
    a primary constructor and an `init` block.
  prefs: []
  type: TYPE_NORMAL
- en: Basic classes app and using the init block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the completed code for this app in the code download. It is in the
    `Chapter10/Basic Classes` folder. But it is most useful to read on to create your
    own working example.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a few different classes using what we have learned throughout
    this chapter to put the theory in to practice. We will also see our first example
    of how classes can interact with each other by passing a class as a parameter
    into the function of another class. We know how to do this in theory already,
    we just haven't seen it in practice yet.
  prefs: []
  type: TYPE_NORMAL
- en: We will also see another way to initialize our data when the class is first
    instantiated by using an `init` block.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a small app that plays with the idea of simulating ships, docks,
    and sea battles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The output for the apps in this chapter and the next will be just text to the
    logcat window. In [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to
    the UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*, we
    will bring together everything we learned in the first five chapters (about the
    Android UI) and everything in the six that followed (about Kotlin) to bring our
    apps to life.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project with the Empty Activity template. Call the application `Basic
    Classes`. Now we will create a new class called `Destroyer`:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `com.gamecodeschool.basicclasses` (or whatever your package
    name is) folder in the project explorer window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **New** **|** **Kotlin File/Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Name:** field, type `Destroyer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the drop-down box, select **Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **OK** button to add the new class to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the previous five steps and create two more classes, one called `Carrier`
    and another called `ShipYard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new classes are created for us with a class declaration and curly brackets
    ready for our code. The auto-generated code also includes the package declaration,
    which will be different based on your choices when you created the project. This
    is what my code looks like at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `Destroyer.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `Carrier.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `ShipYard.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by coding the first part of the `Destroyer` class. What follows
    is the constructor, some properties, and an `init` block. Add the code to the
    project, study it, and then we will review what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that the constructor receives a `String` value
    called `name`. It is not declared with a `val` or a `var` property. Therefore,
    it is not a property, it is just a regular parameter that will cease to exist
    after the initialization of the instance. We will see shortly how we can make
    use of this.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code we declared some properties. Notice that most are all
    mutable `var` except `type`, which is a `String` `val` type that is initialized
    to `Destroyer`. Also notice that most are `private` access except for two.
  prefs: []
  type: TYPE_NORMAL
- en: The `type` property is public, and therefore fully accessible via an instance
    of the class. The `name` property is also public but has a `private` setter. This
    will give access to the instance for getting the value but protect the backing
    field (value) from being altered by the instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `hullIntegrity`, `ammo`, `shotPower`, and `sunk` properties are all `private`
    and inaccessible through the instance, at least, inaccessible directly. Be sure
    to make a mental note of the values assigned to and the types of these properties.
  prefs: []
  type: TYPE_NORMAL
- en: The final section of the preceding code is an `init` block, in which the `name`
    property is initialized by concatenating the type and name properties with a space
    in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `takeDamage` function that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the `takeDamage` function, the `if` expression checks that the `sunk` Boolean
    is not true. If the ship isn't already sunk, then `hullIntegrity` is reduced by
    subtracting the value of `damageTaken`, which was passed in as a parameter. Therefore,
    indirectly, the instance will be affecting `hullIntegrity` even though it is `private`.
    The point is that it can only do so in a manner decided by the programmer of the
    class; in this case – us. As we will see, all the private properties will eventually
    be manipulated in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if the ship is not yet sunk, two `Log.i` calls output the damage taken
    and the remaining hull integrity information to the logcat window. Finally, in
    the not sunk scenario `(!sunk)`, a nested `if` expression checks whether `hullIntegrity`
    is less than zero. If it is, then a message is printed indicating the ship has
    been sunk, and the `sunk` Boolean is set to true.
  prefs: []
  type: TYPE_NORMAL
- en: When the `damageTaken` function is called and the `sunk` variable is true, the
    `else` block will execute, and a message will be printed that the ship doesn't
    exist because it has already been sunk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the `shootShell` function, which will work in conjunction with the
    `takeDamage` function. Or rather, to be more precise, the `takeDamage` function
    of one ship instance will work in conjunction with the `shootShell` function of
    other ship instances, as we will see soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the `shootShell` function, if the ship has any ammo, the `ammo` property
    is decreased by one, and the value of `shotPower` is returned to the calling code.
    If the ship has no ammo left (`ammo` is not greater than zero), then the value
    of `0` is returned to the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for the `Destroyer` class add the `serviceShip` function, which sets
    `ammo` to `10` and `hullIntegrity` to `100` so that the ship is fully prepared
    to take damage again (via `takeDamage`) and deal damage (via `shootShell`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can quickly code the `Carrier` class because it is so similar. Just
    make a note of the slight differences in the values assigned to `type` and `hullIntegrity`.
    Also notice that, instead of `ammo` and `shotPower`, we use `attacksRemaining`
    and `attackPower`. Furthermore, `shootShell` has been replaced with `launchAerialAttack`,
    which seemed more appropriate for an aircraft carrier. Add the following code
    to the `Carrier` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The final code before we start using our new classes is the `ShipYard` class.
    It has two simple functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `serviceDestroyer`, takes a `Destroyer` instance as a parameter,
    and inside that function simply calls the instance's `serviceShip` function. The
    second function, `serviceCarrier`, has the same effect, but takes a `Carrier`
    instance as a parameter. While these two functions are short and simple, their
    later usage will soon reveal some quite interesting nuances to do with classes
    and their instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will create some instances and put our classes to work by simulating
    a fictional naval battle. Add this code to the `onCreate` function in the `MainActivity`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review that code. The code begins by instantiating two friendly ships
    (`friendlyDestroyer` and `friendlyCarrier`) and two enemy ships (`enemyDestroyer`
    and `enemyCarrier`). In addition, a `Shipyard` instance called `friendlyShipyard`
    is also instantiated in preparation for the inevitable carnage that will follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the `friendlyDestroyer` object takes damage twice. Once from `enemyDestroyer`
    and once from `enemyCarrier`. This is achieved by the `takeDamage` function of
    `friendlyDestroyer` passing in the return value of the `shootShell` and `launchAerialAttack`
    functions, respectively, of the two enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the friendlies fight back by dealing two attacks on the `enemyCarrier`
    object, one from the `friendlyCarrier` object via `launchAerialAttack`, and one
    from the `friendlyDestroyer` object via `shootShell`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The states of the two friendly ships are then output to the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the appropriate function of the `Shipyard` instance is called on each of
    appropriate instances in turn. There is no `enemyShipyard` object, so they will
    not be able to repair and rearm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the stats are printed again so that we can see the difference after a
    visit to the shipyard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, perhaps inevitably, the friendly forces finish off the enemies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app, and then we can examine the following output in the logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here is the output again, this time broken up in to parts so that we can clearly
    see which code produced which lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The friendly destroyer is attacked, leaving its hull near to breaking point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The enemy carrier is attacked and sunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The enemy carrier is attacked once more, but because it is sunk, the `else`
    block in the `takeDamage` function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The current ammo/available attacks stats are printed, and things are looking
    bad for the friendly forces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick visit to the shipyard, and things will look much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Fully armed and repaired, the friendly forces finish off the remaining destroyer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to review the code and the output again if any of it doesn't seem to
    match up.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There might be a nagging thought in your mind at this point. Look at the two
    functions from the `Shipyard` class again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When we called those functions and passed the `friendlyDestroyer` and `friendlyCarrier`
    to their appropriate `service…` function, we saw, from the before and after output,
    that the values inside the instances were changed. Usually, if we want to keep
    the result from a function, we need to use the return value. What is happening
    is that, unlike a function that has regular types as parameters, when we pass
    an instance of a class, we are really passing a **reference** to the instance
    itself – not just copies of the values within it, but the actual instance.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, all the different ship-related instances were declared with `val`,
    so how did we change any of the properties at all? The short answer to this conundrum
    is that we didn't change the reference itself, just the properties within it,
    but a fuller discussion is clearly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We will start our exploration of references and then dig deep into other related
    topics, such as the memory inside an Android device in [Chapter 12](ch12.html
    "Chapter 12. Connecting Our Kotlin to the UI and Nullability"), *Connecting Our
    Kotlin to the UI and Nullability*. For now, it is enough to know that, when we
    pass data to a function, if it is a class type, we are passing a reference that
    is equivalent (although not actually) to the real actual instance itself.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have, at last, written our first class. We have seen that we can implement
    a class in a file of the same name as the class. The class itself doesn't do anything
    until we instantiate an object/instance of the class. Once we have an instance
    of the class, we can use its special variables, called properties, and its non-private
    functions. As we proved in the Basic Classes app, every instance of a class has
    its own distinct properties, just as when you buy a car made in a factory, you
    get your very own steering wheel, satnav, and go-faster stripes. We have also
    bumped into the concept of references, which means that, when we pass an instance
    of a class to a function, the receiving function has access to the actual instance.
  prefs: []
  type: TYPE_NORMAL
- en: All this information will raise more questions. OOP is like that. So, let's
    try and consolidate all this class stuff by taking a much closer look at inheritance
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
