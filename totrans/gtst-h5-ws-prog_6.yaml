- en: Chapter 6. Error Handling and Fallbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you must be familiar with the WebSocket capabilities and must have got
    an idea of the power of full-duplex communication. However, the WebSocket goodies
    are built on top of HTML5 and depend strongly on the browsers for full support.
    What happens when the features you want to implement are not supported by the
    means your audience is using? Would you let your customers leave? That doesn't
    sound like a good idea. Fortunately, with a little bit of extra effort, you can
    implement, mimic, and mostly emulate, the WebSocket behavior.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket is the future-friendly way to go, but you'll need some fallback techniques
    in order to support the widest audience possible.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to error handling, you have to take both internal and external
    parameters into account. Internal parameters include errors that can be generated
    because of the bugs in your code, or an unexpected user behavior. External errors
    have nothing to do with the application; rather, they are related to parameters
    you have no control on. The most important one is the network connectivity. Any
    interactive bidirectional web application requires, well, an active Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: Checking network availability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that your users are enjoying your web app, when suddenly the network
    connection becomes unresponsive in the middle of their task. In modern native
    desktop and mobile applications, it is a common task to check for network availability.
    The most common way of doing so is simply making an HTTP request to a website
    that is supposed to be up (for example, [http://www.google.com](http://www.google.com)).
    If the request succeeds, the desktop or mobile device knows there is active connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, HTML has `XMLHttpRequest` for determining network availability.
    HTML5, though, made it even easier and introduced a way to check whether the browser
    can accept web responses. This is achieved via the navigator object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Offline mode means that either the device is not connected or the user has selected
    the offline mode from his/her browser toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to inform the user that the network is not available and try to
    reconnect when a WebSocket close event occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is pretty simple. It checks the error code to determine whether
    the WebSocket connection was closed successfully. Error code 1000 would determine
    exactly this. If the close event was raised due to an error, the code would not
    be 1000\. In this case, the code checks for connectivity and informs the user
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that this is an HTML5 feature. Later, we will discuss polyfills,
    so the following are two polyfills for checking network connectivity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/remy/polyfills/blob/master/offline-events.js](https://github.com/remy/polyfills/blob/master/offline-events.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://nouincolor.com/heyoffline.js/](http://nouincolor.com/heyoffline.js/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first one is using `XMLHttpRequest`, similar to what Smartphone APIs do.
  prefs: []
  type: TYPE_NORMAL
- en: Fallback solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real life, physical contact is preferred, as it is more direct and efficient,
    but it shouldn't be the only way of meeting someone. There are numerous cases
    where you won't be able to handshake, so you'll need to find other methods of
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: The sad reality of HTML5 is that every browser does not equally support it.
    Especially considering the new JavaScript APIs, major or minor differences still
    exist among different browsers. However, even if the browser vendors decided to
    provide the exact same features for their current releases, there would still
    be people who cannot or do not want to update. According to StatCounter and W3Counter,
    as of March 2013, the lion's share of desktop browsing belongs to Google Chrome,
    followed by Microsoft Internet Explorer and Mozilla Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Explorer 8 still shares 7 percent, Internet Explorer 7 shares 5 percent,
    and Safari 5.1 shares 3 percent. A total of 15 percent is translated to a number
    of customers you probably do not want to miss.
  prefs: []
  type: TYPE_NORMAL
- en: Here come the fallback solutions, which can handle such situations and provide
    a gracefully scaled-down experience to the users of older browsers. There are
    two kinds of popular fallbacks nowadays, **Plugins** (such as Flash or Silverlight)
    and **JavaScript hacks**, formally known as **polyfills**.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript polyfills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by examining polyfills, as they are more close to the native web. JavaScript
    polyfills are solutions and libraries that mimic a future feature, by providing
    support for older browsers. Currently, there are polyfill solutions for almost
    all HTML5-specific feature (**canvas**, **storage**, **geolocation**, **WebSockets**,
    **CSS3**, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: A polyfill solution should be used in parallel to the standards-based, HTML5-compliant
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to implement both an HTML5 and a polyfill solution, why not just
    implement the second one and save time and money? Well, here are four reasons
    you should use both:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Better user experience: When using HTML5, you serve your visitors the best
    and smoothest experience possible. Everything is handled by the browser, and you
    only need to focus on your application''s requirements. When using a polyfill
    to address a specific issue, the end-product cannot be of the same quality. Surely,
    delivering something is better than delivering nothing, but a polyfill is just
    a patch for those who run poorer vehicles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Performance: The most significant advantage between a native HTML5 solution
    and a polyfill plugin, is performance. When you request a JavaScript file, you
    require extra resources, which increase loading time. Moreover, a JavaScript plugin
    runs way slower than a native browser-implemented method. Regarding WebSockets,
    the protocol is designed to provide bidirectional full-duplex communication. That
    is the fastest way you can achieve this kind of staff. What a polyfill can do
    is to simply mimic full-duplex communication, using traditional **AJAX polling**.
    We have already seen that AJAX polling is way slower than WebSockets.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Future-friendly: Using HTML5 right now lets your website or app to be automatically
    enhanced from any future browser update. For example, someone who used canvas
    three years ago, benefitted automatically when Internet Explorer was updated to
    Version 9.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Standards-friendly: Although content, not web standards, should be our top
    priority, it is good to know that our current implementation consorts with the
    formal technical specifications. Moreover, the web standards propose what is known
    as "best practices". Although polyfills usually consist of valid JavaScript code,
    most of the time they need to address browser-specific bugs and inconsistencies
    by inserting necessary non-standard code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Popular polyfills
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Modernizr**, a well-known library for detecting HTML5 and CSS3 features,
    provides a great list of HTML5 polyfills that can make your life much easier when
    it comes to supporting older browsers. Regardless of which HTML5 feature you are
    using, there is a corresponding polyfill available at [https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills](https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding WebSockets, following are a some of the libraries that mimic the
    WebSocket behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Hyperlink |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SockJS | [https://github.com/sockjs/sockjs-client](https://github.com/sockjs/sockjs-client)
    |'
  prefs: []
  type: TYPE_TB
- en: '| socket.io | [http://socket.io/](http://socket.io/) |'
  prefs: []
  type: TYPE_TB
- en: '| Kaazing WebSocket Gateway | [http://kaazing.com/products/kaazing-websocket-gateway.html](http://kaazing.com/products/kaazing-websocket-gateway.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| web-socket-js | [http://github.com/gimite/web-socket-js/](http://github.com/gimite/web-socket-js/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Atmosphere | [http://jfarcand.wordpress.com/2010/06/15/using-atmospheres-jquery-plug-in-to-build-applicationsupporting-both-websocket-and-comet/](http://jfarcand.wordpress.com/2010/06/15/using-atmospheres-jquery-plug-in-to-build-applicationsupporting-both-websocket-and-comet/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Graceful WebSocket | [https://github.com/ffdead/jquery-graceful-websocket](https://github.com/ffdead/jquery-graceful-websocket)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Portal | [https://github.com/flowersinthesand/portal](https://github.com/flowersinthesand/portal)
    |'
  prefs: []
  type: TYPE_TB
- en: '| DataChannel | [https://github.com/piranna/DataChannel-polyfill](https://github.com/piranna/DataChannel-polyfill)
    |'
  prefs: []
  type: TYPE_TB
- en: Except Kaazing, all of the above libraries are open-source and free to use.
    Some of these libraries use the AJAX approach, while others rely on Flash, in
    order to emulate the WebSocket behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example using the Graceful WebSocket library. We chose Graceful WebSocket
    because it is simple, lightweight, makes no use of Flash, and exposes functionality
    similar to the WebSocket API.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, download the library, along with jQuery, and include them in
    your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Structure your document as you would normally do and simply replace any reference
    to the WebSocket native class with the `gracefulWebSocket` once!
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is that simple! The rest of the WebSocket events and methods remain the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending data is equally easy and can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In normal mode, the preceding lines of code simply wrap the WebSocket object
    and execute the native methods. In fallback mode, the library changes the protocol
    from WS to HTTP, listens for messages by making HTTP GET requests, and sends messages
    using HTTP POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The specific polyfill solution only required a minor change to our code. Other
    solutions might need you to make a lot of modifications or only work with specific
    server back-ends. You need to pay close attention to the requirements of each
    plugin, its usage, and documentation before using it for production.
  prefs: []
  type: TYPE_NORMAL
- en: Browser plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Browser plugins have been an extremely helpful solution for rich Internet applications
    in the pre-HTML5 era. To name but a few, developers used to offer desktop-rich
    functionality in their websites utilizing the capabilities of Flash (primarily),
    Silverlight, or Java. A few years ago, basic UX effects, transitions, and animations
    could not be made using plain HTML, CSS, or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: To fill this gap, browser plugins provided the developers with a framework which
    could be installed in the client browser and allowed richer content.
  prefs: []
  type: TYPE_NORMAL
- en: Browser plugins have several drawbacks that make them deprecated day-by-day.
    They are resource-intensive, the user needs to wait more until a page is fully
    loaded, and they are mostly based on proprietary technologies. As a result, more
    and more companies (including Apple and Microsoft) are shifting away from browser
    plugins in favor of HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your users browse using an old browser, it is likely that they have
    an old desktop PC with one or more such browser plugins installed. Some great
    WebSocket implementations use Flash in order to achieve bidirectional communication,
    and so do some of the polyfills mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: The **websocket-as**, available at [https://github.com/y8/websocket-as](https://github.com/y8/websocket-as),
    is a popular utility, written in ActionScript, which implements a WebSocket API
    like the HTML5 approach. A similar example exists for Microsoft's Silverlight
    and WCF technologies too ([http://www.codeproject.com/Articles/220350/Super-WebSockets-WCF-Silverlight-5](http://www.codeproject.com/Articles/220350/Super-WebSockets-WCF-Silverlight-5)).
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with Flash or Silverlight, then you could implement a fallback
    solution based on your preferred browser plugin. Otherwise, you can stick to the
    JavaScript implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all browsers support the WebSocket protocol natively. As a result, you need
    to provide some fallback solutions for those users who cannot sense the HTML5
    goodies. Fortunately, the open-source community has provided us with various techniques,
    which emulate the WebSockets' features using plain HTTP or Flash internally. Implementing
    both the HTML5 and the fallback is critical for your web apps and is strongly
    related to the audience width you want to reach. In this chapter, we examined
    some popular fallback techniques and saw how to handle common connectivity errors
    in your WebSocket applications. That's all you need to know for the WebSocket
    and HTML part. In the last chapter, we are going to examine the WebSocket protocol
    in terms of native mobile experience.
  prefs: []
  type: TYPE_NORMAL
