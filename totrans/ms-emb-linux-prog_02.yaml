- en: Chapter 2. Learning About Toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The toolchain is the first element of embedded Linux and the starting point
    of your project. The choices you make at this early stage will have a profound
    impact on the final outcome. Your toolchain should be capable of making effective
    use of your hardware by using the optimum instruction set for your processor,
    using the floating point unit if there is one, and so on. It should support the
    languages that you require and have a solid implementation of POSIX and other
    system interfaces. Not only that, but it should be updated when security flaws
    are discovered or bugs found. Finally, it should be constant throughout the project.
    In other words, once you have chosen your toolchain it is important to stick with
    it. Changing compilers and development libraries in an inconsistent way during
    a project will lead to subtle bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining a toolchain is as simple as downloading and installing a package.
    But, the toolchain itself is a complex thing, as I will show you in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What is a toolchain?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A toolchain is the set of tools that compiles source code into executables
    that can run on your target device, and includes a compiler, a linker, and run-time
    libraries. Initially, you need one to build the other three elements of an embedded
    Linux system: the bootloader, the kernel, and the root filesystem. It has to be
    able to compile code written in assembly, C, and C++ since these are the languages
    used in the base open source packages.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, toolchains for Linux are based on components from the GNU project ([http://www.gnu.org](http://www.gnu.org))
    and that is still true in the majority of cases at the time of writing. However,
    over the past few years, the Clang compiler and the associated LLVM project ([http://llvm.org](http://llvm.org))
    have progressed to the point that it is now a viable alternative to a GNU toolchain.
    One major distinction between LLVM and GNU-based toolchains is in the licensing;
    LLVM has a BSD license, while GNU has the GPL. There are some technical advantages
    to Clang as well, such as faster compilation and better diagnostics, but GNU GCC
    has the advantage of compatibility with the existing code base and support for
    a wide range of architectures and operating systems. Indeed, there are still some
    areas where Clang cannot replace the GNU C compiler, especially when it comes
    to compiling a mainline Linux kernel. It is probable that, in the next year or
    so, Clang will be able to compile all the components needed for embedded Linux
    and so will become an alternative to GNU. There is a good description of how to
    use Clang for cross compilation at [http://clang.llvm.org/docs/CrossCompilation.html](http://clang.llvm.org/docs/CrossCompilation.html).
    If you would like to use it as part of an embedded Linux build system, the EmbToolkit
    ([https://www.embtoolkit.org](https://www.embtoolkit.org)) fully supports both
    GNU and LLVM/Clang toolchains and various people are working on using Clang with
    Buildroot and the Yocto Project. I will cover embedded build systems in [Chapter
    6](ch06.html "Chapter 6. Selecting a Build System"), *Selecting a Build System*.
    Meanwhile, this chapter focuses on the GNU toolchain as it is the only complete
    option at this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'A standard GNU toolchain consists of three main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binutils**: A set of binary utilities including the assembler, and the linker,
    ld. It is available at [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Compiler Collection (GCC)**: These are the compilers for C and other
    languages which, depending on the version of GCC, include C++, Objective-C, Objective-C++,
    Java, Fortran, Ada, and Go. They all use a common back-end which produces assembler
    code which is fed to the GNU assembler. It is available at [http://gcc.gnu.org/](http://gcc.gnu.org/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C library**: A standardized API based on the POSIX specification which is
    the principle interface to the operating system kernel from applications. There
    are several C libraries to consider, see the following section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As well as these, you will need a copy of the Linux kernel headers, which contain
    definitions and constants that are needed when accessing the kernel directly.
    Right now, you need them to be able to compile the C library, but you will also
    need them later when writing programs or compiling libraries that interact with
    particular Linux devices, for example to display graphics via the Linux frame
    buffer driver. This is not simply a question of making a copy of the header files
    in the include directory of your kernel source code. Those headers are intended
    for use in the kernel only and contain definitions that will cause conflicts if
    used in their raw state to compile regular Linux applications.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you will need to generate a set of sanitized kernel headers which I
    have illustrated in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*.
  prefs: []
  type: TYPE_NORMAL
- en: It is not usually crucial whether the kernel headers are generated from the
    exact version of Linux you are going to be using or not. Since the kernel interfaces
    are always backwards-compatible, it is only necessary that the headers are from
    a kernel that is the same as or older than the one you are using on the target.
  prefs: []
  type: TYPE_NORMAL
- en: Most people would consider the GNU debugger, GDB, to be part of the toolchain
    as well, and it is usual that it is built at this point. I will talk about GDB
    in [Chapter 12](ch12.html "Chapter 12. Debugging with GDB"), *Debugging with GDB*.
  prefs: []
  type: TYPE_NORMAL
- en: Types of toolchain - native versus cross toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our purposes, there are two types of toolchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native**: This toolchain runs on the same type of system, sometimes the same
    actual system, as the programs it generates. This is the usual case for desktops
    and servers, and it is becoming popular on certain classes of embedded devices.
    The Raspberry Pi running Debian for ARM, for example, has self-hosted native compilers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross**: This toolchain runs on a different type of system than the target,
    allowing the development to be done on a fast desktop PC and then loaded onto
    the embedded target for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all embedded Linux development is done using a cross development toolchain,
    partly because most embedded devices are not well suited to program development
    since they lack computing power, memory, and storage, but also because it keeps
    the host and target environments separate. The latter point is especially important
    when the host and the target are using the same architecture, X86_64, for example.
    In this case, it is tempting to compile natively on the host and simply copy the
    binaries to the target. This works up to a point but it is likely that the host
    distribution will receive updates more often than the target, that different engineers
    building code for the target will have slightly different versions of the host
    development libraries and so you will violate the principle that the toolchain
    should remain constant throughout the life of the project. You can make this approach
    work if you ensure that the host and target build environments are in lockstep
    with each other, but a much better approach is to keep the host and the target
    separate, and a cross toolchain is a way to do that.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a counter argument in favor of native development. Cross development
    creates the burden of cross-compiling all the libraries and tools that you need
    for your target. We will see later on in this chapter that cross-compiling is
    not always simple because most open source packages are not designed to be built
    in this way. Integrated build tools, including Buildroot and the Yocto Project,
    help by encapsulating the rules to cross compile a range of packages that you
    need in typical embedded systems but, if you want to compile a large number of
    additional packages, then it is better to natively compile them. For example,
    to provide a Debian distribution for the Raspberry Pi or BeagleBone using a cross
    compiler is impossible, they have to be natively compiled. Creating a native build
    environment from scratch is not easy and involves creating a cross compiler first
    to bootstrap a native build environment on the target and using that to build
    packages. You would need a build farm of well-provisioned target boards or you
    may be able to use QEMU to emulate the target. If you want to look into this further,
    you may want to look at the Scratchbox project, now in its second incarnation
    as Scratchbox2 ([https://maemo.gitorious.org/scratchbox2](https://maemo.gitorious.org/scratchbox2)).
    It was developed by Nokia to build their Maemo Linux operating system, and is
    used today by the Mer project and the Tizen project, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, in this chapter, I will focus on the more mainstream cross compiler
    environment, which is relatively easy to set up and administer.
  prefs: []
  type: TYPE_NORMAL
- en: CPU architectures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The toolchain has to be built according to the capabilities of the target CPU,
    which includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU architecture**: arm, mips, x86_64, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Big- or little-endian operation**: Some CPUs can operate in both modes, but
    the machine code is different for each'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating point support**: Not all versions of embedded processors implement
    a hardware floating point unit, in which case, the toolchain can be configured
    to call a software floating point library instead'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Binary Interface (ABI)**: The calling convention used for passing
    parameters between function calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With many architectures, the ABI is constant across the family of processors.
    One notable exception is ARM. The ARM architecture transitioned to the **Extended
    Application Binary Interface** (**EABI**) in the late 2000''s, resulting in the
    previous ABI being named the **Old Application Binary Interface** (**OABI**).
    While the OABI is now obsolete, you continue to see references to EABI. Since
    then, the EABI has split into two, based on the way that floating point parameters
    are passed. The original EABI uses general purpose (integer) registers while the
    newer EABIHF uses floating point registers. The EABIHF is significantly faster
    at floating point operations since it removes the need for copying between integer
    and floating point registers, but it is not compatible with CPUs that do not have
    a floating point unit. The choice, then, is between two incompatible ABIs: you
    cannot mix and match the two and so you have to decide at this stage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU uses a prefix to the tools to identify the various combinations that can
    be generated, consisting of a tuple of three or four components separated by dashes,
    as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**CPU**: The CPU architecture, such as arm, mips, or x86_64\. If the CPU has
    both endian modes, they may be differentiated by adding el for little-endian,
    or eb for big-endian. Good examples are little-endian MIPS, mipsel and big-endian
    ARM, armeb.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor**: This identifies the provider of the toolchain. Examples include
    buildroot, poky, or just unknown. Sometimes it is left out altogether.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel**: For our purposes, it is always ''linux''.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system**: A name for the user space component, which might be `gnu`
    or `uclibcgnu`. The ABI may be appended here as well so, for ARM toolchains, you
    may see `gnueabi`, `gnueabihf`, `uclibcgnueabi`, or `uclibcgnueabihf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the tuple used when building the toolchain by using the `-dumpmachine`
    option of `gcc`. For example, you may see the following on the host computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a native compiler is installed on a machine, it is normal to create links
    to each of the tools in the toolchain with no prefixes so that you can call the
    compiler with the command `gcc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using a cross compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Choosing the C library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The programming interface to the Unix operating system is defined in the C
    language, which is now defined by the POSIX standards. The C library is the implementation
    of that interface; it is the gateway to the kernel for Linux programs, as shown
    in the following diagram. Even if you are writing programs in another language,
    maybe Java or Python, the respective run-time support libraries will have to call
    the C library eventually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing the C library](img/B03982_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The C library is the gateway to the kernel for applications
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the C library needs the services of the kernel it will use the kernel
    `system call` interface to transition between user space and kernel space. It
    is possible to bypass the C library by making kernel system calls directly, but
    that is a lot of trouble and almost never necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several C libraries to choose from. The main options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**glibc**: Available at [http://www.gnu.org/software/libc](http://www.gnu.org/software/libc).
    It is the standard GNU C library. It is big and, until recently, not very configurable,
    but it is the most complete implementation of the POSIX API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eglibc**: Available at [http://www.eglibc.org/home](http://www.eglibc.org/home).
    This is the embedded GLIBC. It was a series of patches to glibc which added configuration
    options and support for architectures not covered by glibc (specifically, the
    PowerPC e500). The split between eglibc and glibc was always rather artificial
    and, fortunately, the code base from eglibc has been merged back into glibc as
    of version 2.20, leaving us with one improved library. eglibc is no longer maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**uClibc**: Available at [http://www.uclibc.org](http://www.uclibc.org). The
    ''u'' is really a Greek ''mu'' character, indicating that this is the micro controller
    C library. It was first developed to work with uClinux (Linux for CPUs without
    memory management units), but has since been adapted to be used with full Linux.
    There is a configuration utility which allows you to fine-tune its features to
    your needs. Even a full configuration is smaller than glibc but it is not as complete
    an implementation of the POSIX standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**musl libc**: Available at [http://www.musl-libc.org](http://www.musl-libc.org).
    It is a new C library designed for embedded systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, which to choose? My advice is to use uClibc only if you are using uClinux
    or if you have very limited amounts of storage or RAM and so the small size would
    be an advantage. Otherwise, I prefer to use an up-to-date glibc, or eglibc. I
    have no experience of musl libc but if you find that glibc/eglibc is not suitable,
    by all means give it a go. This process is summarized in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing the C library](img/B03982_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choosing a C library
  prefs: []
  type: TYPE_NORMAL
- en: Finding a toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have three choices for your cross development toolchain: you may find a
    ready built toolchain that matches your needs, you can use the one generated by
    an embedded build tool which is covered in [Chapter 6](ch06.html "Chapter 6. Selecting
    a Build System"), *Selecting a Build System*, or you can create one yourself as
    described later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pre-built cross toolchain is an attractive option in that you only have to
    download and install it, but you are limited to the configuration of that particular
    toolchain and you are dependent on the person or organization you got it from.
    Most likely, it will be one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: SoC or board vendor. Most vendors offer a Linux toolchain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A consortium dedicated to providing system-level support for a given architecture.
    For example, Linaro, ([https://www.linaro.org](https://www.linaro.org)) have pre-built
    toolchains for the ARM architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party Linux tool vendors such as Mentor Graphics, TimeSys, or MontaVista.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross tool packages for your desktop Linux distribution, for example, Debian-based
    distributions have packages for cross compiling for ARM, MIPS, and PowerPC targets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A binary SDK produced by one of the integrated embedded build tools, the Yocto
    Project has some examples at [http://autobuilder.yoctoproject.org/pub/releases/CURRENT/toolchain](http://autobuilder.yoctoproject.org/pub/releases/CURRENT/toolchain)
    and there is also the Denx Embedded Linux Development Kit at [ftp://ftp.denx.de/pub/eldk/](ftp://ftp.denx.de/pub/eldk/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A link from a forum that you can't find any more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all of these cases, you have to decide whether the pre-built toolchain on
    offer meets your requirements. Does it use the C library you prefer? Will the
    provider give you updates for security fixes and bugs, bearing in mind my comments
    on support and updates from [Chapter 1](ch01.html "Chapter 1. Starting Out"),
    *Starting Out*. If your answer is no to any of these then you should consider
    creating your own.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, building a toolchain is no easy task. If you truly want to do
    the whole thing yourself, take a look at *Cross Linux From Scratch* ([http://trac.clfs.org](http://trac.clfs.org)).
    There, you will find step-by-step instructions on how to create each component.
  prefs: []
  type: TYPE_NORMAL
- en: A simpler alternative is to use crosstool-NG, which encapsulates the process
    into a set of scripts and has a menu-driven front-end. You still need a fair degree
    of knowledge, though, just to make the right choices.
  prefs: []
  type: TYPE_NORMAL
- en: It is simpler still to use a build system such as Buildroot or the Yocto Project
    since they generate a toolchain as part of the build process. This is my preferred
    solution as I have shown in [Chapter 6](ch06.html "Chapter 6. Selecting a Build
    System"), *Selecting a Build System*.
  prefs: []
  type: TYPE_NORMAL
- en: Building a toolchain using crosstool-NG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am going to begin with crosstool-NG because it allows you to see the process
    of creating the toolchain and to create several different sorts.
  prefs: []
  type: TYPE_NORMAL
- en: Some years ago, Dan Kegel wrote a set of scripts and makefiles for generating
    cross development toolchains and called it crosstool ([kegel.com/crosstool](http://kegel.com/crosstool)).
    In 2007, Yann E. Morin used that base to create the next generation of crosstool,
    crosstool-NG ([crosstool-ng.org](http://crosstool-ng.org)). Today it is, by far,
    the most convenient way to create a stand-alone cross toolchain from source.
  prefs: []
  type: TYPE_NORMAL
- en: Installing crosstool-NG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you begin, you will need a working native toolchain and build tools
    on your host PC. To work with crosstool-NG on an Ubuntu host, you will need to
    install the packages using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, get the current release from the croostool-NG downloads section, [http://crosstool-ng.org/download/crosstool-ng](http://crosstool-ng.org/download/crosstool-ng).
    In my examples I have used 1.20.0\. Extract it and create the front-end menu system,
    ct-ng, as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `--enable-local` option means that the program will be installed into the
    current directory, which avoids the need for root permissions as would be required
    if you were to install it in the default location, `/usr/local/bin`. Type `./ct-ng`
    from the current directory to launch the crosstool menu.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the toolchain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Crosstool-NG can build many different combinations of toolchains. To make the
    initial configuration easier, it comes with a set of samples that cover many of
    the common use-cases. Use `./ct-ng list-samples` to generate the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, suppose that your target is a BeagleBone Black which has an
    ARM Cortex A8 core and a VFPv3 floating point unit, and that you want to use a
    current version of glibc. The closest sample is `arm-cortex_a8-linux-gnueabi`.
    You can see the default configuration by prefixing the name with `show-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To select this as the target configuration, you would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can review the configuration and make changes using the
    configuration menu command `menuconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The menu system is based on the Linux kernel `menuconfig` and so navigation
    of the user interface will be familiar to anyone who has configured a kernel.
    If not, please refer to [Chapter 4](ch04.html "Chapter 4. Porting and Configuring
    the Kernel"), *Porting and Configuring the Kernel* for a description of `menuconfig`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few configuration changes that I would recommend you make at this
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Paths and misc** options, disable **Render the toolchain read-only** (`CT_INSTALL_DIR_RO`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Target options** | **Floating point,** select **hardware (FPU)** (`CT_ARCH_FLOAT_HW`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **C-library** | **extra config**, add **--enable-obsolete-rpc** (`CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first is necessary if you want to add libraries to the toolchain after it
    has been installed, which I will describe later in this chapter. The next is to
    select the optimum floating point implementation for a processor with a hardware
    floating point unit. The last forces the toolchain to be generated with an obsolete
    header file, `rpc.h`, which is still used by a number of packages (note that this
    is only a problem if you selected glibc). The names in parentheses are the configuration
    labels stored in the configuration file. When you have made the changes, exit
    `menuconfig`, and save the configuration as you do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration data is saved into a file named `.config`. Looking at the
    file, you will see that the first line of text reads *Automatically generated
    make config: don''t edit* which is generally good advice, but I recommend that
    you ignore it in this case. Do you remember from the discussion about toolchain
    ABIs that ARM has two variants, one which passes floating point parameters in
    integer registers and one that uses the VFP registers? The float configuration
    you have just chosen is of the latter type and so the ABI part of the tuple should
    read `eabihf`. There is a configuration parameter that does exactly what you want
    but it is not enabled by default, neither does it appear in the menu, at least
    not in this version of crosstool. Consequently, you will have to edit `.config`
    and add the line shown in bold as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use crosstool-NG to get, configure, and build the components according
    to your specification by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The build will take about half an hour, after which you will find your toolchain
    is present in `~/x-tools/arm-cortex_a8-linux-gnueabihf/`.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get an idea of what is in a typical toolchain, I want to examine the crosstool-NG
    toolchain you have just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The toolchain is in the directory `~/x-tools/arm-cortex_a8-linux-gnueabihf/bin`.
    In there you will find the cross compiler, `arm-cortex_a8-linux-gnueabihf-gcc`.
    To make use of it, you need to add the directory to your path using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can take a simple `hello world` program that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And compile it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can confirm that it has been cross compiled by using the `file` command
    to print the type of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finding out about your cross compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you have just received a toolchain, and that you would like to
    know more about how it was configured. You can find out a lot by querying gcc.
    For example, to find the version, you use `--version`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To find how it was configured, use `-v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of output there but the interesting things to note are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--with-sysroot=/home/chris/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot`:
    This is the default sysroot directory, see the following section for an explanation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--enable-languages=c,c++`: Using this we have both C and C++ languages enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--with-arch=armv7-a`: The code is generated using the ARM v7a instruction
    set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--with-cpu=cortex-a8 and --with-tune=cortex-a8`: The the code is further tweaked
    for a Cortex A8 core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--with-float=hard`: Generate opcodes for the floating point unit and uses
    the VFP registers for parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--enable-threads=posix`: Enable POSIX threads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the default settings for the compiler. You can override most of them
    on the gcc command line so, for example, if you want to compile for a different
    CPU, you can override the configured setting, `–-with-cpu`, by adding `-mcpu`
    to the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can print out the the range of architecture-specific options available
    using `--target-help,` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering if it matters whether or not you get the exact configuration
    right at the time you generate the toolchain if you can change it later on, and
    the answer depends on the way you anticipate using it. If you plan to create a
    new toolchain for each target, then it makes sense to set everything up at the
    beginning because it will reduce the risks of getting it wrong later on. Jumping
    ahead a little to [Chapter 6](ch06.html "Chapter 6. Selecting a Build System"),
    *Selecting a Build System*, I call this the Buildroot philosophy. If, on the other
    hand, you want to build a toolchain that is generic and you are prepared to provide
    the correct settings when you build for a particular target, then you should make
    the base toolchain generic, which is the way the Yocto Project handles things.
    The preceding examples follow the Buildroot philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: The sysroot, library, and header files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The toolchain sysroot is a directory which contains subdirectories for libraries,
    header files, and other configuration files. It can be set when the toolchain
    is configured through `--with-sysroot=` or it can be set on the command line,
    using `--sysroot=`. You can see the location of the default sysroot by using `-print-sysroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find the following in the sysroot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lib`: Contains the shared objects for the C library and the dynamic linker/loader,
    `ld-linux`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/lib`: the static library archives for the C library and any other libraries
    that may be installed subsequently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/include`: Contains the headers for all the libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/bin`: Contains the utility programs that run on the target, such as the
    `ldd` command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr/share`: Used for localization and internationalization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sbin`: Provides the ldconfig utility, used to optimize library loading paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plainly, some of these are needed on the development host to compile programs,
    and others – for example the shared libraries and `ld-linux` – are needed on the
    target at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools in the toolchain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows various other commands in the toolchain together
    with a brief description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `addr2line` | Converts program addresses into filenames and numbers by reading
    the debug symbol tables in an executable file. It is very useful when decoding
    addresses printed out in a system crash report. |'
  prefs: []
  type: TYPE_TB
- en: '| `ar` | The archive utility is used to create static libraries. |'
  prefs: []
  type: TYPE_TB
- en: '| `as` | This is the GNU assembler. |'
  prefs: []
  type: TYPE_TB
- en: '| `c++filt` | This is used to demangle C++ and Java symbols. |'
  prefs: []
  type: TYPE_TB
- en: '| `cpp` | This is the C preprocessor, and is used to expand `#define`, `#include`,
    and other similar directives. You seldom need to use this by itself. |'
  prefs: []
  type: TYPE_TB
- en: '| `elfedit` | This is used to update the ELF header of ELF files. |'
  prefs: []
  type: TYPE_TB
- en: '| `g++` | This is the GNU C++ front-end, which assumes source files contain
    C++ code. |'
  prefs: []
  type: TYPE_TB
- en: '| `gcc` | This is the GNU C front-end, which assumes source files contain C
    code. |'
  prefs: []
  type: TYPE_TB
- en: '| `gcov` | This is a code coverage tool. |'
  prefs: []
  type: TYPE_TB
- en: '| `gdb` | This is the GNU debugger. |'
  prefs: []
  type: TYPE_TB
- en: '| `gprof` | This is a program profiling tool. |'
  prefs: []
  type: TYPE_TB
- en: '| `ld` | This is the GNU linker. |'
  prefs: []
  type: TYPE_TB
- en: '| `nm` | This lists symbols from object files. |'
  prefs: []
  type: TYPE_TB
- en: '| `objcopy` | This is used to copy and translate object files. |'
  prefs: []
  type: TYPE_TB
- en: '| `objdump` | This is used to display information from object files. |'
  prefs: []
  type: TYPE_TB
- en: '| `ranlib` | This creates or modifies an index in a static library, making
    the linking stage faster. |'
  prefs: []
  type: TYPE_TB
- en: '| `readelf` | This displays information about files in ELF object format. |'
  prefs: []
  type: TYPE_TB
- en: '| `size` | This lists section sizes and the total size. |'
  prefs: []
  type: TYPE_TB
- en: '| `strings` | This display strings of printable characters in files. |'
  prefs: []
  type: TYPE_TB
- en: '| `strip` | This is used to strip an object file of debug symbol tables, thus
    making it smaller. Typically, you would strip all the executable code that is
    put onto the target. |'
  prefs: []
  type: TYPE_TB
- en: Looking at the components of the C library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C library is not a single library file. It is composed of four main parts
    that together implement the POSIX functions API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libc`: The main C library that contains the well-known POSIX functions such
    as `printf`, `open`, `close`, `read`, `write`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libm`: Maths functions such as `cos`, `exp`, and `log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libpthread`: All the POSIX thread functions with names beginning with `pthread_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`librt`: The real-time extensions to POSIX, including shared memory and asynchronous
    I/O'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first one, `libc`, is always linked in but the others have to be explicitly
    linked with the `-l` option. The parameter to `-l` is the library name with `lib`
    stripped off. So, for example, a program that calculates a sine function by calling
    `sin()` would be linked with `libm` using `-lm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify which libraries have been linked in this or any other program
    by using the `readelf` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Shared libraries need a run-time linker, which you can expose using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is so useful that I have a script file with these commands into a shell
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Linking with libraries: static and dynamic linking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any application you write for Linux, whether it be in C or C++, will be linked
    with the C library, libc. This is so fundamental that you don't even have to tell
    `gcc` or `g++` to do it because it always links libc. Other libraries that you
    may want to link with have to be explicitly named through the `-l` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library code can be linked in two different ways: statically, meaning that
    all the library functions your application calls and their dependencies are pulled
    from the library archive and bound into your executable; and dynamically, meaning
    that references to the library files and functions in those files are generated
    in the code but the actual linking is done dynamically at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Static libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static linking is useful in a few circumstances. For example, if you are building
    a small system which consists of only BusyBox and some script files, it is simpler
    to link BusyBox statically and avoid having to copy the runtime library files
    and linker. It will also be smaller because you only link in the code that your
    application uses rather than supplying the entire C library. Static linking is
    also useful if you need to run a program before the filesystem that holds the
    runtime libraries is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'You tell gcc to link all libraries statically by adding `-static` to the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the size of the binary increases dramatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Static linking pulls code from a library archive, usually named `lib[name].a`.
    In the preceding case it is `libc.a`, which is in `[sysroot]/usr/lib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that the syntax `$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)` places
    the output of the program on the command line. I am using it as a generic way
    to refer to the files in the sysroot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a static library is as simple as creating an archive of object files
    using the `ar` command. If I had two source files named `test1.c` and `test2.c`
    and I want to create a static library named `libtest.a,` then I would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then I could link `libtest` into my `helloworld` program using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Shared libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more common way to deploy libraries is as shared objects that are linked at
    runtime, which makes more efficient use of storage and system memory, since only
    one copy of the code needs to be loaded. It also makes it easy to update library
    files without having to re-link all the programs that use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object code for a shared library must be position-independent so that the
    runtime linker is free to locate it in memory at the next free address. To do
    this, add the `-fPIC` parameter to gcc, and then link it using the `-shared` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To link an application with this library, you add `-ltest`, exactly as in the
    static case mentioned in the preceding paragraph but, this time, the code is not
    included in the executable, but there is a reference to the library that the runtime
    linker will have to resolve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The runtime linker for this program is `/lib/ld-linux-armhf.so.3`, which must
    be present in the target''s filesystem. The linker will look for `libtest.so`
    in the default search path: `/lib` and `/usr/lib`. If you want it to look for
    libraries in other directories as well, you can place a colon-separated list of
    paths in the shell variable `LD_LIBRARY_PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Understanding shared library version numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the benefits of shared libraries is that they can be updated independently
    of the programs that use them. Library updates are of two types: those that fix
    bugs or add new functions in a backwards-compatible way, and those that break
    compatibility with existing applications. GNU/Linux has a versioning scheme to
    handle both these cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Each library has a release version and an interface number. The release version
    is simply a string that is appended to the library name, for example the JPEG
    image library, libjpeg, is currently at release 8.0.2 and so the library is named
    `libjpeg.so.8.0.2`. There is a symbolic link named `libjpeg.so` to `libjpeg.so.8.0.2`
    so that, when you compile a program with `–ljpeg,` you link with the current version.
    If you install version 8.0.3, the link is updated and you will link with that
    one instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose that version 9.0.0 comes along and that breaks backwards compatibility.
    The link from `libjpeg.so` now points to `libjpeg.so.9.0.0`, so that any new programs
    are linked with the new version, possibly throwing compile errors when the interface
    to libjpeg changes, which the developer can fix. Any programs on the target that
    are not recompiled are going to fail in some way because they are still using
    the old interface. This is where the `soname` helps. The `soname` encodes the
    interface number when the library was built and is used by the runtime linker
    when it loads the library. It is formatted as `<library name>.so.<interface number>`.
    For `libjpeg.so.8.0.2,` the `soname` is `libjpeg.so.8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Any program compiled with it will request `libjpeg.so.8` at runtime which will
    be a symbolic link on the target to `libjpeg.so.8.0.2`. When version 9.0.0 of
    libjpeg is installed, it will have a `soname` of `libjpeg.so.9`, and so it is
    possible to have two incompatible versions of the same library installed on the
    same system. Programs that were linked with `libjpeg.so.8.*.*` will load `libjpeg.so.8,`
    and those linked with `libjpeg.so.9.*.*` will load `libjpeg.so.9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why, when you look at the directory listing of `<sysroot>/usr/lib/libjpeg*`,
    you find these four files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`libjpeg.a`: This is the library archive used for static linking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libjpeg.so -> libjpeg.so.8.0.2` : This is a symbolic link, used for dynamic
    linking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libjpeg.so.8 -> libjpeg.so.8.0.2`: This is a symbolic link used when loading
    the library at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`libjpeg.so.8.0.2`: This is the actual shared library, used at both compile
    time and runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two are only needed on the host computer for building, the last two
    are needed on the target at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The art of cross compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a working cross toolchain is the starting point of a journey, not the
    end of it. At some point, you will want to begin cross compiling the various tools,
    applications, and libraries that you need on your target. Many of them will be
    open source packages, each of which has its own method of compiling, and each
    with its own peculiarities. There are some common build systems, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Pure makefiles where the toolchain is controlled by the `make` variable `CROSS_COMPILE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GNU build system known as Autotools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake ([https://cmake.org](https://cmake.org))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will cover only the first two here since these are the ones needed for even
    a basic embedded Linux system. For CMake, there are some excellent resources on
    the CMake website referenced in the preceding point.
  prefs: []
  type: TYPE_NORMAL
- en: Simple makefiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some important packages are very simple to cross compile, including the Linux
    kernel, the U-Boot bootloader, and Busybox. For each of these, you only need to
    put the toolchain prefix in the `make` variable `CROSS_COMPILE`, for example `arm-cortex_a8-linux-gnueabi-`.
    Note the trailing dash `-`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to compile Busybox, you would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can set it as a shell variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the case of U-Boot and Linux, you also have to set the `make` variable `ARCH`
    to one of the machine architectures they support, which I will cover in [Chapter
    3](ch03.html "Chapter 3. All About Bootloaders"), *All About Bootloaders* and
    [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"), *Porting
    and Configuring the Kernel*.
  prefs: []
  type: TYPE_NORMAL
- en: Autotools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name, Autotools, refers to a group of tools that are used as the build
    system in many open source projects. The components, together with the appropriate
    project pages, are:'
  prefs: []
  type: TYPE_NORMAL
- en: GNU Autoconf ([http://www.gnu.org/software/autoconf/autoconf.html](http://www.gnu.org/software/autoconf/autoconf.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Automake ([http://www.gnu.org/savannah-checkouts/gnu/automake](http://www.gnu.org/savannah-checkouts/gnu/automake))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GNU Libtool ([http://www.gnu.org/software/libtool/libtool.html](http://www.gnu.org/software/libtool/libtool.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gnulib ([https://www.gnu.org/software/gnulib](https://www.gnu.org/software/gnulib))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of Autotools is to smooth over the differences between the many different
    types of system that the package may be compiled for, accounting for different
    versions of compilers, different versions of libraries, different locations of
    header files, and dependencies with other packages. Packages that use Autotools
    come with a script named `configure` that checks dependencies and generates makefiles
    according to what it finds. The configure script may also give you the opportunity
    to enable or disable certain features. You can find the options on offer by running
    `./configure --help`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure, build, and install a package for the native operating system,
    you would typically run these three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Autotools is able to handle cross development as well. You can influence the
    behavior of the configure script by setting these shell variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CC`: The C compiler command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CFLAGS`: Additional C compiler flags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LDFLAGS`: Additional linker flags, for example if you have libraries in a
    non-standard directory `<lib dir>` you would add it to the library search path
    by adding `-L<lib dir>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LIBS`: Contains a list of additional libraries to pass to the linker, for
    instance `-lm` for the math library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPPFLAGS`: Contains C/C++ preprocessor flags, for example you would add `-I<include
    dir>` to search for headers in a non-standard directory `<include dir>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CPP`: The C preprocessor to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes it is sufficient to set only the `CC` variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'At other times, that will result in an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for the failure is that `configure` often tries to discover the
    capabilities of the toolchain by compiling snippets of code and running them to
    see what happens, which cannot work if the program has been cross compiled. Nevertheless,
    there is a hint in the error message of how to solve the problem. Autotools understands
    three different types of machine that may be involved when compiling a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: This is the computer that is to build the package, which defaults
    to the current machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Host**: This is the computer the program will run on: for a native compile
    this is left blank and it defaults to be the same computer as build. For a cross
    compile you set it to be the tuple of your toolchain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: This is the computer the program will generate code for: you would
    set this when building a cross compiler, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, to cross compile, you just need to override host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'One final thing to note is that the default install directory is `<sysroot>/usr/local/*`.
    You would usually install it in `<sysroot>/usr/*` so that the header files and
    libraries would be picked up from their default locations. The complete command
    to configure a typical Autotools package is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An example: SQLite'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SQLite library implements a simple relational database and is quite popular
    on embedded devices. You begin by getting a copy of SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the configure script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That seems to work! If it failed, there would be error messages printed to
    the terminal and recorded in `config.log`. Note that several makefiles have been
    created, so now you can build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you install it into the toolchain directory by setting the `make` variable
    `DESTDIR`. If you don't, it will try to install it into the host computer's `/usr`
    directory which is not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You may find that final command fails with a file permissions error. A crosstool-NG
    toolchain will be read-only by default, which is why it is useful to set `CT_INSTALL_DIR_RO`
    to `y` when building it. Another common problem is that the toolchain is installed
    in a system directory such as `/opt` or `/usr/local` in which case you will need
    root permissions when running the install.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing, you should find that various files have been added to your
    toolchain:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/bin`: sqlite3\. This is a command-line interface for SQLite
    that you can install and run on the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<`sysroot>/usr/lib`: libsqlite3.so.0.8.6, libsqlite3.so.0, libsqlite3.so libsqlite3.la
    libsqlite3.a. These are the shared and static libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/lib/pkgconfig`: `sqlite3.pc`: This is the package configuration
    file, as described in the following section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<sysroot>/usr/lib/include`: `sqlite3.h`, `sqlite3ext.h`: These are the header
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<`sysroot>/usr/share/man/man1`: sqlite3.1\. This is the manual page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you can compile programs that use sqlite3 by adding `-lsqlite3` at the
    link stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Where, `sqlite-test.c` is a hypothetical program that calls SQLite functions.
    Since sqlite3 has been installed into the sysroot, the compiler will find the
    header and library files without any problem. If they had been installed elsewhere
    you would have to add `-L<lib dir>` and `-I<include dir>`.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, there will be runtime dependencies as well, and you will have to
    install the appropriate files into the target directory as described in [Chapter
    5](ch05.html "Chapter 5. Building a Root Filesystem"), *Building a Root Filesystem*.
  prefs: []
  type: TYPE_NORMAL
- en: Package configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tracking package dependencies is quite complex. The package configuration utility,
    `pkg-config` ([http://www.freedesktop.org/wiki/Software/pkg-config](http://www.freedesktop.org/wiki/Software/pkg-config))
    helps track which packages are installed and which compile flags each needs by
    keeping a database of Autotools packages in `[sysroot]/usr/lib/pkgconfig`. For
    instance, the one for SQLite3 is named `sqlite3.pc` and contains essential information
    needed by other packages that need to make use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the utility `pkg-config` to extract information in a form that
    you can feed straight to gcc. In the case of a library like libsqlite3, you want
    to know the library name (`--libs`) and any special C flags (`--cflags`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! That failed because it was looking in the host''s sysroot and the development
    package for libsqlite3 has not been installed on the host. You need to point it
    at the sysroot of the target toolchain by setting the shell variable `PKG_CONFIG_LIBDIR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output is `-lsqlite3`. In this case, you knew that already, but generally
    you wouldn''t, so this is a valuable technique. The final command to compile would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Problems with cross compiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sqlite3 is a well-behaved package and cross compiles nicely but not all packages
    are so tame. Typical pain points include:'
  prefs: []
  type: TYPE_NORMAL
- en: Home-grown build systems, zlib, for example, has a configure script but it does
    not behave like the Autotools configure described in the previous section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure scripts that read `pkg-config` information, headers, and other files
    from the host, disregarding the `--host` override
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripts that insist on trying to run cross compiled code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each case requires careful analysis of the error and additional parameters to
    the configure script to provide the correct information or patches to the code
    to avoid the problem altogether. Bear in mind that one package may have many dependencies,
    especially with programs that have a graphical interface using GTK or QT or handle
    multimedia content. As an example, mplayer, which is a popular tool for playing
    multimedia content, has dependencies on over 100 libraries. It would take weeks
    of effort to build them all.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, I would not recommend manually cross compiling components for the
    target in this way except when there is no alternative, or the number of packages
    to build is small. A much better approach is to use a build tool such as Buildroot
    or the Yocto Project, or, avoid the problem altogether by setting up a native
    build environment for your target architecture. Now you can see why distributions
    like Debian are always compiled natively.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The toolchain is always your starting point: everything that follows from that
    is dependent on having a working, reliable toolchain.'
  prefs: []
  type: TYPE_NORMAL
- en: Most embedded build environments are based on a cross development toolchain
    which creates a clear separation between a powerful host computer building the
    code and a target computer on which it runs. The toolchain itself consists of
    the GNU binutils, a C compiler from the GNU compiler collection – and quite likely
    the C++ compiler as well – plus one of the C libraries I have described. Usually
    the GNU debugger, gdb, will be generated at this point, which I describe in [Chapter
    12](ch12.html "Chapter 12. Debugging with GDB"), *Debugging with GDB*. Also, keep
    a watch out for the Clang compiler, as it will develop over the next few years.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may start with nothing but a toolchain – perhaps built using crosstool-NG
    or downloaded from Linaro – and use it to compile all of the packages that you
    need on your target, accepting the amount of hard work this will entail. Or, you
    may obtain the toolchain as part of a distribution which includes a range of packages.
    A distribution can be generated from source code using a build system such as
    Buildroot or the Yocto Project, or it can be a binary distribution from a third
    party, maybe a commercial enterprise like Mentor Graphics or an open source project
    such as the Denx ELDK. Beware of toolchains or distributions that are offered
    to you for free as part of a hardware package: they are often poorly configured
    and not maintained. In any case, you should make the choice according to your
    situation, and then be consistent in its use throughout the project.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a toolchain, you can use it to build the other components of your
    embedded Linux system. In the next chapter, you will learn about the bootloader,
    which brings your device to life and begins the boot process.
  prefs: []
  type: TYPE_NORMAL
