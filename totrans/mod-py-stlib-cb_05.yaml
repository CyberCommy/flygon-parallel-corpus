- en: Date and Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Time-zone-aware datetime—retrieving a reliable value for the current datetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing dates—how to parse dates according to the ISO 8601 format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving dates—how to store datetimes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From timestamp to datetime—converting to and from timestamps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying dates in a user format—formatting dates according to our user language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going to tomorrow—how to compute a datetime that refers to tomorrow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going to next month—how to compute a datetime that refers to next month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weekdays—how to build a date that refers to the *n^(th)* Monday/Friday of the
    month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workdays—how to get workdays in a time range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining dates and times—making a datetime out of a date and time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dates are a part of our lives and we are used to handling times and dates as
    a basic process. Even a small kid knows what time it is or what *tomorrow* means.
    But, try to talk to someone on the other side of the world and suddenly the concepts
    of *tomorrow*, *midnight*, and so on start to become very complex.
  prefs: []
  type: TYPE_NORMAL
- en: When you say tomorrow, are you talking about your tomorrow or mine? If you schedule
    a process that should run at midnight, which midnight is it?
  prefs: []
  type: TYPE_NORMAL
- en: To make everything harder, we have leap seconds, odd time zones, daylight savings,
    and so on. When you try to approach dates in software, especially in software
    as a service that might be used by people around the world, suddenly it becomes
    clear that dates are a complex affair.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter includes some recipes that, while being short, can save you headaches
    and bugs when working with user-provided dates.
  prefs: []
  type: TYPE_NORMAL
- en: Time-zone-aware datetime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python datetimes are usually *naive*, which means they don't know which time
    zone they refer to. This can be a major problem because, given a datetime, it's
    impossible to know when it actually refers to.
  prefs: []
  type: TYPE_NORMAL
- en: The most common error in working with dates in Python is trying to get the current
    datetime through `datetime.datetime.now()`, as all `datetime` methods work with
    naive dates, it's impossible to know which time that value represents.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only reliable way to retrieve the current datetime is by using `datetime.datetime.utcnow()`.
    Independently of where the user is and how the system is configured, it will always
    return the UTC time. So we need to make it time-zone-aware to be able to decline
    it to any time zone in the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a time-zone-aware current time, it is possible to convert it to
    any other time zone, so that we can display to our users the value in their own
    time zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, given I''m currently in the UTC+01:00 time zone, I can grab the current
    time-zone-aware time for UTC and then display it in my own time zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All Python datetimes, by default, come without any time zone specified, but
    by setting `tzinfo`, we can make them aware of the time zone they refer to.
  prefs: []
  type: TYPE_NORMAL
- en: If we just grab our current time (`datetime.datetime.now()`), there is no easy
    way for us to know from within our software which time zone we are grabbing the
    time from. The only time zone we can always rely on is UTC, for that reason. Whenever
    retrieving the current time, it's best always to rely on `datetime.datetime.utcnow()`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a date for UTC, as we know it's actually for the UTC time zone,
    we can easily attach the `datetime.timezone.utc` time zone (the only one that
    Python provides out of the box) and make it time-zone-aware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `now` function does that: it grabs the datetime and makes it time-zone-aware.'
  prefs: []
  type: TYPE_NORMAL
- en: As our datetime is now time-zone-aware, from that moment on, we can rely on
    the `datetime.datetime.astimezone` method to convert to any time zone we want.
    So, if we know that our user is on UTC+01:00, we can display the datetime with
    the user's local value instead of showing a UTC value.
  prefs: []
  type: TYPE_NORMAL
- en: That's exactly what the `astimezone` function does. Once a datetime and an offset
    from UTC are provided, it returns a date that refers to a local time zone based
    on that offset.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that while this solution works, it lacks more advanced
    features. For example, I'm currently on UTC+01:00, but according to my country's
    Daylight Savings policy, I might be on UTC+02:00\. Also, we only support offsets
    based on an integer hour, and while that's the most common case, there are time
    zones, such as India's or Iran's, that have a half-hour offset.
  prefs: []
  type: TYPE_NORMAL
- en: While we can extend our support for time zones to include these oddities, for
    more advanced cases you should probably rely on the `pytz` package, which ships
    time zones for the full IANA time zone database.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When receiving a datetime from another software or from a user, it will probably
    be in a string format. Formats such as JSON don't even define how a date should
    be represented, but it's usually a best practice to provide those in the ISO 8601
    format.
  prefs: []
  type: TYPE_NORMAL
- en: The ISO 8601 format is usually defined as `[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]+-[TZ]`,
    for example `2018-03-19T22:00+0100` would refer to March 19 at 10 P.M. on the
    UTC+01:00 time zone.
  prefs: []
  type: TYPE_NORMAL
- en: ISO 8601 conveys all the information you need to represent a date and time,
    so it's a good way to marshal a datetime and send it across a network.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, it has many oddities (for example, the `+00` time zone can also be written
    as `Z`, or you can omit the `:` between hours, minutes, and seconds), so parsing
    it might sometimes cause trouble.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to all the variants ISO 8601 allows, there is no easy way to throw it to
    `datetime.datetime.strptime` and get back a datetime for all case; we must coalesce
    all possible formats to a single one and then parse that one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous implementation of `parse_iso8601` copes with most possible ISO
    8601 representations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea of `parse_iso8601` is that whatever dialect of ISO 8601 is received
    before parsing it, we will transform it into the form of `[YYYY][MM][DD]T[hh][mm][ss]+-[TZ]`.
  prefs: []
  type: TYPE_NORMAL
- en: The hardest part is detecting the time zone, as that can be separated by `+`, `-`,
    or can even be `Z`. Once the time zone is extracted, we can just get rid of all
    examples of `-` in the date and all instances of `:` in times.
  prefs: []
  type: TYPE_NORMAL
- en: Note that before extracting the time zone we separated the time from the date,
    as both the date and the time zone might contain the `-` character, and we don't
    want our parser to get confused.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parsing dates can become very complex. While our `parse_iso8601` will work when
    interacting with most systems that serve a date in string format (such as JSON),
    you will quickly face cases where it falls short due to all the ways a datetime
    can be expressed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might receive back a value such as `2 weeks ago` or `July 4,
    2013 PST`. Trying to parse all these cases is not very convenient and can get
    complicated pretty quickly. In case you have to handle these special cases, you
    should probably rely on an external package such as `dateparser`, `dateutil`,
    or `moment`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving dates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sooner or later, we all have to save a date somewhere, sending it to a database
    or saving it into a file. Maybe we will be converting it into JSON to send it
    to another software.
  prefs: []
  type: TYPE_NORMAL
- en: Many database systems do not track time zones. Some of them have a configuration
    option that states what time zone they should work with, but in most cases, the
    date you provide will be saved as is.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to unexpected bugs or behaviors in many cases. Suppose you were a
    good boy scout and properly did all the work required to receive a datetime preserving
    its time zone. Now you have a datetime of `2018-01-15 15:30:00 UTC+01:00` and,
    once you store it in your database, `UTC+01:00` will easily be lost, even if you
    store it in a file yourself, storing and restoring the time zone is usually a
    bothersome work.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you should always ensure you convert your datetimes to UTC
    before storing them somewhere, that will always guarantee that, independently
    from which time zone the datetime came from, it will always represent the right
    time when you load it back.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To save a datetime, we want a function that ensures that datetime always refers
    to UTC before actually storing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `asutc` function can be used with any datetime to ensure it''s moved to
    UTC before actually storing it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functioning of this recipe is pretty straightforward, through the `datetime.datetime.astimezone`
    method, the date is always converted to its UTC representation.
  prefs: []
  type: TYPE_NORMAL
- en: This ensures it will work for both where your storage keeps track of time zones
    (as the date will still be time-zone-aware, but the time zone will be UTC) and
    when your storage doesn't preserve time zones (as a UTC date without a time zone
    still represents the same UTC date as if the delta was zero).
  prefs: []
  type: TYPE_NORMAL
- en: From timestamps to datetimes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Timestamps are the representation of a date in the number of seconds from a
    specific moment. Usually, as the value that a computer can represent is limited
    in size, that is normally taken from January 1st, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever received a value such as `1521588268` as a datetime representation,
    you might be wondering how that can be converted into an actual datetime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most recent Python versions introduced a method to quickly convert datetimes
    back and forth from timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As pointed out in the recipe introduction, there is a limit to how big a number
    can be for a computer. For that reason, it's important to note that while `datetime.datetime`
    can represent practically any date, a timestamp can't.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, trying to represent a datetime from `1300` will succeed but it
    will fail to convert it to a timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A timestamp is only able to represent dates starting from January 1st, 1970.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true also in the reverse direction for faraway dates, while `253402214400`
    represents the timestamp for December 31, 9999, trying to create a datetime from
    a date later than that value will fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A datetime is only able to represent dates from the year 1 to 9999.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying dates in user format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When displaying dates from software, it's easy to confuse users if they don't
    know the format you are going to rely on.
  prefs: []
  type: TYPE_NORMAL
- en: We already know that time zones play an important role and that when displaying
    a time we always want to show it as time-zone-aware, but even dates can have their
    ambiguities. If you write 3/4/2018, will it be April 3^(rd) or March 4^(th)?
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, you usually have two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Go for the international format (2018-04-03)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Localize the date (April 3, 2018)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When possible, it's obviously better to be able to localize the date format,
    so that our users will see a value that they can easily recognize.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe requires the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `locale` module in the Python standard library provides a way to get formatting
    for the localization supported by your system. By using it, we can format dates
    in any way allowed by the target system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `format_date` will properly give the output as a string representation
    of the date in the expected `locale` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `format_date` function is divided into two major parts.
  prefs: []
  type: TYPE_NORMAL
- en: The first is provided by the `switchlocale` context manager, which is in charge
    of enabling the requested `locale` (locales are process-wide), giving back control
    to the wrapped block of code and then restoring the original `locale`. This way,
    we can use the requested `locale` only within the context manager and not influence
    any other part of our software.
  prefs: []
  type: TYPE_NORMAL
- en: The second is what happens within the context manager itself. Using `locale.nl_langinfo`,
    the date-and-time format string (`locale.D_T_FMT`) is requested to the currently
    enabled `locale`. That gives back a string that tells us how to format a datetime
    in the currently active `locale`. The returned string will be something like `'%a
    %e %b %X %Y'`.
  prefs: []
  type: TYPE_NORMAL
- en: Then the date itself is formatted according to the retrieved format string through
    `datetime.strftime`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the returned string will usually contain the `%a` and `%b` formatters,
    which represent the *current weekday* and *current month* names. As the name of
    a weekday or month changes for each language, the Python interpreter will emit
    the name of the weekday or month in the currently enabled `locale`.
  prefs: []
  type: TYPE_NORMAL
- en: So, we not only formatted the date the way the user expected, but the resulting
    output will also be in the user's language.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this solution seems very convenient, it's important to note that it relies
    on switching `locale` on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Switching `locale` is a very expensive operation, so if you have a lot of values
    to format (such as a `for` loop or thousand of dates), it might be far too slow.
  prefs: []
  type: TYPE_NORMAL
- en: Also switching `locale` is not thread-safe, so you won't be able to apply this
    recipe in multithreaded software, unless all the switching of `locale` happens
    before other threads are started.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to handle localization in a robust and thread-safe way, you might
    want to check the babel package. Babel has support for the localization of dates
    and numbers, and it works in a way that doesn't require setting a global state,
    thus behaving properly even in threaded environments.
  prefs: []
  type: TYPE_NORMAL
- en: Going to tomorrow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have a date, it's common to need to apply math to that date. For example
    maybe you want to move to tomorrow or to yesterday.
  prefs: []
  type: TYPE_NORMAL
- en: Datetimes support math operations, such as adding or subtracting to them, but
    when time is involved, it's not easy to get the exact number of seconds you need
    to add or subtract to move to the next or previous day.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, this recipe will show off an easy way to move to the next or
    previous day from any given date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shiftdate` function will allow us to move to a date by any number of days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using it is as simple as just providing the days you want to add or remove:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to go to tomorrow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to go to yesterday:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even to go into the next month:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually what we want when moving datetime is to go to the beginning of a day.
    Suppose you want to find all events that happen tomorrow out of a list of events,
    you really want to search for `day_after_tomorrow > event_time >= tomorrow` as
    you want to find all events that happened from tomorrow at midnight up to the
    day after tomorrow at midnight.
  prefs: []
  type: TYPE_NORMAL
- en: So, simply changing the day itself won't work, because our datetime also has
    a time associated with it. If we just add a day to the date, we will actually
    end up being somewhere in the range of hours that are included in tomorrow.
  prefs: []
  type: TYPE_NORMAL
- en: That's the reason why the `shiftdate` function always replaces the time of the
    provided date with midnight.
  prefs: []
  type: TYPE_NORMAL
- en: Once the date has been moved to midnight, we just add to it a `timedelta` equal
    to the number of specified days. If this number is negative, we will just move
    back in time as `D + -1 == D -1`.
  prefs: []
  type: TYPE_NORMAL
- en: Going to next month
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another frequent need when moving dates is to be able to move the date to the
    next or previous month.
  prefs: []
  type: TYPE_NORMAL
- en: If you read the *Going to tomorrow* recipe, you will see many similarities with
    this recipe even though there are some additional changes that are required when
    working with months that are not needed when working with days, as months have
    a variable duration.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shiftmonth` function will allow us to move our date back and forth by
    any number of months:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Using it is as simple as just providing the months you want to add or remove:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it to go to the next month:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Or back to the previous month:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even to move by any number of months:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you tried to compare this recipe with the *Going to tomorrow* one, you would
    notice that this one got far more complex even though its purpose is very similar.
  prefs: []
  type: TYPE_NORMAL
- en: Just as when moving across days we are interested in moving at a specific point
    in time during the day (usually the beginning), when moving months, we don't want
    to end up being in a random day and time in the new month.
  prefs: []
  type: TYPE_NORMAL
- en: 'That explains the last part of our recipe, where for any datetime resulting
    from our math expression, we reset the time to midnight of the first day of the
    month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Like for the days recipe, this allows us to check for conditions, such as `two_month_from_now
    > event_date >= next_month`, as we will catch all events from midnight of the
    first day up to 23:59 of the last day.
  prefs: []
  type: TYPE_NORMAL
- en: The part you might be wondering about is the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Differently from when we have to move by days (which all have an equal duration
    of 24 hours), when moving by months, we need to account for the fact that each
    of them will have a different duration.
  prefs: []
  type: TYPE_NORMAL
- en: This is why, when moving forward, we set the current date to be the 5^(th) of
    the month and then we add 28 days. Adding 28 days by itself wouldn't suffice as
    it would only work for February, and if you are wondering, adding 31 days won't
    work either, because in the case of February, you would be moving by two months
    instead of just one.
  prefs: []
  type: TYPE_NORMAL
- en: That is why we set the current date to be the 5^(th) of the month because we
    want to pick a day from which we know for sure that adding 28 days to it will
    move us into the next month.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, picking the 1^(st) of the month would work, because March 1^(st)
    + 28 days = March 29^(th), so we would still be in March. While March 5^(th) +
    28 days = April 2^(nd), April 5^(th) + 28 days = May 3^(rd), and Feb 5^(th) +
    28 days = March 5^(th). So for any given month, we are always moving into the
    the next one when adding 28 days to the 5^(th).
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we always move on to a different day won't really matter as that
    day will always be replaced with the 1^(st) of the month.
  prefs: []
  type: TYPE_NORMAL
- en: As there isn't any fixed amount of days we can move that ensure we always move
    exactly into the next month, we can't move just by adding `days * months`, so
    we have to do this in a `for` loop and continuously move into the next month a
    `months` number of times.
  prefs: []
  type: TYPE_NORMAL
- en: When moving back, things get far easier. As all months begin with the first
    of the month, we can just move there and then subtract one day. We will always
    end up being on the last day of the previous month.
  prefs: []
  type: TYPE_NORMAL
- en: Weekdays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a date for the 20^(th) of the month or for the 3^(rd) week of the month
    is pretty straightforward, but what if you have to build the date for the 3^(rd)
    Monday of the month?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go through these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To approach this problem, we are going to actually generate all the month days
    that match the requested weekday:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, once we have a list of those, grabbing the *n^(th)* day is just a matter
    of indexing the resulting list. For example, to grab the Mondays from March:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So grabbing the 3^(rd) Monday of March would be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the recipe, we create a date for the first day of the requested
    month. Then we just move forward one day at a time until the month finishes and
    we set aside all days that match the requested weekday.
  prefs: []
  type: TYPE_NORMAL
- en: The weekdays go from one for Monday to seven for Sunday.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all the Mondays, Fridays, or whatever days of the month, we can
    just index the resulting list to grab only the ones we are actually interested
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Workdays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many management applications, you only have to consider workdays, and Saturdays
    and Sundays won't matter. You are not working during those days, so from a work
    point of view, they don't exist.
  prefs: []
  type: TYPE_NORMAL
- en: So when computing days included in a given timespan for a project management
    or work-related application, you can ignore those days.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to grab the list of days between two dates as far as they are working
    days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if it''s March 22^(nd), 2018, which is a Thursday, and I want
    to know the working days up to the next Monday (which is March 26^(th)), I can
    easily ask for `workdays`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So we know that two days are left: Thursday itself and Friday.'
  prefs: []
  type: TYPE_NORMAL
- en: In case you are in a part of the world where you work on Sunday and maybe don't
    on Fridays, the `excluded` argument can be used to signal which days should be
    excluded from working days.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe is pretty straightforward, we just start from the provided date (`d`),
    add one day at a time and loop until we reach `end`.
  prefs: []
  type: TYPE_NORMAL
- en: We consider the provided arguments to be datetimes, thus we loop comparing only
    the date, as we don't want to randomly include and exclude the last day depending
    on times provided in `d` and `end`.
  prefs: []
  type: TYPE_NORMAL
- en: This allows `datetime.datetime.utcnow()` to provide us with the first argument
    without having to care about when the function was called. Only the dates themselves
    will be compared, without their times.
  prefs: []
  type: TYPE_NORMAL
- en: Combining dates and times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you will have separated dates and times. This is particularly frequent
    when they are entered by a user. From an interaction point of view, it's usually
    easier to pick a date and then pick a time than to pick a date and a time together.
    Or you might be combining inputs from two different sources.
  prefs: []
  type: TYPE_NORMAL
- en: In all those cases, you will end up with a date and a time that you want to
    combine in a single `datetime.datetime` instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python standard library provides support for such operations out of the
    box, so having any two of those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily combine them into a single entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your `time` instance has a time zone (`tzinfo`), combining the date with
    the time will also preserve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If your time doesn''t have a time zone, you can still specify one when combining
    the two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Providing a time zone when combining is only supported for Python 3.6+. If you
    are working with a previous Python version, you will have to set the time zone
    into the time value.
  prefs: []
  type: TYPE_NORMAL
