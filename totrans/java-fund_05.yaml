- en: '*Chapter 5*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OOP in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this lesson, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement interfaces in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform typecasting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the `Object` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with abstract classes and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous lesson, we looked at the basics of object-oriented programming,
    such as classes and objects, inheritance, polymorphism, and overloading.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how classes act as a blueprint from which we can create objects, and
    saw how methods define the behavior of a class while fields hold the state.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how a class can acquire properties from another class through inheritance
    to enable us to reuse code. Then, we learned how we can reuse a method name through
    overloading – that is, as long as they have different signatures. Finally, we
    had a look at how subclasses can redefine their own unique behavior by overriding
    methods from the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: In this lesson, we will delve deeper into the principles of object-oriented
    programming and how to better structure our Java programs.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with interfaces, which are constructs that allow us to define
    a generic behavior that any class can implement. We will then learn about a concept
    called **typecasting**, whereby we can change a variable from one type to another
    and back. In the same manner, we will deal with primitive data types as objects
    by using wrapper classes that are provided by Java. We will finish off with a
    detailed look at abstract classes and methods, which is a way to let users who
    are inheriting your class to run their own unique implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In this lesson, we will walk through three activities by using the `Animal`
    class we created in the previous lesson. We will also be using our `Person` class
    to demonstrate some of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, you can use interfaces to provide a set of methods that classes must
    implement for them to be conformant.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the example of our `Person` class. We want to define a set of actions
    that define the behavior of any person, regardless of their age or gender.
  prefs: []
  type: TYPE_NORMAL
- en: A few examples of these actions include sleeping, breathing, and moving/walking.
    We can place all of these common actions in an interface and let any class that
    claims to be a person implement them. A class that implements this interface is
    often referred to as being of the type `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we use the keyword interface to denote that the following block will
    be an interface. All the methods in an interface are empty and are not implemented.
    This is because any class that will implement this interface will provide its
    unique implementation details. Therefore, an interface is essentially a group
    of methods with no bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an interface to define the behavior of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface is called `PersonBehavior` and it contains three methods: one
    to breathe, another one to sleep, and one to walk at a given speed. Every class
    that implements this interface will have to also implement these three methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `implements` keyword after a class name, followed by the interface
    name, when we want to implement a given interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this with an example. We will create a new class called `Doctor`
    to represent doctors. This class will implement the `PersonBehavior` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we have stated that we want to conform to the `PersonBehavior` interface,
    the compiler will give us an error if we don''t implement the three methods in
    the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use the `@Override` annotation to indicate that this method is from the interface.
    Inside these methods, we are free to perform any kind of operations that are relevant
    to our `Doctor` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same spirit, we can also create an `Engineer` class that implements
    the same interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In *Lesson 1*, *Introduction to Java*, we mentioned abstraction as one of the
    underlying principles of OOP. Abstraction is a way for us to provide a consistent
    interface to our classes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use a mobile phone as an example. With a mobile phone, you are able to
    call and text your friends. When calling, you press the call button and immediately
    get connected to a friend. That call button forms an interface between you and
    your friend. We don't really know what happens when we press the button because
    all those details are abstracted (hidden) from us.
  prefs: []
  type: TYPE_NORMAL
- en: You will often hear the term **API**, which stands for Application Programming
    Interface. It is a way for different software to speak to each other in harmony.
    An example is when you want to log in to an app using Facebook or Google. The
    application will call the Facebook or Google API. The Facebook API will then define
    the rules to be followed to log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class in Java can implement more than one interface. These extra interfaces
    are separated by a comma. The class must provide implementations for all the methods
    it promises to implement in the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use Case: Listeners'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important uses of interfaces is creating listeners for conditions
    or events in your programs. Basically, a listener notifies you of any state changes
    when an action takes place. Listeners are also called callbacks – a term that
    stems from procedural languages.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an event listener could be called when a button is clicked or hovered
    over.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of event-driven programming is popular for making Android apps using
    Java.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we want to know when a person walks or sleeps so that we can perform
    some other actions. We can achieve this by using an interface that listens for
    such events. We will look at this in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13: Implementing Interfaces'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to create an interface called `PersonListener` that listens for
    two events: `onPersonWalking` and `onPersonSleeping`. When the `walk(int speed)`
    method is called, we will dispatch the `onPersonWalking` event, and when `sleep()`
    is called, `onPersonSleeping` will be called:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface called `PersonListener` and paste the following code inside
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Open our `Doctor` class and add the `PersonListener` interface after the `PersonBehavior`
    interface, separated by a comma:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the two methods in our `PersonListener` interface. When the doctor
    walks, we will perform some actions and raise the `onPersonWalking` event to let
    other listeners know that the doctor is walking. When the doctor sleeps, we shall
    raise the `onPersonSleeping` event. Modify the `walk()` and `sleep()` methods
    to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the main method to test our code by calling `walk()` and `sleep()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `Doctor` class and see the output in the console. You should see something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1: Output of the Doctor class](img/C09581_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Output of the Doctor class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The full `Doctor` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since a class can implement more than one interface, we can use interfaces in
    Java to simulate multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16: Creating and Implementing Interfaces in Java'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scenario: In our animal farm from the previous lesson, we wish to have common
    actions that all animals must possess, regardless of their type. We want to also
    know when an animal has moved or made any sound. A movement can help us keep track
    of where each animal is and the sound can be indicative of distress.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective: We are going to implement two interfaces: one that holds two actions
    that all animals must possess, `move()` and `makeSound()`, and the other that
    listens for movement and sound from the animals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aim: To understand how to create interfaces in Java and implement them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your `Animals` project from the previous lesson.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new interface called `AnimalBehavior`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this, create two methods: `void move()` and `void makeSound()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another interface called `AnimalListener` with `onAnimalMoved()` and
    `onAnimalSound()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new public class called `Cow` and implement the `AnimalBehavior` and
    `AnimalListener` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create instance variable sound and `movementType` in `Cow` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `move()` such that the `movementType` is "Walking" and the `onAnimalMoved()`
    method is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `makeSound()` such that `movementType` is "Moo" and the `onAnimalMoved()`
    method is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `onAnimalMoved()` and `inAnimalMadeSound()` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `main()` to test the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 323.
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen how, when we write `int a = 10`, `a` is of integer data
    type, which is usually 32 bits in size. When we write `char c = 'a'`, `c` has
    a data type of character. These data types were referred to as primitive types
    because they can be used to hold simple information.
  prefs: []
  type: TYPE_NORMAL
- en: Objects also have types. The type of an object is often the class of that object.
    For example, when we create an object such as `Doctor myDoctor = new Doctor()`,
    the `myDoctor` object is of type `Doctor`. The `myDoctor` variable is often referred
    to as a reference type. As we discussed earlier, this is because the `myDoctor`
    variable doesn't hold the object itself. Rather, it holds the reference to the
    object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Typecasting is a way for us to change the class or interface from one type to
    another. It's important to note that only classes or interfaces (together, these
    are called types) that belong to the same superclass or implement the same interface,
    that is, they have a parent-child relationship, can be cast or converted into
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `Person` example. We created the `Student` class, which
    inherits from this class. This essentially means that the `Student` class is in
    the `Person` family and so is any other class that inherits from the `Person`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Inheriting the subclass from the base class](img/C09581_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Inheriting the subclass from the base class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We typecast in Java by using brackets before the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have created an object of type `Student` called `student`.
    We then typecast it to a `Person` by using the `(Person)student` statement. This
    statement labels s`tudent` as a `Person` type instead of `Student` type. This
    type of typecasting, where we label the subclass as a superclass, is called upcasting.
    This operation doesn't change the original object; it only labels it as a different
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting reduces the number of methods we have access to. For example, the
    `student` variable cannot access the methods and fields in the `Student` class
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'We convert `student` back to the `Student` type by performing downcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Downcasting is the conversion of a superclass type into a subclass type. This
    operation gives us access to the methods and fields in the subclass. For example,
    `newStudent` now has access to all the methods in the `Student` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For downcasting to work, the object must have originally been of the subclass
    type. For example, the following operation is not possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to run this program, you will get the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Exception message while downcasting](img/C09581_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Exception message while downcasting'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is because `person` was not originally a `Lecturer` type, but rather a
    `Student` type. We will talk more about exceptions in the upcoming lessons.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid such kinds of exceptions, you can use the `instanceof` operator to
    first check whether an object is of a given type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `instanceof` operator returns `true` if `person` was originally of type
    `Lecturer`, or returns false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 17: Using instanceof and Typecasting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On previous activity, you used interface to declare common methods around salary
    and tax on the Employee interface. With the expansion of JavaWorks limited, sales-people
    started to get commission. That means that now, you''ll need to write a new class:
    `SalesWithCommission`. This class will extends from `Sales`, which means it has
    all the behavior that employees have but will also have an additional method:
    `getCommission`. This new method returns the gross sales of this employee (which
    will be passed in the constructor) times the sales commission, which is 15% for
    all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this activity, you''ll also write a class that has a method that
    generates employees. This will serve as the `datasource` for this and other activities.
    This `EmployeeLoader` class will have one method: `getEmployee()`, which returns
    an Employee. Inside this method, you can use any means to return a newly generated
    employee. Using the `java.util.Random` class might help you to accomplish this
    and still get consistency if you need it.'
  prefs: []
  type: TYPE_NORMAL
- en: With your data source and the new `SalesWithCommission`, you'll write an application
    that will call the `EmployeeLoader.getEmployee` method a few times using a `for`
    loop. With each generated employee, it will print their net salary and the tax
    they pay. It will also check if the employee is an instance of `SalesWithCommission`,
    cast it and print his commission.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity you''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `SalesWithCommission` class that extends `Sales`. Add a constructor
    that receives the gross sales as double and store it as a field. Also add a method
    called `getCommission` which returns a double that is the gross sales times 15%
    (0.15).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create another class that will work as a data source, generating employees.
    This class has one method `getEmployee()` that will create an instance of one
    of the implementations of Employee and return it. The method return type should
    be Employee.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an application that calls `getEmployee()` repeatedly inside a `for` loop
    and print the information about the Employee salary and tax. And if the employee
    is an instance of `SalesWithCommission`, also print his commission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 325.
  prefs: []
  type: TYPE_NORMAL
- en: The Object Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Java provides a special class called `Object`, from which all classes implicitly
    inherit. You don''t have to manually inherit from this class because the compiler
    does that for you. `Object` is the superclass of all classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C09581_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Superclass Object'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This means that any class in Java can be upcast to `Object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, you can downcast to the original class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can use this `Object` class when you want to pass around objects whose type
    you don't know. It's also used when the JVM wants to perform garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Autoboxing and Unboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we need to deal with primitive types in methods that only accept
    objects. A good example of this is when we want to store integers in an ArrayList
    (which we will discuss later). This class, `ArrayList`, only accepts objects,
    and not primitives. Fortunately, Java provides all primitive types as classes.
    Wrapper classes can hold primitive values and we can manipulate them as if they
    were normal classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `Integer` class, which can hold an `int` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also skip the `new` keyword and the compiler will implicitly wrap it
    for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can then use the object as if it was any other object. We can upcast it to
    `Object` and then downcast it back to an `Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: This operation of converting a primitive type into an object (reference type)
    is referred to as autoboxing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also convert the object back into a primitive type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `b` primitive is assigned the value of `a`, which is 1\. This operation
    of converting a reference type back to a primitive is called unboxing. The compiler
    performs autoboxing and unboxing automatically for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `Integer`, Java also provides the following wrapper classes
    for the following primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C09581_Table_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Table 5.1: Table representing the wrapper classes for primitives'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Activity 18: Understanding Typecasting in Java'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scenario: Let''s understand typecasting concepts using our `Animal` classes
    we have been working with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective: We are going to create a test class for our `Animal` class, and
    upcast and downcast the `Cow` and `Cat` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aim: Internalize the concepts of typecasting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Animals` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class called `AnimalTest` and, inside it, create the `main` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` method create an object of the `Cat` and `Cow` classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the owner of the `Cat` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upcast the object of `Cat` class to `Animal` and try to print the owner once
    more. Notice the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the sound of the object of `Cow` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upcast the object of `Cow` class to `Animal` and try to print the owner once
    more. Notice the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downcast the object of Animal class to the new object of `Cat` class and print
    the owner again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8:  Output of the AnimalTest class](img/C09581_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Output of the AnimalTest class'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 327.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Classes and Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we discussed interfaces and how they can be useful when we wish to
    have a contract with our classes on the methods they have to implement. We then
    saw how we can only cast classes that share the same hierarchy tree.
  prefs: []
  type: TYPE_NORMAL
- en: Java also allows us to have classes with abstract methods that all classes inheriting
    from it must implement. Such a class is referred to as an `abstract` keyword after
    the access modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we declare a class as `abstract`, any class inheriting from it must implement
    the `abstract` methods in it. We cannot instantiate abstract classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because `abstract` classes are still classes in the first place, they can have
    a logic and state of their own. This gives them more advantages compared to interfaces
    whose methods are empty. In addition, once we inherit from an `abstract` class,
    we can perform typecasting along that class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Java also allows us to have `abstract` method must also be declared as `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `abstract` keyword after the access modifier to declare a method
    `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we inherit from an `abstract` class, we have to implement all the `abstract`
    methods in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 19: Implementing Abstract Classes and Methods in Java'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Scenario: Imagine that you have been tasked by the local hospital to build
    a piece of software to manage the different types of people who use the facility.
    You have to find a way to represent the doctors, nurses, and patients.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective: We are going to create three classes: one that''s abstract, to represent
    any person, another one to represent the doctor, and finally, one to represent
    the patient. All of the classes are going to inherit from the abstract person
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aim: To understand these concepts of `abstract` classes and methods in Java.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Hospital` and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `src` folder, create an abstract class called `Person`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `abstract` method that returns the type of person in the hospital.
    Name this method String `getPersonType()`, returning a String:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have finished our `abstract` class and method. Now, we will continue to inherit
    from it and implement this `abstract` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class called `Doctor` that inherits from the `Person` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `getPersonType` abstract method in our `Doctor` class. Return
    the "`Arzt`" string. This is German for doctor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create another class called `Patient` to represent the patients in the hospital.
    Similarly, make sure that the class inherits from `Person` and overrides the `getPersonType`
    method. Return "`Kranke`". This is German for patient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now we have two classes, we will test our code using a third test class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a third class called `HospitalTest`. We will use this class to test the
    two classes we created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `HospitalTest` class, create the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `main` method, create an instance of `Doctor` and another instance
    of `Patient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Try calling the `getPersonType` method for each of the objects and print it
    out to the console. What is the output?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C09581_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Output on calling getPersonType()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 329.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 20: Use abstract class to Encapsulate Common Logic'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaWorks keeps growing. Now that they have many employees, they noticed that
    salary variation is not supported for the application you've built before. So
    far every Engineer had to have the same salary as all others. Same with Managers,
    Sales and Sales with commission people. To solve that, you're going to use an
    abstract class that encapsulates the logic to calculate net salary, based on the
    tax. For that to work, the abstract class will have a constructor that receives
    the gross salary. It will not implement the `getTax()` method, delegating that
    to the subclasses. With new subclasses for the generic employees that receive
    the gross salary as an argument for the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: You'll also add a new method to the `EmployeeLoader`, `getEmployeeWithSalary()`,
    that will generate a new generic employee with a randomly generated gross salary.
  prefs: []
  type: TYPE_NORMAL
- en: And last, on your application, you'll do just like you did before, print the
    salary information and tax, and if the employee is an instance of `GenericSalesWithCommission`,
    also print his commission.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity, you''ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an abstract class `GenericEmployee` that has a constructor that receives
    the gross salary and stores that in a field. It should implement the Employee
    interface and have two methods: `getGrossSalary()` and `getNetSalary()`. The first
    will just return the value passed into the constructor. The latter will return
    the gross salary minus the result of calling `getTax()` method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new generic version of each type of employee: `GenericEngineer`, `GenericManager`,
    `GenericSales`, and `GenericSalesWithCommission`. They all need a constructor
    that receives gross salary and pass it to the super constructor. They also need
    to implement the `getTax()` method, returning the correct tax value for each class.
    Remember to also receive the gross sales on the `GenericSalesWithCommission` class,
    and add the method that calculates the commission.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new method `getEmployeeWithSalary` to your `EmployeeLoader` class. This
    method will generate a random salary between 70,000 and 120,000 and assign to
    the newly created employee before returning it. Remember to also provide a gross
    sales when creating a `GenericSalesWithCommission` employee.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write an application that calls the `getEmployeeWithSalary` method multiple
    times from inside a `for` loop. This method will work like the one in the previous
    activity: print the net salary and tax for all employees. If the employee is an
    instance of `GenericSalesWithCommission` also print his commission.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 331.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this lesson, we have learned that interfaces are a way for us to define a
    set of methods that all classes implementing them must provide specific implementations
    for. Interfaces can be used to implement events and listeners in your code when
    a specific action occurs.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned that typecasting is a way for us to change a variable of one
    type to another type, as long as they are on the same hierarchy tree or implement
    a common interface.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the use of the `instanceof` operator and the `Object` class
    in Java, and learned the concepts of autoboxing, unboxing, abstract classes, and
    abstract methods in Java.
  prefs: []
  type: TYPE_NORMAL
- en: In the next lesson, we will look at a few common classes and data structures
    that come with Java.
  prefs: []
  type: TYPE_NORMAL
