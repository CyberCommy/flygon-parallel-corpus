- en: Chapter 6. Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you write JavaScript applications, you will soon realize that having a sound
    testing strategy is indispensable. In fact, not writing enough tests is almost
    always a bad idea. It is essential to cover all the non-trivial functionality
    of your code to make sure of the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The existing code behaves as per the specifications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new code does not break the behavior defined by the specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these points are very important. Many engineers consider only the first
    point the sole reason to cover your code with enough tests. The most obvious advantage
    of test coverage is to really make sure that the code being pushed to the production
    system is mostly error-free. Writing test cases to smartly cover the maximum functional
    areas of the code generally gives you a good indication about the overall quality
    of the code. There should be no arguments or compromises around this point. It
    is unfortunate though that many production systems are still bereft of adequate
    code coverage. It is very important to build an engineering culture where developers
    think about writing tests as much as they think about writing code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The second point is even more important. Legacy systems are usually very difficult
    to manage. When you are working on code written either by someone else or a large
    distributed team, it is fairly easy to introduce bugs and break things. Even the
    best engineers make mistakes. When you are working on a large code base that you
    are unfamiliar with and if there is no sound test coverage to help you, you will
    introduce bugs. As you won't have the confidence in the changes that you are making
    (because there are no test cases to confirm your changes), your code releases
    will be shaky, slow, and obviously full of hidden bugs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: You will refrain from refactoring or optimizing your code because you won't
    really be sure what changes to the code base would potentially break something
    (again, because there are no test cases to confirm your changes)—all this is a
    vicious circle. It's like a civil engineer saying, "though I have constructed
    this bridge, I have no confidence in the quality of the construction. It may collapse
    immediately or never." Though this may sound like an exaggeration, I have seen
    a lot of high impact production code being pushed with no test coverage. This
    is risky and should be avoided. When you are writing enough test cases to cover
    majority of your functional code and when you make a change to these pieces, you
    immediately realize if there is a problem with this new change. If your changes
    make the test case fail, you realize the problem. If your refactoring breaks the
    test scenario, you realize the problem—all this happens much before the code is
    pushed to production.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, ideas such as test-driven development and self-testing code
    are gaining prominence, especially in **agile methodology**. These are fundamentally
    sound ideas and will help you write robust code—code that you are confident of.
    We will discuss all these ideas in this chapter. You will understand how to write
    good test cases in modern JavaScript. We will also look at several tools and methods
    to debug your code. JavaScript has been traditionally a bit difficult to test
    and debug primarily due to lack of tools, but modern tools make both of these
    easy and natural.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about test cases, we mostly mean **unit tests**. It is incorrect
    to assume that the unit that we want to test is always a function. The unit (or
    unit of work) is a logical unit that constitutes a single behavior. This unit
    should be able to be invoked via a public interface and should be testable independently.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, a unit test performs the following functions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: It tests a single logical function
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be run without a specific order of execution
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes care of its own dependencies and mock data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It always returns the same result for the same input
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be self-explanatory, maintainable, and readable
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该是自解释的、可维护的和可读的
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Martin Fowler advocates the **test pyramid** ([http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html))
    strategy to make sure that we have a high number of unit tests to ensure maximum
    code coverage. The test pyramid says that you should write many more low-level
    unit tests than higher level integration and UI tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Martin Fowler提倡**测试金字塔**（[http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html)）策略，以确保我们有大量的单元测试来确保最大的代码覆盖率。测试金字塔表示您应该编写比高级集成和UI测试更多的低级单元测试。
- en: There are two important testing strategies that we will discuss in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两种重要的测试策略。
- en: Test-driven development
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-driven** **development** (**TDD**) has gained a lot of prominence in
    the last few years. The concept was first proposed as part of the **Extreme Programming**
    methodology. The idea is to have short repetitive development cycles where the
    focus is on writing the test cases first. The cycle looks as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）在过去几年中获得了很大的关注。这个概念最初是作为**极限编程**方法论的一部分提出的。其思想是有短的重复开发周期，重点是先编写测试用例。循环如下：'
- en: Add a test case as per the specifications for a specific unit of code.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据特定代码单元的规范添加一个测试用例。
- en: Run the existing suite of test cases to see if the new test case that you wrote
    fails—it should (because there is no code for this unit yet). This step ensures
    that the current test harness works well.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行现有的测试套件，看看您编写的新测试用例是否失败——应该失败（因为此单元尚无代码）。此步骤确保当前的测试工具很好地工作。
- en: Write the code that serves mainly to confirm the test case. This code is not
    optimized or refactored or even entirely correct. However, this is fine at the
    moment.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写主要用于确认测试用例的代码。这段代码并不是优化的、重构的，甚至完全正确。但是，目前这样做是可以的。
- en: Rerun the tests and see if all the test cases pass. After this step, you will
    be confident that the new code is not breaking anything.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行测试，看看所有测试用例是否通过。经过这一步，您将对新代码不会破坏任何东西感到自信。
- en: Refactor the code to make sure that you are optimizing the unit and handling
    all corner cases.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构代码以确保你正在优化单元并处理所有边缘情况。
- en: These steps are repeated for all the new code that you add. This is an elegant
    strategy that works really well for the agile methodology. TDD will be successful
    only if the testable units of code are small and confirm only to the test case
    and nothing more. It is important to write small, modular, and precise code units
    that have input and output confirming the test case.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤对您添加的所有新代码都是重复的。这是一种对敏捷方法论非常有效的优雅策略。只有当可测试的代码单元很小并且仅符合测试用例而不多时，TDD才会成功。编写小型、模块化和精确的代码单元非常重要，这些代码单元具有输入和输出，以确认测试用例。
- en: Behavior-driven development
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为驱动开发
- en: A very common problem while trying to follow TDD is vocabulary and the definition
    of *correctness*. BDD tries to introduce a *ubiquitous language* while writing
    the test cases when you are following TDD. This language makes sure that both
    the business and engineering teams are talking about the same thing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试遵循TDD时，一个非常常见的问题是词汇和*正确性*的定义。BDD试图在遵循TDD时引入*普遍语言*。这种语言确保业务团队和工程团队都在讨论同一件事情。
- en: We will use **Jasmine** as the primary BDD framework and explore various testing
    strategies.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Jasmine**作为主要的BDD框架，并探索各种测试策略。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can install Jasmine by downloading the standalone package from [https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip](https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从[https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip](https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip)下载独立软件包来安装Jasmine。
- en: 'When you unzip this package, you will have the following directory structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您解压此软件包时，您将拥有以下目录结构：
- en: '![Behavior-driven development](img/00011.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![行为驱动开发](img/00011.jpeg)'
- en: 'The `lib` directory contains the JavaScript files that you need in your project
    to start writing Jasmine test cases. If you open `SpecRunner.html`, you will find
    the following JavaScript files included in it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib`目录包含您在项目中需要的JavaScript文件，以开始编写Jasmine测试用例。如果您打开`SpecRunner.html`，您将在其中找到以下包含的JavaScript文件：'
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three are Jasmine's own framework files. The next section includes
    the source files that we want to test and the actual test specifications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个是Jasmine自己的框架文件。接下来的部分包括我们要测试的源文件和实际的测试规范。
- en: 'Let''s experiment with Jasmine with a very ordinary example. Create a `bigfatjavascriptcode.js`
    file and place it in the `src/` directory. We will test the following function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常普通的例子来尝试Jasmine。创建一个`bigfatjavascriptcode.js`文件，并将其放在`src/`目录中。我们将测试以下函数：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple function that does one single thing. It receives a string and
    returns a capitalized string. We will test various scenarios around this function.
    This is the unit of code that we discussed earlier.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只做一件事情的简单函数。它接收一个字符串并返回一个大写字符串。我们将围绕这个函数测试各种场景。这是我们之前讨论过的代码单元。
- en: 'Next, create the test specifications. Create one JavaScript file, `test.spec.js`,
    and place it in the `spec/` directory. The file should contain the following.
    You will need to add the following two lines to `SpecRunner.html`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建测试规范。创建一个JavaScript文件`test.spec.js`，并将其放在`spec/`目录中。该文件应包含以下内容。您需要将以下两行添加到`SpecRunner.html`中：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The order of this inclusion does not matter. When we run `SpecRunner.html`,
    you will see something as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种包含的顺序并不重要。当我们运行`SpecRunner.html`时，您将看到以下内容：
- en: '![Behavior-driven development](img/00012.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![行为驱动开发](img/00012.jpeg)'
- en: 'This is the Jasmine report that shows the details about the number of tests
    that were executed and the count of failures and successes. Now, let''s make the
    test case fail. We want to test a case where an undefined variable is passed to
    the function. Add one more test case as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when you run `SpecRunner.html`, you will see the following result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-driven development](img/00013.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the failure is displayed for this test case in a detailed error
    stack. Now, we go about fixing this. In your original JavaScript code, we can
    handle an undefined condition as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this change, your test case will pass and you will see the following in
    the Jasmine report:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior-driven development](img/00014.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: This is very similar to what a test-driven development would look. You write
    test cases, you then fill in the necessary code to confirm to the specifications,
    and rerun the test suite. Let's understand the structure of the Jasmine tests.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test specification looks as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `describe("TestStringUtilities"` is a test suite. The name of the test
    suite should describe the unit of code that we are testing—this can be a function
    or group of related functionality. In the specifications, you call the global
    Jasmine `it` function to which you pass the title of the specification and test
    function used by the test case. This function is the actual test case. You can
    catch one or more assertions or the general expectations using the `expect` function.
    When all expectations are `true`, your specification is passed. You can write
    any valid JavaScript code in the `describe` and `it` functions. The values that
    you verify as part of the expectations are matched using a matcher. In our example,
    `toEqual()` is the matcher that matches two values for equality. Jasmine contains
    a rich set of matches to suit most of the common use cases. Some common matchers
    supported by Jasmine are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`toBe()`: This matcher checks whether two objects being compared are equal.
    This is the same as the `===` comparison, as shown in the following code:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`not`: You can negate a matcher with a `not` prefix. For example, `expect(1).not.toEqual(2);`
    will negate the match made by `toEqual()`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toContain()`: This checks whether an element is part of an array. This is
    not an exact object match as `toBe()`. For example, look at the following code:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`toBeDefined()` and `toBeUndefined()`: These two matches are handy to check
    whether a variable is undefined (or not).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toBeNull()`: This checks whether a variable''s value is `null`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toBeGreaterThan()` and `toBeLessThan()`: These matchers perform numeric comparisons
    (they work on strings too):'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One interesting feature of Jasmine is the **spies**. When you are writing a
    large system, it is not possible to make sure that all systems are always available
    and correct. At the same time, you don''t want your unit tests to fail due to
    a dependency that may be broken or unavailable. To simulate a situation where
    all dependencies are available for a unit of code that we want to test, we mock
    these dependencies to always give the response that we expect. Mocking is an important
    aspect of testing and most testing frameworks provide support for the mocking.
    Jasmine allows mocking using a feature called a spy. Jasmine spies essentially
    stub the functions that we may not have ready; at the time of writing the test
    case but as part of the functionality, we need to track that we are executing
    these dependencies and not ignoring them. Consider the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, while we are writing this test case, we either don't have the
    real implementation of the `configurator.submitPOSTRequest()` dependency or someone
    is fixing this particular dependency. In any case, we don't have it available.
    For our test to work, we need to mock it. Jasmine spies allow us to replace a
    function with its mock and track its execution.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we need to ensure that we called the dependency. When the actual
    dependency is ready, we will revisit this test case to make sure that it fits
    the specifications, but at this time, all that we need to ensure is that the dependency
    is called. The Jasmine `tohaveBeenCalled()` function lets us track the execution
    of a function, which may be a mock. We can use `toHaveBeenCalledWith()` that allows
    us to determine if the stub function was called with the correct parameters. There
    are several other interesting scenarios that you can create using Jasmine spies.
    The scope of this chapter won't permit us to cover them all, but I would encourage
    you to discover these areas on your own.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can refer to the user manual for Jasmine for more information on Jasmine
    spies at [http://jasmine.github.io/2.0/introduction.html](http://jasmine.github.io/2.0/introduction.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Mocha, Chai, and Sinon**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Though Jasmine is the most prominent JavaScript testing framework, **Mocha**
    and **Chai** are gaining prominence in the Node.js environment. Mocha is the testing
    framework used to describe and run test cases. Chai is the assertion library supported
    by Mocha. **Sinon.JS** comes in handy while creating mocks and stubs for your
    tests. We won't discuss these frameworks in this module, but experience on Jasmine
    will be handy if you want to experiment with these frameworks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript debugging
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not a completely new programmer, I am sure you must have spent some
    amount of time debugging your or someone else's code. Debugging is almost like
    an art form. Every language has different methods and challenges around debugging.
    JavaScript has traditionally been a difficult language to debug. I have personally
    spent days and nights of misery trying to debug badly-written JavaScript code
    using `alert()` functions. Fortunately, modern browsers such as Mozilla Firefox
    and Google Chrome have excellent developer tools to help debug JavaScript in the
    browser. There are IDEs like **IntelliJ WebStorm** with great debugging support
    for JavaScript and Node.js. In this chapter, we will focus primarily on Google
    Chrome's built-in developer tool. Firefox also supports the Firebug extension
    and has excellent built-in developer tools, but as they behave more or less the
    same as Google Chrome's **Developer Tools** (**DevTools**), we will discuss common
    debugging approaches that work in both of these tools.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Before we talk about the specific debugging techniques, let's understand the
    type of errors that we would be interested in while we try to debug our code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When your code has something that does not confirm to the JavaScript language
    grammar, the interpreter rejects this piece of code. These are easy to catch if
    your IDE is helping you with syntax checking. Most modern IDEs help with these
    errors. Earlier, we discussed the usefulness of the tools such as **JSLint** and
    **JSHint** around catching syntax issues with your code. They analyze the code
    and flag errors in the syntax. JSHint output can be very illuminating. For example,
    the following output shows up so many things that we can change in the code. This
    snippet is from one of my existing projects:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using strict
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly discussed the **strict** mode in earlier chapters. The strict mode
    in JavaScript flags or eliminates some of the JavaScript silent errors. Rather
    than silently failing, the strict mode makes these failures throw errors instead.
    The strict mode also helps in converting mistakes to actual errors. There are
    two ways of enforcing the strict mode. If you want the strict mode for the entire
    script, you can just add the `use strict` statement as the first line of your
    JavaScript program. If you want a specific function to conform with the strict
    mode, you can add the directive as the first line of a function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Runtime exceptions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These errors appear when you execute the code and try to refer to an undefined
    variable or process a null. When a runtime exception occurs, any code after that
    particular line (which caused the exception) does not get executed. It is essential
    to handle such exceptional scenarios correctly in the code. While exception handling
    can help prevent crashes, they also aid in debugging. You can wrap the code that
    *may* encounter a runtime exception in a `try{ }` block. When any code in this
    block generates a runtime exception, a corresponding handler captures it. The
    handler is defined by a `catch(exception){}` block. Let''s clarify this using
    an example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, the `var a = doesnotexist;` line tries to assign an undefined
    variable, `doesnotexist`, to another variable, `a`. This causes a runtime exception.
    When we wrap this problematic code in the `try{} catch(){}` block and when the
    exception occurs (or is thrown), the execution stops in the `try{}` block and
    goes directly to the `catch() {}` handler. The `catch` handler is responsible
    for handling the exceptional scenario. In this case, we are displaying the error
    message on the console for debugging purposes. You can explicitly throw an exception
    to trigger an unhandled scenario in the code. Consider the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we are handling valid states of a gear shift (`R`, `N`, and
    `D`), but when we receive an invalid state, we are explicitly throwing an exception
    clearly stating the reason. When we call the function that we think may throw
    an exception, we wrap the code in the `try{}` block and attach a `catch(){}` handler
    with it. When the exception is caught by the `catch()` block, we handle the exceptional
    condition appropriately.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Console.log and asserts
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Displaying the state of execution on the console can be very useful while debugging.
    However, modern developer tools allow you to put breakpoints and halt execution
    to inspect a particular value during runtime. You can quickly detect small issues
    by logging some variable state on the console.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: With these concepts, let's see how we can use Chrome Developer Tools to debug
    JavaScript code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Chrome DevTools
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can start Chrome DevTools by navigating to menu | **More tools** | **Developer
    Tools**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools](img/00015.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'Chrome DevTools opens up on the lower pane of your browser and has a bunch
    of very useful sections:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools](img/00016.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: The **Elements** panel helps you inspect and monitor the DOM tree and associated
    style sheet for each of these components.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The **Network** panel is useful to understand network activity. For example,
    you can monitor the resources being downloaded over the network in real time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important pane for us is the **Sources** pane. This pane is where
    the JavaScript source and debugger are displayed. Let''s create a sample HTML
    with the following content:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Save this HTML file and open it in Google Chrome. Open DevTools in the browser
    and you will see the following screen:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools](img/00017.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: This is the view of the **Sources** panel. You can see the HTML and embedded
    JavaScript source in this panel. You can see the **Console** window as well. You
    can see that the file is executed and output is displayed in the **Console**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right-hand side, you will see the debugger window:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools](img/00018.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'In the **Sources** panel, click on the line numbers **8** and **15** to add
    a breakpoint. The breakpoints allow you to stop the execution of the script at
    the specified point:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools](img/00019.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'In the debugging pane, you can see all the existing breakpoints:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools](img/00020.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'Now, when you rerun the same page, you will see that the execution stops at
    the debug point. One very useful technique is to inject code during the debugging
    phase. While the debugger is running, you can add code in order to help you understand
    the state of the code better:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome DevTools](img/00021.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'This window now has all the action. You can see that the execution is paused
    on line **15**. In the debug window, you can see which breakpoint is being triggered.
    You can see the **Call Stack** also. You can resume execution in several ways.
    The debug command window has a bunch of actions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口现在有了所有的操作。您可以看到执行已经暂停在第**15**行。在调试窗口中，您可以看到触发了哪个断点。您还可以看到**调用堆栈**。您可以通过多种方式恢复执行。调试命令窗口有许多操作：
- en: '![Chrome DevTools](img/00022.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome DevTools](img/00022.jpeg)'
- en: 'You can resume execution (which will execute until the next breakpoint) by
    clicking on the ![Chrome DevTools](img/00023.jpeg) button. When you do this, the
    execution continues until the next breakpoint is encountered. In our case, we
    halt at line **8**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击![Chrome DevTools](img/00023.jpeg)按钮来恢复执行（直到下一个断点）。这样做时，执行会继续，直到遇到下一个断点。在我们的情况下，我们会在第**8**行停下来。
- en: '![Chrome DevTools](img/00024.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome DevTools](img/00024.jpeg)'
- en: You can observe that the **Call Stack** window shows you how we arrived at line
    **8**. The **Scope** panel shows the **Local** scope where you can see the variables
    in the scope when the breakpoint was arrived at. You can also step into or step
    over the next function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到**调用堆栈**窗口显示了我们如何到达第**8**行。**作用域**面板显示了**本地**作用域，在那里您可以看到在到达断点时作用域中的变量。您还可以步入或跳过下一个函数。
- en: There are other very useful mechanisms to debug and profile your code using
    Chrome DevTools. I would suggest you to go experiment with the tool and make it
    a part of your regular development flow.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他非常有用的机制可以使用Chrome DevTools来调试和分析您的代码。我建议您去尝试这个工具，并将其作为您常规开发流程的一部分。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Both the testing and debugging phases are essential to developing robust JavaScript
    code. TDD and BDD are approaches closely associated with the agile methodology
    and are widely embraced by the JavaScript developer community. In this chapter,
    we reviewed the best practices around TDD and usage of Jasmine as the testing
    framework. We saw various methods of debugging JavaScript using Chrome DevTools.
    In the next chapter, we will explore the new and exciting world of ES6, DOM manipulation,
    and cross-browser strategies.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试阶段对于开发健壮的JavaScript代码至关重要。TDD和BDD是与敏捷方法学密切相关的方法，广泛受到JavaScript开发者社区的欢迎。在本章中，我们回顾了围绕TDD的最佳实践以及Jasmine作为测试框架的使用。我们看到了使用Chrome
    DevTools调试JavaScript的各种方法。在下一章中，我们将探索ES6、DOM操作和跨浏览器策略的新颖世界。
