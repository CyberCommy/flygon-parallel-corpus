- en: Chapter 6. Plugins – Building Your House with Your Own Bricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to manage the global application store
    using the Vuex architecture. You learned a lot of new concepts and applied them.
    You also learned how to create a store, how to define its state and mutations,
    and how to use actions and getters. We brought our shopping list and Pomodoro
    applications to life using the knowledge acquired during the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will revisit Vue plugins, see how they work, and how they
    must be created. We will use some existing plugins and create our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing it up, in this chapter, we are going to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the nature of Vue plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the resource plugin in the shopping lists application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a plugin that produces white, pink, and brown noises and apply it to
    our Pomodoro application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of Vue plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plugins in Vue.js are used for exactly the same purpose as they are used in
    any other scope: to add some nice functionality that, due to its nature, cannot
    be achieved with the core functionality of the system. Plugins written for Vue
    can provide various functionalities, starting from the definition of some global
    Vue methods or even the instance methods and moving toward providing some new
    directives, filters, or transitions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to use an existing plugin, you must first install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, tell Vue to use it in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create our own plugins. This is also easy. Your plugin must provide
    an `install` method where you define any global or instance methods, or custom
    directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then it can be used just like any other existing plugin. In this chapter, we
    will use the existing `resource` plugin for Vue ( [https://github.com/vuejs/vue-resource](https://github.com/vuejs/vue-resource)
    ) and create our own plugin that generates white, pink, and brown noises.
  prefs: []
  type: TYPE_NORMAL
- en: Using the vue-resource plugin in the shopping list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the shopping list application (the [chapter6/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/shopping-list)
    folder) and run `npm install` and `npm run dev`. It''s nice and clean, but it
    still uses the hardcoded list of the shopping lists. It would be really nice if
    we were able to add new shopping lists, delete them, and store the information
    on updated shopping lists so that when we restart the application, the displayed
    information corresponds to the last we saw before restarting. In order to be able
    to do that, we will use the `resource` plugin, which allows us to easily create
    REST resources and call REST methods on them. Before starting, let''s summarize
    everything that we need to do in order to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to have a simple server that contains some storage from
    where we can retrieve and where we can store our shopping lists. This server must
    provide the needed endpoints for all this functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating our server and all needed endpoints, we should install and use
    the `vue-resource` plugin to create a resource and actions that will call the
    methods on the provided endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to guarantee the data integrity, we should call actions that update
    server's state on each shopping lists update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the application start, we should fetch shopping lists from the server and
    assign them to our store's state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should also provide a mechanism to create new shopping lists and delete the
    existing ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't sound too difficult, right? Let's start then!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we will use a very basic and easy-to-use HTTP server
    that stores data inside a regular JSON file. It is called `json-server` and it
    is hosted at [https://github.com/typicode/json-server](https://github.com/typicode/json-server).
    Install it in the shopping list application''s directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `server` folder with the `db.json` file inside it with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be our database. Let''s add the script entry to our `package.json`
    file so that we can easily start our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to start a server, just run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the browser page at `http://localhost:3000/shoppinglists`. You will see
    an empty array as a result. This is because our database is still empty. Try to
    insert some data using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh the page now, you will see your new inserted value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our simple REST server up and running, let's use it in our
    shopping list application with the help of the `vue-resource` plugin!
  prefs: []
  type: TYPE_NORMAL
- en: Installing vue-resource, creating resources, and its methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going deeper into the usage of the `vue-resource` plugin, check out its
    documentation at [https://github.com/vuejs/vue-resource/blob/master/docs/resource.md](https://github.com/vuejs/vue-resource/blob/master/docs/resource.md)
    . Basically, the documentation provides an easy way of creating resources based
    on the given URL (in our case, it will be `http://localhost:3000/shoppinglists`).
    After the resource is created, we can call `get`, `delete`, `post`, and `update`
    methods on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it in the project''s folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create the entry point for our API. Inside an `src` folder of the
    shopping list application, create a subfolder and call it `api`. Create an `index.js`
    file inside it. In this file, we will import the `vue-resource` plugin and tell
    `Vue` to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice! Now we are ready to create `ShoppingListsResource` and attach some methods
    to it. To create a resource using the `vue-resource` plugin, we just call a `resource`
    method on `Vue` and pass the URL to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ShoppingListsResource` constant now exposes all the methods needed for
    the implementation of **CRUD** (**Create, Read, Update, and Delete**) operations.
    It is so easy to use that we could basically export the resource itself. But let''s
    export nice methods for each of the CRUD operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The full code for the `api/index.js` file can be seen in this gist at [https://gist.github.com/chudaol/d5176b88ba2c5799c0b7b0dd33ac0426](https://gist.github.com/chudaol/d5176b88ba2c5799c0b7b0dd33ac0426)
    .
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Our API is ready to be used and to populate our reactive Vue data!
  prefs: []
  type: TYPE_NORMAL
- en: Fetching all the shopping lists the application starts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating an action that will fetch and populate store's `shoppinglists`
    state. After its creation, we can call it on the main `App.vue` ready state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a constant in the `mutation_types.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a mutation. This mutation will just receive an array of `shoppinglists`
    and assign it to the `shoppinglists` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok then! Now we just need an action that will use the API''s `get` method and
    dispatch the populating mutation. Import the API in the `actions.js` file and
    create a corresponding action method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding lines of code, we perform a very simple task—we call the `fetchShoppingLists`
    API's method that, in turn, calls the `get` method of the resource. This method
    performs an `http GET` call and returns a promise that is resolved when the data
    is back from the server.
  prefs: []
  type: TYPE_NORMAL
- en: This data is then used to dispatch the populating mutation with it. This method
    will assign this data to the store's state `shoppinglists` property. This property
    is reactive; do you remember? This means that all the views that rely on the `shoppinglists`
    property getter will be updated. Let's now use this action in the main `App.vue`
    component on its `mounted` state. Check more about `mounted` state hook in the
    official Vue documentation page at [https://vuejs.org/v2/api/#mounted](https://vuejs.org/v2/api/#mounted)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `App.vue` component, import the `mapActions` object, map the `populateShoppingLists`
    action inside the component''s `methods` property, and call it inside the `mounted`
    handler. So, after the changes, the `script` tag of `App.vue` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open the page now, you will see the only shopping list that we created
    using `curl`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fetching all the shopping lists the application starts](../Images/image00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The displayed shopping lists are being served by our simple server!
  prefs: []
  type: TYPE_NORMAL
- en: Try to insert more items using `curl` or even directly modifying the `db.json`
    file. Refresh the page and look how it works like a charm!
  prefs: []
  type: TYPE_NORMAL
- en: Updating server status on changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very well, now we have our shopping lists being served by our REST API and everything
    works and looks nice. Try to add some shopping list items or change the titles
    of the shopping lists and check or uncheck items. After all these interactions,
    refresh the page. Whoops, the lists are empty, nothing happened. That's absolutely
    correct, we have an API method for updating the given shopping list but we don't
    call it anywhere, so our server is not aware of the applied changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining what components do something with our shopping lists
    so that these changes are sent to the server. The following three things can happen
    to the shopping lists and their items:'
  prefs: []
  type: TYPE_NORMAL
- en: The title of the list can be changed in `ChangeTitleComponent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new item can be added to the shopping list in `AddItemComponent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The item of the shopping list can be checked or unchecked in `ItemComponent`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must create an action that must be triggered on all these changes. Within
    this action, we should call the `update` API''s method. Have a close look at the
    update method inside the `api/index.js` module; it must receive the whole shopping
    list object as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create an action that receives an `id` as a parameter, retrieves the
    shopping list by its ID, and calls the API''s method. Before doing this, create
    a `getListById` method in the `getters.js` file and import it into the actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to define the action for updating the shopping list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, we can now delete the `findById` method from `mutations.js` and just
    reuse this one from `getters.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Well, now we have defined the action that calls the `updateList` method of our
    API. Now we just have to call the action on each change that happens inside the
    components!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `AddItemComponent`. We must dispatch the `updateList` action
    inside the `addItem` method using the `this.$store.dispatch` method with the action''s
    name. However, there''s a small problem—we must pass the list item ID to the `updateList`
    method and we do not have a reference to it inside this component. But it''s actually
    an easy fix. Just add the ID inside the component''s `props` and bind it to the
    component on its invocation inside `ShoppingListComponent`. So our `AddItemComponent` component''s
    `script` tag looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And, inside `ShoppingListComponent`, on the `add-item-component` invocation,
    bind the ID to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you try to add items to the shopping lists and refresh the page, the
    newly added items appear in the list!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should do the same for `ChangeTitleComponent`. Open the `ChangeTitleComponent.vue` file
    and check the code. Right now, it calls the `changeTitle` action on input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We could, of course, import the `updateList` action and call it right after
    calling the `changeTitle` action. But it might be easier to do it inside the action
    itself. You may remember that in order to dispatch the store''s action, we should
    call the `dispatch` method applied to the store with the action''s name as a parameter.
    So we can do it inside the `changeTitle` action. Just open the `action.js` file,
    find our `changeTitle` action, and add the call to `updateList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It's done! Open the page, modify the titles of the pages, and refresh the page.
    The titles should maintain their modified state!
  prefs: []
  type: TYPE_NORMAL
- en: The last change that we need to guarantee to be persisted is the change in the
    shopping list's items `checked` property. Let's look at `ItemComponent` and decide
    where we should call the `updateList` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the ID inside the `props` attribute, just like we did
    with `AddItemComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We must also bind the `id` property to the component''s invocation, which is
    done inside `ItemsComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This also means that we must bind the `id` property to `item-component` inside `ShoppingListComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We should also import the `mapActions` object inside `ItemComponent` and export
    the `updateList` method inside the `methods` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Okay then, everything is bound to everything; now we just have to find the right
    place inside `ItemComponent` to call the `updateList` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'And this turns out to be not such as easy task, because unlike in the other
    components where we had event handlers dealing with changes and calling the corresponding
    functions, here we just have class and model bindings attached to the checkbox
    element. Luckily for us, `Vue` provides a `watch` option that allows us to attach
    listeners to any of the component''s data and bind the handlers to them. In our
    case, we want to watch the `item.checked` property and call the action. So, just
    add the `watch` attribute to the components options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And...we are done! Try to add items to the shopping lists, check, uncheck, and
    check them again. Refresh the page. Everything looks like it was before refreshing!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new shopping list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay then, we are already fetching the shopping lists from the server; we also
    store applied changes, so we are fine. But wouldn't it also be nice if we could
    create the shopping lists using the user interface of our application instead
    of modifying the `db.json` file or using `curl post` requests? Of course, it would
    be nice. And, of course, we can do it with few lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the action that calls the corresponding API method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have to provide a visual mechanism for calling this action. For that,
    we can create an extra tab in the tab list with the plus button, which will call
    the action when it is clicked. We will do it inside the `App.vue` component. We
    have already imported the `mapActions` object. Let''s just add the `createShoppingList`
    method to the exported `methods` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At this moment, our `App.vue` component has access to the `createShoppingList`
    action and can call it on an event handler. The question is—with what data? The
    `createShoppingList` method is waiting to receive an object that will then be
    sent to the server. Let''s create a method that will generate a new list with
    a hardcoded title, and within this method, call the action with this new object.
    But where should it put this method? The `methods` property of the component is
    already occupied by the invocation of the `mapActions` helper. Well, the `mapActions`
    method returns a map of methods. We can simply *extend* this map with our local
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just need to add a button and bind the `addShoppingList` method to its
    `click` event. You can create your own button anywhere on the page. My button''s
    code looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the page; now we have a nice plus button on the last tab, which clearly
    indicates that there is a possibility of adding a new shopping list, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new shopping list](../Images/image00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can add new shopping lists using this nice plus button
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to click on the button. Whoops, nothing happens! However, if we look at
    the Network panel, we can see the request was actually performed and that succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new shopping list](../Images/image00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The creation request was performed successfully; however, nothing changed on
    the page
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, this makes perfect sense. We updated the information on the server,
    but the client side is not aware of these changes. If we could populate shopping
    lists after the successful shopping list creation, it would be nice, wouldn''t
    it? Did I say "if we could"? Of course we can! Just go back to `actions.js` and
    call the `populateShoppingLists` action on the promise''s `then` callback using
    the `store.dispatch` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you click on the plus button, you will immediately see the newly created
    list appearing in the tab pane, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new shopping list](../Images/image00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Newly added shopping list after repopulating our lists
  prefs: []
  type: TYPE_NORMAL
- en: You can now click on the new shopping list, change its name, add its items,
    and check and uncheck them. When you refresh the page, everything is just like
    it was before the refreshing. Amazing work!
  prefs: []
  type: TYPE_NORMAL
- en: Deleting existing shopping lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are already able to create and update our shopping lists. Now we just need
    to be able to delete them. After all the things that we have learned in this chapter,
    this will be the easiest part. We should add the action that will call the `deleteShoppingList`
    method of our API, add the remove button to each of the shopping list, and call
    the action on the button click.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the action. Similarly, as we did with the creation of
    shopping lists, we will call the `populate` method right after removing the shopping
    list, so our action will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s think where we should add the remove button. I would like to see
    it near the shopping list title in the tab header. This is the component called
    `ShoppingListTitleComponent`. Open it and import the `mapActions` helper. Export
    it in the `methods` property. So, the code inside the `script` tag of this component
    looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the remove button and bind the `deleteShoppingList` method to
    its `click` event listener. We should pass the ID to this method. We can do it
    directly inside the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'I also added a little bit of styling to the remove icon so that it looks a
    bit smaller and a bit more elegant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Open the page and you''ll see a tiny **`x`** button near each shopping
    list title. Try clicking on it and you will immediately see the changes, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting existing shopping lists](../Images/image00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shopping lists with the remove X button that allows us to delete unused shopping
    lists
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Now we have a fully functional application that allows us to
    create shopping lists for any occasion, remove them, and manage the items on each
    of them! Good work! The final code for this section can be found in the [chapter6/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/shopping-list2)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our shopping lists are all very similar to each other. I would like to propose
    a small styling exercise in which you should attach coloring to your lists in
    order to make them differ one from another. It will require you to add one more
    field for the background color on the shopping list creation and to use it inside
    the component to paint your lists with the given color.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using a plugin in the Pomodoro application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to use existing plugins with our Vue application, why not
    create our own plugin? We already have a little bit of animation in our Pomodoro
    application, and the screen changes completely when the state is changed from
    the working Pomodoro interval to the resting interval. However, if we are not
    looking at the tab, we have no idea if we should work or rest. It would be nice
    to add some sounds to our Pomodoro!
  prefs: []
  type: TYPE_NORMAL
- en: When thinking about sounds in a time management application, I would like to
    think about the sound that is nice for working. Every one of us has our own favorite
    playlist for work. Of course, it differs according to each person's musical preferences.
    That's why I decided to add some neutral sound to our application during the working
    period of time. It was proven by some studies that different noises (white, pink,
    brown, and so on) are good for the kind of work where a high level of concentration
    is required. The Wikipedia entry about these studies can be found at [https://en.wikipedia.org/wiki/Sound_masking](https://en.wikipedia.org/wiki/Sound_masking)
    . And some Quora experts talking about this can be found at [http://bit.ly/2cmRVW2](http://bit.ly/2cmRVW2)
    .
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the Web Audio API ( [https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
    ) to create a plugin for Vue that generates white, pink, and brown noises. We
    will provide a mechanism to instantiate one noise or another using Vue directives
    and we will also provide global Vue methods that will start and pause these sounds.
    After that, we will use this plugin to switch between a silent state while resting
    and looking at cats and a noisy state while working. Does it sound challenging
    and interesting? I really hope it does! Let's start then!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the NoiseGenerator plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our plugin will be stored in a single JavaScript file. It will contain three
    methods, one for the generation of each noise and provide a `Vue.install` method
    where the directives and needed Vue methods will be defined. Use the [chapter6/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/pomodoro)
    folder as a starting point. Start by creating a `plugins` subfolder in the `src`
    folder and adding the `VueNoiseGeneratorPlugin.js` file there. Now let''s create
    the following three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generateWhiteNoise`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generatePinkNoise`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generateBrownNoise`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will not reinvent the wheel and will just copy and paste the already existing
    code that I found on the Internet. Of course, I would like to give huge credit
    to the great resource that I found at [http://noisehack.com/generate-noise-web-audio-api/](http://noisehack.com/generate-noise-web-audio-api/)
    . That being said, our plugin after copying the code and organizing it in the
    functions should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can test all these noises in the JSFiddle at [https://jsfiddle.net/chudaol/7tuewm5z/](https://jsfiddle.net/chudaol/7tuewm5z/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we have all the three noises implemented. Now we must export the `install`
    method that will be called by `Vue`. This method receives the `Vue` instance and
    can create directives and methods on it. Let''s create a directive and call it
    `noise`. This directive can have one of three values, `white`, `pink`, or `brown`,
    and according to the received value will instantiate the `noise` variable by calling
    the corresponding noise creation method. So, our directive creation within an
    `install` method will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After the instantiation, we connect the `noise` to the already instantiated
    `audioContext` and `suspend` it because we don''t want it to start producing the
    noise right on the directive binding. We want it to be instantiated on some events
    (for example, clicking on the start button) and paused on other events (for example,
    when someone clicks on the pause button). For that, let''s provide methods for
    starting, pausing, and stopping our `audioContext`. We will put these three methods
    on the global Vue property called `noise`. We will call these methods `start`,
    `pause`, and `stop`. Within the `start` method, we want to resume `audioContext`
    and suspend it on both the `pause` and `stop` methods. So, our methods will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Our plugin is completely ready to be used. It's not perfect, of course,
    because we only have one `audioContext`, which is being instantiated once and
    then populated by one of the chosen noises, meaning we will not be able to use
    the `noise` directive more than once on the page, but again, this is just a prototype
    and you are more than welcome to enhance it and make it perfect and public!
  prefs: []
  type: TYPE_NORMAL
- en: Using the plugin in the Pomodoro application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fine then, now we have our nice noise-producing plugin, and the only thing
    that is missing is using it! You already know how to do it. Open the `main.js`
    file, import `VueNoiseGeneratorPlugin`, and tell `Vue` to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, we can attach the `noise` directive and use the `Vue.noise` method
    in any part of our Pomodoro application. Let''s bind it to our main template inside
    the `App.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use `v-noise` in the name of the directive and not just `noise`.
    We already talked about it when we learned custom directives. To use a directive,
    we should always prepend the `v-` prefix to its name. Also note that we used double
    quotes inside the single quotes to wrap the `brown` string. If we didn't do it,
    Vue would search for the data property called `brown`, because that's how the
    Vue works. As we can write any JavaScript statement inside the directive binding
    assignment, we must pass the string with double quotes. You can go further and
    create a data property called `noise` and assign to it the value you want (`white`,
    `brown`, or `pink`) and reuse it inside the directive binding syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that being done, let''s call the `Vue.noise.start` method in our `start`
    mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Check the page and click on the start button. You will listen to a nice brown
    noise. Be careful, however, to not to wake up your coworkers nor to scare your
    family (or vice versa). Try changing the value of the noise directive and choose
    your favorite noise to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, we are not done. We created a mechanism so that the noise is started,
    but it''s turning out to be a never-ending noise. Let''s call the `Vue.noise.pause`
    and `Vue.noise.stop` methods on the `pause` and `stop` mutations, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the page. Now if you click on the pause or stop button, the noise is
    suspended! We are still not done yet. Remember that our purpose was to have the
    noise only during working time and not during resting time. So, let''s have a
    look at the `tooglePomodoro` method inside `mutations.js` and add a mechanism
    that starts or stops the noise according to the Pomodoro''s current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The code of the Pomodoro application after all these modifications can be found
    in the [chapter6/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/pomodoro2)
    folder. Check how the noise is started when we start the application, how it's
    pausing when the working Pomodoro is completed, and how it restarted again when
    we should be back to work. Check also how the start, pause, and stop buttons trigger
    the noise as well. Nice work!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a button to toggle the sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s really nice that we have the noise sound bound to the working state of
    the Pomodoro application. It''s also nice that the sound is paused when we pause
    the application. However, it might be also useful to be able to pause the sound
    without having to pause the whole application. Think about those situations when
    you want to work in complete silence, or you might want to receive a Skype call.
    In these situations, having a noise in background, even if it''s nice and pink,
    is not nice at all. Let''s add a button to our application to toggle the sound.
    Start by declaring a store property called `soundEnabled` and initialize it with
    `true`. Also, create `getter` for this property. So `store.js` and `getters.js`
    start looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we must provide a mechanism to toggle the sound. Let''s create a mutation
    method for this and add an action that dispatches this mutation. Start by declaring
    a mutation type called `TOGGLE_SOUND`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s open `mutations.js` and add the mutation method that toggles the
    `soundEnabled` store property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add the action that dispatches this mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay then, now we have everything we need to create a toggle sound button!
    Let''s do it in our `ControlsComponent`. Start by adding a necessary getter and
    action to the map of methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add the button to our template. I suggest that it will be the icon
    with the `glyphicon` class that will be aligned to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s only show this icon when the application is `started` and `not paused`,
    and only when the Pomodoro state *is* `working` so that we don''t mess up the
    toggle sound button in a state where it is not supposed to have sound at all.
    This means that our `v-show` directive on this element will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are using the `isWorking` property here, which has not yet been
    imported. Add it to the map of `methods`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also use the `glyphicon-volume-off` and `glyphicon-volume-on` classes
    on this element. They will indicate calling for the action to toggle the sound''s
    state. This means that the `glyphicon-volume-off` class should be applied when
    the sound is *enabled* and the `glyphicon-volume-on` class should be applied when
    the sound is *disabled*. Putting it in the code, our class directive should look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not least, we should call the `toggleSound` action when the button
    is clicked. This means that we should also bind the `click` event listener to
    this element, which will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the whole jade markup code for this button will be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just add a bit of styling to this button so that it appears aligned
    to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the page and start the Pomodoro application. Now you can see this nice
    button on the top-right corner that will allow you to turn the sound off, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a button to toggle the sound](../Images/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can turn the sound off while working!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on this button, it will transform into another button, whose purpose
    is to turn the sound on again, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a button to toggle the sound](../Images/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: And we can turn it on again!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following scenario: we start the application, turn off the
    sound, pause the application, and resume the application. Our current logic suggests
    that the sound is started each time the application is started. We will be in
    an inconsistent state—the application has started, the sound is playing, but the
    toggling sound button is suggesting to turn the sound on. That''s not right, is
    it? But this has an easy fix—just add one more condition to the start mutation,
    not only it should check if `isWorking` is `true`, but also that the sound is
    enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now we are fine. The code after all these modifications can be found in the
    [chapter6/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/pomodoro3)
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Check the code, run the application, enjoy the sound, and do not forget to have
    a break!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be nice if during our Pomodoro intervals we could also enjoy some happy
    nice music while looking at cats. Create a plugin that plays a chosen mp3 file
    and use it on the Pomodoro intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While I was writing the last lines of code for this chapter and checking the
    page, at one point I got stuck looking at this picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](../Images/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A lot of cats looking at me and asking: will this chapter get to its end at
    some point?'
  prefs: []
  type: TYPE_NORMAL
- en: I even paused the application to have a better look at this picture (yes, when
    you pause the Pomodoro application during resting time, the picture will pause
    as well because the cache-buster timestamp is not being updated anymore). Doesn't
    it seem like these cats are asking us to get some rest? Also, the amount of them
    is pretty close to the number of things that we've learned in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how the plugins system work with Vue.js. We used
    an existing `resource` plugin to attach the server-side behavior to our shopping
    list application. Now we can create, delete, and update our shopping lists.
  prefs: []
  type: TYPE_NORMAL
- en: We have also created our own plugin! Our plugin is able to produce sound that
    can help in concentrating during the working period. Not only have we created
    it, but we have also used it in our Pomodoro application! Now we can concentrate
    better while Pomodoro is working and toggle the sound at any time!
  prefs: []
  type: TYPE_NORMAL
- en: Now we have two really nice applications in our hands. Do you know what is better
    than a nice application?
  prefs: []
  type: TYPE_NORMAL
- en: '*The only thing that is better than a nice application is a nicely tested application!*'
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, it's about time we tested our applications. In the next chapter,
    we will check and apply some testing techniques. We will write unit tests using
    Karma test runner and Jasmine as an assertion library. We will also write end-to-end
    tests using Nightwatch. I love to test applications and I hope that you will love
    it as well. Let's go!
  prefs: []
  type: TYPE_NORMAL
