- en: Chapter 6. Plugins – Building Your House with Your Own Bricks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。插件-用自己的砖头建造你的房子
- en: In the previous chapter, you learned how to manage the global application store
    using the Vuex architecture. You learned a lot of new concepts and applied them.
    You also learned how to create a store, how to define its state and mutations,
    and how to use actions and getters. We brought our shopping list and Pomodoro
    applications to life using the knowledge acquired during the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学会了如何使用Vuex架构管理全局应用程序存储。你学到了很多新概念并应用了它们。你还学会了如何创建一个存储，如何定义它的状态和变化，以及如何使用操作和获取器。我们利用在这一章中获得的知识，让我们的购物清单和番茄钟应用程序焕发生机。
- en: In this chapter, we will revisit Vue plugins, see how they work, and how they
    must be created. We will use some existing plugins and create our own.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将重新审视Vue插件，看看它们是如何工作的，以及它们必须如何创建。我们将使用一些现有的插件并创建我们自己的插件。
- en: 'Summing it up, in this chapter, we are going to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，在这一章中，我们将做以下事情：
- en: Understand the nature of Vue plugins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Vue插件的性质
- en: Use the resource plugin in the shopping lists application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在购物清单应用程序中使用资源插件
- en: Create a plugin that produces white, pink, and brown noises and apply it to
    our Pomodoro application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个生成白色、粉色和棕色噪音的插件，并将其应用到我们的番茄钟应用程序中
- en: The nature of Vue plugins
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue插件的性质
- en: 'Plugins in Vue.js are used for exactly the same purpose as they are used in
    any other scope: to add some nice functionality that, due to its nature, cannot
    be achieved with the core functionality of the system. Plugins written for Vue
    can provide various functionalities, starting from the definition of some global
    Vue methods or even the instance methods and moving toward providing some new
    directives, filters, or transitions.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Vue.js中，插件的用途与在任何其他范围中使用的目的完全相同：为系统的核心功能无法实现的一些良好功能添加一些功能。为Vue编写的插件可以提供各种功能，从定义一些全局Vue方法，甚至实例方法，到提供一些新的指令、过滤器或转换。
- en: 'In order to be able to use an existing plugin, you must first install it:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用现有的插件，你必须首先安装它：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And then, tell Vue to use it in your application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，告诉Vue在你的应用程序中使用它：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also create our own plugins. This is also easy. Your plugin must provide
    an `install` method where you define any global or instance methods, or custom
    directives:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建我们自己的插件。这也很容易。你的插件必须提供一个`install`方法，在这个方法中你可以定义任何全局或实例方法，或自定义指令：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then it can be used just like any other existing plugin. In this chapter, we
    will use the existing `resource` plugin for Vue ( [https://github.com/vuejs/vue-resource](https://github.com/vuejs/vue-resource)
    ) and create our own plugin that generates white, pink, and brown noises.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它可以像任何其他现有的插件一样使用。在这一章中，我们将使用现有的`resource`插件为Vue（[https://github.com/vuejs/vue-resource](https://github.com/vuejs/vue-resource)）并创建我们自己的插件，生成白色、粉色和棕色噪音。
- en: Using the vue-resource plugin in the shopping list application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在购物清单应用程序中使用vue-resource插件
- en: 'Open the shopping list application (the [chapter6/shopping-list](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/shopping-list)
    folder) and run `npm install` and `npm run dev`. It''s nice and clean, but it
    still uses the hardcoded list of the shopping lists. It would be really nice if
    we were able to add new shopping lists, delete them, and store the information
    on updated shopping lists so that when we restart the application, the displayed
    information corresponds to the last we saw before restarting. In order to be able
    to do that, we will use the `resource` plugin, which allows us to easily create
    REST resources and call REST methods on them. Before starting, let''s summarize
    everything that we need to do in order to achieve this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we need to have a simple server that contains some storage from
    where we can retrieve and where we can store our shopping lists. This server must
    provide the needed endpoints for all this functionality.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After creating our server and all needed endpoints, we should install and use
    the `vue-resource` plugin to create a resource and actions that will call the
    methods on the provided endpoints.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to guarantee the data integrity, we should call actions that update
    server's state on each shopping lists update.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the application start, we should fetch shopping lists from the server and
    assign them to our store's state.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should also provide a mechanism to create new shopping lists and delete the
    existing ones.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doesn't sound too difficult, right? Let's start then!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple server
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we will use a very basic and easy-to-use HTTP server
    that stores data inside a regular JSON file. It is called `json-server` and it
    is hosted at [https://github.com/typicode/json-server](https://github.com/typicode/json-server).
    Install it in the shopping list application''s directory:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a `server` folder with the `db.json` file inside it with the following
    content:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will be our database. Let''s add the script entry to our `package.json`
    file so that we can easily start our server:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, to start a server, just run the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open the browser page at `http://localhost:3000/shoppinglists`. You will see
    an empty array as a result. This is because our database is still empty. Try to
    insert some data using `curl`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you refresh the page now, you will see your new inserted value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our simple REST server up and running, let's use it in our
    shopping list application with the help of the `vue-resource` plugin!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Installing vue-resource, creating resources, and its methods
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going deeper into the usage of the `vue-resource` plugin, check out its
    documentation at [https://github.com/vuejs/vue-resource/blob/master/docs/resource.md](https://github.com/vuejs/vue-resource/blob/master/docs/resource.md)
    . Basically, the documentation provides an easy way of creating resources based
    on the given URL (in our case, it will be `http://localhost:3000/shoppinglists`).
    After the resource is created, we can call `get`, `delete`, `post`, and `update`
    methods on it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Install it in the project''s folder:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s create the entry point for our API. Inside an `src` folder of the
    shopping list application, create a subfolder and call it `api`. Create an `index.js`
    file inside it. In this file, we will import the `vue-resource` plugin and tell
    `Vue` to use it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Nice! Now we are ready to create `ShoppingListsResource` and attach some methods
    to it. To create a resource using the `vue-resource` plugin, we just call a `resource`
    method on `Vue` and pass the URL to it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ShoppingListsResource` constant now exposes all the methods needed for
    the implementation of **CRUD** (**Create, Read, Update, and Delete**) operations.
    It is so easy to use that we could basically export the resource itself. But let''s
    export nice methods for each of the CRUD operations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The full code for the `api/index.js` file can be seen in this gist at [https://gist.github.com/chudaol/d5176b88ba2c5799c0b7b0dd33ac0426](https://gist.github.com/chudaol/d5176b88ba2c5799c0b7b0dd33ac0426)
    .
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: That's it! Our API is ready to be used and to populate our reactive Vue data!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Fetching all the shopping lists the application starts
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating an action that will fetch and populate store's `shoppinglists`
    state. After its creation, we can call it on the main `App.vue` ready state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a constant in the `mutation_types.js` file as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now create a mutation. This mutation will just receive an array of `shoppinglists`
    and assign it to the `shoppinglists` state:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Ok then! Now we just need an action that will use the API''s `get` method and
    dispatch the populating mutation. Import the API in the `actions.js` file and
    create a corresponding action method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding lines of code, we perform a very simple task—we call the `fetchShoppingLists`
    API's method that, in turn, calls the `get` method of the resource. This method
    performs an `http GET` call and returns a promise that is resolved when the data
    is back from the server.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: This data is then used to dispatch the populating mutation with it. This method
    will assign this data to the store's state `shoppinglists` property. This property
    is reactive; do you remember? This means that all the views that rely on the `shoppinglists`
    property getter will be updated. Let's now use this action in the main `App.vue`
    component on its `mounted` state. Check more about `mounted` state hook in the
    official Vue documentation page at [https://vuejs.org/v2/api/#mounted](https://vuejs.org/v2/api/#mounted)
    .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `App.vue` component, import the `mapActions` object, map the `populateShoppingLists`
    action inside the component''s `methods` property, and call it inside the `mounted`
    handler. So, after the changes, the `script` tag of `App.vue` looks like the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you open the page now, you will see the only shopping list that we created
    using `curl`, as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Fetching all the shopping lists the application starts](../Images/image00295.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: The displayed shopping lists are being served by our simple server!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Try to insert more items using `curl` or even directly modifying the `db.json`
    file. Refresh the page and look how it works like a charm!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Updating server status on changes
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Very well, now we have our shopping lists being served by our REST API and everything
    works and looks nice. Try to add some shopping list items or change the titles
    of the shopping lists and check or uncheck items. After all these interactions,
    refresh the page. Whoops, the lists are empty, nothing happened. That's absolutely
    correct, we have an API method for updating the given shopping list but we don't
    call it anywhere, so our server is not aware of the applied changes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining what components do something with our shopping lists
    so that these changes are sent to the server. The following three things can happen
    to the shopping lists and their items:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The title of the list can be changed in `ChangeTitleComponent`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new item can be added to the shopping list in `AddItemComponent`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The item of the shopping list can be checked or unchecked in `ItemComponent`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must create an action that must be triggered on all these changes. Within
    this action, we should call the `update` API''s method. Have a close look at the
    update method inside the `api/index.js` module; it must receive the whole shopping
    list object as a parameter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s create an action that receives an `id` as a parameter, retrieves the
    shopping list by its ID, and calls the API''s method. Before doing this, create
    a `getListById` method in the `getters.js` file and import it into the actions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we are ready to define the action for updating the shopping list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Actually, we can now delete the `findById` method from `mutations.js` and just
    reuse this one from `getters.js`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Well, now we have defined the action that calls the `updateList` method of our
    API. Now we just have to call the action on each change that happens inside the
    components!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `AddItemComponent`. We must dispatch the `updateList` action
    inside the `addItem` method using the `this.$store.dispatch` method with the action''s
    name. However, there''s a small problem—we must pass the list item ID to the `updateList`
    method and we do not have a reference to it inside this component. But it''s actually
    an easy fix. Just add the ID inside the component''s `props` and bind it to the
    component on its invocation inside `ShoppingListComponent`. So our `AddItemComponent` component''s
    `script` tag looks like the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And, inside `ShoppingListComponent`, on the `add-item-component` invocation,
    bind the ID to it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, if you try to add items to the shopping lists and refresh the page, the
    newly added items appear in the list!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we should do the same for `ChangeTitleComponent`. Open the `ChangeTitleComponent.vue` file
    and check the code. Right now, it calls the `changeTitle` action on input:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We could, of course, import the `updateList` action and call it right after
    calling the `changeTitle` action. But it might be easier to do it inside the action
    itself. You may remember that in order to dispatch the store''s action, we should
    call the `dispatch` method applied to the store with the action''s name as a parameter.
    So we can do it inside the `changeTitle` action. Just open the `action.js` file,
    find our `changeTitle` action, and add the call to `updateList`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's done! Open the page, modify the titles of the pages, and refresh the page.
    The titles should maintain their modified state!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The last change that we need to guarantee to be persisted is the change in the
    shopping list's items `checked` property. Let's look at `ItemComponent` and decide
    where we should call the `updateList` action.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the ID inside the `props` attribute, just like we did
    with `AddItemComponent`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We must also bind the `id` property to the component''s invocation, which is
    done inside `ItemsComponent`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This also means that we must bind the `id` property to `item-component` inside `ShoppingListComponent`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We should also import the `mapActions` object inside `ItemComponent` and export
    the `updateList` method inside the `methods` property:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Okay then, everything is bound to everything; now we just have to find the right
    place inside `ItemComponent` to call the `updateList` action.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'And this turns out to be not such as easy task, because unlike in the other
    components where we had event handlers dealing with changes and calling the corresponding
    functions, here we just have class and model bindings attached to the checkbox
    element. Luckily for us, `Vue` provides a `watch` option that allows us to attach
    listeners to any of the component''s data and bind the handlers to them. In our
    case, we want to watch the `item.checked` property and call the action. So, just
    add the `watch` attribute to the components options as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And...we are done! Try to add items to the shopping lists, check, uncheck, and
    check them again. Refresh the page. Everything looks like it was before refreshing!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new shopping list
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Okay then, we are already fetching the shopping lists from the server; we also
    store applied changes, so we are fine. But wouldn't it also be nice if we could
    create the shopping lists using the user interface of our application instead
    of modifying the `db.json` file or using `curl post` requests? Of course, it would
    be nice. And, of course, we can do it with few lines of code!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the action that calls the corresponding API method,
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we have to provide a visual mechanism for calling this action. For that,
    we can create an extra tab in the tab list with the plus button, which will call
    the action when it is clicked. We will do it inside the `App.vue` component. We
    have already imported the `mapActions` object. Let''s just add the `createShoppingList`
    method to the exported `methods` property:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this moment, our `App.vue` component has access to the `createShoppingList`
    action and can call it on an event handler. The question is—with what data? The
    `createShoppingList` method is waiting to receive an object that will then be
    sent to the server. Let''s create a method that will generate a new list with
    a hardcoded title, and within this method, call the action with this new object.
    But where should it put this method? The `methods` property of the component is
    already occupied by the invocation of the `mapActions` helper. Well, the `mapActions`
    method returns a map of methods. We can simply *extend* this map with our local
    method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we just need to add a button and bind the `addShoppingList` method to its
    `click` event. You can create your own button anywhere on the page. My button''s
    code looks like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Look at the page; now we have a nice plus button on the last tab, which clearly
    indicates that there is a possibility of adding a new shopping list, as shown
    in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new shopping list](../Images/image00296.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Now we can add new shopping lists using this nice plus button
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to click on the button. Whoops, nothing happens! However, if we look at
    the Network panel, we can see the request was actually performed and that succeeded:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new shopping list](../Images/image00297.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: The creation request was performed successfully; however, nothing changed on
    the page
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, this makes perfect sense. We updated the information on the server,
    but the client side is not aware of these changes. If we could populate shopping
    lists after the successful shopping list creation, it would be nice, wouldn''t
    it? Did I say "if we could"? Of course we can! Just go back to `actions.js` and
    call the `populateShoppingLists` action on the promise''s `then` callback using
    the `store.dispatch` method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, if you click on the plus button, you will immediately see the newly created
    list appearing in the tab pane, as shown in the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new shopping list](../Images/image00298.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Newly added shopping list after repopulating our lists
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: You can now click on the new shopping list, change its name, add its items,
    and check and uncheck them. When you refresh the page, everything is just like
    it was before the refreshing. Amazing work!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Deleting existing shopping lists
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are already able to create and update our shopping lists. Now we just need
    to be able to delete them. After all the things that we have learned in this chapter,
    this will be the easiest part. We should add the action that will call the `deleteShoppingList`
    method of our API, add the remove button to each of the shopping list, and call
    the action on the button click.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the action. Similarly, as we did with the creation of
    shopping lists, we will call the `populate` method right after removing the shopping
    list, so our action will look like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now let''s think where we should add the remove button. I would like to see
    it near the shopping list title in the tab header. This is the component called
    `ShoppingListTitleComponent`. Open it and import the `mapActions` helper. Export
    it in the `methods` property. So, the code inside the `script` tag of this component
    looks like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now let''s add the remove button and bind the `deleteShoppingList` method to
    its `click` event listener. We should pass the ID to this method. We can do it
    directly inside the template:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I also added a little bit of styling to the remove icon so that it looks a
    bit smaller and a bit more elegant:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That''s it! Open the page and you''ll see a tiny **`x`** button near each shopping
    list title. Try clicking on it and you will immediately see the changes, as shown
    in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting existing shopping lists](../Images/image00299.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: Shopping lists with the remove X button that allows us to delete unused shopping
    lists
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! Now we have a fully functional application that allows us to
    create shopping lists for any occasion, remove them, and manage the items on each
    of them! Good work! The final code for this section can be found in the [chapter6/shopping-list2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/shopping-list2)
    folder.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our shopping lists are all very similar to each other. I would like to propose
    a small styling exercise in which you should attach coloring to your lists in
    order to make them differ one from another. It will require you to add one more
    field for the background color on the shopping list creation and to use it inside
    the component to paint your lists with the given color.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using a plugin in the Pomodoro application
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how to use existing plugins with our Vue application, why not
    create our own plugin? We already have a little bit of animation in our Pomodoro
    application, and the screen changes completely when the state is changed from
    the working Pomodoro interval to the resting interval. However, if we are not
    looking at the tab, we have no idea if we should work or rest. It would be nice
    to add some sounds to our Pomodoro!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: When thinking about sounds in a time management application, I would like to
    think about the sound that is nice for working. Every one of us has our own favorite
    playlist for work. Of course, it differs according to each person's musical preferences.
    That's why I decided to add some neutral sound to our application during the working
    period of time. It was proven by some studies that different noises (white, pink,
    brown, and so on) are good for the kind of work where a high level of concentration
    is required. The Wikipedia entry about these studies can be found at [https://en.wikipedia.org/wiki/Sound_masking](https://en.wikipedia.org/wiki/Sound_masking)
    . And some Quora experts talking about this can be found at [http://bit.ly/2cmRVW2](http://bit.ly/2cmRVW2)
    .
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the Web Audio API ( [https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API)
    ) to create a plugin for Vue that generates white, pink, and brown noises. We
    will provide a mechanism to instantiate one noise or another using Vue directives
    and we will also provide global Vue methods that will start and pause these sounds.
    After that, we will use this plugin to switch between a silent state while resting
    and looking at cats and a noisy state while working. Does it sound challenging
    and interesting? I really hope it does! Let's start then!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Creating the NoiseGenerator plugin
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our plugin will be stored in a single JavaScript file. It will contain three
    methods, one for the generation of each noise and provide a `Vue.install` method
    where the directives and needed Vue methods will be defined. Use the [chapter6/pomodoro](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/pomodoro)
    folder as a starting point. Start by creating a `plugins` subfolder in the `src`
    folder and adding the `VueNoiseGeneratorPlugin.js` file there. Now let''s create
    the following three methods:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '`generateWhiteNoise`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generatePinkNoise`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generateBrownNoise`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I will not reinvent the wheel and will just copy and paste the already existing
    code that I found on the Internet. Of course, I would like to give huge credit
    to the great resource that I found at [http://noisehack.com/generate-noise-web-audio-api/](http://noisehack.com/generate-noise-web-audio-api/)
    . That being said, our plugin after copying the code and organizing it in the
    functions should look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can test all these noises in the JSFiddle at [https://jsfiddle.net/chudaol/7tuewm5z/](https://jsfiddle.net/chudaol/7tuewm5z/)
    .
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we have all the three noises implemented. Now we must export the `install`
    method that will be called by `Vue`. This method receives the `Vue` instance and
    can create directives and methods on it. Let''s create a directive and call it
    `noise`. This directive can have one of three values, `white`, `pink`, or `brown`,
    and according to the received value will instantiate the `noise` variable by calling
    the corresponding noise creation method. So, our directive creation within an
    `install` method will look like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After the instantiation, we connect the `noise` to the already instantiated
    `audioContext` and `suspend` it because we don''t want it to start producing the
    noise right on the directive binding. We want it to be instantiated on some events
    (for example, clicking on the start button) and paused on other events (for example,
    when someone clicks on the pause button). For that, let''s provide methods for
    starting, pausing, and stopping our `audioContext`. We will put these three methods
    on the global Vue property called `noise`. We will call these methods `start`,
    `pause`, and `stop`. Within the `start` method, we want to resume `audioContext`
    and suspend it on both the `pause` and `stop` methods. So, our methods will look
    like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it! Our plugin is completely ready to be used. It's not perfect, of course,
    because we only have one `audioContext`, which is being instantiated once and
    then populated by one of the chosen noises, meaning we will not be able to use
    the `noise` directive more than once on the page, but again, this is just a prototype
    and you are more than welcome to enhance it and make it perfect and public!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Using the plugin in the Pomodoro application
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fine then, now we have our nice noise-producing plugin, and the only thing
    that is missing is using it! You already know how to do it. Open the `main.js`
    file, import `VueNoiseGeneratorPlugin`, and tell `Vue` to use it:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'From now on, we can attach the `noise` directive and use the `Vue.noise` method
    in any part of our Pomodoro application. Let''s bind it to our main template inside
    the `App.vue` component:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we use `v-noise` in the name of the directive and not just `noise`.
    We already talked about it when we learned custom directives. To use a directive,
    we should always prepend the `v-` prefix to its name. Also note that we used double
    quotes inside the single quotes to wrap the `brown` string. If we didn't do it,
    Vue would search for the data property called `brown`, because that's how the
    Vue works. As we can write any JavaScript statement inside the directive binding
    assignment, we must pass the string with double quotes. You can go further and
    create a data property called `noise` and assign to it the value you want (`white`,
    `brown`, or `pink`) and reuse it inside the directive binding syntax.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'After that being done, let''s call the `Vue.noise.start` method in our `start`
    mutation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Check the page and click on the start button. You will listen to a nice brown
    noise. Be careful, however, to not to wake up your coworkers nor to scare your
    family (or vice versa). Try changing the value of the noise directive and choose
    your favorite noise to work with.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, we are not done. We created a mechanism so that the noise is started,
    but it''s turning out to be a never-ending noise. Let''s call the `Vue.noise.pause`
    and `Vue.noise.stop` methods on the `pause` and `stop` mutations, respectively:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Look at the page. Now if you click on the pause or stop button, the noise is
    suspended! We are still not done yet. Remember that our purpose was to have the
    noise only during working time and not during resting time. So, let''s have a
    look at the `tooglePomodoro` method inside `mutations.js` and add a mechanism
    that starts or stops the noise according to the Pomodoro''s current state:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The code of the Pomodoro application after all these modifications can be found
    in the [chapter6/pomodoro2](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/pomodoro2)
    folder. Check how the noise is started when we start the application, how it's
    pausing when the working Pomodoro is completed, and how it restarted again when
    we should be back to work. Check also how the start, pause, and stop buttons trigger
    the noise as well. Nice work!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Creating a button to toggle the sound
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s really nice that we have the noise sound bound to the working state of
    the Pomodoro application. It''s also nice that the sound is paused when we pause
    the application. However, it might be also useful to be able to pause the sound
    without having to pause the whole application. Think about those situations when
    you want to work in complete silence, or you might want to receive a Skype call.
    In these situations, having a noise in background, even if it''s nice and pink,
    is not nice at all. Let''s add a button to our application to toggle the sound.
    Start by declaring a store property called `soundEnabled` and initialize it with
    `true`. Also, create `getter` for this property. So `store.js` and `getters.js`
    start looking like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we must provide a mechanism to toggle the sound. Let''s create a mutation
    method for this and add an action that dispatches this mutation. Start by declaring
    a mutation type called `TOGGLE_SOUND`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s open `mutations.js` and add the mutation method that toggles the
    `soundEnabled` store property:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now let''s add the action that dispatches this mutation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Okay then, now we have everything we need to create a toggle sound button!
    Let''s do it in our `ControlsComponent`. Start by adding a necessary getter and
    action to the map of methods:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now we can add the button to our template. I suggest that it will be the icon
    with the `glyphicon` class that will be aligned to the right.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s only show this icon when the application is `started` and `not paused`,
    and only when the Pomodoro state *is* `working` so that we don''t mess up the
    toggle sound button in a state where it is not supposed to have sound at all.
    This means that our `v-show` directive on this element will look like the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note that we are using the `isWorking` property here, which has not yet been
    imported. Add it to the map of `methods`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s also use the `glyphicon-volume-off` and `glyphicon-volume-on` classes
    on this element. They will indicate calling for the action to toggle the sound''s
    state. This means that the `glyphicon-volume-off` class should be applied when
    the sound is *enabled* and the `glyphicon-volume-on` class should be applied when
    the sound is *disabled*. Putting it in the code, our class directive should look
    like the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Last but not least, we should call the `toggleSound` action when the button
    is clicked. This means that we should also bind the `click` event listener to
    this element, which will look like the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So, the whole jade markup code for this button will be like the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s just add a bit of styling to this button so that it appears aligned
    to the right:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Open the page and start the Pomodoro application. Now you can see this nice
    button on the top-right corner that will allow you to turn the sound off, as shown
    in the following screenshot:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a button to toggle the sound](../Images/image00300.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: Now we can turn the sound off while working!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on this button, it will transform into another button, whose purpose
    is to turn the sound on again, as shown in the following screenshot:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a button to toggle the sound](../Images/image00301.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: And we can turn it on again!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the following scenario: we start the application, turn off the
    sound, pause the application, and resume the application. Our current logic suggests
    that the sound is started each time the application is started. We will be in
    an inconsistent state—the application has started, the sound is playing, but the
    toggling sound button is suggesting to turn the sound on. That''s not right, is
    it? But this has an easy fix—just add one more condition to the start mutation,
    not only it should check if `isWorking` is `true`, but also that the sound is
    enabled:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now we are fine. The code after all these modifications can be found in the
    [chapter6/pomodoro3](https://github.com/PacktPublishing/Learning-Vue.js-2/tree/master/chapter6/pomodoro3)
    folder.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Check the code, run the application, enjoy the sound, and do not forget to have
    a break!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be nice if during our Pomodoro intervals we could also enjoy some happy
    nice music while looking at cats. Create a plugin that plays a chosen mp3 file
    and use it on the Pomodoro intervals.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While I was writing the last lines of code for this chapter and checking the
    page, at one point I got stuck looking at this picture:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](../Images/image00302.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: 'A lot of cats looking at me and asking: will this chapter get to its end at
    some point?'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: I even paused the application to have a better look at this picture (yes, when
    you pause the Pomodoro application during resting time, the picture will pause
    as well because the cache-buster timestamp is not being updated anymore). Doesn't
    it seem like these cats are asking us to get some rest? Also, the amount of them
    is pretty close to the number of things that we've learned in this chapter!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how the plugins system work with Vue.js. We used
    an existing `resource` plugin to attach the server-side behavior to our shopping
    list application. Now we can create, delete, and update our shopping lists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We have also created our own plugin! Our plugin is able to produce sound that
    can help in concentrating during the working period. Not only have we created
    it, but we have also used it in our Pomodoro application! Now we can concentrate
    better while Pomodoro is working and toggle the sound at any time!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Now we have two really nice applications in our hands. Do you know what is better
    than a nice application?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '*The only thing that is better than a nice application is a nicely tested application!*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, it's about time we tested our applications. In the next chapter,
    we will check and apply some testing techniques. We will write unit tests using
    Karma test runner and Jasmine as an assertion library. We will also write end-to-end
    tests using Nightwatch. I love to test applications and I hope that you will love
    it as well. Let's go!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
