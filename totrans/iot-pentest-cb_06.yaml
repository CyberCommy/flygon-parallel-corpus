- en: IoT Device Hacking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware exploitation versus software exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware hacking methodology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware Reconnaissance techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electronics 101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying buses and interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial interfacing for embedded devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NAND glitching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JTAG debugging and exploitation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key central component of any **Internet of Things** (**IoT**) solution is
    the embedded device. It is the device that interacts with the physical environment
    and communicates with the web endpoints and other devices around it. Knowledge
    of how to exploit these hardware devices is extremely crucial for performing an
    IoT pen test.
  prefs: []
  type: TYPE_NORMAL
- en: The type of device being used in an IoT solution might vary from product to
    product. In some cases, it could be a gateway, which allows various devices to
    interact with it, while also communicating with the web endpoints, or, it could
    be a medical device utility with the sole purpose of collecting data from a patient's
    body and showing it on a smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: However, there exist certain specific security issues, which can affect any
    given hardware device, no matter what its category. This is what we will be focusing
    on in this chapter-to gain an in-depth understanding of various IoT device security
    issues, how to identify them, and how to exploit them, irrespective of the device
    type. But, before we get into actual hardware exploitation, let's have a look
    at how hardware exploitation differs from traditional software exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware exploitation versus software exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The differences between hardware exploitation and software exploitation are
    quite significant, with the most important being that to find vulnerabilities
    and exploits in hardware, you will need to have the physical device with you.
    This means that unless you have possession of two or more devices, it is pretty
    complicated to pen test an IoT device's hardware effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Another factor that increases the complexity of working with hardware security
    is the amount of resources publicly available around hardware security. For instance,
    in the case of a software that you are assessing, the chances are that you might
    be able to find the existing vulnerabilities in one of the components that the
    software is using or a common vulnerability, which is found in the type of software
    that you are working with. It does not mean that hardware exploitation is tougher,
    it simply means that if you are getting started, you might find hardware exploitation
    a bit more complicated compared to your previous software exploitation experiences
    due to a lack of in-depth, security-related information of a given component.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note, in terms of hardware-based vulnerabilities, is that they
    are relatively tougher to patch and, in some cases, impossible without the complete
    replacement of the device for the end user. This means that if a hardware device
    ships with critical security issues in the hardware device itself, it would be
    the only option for the manufacturer for recall the devices and replace them with
    more secure ones.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, one of the most prominent differences for us as pen testers is that
    for hardware exploitation we would require a number of hardware tools and devices
    to assess and exploit the security of the end device effectively.
  prefs: []
  type: TYPE_NORMAL
- en: However, don't get demotivated as we will be covering a number of tools and
    techniques for hardware exploitation, which will give you a very quick head start
    into the world of hardware hacking.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware hacking methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps involved in a Hardware hacking methodology methodology:'
  prefs: []
  type: TYPE_NORMAL
- en: Information gathering and recon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External and internal analysis of the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying communication interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Acquiring data using hardware communication techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software exploitation using hardware exploitation methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdooring (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go into each of them, one by one, and understand each of these steps at
    a deeper level.
  prefs: []
  type: TYPE_NORMAL
- en: Information gathering and recon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in an embedded device hacking methodology is to gather as much
    information as possible about the target that we are working with. Now this may
    sound simple, but in the cases of embedded devices, this might be a bit more complicated
    than we might think. The information about a target device is usually limited-at
    least from a very high-level view-given the fact that in order to gain a relevant
    amount of information about the device, we will need access to the physical device
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: But even before doing so, there are a number of ways in which a pen tester can
    gather more information about a given target device. These include publicly available
    sources or the documentation, which the client has made available or through other
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the information that might be relevant at this stage would be:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the embedded device based on?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operating system it runs on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the external peripherals that the device supports?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of chipsets is the device using?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about the storage and memory being used in the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other relevant technical information about the device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have this information, we can move to the next step, which is analyzing
    the device using both exterior and interior analysis.
  prefs: []
  type: TYPE_NORMAL
- en: External and internal analysis of the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have the information acquired from the previous step, the next step
    would be to start working with the device itself. Here, the goal would be to look
    at the device from an attacker's perspective and identify as much information
    as possible using visual inspection-both external and internal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exterior analysis is quite straightforward and can be performed by looking
    at the device and figuring out all the various components that you can see. Here,
    you may ask yourself the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the various interfacing options with the device-does it have any USB
    ports, SD card slots, or an Ethernet port?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is the device powered on-by batteries, PPoE, or adapter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any labels on the device? If yes, what kind of information do they
    have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have performed the external analysis, the next step is to move to internal
    analysis of the device. This requires you to open up the device and look at the
    **printed circuit board** (**PCB**). In this step, we will be identifying all
    the various chipsets present in the device, looking them up on the datasheet and
    understanding what each particular component does, along with noting down the
    various information that we find from its datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, I also like to draw a basic block diagram of the various interconnections
    between components so as to have a much clearer understanding for the entire device
    internals.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying communication interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have looked at the PCB and have found enough information about the overall
    circuit and the various components involved in it, the next step is to look for
    all the possible options of interfacing with the device.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it could be pretty evident and standing out in front of you,
    and in others it might be something tougher to identify, by being scattered across
    the board or, in some cases, where you will have to directly hook into the legs
    of a given chipset.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring data using hardware communication techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have identified the communication protocol/interface in use, we can
    use a specific set of tools to communicate with the target device over the given
    protocol and interact with the target or read/write information to the given chip.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the interface under scrutiny, we will be using different techniques
    to connect to it and acquire useful data for pen testing. Some of the most commonly
    found interfaces are UART, JTAG, SPI, I2C, and 1-Wire.
  prefs: []
  type: TYPE_NORMAL
- en: Software exploitation using hardware exploitation methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have access to the target device over a given hardware interface, the
    next step would be to perform various software exploitation techniques via hardware
    exploitation. These involve performing things such as dumping the firmware, writing
    new content at a given memory region, performing modifications to running processes,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have understood by now, most exploitation's using hardware techniques
    would lead you to gain access to sensitive resources, which then could be exploited
    in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of the overall hardware pen testing methodology,
    let's move deeper into how to perform reconnaissance on hardware devices.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware reconnaissance techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the visual exterior analysis, reconnaissance consists of two steps-opening
    the device and looking at the various chips present, and finding information from
    its datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Opening the device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in a hardware reconnaissance process is to open up the device.
    This process's complexity can range from being extremely simple to highly complex
    depending on the device you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: In some of the devices, you will find that the screws are hidden beneath rubber
    pads on the legs, while in other cases they will be largely exposed, and in others
    still, the two different sections might be welded together.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how the device has been put together, use the appropriate tools
    to take apart the different sections. It is also recommended to have a good set
    of screwdrivers along with you for the entire hardware exploitation process, as
    varying devices will have many different kinds of screws used in them.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at various chips present
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have opened up the device, the next step is to look at the PCB and
    identify all the various chips present. To read the labels of the chip, use a
    USB microscope or your smartphone's flashlight while tilting the chip slightly.
    It is also recommended to have holders, which can hold the device steadily while
    you read the names of the various chips.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have figured out the name of a chip, head over to Google and search
    for its manufacturer, followed by the model number and the word, "datasheet".
    This is also something we will do later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the datasheet with you, you can use the information present there
    to figure out all the various properties of the target chip, including the pinout,
    which would prove to be extremely useful during the hardware exploitation process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to perform reconnaissance on our target device, we can
    move on to getting deeper into hardware exploitation. To ensure that we know our
    target very well and to ensure that our attacks succeed, we will need to get a
    finer understanding of electronics, which will make things easier and more understandable
    for us as we go into exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Electronics 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned, electronics is one of the most important things to understand
    if you want to get into hardware hacking. You might be able to catch some of the
    low-hanging vulnerabilities without an understanding of electronics; however,
    to be good at it, you will need to understand what is happening on the device
    and how a given component can be exploited. In this section, we will be looking
    at some of the foundational concepts in electronics, which will help you gain
    more confidence and understanding, once you start looking into embedded device
    internals.
  prefs: []
  type: TYPE_NORMAL
- en: This may look absolutely basic to you; however, think of this section as a refresher
    to what you are about to see in the later sections, and in real life, as you start
    working with embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: Resistor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resistors are electronic components, which offer resistance against the current
    flow, or speaking at a deeper level, against the electrons' flow. Resistors, denoted
    by *R*, are passive components, which means that they don't generate any electricity
    at all, but rather reduce voltage and current by dissipating power in the form
    of heat.
  prefs: []
  type: TYPE_NORMAL
- en: The unit of resistance is ohms (Ω) and resistors are usually built using carbon
    or metal wire. You will also find the resistors being color-coded in order to
    help convey the value of resistance they offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a resistor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c2aac831-cac2-4e0b-a47a-f4c01b8de34c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that you know what resistors are, it is also worth noting that there could
    be two different categories of resistors-fixed and variable. As the name implies,
    a fixed resistor is where the resistance is fixed and cannot be changed, whereas
    in a variable resistor, the resistance can be varied using certain techniques.
    One of the most popular examples of a variable resistor would be a **potentiometer**.
  prefs: []
  type: TYPE_NORMAL
- en: Voltage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Voltage in electronics is simply the potential energy difference between two
    different points of measurement. In most scenarios, you will find the reference
    point taken to measure the voltage of a given point is **ground** (**GND**), or
    the negative terminal of a battery or power supply. To put this in a real-life
    context, if you have used a 9V battery, this means that the potential difference
    between the two points would be 9 volts.
  prefs: []
  type: TYPE_NORMAL
- en: To go on to a deeper level, let's say that at the two ends of a conductor, such
    as copper wire, you have a huge amount of electrons (negative charge) and at the
    other end you have protons (positive charge). This means that there is a difference
    between the potentials of these two points ultimately leading to a flow of current.
  prefs: []
  type: TYPE_NORMAL
- en: To measure voltage, we use a device called a **voltmeter**, which tells us about
    the potential difference between the two points it is connected to. For example,
    the positive end of the 9V battery will have a voltage of +9V, and the negative
    end of the battery will have a voltage of -9V.
  prefs: []
  type: TYPE_NORMAL
- en: Current
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in the previous scenario, the current flows (in the preceding
    case because of the medium being a copper conductor) when there is a difference
    in voltages and it will continue flowing until both the sides have equal amounts
    of electrons and protons.
  prefs: []
  type: TYPE_NORMAL
- en: A current could either be an **alternating current** (**AC**) or a **direct
    current** (**DC**), which simply means that if the current is flowing at a constant
    rate, such as in batteries, it would be a DC, whereas if it is alternating or
    changing with time, it is an AC. For example, in the United States, the default
    power that you get from a power outlet is 120V and 60Hz AC.
  prefs: []
  type: TYPE_NORMAL
- en: Current is measured in **amperes** (**A**) and is denoted with the letter *I*
    in equations and formulas. The device used to measure the current is called an
    **ammeter**.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking here that these three components-Current, voltage, and
    resistance seem to be dependent on each other. To put it all together, voltage
    causes the current to flow, and resistance opposes the current flow.
  prefs: []
  type: TYPE_NORMAL
- en: The relation is what is famously known as **Ohm****'s Law**, which states that
    *Current (I) = Voltage (V)/Resistance(R)*.
  prefs: []
  type: TYPE_NORMAL
- en: This also confirms the fact that current is directly proportional to voltage,
    and indirectly proportional to resistance.
  prefs: []
  type: TYPE_NORMAL
- en: Capacitor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Capacitors are one of the other most common components found in almost all embedded
    devices. As the name suggests, one of their primary tasks is to hold energy in
    the form of an electric charge.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a capacitor are two oppositely charged plates, which hold the electric
    charge when connected to a power source. Some of the other usages of a capacitor
    are acting as filters, reducing electrical noise affecting other chips on the
    device, separating AC and DC components (AC coupling), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The unit of capacitance is the faraday denoted with an *F*, and it is calculated
    using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C=Q/V*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *C* is the capacitance, *Q* is the electric charge, and *V* is the voltage.
  prefs: []
  type: TYPE_NORMAL
- en: All of the preceding values are measured in their standard units of faradays
    (*F*), coulombs (*C*), and volts (*V*).
  prefs: []
  type: TYPE_NORMAL
- en: Transistor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transistors are electronic components, which serve a number of purposes by acting
    as both switches and an amplifiers.
  prefs: []
  type: TYPE_NORMAL
- en: As an amplifier, it can take in a small current and amplify it to produce a
    much bigger output current. One of the examples of this could be in a microphone
    connected to a loudspeaker, where the mic takes in a small sound input and amplifies
    it to produce a much louder sound when it comes out via the loudspeaker.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, as a switch, it can take a small current input and use it to allow
    a much larger current to flow by activating the new current flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a transistor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d3cb606-5a66-4cc3-ada1-dddb67fc54b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is how an NPN transistor (the other type is a PNP, where the
    arrow points at the base) is schematically represented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6295c4b8-4e43-426e-8d6a-8f054feff39c.png)'
  prefs: []
  type: TYPE_IMG
- en: Memory types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the most important components in embedded devices are related to data
    storage, which can be used by the device for a number of purposes. This is where
    you will be able to find things such as the firmware and **application programming
    interface** (**API**) keys. The three primary categories of memory types in embedded
    devices, along with their subdivisions, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Random Access Memory** (**RAM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static RAM** (**SRAM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic RAM** (**DRAM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read Only Memory** (**ROM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Programmable ROM** (**PROM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Erasable Programmable ROM** (**EPROM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hybrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Electrically Erasable Programmable ROM** (**EEPROM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differentiation of the various kinds of memory types is made on the basis
    of a number of factors such as the ability to store data, time duration for which
    it can store the data, how the data can be erased and rewritten, and what the
    rewriting data process looks like.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, SRAM holds data for only as long as it receives a power supply,
    compared to DRAM, which stores each bit of data in an individual capacitor. Additionally,
    because of the primary fact that DRAM has refresh cycles (as the capacitors will
    eventually be discharged), SRAM is comparatively faster compared to DRAM.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, for ROM-based on how many times data can be written on it-it is classified
    as PROM or EPROM. For PROM, data once written can't be modified, whereas in EPROM,
    the data can be erased using a **ultraviolet** (**UV**) ray, which can reach the
    chip through a small window, erasing the chip by resetting it and bringing it
    to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: However, the two most important memory types that we will be encountering are
    EEPROM and Flash, or NOR and NAND Flash based on the differences in the read,
    write, and erase cycles-depending on whether the action can be performed on the
    entire block at once (Flash) and compared to whether it needs to be performed
    on a single bit at once (EEPROM).
  prefs: []
  type: TYPE_NORMAL
- en: Serial and parallel communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of some of the electronic components,
    let's move into the different kinds of communication mediums that are used in
    embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: The two methods of data communication in embedded devices are serial and parallel
    communication. As the name suggests, serial communication sends data one bit at
    a time sequentially. This means that if 8 bits have to be transferred, it will
    send one bit after the other, and the data transfer will be complete only when
    all the 8 bits are received.
  prefs: []
  type: TYPE_NORMAL
- en: However, in cases of parallel communication, multiple bits would be transferred
    at the same time, thus making the data transfer process faster compared to its
    serial counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that parallel communication would be much better and would be
    used predominantly everywhere because of faster data transfer rates. This, however,
    is not the case because we did not consider the amount of real estate on the circuit
    board it would require for a parallel communication.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded devices are extremely low in physical space. Thus, when it comes to
    data transfer, faster is not always the better option, when considering the fact
    that a parallel data transfer would require much more data lines compared with
    a serial data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the examples of parallel data transfer communications are PCI and ATA,
    whereas a serial communication is undertaken using USB, UART, and SPI.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will be focusing on the serial communication mediums, as they
    are most widely found in all the hardware devices that you will come across.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things you could perform additionally at this point of time is to
    look at the circuit board of any given embedded device and try to identify what
    are the various components involves and what kind of communication mechanism they
    are using.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying buses and interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a good understanding of the different components present in
    an embedded device, let's have a look at how we can identify the different buses
    and interfaces present in a device.
  prefs: []
  type: TYPE_NORMAL
- en: For this, the first step would be to open up the device and look at the PCB.
    Note that in this section, we will only be concerned with identifying what a particular
    pin, or header, or chip is for, rather than actually connecting to it, which is
    what we will cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...We will start by looking for UART which is one of the hacker's
    favorite interface to get access to the device. We will start by looking at the
    internals of UART, moving to how to identify the pinouts and finally how to connect
    with the target device.
  prefs: []
  type: TYPE_NORMAL
- en: UART identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we will look for in an embedded device is the **universal
    asynchronous receiver transmitter** (**UART**) interface. UART is one of the most
    common communication protocols found in embedded devices. UART essentially converts
    the parallel data that it receives into a serial bit stream of data, which could
    be easier to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Since the other focus here is on reducing the number of lines, there is no clock
    present in a UART communication. Instead, UART relies on **baud rate**, which
    is the rate of data transfer. The two different components present in a UART communication
    will agree on a specified baudrate to ensure that the data is received in a proper
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, in a UART communication, another bit called the **parity bit**
    is also added to the communication to facilitate error detection. Thus, a typical
    UART communication would have the following bits in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start bit**: This indicates that this is the start of a UART communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data bits**: This is the actual data that needs to be transmitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parity bit**: This is used for error detection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stop bit**: This is used to indicate the end of the UART data stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you would like to try this out by yourself and understand the UART data
    stream, you can use a logic analyzer and hook into the UART ports (which we will
    identify in a while) and view the results in the logic analyzer software. One
    of the popular logic analyzers that can be used is Salae Logic, which comes in
    both 8-channel and 16-channel options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows what the data would look like in a logic analyzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a6075de-45dc-4f32-be02-5b5e948b0ecd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and see what UART ports look like in real devices. The following
    are some examples of UART ports, which have been identified in devices. Note that
    for a UART communication to take place, two pins are essential-Transmit (Tx) and
    Receive (Rx). Additionally, in most of the cases, you will also find two more
    pins for ground (GND) and Vcc:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8eac5a14-3ba3-49d9-b16f-2ba15691ae9e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding image, there are four pins next to each other,
    which in this case are the UART pins. In the next section about acquiring and
    interfacing with serial communication, we will look at ways to identify the exact
    pinouts-which pins correspond to Tx, Rx, and GND, and also interface with these
    pins/ports to get access to the device.
  prefs: []
  type: TYPE_NORMAL
- en: SPI and I2C identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPI and I2C identification is similar to what we just saw in the UART communication
    identification. One of the ways of identifying that the communication protocol
    being used is SPI or I2C is by using a logic analyzer and looking at the various
    bits that have been transmitted in the communication.
  prefs: []
  type: TYPE_NORMAL
- en: Both SPI and I2C fall under serial communication, mostly used in Flash and EEPROM.
    One of the ways to correctly identify the exact protocol being used, along with
    further details, is to look at the chip name and get the information from the
    datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what an SPI flash chip looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0c2764c-d27e-40aa-a613-e7d51d3c2bf9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: [https://cdn-shop.adafruit.com/1200x900/1564-00.jpg](https://cdn-shop.adafruit.com/1200x900/1564-00.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: The flash chip in the preceding image has the label, Winbond W25Q80BV, which
    means that now we can look up its datasheet and identify its various properties-even
    without knowing that it's an SPI flash chip.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do a Google search for the chip number, the following is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcba91d3-d9cc-49e1-ba1f-e59791a60444.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and open up any of the datasheet PDFs found in the search result.
    At the very start of the datasheet itself, we will find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d76b63c-e7db-4511-ac16-7aeaf2b278d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that our chip is an SPI flash chip with 8 MB of storage. As we go
    further in the datasheet, we also find out its pinouts, as shown in the following
    screenshot, which tells us the exact pinouts of the given SPI flash chip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8f9c959-1bdf-46b8-9b0e-7e961068da02.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, we have been able to correctly identify what that chip is meant for, what
    its properties are, and what are its pinouts.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have this information, we can connect to the SPI flash chip using Attify
    Badge, which is a tool for working with various hardware protocols and standards
    such as UART, JTAG, SPI, and I2C. Alternatively, you can also use the FTDI MPSSE
    cable.
  prefs: []
  type: TYPE_NORMAL
- en: Connect the **data out** (**DO**) and **data in** (**DI**) to the MOSI and MISO
    respectively in the Attify Badge or, if you are using the FTDI cable, then the
    DI from the chip goes to the DO (yellow) and the DO of the chip goes to the DI
    (green) of the cable. Additionally, also connect the Vcc, GND, WP, and CS of the
    cable to the same pins on the chip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table in the following figure will help you make the connections at this
    stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8190c765-09ec-4302-a59a-84cd0aea9ba0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the connections are made, all we have to do is run the `spiflash.py` utility
    from the LibMPSSE library located at [https://github.com/devttys0/libmpsse](https://github.com/devttys0/libmpsse).
    This is also shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a0d4fb8-9c0c-4dfc-a71c-0ab86c27b599.png)'
  prefs: []
  type: TYPE_IMG
- en: The size in the preceding syntax was obtained from the datasheet of the flash
    chip, and the entire content of the flash chip was put into a file called `new.bin`.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, now you can look at a SPI flash chip, find out its pinouts, and dump data
    from it, which could be firmware, hardcoded keys, or other sensitive information,
    depending on the device that you are working with.
  prefs: []
  type: TYPE_NORMAL
- en: JTAG identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing that we will look for in order to identify interesting exposed
    interfaces on the device is a **Joint Test Action Group** (**JTAG**).
  prefs: []
  type: TYPE_NORMAL
- en: JTAG is a simplified way of testing pins and debugging them compared to the
    previous way of bed-of-nails testing. It allows device developers and testers
    to ensure that each of the pins in the various chips on the device are functional,
    interconnected, and operational as intended.
  prefs: []
  type: TYPE_NORMAL
- en: For penetration testers, JTAG serves a number of purposes, ranging from giving
    us the ability to read/write data and even debug running processes, and modifying
    the program execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: The four most important pins when we are looking for JTAG are **test data in**
    (**TDI**), **test data out** (**TDO**), **test clock** (**TCK**), and **test mode
    select** (**TMS**). However, even before identifying these individual pinouts,
    which we will do in the next section, we must first identify where  the JTAG headers
    are located on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things easier, JTAG comes in a couple of standard interface options
    such as 13 pins, 14 pins, 20 pins, and so on. The following are some of the images
    of JTAG interfaces in real-world devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a571cc13-8bb0-4fd7-99c0-224c36bd5d79.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: https://www.dd-wrt.com/wiki/images/thumb/9/99/DLINK-DIR632_Board.png/500px-DLINK-DIR632_Board.png'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the JTAG interface on an Experia v8 Box with the headers for JTAG
    soldered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5f1935f-f04b-41bd-8ca6-17c5f62c3b78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: http://www.alfredklomp.com/technology/experia-v8/'
  prefs: []
  type: TYPE_NORMAL
- en: Another important point to note here is that, even though you might be able
    to find the JTAG laid out in the standard header format, in some of the real-world
    devices, you will find the JTAG pins scattered all across the board instead of
    being at a single location. In these cases, you will need to solder headers/jumpers
    on them and connect them to a JTAGulator to be able to identify if they are JTAG
    pinouts, and which pin corresponds to what JTAG pin.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the interfaces and protocols mentioned earlier, there could be many
    other hardware communication protocols that your target device might be using.
    Some of the other popular communication techniques are CAN, PCI, 1-Wire, and so
    on. It would be recommended for you to look into more hardware communication protocols
    to gain a much wider understanding of ways in which you can analyze a protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial interfacing for embedded devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already covered the basics of UART in the previous section, let's
    jump into how we can interface with UART interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by looking at how to identify the pins once we have located the
    UART pinouts on a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four pins that we are trying to find are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Tx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vcc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this, we will use a **multimeter**, which can measure both voltage and current,
    thus acting as both a voltmeter and ammeter, hence the name, multimeter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what a multimeter looks like. Connect the probes as shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f061597a-b724-4541-a1e5-c3ea6437dfd7.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once connected, let's go ahead and find the different UART pinouts as described
    in the upcoming steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the pointer on the multimeter points to the speaker symbol,
    as shown in the following image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b06d22e4-8cd9-4ac9-a6a5-9caa1e456c1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that your device is turned off. Place the black probe on a ground surface-this
    could be any metallic surface on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Place the red probe on each of the four pads, which you think are the UART's,
    individually. Reiterate with the other pads until you hear a beep/buzz sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The place where you hear a *BEEP* sound is the GND pin on the device. This test
    is also known as the continuity test, as we just checked for continuity between
    two GND pins-one known and one unknown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have identified the GND pin, let's go ahead and identify the other
    remaining pins.
  prefs: []
  type: TYPE_NORMAL
- en: Put the multimeter pointer to the V - 20 position, as now we are going to measure
    the voltage. Keep the black probe to GND and move your red probe over the other
    pins of the UART (other than the GND).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this stage, power cycle the device and turn it on. At the pin where you see
    a constant high voltage is our Vcc pin.
  prefs: []
  type: TYPE_NORMAL
- en: Next, reboot the device again and measure the voltage between the remaining
    pads and GND (other than the Vcc and GND identified in the previous steps). Due
    to the significant amount of data transfer initially made during boot up, you
    will notice a huge fluctuation in the voltage value on one of the pins during
    the initial 10-15 seconds. This pin will be our Tx pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rx can be determined by the pin that has the lowest voltage fluctuation and
    the lowest overall value during the entire process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, we have identified all the pins required for a UART communication-Tx and
    Rx, as well as GND and Vcc.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have identified the pinouts of the device, the next step would be to
    connect the device's UART pins to Attify Badge. You can also use other devices
    in place of Attify Badge here, such as a USB-TTL or Adafruit FT232H.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pins on Attify Badge that we will be concerned with at this point in time
    are D0 and D1, which correspond to Transmit and Receive respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The target device's **Transmit** (**Tx**) would go to Attify Badge's Rx (D0)
    and the Rx of the target device will go to the Tx (D1) of Attify Badge. The GND
    of the IP camera would be connected to the Attify Badge's GND.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have made all the connections, the next step is to figure out the baudrate
    on which the device operates. Connect the Attify Badge to the system and power
    on the target device.
  prefs: []
  type: TYPE_NORMAL
- en: To identify the baudrate, we will use the `baudrate.py` utility available at
    [https://github.com/devttys0/baudrate/blob/master/baudrate.py](https://github.com/devttys0/baudrate/blob/master/baudrate.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'This could be run using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are in the baudrate, screen, you can use the up and down arrow keys
    to switch baudrates. At the baudrate if you are able to see readable characters,
    that is the correct baudrate for your target device. It should look something
    like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a58f2f84-6507-4277-b250-cfd6e0db41b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, hit *Ctrl* + *C*, which will take you to the minicom utility using the
    identified settings. Hitting *Enter* here would grant you shell access, given
    that your target device has a UART-based shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6fd8d08-8df1-4b6c-9b30-58929f0a3a49.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, we were able to exploit the exposed UART interface, figure out the pinouts
    and interface with it, and finally get a root shell.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have access to the UART interface of your target device, you can
    also perform additional exploitation techniques such as backdooring and dumping
    the entire file system over **trivial file transfer protocol** (**TFTP**). This,
    however, would vary from device to device and would be dependent on the current
    privileges you have on the device that you have compromised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NAND glitching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the other things which you can perform on embedded devices to bypass
    security measures (such as no root shell on UART console) is to take advantage
    of glitching-based attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Glitching, as the name suggests, is a way of introducing faults in the system
    that you are working with. This could be done in a number of various ways and
    there are separate books and research papers written solely on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we will be looking at a very basic glitching-based attack overview.
    The goal of this is to be able to access the bootloader, which will allow us to
    change sensitive parameters such as the boot up args, where we can define our
    own arguments to tell the system to launch the UART console with a login prompt/shell
    or boot the system in a single user mode bypassing authentication.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The glitch that we will look at here is called **NAND glitching**, where we
    will short one of the I/O pins of our device's NAND flash to a GND pin. Note that
    this shorting has to be performed at the very moment when the bootloader has booted
    and the kernel is about to boot up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consequently, if the shorting works, the kernel will fail to boot, thus causing
    you to drop to the default bootloader prompt, enabling you to change the bootloader
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give an example of what you can do with bootloader access, adding `single`
    to the boot up args will enable you to log in to the single user mode, thus bypassing
    the requirements of authentication on some systems. This is also shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fc3295d7-d0ed-4124-ad13-1a57b0c43016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: http://console-cowboys.blogspot.com/2013/01/swann-song-dvr-insecurity.html'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, performing the same NAND glitch on Wink Hub will result in dropping
    to the bootloader (discovered by the team at `Exploitee.rs` ), where you can change
    the arguments as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/36dc0849-e954-4ec8-816c-f2570c056ed4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you modify the boot arguments, you will be able to gain access to the
    root shell on the next boot via UART, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e2c2773f-5ddc-47bb-aab9-dce2f3da4455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Image source: http://www.brettlischalk.com/assets/WinkHack/WinkRootShell.png'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NAND glitching is one of the techniques where we take advantage of glitching-based
    attacks. However, you can also use power and voltage glitching techniques to perform
    things such as bypassing crypto and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional useful resources are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www2.cs.arizona.edu/~collberg/Teaching/466-566/2012/Resources/presentations/2012/topic1-final/report.pdf](https://www2.cs.arizona.edu/~collberg/Teaching/466-566/2012/Resources/presentations/2012/topic1-final/report.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.cl.cam.ac.uk/~sps32/ECRYPT2011_1.pdf](https://www.cl.cam.ac.uk/~sps32/ECRYPT2011_1.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-Electrical-Glitching-Attacks.pdf](https://www.blackhat.com/docs/eu-15/materials/eu-15-Giller-Implementing-Electrical-Glitching-Attacks.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JTAG debugging and exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered various exploitation techniques on hardware devices,
    it is time to cover one of the most important methods to compromise a device-JTAG.
    We have already seen what JTAG is and what JTAG pins usually look like.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get started with identifying the JTAG pinouts on our given target device.
    For this, we will use JTAGulator, which is a hardware tool built by *Joe Grande*
    to identify JTAG pinouts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have connected all the JTAGulator channels to the expected JTAG pinouts
    on the target device, additionally connecting the GND to GND.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the screen using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will be granted with a JTAGulator prompt, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2dbcf43-e00d-454e-b5a9-f6420da6a08a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that we will do here is set our target device''s voltage, which
    in the current scenario is 3.3\. To do this, simply type `V` followed by `3.3`
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bca14d5f-2b80-419d-b111-fb0a303d5508.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have set the target voltage, we can then run a bypass scan by hitting
    *B* to figure out the JTAG pins in our current connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8d393cf-f317-4ead-b8cb-a44647eb262c.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, JTAGulator was able to identify the JTAG pinouts and tell us
    what the individual pins correspond to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have identified the pinouts, the next step is to connect the pinouts
    to Attify Badge (or FTDI C232HM MPSSE cable) as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TDI of the target goes to the D1(TDI) of Attify Badge (or the Yellow of
    the FTDI cable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TDO of the target goes to the D2 (TDO) of Attify Badge (or the Green of
    the FTDI cable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TMS of the target goes to the D3 (TMS) of Attify Badge (or the Brown of
    the FTDI cable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The TCK of the target goes to the D0 (TCK) of Attify Badge (or the Orange of
    the FTDI cable)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have made the required connections, the next step is to run OpenOCD
    using the configuration files for Attify Badge (or the FTDI C232HM MPSSE cable)
    and the target device's chip. The configuration files can be obtained from the
    `OpenOCD` directory after installation and are located at `openocd/tcl/target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'OpenOCD can be run as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba0145d1-6b71-450e-8049-bf31a89c68fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, OpenOCD has identified both the devices in the chain and it
    has also enabled Telnet on port `4444`, which we can now connect to, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2dce679f-6465-47d2-b18d-15a826d1e49b.png)'
  prefs: []
  type: TYPE_IMG
- en: At this step, you can perform all the various OpenOCD commands, as well as the
    commands specific to your given chip, in order to compromise the device.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the things you can do with the ability to access a device over JTAG
    are reading data from a given memory location using the `mdw` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6c226f3-a33f-4f3d-b158-9c9fe9fb65cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Another example would be to connect to GDB to debug running processes by connecting
    to the running instance over port `3333`, and performing ARM/MIPS exploitation
    using the skills we have learned in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
