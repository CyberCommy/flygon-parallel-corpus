- en: Practical Example - A Look at Svelte and Being Vanilla
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the past few chapters took a look at the modern web and the APIs available
    to us, we are now going to take a practical example of those same APIs in action.
    There has been quite a bit of development in web frameworks that create a kind
    of *runtime* associated with them. This *runtime* can be almost all attributed
    to a **Virtual DOM** (**VDOM**) and a state system. When these two things are
    interconnected, we are able to create rich and reactive frontend. Examples of
    these frameworks are React, Vue, and Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens if we got rid of the VDOM and runtime concept and somehow
    compiled all of this code down to vanilla JavaScript and web API calls? This is
    what the creators of the Svelte framework had in mind: to utilize what we have
    in the browser instead of creating our own version of the browser (this is an
    obvious oversimplification, but it does not stretch the truth too much). In this
    chapter, we will take a look a Svelte and how it achieves some of this magic,
    along with a few examples of applications written in this framework. This should
    give a good understanding of Svelte and the *runtime-less* frameworks that are
    out there and how they could potentially speed up our application runtime speed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A framework for pure speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the basics – a Todo application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting fancier – basic weather application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are required for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An editor or IDE such as **Visual Studio Code** (**VS Code**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Node environment setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A good understanding of the DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web browser such as Chrome
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter04).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A framework for pure speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Svelte framework decided to shift the focus from a runtime-based system
    to a compiler-based system. This can be seen on their website, located at [https://svelte.dev](https://svelte.dev).
    On their front page, it even states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Svelte compiles your code to tiny, framework-less vanilla JS – your app starts
    fast and stays fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'By moving the steps from the runtime to the initial compile, we are able to
    create applications that will download and run fast. But, before we can start
    looking at this compiler, we need to get it onto our machines. The following steps
    should enable us to start writing code for Svelte (taken directly from [https://svelte.dev/blog/the-easiest-way-to-get-started](https://svelte.dev/blog/the-easiest-way-to-get-started)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With these commands, we now have a running Svelte application located at `localhost:5000`.
    Let's take a look at what the `package.json` has inside of it that got us up and
    running so fast. First, we will notice that we have a bunch of Rollup-based dependencies.
    Rollup is a module bundler for JavaScript that also has a rich set of tools to
    do many other tasks. It is similar to webpack or Parcel, but it is the tool that
    Svelte has decided to rely on. We will look at Rollup in more depth in [Chapter
    12](6662ad13-783a-440b-9565-8a75223284da.xhtml), *Building and Deploying a Full
    Web Application*. Just know that it is compiling and bundling our code for us.
  prefs: []
  type: TYPE_NORMAL
- en: It also seems that we got a `sirv` called (as can be seen in the `package.json`
    file). If we look up `sirv` inside `npm`, we will see that it is a static asset
    server, but, instead of looking for the files directly on the filesystem (which
    is quite an expensive operation), it caches the request headers and responses
    in memory for a certain period of time. This allows it to serve assets that may
    have already been served quickly, since it only has to look at its own memory
    instead of doing an I/O operation to look for the asset. The **command-line interface**
    (**CLI**) allows us to set up the server quite quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we start our application in dev mode. If we look at the `scripts`
    section of the `package.json` file, we will see that it runs the following command: `run-p
    start:dev autobuild`. The `run-p` command says to run all subsequent commands
    in parallel. The `start:dev` command says to start our `sirv` server up in dev
    mode, and the `autobuild` command tells Rollup to compile and watch our code.
    This means that whenever we make changes to the files, it will automatically build
    for us. Let''s quickly see this in action. Let''s go into the `src` folder and
    make a change to the `App.svelte` file. Add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will notice that our web page has automatically updated, and we now have
    a reactive web page based on an event! This is really nice when we are in development
    mode since we don't have to keep triggering the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The editor of choice in these examples is VS Code. If we head to the extensions
    section of VS Code, there is a nice plugin for Svelte. We can utilize this plugin
    for syntax highlighting and some alerts when we are doing something wrong. If
    the preferred editor does not have a Svelte plugin, try to at least get the HTML
    highlighting enabled for the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright: this simple example already gives us plenty to look at. First, the
    `App.svelte` file gives us a similar syntax to Vue files. We have a section for
    JavaScript, a section for styling, and a section for our enhanced HTML. We have
    exported two variables, called `name` and `counter`. We also have a function that
    we are utilizing in the click handler of our button. We have also enabled a style
    for our `h1` element.'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like the curly braces add the one-way data binding that we expect from
    these reactive frameworks. It also looks like we attach events in a simple `on:<event>`
    binding, instead of utilizing the built-in `on<event>` system.
  prefs: []
  type: TYPE_NORMAL
- en: If we now head into the `main.js` file, we will see that we are importing the
    Svelte file that we were just looking at. We then create a new *app* (it should
    look familiar to other reactive frameworks) and we target the body of the document
    with our application. On top of this, we are setting up some properties, the `name`
    and `counter` variables that we exported before. We then export this as the default
    export for this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this should seem quite similar to the previous chapter, when we looked
    at the class and module system that is built into the browsers. Svelte has just
    piggybacked on these similar concepts to write their compiler. Now, we should
    take a look at the output of the compilation process. We will notice that we have
    a `bundle.css` and a `bundle.js` file. If we first take a look at the `bundle.css`
    file that was generated, we will see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, Svelte is *mimicking* web components by putting them under a unique
    namespace, in this case, `svelte-i7qo5m`. This is quite straightforward, and those
    that have utilized other systems will notice that this is how a lot of frameworks
    create scoped stylesheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we go into the `bundle.js` file we will see quite a different story.
    First, we have an **Immediately Invoked Function Expression** (**IIFE**), which
    is the live reload code. Next, we have another IIFE that is assigning our application
    to a global variable called `app`. The code inside then has a bunch of boilerplate
    code such as `noop`, `run`, and `blank_object`. We also can see that Svelte wraps
    many of the built-in methods, such as the DOM''s `appendChild` and `createElement`
    APIs. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'They have even wrapped the `addEventListener` system in their own form so they
    can control callbacks and lifetime events. This can be seen with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: They then have a bunch of arrays that they are utilizing as queues for the various
    events. They loop through them and pop and run the events as they come up. This
    can is seen in the flush method that they have laid out. One interesting note
    is that they have `seen_callbacks` set. This is so that they stop infinite looping
    by counting methods/events that can cause an infinite loop. For example, component
    *A* gets an update that subsequently sends an update to component *B*, which then
    sends an update to component *A*. `WeakSet` may have been a better choice here,
    but they have opted to utilize the regular `Set` since it will be dumped once
    the flush method has finished.
  prefs: []
  type: TYPE_NORMAL
- en: One of the final functions that would be good to look at is the `create_fragment`
    method. We will notice that it returns an object that has a create function named
    `c`. As we can see, this creates the HTML elements that we had in our Svelte file.
    We will then see an `m` property, which is the mount function that adds our DOM
    elements to the actual document. The `p` property updates the properties that
    we have bound to this Svelte component (in this case, the `name` and `counter`
    properties). Finally, we have the `d` property, which relates to the `destroy`
    method and removes all the DOM elements and the DOM events.
  prefs: []
  type: TYPE_NORMAL
- en: Looking through this code, we can see that Svelte is utilizing a lot of the
    concepts that we would use if we were building a UI from scratch and utilizing
    the DOM API ourselves, but they have just wrapped it into a bunch of convenient
    wrappers and clever lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: A great way to understand a library is to read the source code or see what it
    outputs. By doing this, we can find where the magic usually lies. While this may
    not be beneficial right away, it can help us write for the framework or even utilize
    some of the tricks that we see in their code in our own code bases. One way of
    learning is to imitate others.
  prefs: []
  type: TYPE_NORMAL
- en: Out of all of this, we can see how Svelte states that there is no runtime. They
    are utilizing the basic elements that the DOM gives us in some nice convenient
    wrappers. They also give us a nice file format to write our code in. Even though
    this may seem like some basic code, we are able to write complex applications
    in this style.
  prefs: []
  type: TYPE_NORMAL
- en: The first application we will write is a simple Todo application. We will be
    adding some of our own ideas to it, but it will be a traditional Todo application
    at the start.
  prefs: []
  type: TYPE_NORMAL
- en: Build the basics – a Todo application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start off our Todo application, let''s go ahead and utilize the template
    that we already have. Now, in most Todo applications, we want to be able to do
    the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove/mark complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So what we have is a basic CRUD application without any server operations.
    Let''s go ahead and write the Svelte HTML that we would expect for this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have split our Todo application into a Todo component and the general application.
    The Todo element will hold all of our logic for the completion and deletion of
    the element. As we can see from the preceding example, we are doing the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: We expose the number this task is and the description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a completed property that is hidden from the main application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a class for styling a completed item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list element with the completion variable is bound to the complete class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `num` and `description` properties are tied to information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A checkbox is added for when we complete an item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there's a button that will tell our application what we want to be removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is quite a bit to digest, but when we put it all together, we will see
    that this holds most of the logic for an individual Todo item. Now, we need to
    add all of the logic for our application. It should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We first import the `Todo` that we created before. We then have `newTodoText`
    as a property bound to our input text. Then, we create a set to store all of our
    `Todos`. Next, we create an `addTodo` method that will be bound to the `click`
    event of our Add Todo button. This will create a new `Todo`, binding the element
    to our unordered list and setting the properties to our set size and input text
    respectively. We reset the `Todo` text, and add a remove listener to destroy the
    `Todo` and also remove it from our set. Finally, we add it to our set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a basic Todo application! All of this logic should be fairly straightforward.
    Let''s add some additional features as we had in a previous chapter. We will add
    the following things to our Todo application to make it a bit more robust and
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Have due dates associated with each `Todo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a count of all the `Todos`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create filters that will filter based on overdue, completed, and all
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitions based on the filters and the addition of each `Todo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let''s add a due date to our Todo application. We will add a new exported
    field inside our `Todo.svelte` file called `dueDate`, and we will also add it
    to our template like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside of our `App.svelte` file, we will add a date control and make
    sure that when we add our `Todo` to the list, we also make sure that we put this
    field back in. This should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a fully functioning due date system. Next, we will add the number
    of current `Todos` to our application. This is as simple as binding some text
    in a span to the size of our set, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, now we want to be able to do something with all of the dates and completed
    states. Let''s add some filters so we can remove `Todos` that do not fit our criteria.
    We will be adding the completed and overdue filters. We are going to make these
    checkboxes since an item can be both overdue and completed at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our handle filter logic should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to make sure that we have the same hide logic for any new `Todo`
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our `Todo.svelte` component should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this should look familiar, except for the top portion. There are special
    tags that we can add to Svelte files that allow us access to certain properties,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<svelte:window>` gives us access to the window events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<svelte:body>` gives us access to the body events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<svelte:head>` gives us access to the head of the document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<svelte:component>` gives us access to ourselves as a DOM element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<svelete:self>` allows us to contain ourselves (for recursive structures such
    as trees).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<svelte:options>` allows us to add compiler options to our component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we want our parent component to be able to access our properties
    through getters/setters, so we set the `accessors` option to `true`. This is how
    we are able to change our hidden property inside of the `App.svelte` file and
    allows us to get properties that are on each `Todo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add in some fade in and out transitions. Svelte comes with
    some nice animations when we add/remove elements. The one that we are going to
    use is the `fade` animation. So, our `Todo.svelte` file will now have the following
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The special syntax is for conditional DOM addition/subtraction. The same way
    we can add/remove children with the DOM API, Svelte is doing the same. Next, we
    can see that we added the `in:fade` and `out:fade` directives to the list elements.
    Now, when the element is added or removed from the DOM, it will fade in and out.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a fairly functional Todo application. We have filtering logic, `Todos`
    that are tied to due dates, and even a bit of animation. The next step is to clean
    up the code a bit. We can do this with the stores built into Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Stores are a way of sharing state without having to do some of the trickery
    that we have had to use in our application (we opened up the accessor system when
    we probably should not have). The shared state between our `Todos` and our main
    application is the overdue and completed filters. Each `Todo` should most likely
    be in control of this property, but we are currently utilizing the accessor option
    and all of the filtering is done in our main application. With a writable store,
    we no longer have to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we write a `stores.js` file like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update our `App.svelte` file to not target the `hidden` property in
    the `Todos`, and we bind the `checked` properties of our checkbox inputs to the
    stores like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The dollar sign in front of our stores means that these are stores and not
    variables in our scripts. It allows us to update and subscribe to the stores without
    having to unsubscribe from them on destroy. Finally, we can update our `Todo.svelte`
    file to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have added the overdue and completed stores to our system. You may have noticed
    that we got rid of the compiler option at the top of the file. We then link our
    `#if` condition to these stores. We have now put the responsibility of hiding
    the `Todos` based on filters on the `Todos` themselves while also removing quite
    a bit of code. It should start to become obvious that there are many ways that
    we can build applications in Svelte and maintain quite a bit of control over our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving onto the next application, go ahead and look at the bundled JavaScript
    and CSS along with adding new features to the application. Next, we are going
    to look at building a weather application and getting data from a server for this
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting fancier – a basic weather application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be quite obvious that Svelte has built up its compiler to work with
    most of the modern ECMAScript standards. One area where they do not provide any
    sort of wrapper is for fetching data. A good way to add this and see the effects
    is to build a basic weather application.
  prefs: []
  type: TYPE_NORMAL
- en: A weather application, at its core, needs to be able to take in a zip code or
    city and spit out information about the current weather for that region. We can
    also get an outlook for the weather based on this location. Finally, we can also
    save these choices in the browser, so we can use them when we come back to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our weather data, we are going to pull from [https://openweathermap.org/api](https://openweathermap.org/api).
    Here, the free service will allow us to get the current weather. On top of this,
    we will need an input system that will accept the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The city/country
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The zip code (if no country is given, we will assume US since that is the default
    for the API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we enter the correct value, we will store it in `LocalStorage`. Later in
    the chapter, we will take a more in-depth look at the `LocalStorage` API, but
    just note that it is a key-value storage mechanism in the browser. When we go
    to enter a value for the input, we will get a drop-down of all of our previous
    searches. We will also add the ability to remove any one of these results from
    the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get an API key. To do so, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://openweathermap.org/api](https://openweathermap.org/api) and follow
    the instructions to get an API key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have created an account and verify it, we will be able to add API keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After login, there should be a tab that says **API keys**. If we go to that,
    we should be greeted with a *no api keys* message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can create a key and add a name to it if we want (we can just call it `default`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this key, we are now able to start calling their server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and set up a test call. The following code should work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we put this into a code snippet, we should get back a JSON object with a
    bunch of data inside of it. Now we can move onto utilizing Svelte with this API
    to create a nice weather application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up our application in the same way we set up our Todo application.
    Run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have started the environment, let''s create a boilerplate application
    with some basic styling. In the `global.css` file, add the following lines to
    the body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure our elements are both column-based and that they will start
    from the center and grow out. This will give us a nice look for our application.
    Next, we are going to create two Svelte components, a `WeatherInput` and a `WeatherOutput`
    component. Next, we are going to focus on the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to have the following items so we can get the correct input from
    our users:'
  prefs: []
  type: TYPE_NORMAL
- en: Input for the zip code or the city
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input for the country code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Submit button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are also going to add some conditional logic to our application. Instead
    of trying to parse the input, we are going to conditionally render a text or number
    input based on a checkbox to the left of our input. With these ideas, our `WeatherInput.svelte`
    file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have the basic template for our input. First, we create a `zipcode`
    store to conditionally display a number or text input. Then, we create a couple
    of local variables that we will bind to our input values. The `submitData` function
    will submit everything once we are ready to get some type of response. Currently,
    we are just logging the output to the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: For styling, we just added some basic styling for valid versus invalid inputs.
    Our template gives us a checkbox to turn on the `zipcode` feature or to turn it
    off. We then conditionally show the `zipcode` or the city textbox. Each of these
    textboxes has the built-in validation added to it. Next, we added another text
    field to get a country code from our users. Finally, we added a button that will
    go out and check for the data.
  prefs: []
  type: TYPE_NORMAL
- en: The brackets are heavily utilized in Svelte. One feature of input validation
    is regex based. The field is called a pattern. If we try to utilize brackets in
    here, it will cause the Svelte compiler to fail. Just be aware of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the output, let''s go ahead and add some labels to our input
    to make it easier for users to use. The following should do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'For every `input` element, we have wrapped them in a `label` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we have the basic user interface for our `input` element. Now, we
    need to have the `fetch` call actually output to something that can be available
    to our `WeatherOutput` element once we have made it. Instead of just passing this
    data out as props, let''s create a custom store that implements a `gather` method.
    Inside of `stores.js`, we should have something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now moved the logic of getting the data into a store and we can now
    subscribe to this store to update ourselves. This will mean that we can make the
    `WeatherOutput` component subscribe to this for some basic output. The following
    code should be put into `WeatherOtuput.svelte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'All we are doing for now is putting the output of our weather into a paragraph
    element and stringifying it so we can read the output without looking at the console.
    We also need to update our `App.svelte` file and import the `WeatherOutput` component
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now test our application, we should get some ugly-looking JSON, but we
    have now tied our two components through the store! Now, all we need to do is
    pretty up the output, and we have a fully functioning weather application! Change
    the styling and the template inside of `WeatherOutput.svelte` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we should add a new control so our users can pick metric or imperial
    units for the output. Add the following to the `WeatherInput.svelte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will also use a new `metric` store to the `stores.js` file that defaults
    to `false`. With all of this, we should have now have a functioning weather application!
    The only piece that we have left is to add the `LocalStorage` capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of storage that do similar things. They are `LocalStorage`
    and `SessionStorage`. The main difference is how long they will stay cached. `LocalStorage`
    stays until the user deletes the cache or the application developer decides to
    delete it. `SessionStorage` stays in the cache for the lifetime of the page. Once
    the user decides to leave the page, `SessionStorage` will clear out. Leaving the
    page means closing the tab or navigating away; it does not mean reloading the
    page or Chrome crashing and the user recovering the page. It is up to the designer
    which one to use.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing `LocalStorage` is quite easy. The object is held on the window in
    our case (if we were in a worker, it would be held on the global object). One
    thing to keep in mind is that when we utilize `LocalStorage`, it converts all
    values to strings, so we will need to convert complex objects if we want to store
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change our application, let''s create a new component specifically for our
    drop-down. Let''s call it `Dropdown`. First, create a `Dropdown.svelte` file.
    Next, add the following code to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a bit of code, so let's break down what we have just done. First,
    we are taking our inputs and changing them to a `dropdown` component. We are also
    internalizing a lot of the state for this component. We open up various fields
    for the user to be able to customize the fields themselves. The main field that
    we need to make sure that we set is `name`. This is what we are using for the
    `LocalStorage` key to store our searches.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we subscribe to the `weather` store. We do not use the actual data, but
    we do get the event so we can add the selection to the store if it is unique (a
    set could be used here instead of an array). We add some basic logic if we want
    to activate the drop-down if we are focused or if we have clicked outside of our
    drop-down. We also add some logic to the click event of the list element (we actually
    add it to the children of the list element) for putting the text into the drop-down
    or removing from our `LocalStorage`. Finally, we add behavior to the `onMount`
    and the `onDestroy` of our component. `onMount` will pull from `localStorage`
    and add this to our inputs list. The `onDestroy` just removes our subscription
    so we do not have a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the styling and the templating should look familiar, except for
    the `bind:this` in the unordered list system. This allows us to bind a variable
    to the element itself. This allows us to deactivate our drop-down list if the
    element is not inside of the list of elements in the event path.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, make the following updates to the `WeatherInput.svelte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have now created a semi-reusable `dropdown` component (we do rely on the
    weather store, so it really only works with our application) and have created
    something that looks like a single component.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Svelte is an interesting framework in which we compile our code to Vanilla JavaScript.
    It utilizes modern ideas such as modules, templates, and scoped styling. We are
    also able to create reusable components in a simple manner. While there are even
    more optimizations that we could make to the applications that we have built,
    we can see how fast they truly are. While Svelte may not become a mainstream choice
    for application development, it is a great framework to see many of the concepts
    we have explored in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take a break from the browser and take a look at how we can utilize
    JavaScript on the server utilizing Node.js. Many of the ideas that we have seen
    here will be applied there. We will also see new ways of coding our applications
    and how we can use one language across the entire web ecosystem.
  prefs: []
  type: TYPE_NORMAL
