- en: Creating ECS Clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, you learned how to build a custom ECS container-instance
    Amazon Machine Image (AMI), which introduced features you will typically want
    in your production real-world use cases, including custom storage configurations,
    CloudWatch logs support, and integration with CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will put your custom machine image to work, building an
    ECS cluster composed of ECS container instances based on your custom machine image.
    Rather than take the approach of previous chapters, of discussing each of the
    various methods of configuring AWS resources, in this chapter, we will focus on
    using an infrastructure-as-code approach, and define your ECS cluster and supporting
    resources using CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: The standard model for deploying ECS clusters is based upon EC2 Auto Scaling
    groups, which consist of a group of EC2 instances that can automatically scale
    up or down based upon a variety of factors. In the use case of an ECS cluster,
    the EC2 Auto Scaling group is a collection of ECS container instances that collectively
    form an ECS cluster to which you can deploy your ECS services and ECS tasks. You
    will learn how to define EC2 auto-scaling groups, define launch configurations
    that control how your EC2 instances are deployed, and configure CloudFormation
    Init metadata, which allows you to trigger custom initialization logic at instance
    creation and wait for each of your instances to signal they have initialized successfully.
    Finally, you will configure supporting resources, such as IAM instance profiles
    and EC2 security groups, proceed to create your CloudFormation stack, and deploy
    your ECS cluster and underlying EC2 Auto Scaling group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an ECS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring EC2 Auto Scaling groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining EC2 Auto Scaling launch configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring CloudFormation Init Metadata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Auto Scaling group creation policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring EC2 Instance Profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring EC2 Security Groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and testing an ECS cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following lists the technical requirements to complete this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Administrator access to an AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local AWS profile configured as per instructions in Chapter 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch7](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch7)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch4)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2PaK6AM](http://bit.ly/2PaK6AM)'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the next two chapters is to establish the supporting infrastructure
    and resources to deploy Docker applications using AWS. In the spirit of the best
    practice of defining your infrastructure as code, you will be defining a CloudFormation
    template that will include all AWS resources required to support your Docker applications
    running in ECS. As you progress through each chapter, you will build on this template,
    slowly but surely adding more and more resources until you have a complete solution
    for deploying your Docker applications in AWS using ECS.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, the focus of this chapter is to learn how to build ECS clusters
    using CloudFormation, and as you have already learned in previous chapters, an
    ECS cluster is a collection of ECS container instances that you can target when
    you run an ECS service or ECS task.
  prefs: []
  type: TYPE_NORMAL
- en: 'ECS clusters themselves are very simple constructs - they simply define a collection
    of ECS container instances and a cluster name. How these clusters are formed,
    however, is much more involved and requires several supporting resources, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EC2 Auto Scaling group**: Defines a collection of EC2 instances with identical
    configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EC2 Auto Scaling Launch Configuration**: Defines the launch configuration
    of newly created instances in the Auto Scaling group. A launch configuration often
    includes user data scripts, which are executed by instances on first run and can
    be used to trigger the CloudFormation helper scripts you installed in your custom
    machine image in the previous chapter to interact with CloudFormation Init Metadata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFormation Init Metadata**: Defines initialization logic that each EC2
    instance in the Auto Scaling group should run on initial creation, such as running
    provisioning commands, enabling services, and creating users and groups. CloudFormation
    Init Metadata is more powerful that the provisioning capabilities offered by user
    data, and most importantly, provides a mechanism for each instance to signal to
    CloudFormation that the instance has successfully provisioned itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFormation Creation Policy**: Defines criteria that determines when CloudFormation
    can consider an EC2 Auto Scaling group as having been created successfully and
    to continue provisioning other dependencies in the CloudFormation stack. This
    is based upon CloudFormation receiving a configurable number of success messages
    from each EC2 instance that is part of the EC2 Auto Scaling group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other ways you can form ECS clusters, but for large-scale production
    environments, you generally want to use EC2 Auto Scaling groups and use CloudFormation
    and associated CloudFormation Init Metadata and Creation Policies to deploy your
    clusters in a robust, repeatable, infrastructure-as-code manner.
  prefs: []
  type: TYPE_NORMAL
- en: How each of these components work together is perhaps best described with a
    diagram, followed by a short description of how ECS clusters are formed from these
    components, after which you will proceed to learn how to perform each of the related
    configuration tasks required to create your own ECS clusters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the deployment process for creating an ECS
    cluster, assuming you are using EC2 Auto Scaling groups and CloudFormation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8fb418d5-187f-43c2-baa4-5def9d81bef0.png)ECS cluster deployment
    overview using EC2 Auto Scaling Groups and CloudFormation'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding diagram, the general approach is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As part of your CloudFormation deployment, CloudFormation determines it is ready
    to start creating the configured ECS cluster resource. The ECS cluster resource
    will be referenced in CloudFormation Init Metadata that is part of the EC2 Auto
    Scaling Launch Configuration resource, hence this ECS cluster resource must be
    created first. Note that at this point, the ECS cluster is empty and is awaiting
    ECS container instances to join the cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CloudFormation creates an EC2 Auto Scaling Launch Configuration resource, which
    defines the launch configuration that each EC2 instance in the EC2 Auto Scaling
    group will apply on instance creation. The launch configuration includes a user
    data script that invokes CloudFormation helper scripts installed on the EC2 instance,
    which in turn downloads CloudFormation Init Metadata that defines a series of
    commands and other initialization actions each instance should perform on creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the launch configuration resource has been created, CloudFormation creates
    the EC2 Auto Scaling group resource. The creation of the Auto Scaling group will
    trigger the EC2 Auto Scaling service to create a configurable desired number of
    EC2 instances in the group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As each EC2 instance launches, it applies the launch configuration, executes
    the user data script, and downloads and executes the provisioning tasks defined
    in CloudFormation Init Metadata. This will include various initialization tasks,
    and in our specific use case, the instance will execute the first run script you
    added to your custom machine image in the previous chapter, to join the configured
    ECS cluster, ensure the CloudWatch logs agent is configured to log to the correct
    CloudWatch log groups, start and enable Docker and the ECS agent, and finally,
    verify the EC2 instance successfully joined the ECS cluster and signal to CloudFormation
    that the EC2 instance was launched successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Auto Scaling group is configured with a Creation Policy, which is a special
    feature of CloudFormation that causes CloudFormation to wait until a configurable
    number of success signals is received from EC2 instances in the Auto Scaling group.
    Typically, you will configure this to be all instances in your EC2 autoscaling
    group, ensuring all instances have successfully joined the ECS cluster and are
    healthy before continuing other provisioning tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the ECS cluster in place with the correct number of ECS container instances
    derived from the EC2 Auto Scaling group, CloudFormation can safely provision other
    ECS resources that require a healthy ECS cluster to be in place. For example,
    you might create an ECS service, which will deploy your container applications
    to your ECS cluster.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining an ECS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have an overview of the ECS cluster provisioning process, let's
    step through the configuration required to get an ECS cluster up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'As indicated in the deployment overview, you will be using CloudFormation to
    create your resources in an infrastructure-as-code manner, and because you are
    right at the start of this journey, you first need to create this CloudFormation
    template, which I will assume you are defining in a file called `stack.yml` at
    the root of the **todobackend-aws** repository you created earlier in Chapter
    5 - *Publishing Docker Images Using ECR*, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Establishing the todobackend-aws repository
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now establish a skeleton CloudFormation template in the `stack.yml`
    file and create your ECS cluster resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Defining a CloudFormation template
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding example, defining an ECS cluster is very simple,
    with the `AWS::ECS::Cluster` resource type only having a single optional property
    called `ClusterName`. After ensuring your environment is configured with the correct
    AWS profile, you can now create and deploy the stack using the `aws cloudformation
    deploy` command, and verify your cluster has been created by using the `aws ecs
    list-clusters` command, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating an ECS cluster using CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an EC2 Auto Scaling group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have established an ECS cluster, but without ECS container instances to
    provide a container runtime and compute resources, the cluster is not of much
    use. At this point, you could create individual ECS container instances and join
    them to the cluster, however, such an approach is not feasible if you have the
    requirement to run production workloads that need to support tens or hundreds
    of containers, dynamically adding and removing ECS container instances to the
    cluster depending on the current resource requirements of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS mechanism to deliver such behavior for your ECS container instances
    is the EC2 Auto Scaling group, which operates as a collection of EC2 instances
    that share identical configurations referred to as launch configurations. The
    EC2 Auto Scaling service is a managed service provided by AWS, and takes care
    of managing the lifecycle your EC2 Auto Scaling groups and the EC2 instances that
    make up the group. This mechanism provides one of the core tenets of the cloud
    - elasticity - and allows you to dynamically scale up or scale down the number
    of EC2 instances that are servicing your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of ECS, you can generally think of an ECS cluster as having a
    close correlation to EC2 Auto Scaling groups, and ECS container instances as the
    EC2 instances within the EC2 Auto Scaling groups where the ECS agent and Docker
    Engine are the applications running on each EC2 instance. This is not strictly
    true, in that you can have ECS clusters that span multiple EC2 Auto Scaling groups,
    but it is typical to structure a one-to-one relationship between your ECS clusters
    and EC2 Auto Scaling groups, with a corresponding direct linkage of ECS container
    instances to EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand the basic background of EC2 Auto Scaling groups and
    how are they related specifically to ECS, it''s important to outline the various
    configuration constructs that you need to interact with when creating EC2 Auto
    Scaling groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Auto Scaling group**: Defines a collection of EC2 instances and specifies
    minimum, maximum, and desirable capacities for the group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Launch configuration**: A launch configuration defines a generic configuration
    that is applied to each EC2 instance at instance creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CloudFormation Init metadata**: Defines custom initialization logic that
    can be applied at instance creation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IAM instance profile and role**: Grants permissions to each EC2 instance
    to interact with the ECS service and publish to CloudWatch logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EC2 security groups**: Define ingress and egress network policy rules. At
    a minimum, these rules must allow the ECS agent running on each EC2 instance to
    communicate with the ECS API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that I am presenting a top-down approach of defining the requirements for
    an EC2 Auto Scaling group, which is possible when using a declarative infrastructure-as-code
    approach, such as CloudFormation. When it comes to the actual implementation of
    these resources, they will be applied in a bottom-up manner, where dependencies,
    such as security groups and IAM roles, are first created, after which the launch
    configuration, and finally the Auto Scaling group will be created. This, of course,
    is handled by CloudFormation, so we can focus on the desired state configuration
    and let CloudFormation deal with the specific imperative execution requirements
    of meeting the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EC2 Auto Scaling group
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first resource you need to define when creating EC2 Auto Scaling groups
    is the EC2 Auto Scaling group itself, which in CloudFormation terms is defined
    as a resource of the `AWS::AutoScaling::AutoScalingGroup` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defining an EC2 Auto Scaling group
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration in the preceding example is a basic configuration that meets
    the minimum requirements for defining an EC2 Auto Scaling group as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LaunchConfigurationName`: The name of the launch configuration that should
    be applied to each instance in the group. In the preceding example, we use the
    shorthand syntax of the `Ref` intrinsic function combined with the name of a resource
    called `ApplicationAutoscalingLaunchConfiguration`, which is a resource we will
    define shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MinSize`, `MaxSize`, and `DesiredCapacity`: The absolute minimum, absolute
    maximum, and desired number of instances in the Auto Scaling group. The EC2 Auto
    Scaling group will always try to maintain the desired number of instances, although
    it may temporarily scale up or scale down the number of instances based upon your
    own criteria within the bounds of the `MinSize` and `MaxSize` properties. In the
    preceding example, you reference a parameter, called `ApplicationDesiredCount`,
    to define the desired number of instances, with the ability to scale down to zero
    instances or scale up to a maximum of four instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VPCZoneIdentifier`: A list of the target subnets that EC2 instances within
    the Auto Scaling group should be deployed to. In the previous example, you reference
    an input parameter, called `ApplicationSubnets`, which is defined as a parameter
    of the `List<AWS::EC2::Subnet::Id>` type. This can be supplied as simply a comma-separated
    list, and you will shortly see an example of defining such a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags`: Defines one or more tags to attach to the Auto Scaling group. At a
    minimum, it is useful to define the `Name` tag so that you can clearly identify
    your EC2 instances, and in the preceding example, you use the short form of the
    `Fn::Sub` intrinsic function to dynamically inject the name of the stack as defined
    by the `AWS::StackName` pseudo-parameter. The `PropagateAtLaunch` tag configures
    the tag to be attached to each EC2 instance at launch, ensuring the configured
    name will be visible for each instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the AWS CloudFormation documentation ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html))
    for more information on how to configure Auto Scaling group resources.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CloudFormation Input Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, you added parameters to your CloudFormation template
    called `ApplicationDesiredCount` and `ApplicationSubnets`, which you will need
    to supply the values for when you deploy the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ApplicationDesiredCount` parameter simply needs to be a number between
    the configure MinSize and MaxSize properties (that is, between 0 and 4), however,
    to determine the value of the subnet IDs in your account, you can use the `aws
    ec2 describe-subnets` command, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Querying subnets using the AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you use a JMESPath query expression to select the
    `SubnetId` and `AvailabilityZone` properties for each subnet, and display the
    output in a table format. Here we are just leveraging the default subnets that
    are created in the default VPC for your account, but you could use any subnets
    that may be defined in your account, depending on the nature of your network topology.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will use two subnets in the `us-east-1a` and `us-east-1b`
    availability zones, and your next question might be, how do we pass these values
    to the CloudFormation stack? The AWS CLI only currently offers the ability to
    provide input parameters as key value pairs using a command-line flag in conjunction
    with the `aws cloudformation deploy` command, however, this approach quickly becomes
    tedious and unwieldy when you have a large number of stack input and want to persist
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One very simple approach we will adopt is to define the various input parameters
    within a configuration file called `dev.cfg` at the root of the `todobackend-aws`
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Defining a configuration file for stack parameters in dev.cfg
  prefs: []
  type: TYPE_NORMAL
- en: The approach with the configuration file is to add each parameter in the `<key>=<value>`
    format on a new line, and later on in this chapter, you will see how we can use
    this file in conjunction with the `aws cloudformation deploy` command. In the
    preceding example, notice that we configure the `ApplicationSubnets` parameter
    value as a comma-delimited list, which is the standard format for any List types
    when configuring CloudFormation parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Stack parameters are typically environment-specific, hence it makes sense to
    name your configuration files according to your environments. For example, if
    you had a development and production environment, you might call your configuration
    files `dev.cfg` and `prod.cfg`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an EC2 Auto Scaling launch configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you have defined an EC2 Auto Scaling group resource, you cannot yet
    deploy your CloudFormation template as the Auto Scaling group references a resource
    called `ApplicationAutoscalingLaunchConfiguration`, which is yet to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: An EC2 Auto Scaling launch configuration defines the configuration that is applied
    to each instance at launch time, and provides a common approach to ensuring each
    instance in your Auto Scaling group is consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates configuring an Auto Scaling launch configuration
    within your CloudFormation template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Defining an EC2 Auto Scaling Launch Configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that you specify a `AWS::AutoScaling::LaunchConfiguration` resource
    type and configure the following properties for your launch configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImageId`: The AMI of the image that the EC2 instance will be launched from.
    For our use case, you will use the AMI that you created in the previous chapter.
    This property references a new parameter called `ApplicationImageId`, so you need
    to add this parameter with the AMI ID of your custom machine image to the `dev.cfg`
    file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InstanceType`: The instance family and type of the EC2 instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KeyName`: The EC2 key pair that will be permitted SSH access to each EC2 instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IamInstanceProfile`: The IAM instance profile to attach to the EC2 instance.
    As you learned in earlier chapters, in order to support operation as an ECS container
    instance, the IAM instance profile must grant permissions for the EC2 instance
    to interact with the ECS service. In the previous example, you reference a resource
    called `ApplicationAutoscalingInstanceProfile`, which you will create later in
    this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecurityGroups`: The EC2 security groups to attach to each instance. These
    define the ingress and egress security rules that are applied to network traffic,
    and, at a minimum, must permit communications to the ECS service, CloudWatch logs
    service, and other associated AWS services. Again, you reference a resource called
    `ApplicationAutoscalingSecurityGroup`, which you will create later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserData`: Defines the user data script that is run upon instance creation.
    This must be supplied as a Base64-encoded string, and you can use the `Fn::Base64`
    intrinsic function to have CloudFormation automatically perform this conversion.
    You define a bash script that first runs the `cfn-init` command, which will download
    and execute CloudFormation Init metadata associated with the `ApplicationAutoscalingLaunchConfiguration`
    reference resource, and then runs the `cfn-signal` command to signal to CloudFormation
    whether or not `cfn-init` ran successfully (note that `cfn-signal` references
    the `AutoscalingGroup` resource, rather than the `ApplicationAutoscalingLaunchConfiguration`
    resource).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice the use of the `Fn::Sub` function followed by the pipe operator (`|`),
    which enables you to enter free-form text that will honour all line breaks and
    allows you to reference the correct stack name and AWS region using the `AWS::StackName`
    and `AWS::Region` pseudo-parameters.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the `set -e` flag is not set in the UserData bash script,
    and this is deliberate as we want the `cfn-signal` script to report the exit code
    of the `cfn-init` script to CloudFormation (as defined by `-e $?` option, where
    `$?` outputs the exit code of the last process). If you were to include `set -e`,
    the script would exit immediately if `cfn-init` returned an error, and `cfn-signal`
    would not be able to signal CloudFormation of the failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding the ApplicationImageId parameter to the dev.cfg file
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CloudFormation Init Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most complex piece of configuration you have performed so far in our stack
    is the `UserData` property, defined as part of the Auto Scaling launch configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall in the previous chapter when you created a custom machine image, you
    installed the `cfn-bootstrap` CloudFormation helper scripts, which include the
    `cfn-init` and `cfn-signal` scripts that are referenced in the previous example.
    These scripts are designed to work with a feature known as CloudFormation Init
    metadata, which we will configure now, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Configuring CloudFormation Init Metadata
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you can see the CloudFormation Init metadata defines
    a configuration set that includes a `commands` directive, which defines a several
    command objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`05_public_volume` - creates a folder called `public` under the `/data` mount
    that is configured in our custom ECS AMI.  We require this path as recall our
    application needs a public volume where static files will be located, and our
    application runs as a non-root user.  Later on we will create a Docker volume
    that references this path, and note that because ECS currently only supports bind
    mounts, this approach of pre-creating a folder on the underly Docker host is required
    (see [https://github.com/aws/amazon-ecs-agent/issues/1123#issuecomment-405063273](https://github.com/aws/amazon-ecs-agent/issues/1123#issuecomment-405063273)
    for more details).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`06_public_volume_permissions` - this changes the ownership on the `/data/public`
    folder created in the previous command to be owned by the user and group with
    an ID of 1000.  This is the same user ID/group ID that the todobackend application
    runs as, so will allow the application to read and write to the `/data/public`
    folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10_first_run` -  runs the `sh firstrun.sh` command in the working directory
    of `/home/ec2-user`, which recall from the previous chapter refer to the first
    run script you included in your custom machine image to perform custom initialization
    tasks at instance creation. This first run script includes references to a number
    of environment variables, which are defined in the CloudFormation Init metadata
    under the `env` property and supply the appropriate values to the first run script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate further how the `10_first_run` script works, the following snippet
    configures the ECS container instance to join an ECS cluster as defined by the
    `ECS_CLUSTER` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First run script snippet
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `STACK_NAME`, `AUTOSCALING_GROUP`, and `AWS_DEFAULT_REGION`
    variables are all used to configure the CloudWatch logs agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: First run script snippet
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Auto Scaling group creation policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you configured a user data script and CloudFormation
    Init metadata so that your ECS container instances can perform first time initialization
    and configuration appropriate to the given target environment. Although each instance
    will signal CloudFormation of success or failure of the CloudFormation Init process,
    you need to configure CloudFormation explicitly to wait for each instance in the
    Auto Scaling group to signal success, which is important if you want to ensure
    you don't attempt to try and deploy ECS services to your ECS clusters before they
    have registered with the ECS cluster or if they fail for some reason.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation includes a feature referred to as creation policies, which allow
    you to specify optional creation success criteria when creating EC2 Auto Scaling
    groups and EC2 instances. When a creation policy is attached to an EC2 Auto Scaling
    group, CloudFormation will wait for a configurable number of instances in the
    Auto Scaling group to signal success before proceeding, which provides us with
    a powerful capability to ensure your ECS Auto Scaling groups and corresponding
    ECS clusters are in a healthy state, before proceeding to create other resources
    in your CloudFormation stack. Recall in the previous chapter that the final step
    of the first run script in your custom machine image is to query the local ECS
    agent metadata to verify the instance has joined to the configured ECS cluster,
    so if the first run script completes successfully and cfn-signal signals success
    to CloudFormation, we know that the instance has been successfully registered
    to the ECS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates configuring a creation policy on your existing
    EC2 Auto Scaling group resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Configuring a Creation Policy in CloudFormation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding example, creation policies are configured using
    the `CreationPolicy` attribute, and at the time of writing, these policies can
    only be configured for EC2 Auto Scaling group resources, EC2 instance resources
    and another special type of CloudFormation resource call wait conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The `ResourceSignal` object includes a `Count` property that defines the minimum
    number of success signals required to determine whether the Auto Scaling group
    has been created successfully, and you reference the `ApplicationDesiredCount`
    parameter, meaning you expect all instances in the Auto Scaling group to be created
    successfully. The `Timeout` property defines the maximum amount to time to wait
    for all success signals - if the configured count is not met within this time
    frame, then the Auto Scaling group will be considered to not have created successfully
    and stack deployment will fail and roll back. This property is configured using
    a special format called **ISO8601 duration format**, and the value of `PT15M`
    means CloudFormation will wait up to 15 minutes for all success signals.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring EC2 instance profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the EC2 Auto Scaling launch configuration you defined in the previous example,
    you referenced an IAM instance profile, which we need to create as a separate
    resource in our stack. EC2 instance profiles allow you to attach an IAM role,
    which your EC2 instances can use to gain access to AWS resources and services,
    and in the ECS container instance use case. Recall from Chapter 4, when you created
    your first ECS cluster, that an IAM instance profile and associated IAM role that
    granted various ECS permissions was automatically attached to your ECS container
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are configuring our ECS cluster and Auto Scaling group from scratch,
    we need to explicitly define an appropriate IAM instance profile and linked IAM
    role, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Defining an IAM instance profile and IAM role
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, rather than attach the `AmazonEC2ContainerServiceforEC2Role`
    managed policy, you attach a custom policy that defines a similar set of permission,
    noting the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The permission to create a cluster is not granted, as you are already creating
    the ECS cluster yourself within the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The permissions to register, deregister, and update container instance states
    are limited to the ECS cluster defined in your stack. In contrast, the `AmazonEC2ContainerServiceforEC2Role`
    role grants this permission to all clusters in your account, so your custom configuration
    is considered more secure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom policy grants the `logs:CreateLogGroup` permission - this is required
    as the CloudWatch logs agent expects this permission, even if the log group has
    already been created. In the preceding example, we constrain this permission to
    log groups that are prefixed with the current stack name, limiting the scope of
    these permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring EC2 security groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have almost completed the required configuration to be able to deploy your
    ECS cluster and EC2 Auto Scaling group, however one final resource we need to
    create is the `ApplicationAutoscalingSecurityGroup` resource, which you referenced
    earlier in the `ApplicationAutoscalingLaunchConfiguration` resource configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Defining an EC2 Security Group
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you permit inbound SSH access to your instances, and
    allow your instances to access DNS, HTTP, and HTTPS resources on the internet.
    This is not the most secure security group configuration, and in a production
    use case, at a minimum, you would limit SSH access to internal management addresses,
    but for the purposes of keeping things simple and accessible for demonstration
    purposes, you configure a reasonably lax set of security rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that you also define a new parameter, called VPC ID, which specifies
    the ID of the VPC that the security group will be created in, and you can use
    the `aws ec2 describe-vpcs` command to obtain the ID of the default VPC that is
    created by default in your AWS account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Determining your VPC ID
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the correct VPC ID value, you need to update your `dev.cfg` file
    to include the `VpcId` parameter and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the VpcId parameter in dev.cfgA more scalable approach to looking
    up the physical identifiers of external resources that your stack has dependencies
    on is to use a feature referred to as CloudFormation exports, which allow you
    to export data about a resource to other stacks. For example, you might define
    all of your networking resources in a stack called network-resources, and then
    configure a CloudFormation export that exports the VPC ID of VPC resources created
    by that stack. These exports can then be referenced in other CloudFormation stacks
    by using the `Fn::ImportValue` intrinsic function. See [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-exports.html)
    for more details on this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and testing an ECS cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have now completed the configuration of your CloudFormation template, and
    it''s time to deploy the changes you made in the previous section. Recall that
    you created a separate configuration file, called `dev.cfg`, to store values for
    each stack parameter. The following example demonstrates how you can now use the
    `aws cloudformation deploy` command to deploy your updated stack and reference
    your input parameter values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Deploying a CloudFormation Stack with parameter overrides
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you use the `--parameter-overrides` flag to specify
    values for each of the parameters your template expects. Rather than type these
    out manually each time, you simply use a bash substitution and list the contents
    of the local `dev.cfg` file, which expresses each parameter name and value in
    the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that because your CloudFormation stack now includes IAM resources,
    you must specify the `--capabilities` flag with a value of either `CAPABILITY_IAM`
    or `CAPABILITY_NAMED_IAM`. When you do this, you are acknowledging that CloudFormation
    will be creating IAM resources on your behalf and that you grant permission. Although
    you only need to specify the `CAPABILITY_NAMED_IAM` value if you are creating
    named IAM resources (which we are not), I find it is just more universal and less
    error-prone to always reference this value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming your template has no configuration errors, your stack should deploy
    successfully and if you browse to the CloudFormation in the AWS console selecting
    the todobackend stack, you can review the various events that took place during
    stack deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/236fe068-06d9-4685-862c-a553d2b7494c.png)Viewing CloudFormation
    deployment status'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that CloudFormation starts creating
    an Auto Scaling group at `20:18:56`, and then just over a minute and a half later,
    at `20:20:39`, receives a SUCCESS signal from the single EC2 instance in the Auto
    Scaling group. This meets the creation policy criteria of receiving the desired
    count of instances, and the stack update completes successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your ECS cluster should have a single ECS container instance
    registered and active, and you can use the `aws ecs describe-cluster` command
    to verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Verifying an ECS cluster
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, you can see that the ECS cluster had a single registered
    ECS container instance and the status of the cluster is ACTIVE, meaning your ECS
    cluster is ready to run your ECS tasks and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also verify that your EC2 Auto Scaling group was created correctly
    by navigating to the EC2 console, and selecting Auto Scaling Groups from the left-hand
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2447a1eb-c0bf-4d72-871f-0473731f994e.png)Verifying EC2 Auto Scaling
    Groups'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, notice that the name of your Auto Scaling group
    includes the stack name (`todobackend`), logical resource name (`ApplicationAutoscaling`),
    and a random string value (`XFSR1DDVFG9J`). This illustrates an important concept
    of CloudFormation - if you don't name your resources explicitly (assuming the
    resource has a `Name` or equivalent property), then CloudFormation will append
    a random string to ensure resources are named uniquely.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have followed along and configured your stack without any errors, then
    your CloudFormation stack should deploy successfully, as demonstrated in previous
    screenshots. Chances are that, with a CloudFormation template with ~150 lines
    of configuration, there is a possibility you will make an error and your CloudFormation
    deployment will fail. If you do get stuck and can''t resolve a deployment issue,
    refer to the this GitHub URL as a reference: [https://github.com/docker-in-aws/docker-in-aws/blob/master/ch7/todobackend-aws](https://github.com/docker-in-aws/docker-in-aws/blob/master/ch7/todobackend-aws)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create an ECS cluster, complete with an
    EC2 Auto Scaling group and ECS container instances based on a custom Amazon machine
    image, using an infrastructure-as-code approach to define all resources using
    CloudFormation.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how an ECS cluster is simply a logical grouping of ECS container
    instances, and is composed of EC2 Auto Scaling groups that manage a collection
    of EC2 instances. EC2 Auto Scaling groups can dynamically scale up and down, and
    you attached an EC2 Auto Scaling launch configuration to your Auto Scaling group,
    which provides a common collection of settings applied to each new EC2 instance
    that is added to the group.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation provides powerful features for ensuring instances in your Auto
    Scaling groups are initialized correctly, and you learned how you to configure
    user data to invoke the CloudFormation helper scripts you installed in your custom
    machine image, which then download configurable initialization logic defined in
    CloudFormation Init metadata that is attached to your launch configuration resources.
    Once the CloudFormation Init process is complete, the helper scripts signal success
    or failure of the initialization process to CloudFormation, and you configured
    a creation policy for your Auto Scaling group that defined the required number
    of instances that must report success for the overall Auto Scaling group resource
    to be considered healthy.
  prefs: []
  type: TYPE_NORMAL
- en: You next attached an IAM instance profile and security group to your launch
    configuration, ensuring your ECS container instances have necessary permissions
    to interact with the ECS service, download images from ECR, publish logs to CloudWatch
    logs, and communicate with the relevant AWS API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: With the core Auto Scaling group, launch configuration, and other supporting
    resources in place, you successfully deployed your cluster using CloudFormation,
    establishing the necessary infrastructure foundations required to run your ECS
    tasks and services. In the next chapter, you will build on this foundation, extending
    your CloudFormation template to define ECS task definitions, ECS services, and
    other supporting resources required to deploy a complete end-to-end application
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True/false: An EC2 Auto Scaling group allows you to define a fixed IP address
    for each instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of encoding needs to be applied to EC2 user data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you refer to the current AWS region in your CloudFormation templates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: The `Ref` intrinsic function can only refer to resources in a CloudFormation
    template.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using CloudFormation Init metadata, which two helper scripts do you need
    to run on your EC2 instances?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are attempting to create an EC2 Auto Scaling group and ECS cluster using
    the standard ECS-optimized AMI published by Amazon, however you receive errors
    indicating no instances are registered to a target ECS cluster even though CloudFormation
    reports the Auto Scaling group has been created. How might you fix this problem?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True/false: The `aws cloudformation create` command is used for deploying and
    updating CloudFormation stacks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are attempting to deploy an ECS cluster in a private subnet with no default
    internet route, however the ECS container instances within the cluster fail to
    register to ECS. What is the most likely explanation for this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'CloudFormation EC2 Auto Scaling group Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-group.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation EC2 Auto Scaling Launch Configuration Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-launchconfig.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-as-launchconfig.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation IAM Instance Profile Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-instanceprofile.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation IAM Role Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation EC2 Security Group Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supported Resource-Level Permissions for Amazon ECS API Actions: [https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-supported-iam-actions-resources.html](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-supported-iam-actions-resources.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation Helper Scripts: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-helper-scripts-reference.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-helper-scripts-reference.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation Init Metadata Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-init.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-init.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CloudFormation Creation Policy Attribute: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-creationpolicy.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-creationpolicy.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
