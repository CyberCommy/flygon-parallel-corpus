- en: Chapter 12. Connecting Our Kotlin to the UI and Nullability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, the missing link between our Kotlin code and our
    XML layouts will be fully revealed, leaving us with the power to add all kinds
    of widgets and UI features to our layouts as we have done before, but this time
    we will be able to control them through our code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take control of some simple UI elements, such as `Button`
    and `TextView`, and, in the next chapter, we will take things further and manipulate
    a whole range of UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: To enable us to understand what is happening, we need to find out a bit more
    about the memory in an app, and two areas of it in particular – the **Stack**
    and the **Heap**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Android UI elements are classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our UI is on the Heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nullability – val and var revisited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to different types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare to make your UI come to life.
  prefs: []
  type: TYPE_NORMAL
- en: All the Android UI elements are classes too
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our app is run and the `setContentView` function is called from the `onCreate`
    function, the layout is **inflated** from the XML UI, and is loaded into memory
    as usable objects. They are stored in a part of the memory called the Heap.
  prefs: []
  type: TYPE_NORMAL
- en: But where is this Heap place? We certainly can't see the UI instances in our
    code. And how on earth do we get our hands on them?
  prefs: []
  type: TYPE_NORMAL
- en: The operating system inside every Android device takes care of memory allocation
    to our apps. In addition, it stores different types of variables in different
    places.
  prefs: []
  type: TYPE_NORMAL
- en: Variables that we declare and initialize in functions are stored in an area
    of memory known as the Stack. We already know how we can manipulate variables
    on the Stack with straightforward expressions. So, let's talk about the Heap some
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Important fact: all objects of classes are reference type variables and are
    just references to the actual objects that are stored on the Heap – they are not
    the actual objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Think of the Heap as a separate area of the same warehouse as where our regular
    variables are stored. The Heap has lots of floor space for odd-shaped objects,
    racks for smaller objects, lots of long rows with smaller sized cubby holes, and
    so on. This is where objects are stored. The problem is that we have no direct
    access to the Heap. Think of it as a restricted access part of the warehouse.
    You can't actually go there, but you can *refer* to what is stored there. Let's
    look at what a reference variable really is.
  prefs: []
  type: TYPE_NORMAL
- en: It is a variable that we refer to and use via a reference. A reference can be
    loosely, but usefully, defined as an address or location. The reference (address
    or location) of the object is on the Stack.
  prefs: []
  type: TYPE_NORMAL
- en: So, when we use the dot operator, we are asking the OS to perform a task at
    a specific location, a location that is stored in the reference.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reference variables are just that – a reference. They are a way to access and
    manipulate the object (properties and functions), but they are not the actual
    object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we ever want a system like this? Just give me my objects on the Stack,
    already! Here is why.
  prefs: []
  type: TYPE_NORMAL
- en: A quick break to throw out the trash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is what the whole Stack and Heap thing does for us.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the operating system keeps track of all our objects for us and stores
    them in a devoted area of our warehouse called the Heap. While our app is running,
    the operating system will regularly scan the Stack, the regular racks of our warehouse,
    and match up references to objects that are on the Heap. Any objects it finds
    without a matching reference, it destroys. Or, in correct terminology, it **garbage
    collects**.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a very discerning refuse vehicle driving through the middle of our
    Heap, scanning objects to match up to references (on the Stack). No reference
    means it is garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: If an object has no related reference variable, we can't possibly do anything
    with it anyway because we have no way to access it/refer to it. This system of
    garbage collection helps our apps run more efficiently by freeing up unused memory.
  prefs: []
  type: TYPE_NORMAL
- en: If this task was left to us, our apps would be much more complicated to code.
  prefs: []
  type: TYPE_NORMAL
- en: So, variables declared inside a function are local, on the Stack, and are only
    visible within the function where they were declared. A property (of an object)
    is on the Heap, and can be referenced from anywhere where there is a reference
    to it, and if the access modifier (encapsulation) allows.
  prefs: []
  type: TYPE_NORMAL
- en: Seven useful facts about the Stack and the Heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at what we have learned about the Stack and the Heap:'
  prefs: []
  type: TYPE_NORMAL
- en: You don't delete objects, but the operating system sends the garbage collector
    when it thinks it is appropriate. This is usually when there is no active reference
    to an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables are on the Stack, and are local to the specific function within which
    they were declared.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties are on the Heap (with their object/instance), but the reference to
    the object/instance (its address) is a local variable on the Stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We control what goes onto the Stack. We can use the objects on the Heap, but
    only by referencing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Heap is kept clear and up-to-date by the garbage collector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object is garbage collected when there is no longer a valid reference to
    it. So, when a reference variable is removed from the Stack, then its related
    object becomes viable for garbage collection. And, when the operating system decides
    the time is right (usually very promptly), it will free up the RAM memory to avoid
    running out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we managed to reference an object that didn't exist, we will get a **NullPointerException**
    error, and the app will crash. One of the major features of Kotlin is that it
    protects us from this occurring. In Java, which Kotlin is trying to improve upon,
    a **NullPointerException error** is the most common cause of an app crashing.
    We will learn more about how Kotlin helps us avoid **NullPointerException** errors
    in the section near the end of this chapter called *Nullability –* `val` *and*
    `var` *revisited*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's move on and see exactly what this information buys us in terms of taking
    control of our UI.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this Heap thing help me?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any UI element that has its `id` attribute set in the XML layout can have its
    reference retrieved from the Heap and used, just as we can with the classes we
    wrote and declared ourselves over the previous two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a project with a Basic Activity template (feel free to do so,
    but you don''t need to), drag a button on to the UI, infer the constraints, and
    run the app on an emulator. We will then get what we see in this next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![So, how does this Heap thing help me?](img/B12806_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is what we should expect from what we have already seen in the first five
    chapters. If we added this line of code to the `onCreate` function, then something
    interesting will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app again and observe the change in the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![So, how does this Heap thing help me?](img/B12806_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have changed the text on the button.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, if you have previously programmed Android using Java, you might
    want to lie down for a few minutes and contemplate how easy life will be from
    now on.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite exciting, because it shows we can grab a reference to a whole
    bunch of stuff from our layout. We can then start using all the functions and
    properties that these objects have that are provided by the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: The `button` instance in the code refers to the `id` of the `Button` widget
    in the XML layout. The `text` instance in our code then refers to the `text` property
    of the `Button` class, and the `= "WOO HOO!"` text in our code uses the setter
    of the `text` property to change the value it holds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Button` class (or an other UI element) had a different `id` value, then
    we would need to adjust our code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: If you think that after eleven chapters we are finally going to start doing
    some neat stuff with Android, you would be right!
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about another aspect of OOP, and then we will be able to build our
    most functional app so far.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface is like a class. Phew! Nothing complicated here then. But, it's
    like a class that is always abstract, and only has abstract functions.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of an interface as an entirely abstract class, with all its functions
    and properties being abstract. When a property is abstract, it does not hold a
    value. It has no backing field for the property. However, when another class implements
    (uses) the interface, it must override the property, and therefore provide the
    backing field for storing a value.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, interfaces are stateless classes. They provide an implementation
    template without any data.
  prefs: []
  type: TYPE_NORMAL
- en: OK, so you can just about wrap your head round an abstract class, because at
    least it can pass on some functionality in its functions and some state in its
    properties that are not abstract and serve as a polymorphic type.
  prefs: []
  type: TYPE_NORMAL
- en: But, seriously, this interface seems a bit pointless. Let's look at the simplest
    possible example of an interface, then we can discuss it further.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an interface, we type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The functions of an interface have no body, because they are abstract, but they
    can still have return types and parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an interface, we use the same `:` syntax after the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the property and the function has been overridden in
    the class that implements the interface. The compiler forces the user of an interface
    to do this, or else the code will not compile.
  prefs: []
  type: TYPE_NORMAL
- en: If you are inheriting from a class at the same time as implementing one or more
    interfaces, then the super class simply goes into the list with the interface(s).
    It is convention, to make the different relationships clear, to put the super
    class first in the list. This is, however, not required by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. If a class implements an interface,
    the whole thing can be passed along or used as if it is that thing, because it
    is that thing. It is polymorphic (many things).
  prefs: []
  type: TYPE_NORMAL
- en: We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface, and be sure to override all the
    necessary functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will use the interfaces of the Android API more often than
    we write our own. In the next section, one such interface we will use is the `OnClickListener`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Many things might like to know when they are being clicked, such as a `Button`
    widget or a `TextView` widget. So, using an interface, we don't need different
    functions for every type of UI element we might like to click.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at an interface in action at the same time as connecting our
    Kotlin code with the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Using buttons and TextView widgets from our layout with a little help from interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with this project, create a new Android Studio project, call
    it `Kotlin Meet UI`, and choose the **Empty Activity** template. You can find
    the code and the XML layout code in the `Chapter12``/Kotlin Meet UI` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build a simple UI by observing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the editor window of Android Studio, switch to `activity_main.xml` and make
    sure you are on the **Design** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the auto-generated `TextView`, the one that reads "Hello world!".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **TextView** widget to the top-center of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **text** property to `0`, its `id` property to `txtValue`, and its `textSize`
    to `40sp`. Pay careful attention to the case of the `id` value. It has an uppercase
    `V`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, drag and drop six buttons on to the layout so that it looks a bit like
    the following diagram. The exact layout isn't important:![Using buttons and TextView
    widgets from our layout with a little help from interfaces](img/B12806_12_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the layout is how you want it, click the **Infer Constraints** button to
    constrain all the UI items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double left-click on each button in turn (left-to-right, and then top-to-bottom),
    and set the `text` and `id` properties, as shown in the following table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| The `text` property | The `id` property |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | `btnAdd` |'
  prefs: []
  type: TYPE_TB
- en: '| `take` | `btnTake` |'
  prefs: []
  type: TYPE_TB
- en: '| `grow` | `btnGrow` |'
  prefs: []
  type: TYPE_TB
- en: '| `shrink` | `btnShrink` |'
  prefs: []
  type: TYPE_TB
- en: '| `hide` | `btnHide` |'
  prefs: []
  type: TYPE_TB
- en: '| `reset` | `btnReset` |'
  prefs: []
  type: TYPE_TB
- en: 'When you''re done, your layout should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The precise position and text on the buttons are not very important, but the
    values given to the `id` properties must be the same. The reason for this is that
    we will be using these `id` values to get a reference to the `Button` instances
    and the `TextView` instance in this layout from our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **MainActivity.kt** tab in the editor and find the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now amend the line of code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you type, you will get a pop-up list asking you to choose an interface to
    implement. Choose **OnClickListener (android.view.view)**, as shown in the next
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will need to import the `View` class. Be sure to do this before continuing
    with the next step, or you will get confusing results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `MainActivity` declaration is underlined in red, showing an
    error. Now, because we have made `MainActivity` into `OnClickListener` by adding
    it as an interface, we must implement the abstract function of `OnClickListener`.
    The function is called `onClick`. When we add the function, the error will be
    gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get Android Studio to add it for us by left-clicking anywhere on the
    code containing the error, and then by using the keyboard combination *Alt* +*Enter*.
    Left-click **Implement members**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, left-click **OK** to confirm we want Android Studio to add the `onClick`
    method/function. The error is gone, and we can carry on adding code. We also have
    an `onClick` function, and we will soon see what we will do with that.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A quick note on terminology. A **method** is a function that is implemented
    in a class. Kotlin allows programmers to implement functions independent of a
    class, so all methods are functions but not all functions are methods. I chose
    to refer to all functions/methods throughout this book as functions. There is
    an argument that method would have been a more precise term, but in the context
    of this book, either is correct. You can call functions in classes methods if
    you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following property inside the class declaration but outside/before
    any functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have declared an `Int` property called `value` and initialized it to `0`.
    Notice that it is a `var` property because we need to change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, inside the `onCreate` function, add the following six lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the *Alt* +*Enter* keyboard combination to import all the `Button` and
    `TextView` instances from the `activity_main.xml` layout file. Or, manually add
    the following import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets up our app to listen for clicks on the buttons in the
    layout. Each line of code does the same thing but on a different button. For example,
    `btnAdd` refers to the button in our layout with the `id` property value of `btnAdd`,
    and `btnTake` refers to the button in our layout with the `id` property value
    of `btnTake`.
  prefs: []
  type: TYPE_NORMAL
- en: Each button instance then calls the `setOnClickListener` function on itself.
    The argument passed in is `this`. Remember from [Chapter 10](ch10.html "Chapter 10. Object-Oriented
    Programming"), *Object-Oriented Programming*, `this` refers to the current class
    where the code is written. Therefore, in the preceding code, `this` refers to
    `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: The `setOnClickListener` function sets up our app to call the `onClick` function
    of the `OnClickListener` interface. Now, whenever one of our buttons gets clicked,
    the `onClick` function will be called. All this works because `MainActivity` implements
    the `OnClickListener` interface.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to verify this, temporarily delete the `View.OnClickListener` code
    from the end of the class declaration, and our code will suddenly be riddled with
    a sea of red errors. This is because `this` is no longer of the `OnCLickListener`
    type, and therefore it cannot be passed to the `setOnClickListener` function of
    the various buttons, and the `onClick` function will also show an error because
    the compiler has no idea what we are trying to override. The interface is what
    makes all this functionality come together.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Replace the `View.OnClickListener` at the end of the class declaration if you
    previously removed it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, scroll down to the `onClick` function that Android Studio added for us
    after we implemented the `OnClickListener` interface. Add the `Float size` variable
    declaration and an empty `when` block inside it so it looks like this next code.
    The new code to add is highlighted next. There is one more thing to notice and
    implement in the next code. When the `onClick` function was autogenerated by Android
    Studio, a question mark was added after the `v: View?` parameter. Remove the question
    mark, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `when` will check for a matching value to an expression. The `when`
    condition is `v.id`. The `v` variable is passed to the `onClick` function, and
    `v.id` identifies the `id` property of whichever button was clicked. It will match
    the `id` of one of our buttons in the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are wondering about that curious question mark that we deleted, it will
    be explained in the next section: *Nullability – val and var revisited.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do next is handle what happens for each button. Add this next
    block of code inside the opening and closing curly brackets of the `when` expression,
    and then we will go through and discuss it. Try and work out the code for yourself
    first, as you will be pleasantly surprised how much we already understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is that first line of code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`View` is the parent class for `Button`, `TextView`, and more. So, perhaps
    as we might expect, using `v.id` will return the `id` attribute of the UI widget
    that has been clicked, and which triggered the call to `onClick` in the first
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do then is provide a `when` statement (and an appropriate action)
    for each of the `Button` id values we want to respond to. Here is that part of
    the code again for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Have another look at the next part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is the first three `when` branches. They handle `R.id.btnAdd`,
    `R.id.btnTake`, and `R.id.btnReset`.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `R.id.btnAdd` branch simply increments the `value` variable,
    and then it does something new.
  prefs: []
  type: TYPE_NORMAL
- en: It sets the `text` property of the the `txtValue` object. This has the effect
    of causing this `TextView` to display whatever value is stored in `value`.
  prefs: []
  type: TYPE_NORMAL
- en: The **TAKE** button (`R.id.btnTake`) does exactly the same, only it subtracts
    one from `value` instead of adding one.
  prefs: []
  type: TYPE_NORMAL
- en: The third branch of the `when` statement handles the **RESET** button, sets
    `value` to zero, and again updates the `text` property of `txtValue`.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of whichever `when` branch is executed, the entire `when` block is
    exited, the `onClick` function returns, and life goes back to normal – until the
    user's next click.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to examine the next two branches of the `when` block. Here they
    are again for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The next two branches handle the **SHRINK** and **GROW** buttons from our UI.
    We can confirm this from the id's `R.id.btnGrow` value and `R.id.btnShrink` value.
    What is new, and more interesting, are the getter and setter of the `TextView`
    class that are used on the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: The getter of the `textScaleX` property returns the horizontal scale of the
    text within the object it is used on. We can see that the object it is used on
    is our `TextView txtValue` instance. The `size =` code at the start of the line
    of code assigns that returned value to our `Float` variable `size`.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code in each `when` branch changes the horizontal scale of
    the text using the setter of the `textScaleX` property. When the **GROW** button
    is pressed, the scale is set to `size + 1`, and when the **SHRINK** button is
    pressed, the scale is set to `size - 1`.
  prefs: []
  type: TYPE_NORMAL
- en: The overall effect is to allow these two buttons to grow and shrink the text
    in `txtValue` by a scale of `1` on each click.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the final branch of the `when` code. Here it is again for your
    convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code takes a little bit of explaining, so let''s take it a step
    at a time. First, there is an `if` – `else` expression nested inside the `when`
    branch. Here is the `if` part again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The condition to be evaluated is `txtValue.visibility == View.VISIBLE`. The
    first part of that, before the `==` operator, uses the `visibility` property's
    getter to return the value describing whether or not the `TextView` is currently
    visible. The return value will be one of three possible constant values as defined
    in the `View` class. They are `View.VISIBLE`, `View.INVISIBLE,` and `View.GONE`.
  prefs: []
  type: TYPE_NORMAL
- en: If `TextView` is visible to the user on the UI, the getter returns `View.VISIBLE`,
    the condition is evaluated as `true,` and the `if` block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `if` block, we use the `visibility` property's setter and make it
    invisible to the user with the `View.INVISIBLE` value.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we change the text on the `btnHide` object to **SHOW**
    using the `text` property's setter.
  prefs: []
  type: TYPE_NORMAL
- en: After the `if` block has executed, `txtValue` will be invisible, and we have
    a button on our UI that says **SHOW**. When the user clicks on it in this state,
    the `if` statement will be false and the `else` block will execute. In the `else`
    block, we reverse the situation. We set the `txtValue` object's `visibility` property
    back to `View.VISIBLE`, and the `text` property on `btnHide` back to **HIDE**.
  prefs: []
  type: TYPE_NORMAL
- en: If this is in any way unclear, just enter the code, run the app, and revisit
    this last code and explanation once you have seen it in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the UI and the code in place, so it is now time to run the app and
    try out all the buttons. Notice that the **ADD** and **TAKE** buttons change the
    value of `value` by one in either direction, and then display the result in the
    `TextView`. In this next image, I have clicked the **ADD** button three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the **SHRINK** and **GROW** buttons increase the width of the text,
    and **RESET** sets the `value` variable to zero and displays it on the `TextView`.
    In the following screenshot, I have clicked the **GROW** button eight times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the **HIDE** button not only hides the `TextView,` but changes its
    own text to **SHOW**, and will, indeed, re-show the `TextView` if tapped again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I will not bother you by showing you an image of something that is hidden. Be
    sure to try the app in an emulator as well as following along with the book. If
    you are wondering about the difference between `View.INVISIBLE` and `View.GONE`,
    `INVISIBLE` simply hides the object, but when `GONE` is used the layout behaves
    as if the object was never there, so can affect the layout of the remaining UI.
    Change the line of code from `INVISIBLE` to `GONE` and run the app to observe
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there was no need for `Log` or `Toast` in this app, as we are finally
    manipulating the UI using our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Nullability – val and var revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we declare an instance of a class with `val` it does not mean we cannot
    change the value held in the properties. What determines whether we can reassign
    the values held by the properties is whether the properties themselves are `val`
    or `var`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we declare an instance of a class with `val`, it just means we cannot
    reassign another instance to it. When we want to reassign to an instance, we must
    declare it with `var`. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding hypothetical code, an instance called `someInstance` is declared,
    and it is of the `SomeClass` type. It is declared as `val`. The three lines of
    code that follow suggest that, if its properties were declared with `var` we can
    change those properties, but, as we have already learned, when the property is
    declared with `val` we cannot change it. So, what exactly does declaring an instance
    with `val` or `var` mean? Look at this next hypothetical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes clear that when an instance is a `val`, it cannot be
    reassigned to refer to a different object on the heap, but when it is `var` it
    can. Whether an instance is `val` or `var` does not affect whether its properties
    are `val` or `var`.
  prefs: []
  type: TYPE_NORMAL
- en: We have already learned when discussing properties that, if we don't need to
    change a value, it is good practice to declare as `val`. The same is true for
    objects/instances. If we don't need to reassign an instance, we should declare
    it as `val`.
  prefs: []
  type: TYPE_NORMAL
- en: Null objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we declare an object or property as `var`, we have the option not to initialize
    it immediately, and sometimes this is what we need. When we don''t initialize
    an object, it is called a **null reference**, because it doesn''t refer to anything.
    We often need to declare an object but not initialize it until our app is running,
    but this can cause a problem. Look at some more hypothetical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have declared a new instance of `SomeClass` called
    `someInstance5`, but we have not initialized it. Now, look at this screenshot
    to see what happens when we try to use this instance before we have initialized
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Null objects](img/B12806_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The compiler will not allow us to do this. When we need to initialize an instance
    during program execution, we must specifically initialize it as `null` so that
    the compiler knows it is intentional. Furthermore, when we initialize an instance
    as `null`, we must use the **nullable operator**. Look at the next hypothetical
    code that fixes the problem we have just seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the nullable operator is used on the end of the `SomeClass?`
    type, and the instance is initialized to `null`. When we use the nullable operator
    we can think of the instance as being a different type – *SomeClass nullable*
    as opposed to just *SomeClass*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we could initialize the instance whenever we need to in our code. We
    will see some real examples of this starting in [Chapter 14](ch14.html "Chapter 14. Android
    Dialog Windows"), *Android Dialog Windows*, and throughout the rest of the book,
    but for now, here is a hypothetical way we might conditionally initialize this
    null object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We could then proceed to use `someInstance5` as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Safe call operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes we need more flexibility. Suppose that we need the value of one of
    the properties in `someInstance5`, but it is not possible to guarantee that it
    has been initialized? In this situation we can use the **safe call** `?` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, if `someInstance5` has been initialized, the value stored
    in the `someImmutable` property will be used to initialize `someInt`. If it hasn't
    been initialized, then `someInt` will be initialized with null. Note, therefore,
    that `someInt` is inferred to be of the `Int` nullable type, not plain `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: Non null assertion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There will arise situations where we cannot guarantee, at compile time, that
    the instance is initialized, and it is not possible to satisfy the compiler that
    it will be. When this is the case, we must assert that the object is not null
    with the **non-null assertion** `!!` operator. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, it is possible that `someInstance5` might not have been
    initialized, and we used the non-null assertion operator, or the code would not
    have compiled.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that, if we write some faulty logic and the instance is still null
    when we use it, then the app will crash. In fact, the `!!` operator should be
    used as infrequently as possible, as the safe call operator is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Nullability in review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to nullability than we have covered so far. It is possible to
    write many pages discussing the different usages of the different operators, and
    there are more of these as well. The point is that Kotlin is designed to help
    us avoid crashes due to null objects whenever possible. It is much more instructive,
    however, to see nullable types, the safe call operator, and the non-null assertion
    operator in action than it is to theorize about them. We will bump into all three
    of them regularly throughout the book, when hopefully their context will be more
    instructive than their theory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finally had some real interaction between our code and our
    UI. It turns out that every time we add a widget to our UI, we are adding a Kotlin
    instance of a class that we can access with a reference in our code. All these
    objects are stored in a separate area of memory called the Heap – along with any
    instances of classes of our own.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position where we can learn about and do cool things with some
    of the more interesting widgets. We will look at loads of them in the next chapter,
    [Chapter 13](ch13.html "Chapter 13. Bringing Android Widgets to Life"), *Bringing
    Android Widgets to Life*, and we will also keep introducing new widgets throughout
    the rest of the book.
  prefs: []
  type: TYPE_NORMAL
