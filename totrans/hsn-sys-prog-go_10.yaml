- en: Handling Processes and Daemons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to how to handle the properties of the current
    process using the Go standard library, and how to change them. We will also focus
    on how to create child processes and give an overview of the `os/exec` package.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will explain what daemons are, what properties they have, and how
    to create them using the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Child processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning with daemons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, you can refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml), *An
    Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen the importance of processes in the Unix operating system,
    so now we will look at how to obtain information on the current process and how
    to create and handle child processes.
  prefs: []
  type: TYPE_NORMAL
- en: Current process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library allows us to get information on the current process.
    This is done by using a series of functions that are available in the `os` package.
  prefs: []
  type: TYPE_NORMAL
- en: Standard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first two things that a program may want to know are its identifier and
    the parent identifier, that is, PID and PPID. This is actually pretty straightforward
    – the `os.Getpid()` and `os.Getppid()` functions both return an integer value
    with both of the identifiers, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/ng0m9y4LcD5](https://play.golang.org/p/ng0m9y4LcD5).
  prefs: []
  type: TYPE_NORMAL
- en: User and group ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another piece of information that can be handy is the current user and the groups
    that the process belongs to. A typical user case could be to compare them with
    a file-specific permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` package offers the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.Getuid()`: Returns the user ID of the process owner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Getgid()`: Returns the group ID of the process owner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.Getgroups()`: Returns additional group IDs of the process owner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can see that these three functions return IDs in their numerical form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/EqmonEEc_ZI](https://play.golang.org/p/EqmonEEc_ZI).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get the names of users and groups, there are some helper functions
    in the `os/user` package. These functions (with a pretty self-explanatory name)
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func LookupGroupId(gid string) (*Group, error)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func LookupId(uid string) (*User, error)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if the user ID is an integer, it takes a string as an argument, and so
    a conversion needs to be done. The easiest way to do that is to use the `strconv` package,
    which offers a series of utilities to convert from strings into the other basic
    data types, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see them in action in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/C6EWF2c50DT](https://play.golang.org/p/C6EWF2c50DT).
  prefs: []
  type: TYPE_NORMAL
- en: Working directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very useful piece of information that a process can give us access to
    is the working directory so that we can change it. In [Chapter 4](0b73653d-6073-4708-b015-fe6a43cb9f37.xhtml), *Working
    with the Filesystem*, we learned about which tools we can use – `os.Getwd` and `os.Chdir`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following practical example, will look at how to use these functions
    to manipulate the working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will obtain the current working directory and use it to get the path
    of the binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will join the working directory with another path and use it create
    a directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will use the path of the directory we just created to change the
    current working directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check out the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/UXAer5nGBtm](https://play.golang.org/p/UXAer5nGBtm).
  prefs: []
  type: TYPE_NORMAL
- en: Child processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Go application can interact with the operating system to create some other
    processes. Another subpackage of `os` offers the functionality to create and run
    new processes. Inside the `os/exec` package, there is the `Cmd` type, which represents
    command execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to create a new command is by using the `exec.Command` function,
    which takes the executable path and a series of arguments. Let''s look at a simple
    example with an `echo` command and some arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The full example is available at [https://play.golang.org/p/dBIAUteJbxI](https://play.golang.org/p/dBIAUteJbxI).
  prefs: []
  type: TYPE_NORMAL
- en: 'One very important detail is the nature of standard input, output, and error
    – they are all interfaces that we are already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: The input is an `io.Reader`, which could be `bytes.Reader`, `bytes.Buffer`,
    `strings.Reader`, `os.File`, or any other implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output and the error are `io.Writer`, can also be `os.File` or `bytes.Buffer`,
    and can also be `strings.Builder` or any another writer implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are different ways to launch the process, depending on what the parent
    application needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cmd.Run`: Executes the command, and returns an error that is `nil` if the
    child process is executed correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cmd.Start `: Executes the command asynchronously and lets the parent continue
    its flow. In order to wait for the child process to finish its execution, there
    is another method, `Cmd.Wait`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cmd.Output`: Executes the command and returns its standard output, and returns
    an error if `Stderr` isn''t defined but the standard error produced the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cmd.CombinedOutput`: Executes the command and returns both a standard error
    and output combined, which is very useful when the entire output of the child
    process-standard output plus standard error needs to be checked or saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing child properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the command has started its execution, synchronously or not, the underlying `os.Process` gets
    populated and it is possible to see its PID, as we can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Standard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Standard input can be used to send some data from the application to the child
    process. A buffer can be used to store the data and let the command read it, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Beginning with daemons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Unix, all of the programs that are running in the background are called **daemons**. They
    usually have a name that ends with the letter *d*, like `sshd` or `syslogd`, and
    they provide many functionalities of the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Operating system support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In macOS, Unix, and Linux, a process is a daemon if it survives its parent
    life cycle, that is, when the parent process terminates its execution and the
    child process lives on. That''s because the process parent is changed to the `init` process,
    a special daemon with no parent, and PID 1, which starts and terminates with the
    OS. Before going into this further, let''s introduce two very important concepts – *sessions* and *process
    groups*:'
  prefs: []
  type: TYPE_NORMAL
- en: A process group is a collection of processes that share signal handling. The
    first process of the group is called the **group leader**. There is a Unix system
    call, `setpgid`, that is capable of changing the group for a process, but it has
    some limits. The process can change its own process group, or change the group
    of one of its child processes before the `exec` system call is executed on it.
    When the process group changes, the session group needs to be changed accordingly,
    the same as for the leader of the destination group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A session is a collection of process groups that allow us to impose a series
    of restrictions on process groups and other operations. A session doesn't allow
    process group migration to another session, and it prevents processes from creating
    process groups in different sessions. The `setsid` system call allows us to change
    the process session to a new session if the process isn't a process group leader.
    Also, the first process group ID sets the session ID. If this ID is the same as
    the one of the running process, that process is called the **session leader**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve explained these two properties, we can look at the standard
    operations that are needed to create a daemon, which are usually the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean up the environment to remove unnecessary variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a fork so that the main process can terminate the process normally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the `setsid` system call, which accomplishes these three steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the PPID from the forked process so that it gets adopted by the `init` process
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new session for the fork, which will become the session leader
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the process as the group leader
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fork's current directory is set to the root directory to avoid having other
    directories in use, and all the files opened by the parent are closed (the child
    will open them if needed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting standard input to `/dev/null` and using some log files as standard output
    and error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the fork can be forked again, and can then exit. The first fork
    will be the group leader, and the second one will have the same group, allowing
    us to have another fork that isn't a group leader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is valid for Unix-based operating systems, though Windows also has support
    for permanent background processes, which are called **services**. Services can
    start automatically at boot or be started and stopped manually using a visual
    application called **Service Control Manager** (**SCM**). They can also be controlled
    from a command line, using the `sc` command in the regular prompt, and via the `Start-Service` and `Stop-Service` cmdlets
    in PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: Daemons in action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand what a daemon is and how it works, we can attempt to
    use the Go standard library to create one. Go applications are multithreaded and
    don't allow us to call to the `fork` system call directly.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that the `Cmd.Start` method in the `os/exec` package allows
    us to start a process asynchronously. The second step is to use the `release`
    method to close all the resources from the current process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows us how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the `forkProcess` function does, create another process, and
    start it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the process working directory gets set to root, and the output and error
    streams are set to the standard ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can release the resources – first, though, we need to find the current
    process. Then, we can call the `os.Process` method, `Release`, to ensure that
    the main process releases its resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function will contain the daemon logic, which in this example is
    very simple – it will just print what is running every few seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how the first process that lives from boot to the shutdown
    of the OS is called `init` or `init.d` since it's a daemon. This process is responsible
    for handling the other daemons, and stores its configuration in the `/etc/init.d` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Each Linux distribution uses its own version of the daemon control process,
    like `upstart` for Chrome OS or `systemd` in Arch Linux. They all serve the same
    purpose and have similar behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Each daemon has a control script or application that resides inside `/etc/init.d` and
    should be able to interpret a series of commands as first arguments, such as `status`, `start`, `stop`,
    and `restart`. In most cases, the `init.d` file is a script that executes a switch
    on the argument and behaves accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some applications are capable of automatically handling their service file,
    and this is what we will try to achieve, step by step. Let''s start with an `init.d` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a sample script that passes the first argument to the daemon. The path
    to the binary will be dependent on where the file is located. This needs to be
    defined at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function will handle the different commands, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we make sure that our app is running? A very sound strategy is to use
    a`PID` file, which is a text file that contains the current PID of the running
    process. Let''s define a couple of auxiliary functions to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `install` and `uninstall` functions will take care of adding or removing
    the service file located at `/etc/init.d/mydaemon` and requires us to launch the
    app with root permissions because of the file''s location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once the file is created, we can install the app as a service with the `mydaemon
    install` command and remove it with `mydaemon uninstall`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the daemon has been installed, we can use `sudo service mydaemon [start|stop|status]` to
    control the daemon. Now, all we need to do is implement these actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`status` will look for the `pid` file, read it, and send a signal to the process
    to check whether it''s running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start` will run the application with the `run` command and write the `pid` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`  will get the `pid` file, find the process, kill it, and then remove
    the `pid` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at how the `status` command is implemented. Note that the `0` signal
    doesn''t exist in Unix, and doesn''t trigger an action from the operating system
    or the app, but the operation will fail if the process isn''t running. This tells
    us whether the process is alive or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `start` command, we will create the daemon by following the steps we
    covered in the *Operating system support* *section*:'
  prefs: []
  type: TYPE_NORMAL
- en: Use files for standard output and input
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the working directory to root
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the command asynchronously
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition to these operations, the `start` command saves the PID value of
    the process in a specific file, which will be used to see whether the process
    is alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, `stopApp` will terminate the process identified by the PID file, if
    it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all of the parts that are needed for an application''s control are there,
    and all that is missing is the main application part, which should be a loop so
    that the daemon stays alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, all it does is sleep for a fixed amount of time, between the
    loop iterations. This is generally a good idea in a main loop, because an empty `for` loop
    would use a lot of resources for no reason. Let's assume that your application
    is checking for a certain condition in a `for` loop. If that is satisfied, continually
    checking for this will use a lot of resources. Adding an idle sleep of a few milliseconds can
    help reduce idle CPU consumption by 90-95%, so keep it in mind when designing
    your daemons!
  prefs: []
  type: TYPE_NORMAL
- en: Third-party packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen how to implement daemons from scratch using the `init.d` service.
    Our implementation is very simple and limited. It could be improved, but there
    are already many packages that offer the same functionalities. They offer support
    for different providers such as `init.d` and `systemd`, and some of them also
    work across non-Unix OSes such as Windows.
  prefs: []
  type: TYPE_NORMAL
- en: One of the more famous packages (more than 1,000 stars on GitHub) is `kardianos/service`,
    which supports all major platforms – Linux, macOS, and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'It defines a main interface that represents a daemon and has two methods –
    one for starting the daemon, and the other for stopping it. Both are non-blocking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The package already offers some use cases, from simple to more convoluted ones,
    in the example ([https://github.com/kardianos/service/tree/master/example](https://github.com/kardianos/service/tree/master/example)) directory.
    The best practice is to start a goroutine with the main activity loop. The `Start` method
    can be used to open and prepare the necessary resources, while `Stop` should be
    used to free them, and for other deferred activities such as buffer flushing.
  prefs: []
  type: TYPE_NORMAL
- en: Some other packages only offer compatibility with Unix systems, such as `takama/daemon`
    ([https://github.com/takama/daemon](https://github.com/takama/daemon)), which
    works in a similar fashion. It also offers some usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed how to get information related to the current process,
    PID and PPID, UID and GID,  and the working directory. Then, we saw how the `os/exec` package
    allows us to create child processes, and how their properties can be read similar
    to the current process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at what daemons are and how various operating systems support
    them. We verified how simple it is to execute a process that outlives its parent
    with `os/exec` using `Cmd.Run`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we went through the automated daemon management systems that are available
    with Unix, and created an application capable of running with `service` step by
    step.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to improve the control we have over child
    processes by checking out how to use exit codes and how to manage and send signals.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What information is available for the current process inside a Go application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you create a child process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you ensure that a child process survives its parent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you access child properties? How can you use them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's a daemon in Linux and how are they handled?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
