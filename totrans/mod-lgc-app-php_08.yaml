- en: Chapter 8. Extract SQL statements to Gateways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have moved all our class-oriented functionality to a central directory
    location (and have a reasonable test suite for those classes) we can begin extracting
    more logic from our page scripts and place that logic into classes. This will
    have two benefits: first, we will be able to keep the various concerns of the
    application separated; second, we will be able to test the extracted logic so
    that any breaks will be easy to notice before we deploy into production.'
  prefs: []
  type: TYPE_NORMAL
- en: The first of these extractions will be to move all SQL-oriented code to its
    own set of classes. For our purposes, SQL is a stand-in for any system of reading
    from and writing to a data store. This may be a no-SQL system, a CSV file, a remote
    resource, or anything else. We will concentrate on SQL-oriented data stores in
    this chapter because they are so common throughout legacy applications, but the
    principles apply to any form of data storage.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded SQL Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right now, our page scripts (and probably some of our classes) interact with
    a database directly with embedded SQL statements. For example, a page script might
    have some logic like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The problems with using embedded SQL strings are numerous. Among other things,
    we want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Test the SQL interactions in isolation from the rest of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the number of repeated SQL strings throughout the codebase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collect related SQL commands for generalization and reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolate and remove security flaws such as SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These problems and more lead us to the conclusion that we need to extract all
    our SQL-related code to an SQL layer, and replace the embedded SQL logic with
    calls to our SQL-related class methods. We will do this by creating a series of
    `Gateway` classes. The only thing these `Gateway` classes will do is get data
    from, and send data back to, our data sources.
  prefs: []
  type: TYPE_NORMAL
- en: The `Gateway` classes in this chapter are technically more like table data gateways.
    However, you may choose to set up any kind of `Gateway` that is appropriate for
    your data source.
  prefs: []
  type: TYPE_NORMAL
- en: The extraction process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, this is the process we will follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the entire codebase for SQL statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each statement not already in a `Gateway`, move the statement and relevant
    logic to a related `Gateway` class method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a test for the new `Gateway` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the statement and relevant logic in the original file with a call to
    the `Gateway` class method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test, commit, push, and notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat with the next SQL statement that is outside a `Gateway` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for SQL statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in previous chapters, we employ a project-wide search function here. Use
    a regular expression like the following to identify where SQL statement keywords
    are located in the codebase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Search for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We may find that our codebase uses other SQL commands as well. If so, we should
    include them in the search expression.
  prefs: []
  type: TYPE_NORMAL
- en: It will be easier on us if the codebase consistently uses only one case, whether
    upper or lower, for SQL keywords. However, this is not always the convention in
    legacy code. If our codebase is inconsistent regarding the case for SQL keywords,
    and our project-wide search facility has a case-insensitive option, we should
    use that option in this search. Otherwise, we need to expand the search terms
    to include lower-case (and perhaps mixed-case) variations of the SQL keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the search results are likely to include false positives. For example,
    narrative text such as "Select one of the following options" will be in the result
    list. We will need to examine the results individually to determine if they are
    SQL statements or only narrative text.
  prefs: []
  type: TYPE_NORMAL
- en: Move SQL to a Gateway class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The task of extracting the SQL to a `Gateway` is detail-oriented and context-specific.
    The structure of the legacy codebase itself will determine one or more correct
    approaches to this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, extracting a plain old SQL statement like the following seems
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But it turns out we need to make a lot of decisions even with this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: What should we name the `Gateway` class and method?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How should we deal with parameters to the query?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we avoid security flaws?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the proper return value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespace and Class names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To determine our namespace and class names, the first thing we need to decide
    is whether to organize by layer or by entity.
  prefs: []
  type: TYPE_NORMAL
- en: If we organize by implementation layers, the top-level namespaces for our class
    might be `Gateway` or `DataSource\Gateway`. This naming arrangement structures
    the classes by their operational purpose in the codebase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we organize by domain entities, the top-level namespaces would be something
    like `Comments`, or even `Domain\Comments`. This naming arrangement structures
    the classes by their purpose within the business logic domain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The legacy codebase is likely to dictate which way to go. If there is code already
    organized by one or the other, then it might be better to continue in the established
    structure rather than redoing the existing work. We want to avoid setting up conflicting
    or inconsistent organizational structures in the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Of the two, I recommend organizing by domain entities. I find it more sensible
    to collect functionality related to specific domain entity types within their
    relevant namespaces, than to spread operational implementations across several
    namespaces. We can also further segregate the implementation pieces within the
    specific domain feature in a way that is not easily done when organizing by layer.
  prefs: []
  type: TYPE_NORMAL
- en: To reflect my domain entity bias, the examples in the rest of this chapter will
    be structured along domain lines, not implementation layers.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an organizing principle for our `Gateway` classes, we can easily
    find good class names. For example, our comments-related `Gateway` in PHP 5.3
    and later might be named `Domain\Comments\CommentsGateway`. If we are using PHP
    5.2 or earlier, we will need to avoid namespaces proper and use underscores in
    the class name instead; e.g., `Domain_Comments_CommentsGateway`.
  prefs: []
  type: TYPE_NORMAL
- en: Method names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choosing an appropriate method name, however, is a little more difficult. Once
    again, we should look to the existing legacy codebase for a convention. The common
    idiom may be to `get()` the data, `find()` the data, `fetch()` the data, `select()`
    the data, or something else entirely.
  prefs: []
  type: TYPE_NORMAL
- en: We should stick with any existing naming convention as much as possible. While
    the method name itself does not matter, consistency-of-naming does. Consistency
    will make it easier for us to look at calls to the `Gateway` object and understand
    what is happening without having to read the underlying method code, and to search
    the codebase for data-access calls.
  prefs: []
  type: TYPE_NORMAL
- en: If our legacy codebase does not reveal a consistent pattern, it is up to us
    to choose a consistent naming convention for the new `Gateway` methods. Because
    the `Gateway` classes are supposed to be a simple layer to wrap SQL calls, the
    examples in this chapter will use method names like `select`, `insert`, etc. to
    identify the behavior being wrapped.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the method name should probably indicate the kind of `select()` being
    performed. Are we selecting one record or or all of them? Are we selecting by
    specific criteria? Are there other considerations on the query? These and other
    questions will give us hints on how to name the `Gateway` methods.
  prefs: []
  type: TYPE_NORMAL
- en: An initial Gateway class method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When extracting logic to a class method, we should be careful to follow all
    the lessons we learned about dependency injection in prior chapters. Among other
    things, this means: no use of globals, replacing superglobals with a `Request`
    object, no use of the `new` keyword outside `Factory` classes, and (of course)
    injecting objects via the constructor as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the above naming principles, and the original `SELECT` statement to retrieve
    comment rows, we may build a `Gateway` that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is practically an exact copy of the logic from the original page script.
    It leaves at least one major issue in place, though: it uses the input parameter
    directly in the query. This leaves us open to SQL injection attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**What Is SQL Injection**'
  prefs: []
  type: TYPE_NORMAL
- en: The classic XKCD comic regarding Little Bobby Tables should help to illustrate
    the problem. The input parameter being used directly in a database query is maliciously
    formed to change the query so that it damages or otherwise exploits the database.
  prefs: []
  type: TYPE_NORMAL
- en: Defeating SQL Injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we create our `Gateway` methods, we should never assume the parameter values
    are safe. It doesn't matter if we expect the parameters to be hard-coded to constant
    values on every call, or otherwise guaranteed to be safe. At some point, someone
    is going to change a bit of code that calls the `Gateway` method and we will have
    a security issue. Instead, we need to treat every parameter value as unsafe, and
    deal with it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to defeat SQL injection attempts, we should do one of three things with
    every query in our `Gateway` methods (indeed, in any SQL statement anywhere in
    the codebase):'
  prefs: []
  type: TYPE_NORMAL
- en: The best solution is to use prepared statements and parameter binding instead
    of query string interpolation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second-best solution is to use the database layer's "quote-and-escape" mechanism
    on each parameter before interpolating it into the query string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third-best solution is to escape each of the input parameters before interpolating
    them into the query string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alternatively, we can avoid the problem of strings entirely by casting expected
    numeric values to `int` or `float`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the third-best solution first, since it is more likely to already
    be present in our legacy codebase. We use the database''s `escape` functionality
    to escape each parameter before we use it in a query string, and quote it appropriately
    for the database. Thus, we can rewrite the `selectAllByPostId()` method like so,
    assuming a MySQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Escaping values for interpolation into strings is a third-best solution for
    several reasons. The main one is that the escaping logic is sometimes insufficient.
    Something like `mysql_escape_string()` function is simply not good enough for
    our purposes here. Even the `mysql_real_escape_string()` method has a flaw that
    will allow attackers to succeed at SQL injection attempts depending on the current
    character set. However, this may be the only option available to the underlying
    database driver.
  prefs: []
  type: TYPE_NORMAL
- en: The second-best solution is a variation of escaping called quote-and-escape.
    This feature, available only via the `PDO::quote()` method, is safer than escaping
    because it additionally wraps the value in quotes and deals with the proper character
    set automatically. This avoids the character set mismatch issues inherent to just
    escaping and adding quotes on our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'A rewritten `selectAllByPostId()` method might look like this with a `Db` object
    that exposes the `PDO::quote()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a safe approach when we remember to use it. The issue here, of course,
    is that if we add a parameter to the method, we may forget to quote it, and then
    we are vulnerable to SQL injection again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the best solution: prepared statements and parameter binding. These
    are only available via PDO (which works with almost all databases) and the `mysqli`
    extension. Each has its own variations on how to handle statement preparation.
    We will use `PDO` style examples here.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of interpolating values into query strings, we use named placeholders
    to indicate where parameters should be placed in a query string. We then tell
    `PDO` to prepare the string as a `PDOStatement` object, and bind values to the
    named placeholders when we execute the query through that prepared statement.
    `PDO` automatically uses safe representations of the parameter values, making
    us secure against SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of what a rewrite would look like using a `Db` object that
    exposes the `PDO` statement preparation logic and execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The great benefit here is that we never use the parameter variables in the query
    string. We always and only use named placeholders, and bind the placeholders to
    the parameter values into the prepared statement. This idiom makes it clear when
    we are improperly using interpolated variables, and `PDO` automatically complains
    if there are extra or missing bound values, so the chances of accidentally making
    an insecure change are greatly reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Write a test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it is time to write a test for our new class method. The test we write at
    this point is going to be less perfect than we would like because we need to interact
    with the database. However, an imperfect test is better than no test. As *The
    Way Of Testivus* tells us, we write the test we can at the time we can.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for our new `Gateway` method might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we run our test suite to see if the test passes. If it does, we rejoice
    and move on! If it does not, we continue to refine the `Gateway` method and the
    related test until both are working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Perfecting Our Tests**'
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, this is very much an imperfect test. Among other things, it
    depends on a working database connection, and on having data seeded into the database
    in the first place. By depending on the database, we are dependent on it being
    in a correct state. If the database does not have the correct data in it, then
    the test will fail. The failure will come not from the code, which is what we
    are testing, but from the database, which is mostly beyond our control. One opportunity
    for improving the test is to change the `Gateway` class to depend on a `DbInterface`
    instead of a concrete `Db` class. We would then create a `FakeDb` class for testing
    purposes that implements the `DbInterface`, and inject a `FakeDb` instance into
    the `Gateway` instead of a real `Db` instance. Doing so would give us greater
    insight into the correctness of the SQL query string along with greater control
    over the the data being returned to the `Gateway`. Above all, it would decouple
    the test from its dependency on a working database. For now, in the interest of
    expediency, we will use the imperfect test.
  prefs: []
  type: TYPE_NORMAL
- en: Replace the original code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a working and tested `Gateway` method, we replace the original
    code with a call to the `Gateway`. Whereas the old code looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The new version would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have done little to modify the operational logic. For example,
    we have not added error checking that was not previously present. The furthest
    extent of our modification has been to secure the query against SQL injection
    via prepared statements.
  prefs: []
  type: TYPE_NORMAL
- en: Test, Commit, Push, Notify QA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in previous chapters, we now need to spot check the legacy application. Although
    we have a unit test for the new `Gateway` method, we still need to spot check
    the part of the application we have modified. If we prepared a characterization
    test earlier that covers this part of our legacy application, we can run that
    now. Otherwise, we can do this by browsing to or otherwise invoking the changed
    part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are satisfied that we have successfully replaced the embedded SQL with
    a call to our new `Gateway` method, we commit the changes, including our tests,
    to revision control. We then push to the central repository and notify the QA
    team of our changes.
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With that complete, we search the codebase again for uses of SQL keywords to
    indicate embedded query strings. Where they exist outside of a `Gateway` class,
    we continue extracting the queries to an appropriate `Gateway`. Once all the SQL
    statements have been moved to `Gateway` classes, we're done.
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What about INSERT, UPDATE, and DELETE Statements?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we have looked exclusively at `SELECT` statements since they are likely
    to be the most common case in our legacy codebase. However, there will be a significant
    number of `INSERT`, `UPDATE`, `DELETE`, and perhaps other statements as well.
    These are treated essentially the same as the `SELECT` for purposes of extraction
    to a `Gateway`, but there are some minor differences.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, `INSERT` and `UPDATE` statements may contain a large number of
    parameters indicating the column values to be inserted or updated. Adding too
    many parameters to the extracted `Gateway` method signature will make it difficult
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, we can use a data array to indicate the column names and their
    corresponding values. We need to make sure that we are inserting or updating only
    the correct columns, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we start with the following code in a page script to save
    a new comment with the name of the commenter, the comment body, the IP address
    of the commenter, and the post ID to which the comment is attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we extract this to a method in our `CommentsGateway`, we could have a parameter
    for each column value being inserted. In this case there are only four columns,
    but if there were a dozen, the method signature would be harder to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an alternative to one parameter per column, we could pass an array of data
    as a single parameter and then work with that inside the method. This example
    of using a data array includes a prepared statement with placeholders to defeat
    SQL injection attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a method like this in the `CommentsGateway`, we can modify the
    original code to read more like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What about Repetitive SQL strings?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing we will probably encounter during this process is a large amount of
    repetition, or repetition with variation, in the query strings throughout our
    legacy application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we may find a comments-related query elsewhere in our legacy application
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The query string is identical to the example code from the beginning of this
    chapter, except it has a `LIMIT` clause attached. Should we create an entirely
    new method for this query, or do we modify an existing method?
  prefs: []
  type: TYPE_NORMAL
- en: This is the sort of thing that requires professional judgment and familiarity
    with the codebase. In this case, modification seems to be reasonable, but in other
    situations the difference might be great enough to warrant an entirely new method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we choose to modify an existing method in the `CommentsGateway`, we might
    rewrite `selectAllByPostId()` to include an optional `LIMIT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have modified the application class, we need to run our existing
    tests. If they fail, we rejoice! We have discovered that our change was flawed,
    and the tests have prevented that bug from making it into production. If they
    pass, we rejoice, because things are still working the way they used to before
    the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after the existing tests pass, we modify the `CommentsGatewayTest`
    so that it checks to see if the new `LIMIT` functionality works properly. This
    test continues to be imperfect, but it gets the point across:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We run the tests yet again to make sure our new `LIMIT` functionality works,
    and refine the code and test until it passes.
  prefs: []
  type: TYPE_NORMAL
- en: We then proceed to replace the original embedded SQL code with a call to the
    `Gateway`, spot check, commit, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to be cautious here. After seeing one variation of a query, we will
    be able to imagine many other possible variations of that query. The resulting
    temptation will be to preemptively modify our `Gateway` methods to account for
    the imagined variations before we actually encounter them. Unless we have actually
    seen a particular variation in the legacy codebase, we should restrain ourselves
    from writing code for that variation. We do not want to get too far ahead of what
    the codebase actually requires right now. The goal is to improve in small steps
    on a visible path, not to make giant leaps into a fog of imagination.
  prefs: []
  type: TYPE_NORMAL
- en: What about complex query strings?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples so far have been relatively simple query strings. These simple
    examples help to keep the process clear. However, we are likely to see very complicated
    queries in our legacy codebase. These may include queries built up in pieces,
    using several conditional statements to modify how the pieces are built, with
    many different parameters being used in the query. Here is one example of a complex
    query taken from [Appendix A](apa.xhtml "Appendix A. Typical Legacy Page Script"),
    *Typical Legacy Page Script*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For complex arrangements of this sort, we will need to pay great attention to
    detail in extracting the relevant query-building logic to our `Gateway`. The main
    considerations are to determine which variables are used in the query-building
    logic, and to set those up as parameters to our new `Gateway` method. We can then
    move the query-building logic to our `Gateway`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first pass at extracting the embedded SQL-related logic to a `Gateway` method
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we have removed some dependencies (e.g. the implicit global dependency
    on a `mysql_connect()` link identifier), there are still lots of problems with
    this first pass. Among other things, it is still vulnerable to SQL injection.
    We would need to use `mysql_real_escape_string()` on every parameter used in the
    query, and cast the `LIMIT` values to integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we complete the extraction and its related test, we change the original
    code to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What about queries inside non-Gateway classes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples in this chapter show SQL query strings embedded in page scripts.
    It is just as likely that we will find query strings embedded in non-Gateway classes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, we follow the same process as we did for page scripts. One
    added issue is that we will have to pass the `Gateway` dependency to the class.
    For example, say we have a `Foo` class that uses a `doSomething()` method to retrieve
    comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We extract the SQL query string and its related logic as we did with the page
    script. We then modify the `Foo` class to take the `Gateway` as a dependency instead
    of the `Db` object, and use the `Gateway` as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Can we extend from a base Gateway class?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we have many `Gateway` classes that all have similar functionality, it may
    be reasonable to collect some of that functionality into an `AbstractGateway`.
    For example, if they all need the a `Db` connection, and all have similar `select*()`
    methods, we might do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then extend a class from that base `AbstractGateway` and tune the extended
    properties for a specific table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The base `selectOneByPrimaryKey()` method can then work with a wide range of
    `Gateway` classes. We can still add other concrete methods on specific `Gateway`
    classes as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be cautious with this approach. We should abstract only the functionality that
    already exists in the behaviors we have already extracted. Resist the temptation
    to preemptively create functionality that we have not actually seen in the legacy
    codebase.
  prefs: []
  type: TYPE_NORMAL
- en: What about multiple queries and complex result structures?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The examples in this chapter have shown single queries against single tables.
    It is likely that we will encounter logic that uses multiple queries against several
    different tables and then combines the results into a complex domain entity or
    collection. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example shows a classic N+1 problem where one query is issued for each
    member of a master set. The first query to get the blog posts will be followed
    by 10 more queries, one for each blog post, to get the comments. The total number
    of queries is thus 10, plus one for the initial query. For 50 posts, there would
    be 51 queries total. This is a typical source of performance drags in legacy applications.
    For extended discussion of, and solutions to, the N+1 problem, please see *Solving
    The N+1 Problem in PHP* ([https://leanpub.com/sn1php](https://leanpub.com/sn1php))
  prefs: []
  type: TYPE_NORMAL
- en: The first issue is to identify how we can split up the queries into `Gateway`
    methods. Some queries will have to go together, while others can be separated.
    In this case, the first and second queries can be separated into different `Gateway`
    classes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: The next issue is to determine which `Gateway` class should receive the extracted
    logic. This can sometimes be hard to figure out when multiple tables are involved,
    so we have to choose which is the primary subject of the query. The first query
    above references posts, authors, and stats, but it seems clear from the logic
    that we are primarily interested in the posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, we can extract the first query to a `PostsGateway`. We want to modify
    the query itself as little as possible, so we leave the joins and such in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once completed, we proceed to write a test for the new functionality based on
    the first query. We modify the code and test until the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: The second query, the one related to comments, is the same as our earlier example.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we finish the extractions and their related tests, we can modify the
    page script to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: What if there is no Database Class?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many legacy codebases do not have a database access layer. Instead, these legacy
    applications use the `mysql` extension directly in their page scripts. Calls to
    `mysql` functions are scattered throughout the codebase and are not gathered into
    a single class.
  prefs: []
  type: TYPE_NORMAL
- en: If we can upgrade to `PDO`, we should. However, it may not be possible to upgrade
    away from `mysql` for various reasons. `PDO` does not work quite the same way
    as `mysql`, and changing from `mysql` idioms to `PDO` ones might be too much to
    do in a single step. A migration at this point might also make testing more difficult
    than we would like.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we could move the `mysql` calls as they are into our `Gateway`
    classes. Doing so seems reasonable at first. However, the `mysql` extension has
    a bit of global state built into it. Any `mysql` functions that need a link identifer
    (i.e., a server connection) automatically use the most-recent connection resource
    when no link identifier is passed. This is counter to the principles of dependency
    injection, since we would rather not be dependent on global state if we can help
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, instead of migrating directly to PDO, and instead of leaving the `msyql`
    function calls as they are, I suggest we wrap the `mysql` calls in a class that
    proxies method calls to the `mysql` functions. We can then use the class methods
    instead of the `mysql` functions. The class itself can contain the link identifier
    and pass it to each method call. This will give us a database access layer that
    our `Gateway` objects can use without changing the `mysql` idiomatic usage too
    greatly.
  prefs: []
  type: TYPE_NORMAL
- en: One operational example implementation of such a wrapper is the `MysqlDatabase`
    class. When we create an instance of `MysqlDatabase`, it retains the connection
    information but does not actually connect to the server. It only connects when
    we call a method that actually needs a server connection. This lazy-loading approach
    helps us reduce resource usage. In addition, the `MysqlDatabase` class explicitly
    adds the link identifier argument, which is optional in the relevant `mysql` functions,
    so that we are never dependent on the implicit global state of the `mysql` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'To replace `mysql` function calls with `MysqlDatabase` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the entire codebase for the `mysql_` prefix on function calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In each file where there are function calls with the `mysql_` function prefix
    ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create or inject an instance of `MysqlDatabase`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replace each `mysql_` function prefix with the `MysqlDatabase` object variable
    and a single arrow operator (`->`). If we are sticklers for style, we can can
    convert the remaining method name portion from `snake_case()` to `camelCase()`
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spot check, commit, push, and notify QA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue searching for the `mysql_` prefix on function calls until they have
    all been replaced with `MysqlDatabase` method calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, say we have a piece of legacy code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above process, we can convert the code to use the `MysqlDatabase`
    object instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the MysqlDatabase class**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That code, in turn, can be extracted to a `Gateway` class using an injected
    `MysqlDatabase` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our page scripts, it may be best to create a `MysqlDatabase` instance in
    our existing setup file and use that, instead of creating one separately in each
    page script. The lazy-connecting nature of the implementation means that if we
    never make a call to the database, no connection will ever be made, so we don't
    need to worry about unnecessary resource usage. The existing legacy codebase will
    help us determine if this is a reasonable approach.
  prefs: []
  type: TYPE_NORMAL
- en: Once our `Gateway` classes use an injected `MysqlDatabase` object, we can then
    proceed to planning a migration away from the wrapped `mysql` functions over to
    `PDO` with its different idioms and usage. Because the database access logic is
    now wrapped by `Gateway` objects, the migration and testing will be easier than
    if we had replaced `mysql` calls spread throughout the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have completed this step, all of our SQL statements will be inside `Gateway`
    classes, and no longer in our page scripts or other non-Gateway classes. We will
    also have tests for our `Gateway` classes.
  prefs: []
  type: TYPE_NORMAL
- en: From here on out, any time we need to add new calls to the database, we will
    do so only in the `Gateway` classes. Any time we need to fetch or save data, we
    will use the `Gateway` methods instead of writing embedded SQL. This gives us
    a clear separation of concerns between the database interactions and our future
    model layer and entity objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have separated our database interactions into their own layer, we
    are going to inspect all the calls to the `Gateway` objects throughout the legacy
    application. We will examine how the returned results are manipulated by the page
    scripts and other classes, and begin extracting the behaviors that define our
    model layer.
  prefs: []
  type: TYPE_NORMAL
