- en: Day 05 - Overview of Reflection and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today is day five of our seven-day learning series. Up till now, we have gone
    through various insights into the C# language and have got the idea about how
    to work with statements, loops, methods, and so on. Today, we will learn the best
    way to work dynamically when we're writing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of ways we can dynamically implement code changes and generate
    an entire programming class. Today, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is reflection?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of delegates and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections and non-generics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is reflection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simple terms, reflection is a way to get inside of a program, gathering
    the object information of a program/code and/or invoking these at runtime. So,
    with the help of reflection, we can analyze and assess our code by writing code
    in C#. To understand reflection in detail, let''s take the example of the `class`
    `OddEven`. Here is the partial code of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After going through the code, we can say this code has a few public methods
    and private methods. Public methods utilize private methods for various functional
    demands and perform tasks to solve a real-world problems where we need to identify
    the odd or even numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we need to utilize the preceding class, we have to instantiate this class
    and then call their methods to get the results. Here is how we can utilize this
    simple class to get the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00073.gif)'
  prefs: []
  type: TYPE_IMG
- en: The previous code shows one of the ways in which we can implement the code.
    In the same way, we can implement this using the same solution but by analyzing
    the code. We have already stated that reflection is a way to analyse our code.
    In the upcoming section, we will implement and discuss the code of a similar implementation,
    but with the use of reflection.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add the following NuGet package to work with reflection, using
    the Package Manager Console: install-`Package System.Reflection`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, instead of `Activator.CreateInstance(typeof(OddEven))`,
    we can also use `Assembly.CreateInstance("OddEven")`. `Assembly.CreateInstance`
    looks into the type of the assembly and creates the instance using `Activator.CreateInstance`.
    For more information on `Assembly`,`CreateInstance`, refer to: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netstandard-2.0#System_Reflection_Assembly_CreateInstance_System_String_](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netstandard-2.0#System_Reflection_Assembly_CreateInstance_System_String_).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.gif)'
  prefs: []
  type: TYPE_IMG
- en: Reflection in use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we get an idea about reflection and how we can utilize
    the power of `Reflection` to analyse the code. In this section, we will see more
    complex scenarios where we can use `Reflection` and discuss `System.Type` and
    `System.Reflection` in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Getting type info
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a `System.Type` class available which provides us with the complete
    information about our object type: we can use `typeof` to get all the information
    about our class. Let''s see the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the same node, we can we have method `GetType()` of the `System.Type` class,
    which gets the type and provides the information. Let us analyse and discuss the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code snippets discussed in the previous sections had a type which represented
    a class `System.Type`, and then we gathered the information using properties.
    These properties are explained in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Name** | Returns the name of the type, for example, `Program` |'
  prefs: []
  type: TYPE_TB
- en: '| **Full Name** | Returns the fully qualified name of the type without the
    assembly name, for example, `Day05.Program` |'
  prefs: []
  type: TYPE_TB
- en: '| **Namespace** | Returns the namespace of the type, for example, `Day05`.
    This property returns null if there is no namespace |'
  prefs: []
  type: TYPE_TB
- en: These properties are read-only (of class `System.Type` which is an abstract
    class); that means we can only read or get the results, but they do not allow
    us to set the values.
  prefs: []
  type: TYPE_NORMAL
- en: The `System.Reflection.TypeExtensions` class has everything we need to analyse
    and write code dynamically. The complete source code is available at [https://github.com/dotnet/corefx/blob/master/src/System.Reflection.TypeExtensions/src/System/Reflection/TypeExtensions.cs](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.TypeExtensions/src/System/Reflection/TypeExtensions.cs).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation of all extension methods is beyond the scope of this book, so
    we added the following table which represents all details on important extension
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method name** | **Description** | **Source (** [https://github.com/dotnet/corefx/blob/master/src](https://github.com/dotnet/corefx/blob/master/src)
    ) |'
  prefs: []
  type: TYPE_TB
- en: '| `GetConstructor(Type type, Type[] types)` | Performs over the provided type
    and returns output of type `System.Reflection. ConstructorInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ConstructorInfo[] GetConstructors(Type type)` | Returns all constructor
    information for provided type and array outputs of `System.Reflection. ConstructorInfo`
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  prefs: []
  type: TYPE_TB
- en: '| `ConstructorInfo[] GetConstructors(Type type, BindingFlags bindingAttr)`
    | Returns all constructor information for provided type and attributes | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `MemberInfo[] GetDefaultMembers(Type type)` | Gets the access for provided
    attribute, for member, for given type, and for outputs of array `System.Reflection.
    MemberInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  prefs: []
  type: TYPE_TB
- en: '| `EventInfo` `GetEvent(Type type, string name)` | Provides the access to EventMetadata
    outputs of `System.Reflection. MemberInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FieldInfo GetField(Type type, string name)` | Gets the field info of the
    specified type, and for the field name provided, and returns, output of `System.Reflection.
    FieldInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  prefs: []
  type: TYPE_TB
- en: '| `MemberInfo[] GetMember(Type type, string name)` | Gets the member info of
    the specified type by using member name, and this method outputs an array of `System.Reflection.
    MemberInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  prefs: []
  type: TYPE_TB
- en: '| `PropertyInfo[] GetProperties(Type type)` | Provides all properties for the
    specified type and outputs as an array of `System.Reflection. PropertyInfo` |
    `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  prefs: []
  type: TYPE_TB
- en: Try implementing all extension methods using a simple program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous sections, we learned how to analyze our compiled code/application
    using `Reflection`. `Reflection` works fine when we have existing code. Think
    of a scenario where we require some dynamic code generation logic. Let''s say
    we need to generate a simple class as mentioned in following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating or writing purely dynamic code or code on the fly is not possible with
    the sole use of `Reflection`. With the help of `Reflection`, we can analyze our
    `MathClass`, but we can create this class on the fly with the use of `Reflection.Emit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic code generation is beyond the scope of this book. You can refer to
    the following thread for more information: [https://stackoverflow.com/questions/41784393/how-to-emit-a-type-in-net-core](https://stackoverflow.com/questions/41784393/how-to-emit-a-type-in-net-core)'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of delegates and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the basics of delegates and events. Both delegates
    and events are the most advanced features of the C# language. We will understand
    these in coming sections in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C#, delegates are a similar concept to pointers to functions, as in C and
    C++. A delegate is nothing but a variable of a reference type, which holds a reference
    of a method, and this method is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve late binding using delegates. In [Chapter 7](part0238.html#72V5S0-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Understanding Object Oriented Programing with C#*, we will discuss late binding
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Delegate` is a class from which all delegates are derived. We use delegates
    to implement events.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a delegate type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declaring a delegate type is similar to the method signature class. We just
    need to declare a type public delegate string: `PrintFizzBuzz(int number);`. In
    the preceding code, we declared a delegate type. This declaration is similar to
    an abstract method with the difference that delegate declaration has a type delegate.
    We just declared a delegate type `PrintFizzBuzz`, and it accepts one argument
    of int type and returns the result of the string. We can only declare public or
    internal accessible delegates.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility of delegates is internal by default.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous figure, we can analyse the syntax of the delegate declaration.
    If we saw this figure, we would notice that it started with public, then the keyword
    delegate, which tells us that this is a delegate type, the string, which is a
    return type, and our syntax is concluded with name and passing arguments. The
    following table defines that declaration has major parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Syntax part** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Modifier | Modifier is the defined accessibility of a delegate type. These
    modifiers can be only public or internal, and by default a delegate type modifier
    is internal. |'
  prefs: []
  type: TYPE_TB
- en: '| Return type | Delegate can or cannot return a result; it can be of any type
    or void. |'
  prefs: []
  type: TYPE_TB
- en: '| Name | The name of the declared delegate. The name of the delegate type follows
    the same rules as a typical class, as discussed on day two. |'
  prefs: []
  type: TYPE_TB
- en: '| Parameter list | A typical parameter list; parameters can be any type. |'
  prefs: []
  type: TYPE_TB
- en: Instances of delegate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we created a delegate type named `PrintFizzBuzz`.
    Now we need to declare an instance of this type so we can use the same in our
    code. This is similar to the way we declared variables—please refer to day two
    to know more about the declaration of variables. The following code snippet tells
    us how we can declare an instance of our delegate type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintFizzBuzz printFizzBuzz;`'
  prefs: []
  type: TYPE_NORMAL
- en: Delegates in use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can directly use delegate types by calling matching methods, which means
    the delegate type invokes a related method. In the following code snippet, we
    are simply invoking a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code snippet written in the previous section, we are taking an input
    from the user and then, with the help of the delegate, we are getting the expected
    results. The following screenshot shows the complete output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.gif)'
  prefs: []
  type: TYPE_IMG
- en: More advanced delegates, namely multicast, and strongly typed delegates will
    be discussed on day six.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, whenever events come into the picture, we can think about an action
    for the user or user action. There are a couple of examples from our daily life;
    namely we check our emails, send emails, and so on. Actions such as clicking a
    send button or receive button from our email clients are nothing but events.
  prefs: []
  type: TYPE_NORMAL
- en: Events are members of a type, and this type is of delegate type. These members
    notify to other types when raised.
  prefs: []
  type: TYPE_NORMAL
- en: Events use the publisher-subscriber model. A publisher is nothing but an object
    which has a definition of the event and the delegate. On the other hand, a subscriber
    is an object which accepts the events and provides the event handler (event handlers
    are nothing but a method which is invoked by delegates in the publisher class).
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we declare an event, we should have a delegate type, so we should first
    declare a delegate. The following code snippet shows delegate type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00079.gif)'
  prefs: []
  type: TYPE_IMG
- en: Collections and non-generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On day two, we learned about arrays, which are of fixed size, and you can use
    these for strongly typed list objects. But what about if we want to use or organize
    these objects into other data structures such as queues, lists, stacks, and so
    on? All these we can achieve with the use of collections (`System.Collections`).
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to play with data (storage and retrieval) with the use
    of collections. The following are the main collection classes we can use.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections.NonGeneric` ([https://www.nuget.org/packages/System.Collections.NonGeneric/](https://www.nuget.org/packages/System.Collections.NonGeneric/)
    ) is a NuGet package which provides all non-generic types, namely `ArrayList`,
    `HashTable`, `Stack`, `SortedList`, `Queue`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it is an array, it contains an ordered collection of an object and can be
    indexed individually. As this is a non-generic class, it is available under a
    separate NuGet package from `System.Collections.NonGeneric`. To work with the
    example code, you should first install this NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `ArrayList` properties and methods are important to add, store, or remove
    our data items from our collections. There are many properties and methods available
    for the `ArrayList` class. In the upcoming sections, we will discuss commonly
    used methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The properties of `ArrayList` play a vital role while analysing an existing
    `ArrayList`; the following are the commonly used properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Capacity` | A getter setter property; with the use of this, we can set or
    get the number of elements of `ArrayList`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Count` | Total actual number of elements `ArrayList` contains. Please note
    that this count may differ from capacity.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `IsFixedSize` | A getter property returns true/false on the basis of whether
    `ArrayList` is of fixed size or not.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in the previous section, properties play important roles while
    we''re working with `ArrayList`. In the same node, methods provide us a way to
    add, remove, or perform other operations while working with non-generic collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Add (object value)` | Adds an object to the end of `ArrayList`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Clear()` | Removes all elements from `ArrayList`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Remove(object obj)` | Removes first occurred element in the collection.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Sort()` | Sorts all the elements in `ArrayList` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You will learn all advanced concepts of collections and generics on day six.
  prefs: []
  type: TYPE_NORMAL
- en: HashTable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A non-generic type, the `hashTable` class is nothing but a representation of
    collections of key/value pairs and is organized on the basis of a key, which is
    nothing but a hash code. The use of `hashTable` is advisable when we need to access
    data on the basis of a key.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of HashTable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Hashtable` can be declared by initializing the `Hashtable` class; the following
    code snippet shows the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss commonly used methods and properties of `HashTable` next.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The properties of `hashTable` play a vital role while analyzing an existing
    `HashTable`; the following are the commonly used properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Count` | A getter property; returns number of key/value pairs in the `HashTable`.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `IsFixedSize` | A getter property; returns true/false on the basis of whether
    the `HashTable` is of fixed size or not.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `IsReadOnly` | A getter property; tells us whether `Hashtable` is read-only
    or not.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The methods of `HashTable` provide a way to add, remove, and analyze the collection
    by providing more operations, as discussed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Add (object key, object value)` | Adds an element of a specific key and
    value to `HashTable`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Clear()` | Removes all elements from `HashTable`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Remove (object key)` | Removes element of a specified key from HashTable.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.gif)'
  prefs: []
  type: TYPE_IMG
- en: SortedList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A non-generic type, the `SortedList` class is nothing but a representation of
    collections of key/value pairs, organized on the basis of a key, and is sorted
    by key. `SortedList` is a combination of `ArrayList` and `HashTable`. So, we can
    access the elements by key or index.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of SortedList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`SortedList` can be declared by initializing the `SortedList` class; the following
    code snippet shows the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss commonly used methods and properties of `SortedList` next.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The properties of `SortedList` play a vital role while analyzing an existing
    `SortedList`; the following are the commonly used properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Capacity` | A getter setter property; with the use of this, we can set or
    get the capacity of `SortedList`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Count` | A getter property; returns number of key/value pairs in the `HashTable`.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `IsFixedSize` | A getter property; returns true/false on the basis of whether
    `SortedList` is of fixed size or not.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `IsReadOnly` | A getter property; tells us whether `SortedList` is read-only
    or not.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Add (object key, object value)` | Adds an element of a specific key and
    value to `SortedList`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Clear()` | Removes all elements from `SortedList`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Remove (object key)` | Removes an element of specified key from `SortedList`.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the upcoming section, we will implement code with the use of the properties
    and methods mentioned in previous sections. Let''s collect a list of all stakeholders
    of the book *Learn C# in 7 days* with the use of `SortedList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.gif)'
  prefs: []
  type: TYPE_IMG
- en: Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A non-generic type, it represents a collection as **last in, first out (LIFO)**
    of objects. It contains two main things: `Push` and `Pop`. Whenever we''re inserting
    an item into the list, it is called pushing, and when we extract/remove an item
    from the list, it''s called popping. When we get an object without removing the
    item from the list, it is called peeking.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The declaration of `Stack` is very similar to the way we declared other non-generic
    types. The following code snippet shows the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss commonly used methods and properties of `Stack`.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stack` class has only one property, which tells the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Count` | A getter property; returns number of elements a stack contains.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Object Peek()` | Returns the object at the top of the stack but does not
    remove it.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Object Pop()` | Removes and returns the object at the top of the stack.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Push(object obj)` | Inserts an object at the top of the stack.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Clear()` | Removes all elements from the stack.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the complete example of stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code captures a list of stakeholders for the book *Learning C#
    in 7 days* using `Stack`, and showing the usage of properties and methods discussed
    in previous sections. This code resulted in the output shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.gif)'
  prefs: []
  type: TYPE_IMG
- en: Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Queue is just a non-generic type that represents a FIFO collection of an object.
    There are two main actions of `queue`: when adding an item, it is called enqueuer,
    and when removing an item, it is called `dequeue`.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaration of Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The declaration of `Queue` is very similar to the way we declared other non-generic
    types. The following code snippet shows the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss commonly used methods and properties of `Queue` next.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Queue` class has only one property, which tells the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Property** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Count` | A getter property; returns the number of elements `queue` contained.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the commonly used methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Object Peek()` | Returns the object at the top of the `queue` but does not
    remove it.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Object Dequeue()` | Removes and returns the object at the beginning of the
    `queue`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Enqueue (object obj)` | Inserts an object at the end of the `queue`.For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Void Clear()` | Removes all elements from `Queue`.For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.gif)'
  prefs: []
  type: TYPE_IMG
- en: BitArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BitArray is nothing but an array which manages an array of bit values. These
    values are represented as Boolean. True means bit is *ON* (1) and false means
    bit is *OFF*(0). This non-generic collection class is important when we need to
    store the bits.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of BitArray is not covered. Please refer to the exercises
    at the end of the chapter to implement BitArray.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed non-generic collections in this chapter. Generic collections
    are beyond the scope of this chapter; we will cover them on day six. To compare
    different collections, refer to [https://www.codeproject.com/Articles/832189/List-vs-IEnumerable-vs-IQueryable-vs-ICollection-v](https://www.codeproject.com/Articles/832189/List-vs-IEnumerable-vs-IQueryable-vs-ICollection-v).
  prefs: []
  type: TYPE_NORMAL
- en: Hands - on exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solve the following questions, which cover the concepts from today''s learning:'
  prefs: []
  type: TYPE_NORMAL
- en: What is reflection? Write a short program to use `System.Type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class that contains at least three properties, two constructors, two
    public methods, and three private methods, and implements at least one interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program with the use of `System.Reflection.Extensins` to assess the
    class created in question two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Study the NuGet package `System.Reflection.TypeExtensions` and write a program
    by implementing all of its features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Study the NuGet package `System.Reflection. Primitives` and write a program
    by implementing all of its features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are delegate types and how can you define multicast delegates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are events? How are events are based on the publisher-subscriber model?
    Show this with the use of a real-world example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program using delegates and events to get an output similar to [https://github.com/garora/TDD-Katas#string-sum-kata](https://github.com/garora/TDD-Katas#string-sum-kata).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define collections and implement non-generic types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refer to our problem from day one, the vowel count problem, and implement this
    using all non-generic collection types.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Day 05
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, we have discussed very important concepts of C#, covering reflection,
    collections, delegates, and events.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed the importance of reflection in our code analysis approach. During
    the discussion, we implemented code showing the power of reflection, where we
    analyzed the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: Then we discussed delegates and events and how delegates and events work in
    C#. We also implemented delegates and events.
  prefs: []
  type: TYPE_NORMAL
- en: One of the important and key features of the C# language that we discussed in
    detail was non-generic types, namely `ArrayList`, `HashTable`, `SortedList`, `Queue`,
    `Stack`, and so on. We implemented all these using C# 7.0 code.
  prefs: []
  type: TYPE_NORMAL
