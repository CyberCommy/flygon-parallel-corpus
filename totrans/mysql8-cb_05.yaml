- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using savepoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isolation levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following recipes, we will discuss the transactions and various isolation
    levels in MySQL. Transaction means a set of SQL statements that should succeed
    or fail together. Transactions should also satisfy **Atomicity, Consistency, Isolation,
    and** **Durability**(**ACID**) properties. Take a very basic example of a money
    transfer from account `A` to account `B`. Assume that `A` has $600, `B` has $400,
    and `B` wishes to transfer $100 from `A` to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bank would deduct $100 from `A` and add to `B` using the following SQL
    code (for illustration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmatically, check whether `@a.bal` is greater than or equal to 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmatically, check whether `@b.bal` is `NOT NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These four SQL lines should be part of a single transaction and satisfy the
    following ACID properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity**: Either all the SQLs should be successful or all should fail.
    There should not be any partial updates. If this property is not obeyed and if
    the database crashes after running two SQLs, then `A` would lose 100.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: A transaction must change affected data only in allowed ways.
    In this example, if `account_number` with `B` does not exist, the whole transaction
    should be rolled back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: Transactions that occur at the same time (concurrent transactions)
    should not lead the database to an inconsistent state. Each of the transactions
    should be executed as if it were the only transaction in the system. No transaction
    should affect the existence of any other transaction. Suppose `A` transfers all
    of this 600 exactly at the same time while transferring to `B`; both transactions
    should act independently, ensuring the balance before transferring the amount.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Durability**: The data should be persistent on disk and should not be lost
    despite any database or system failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InnoDB`, the default storage engine in MySQL, supports transactions whereas
    MyISAM does not support them.'
  prefs: []
  type: TYPE_NORMAL
- en: Performing transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create dummy tables and sample data to understand this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start a transaction (set of SQLs), execute the `START TRANSACTION` or `BEGIN` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then execute all the statements that you wish to be inside a transaction, such
    as transferring 100 from `A` to `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After making sure that all the SQLs are executed successfully, execute the `COMMIT`
    statement, which will finish the transaction and commit the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you encounter any error in between and wish to abort the transaction, you
    can issue a `ROLLBACK` statement instead of `COMMIT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, instead of sending to `B`, if `A` wants to transfer to an account
    that does not exist, you should abort the transaction and refund the amount to
    `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Autocommit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, autocommit is `ON`, which means that all individual statements
    are committed as soon as they are executed unless they are in a `BEGIN...COMMIT`
    block. If autocommit is `OFF`, you need to explicitly issue a `COMMIT` statement
    to commit a transaction. To disable it, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: DDL statements, such as `CREATE` or `DROP` for databases and `CREATE`, `DROP`,
    or `ALTER` for tables or stored routines cannot be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain statements such as DDLs, `LOAD DATA INFILE`, `ANALYZE TABLE`,
    replication-related statements and so on that cause implicit `COMMIT`. For more
    details on these statements, refer [https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html](https://dev.mysql.com/doc/refman/8.0/en/implicit-commit.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using savepoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using savepoints, you can roll back to certain points in the transaction without
    terminating the transaction. You can use  `SAVEPOINT identifier` to set a name
    for the transaction and use the `ROLLBACK TO identifier` statement to roll back
    a transaction to the named savepoint without terminating the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose `A` wants to transfer to multiple accounts; even if a transfer to one
    account fails, the others should not be rolled back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Isolation levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When two or more transactions occur at the same time, the isolation level defines
    the degree at which a transaction is isolated from the resource or data modifications
    made by other transactions. There are four types of isolation levels; to change
    the isolation level, you need to set the `tx_isolation` variable which is dynamic
    and has session level scope.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To change this level, execute `SET @@transaction_isolation = 'READ-COMMITTED';`.
  prefs: []
  type: TYPE_NORMAL
- en: Read uncommitted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current transaction can read data written by another uncommitted transaction,
    which is also called **dirty read**.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `A` wants to add some amount to his account and transfer it to
    `B`. Assume both the transactions happen at the same time; the flow will be like
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '`A` initially has $400 and wants to transfer $500 to `B` after adding $500
    to his account.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **# Transaction 1 (adding amount)** | **# Transaction 2 (transferring amount)**
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: You can notice that *Transaction 2* has read the data that is not committed
    or rolled back from *Transaction 1*, causing account `A` to go into negative balance
    after this transaction, which is clearly not desired.
  prefs: []
  type: TYPE_NORMAL
- en: Read committed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current transaction can read only the data committed by another  transaction,
    which is also called **non-repeatable read**.
  prefs: []
  type: TYPE_NORMAL
- en: Take the same example again where `A` has $400 and `B` has $600.
  prefs: []
  type: TYPE_NORMAL
- en: '| **# Transaction 1 (adding amount)** | **# Transaction 2 (transferring amount)**
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: You can notice that, in the same transaction, different results are fetched
    for the same `SELECT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A transaction will see the same data that is read by the first statement even
    though another transaction has committed the data. All consistent reads within
    the same transaction read the snapshot established by the first read. An exception
    is a transaction that can read the data changed within the same transaction.
  prefs: []
  type: TYPE_NORMAL
- en: When a transaction starts and executes its first read, a read view will be created
    and stay open until the end of the transaction. In order to provide the same result
    set until the end of the transaction, `InnoDB` uses row versioning and `UNDO`
    information. Suppose *Transaction 1* has selected a few rows and another transaction
    has deleted those rows and committed the data. If *Transaction 1* is open, it
    should be able to see the rows it has selected at the beginning. The deleted rows
    are preserved in the `UNDO` log space to fulfill *Transaction 1*. Once *Transaction
    1* finishes, the rows are marked to be deleted from the `UNDO` logs. This is called
    **Multi-Version Concurrency Control** (**MVCC**).
  prefs: []
  type: TYPE_NORMAL
- en: Take the same example again where `A` has 400 and `B` has 600.
  prefs: []
  type: TYPE_NORMAL
- en: '| **# Transaction 1 (adding the amount)** | **# Transaction 2 (transferring
    the amount)** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: This applies only to `SELECT` statements and not necessarily to DML statements.
    If you insert or modify some rows and then commit that transaction, a `DELETE`
    or `UPDATE` statement issued from another concurrent `REPEATABLE READ` transaction
    could affect those just-committed rows, even though the session cannot query them.
    If a transaction does update or delete rows committed by a different transaction,
    those changes become visible to the current transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **# Transaction 1** | **# Transaction 2** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|   -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **# Transaction 1** | **# Transaction 2** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: Serializable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This provides the highest level of isolation by locking all the rows that are
    being selected. This level is like `REPEATABLE READ`, but `InnoDB` implicitly
    converts all plain `SELECT` statements to `SELECT...LOCK IN SHARE MODE` if autocommit
    is disabled. If autocommit is enabled, `SELECT` is its own transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **# Transaction 1** | **# Transaction 2** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **# Transaction 1** | **# Transaction 2** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: '|  -- |'
  prefs: []
  type: TYPE_TB
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '| -- |'
  prefs: []
  type: TYPE_TB
- en: So, serializable waits for the locks and always reads the latest committed data.
  prefs: []
  type: TYPE_NORMAL
- en: Locking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of locking:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal locking**: MySQL performs internal locking within the server itself
    to manage contention for table contents by multiple sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External locking**: MySQL gives the option to client sessions to acquire
    a table lock explicitly for preventing other sessions from accessing the table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal locking**: There are mainly two types of locks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Row-level locks**: The locking is granular to the level of rows. Only the
    rows that are accessed are locked. This allows simultaneous write access by multiple
    sessions, making them suitable for multi-user, highly concurrent, and OLTP applications.
    Only `InnoDB` supports row-level locks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Table-level locks**: MySQL uses table-level locking for `MyISAM`, `MEMORY`,
    and `MERGE` tables, permitting only one session to update those tables at a time.
    This locking level makes these storage engines more suitable for read-only, read-mostly,
    or single-user applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/internal-locking.html](https://dev.mysql.com/doc/refman/8.0/en/internal-locking.html)
    and [https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)
    to know more about the `InnoDB` locks.
  prefs: []
  type: TYPE_NORMAL
- en: '**External Locking**: You can use `LOCK TABLE` and `UNLOCK TABLES` statements
    to control the locks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table locking for `READ` and `WRITE` are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ`: When a table is locked for `READ`, multiple sessions can read data
    from the table without acquiring a lock. Also, multiple sessions can acquire a
    lock on the same table, that is why a `READ` lock is also called a **shared lock**.
    When a `READ` lock is held, no session can write data into the table (including
    the session that held the lock). If any write attempt is make, it will be in waiting
    state until the `READ` lock is released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WRITE`: When a table is locked for `WRITE`, no other session can read and
    write data from the table except the session that held the lock. No other session
    can even acquire any lock until the existing lock is released. That is why this
    is called `exclusive lock`. If any read/write attempt is make, it will be in waiting
    state until the `WRITE` lock is released.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the locks are released when the ;`UNLOCK TABLES` statement is executed or
    when the session terminates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To unlock the tables, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To lock all tables across all databases, execute the following statement. It
    is used when taking a consistent snapshot of the database. It freezes all writes
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Locking queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No two locks can be held together on a table except shared locks (a table can
    have multiple shared locks). If a table already has a shared lock and an exclusive
    lock comes, it will be kept in a queue until the shared lock is released. When
    an exclusive lock is in a queue, all subsequent shared locks are also blocked
    and kept in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: '`InnoDB` acquires a metadata lock when reading/writing from a table. If a second
    transaction requests `WRITE LOCK`, it will be kept in a queue until the first
    transaction completes. If a third transaction wants to read the data, it has to
    wait until the second transaction completes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction 1:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that `COMMIT` is not executed. The transaction is kept open.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction 2:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This statement has to wait until transaction 1 completes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction 3:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Even transaction 3 will not give any result because an exclusive lock is in
    the queue (it is waiting for transaction 2 to complete). Moreover, it is blocking
    all operations on the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check this by checking `SHOW PROCESSLIST` from another session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can notice that both transaction 2 and transaction 3 are waiting for transaction
    1.
  prefs: []
  type: TYPE_NORMAL
- en: To know more about a metadata lock, refer to [https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html](https://dev.mysql.com/doc/refman/8.0/en/metadata-locking.html).
    The same behavior can be observed while using `FLUSH TABLES WITH READ LOCK`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction 1:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note that `COMMIT` is not executed. The transaction is kept open.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transaction 2:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '**Transaction 3:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Even transaction 3 will not give any result because `FLUSH TABLES` is waiting
    for all the operations on the table to complete before getting a lock. Moreover,
    it is blocking all the operations on the table.
  prefs: []
  type: TYPE_NORMAL
- en: You can check this by checking `SHOW PROCESSLIST` from another session.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For consistent backup, all the backup methods use `FLUSH TABLES WITH READ LOCK`,
    which can be very dangerous if there is a long-running transaction on table.
  prefs: []
  type: TYPE_NORMAL
