- en: Chapter 7. Dynamic Front Ends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter we built a tower toppling physics game where the player
    could use TNT, Wrecking Balls, and Magnetic Cranes to destroy towers made of Glass,
    Wood, and Steel Pillars. In this chapter we are going to build this game by implementing
    a Shop, a Score Screen, and Level Intro Dialog. We are also going to rework the
    HUD so that only the equipment that is available can be used to implement a countdown
    timer, and add buttons for restarting the level and going to the Shop. In order
    to accomplish all of this, we will spend some time looking at arrays and data
    structures for storing information and using global variables.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the rooms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter we built two rooms, `Level_01` and `Level_12`, for testing
    the HUD and game difficulty. We now need to make rooms for all the levels in between
    those two, plus a few additional rooms for the Front End, Shop and Level Select:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Room for each level from `Level_02` to `Level_11`. Set the size
    of the rooms as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Level_02` – `Level_04` is set to **Width**: `640` and **Height**: `480`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Level_05` – `Level_08` is set to **Width**: `960` and **Height**: `720`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Level_09` – `Level_11` is set to **Width**: `1280` and **Height**: `960`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each room needs to have **Room is Physics World** checked in the **Physics**
    tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that **Views** | **Port on Screen** is set to **X**: `0`, **Y**:
    `0`, **W**: `640`, and **H**: `480` so that each room will display properly on
    screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have supplied backgrounds for each level which can be found in `Chapter 7/Backgrounds/`.
    Make sure that **Remove Background** is not checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each level should have a unique tower built from a variety of Pillars and ideally
    be made more difficult than the previous level. Start by placing the ground down
    in the room which requires a different Y coordinate depending on the size of the
    Room. The Y placement is indicated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Level_02` – `Level_04`: **384**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Level_05` – `Level_08`: **576**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Level_09` – `Level_11`: **784**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populate the levels with one instance of `obj_Overlord` and `obj_Menu` each.
    Each room should look something like the following screenshot:![Setting up the
    rooms](img/4100_07_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the levels have been built, we can move on to the Front End. Create a new
    Room and in the **Settings**, name it `MainMenu`, with a **Width** of `640` and
    **Height** of `480`. Move this to the top of the `Rooms` folder in the Resource
    Tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Background, `bg_MainMenu`, and load `Chapter 7/Backgrounds/BG_MainMenu.png`.
    Make sure that **Remove Background** is not checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Room Properties** | **Background** tab, set **Background 0** to `bg_MainMenu`.
    The box for **Visible when room starts** should be checked. We are done with this
    room for now so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need two additional rooms for the Front End: `LevelSelect` and `Shop` with
    the appropriate backgrounds applied. The position in the Resource Tree does not
    matter. We now have all the rooms we will need for the game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initializing the main menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main menu is the very first screen the player will see and it consists
    of two objects: a button to start the game and a game initializing object with
    all the global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with an object for initializing the game. Create a new Object and
    name it `obj_Global`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Script called `scr_Global_GameStart`. We will be adding code to
    this as we go along, but for now we just need to initialize the score:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Add an **Other** | **Game Start** event and apply `scr_Global_GameStart`. Click
    on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reopen `MainMenu` and place a single instance of `obj_Global` somewhere in the
    room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to be creating a few buttons, so let's build a parent object to
    run the common functionality of hover states. Create a new Object called `obj_Button_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All buttons will have multiple frames of animation to be used for the hover
    states, so we need to stop them from playing. Create a new Script, `scr_Button_Parent_Create`,
    and attach this to a **Create** event with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Script, `scr_Button_Parent_MouseEnter`, and attach it to a **Mouse**
    | **Mouse Enter** event with the code to change it to the second frame of animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to reset this by creating another new Script, `scr_Button_Parent_MouseLeave`
    and attach it to a **Mouse** | **Mouse Leave** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent object is now complete and the setting should look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing the main menu](img/4100_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next we can build the first real button. Create a new Sprite, `spr_Button_Start`,
    with **Remove Background** turned off, and load `Chapter 7/Sprites/Button_Start.gif`.
    **Center** the **Origin** and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Button_Start`, and apply `spr_Button_Start` as the
    **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the **Parent** to be `obj_Button_Parent` so that the hover states will function
    properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since each button will do something different we need to give each button its
    own click event. Create a new Script, `scr_Button_Start_MousePressed`, and attach
    it to a **Mouse** | **Left Pressed** event with the following code to go to the
    room `LevelSelect`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This button is now complete. Place a single instance of `obj_Button_Start`
    into `MainMenu` near the bottom of the screen at **X**: `320` and **Y**: `416`.
    The Room should look like the following screenshot:![Initializing the main menu](img/4100_07_01.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game to make sure that it starts with `MainMenu` and that the **Start**
    Button functions as designed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Selecting levels with 2D arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next room we are going to build is `LevelSelect`. In this room there will
    be a button for going to the Shop and buttons for each level in the game, with
    only the first level unlocked at the start. As the player progresses, the buttons
    will unlock and the player will have access to all previous levels. To achieve
    this we will dynamically create buttons for each level in the game and use a 2D
    array to store all this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'A 2D array is just like the arrays we have already used in the book. It is
    a single static list of data but it allows for multiple values per row, like a
    spreadsheet. This is a very powerful tool at our disposal as it makes it much
    simpler to group several different elements together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Global_Levels`, and start by initializing some global
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we are always trying to simplify our code we can use an alternate method
    of declaring global variables with `globalvar`. This declaration method functions
    exactly the same way as `global`, but it will allow us to write `level` instead
    of `global.level`. While this will save us plenty of keystrokes, it is up to us
    to remember that it is a global variable as it is not as obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to create a 2D array with one column holding the level and another
    with whether it is locked or not. Let''s just add the first level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To create a 2D array, you just need to place two numbers inside the brackets.
    The first number is for the row and the second for the column. Here we have only
    a single row that has two columns. The first column will hold the room name and
    the second column will be for whether that room is locked or not; in this case
    `Level_01` is unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one drawback in using simple arrays in GameMaker: Studio that there
    is no function to find out the size of the array. We need to know the size of
    this array so that we can dynamically create all the buttons. We already created
    a global variable to hold the total amount of levels; we just need to manually
    set its value. Let''s add all the levels into the array, lock them, and set the
    `totalLevels` variable. Here is the complete script for all 12 levels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We need to initialize this array at the start of the game. Reopen `scr_Global_GameStart`
    and execute this script after the score variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's move onto building the button for going to the Shop. Create a new Sprite,
    `spr_Button_Shop`, and with **Remove Background** turned off, load `Chapter 7/Sprites/Button_Shop.gif`.
    **Center** the **Origin** and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Button_Shop`, and apply `spr_Button_Shop` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a standard button so set the **Parent** to `obj_Button_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last thing we need to do to this object is to add a **Mouse** | **Left
    Pressed** event and apply a new Script, `scr_Button_Shop_MousePressed` with the
    code to switch rooms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We will draw some text onto these buttons which means that we need to bring
    in some fonts. We have supplied a font called Boston Traffic in this game, which
    is needed to be installed on your computer. To install this font on a Windows
    computer, right-click on `Chapter 7/Fonts/boston.ttf` and select **Install**.
    Then follow the directions when prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in GameMaker: Studio we need to create three new fonts: `fnt_Large`, `fnt_Medium`,
    and `fnt_Small`. All three will have a **Font** of `Boston Traffic`. Set the **Size**
    of `fnt_Large` to `20`, `fnt_Medium` to `16`, and `fnt_Small` to `10`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we can move onto the buttons for selecting the levels. We will be dynamically
    creating these buttons and drawing a number on each one of them so that we only
    need a single art asset. Create a new Sprite, `spr_Button_LevelSelect`, and with
    **Remove Background** turned off, load `Chapter 7/Sprites/Button_LevelSelect.gif`.
    **Center** the **Origin** and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Button_LevelSelect`, and apply `spr_Button_LevelSelect`
    as the **Sprite**. These buttons cannot be parented to `obj_Button_Parent` as
    they require the ability to have a locked state, which will affect the hover states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this button type is unique, we need to initialize some variables. Create
    a new Script, `scr_Button_LevelSelect_Create`, and attach it to a **Create** event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We start by making all buttons locked by default. We set a default room for
    the room it should go to when clicked, and a number that we will draw on top.
    Finally we stop the sprite from animating and set an alarm for one step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using an alarm so that we can ensure that the levels will properly display
    whether they are locked or not. Create a new Script, `scr_Button_LevelSelect_Alarm0`,
    and attach it to an **Alarm** | **Alarm 0** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If the button is to be locked, we set the sprite to display the locked frame.
    Otherwise it is unlocked and we show the first frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Script, `scr_Button_LevelSelect_MouseEnter`, and apply it to a
    **Mouse** | **Mouse Enter** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For the hover state of the button we first check to see if it is locked. If
    it is, we just exit the script immediately. If it is unlocked, we switch to the
    hover frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'This same logic needs to be applied to when the mouse leaves the button. Create
    another new Script, `scr_Button_LevelSelect_MouseLeave`, and apply it to a **Mouse**
    | **Mouse Leave** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will add a **Mouse** | **Left Pressed** event with a new Script, `scr_Button_LevelSelect_MousePressed`,
    attached with code to change rooms if it is unlocked only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need a new Script, `scr_Button_LevelSelect_Draw` that we can
    use to draw the button with the appropriate number on top. Add this to a **Draw**
    | **Draw** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First we need to draw the sprite that has been applied to the object itself.
    Next we set the drawing color to black, set the font, and center align the text.
    We then draw the text held in the `myNum` variable, dropping it down a bit on
    the Y axis so that it centers vertically. Since we will be drawing a lot of text
    in this game, we should force the font to the default font by setting it to `-1`
    value. This will help prevent this font from affecting any other drawn font in
    the game:'
  prefs: []
  type: TYPE_NORMAL
- en: We are now finished with the level selection button and the properties should
    look like the following screenshot:![Selecting levels with 2D arrays](img/4100_07_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have all the components we need for a level selection screen, we just
    need to spawn everything. For this we will create a new Object, `obj_LevelSelect_Overlord`,
    to build the menu upon entering the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an **Other** | **Room Start** event and attach a new Script, `scr_LevelSelect_Overlord_RoomStart`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start by establishing variables for the row and columns that we will need
    for the layout of the buttons. We then run a loop starting at zero and run it
    for the total amount of levels we declared in the global variable `totalLevels`.
    Inside this loop, we first create an instance of `obj_Button_LevelSelect` and
    offset it in both horizontal and vertical directions with an additional 128 pixels
    of padding for a margin between the edge of the screen and the buttons. We then
    change the button's `myLevel` and `isLocked` variables by setting it according
    to the values in the `level` global array. Next we change the `myNum` variable
    to indicate what number will be drawn on the button. The last few lines of code
    are how we will limit the amount of columns and add additional rows of buttons.
    Every loop we increase the column count and once it passes five we reset it to
    zero. This will give us a row of six buttons. If we have more than six buttons,
    a new row will be created that can have another six buttons. This means we can
    add levels to the array later and they will be added into this menu automatically
    creating new rows for every six levels. Last but not least, we spawn an instance
    of the **SHOP** button at the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Open `LevelSelect` and place a single instance of `obj_LevelSelect_Overlord`
    somewhere in the room. This is all we need, and to do so click on the checkmark.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game. After clicking start game, you should end up in `LevelSelect`
    and it should look like the following screenshot. Only Level 1 is accessible at
    this point and the button is yellow. All the other buttons are gray, indicating
    that they are locked. Clicking on the button for **Level 1** will take you to
    that level and the **SHOP** button should take you to the Shop.![Selecting levels
    with 2D arrays](img/4100_07_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preparing the Shop using data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only room we have left to build is the Shop where the player will be able
    to purchase equipment to be used in each level. The room will consist of icons
    for each piece of equipment, a listing of the price, and a button to purchase
    the equipment. We will also have a display showing how much cash the player currently
    has and this will update as they spend money:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do before we build anything is to establish some
    constants to make our code easier to read. Open the **Resources** | **Define Constants**
    editor and set values for the equipment: `TNT`: `0`, `WRECKINGBALL`: `1`, `MAGNET`:
    `2`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will also need some constants that describe all the elements that comprise
    a piece of equipment. Add `SPRITE`: `0`, `OBJECT`: `1`, `AMOUNT`: `2`, and `COST`:
    `3`. When this is complete the settings in the editor should look like the following
    screenshot:![Preparing the Shop using data structures](img/4100_07_04.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to stick with the color scheme of the game we will need to create
    a unique yellow color that we can access globally. Create a new Script, `scr_Global_Colors`,
    with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We create a global variable for our color and then use a function that has parameters
    for the amount of red, green, and blue to make our special yellow color.
  prefs: []
  type: TYPE_NORMAL
- en: Open `scr_Global_GameStart` and execute `scr_Global_Colors()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To build a proper Shop and inventory system we need more control over the data
    than a static array allows. We need something more malleable and searchable. This
    is where **data structures** come in. Data structures are special dynamic structures
    similar to arrays, but with the ability to manipulate the data with specific functions
    for things such as shuffling or reordering the data. GameMaker: Studio comes with
    six different types of data structures, each with its own set of functions and
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stacks**: This structure is last-in-first-out, meaning that each new piece
    of data is placed on top of the previous one and when it is read, the newest data
    is read first. Think of it like a stack of plates, where you are going to use
    the one last placed on the shelf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Queues:** This structure is first-in-first-out, meaning that each new piece
    of data is placed behind the one previous to it and when read, the oldest data
    is read first. Think of a line at a store, where the first person in line is going
    to be served first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists**: This structure is much more flexible. In this structure the data
    can be placed anywhere within the list and can be sorted, altered, and searched
    throughout. Think of this like a deck of cards, where they can be in any order
    which can be changed any time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maps**: This structure allows for information to be stored in linked pairs
    using keys and values, though it cannot be sorted and all keys must be unique.
    Think of a set of keys, where each key opens only the associated door.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority Queues**: This structure is similar to a queue, but each value is
    assigned a priority level. Think of this like a line at a nightclub, where VIPs
    have a higher priority and are let in first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grids**: This structure is the most robust and is similar to a 2D array.
    It has rows and columns, but it has many functions for sorting, searching, and
    manipulating the data. Think of a searchable airport departure schedule, where
    you can see all the planes, the companies, flight times, and so on, and sort it
    according to your preference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to start with a Grid data structure as we need several rows and
    columns of information for each item. Create a new Script, `scr_Global_Equipment`
    and write the following code to build the Grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We start by declaring a global variable which we then use to hold the ID of
    a Grid. When creating a Grid we need to declare how many rows and columns it needs.
    For this game we have three rows for the pieces of equipment and each piece has
    four columns of data. We set the value for each Grid cell individually, so slot
    0 is the sprite to use, slot 1 the object to spawn, slot 2 is for how many the
    player starts with, and finally, slot 3 is how much it will cost to purchase.
    We have done this for each piece of equipment and we (the player) will start the
    game with single TNT only.
  prefs: []
  type: TYPE_NORMAL
- en: Reopen `scr_Global_GameStart` and call this script. We now have all the equipment
    categorized and ready for the Shop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next we need to create an inventory for the player to track what equipment
    they have purchased. Since the player needs to add equipment to the inventory
    and will also use that equipment, we need a data structure that is easily mutable.
    We will use a List for this purpose. Create a new Script, `scr_Global_Inventory`,
    and start a List:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We declare a global variable and then use it to hold the ID of the List we create.
    At the start of the game we have already established that the player will have
    some TNT, so that is all we need in the inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, call this script in `scr_Global_GameStart`. Here is the complete
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the data stored, we can move on to building the item menu.
    The first element we need to create is a purchase button. Create a new Sprite,
    `spr_Button_Buy`, and with **Remove Background** turned off, load `Chapter 7/Sprites/Button_Buy.gif`.
    **Center** the **Origin** and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_Button_Buy`, and assign `spr_Button_Buy` as the **Sprite**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a standard button so set the **Parent** to `obj_Button_Parent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Mouse** | **Left Pressed** event and apply a new Script, `scr_Button_Buy_MousePressed`,
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In order to purchase an item, we first need to check to see if the player has
    enough money. For this, we compare the `score` against the data held in the Grid
    we created. You will notice that we have a variable, `myItem`, that has not been
    initialized in the button itself. We will create that variable dynamically later,
    when we spawn the button. If the player can purchase the item, we increase the
    amount the player owns, and reduce the amount of money by the price of the item.
    Finally, we check to see if the player already has some of the item in their current
    inventory. If this is the first item of its type, we add it to the inventory List.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to spawn everything in the room with a new Object called `obj_Shop_Overlord`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an **Other** | **Room Start** event and attach a new Script, `scr_Shop_Overlord_RoomStart`,
    with the code for spawning the buttons needed in the Shop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start by running a loop through each row of the equipment Grid so that we
    know how many buttons need to be created. We then spawn a purchase button which
    will be stacked vertically on screen. Next we pass the `myItem` variable that
    is used in the mouse pressed event. The last thing we do is create a start button
    in the lower right corner of the screen so that the player can go back to `LevelSelect`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all the buttons placed, but we still need to draw all the other
    necessary information. Create a new Script, `scr_Shop_Overlord_Draw`, and add
    it to a **Draw** | **Draw** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First we need to set the font color to black and center-align the text. We then
    run a loop through the equipment Grid to draw each component. We first draw the
    proper sprite in the correct location to line up with the buttons. Here we use
    a small font to draw the amount of the item the player owns in the small space
    in the lower right corner of the sprite. We then change to a large font and display
    the price of the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu is now built but it is still missing an important piece of information;
    how much cash the player has. Add the following at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We set the color to our special yellow color for the rest of this text. We set
    a medium font to display the word `Cash` and then change to a large font for the
    actual amount they have. Finally, we reset the font to default.
  prefs: []
  type: TYPE_NORMAL
- en: Open up `Shop` and place a single instance of `obj_Shop_Overlord` object somewhere
    in the room. We are done with this room so click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and go to the Shop. You won't be able to purchase anything at this
    point but you should see the icons, buttons, and information properly displayed.
    It should look like the following screenshot:![Preparing the Shop using data structures](img/4100_07_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebuilding the HUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Game development is an iterative process where elements are added in when they
    are needed and often reworked several times as features are implemented and feedback
    from users changes the direction of the project. Building a game in this fashion
    saves time because it allows us to get things done quickly, see the results, and
    adapt as we go. In the last chapter we were focused on functionality of the basic
    gameplay. We built a simple HUD that allowed us to spawn each piece of equipment
    with a click. However, we did not limit what equipment the player had access to,
    nor did it have the ability to restart the level or show a countdown timer displaying
    how much time was remaining to clear the Zone. We will need to fix all of this,
    plus we should allow the player to go to the Shop in case their supplies are running
    low. All of this can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by adding some global variables. Create a new Script, `scr_Global_Gameplay`,
    and declare the necessary global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we initialize two variables that we will need to improve the functionality
    of the game. The variable `isGameActive` will be set to `true` at the start of
    each level to commence gameplay. It will also afford us the ability to display
    information at the end of the level while preventing the player from using the
    Menu. The `isTimerStarted` variable will be used for the countdown to clear the
    Zones.
  prefs: []
  type: TYPE_NORMAL
- en: Open `scr_Global_GameStart` and call this the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Menu is also going to need some new variables. Open `scr_Menu_Create` and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first variable is the amount of time the player will have for a countdown.
    Here we are going to give ten seconds for the Zone to be cleared. We then set
    the vertical location of the menu to be near the bottom of the screen. The next
    two variables are for the horizontal location of the Restart and Shop buttons.
    We need some temporary variables for holding the value of the equipment used and
    how much the player earns in the level as we don't want to change the global score
    unless the player wins the level. Finally, we create another Grid and copy the
    data from the `equip` Grid so that if the level is restarted we still have the
    original settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also want to make sure that the player is unable to play a level if
    they have no equipment in their inventory. If that happens we will want to automatically
    go to the Shop. At the very top of the script, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We check the size of the inventory and if it contains nothing we go to the Shop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous draw script we used for the Menu functioned adequately for what
    we needed at the time. However, now that we have data structures, we can simplify
    the system and add new functionality. We will start by creating a new Script,
    `scr_Menu_Equipment`, for which we will need to accept some parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We start by declaring two variables for the two arguments that must be supplied
    when calling this script. **Arguments** are just variables that pass information
    from a script or function when it is called. Here we will have a slot placement
    on the Menu and a declaration of what item is to be displayed in the slot. Since
    we have a predetermined amount of slots on our Menu to be three, we can check
    which slot is being passed and apply the appropriate horizontal offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we will add the functionality for how the Menu equipment buttons work.
    Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Previously we had code similar to this for each piece of equipment. Now that
    we have the data structure, we can use the information to create all of the equipment
    dynamically. We start by drawing the sprite that is pulled from the local `startEquip`
    Grid. We then check to see if the Menu is active due to the player trying to place
    an item. We check for the mouse location on screen and see if it is hovering above
    the button and change to the appropriate frame of animation. If the button is
    clicked, we create the selected item, subtract one unit of the item from the Grid,
    add the value of the item to how much the player has spent, and make the Menu
    active.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have drawn all the Equipment buttons, but we haven''t displayed how many
    items the player has in their inventory. To fix this, add the following code to
    the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All we are doing here is setting the color, horizontal alignment of the text,
    and the font. We then draw the amount of units for each item in the lower right-hand
    corner as we did in the Shop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the improved and simplified Equipment button code, we can
    go back to `scr_Menu_DrawGUI` and remove all the old clunky code. Delete all the
    code except for the very first line that draws the menu background. Once it has
    been removed, add the following code to draw the Menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking whether the global variable `isGameActive` is true or not.
    If it is true, we get the screen location of the mouse, so we have the proper
    information to place the menu correctly. We then run a loop for as many objects
    as the player has in the inventory, which will then execute the menu equipment
    script to draw all the buttons. At the very end of the script we once again set
    the font back to its default.
  prefs: []
  type: TYPE_NORMAL
- en: The HUD needs more than just buttons for the equipment. For a game like this
    we definitely need a button that allows the player to restart the level. Let's
    quickly create a new Sprite, `spr_Button_Restart`, and with **Remove Background**
    turned off, load `Chapter 7/Sprites/Button_Restart.gif`. **Center** the **Origin**
    and click on **OK**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We do not need to create an object for this button as it is going to be drawn
    on the Menu. Create a new Script, `scr_Menu_Button_Restart`, and write the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with the Equipment buttons, we start by drawing the button in
    its non-hovered state. We then check if the mouse is hovering over the button,
    and if it is, we change the animation to the hover state. If the button is clicked,
    we restart the room.
  prefs: []
  type: TYPE_NORMAL
- en: Reopen `scr_Menu_DrawGUI` and call this script after the loop that creates the
    buttons for the equipment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We also need a button to allow the player to access the Shop. We can''t use
    the button we previously created as we need it to be drawn on the menu, not spawned
    in the world. Luckily, we can use its sprite so all we need to do is create a
    new Script, `scr_Menu_Button_Shop`, with code similar to all the other menu buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Same as before, we draw the sprite and then check whether the mouse is hovering
    or not, making sure that we change the width to the larger size of this sprite.
    If the button is clicked, we go to the Shop.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, open `scr_Menu_DrawGUI` and call this script immediately after the
    Restart button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are almost finished with the HUD, we only have one very important piece
    of information we still need to show the player: How much time is left. This will
    be done completely with text, so all we need to do is create a new Script, `scr_Menu_Clock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The background is black, so we will use the yellow color we created for all
    the text. If the global variable `isTimerStarted` is true, we draw the word `"COUNTDOWN"`
    in small letters and the amount of time remaining in a large font underneath it.
    If `isTimerStarted` is false, we then draw the text in a similar manner to indicate
    to the player what they are supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reopen `scr_Menu_DrawGUI` and call this script after the Shop button call.
    The completed script should look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the countdown started we need to activate it, which we can do in `scr_Overlord_KeyPress`.
    Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We check the `isTimerStarted` variable to see if it has been activated already
    or not as we only want it to happen once. If the timer has not started, it will
    turn on an alarm in the Menu in one second.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do to get everything to work is to open `obj_Menu`
    and add an **Alarm** | **Alarm 0** event with a new Script, `scr_Menu_Alarm0`,
    attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The Menu has a timer initialized for ten seconds and in this alarm we check
    to see if there is still time remaining. If there is, we reduce the time by one
    and reset the alarm for another second. This will repeat until time expires, in
    which case we tell the Overlord to run the victory condition alarm immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The HUD is now controlling the time so we need to remove that functionality
    from the Overlord. Reopen `scr_Overlord_Step` and remove the line of code that
    sets the alarm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and play the first level. The Menu has a single Equipment button
    of TNT, a Restart button, and a Shop button. Once you hit spacebar, the countdown
    timer will start ticking down until zero. When time expires the room will either
    restart or go to the next room based on whether the Zone is clear or not. The
    game should look like the following screenshot:![Rebuilding the HUD](img/4100_07_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding risk and reward to destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far there has been very little risk or reward in the game at all. We have
    added a Shop to the game where we can purchase items, but we are not yet able
    to earn any cash. We can use as much equipment as we want, as long as it is in
    our inventory, which means that there is no need for strategy. We need to add
    a Game Over Screen, if the player ever runs out of money or completes all the
    levels. We also need a Score Screen as currently the player has no idea how well
    they did so we will want to show that as well. It''s time to add these features
    starting with rewarding the player points:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the Game Over screen. Create a new Room called `GameOver`
    and apply `bg_MainMenu` as its background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Object, `obj_GameOver`, with no **Sprite** attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon creation we will create a variable that will contain the game over message
    and we will set an alarm for five seconds, which we will use to restart the game.
    Create a new Script, `scr_GameOver_Create`, with the following code and attach
    it to a **Create** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an **Alarm** | **Alarm 0** event and then attach a new Script, `scr_GameOver_Alarm0`,
    and restart the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'All that we have left to do is to draw the win/lose statement. Create a new
    Script, `scr_GameOver_Draw`, and attach it to a **Draw** | **Draw** event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If it isn't still open, reopen `GameOver` and place a single instance of `obj_GameOver`
    somewhere in the room. We are now done with this and can close the room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we will create is a new Object, `obj_ScoreFloat`, to display
    the points rewarded as each Pillar or Debris is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Create** event with a new Script, `scr_ScoreFloat_Create`, and initialize
    two variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We will have the score fade out over time, so we have a variable for triggering
    the fade out and one for the value of transparency which is currently set to full
    opacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to add a **Draw** | **Draw** event with a new Script, `scr_ScoreFloat_Draw`,
    to show the value on screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This object is not a part of the physics world, so we can manually move it vertically
    every frame. We increase the `fadeOut` variable and once it hits 60, we start
    to decrease the `alpha` variable by a small amount. Once `alpha` has hit zero,
    we destroy the instance so that it doesn't take up any memory. After that we set
    the color, font, and transparency values and draw the text. The `myValue` variable
    will be passed upon creation from the object that spawns it. Finally, we set the
    transparency back to full opacity; otherwise everything else in the entire room
    will fade out as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can display the score we need to spawn it and pass a value to it.
    Since we already know that each Pillar and Debris has a different mass, we can
    use that number to award points upon its destruction. Reopen `scr_Pillar_BreakApart`
    and insert the following code after the shatter sound is played but before the
    instance is destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When the Pillar breaks apart it will spawn an instance of `obj_ScoreFloat`.
    We then set the displayed value to the rounded down amount of the object's total
    mass. Finally, we increase the Menu's `tempScore` by the same amount.
  prefs: []
  type: TYPE_NORMAL
- en: We need the Small Pillars and Debris to do the same, so open `scr_Pillar_Destroy`
    and insert the same code in the same place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the game and destroy the Pillars in the first level. As each piece breaks,
    a number will float up signifying the value that it is worth. The floating numbers
    should fade out after a few seconds and should look something like the following
    screenshot:![Adding risk and reward to destruction](img/4100_07_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All we need to do now is to make a Score Screen that sums up the damage and
    shows the total profit for the level. We will start by bringing in a few more
    sprites, `spr_Screen_BG` and `spr_Button_NextLevel`, both supplied in `Chapter
    7/Sprites/`. Make sure not to **Remove Background** and to **Center** the **Origin**
    for both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create a new Script, `scr_Menu_Button_NextLevel`, with the functionality
    of this button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We only want the Next Level button to appear if the player successfully clears
    the Zones, so we check for that first. If the player has won the level, we draw
    the sprite and then check to see if the mouse is hovering over it. If the mouse
    is over the button and it is pressed, we run a quick loop through the level array
    to see what room we are currently in and unlock the next level. Finally we go
    to the room we just unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to create a new Object, `obj_ScoreScreen`, to display the Score
    Screen. Set the **Depth** to `-100` so that it always draws on top of all other
    GUI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Create** event with a new Script, `scr_ScoreScreen_Create` attached
    and initialize the following variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We don't want the player to play during this time, so we turn off the `isGameActive`
    variable and make the Menu active so that the Equipment buttons no longer function.
    Next we need to check if the player has been successful in order to know what
    to draw. The final seven variables are all for the placement of the various text
    and buttons we will be displaying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to add a **Draw** | **Draw GUI** event with a new Script, `scr_ScoreScreen_DrawGUI`
    and we will start by drawing all the text we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: First we draw the background sprite. We then set the color, alignment, and font.
    We are using the largest font to draw the name of the room and the values for
    the amount of damage, the amount of equipment used, and the total profit. We then
    switch to the medium font to write the description of each value, placed above
    the number it corresponds to. We are done drawing text, so we set the font back
    to its default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to add the buttons into the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with the Menu, we get the coordinates of the mouse on screen
    and then execute the scripts for the three buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to activate the Score Screen, we need to reopen `scr_Overlord_Alarm0`
    and have it spawn an instance of `obj_ScoreScreen` instead of the code it currently
    runs. Remove all the code and replace it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and finish the first level. After the timer has run out, the Score
    Screen appears displaying the damage, the cost, and the profit. The in-game menu
    has disappeared and has been replaced by three buttons for replaying the level,
    going to the Shop, or the next level. It should look like the following screenshot:![Adding
    risk and reward to destruction](img/4100_07_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There is one issue that we need to solve. While the screen says we have earned
    money, if we go to the Shop, there will be no cash available. This is because
    we haven''t transferred the temporary values to the global values, which we will
    do in a new Script called `scr_ScoreCleanUp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: When this script is executed, it will go into the Menu and copy the remaining
    equipment over to the global equipment values and then delete the temporary grid
    from memory. Next we increase the global score based on what occurred during gameplay.
    We then run a loop through the inventory looking for whether the player has run
    out of any items. If they have, we remove it from the inventory altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the player goes to the next level, we should pay them immediately. We should
    also check the score to make sure that the player has money. If they run out of
    money, then it is game over, otherwise they can go to the next level. Reopen `scr_Menu_Button_NextLevel`
    and replace the line of code where we switch rooms with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If the player decides to go to the Shop, it becomes a bit trickier. The script
    we are calling is also used on the Menu, so we don''t want it to change the data
    during gameplay. Reopen `scr_Menu_Button_Shop` and replace the line of code where
    we switch rooms with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now the score will be transferred only if gameplay has stopped. We also check
    the score here for the game over state to decide what room to go to when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Everything should work properly now, so run the game and check to make sure
    that the score doesn't change when you go to the shop during gameplay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding introductory text to each level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a good end to the levels, but the player may not be sure what to do.
    What we need is a bit of a story to sell the idea of destroying towers and explaining
    what it is the player needs to do in each level. To do this we will add a screen,
    much like the Score Screen at the start of each level:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a button to start the level, which again will need to be drawn
    on screen. Create a new Script, `scr_Menu_Button_Start`, with some very familiar
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: All the standard button code is here, but when the button is clicked, we activate
    the gameplay and then destroy the Story screen object. The `start_ZoneWidth` and
    `start_ZoneHeight` variables used here haven't been initialized yet, but we will
    be doing that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need all the text that we want to display for each level. For this
    we will want to use a Map data structure so that we can link the text to the level.
    Create a new Script, `scr_Global_Dialogue`, and write the dialog that we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We make a new global variable and attach it to the Map data structure we create.
    For each entry we need to have a **Key** and a **Value** for that key. Here we
    use the name of each room as a key and write the dialog as the value. We need
    text for every room in the game so it doesn't error out, so we have temporary
    dialog for rooms 2-12 that you can replace with your own text. In the dialog for
    Level 01 we are using `#` which is a special character used to start a new paragraph.
    This will make large amounts of text a bit more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Open `scr_Global_GameStart` and call this script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have all the art assets we need, but we do need a new Object, `obj_StoryScreen`,
    with a **Depth** of `-100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a **Create** event and apply a new Script, `scr_StoryScreen_Create`, to
    initialize the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We stop gameplay and then set six variables for the location of the text we
    will be drawing. We then load up the text from the Map based on the room the player
    is currently in. The last variable we have, `textLength` , is going to be used
    for an inventory effect, where the text appears to be typed in over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to add a **Draw** | **Draw GUI** event with a new Script, `scr_StoryScreen_DrawGUI`,
    that draws everything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As we did with the Score Screen, we draw the background and set the color, alignment,
    and font for the title of the level. Next is the typewrite effect for the dialog
    to be shown on screen. We change the alignment and font for the dialog and start
    increasing the `textLength` variable by one step each. This value is what determines
    how many characters from the dialog need to be copied over to the `writeText`
    variable, which means that the text will grow over time. We are using the `draw_text_ext`
    function, which allows us to limit how wide the paragraph can be before it drops
    down a line, in this case 320 pixels. Once again at the end we get the mouse location
    for the start button to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is left for us to do is to spawn an instance of the Story screen in
    `scr_Overlord_Create`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and go to the first level. The story screen appears and the dialog
    starts appearing one letter at a time and should look like the image below. When
    the **START** button is clicked, the gameplay starts as usual.![Adding introductory
    text to each level](img/4100_07_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving the player's progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polish in games is not always about the visual embellishments. Sometimes it's
    also about adding smaller features that aren't immediately noticeable but can
    drastically improve the overall experience. Currently the game looks good and
    plays well, but if we close down the browser and return to play at a later time,
    we will need to start all over again. Players these days expect that they can
    come back to a game and continue from where they left off. In order to do this,
    we need to save the player's progress.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever a game needs to save data the only viable option is to write the data
    to a file outside of the game itself. This poses a potential problem for web-based
    games as any file that needs to be downloaded will require the user to explicitly
    allow it. This would mean the player would know the name of the file and where
    it is located, which in turn would mean they could easily hack their own saved
    file. To get around this hurdle, HTML5 offers a solution known as **local storage**.
  prefs: []
  type: TYPE_NORMAL
- en: Local storage allows web pages, or in our case a game embedded into a web page,
    to save data within the browser itself. This is similar to internet cookies but
    with the benefit of being faster, more secure, and potentially able to store a
    lot more information. Since this data is saved in the browser, the user is not
    notified of the file being created or accessed; they cannot see the data easily
    and it is only accessible from the domain that creates it. This makes it perfect
    for saving our game data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are only two ways to clear the saved data. Overwrite the data or clear
    your browser's cache. It is recommended that you always test games in a private
    browser mode to guarantee the save system is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to local storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this game, we are going to save all the relevant data related to the levels
    unlocked, the amount of cash accrued, and the equipment purchased. To save the
    game data we are going to need to write to a file. GameMaker: Studio has two file
    formats that it can handle for HTML5 games: **Text files** and **Ini files** .
    Text files are useful for reading or writing large amounts of data and can be
    structured in any way you choose. Ini files are intended for smaller amounts of
    data and use a **section/key/value** structure. This structure breaks the data
    into separate sections and in each section there will be key/value pairs that
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Local storage requires all data to be in key/value pairs so that we will be
    using the Ini file system. It is possible to use the text file system, but for
    the little amount of data we need to save and the amount of extra coding it would
    take, it''s not very beneficial:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing any save system needs to do is to create a save file with the
    appropriate structure and settings desired. Create a new Script, `scr_GameSave`,
    and write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When we execute this script we will require the name of the file to be passed
    as an argument. We can then open the requested file, or if one is not found it
    will be created to open. Once the file is open we can write all of the necessary
    data. We start by writing to a `Score` section, with a key called `Cash` to set
    the value of score. We run a loop using the level array and in a `Levels` section
    we store each level and whether it has been unlocked or not. Next we run another
    loop, this time going through the equipment grid and writing how many of each
    item the player currently has in the game. Finally, after all the data has been
    written we close the file.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a game is only useful if we actually load the data into it. Create a
    new Script, `scr_GameLoad`, so we can read from the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We start by checking whether the file, as passed through the argument, exists.
    If the file is not found in local storage, such as the first time the game is
    run, we run the save script to initialize the values. If the file is found we
    open the save file and read the data into the game just as we saved it. We set
    the score, unlock the appropriate levels, and load the equipment. We also run
    through the inventory to ensure that all the equipment is available to the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will want to load any game data at the start of the game. Open `scr_Global_GameStart`
    and add the following code at the end of the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We create a global variable for the filename so we can save our data easily
    later. We then pass the string to the load script. This code must be at the end
    of the script because we need the default values for our grids and arrays to have
    been initialized first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most logical place to start saving the game is after the player has completed
    each level. Open `scr_ScoreCleanUp` and just before the final brace, insert a
    call to `scr_GameSave`. The entire script is seen below:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We also need to save the game when the player purchases Equipment in the Shop.
    Open `scr_Button_Buy_MousePressed` and insert the call to `scr_GameSave` just
    before the final brace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the game and play the first few levels. After you have completed a few
    levels, refresh the browser. You should see that all your cash, equipment, and
    unlocked levels remain the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving multiple game profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have a game that can save a player''s progress, but no way of clearing
    the data if they want to replay the game. As we mentioned already, the only option
    for removing the data is to have the user clear their browser''s cache or overwrite
    the data, both options having drawbacks. Most users won''t want to clear their
    cache as it will remove all the data in local storage, not just the game data.
    Overwriting the data is problematic if multiple people want to play the game in
    the same browser. Having only a single save file becomes meaningless. We do have
    a third option available which is that we don''t clear the data at all, but rather
    we create additional save files that can be loaded at any time. Our current save/load
    system is already prepared for us to have multiple user profiles, we just need
    to add an input system to capture the name of the user. We will keep the system
    fairly simple, placing it on the front end and limit the user names to a maximum
    of eight characters. When the player clicks the start button, it will load the
    proper profile before it switches rooms:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by adding one more global variable for the player's name. Open
    `scr_Global_GameStart`, initialize the `playerName` variable, and set it to an
    empty string at the end of the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We will need to create a new Object, `obj_NameInput`, which we can use for tracking
    the player's input. It does not need a sprite since we will be drawing the text
    onto the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Create** event with a new Script, `scr_NameInput_Create`, to initialize
    variables for the length of the string and how many characters have been typed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will add a **Draw** | **Draw** event with a new Script, `scr_NameInput_Draw`,
    attached to draw the player''s name as it is typed and a simple instruction telling
    the player to type in their name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have everything displayed on screen we need to gather the keyboard
    input. Add a **Key Press** | **Any Key** event and attach a new Script called
    `scr_NameInput_KeyPressed`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We only want the name to be a maximum of eight letters, so we first check to
    see if there is still space available in the current name. If we can input another
    letter, we then check if the key that is being pressed is a letter. If a letter
    has been pressed, we add that letter to the end of the string and then indicate
    that another space has been used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we ran the game now we would be able to enter letters, but we have no ability
    to undo any letters. We can fix that with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If the user presses *backspace*, we grab the length of the string to find out
    where the last space of the string is. Once we know that, we can then remove the
    letter at the end of the string. Finally we check to see if there are still letters
    remaining and if so, reduce the space count by one. This is needed so that we
    can't go into negative spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Open `MainMenu` and place a single instance of `obj_NameInput` somewhere in
    the room, location does not matter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and play the game. In the front end you should be able to enter a name
    of up to eight letters and by clicking backspace, delete all those letters. It
    should look like the following screenshot:![Saving multiple game profiles](img/4100_07_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The save system is now complete; all that is left to do is to load the data
    when the player clicks the **START** button. Since we use the **START** button
    in the Shop as well as the Main Menu, we will need to run a check to ensure we
    only load the game data at the beginning of the game. Open `scr_Button_Start_MousePressed`
    and before the room is changed, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Save and play the game. Use your name and play the game, completing a few levels.
    Then refresh the page and enter a different name. When you get to the level selection,
    only the first room should be available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refresh the browser a second time and use your name once again. This time when
    you get to the level selection you should see all your unlocked levels. The save
    system works!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Excellent work! In this chapter we really rounded out the game experience by
    adding an entire front end, including a Shop and unlockable levels. We learned
    to use Grids, Maps, and List data structures to hold a variety of information.
    We rebuilt the HUD so that we could display more buttons, display only the available
    equipment, and built a basic countdown timer. We created a Score Screen to show
    the player how they fared in the level. We also created an introductory screen
    at the front of each level that utilized a simple typewriter effect that showed
    us how to manipulate strings. Finally, we added a save system that taught us about
    using local storage and allows us to have multiple player saves!
  prefs: []
  type: TYPE_NORMAL
- en: Overall we took the game from being a playable prototype to a fully fleshed
    out game with a beginning and end and plenty of risk and reward. In the next chapter
    we are going to continue to polish this game by taking a look at particle effects
    and adding them to the Pillar and Debris destruction. Let's get on with it!
  prefs: []
  type: TYPE_NORMAL
