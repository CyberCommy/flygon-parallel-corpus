- en: Test Execution Phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we understand what the test design phase is, it's time to move on to
    the next phase, that is, the test execution phase. This is a phase in the software
    testing life cycle where the build code is validated using the test cases that
    were designed and created in the test design phase.
  prefs: []
  type: TYPE_NORMAL
- en: While the development team is busy building the code for the application, the
    test team gears up the test design and test cycle preparation phases. It also
    utilizes this time to prepare test environments and test data. The team then starts
    the execution of the test cases, but only after the latest code changes have been
    deployed in the test environment or when the first testable components have been
    deployed for testing. Once the test ...
  prefs: []
  type: TYPE_NORMAL
- en: Defining test cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test cycles are designed based on the type of project the test team is working
    on. While designing test cycles, the test team performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validates the test coverage**: This ensures that the test execution phase
    includes all of the test cases that are required to validate all of the requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Estimates the efforts**: Based on the complexity of the requirements, the
    priority of the test cases, the current skill level of the assigned resources,
    the availability of the testing tools, and the scope and allotted time, the test
    team estimates the time required to complete the test execution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Defines iterations**: If several defects are found during the initial test
    execution iteration, which results in a huge impact on the features of the application,
    the test team can always add another test execution iteration. Depending on the
    number of cycles, the buffer time, the defect retest time, and scheduled meetings,
    the estimation of test execution may vary.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are various types of test cycles/iterations that the test team can design
    based on defined and implied customer needs. A few test cases should be designed
    as part of the smoke and regression test cycles as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Smoke test cycle**: This cycle enables testers to check whether the current
    deployed version is testable or not after the execution of a small set of test
    cases. For example, in the case of a banking website, some basic tests, such as
    launching the application, navigating through various tabs, clicking on the available
    links, and logging in and out of the application, can be helpful so that you can
    find out whether the application is working. If it breaks immediately after being
    launched or after clicking on the personal banking link, the team can report a
    defect. Then, the developers can start working on a fix right away. Smoke testing
    helps to ensure that the correct version of the build has been deployed in the
    requested test environment. Sometimes, during the deployment phase, the build
    can fail and developers might have to roll back the changes and redeploy the new
    build. In such cases, smoke testing is useful, as it can identify whether all
    the basic features are available to test and that no files or functionality are
    missing from the currently deployed build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression test cycle**: This cycle is used to identify any adverse effects
    of the newly added/implemented requirements on the existing, workable solutions
    of the product or application. We can also use automated tools to schedule a regression
    test and gather the results as and when needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 4](2406e2e0-83fd-45df-b410-cf0ddfff4e6e.xhtml), *Test Management
    Approach*, we looked at how we can add test cycles to a test plan. In the next
    section, we'll take a closer look at how to add and remove test cases from a test
    cycle, as well as how to start, complete, and abort test cycles in the test execution
    phase.
  prefs: []
  type: TYPE_NORMAL
- en: Adding test cases to the test cycle from the same project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already worked on the necessary test cases, they are ready to
    use and we can add them to a test cycle. Adding test cases from the current project
    is done by dragging and dropping or linking the test cases into the newly created
    test cycles. Let's look at how we can create and initialize test cycles. Once
    we have created test cycles, we can add test cases to them, update test cycles,
    and then commence with the test execution phase.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing test cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test cases are grouped to form test cycles or test iterations. Before we commence
    the execution of a cycle, it''s important to check whether we have added the complete
    set of test cases that are required to verify a feature request. You should check
    the following before initializing a test cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: The current build version that the testing will be performed against
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test environment where the testing will be performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution start and end date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test cases should be organized based on their priority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test cases should be assigned to testers who will be responsible for executing
    the test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at how we can create and execute test cycles using Jira plugins.
  prefs: []
  type: TYPE_NORMAL
- en: synapseRT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In synapseRT, once test plan has been created and is ready, as it has had the
    test cases added to it, we can create test cycles:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Add button in the Test Cycle section and enter the test cycle
    details, such as Name, Environment, and Start Date and End Date, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/4e6b0c21-8e2b-4598-b4e8-ef568bf13573.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After creating the cycle, we have the option to change its state from Draft
    to Start, Complete, or Abort. We can also view and edit its details. To modify
    its details, click on Edit next to the newly created test cycle, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After adding the test cycle, we can see all of the test cases that ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Zephyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like synapseRT, Zephyr doesn''t need a test plan or test cases to create a
    test cycle. Follow these steps to create a test cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a test cycle in Zephyr, we can be more specific about its details,
    such as the Version, Description, Name, start and end dates, and so on. These
    details help us differentiate test cycles from one another:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/6675c42e-622b-4031-b4dd-3fd3e15ad85d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the following screenshot, once we add a test cycle, it''s
    displayed under the Cycle Summary tab. This tab shows us the total number of test
    cases that have been added under this test cycle, its creator, total executions,
    start and end dates, and so on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/c93432d5-ee50-4411-be32-045803307b05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Test cases can be added and removed by clicking on the +Add Tests button from
    the test cycle. We also get the option to select the test cases by their ticket
    number or by adding them from another test cycle. As you can see in the following
    screenshot, we have added three test cases using their ticket number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/5a4a4685-76b6-4ccc-96f2-074d0ec7cf84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the case of Zephyr, we can update the test status at the test case level
    or update it at the test step level. The following screenshot shows updating the
    execution status of the test case at the test case level. By default, Zephyr has
    the UNEXECUTED, PASS, FAIL, WIP, and BLOCKED statuses for test execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/b1f89ab6-6d89-4038-b632-183ba125adcb.png)'
  prefs: []
  type: TYPE_IMG
- en: Test Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like Zephyr, Test Management tools don''t need test plans or test cases to
    create a test cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add test cycles by navigating to the Tests | Cycles section. Once we
    click on the New button to add a new cycle, we will be shown the following Details
    screen, where we can enter details about this cycle, such as Folder, Status, Version,
    Iteration, Owner, Planned start date and Planned end date, Description, and so
    on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/94b9f4ea-1519-44f3-b56b-ce1be4c2db56.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have added a new test cycle, we will have access to its unique identifier
    so that we can differentiate it from other cycles. All of the cycles can be viewed
    under the Cycles tab. In this section, we ...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test execution status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test execution status defines its current state during the execution phase.
    The following are the most commonly used test execution statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No Run / Not Executed**: A No Run or Not Executed test status is displayed
    when the test cases have been added to the test cycles. Its status then gets updated
    as per the execution results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Passed**: If all the test steps mentioned in the test satisfy the expected
    results, its status can be marked as Passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failed**: If any of the test steps fail to meet the expected results, then
    it can be marked as Failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not Applicable / Not in scope**: Sometimes, test cases don''t need to be
    executed as part of a current test cycle. In such cases, the test execution status
    can be updated to Not Applicable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocked**: If an open defect impacts the testing of one or more test cases,
    then the relevant test cases can be marked as Blocked, with the updated defect
    number linked to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If at any point during the test case's execution the test steps fail, then the
    status of the entire test case is marked as Failed. At this point, the testers
    have the option to create defects and link them to the test case, either at the
    step level or at the test case level.
  prefs: []
  type: TYPE_NORMAL
- en: Also, during every test run, testing tools create a new test run instance. Therefore,
    it is relatively easy to compare the test execution results of a test in the same
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing test cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like we can prioritize test cases, test cycles can also be ordered based
    on their priority. Sequentially arranging and reordering test cycles often saves
    the time and effort of retesting one or more test cases, or even the entire cycle,
    and helps to verify the most complete or urgent requirements during the initial
    phase of the test execution cycle.
  prefs: []
  type: TYPE_NORMAL
- en: This helps in the early identification of defects and gives the team enough
    time to fix and retest any changes. As the execution progresses, the test team
    updates all of the project stakeholders about the current execution status, which
    contains information about the total number of test cases being considered for
    this release, the number of test cases marked as passed, ...
  prefs: []
  type: TYPE_NORMAL
- en: Completing test cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before confirming the closure of test cycles, it is required that you go through
    the following checklist:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the test cases in that cycle have either been marked as passed or not
    applicable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the defects related to the test cases have been fixed and retested, and
    the relevant test cases have been passed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the artifacts that are part of text execution have been generated and
    attached to the relevant test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the artifacts, including the test reports that have been generated, satisfy
    the exit or test completion criteria as per the test plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test execution reports have been generated and shared with project stakeholders
    and approved by the relevant approvers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this checklist has been gone through and completed, the test team can officially
    announce the closure of selected test cycles/iterations or execution phases.
  prefs: []
  type: TYPE_NORMAL
- en: Adding test cases to the test cycle from a different project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's ideal to reuse test cases from previous releases or different projects.
    We can add them under the current project and use them as part of the current
    cycle. Let's look at how we can add test cases from different projects to the
    test cycle.
  prefs: []
  type: TYPE_NORMAL
- en: synapseRT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add test cases from another project to test cycles. To do that, click
    on the Add Test Case button in the Test Case and search for the desired test cases.
    As you can see in the following screenshot, we add test cases from another project
    simply by searching for its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0034a7b9-57cc-4d90-8daa-8fe825233150.png)'
  prefs: []
  type: TYPE_IMG
- en: Zephyr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add test cases in Zephyr from another project. Navigate to the test
    cycle and click on the Add Tests button; you will see the following screen. Now,
    search for any test cases from another project by their ticket numbers and add
    them to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/138d487d-f6e9-4782-ad5b-7dcf336bca71.png)'
  prefs: []
  type: TYPE_IMG
- en: Test Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While adding test cases to the current test cycle, Test Management gives you
    the option to select the necessary project. The current project is selected by
    default. We can select another project from which we want to add test cases. Upon
    selection, we can see all of the test cases that are available for us to add to
    our current test cycle. Select the desired test cases and click on the Add button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/76735228-ffeb-4803-9c8e-47080fdab687.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the creation and execution of test cycles
    using Jira plugins. Test cycles in the test execution phase can be created with
    details such as start and end dates, assigned testers, build numbers, and so on. Test
    cycles can be modified to add and remove test cases from the current project before
    starting a test cycle. Test cases can also be reused from previous releases as
    part of the current release.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the importance of defect management and
    see how Jira helps us to track and manage defects effectively.
  prefs: []
  type: TYPE_NORMAL
