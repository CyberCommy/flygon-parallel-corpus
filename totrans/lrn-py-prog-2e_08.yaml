- en: Testing, Profiling, and Dealing with Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、性能分析和处理异常
- en: '"Just as the wise accepts gold after testing it by heating, cutting and rubbing
    it, so are my words to be accepted after examining them, but not out of respect
    for me." – Buddha'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “就像智者在加热、切割和摩擦后接受黄金一样，我的话语在经过检验后才应该被接受，而不是因为尊重我。” - 佛陀
- en: I love this quote by the Buddha. Within the software world, it translates perfectly
    into the healthy habit of never trusting code just because someone smart wrote
    it or because it's been working fine for a long a time. If it has not been tested,
    code is not to be trusted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢佛陀的这句话。在软件世界中，它完美地诠释了一个健康的习惯，即永远不要因为某个聪明人编写了代码或者它长期以来一直运行良好就信任代码。如果没有经过测试，代码就不值得信任。
- en: Why are tests so important? Well, for one, they give you predictability. Or,
    at least, they help you achieve high predictability. Unfortunately, there is always
    some bug that sneaks into the code. But we definitely want our code to be as predictable
    as possible. What we don't want is to have a surprise, in other words, our code
    behaving in an unpredictable way. Would you be happy to know that the software
    that checks on the sensors of the plane that is taking you on your holidays sometimes
    goes crazy? No, probably not.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么测试如此重要？首先，它们给您可预测性。或者至少，它们帮助您实现高度可预测性。不幸的是，总会有一些错误潜入代码中。但我们绝对希望我们的代码尽可能可预测。我们不希望出现意外，换句话说，我们的代码表现出不可预测的方式。您会乐意知道负责检查飞机传感器的软件有时会出现故障吗？可能不会。
- en: Therefore, we need to test our code; we need to check that its behavior is correct,
    that it works as expected when it deals with edge cases, that it doesn't hang
    when the components it's talking to are broken or unreachable, that the performances
    are well within the acceptable range, and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要测试我们的代码；我们需要检查其行为是否正确，当处理边缘情况时是否按预期工作，当其所连接的组件出现故障或不可访问时是否不会挂起，性能是否在可接受范围内等等。
- en: This chapter is all about that—making sure that your code is prepared to face
    the scary outside world, that it's fast enough, and that it can deal with unexpected
    or exceptional conditions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章就是关于这个的 - 确保您的代码准备好面对可怕的外部世界，它足够快，并且可以处理意外或异常情况。
- en: 'In this chapter, we''re going to explore the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Testing (several aspects of it, including a brief introduction to test-driven
    development)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试（包括对测试驱动开发的简要介绍）。
- en: Exception handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Profiling and performances
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析和表现
- en: Let's start by understanding what testing is.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解测试是什么。
- en: Testing your application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的应用程序
- en: There are many different kinds of tests, so many, in fact, that companies often
    have a dedicated department, called **quality assurance** (**QA**), made up of
    individuals who spend their day testing the software the company developers produce.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同类型的测试，实际上有很多，以至于公司通常会有一个专门的部门，称为**质量保证**（**QA**），由一些人组成，他们整天都在测试公司开发人员生产的软件。
- en: 'To start making an initial classification, we can divide tests into two broad
    categories: white-box and black-box tests.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始进行初步分类，我们可以将测试分为两大类：白盒测试和黑盒测试。
- en: '**White-box tests** are those that exercise the internals of the code; they
    inspect it down to a very fine level of detail. On the other hand, **black-box
    tests** are those that consider the software under test as if within a box, the
    internals of which are ignored. Even the technology, or the language used inside
    the box, is not important for black-box tests. What they do is plug input into
    one end of the box and verify the output at the other end—that''s it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**白盒测试**是对代码内部进行测试的测试；它们详细检查代码的内部。另一方面，**黑盒测试**是将被测试的软件视为一个盒子，其中的内部被忽略。甚至盒子内部使用的技术或语言对于黑盒测试也不重要。它们所做的就是将输入插入盒子的一端，并验证另一端的输出，就是这样。'
- en: There is also an in-between category, called **gray-box** testing, which involves
    testing a system in the same way we do with the black-box approach, but having
    some knowledge about the algorithms and data structures used to write the software
    and only partial access to its source code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个中间类别，称为**灰盒**测试，它涉及以与黑盒方法相同的方式测试系统，但对编写软件所使用的算法和数据结构有一定了解，并且只能部分访问其源代码。
- en: 'There are many different kinds of tests in these categories, each of which
    serves a different purpose. To give you an idea, here are a few:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类别中有许多不同类型的测试，每种测试都有不同的目的。举个例子，以下是其中一些：
- en: '**Frontend tests**: Make sure that the client side of your application is exposing
    the information that it should, all the links, the buttons, the advertising, everything
    that needs to be shown to the client. It may also verify that it is possible to
    walk a certain path through the user interface.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端测试**：确保应用程序的客户端展示应该展示的信息，所有链接、按钮、广告，所有需要展示给客户端的内容。它还可以验证通过用户界面走特定路径是否可能。'
- en: '**Scenario tests**: Make use of stories (or scenarios) that help the tester
    work through a complex problem or test a part of the system.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**场景测试**：利用故事（或场景）来帮助测试人员解决复杂问题或测试系统的一部分。'
- en: '**Integration tests**: Verify the behavior of the various components of your
    application when they are working together sending messages through interfaces.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：验证应用程序各个组件在一起工作并通过接口发送消息时的行为。'
- en: '**Smoke tests**: Particularly useful when you deploy a new update on your application.
    They check whether the most essential, vital parts of your application are still
    working as they should and that they are not *on fire*. This term comes from when
    engineers tested circuits by making sure nothing was smoking.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒烟测试**：在应用程序部署新更新时特别有用。它们检查应用程序最基本、最重要的部分是否仍然按照预期工作，并且它们没有着火。这个术语来源于工程师通过确保没有任何东西冒烟来测试电路的情况。'
- en: '**Acceptance tests**, or **user acceptance testing** (**UAT**): What a developer
    does with a product owner (for example, in a SCRUM environment) to determine whether
    the work that was commissioned was carried out correctly.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional tests**: Verify the features or functionalities of your software.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Destructive tests**: Take down parts of your system, simulating a failure,
    to establish how well the remaining parts of the system perform. These kinds of
    tests are performed extensively by companies that need to provide an extremely
    reliable service, such as Amazon and Netflix, for example.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance tests**: Aim to verify how well the system performs under a specific
    load of data or traffic so that, for example, engineers can get a better understanding
    of the bottlenecks in the system that could bring it to its knees in a heavy-load
    situation, or those that prevent scalability.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability tests**, and the closely related **user experience** (**UX**) tests:
    Aim to check whether the user interface is simple and easy to understand and use.
    They aim to provide input to the designers so that the user experience is improved.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and penetration tests**: Aim to verify how well the system is protected
    against attacks and intrusions.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit tests**: Help the developer to write the code in a robust and consistent
    way, providing the first line of feedback and defense against coding mistakes,
    refactoring mistakes, and so on.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression tests**: Provide the developer with useful information about a
    feature being compromised in the system after an update. Some of the causes for
    a system being said to have a regression are an old bug coming back to life, an
    existing feature being compromised, or a new issue being introduced.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many books and articles have been written about testing, and I have to point
    you to those resources if you're interested in finding out more about all the
    different kinds of tests. In this chapter, we will concentrate on unit tests,
    since they are the backbone of software-crafting and form the vast majority of
    tests that are written by a developer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Testing is an *art*, an art that you don't learn from books, I'm afraid. You
    can learn all the definitions (and you should), and try to collect as much knowledge
    about testing as you can, but you will likely be able to test your software properly
    only when you have done it for long enough in the field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When you are having trouble refactoring a bit of code, because every little
    thing you touch makes a test blow up, you learn how to write less rigid and limiting
    tests, which still verify the correctness of your code but, at the same time,
    allow you the freedom and joy to play with it, to shape it as you want.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: When you are being called too often to fix unexpected bugs in your code, you
    learn how to write tests more thoroughly, how to come up with a more comprehensive
    list of edge cases, and strategies to cope with them before they turn into bugs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: When you are spending too much time reading tests and trying to refactor them
    to change a small feature in the code, you learn to write simpler, shorter, and
    better-focused tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: I could go on with this *when you... you learn...*, but I guess you get the
    picture. You need to get your hands dirty and build experience. My suggestion?
    Study the theory as much as you can, and then experiment using different approaches.
    Also, try to learn from experienced coders; it's very effective.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of a test
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we concentrate on unit tests, let's see what a test is, and what its
    purpose is.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: A **test** is a piece of code whose purpose is to verify something in our system.
    It may be that we're calling a function passing two integers, that an object has
    a property called `donald_duck`, or that when you place an order on some API,
    after a minute you can see it dissected into its basic elements, in the database.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'A test is typically composed of three sections:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparation**: This is where you set up the scene. You prepare all the data,
    the objects, and the services you need in the places you need them so that they
    are ready to be used.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：这是您设置场景的地方。您准备所有数据、对象和服务，以便它们准备好在需要它们的地方使用。'
- en: '**Execution**: This is where you execute the bit of logic that you''re checking
    against. You perform an action using the data and the interfaces you have set
    up in the preparation phase.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：这是您执行要检查的逻辑的地方。您使用准备阶段设置的数据和接口执行一个操作。'
- en: '**Verification**: This is where you verify the results and make sure they are
    according to your expectations. You check the returned value of a function, or
    that some data is in the database, some is not, some has changed, a request has
    been made, something has happened, a method has been called, and so on.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：这是您验证结果并确保它们符合您的期望的地方。您检查函数的返回值，或者数据库中是否有一些数据，有一些没有，有一些已经改变，是否已经发出请求，是否发生了某些事情，是否已经调用了某个方法，等等。'
- en: 'While tests usually follow this structure, in a test suite, you will typically
    find some other constructs that take part in the testing game:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试通常遵循这种结构，在测试套件中，您通常会发现一些其他参与测试的构造：
- en: '**Setup**: This is something quite commonly found in several different tests.
    It''s logic that can be customized to run for every test, class, module, or even
    for a whole session. In this phase usually developers set up connections to databases,
    maybe populate them with data that will be needed there for the test to make sense,
    and so on.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：这是在几种不同的测试中经常发现的东西。这是可以定制为每个测试、类、模块，甚至整个会话运行的逻辑。在这个阶段，通常开发人员建立与数据库的连接，也许用测试需要的数据填充数据库，等等。'
- en: '**Teardown**: This is the opposite of the setup; the teardown phase takes place
    when the tests have been run. Like the setup, it can be customized to run for
    every test, class or module, or session. Typically in this phase, we destroy any
    artefacts that were created for the test suite, and clean up after ourselves.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拆卸**：这与设置相反；拆卸阶段发生在测试运行后。与设置一样，它可以定制为每个测试、类或模块，或会话。通常在这个阶段，我们销毁为测试套件创建的任何工件，并在测试后进行清理。'
- en: '**Fixtures**: They are pieces of data used in the tests. By using a specific
    set of fixture, outcomes are predictable and therefore tests can perform verifications
    against them.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固定装置**：它们是测试中使用的数据片段。通过使用特定的固定装置集，结果是可预测的，因此测试可以对其进行验证。'
- en: In this chapter, we will use the `pytest` Python library. It is an incredibly
    powerful tool that makes testing much easier and provides plenty of helpers so
    that the test logic can focus more on the actual testing than the wiring around
    it. You will see, when we get to the code, that one of the characteristics of
    `pytest` is that fixtures, setup, and teardown often blend into one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python库`pytest`。这是一个非常强大的工具，使测试变得更容易，并提供了大量的辅助功能，使测试逻辑可以更多地专注于实际测试而不是围绕它的连接。当我们开始编写代码时，您会看到`pytest`的一个特点是固定装置、设置和拆卸通常融为一体。
- en: Testing guidelines
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试指南
- en: 'Like software, tests can be good or bad, with a whole range of shades in the
    middle. To write good tests, here are some guidelines:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 像软件一样，测试可以是好的或坏的，在中间有各种不同的情况。要编写好的测试，以下是一些指南：
- en: '**Keep them as simple as possible**. It''s okay to violate some good coding
    rules, such as hardcoding values or duplicating code. Tests need, first and foremost,
    to be as **readable** as possible and easy to understand. When tests are hard
    to read or understand, you can never be confident they are actually making sure
    your code is performing correctly.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尽可能保持简单**。违反一些良好的编码规则，如硬编码值或重复代码是可以的。测试首先需要尽可能**可读**和易于理解。当测试难以阅读或理解时，您永远无法确信它们实际上是否确保您的代码执行正确。'
- en: '**Tests should verify one thing and one thing only**. It''s very important
    that you keep them short and contained. It''s perfectly fine to write multiple
    tests to exercise a single object or function. Just make sure that each test has
    one and only one purpose.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试应该验证一件事情，而且只有一件事情**。非常重要的是，您要保持测试简短和集中。编写多个测试来测试单个对象或函数是完全可以的。只需确保每个测试只有一个目的。'
- en: '**Tests should not make any unnecessary assumption when verifying data**. This
    is tricky to understand at first, but it is important. Verifying that the result
    of a function call is `[1, 2, 3]` is not the same as saying the output is a list
    that contains the numbers `1`, `2`, and `3`. In the former, we''re also assuming
    the ordering; in the latter, we''re only assuming which items are in the list.
    The differences sometimes are quite subtle, but they are still very important.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试在验证数据时不应做出任何不必要的假设**。这一点起初很难理解，但很重要。验证函数调用的结果是`[1, 2, 3]`并不等同于说输出是包含数字`1`、`2`和`3`的列表。在前者中，我们还假设了顺序；在后者中，我们只假设了列表中有哪些项。这些差异有时相当微妙，但仍然非常重要。'
- en: '**Tests should exercise the what, rather than the how**. Tests should focus
    on checking *what* a function is supposed to do, rather than *how* it is doing
    it. For example, focus on the fact that it''s calculating the square root of a
    number (the *what*), instead of on the fact that it is calling `math.sqrt` to
    do it (the *how*). Unless you''re writing performance tests or you have a particular
    need to verify how a certain action is performed, try to avoid this type of testing
    and focus on the *what*. Testing the *how* leads to restrictive tests and makes
    refactoring hard. Moreover, the type of test you have to write when you concentrate
    on the *how* is more likely to degrade the quality of your testing code base when
    you amend your software frequently.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该关注的是“什么”，而不是“如何”。测试应该专注于检查函数应该做什么，而不是它是如何做的。例如，专注于它计算一个数字的平方根（“什么”），而不是它调用`math.sqrt`来做到这一点（“如何”）。除非你正在编写性能测试或者有特定需要验证某个操作是如何执行的，尽量避免这种类型的测试，专注于“什么”。测试“如何”会导致限制性测试，并使重构变得困难。此外，当您经常修改软件时，专注于“如何”时必须编写的测试类型更有可能降低测试代码库的质量。
- en: '**Tests should use the minimal set of fixtures needed to do the job**. This
    is another crucial point. Fixtures have a tendency to grow over time. They also
    tend to change every now and then. If you use big amounts of fixtures and ignore
    redundancies in your tests, refactoring will take longer. Spotting bugs will be
    harder. Try to use a set of fixtures that is big enough for the test to perform
    correctly, but not any bigger.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该使用最少量的固定装置来完成工作。这是另一个关键点。固定装置往往会随着时间的推移而增长。它们也往往会不时地发生变化。如果您使用大量的固定装置并忽略测试中的冗余，重构将需要更长的时间。发现错误将更加困难。尽量使用足够大的固定装置集来正确执行测试，但不要使用过多。
- en: '**Tests should run as fast as possible**. A good test codebase could end up
    being much longer than the code being tested itself. It varies according to the
    situation and the developer, but, whatever the length, you''ll end up having hundreds,
    if not thousands, of tests to run, which means the faster they run, the faster
    you can get back to writing code. When using TDD, for example, you run tests very
    often, so speed is essential.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该尽可能快地运行。一个良好的测试代码库最终可能比被测试的代码本身要长得多。根据情况和开发人员的不同，长度可能会有所不同，但无论长度如何，您最终会有数百甚至数千个测试需要运行，这意味着它们运行得越快，您就能越快地回到编写代码。例如，在使用TDD时，您经常运行测试，因此速度至关重要。
- en: '**Tests should use up the least possible amount of resources**. The reason
    for this is that every developer who checks out your code should be able to run
    your tests, no matter how powerful their box is. It could be a skinny virtual
    machine or a neglected Jenkins box, your tests should run without chewing up too
    many resources.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应该尽量使用最少的资源。原因是每个检出您代码的开发人员都应该能够运行您的测试，无论他们的计算机有多强大。它可能是一个瘦小的虚拟机或一个被忽视的Jenkins盒子，您的测试应该在不消耗太多资源的情况下运行。
- en: A **Jenkins** box is a machine that runs Jenkins, software that is capable of,
    among many other things, running your tests automatically. Jenkins is frequently
    used in companies where developers use practices such as continuous integration
    and extreme programming.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jenkins**盒子是运行Jenkins软件的机器，该软件能够自动运行您的测试，除此之外还有许多其他功能。Jenkins经常用于那些开发人员使用持续集成和极限编程等实践的公司。'
- en: Unit testing
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Now that you have an idea about what testing is and why we need it, let''s
    introduce the developer''s best friend: the **unit test**.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了测试是什么以及为什么我们需要它，让我们介绍开发人员最好的朋友：**单元测试**。
- en: 'Before we proceed with the examples, allow me to share some words of caution:
    I''ll try to give you the fundamentals about unit testing, but I don''t follow
    any particular school of thought or methodology to the letter. Over the years,
    I have tried many different testing approaches, eventually coming up with my own
    way of doing things, which is constantly evolving. To put it as Bruce Lee would
    have:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续示例之前，让我分享一些警告：我会尝试向您介绍有关单元测试的基础知识，但我并没有完全遵循任何特定的思想或方法。多年来，我尝试了许多不同的测试方法，最终形成了自己的做事方式，这种方式不断发展。用李小龙的话来说：
- en: '"Absorb what is useful, discard what is useless and add what is specifically
    your own."'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: “吸收有用的东西，抛弃无用的东西，添加特别属于你自己的东西。”
- en: Writing a unit test
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'Unit tests take their name after the fact that they are used to test small
    units of code. To explain how to write a unit test, let''s take a look at a simple
    snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试得名于它们用于测试代码的小单元。为了解释如何编写单元测试，让我们看一个简单的代码片段：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `get_clean_data` function is responsible for getting data from `source`,
    cleaning it, and returning it to the caller. How do we test this function?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_clean_data`函数负责从`source`获取数据，清理数据，并将其返回给调用者。我们如何测试这个函数呢？'
- en: One way of doing this is to call it and then make sure that `load_data` was
    called once with `source` as its only argument. Then we have to verify that `clean_data`
    was called once, with the return value of `load_data`. And, finally, we would
    need to make sure that the return value of `clean_data` is what is returned by
    the `get_clean_data` function as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一种做法是调用它，然后确保`load_data`只调用了一次，参数是`source`。然后我们需要验证`clean_data`被调用了一次，参数是`load_data`的返回值。最后，我们需要确保`clean_data`的返回值也是`get_clean_data`函数返回的值。
- en: To do this, we need to set up the source and run this code, and this may be
    a problem. One of the golden rules of unit testing is that *anything that crosses
    the boundaries of your application needs to be simulated*. We don't want to talk
    to a real data source, and we don't want to actually run real functions if they
    are communicating with anything that is not contained in our application. A few
    examples would be a database, a search service, an external API, and a file in
    the filesystem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: We need these restrictions to act as a shield, so that we can always run our
    tests safely without the fear of destroying something in a real data source.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is that it may be quite difficult for a single developer to reproduce
    the whole architecture on their box. It may require the setting up of databases,
    APIs, services, files and folders, and so on and so forth, and this can be difficult,
    time-consuming, or sometimes not even possible.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Very simply put, an **application programming interface** (**API**) is a set
    of tools for building software applications. An API expresses a software component
    in terms of its operations, input and output, and underlying types. For example,
    if you create a software that needs to interface with a data provider service,
    it's very likely that you will have to go through their API in order to gain access
    to the data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in our unit tests, we need to simulate all those things in some way.
    Unit tests need to be run by any developer without the need for the whole system
    to be set up on their box.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: A different approach, which I always favor when it's possible to do so, is to
    simulate entities without using fake objects, but using special-purpose test objects
    instead. For example, if your code talks to a database, instead of faking all
    the functions and methods that talk to the database and programming the fake objects
    so that they return what the real ones would, I'd much rather spawn a test database,
    set up the tables and data I need, and then patch the connection settings so that
    my tests are running real code, against the test database, thereby doing no harm
    at all. In-memory databases are excellent options for these cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: One of the applications that allow you to spawn a database for testing is Django.
    Within the `django.test` package, you can find several tools that help you write
    your tests so that you won't have to simulate the dialog with a database. By writing
    tests this way, you will also be able to check on transactions, encodings, and
    all other database-related aspects of programming. Another advantage of this approach
    consists in the ability of checking against things that can change from one database
    to another.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, though, it's still not possible, and we need to use fakes, so let's
    talk about them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Mock objects and patching
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, in Python, these fake objects are called **mocks**. Up to Version
    3.3, the `mock` library was a third-party library that basically every project
    would install via `pip` but, from Version 3.3, it has been included in the standard
    library under the `unittest` module, and rightfully so, given its importance and
    how widespread it is.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: The act of replacing a real object or function (or in general, any piece of
    data structure) with a mock, is called **patching**. The `mock` library provides
    the `patch` tool, which can act as a function or class decorator, and even as
    a context manager that you can use to mock things out. Once you have replaced
    everything you don't need to run with suitable mocks, you can pass to the second
    phase of the test and run the code you are exercising. After the execution, you
    will be able to check those mocks to verify that your code has worked correctly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The verification phase is done through the use of assertions. An **assertion**
    is a function (or method) that you can use to verify equality between objects,
    as well as other conditions. When a condition is not met, the assertion will raise
    an exception that will make your test fail. You can find a list of assertions
    in the `unittest` module documentation; however, when using `pytest`, you will
    typically use the generic `assert` statement, which makes things even simpler.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 验证阶段是通过断言来完成的。**断言**是一个函数（或方法），你可以用它来验证对象之间的相等性，以及其他条件。当条件不满足时，断言将引发一个异常，使你的测试失败。你可以在`unittest`模块文档中找到一系列的断言；然而，当使用`pytest`时，你通常会使用通用的`assert`语句，这样事情会更简单。
- en: Testing a CSV generator
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试CSV生成器
- en: Let's now adopt a practical approach. I will show you how to test a piece of
    code, and we will touch on the rest of the important concepts around unit testing,
    within the context of this example.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们采取一个实际的方法。我将向你展示如何测试一段代码，我们将涉及到关于单元测试的其他重要概念，以这个例子为背景。
- en: 'We want to write an `export` function that does the following: it takes a list
    of dictionaries, each of which represents a user. It creates a CSV file, puts
    a header in it, and then proceeds to add all the users who are deemed valid according
    to some rules. The `export` function takes also a filename, which will be the
    name for the CSV in output. And, finally, it takes an indication on whether to
    allow an existing file with the same name to be overwritten.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个`export`函数，它执行以下操作：接受一个字典列表，每个字典代表一个用户。它创建一个CSV文件，在其中放入一个标题，然后继续添加所有根据某些规则被视为有效的用户。`export`函数还接受一个文件名，这将是输出的CSV的名称。最后，它接受一个指示，是否允许覆盖同名的现有文件。
- en: 'As for the users, they must abide by the following: each user has at least
    an email, a name, and an age. There can be a fourth field representing the role,
    but it''s optional. The user''s email address needs to be valid, the name needs
    to be non-empty, and the age must be an integer between 18 and 65.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 至于用户，他们必须遵守以下规定：每个用户至少有一个电子邮件、一个名称和一个年龄。可以有第四个字段代表角色，但是它是可选的。用户的电子邮件地址需要是有效的，名称需要是非空的，年龄必须是18到65之间的整数。
- en: This is our task, so now I'm going to show you the code, and then we're going
    to analyze the tests I wrote for it. But, first things first, in the following
    code snippets, I'll be using two third-party libraries: `marshmallow` and `pytest`.
    They both are in the requirements of the book's source code, so make sure you
    have installed them with `pip`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的任务，所以现在我要向你展示代码，然后我们将分析我为它编写的测试。但首先，在以下代码片段中，我将使用两个第三方库：`marshmallow`和`pytest`。它们都在本书源代码的要求中，所以确保你已经用`pip`安装了它们。
- en: '`marshmallow` is a wonderful library that provides us with the ability to serialize
    and deserialize objects and, most importantly, gives us the ability to define
    a schema that we can use to validate a user dictionary. `pytest` is one of the
    best pieces of software I have ever seen. It is used everywhere now, and has replaced
    other tools such as `nose`, for example. It provides us with great tools to write
    beautiful short tests.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`marshmallow` 是一个很棒的库，它为我们提供了序列化和反序列化对象的能力，最重要的是，它让我们能够定义一个模式，我们可以用它来验证用户字典。`pytest`
    是我见过的最好的软件之一。现在它随处可见，并且已经取代了其他工具，比如`nose`。它为我们提供了很好的工具来编写简洁的测试。'
- en: 'But let''s get to the code. I called it `api.py` just because it exposes a
    function that we can use to do things. I''ll show it to you in chunks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们来看看代码。我将它称为`api.py`，只是因为它公开了一个我们可以用来做事情的函数。我会把它分块展示给你：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This first part is where we import all the modules we need (`os` and `csv`),
    and some tools from `marshmallow`, and then we define the schema for the users.
    As you can see, we inherit from `marshmallow.Schema`, and then we set four fields.
    Notice we are using two `String` fields, `Email` and `Integer`. These will already
    provide us with some validation from `marshmallow`. Notice there is no `required=True` in
    the `role` field.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一部分是我们导入所需的所有模块（`os`和`csv`），以及从`marshmallow`中导入一些工具，然后我们为用户定义模式。正如你所看到的，我们继承自`marshmallow.Schema`，然后设置了四个字段。请注意，我们使用了两个`String`字段，`Email`和`Integer`。这些将已经为我们提供了一些来自`marshmallow`的验证。请注意，在`role`字段中没有`required=True`。
- en: We need to add a couple of custom bits of code, though. We need to add `validate_age`
    to make sure the value is within the range we want. We raise `ValidationError`
    in case it's not. And `marshmallow` will kindly take care of raising an error
    should we pass anything but an integer.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们需要添加一些自定义的代码。我们需要添加`validate_age`来确保值在我们想要的范围内。如果不是，我们会引发`ValidationError`。而且`marshmallow`会很好地处理除了整数之外的任何值。
- en: Next, we add `validate_name`, because the fact that a `name` key in the dictionary
    is there doesn't guarantee that the name is actually non-empty. So we take its
    value, we strip all leading and trailing whitespace characters, and if the result
    is empty, we raise `ValidationError` again. Notice we don't need to add a custom
    validator for the `email` field. This is because `marshmallow` will validate it,
    and a valid email cannot be empty.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`validate_name`，因为字典中存在`name`键并不保证名称实际上是非空的。所以我们取它的值，去除所有前导和尾随的空白字符，如果结果为空，我们再次引发`ValidationError`。请注意，我们不需要为`email`字段添加自定义验证器。这是因为`marshmallow`会验证它，而有效的电子邮件不能为空。
- en: 'We then instantiate `schema`, so that we can use it to validate data. So let''s
    write the `export` function:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实例化`schema`，这样我们就可以用它来验证数据。所以让我们编写`export`函数：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you see, its internals are quite straightforward. If `overwrite` is `False`
    and the file already exists, we raise `IOError` with a message saying the file
    already exists. Otherwise, if we can proceed, we simply get the list of valid
    users and feed it to `write_csv`, which is responsible for actually doing the
    job. Let''s see how all these functions are defined:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它的内部非常简单。如果“overwrite”为“False”并且文件已经存在，我们会引发一个带有文件已经存在的消息的“IOError”。否则，如果我们可以继续，我们只需获取有效用户列表并将其提供给“write_csv”，后者负责实际完成工作。让我们看看这些函数是如何定义的：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Turns out I coded `get_valid_users` as a generator, as there is no need to make
    a potentially big list in order to put it in a file. We can validate and save
    them one by one. The heart of validation is simply a delegation to `schema.validate`,
    which uses validation engine by `marshmallow`. The way this works is by returning
    a dictionary, which is empty if validation succeeded, or else it will contain
    error information. We don't really care about collecting the error information
    for this task, so we simply ignore it, and within `is_valid` we basically return
    `True` if the return value from `schema.validate` is empty, and `False` otherwise.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我将“get_valid_users”编码为生成器，因为没有必要为了将其放入文件而制作一个潜在的大列表。我们可以逐个验证和保存它们。验证的核心是简单地委托给“schema.validate”，它使用“marshmallow”的验证引擎。这样的工作方式是返回一个字典，如果验证成功则为空，否则将包含错误信息。对于这个任务，我们并不真正关心收集错误信息，所以我们简单地忽略它，在“is_valid”中，如果“schema.validate”的返回值为空，我们基本上返回“True”，否则返回“False”。
- en: 'One last piece is missing; here it is:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还缺少最后一部分；在这里：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, the logic is straightforward. We define the header in `fieldnames`, then
    we open `filename` for writing, and we specify `newline=''`, which is recommended
    in the documentation when dealing with CSV files. When the file has been created,
    we get a `writer` object by using the `csv.DictWriter` class. The beauty of this
    tool is that it is capable of mapping the user dictionaries to the field names,
    so we don't need to take care of the ordering.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，逻辑很简单。我们在“fieldnames”中定义标题，然后打开“filename”进行写入，并指定“newline=''”，这在处理CSV文件时在文档中是推荐的。文件创建后，我们通过使用“csv.DictWriter”类来获取一个“writer”对象。这个工具的美妙之处在于它能够将用户字典映射到字段名，因此我们不需要关心排序。
- en: We write the header first, and then we loop over the users and add them one
    by one. Notice, this function assumes it is fed a list of valid users, and it
    may break if that assumption is false (with the default values, it would break
    if any user dictionary had extra fields).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先写入标题，然后循环遍历用户并逐个添加它们。请注意，此函数假定它被提供一个有效用户列表，如果这个假设是错误的（使用默认值，如果任何用户字典有额外字段，它将会出错）。
- en: That's the whole code you have to keep in mind. I suggest you spend a moment
    to go through it again. There is no need to memorize it, and the fact that I have
    used small helper functions with meaningful names will enable you to follow the
    testing along more easily.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要记住的全部代码。我建议你花一点时间再次阅读它。没有必要记住它，而且我使用有意义的名称编写了小的辅助函数，这将使你更容易跟随测试。
- en: 'Let''s now get to the interesting part: testing our `export` function. Once
    again, I''ll show you the code in chunks:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来到有趣的部分：测试我们的“export”函数。再次，我将把代码分成几部分给你看：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s start from the imports: we need `os`, temporary directories (which we
    already saw in [Chapter 7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files
    and Data Persistence*), then `pytest`, and, finally, we use a relative import
    to fetch the three functions that we want to actually test: `is_valid`, `export`,
    and `write_csv`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入开始：我们需要“os”、临时目录（我们在[第7章](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe)中已经看到了，“文件和数据持久性”），然后是“pytest”，最后，我们使用相对导入来获取我们想要实际测试的三个函数：“is_valid”、“export”和“write_csv”。
- en: 'Before we can write tests, though, we need to make a few fixtures. As you will
    see, a `fixture` is a function that is decorated with the `pytest.fixture` decorator.
    In most cases, we expect `fixture` to return something, so that we can use it
    in a test. We have some requirements for a user dictionary, so let''s write a
    couple of users: one with minimal requirements, and one with full requirements.
    Both need to be valid. Here is the code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们可以编写测试之前，我们需要制作一些固定装置。正如你将看到的，一个“fixture”是一个被“pytest.fixture”装饰的函数。在大多数情况下，我们期望“fixture”返回一些东西，这样我们就可以在测试中使用它。我们对用户字典有一些要求，所以让我们写一些用户：一个具有最低要求的用户，一个具有完整要求的用户。两者都需要有效。以下是代码：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the only difference is the presence of the `role` key, but
    it's enough to show you the point I hope. Notice that instead of simply declaring
    dictionaries at a module level, we actually have written two functions that return
    a dictionary, and we have decorated them with the `pytest.fixture` decorator.
    This is because when you declare a dictionary at module-level, which is supposed
    to be used in your tests, you need to make sure you copy it at the beginning of
    every test. If you don't, you may have a test that modifies it, and this will
    affect all tests that follow it, compromising their integrity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，唯一的区别是存在“role”键，但这足以向你展示我希望的观点。请注意，我们实际上编写了两个返回字典的函数，并且用“pytest.fixture”装饰了它们，而不是简单地在模块级别声明字典。这是因为当你在模块级别声明一个字典，它应该在你的测试中使用，你需要确保在每个测试的开始时复制它。如果不这样做，你可能会有一个修改它的测试，这将影响所有随后的测试，从而损害它们的完整性。
- en: 'By using these fixtures, `pytest` will give us a new dictionary every test
    run, so we don''t need to go through that pain ourselves. Notice that if a fixture
    returns another type, instead of dict, then that is what you will get in the test.
    Fixtures also are *composable*, which means they can be used in one another, which
    is a very powerful feature of `pytest`. To show you this, let''s write a fixture
    for a list of users, in which we put the two we already have, plus one that would
    fail validation because it has no age. Let''s take a look at the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nice. So, now we have two users that we can use individually, but also we have
    a list of three users. The first round of tests will be testing how we are validating
    a user. We will group all the tests for this task within a class. This not only
    helps giving related tests a namespace, a place to be, but, as we''ll see later
    on, it allows us to declare class-level fixtures, which are defined just for the
    tests belonging to the class. Take a look at this code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We start very simply by making sure our fixtures are actually passing validation.
    This is very important, as those fixtures will be used everywhere, so we want
    them to be perfect. Next, we test the age. Two things to notice here: I will not
    repeat the class signature, so the code that follows is indented by four spaces
    and it''s because these are all methods within the same class, okay? And, second,
    we''re going to use parametrization quite heavily.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Parametrization is a technique that enables us to run the same test multiple
    times, but feeding different data to it. It is very useful, as it allows us to
    write the test only once with no repetition, and the result will be very intelligently
    handled by `pytest`, which will run all those tests as if they were actually separate,
    thus providing us with clear error messages when they fail. If you parametrize
    manually, you lose this feature, and believe me you won''t be happy. Let''s see
    how we test the age:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Right, so we start by writing a test to check that validation fails when the
    user is too young. According to our rule, a user is too young when they are younger
    than 18\. We check for every age between 0 and 17, by using `range`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: If you take a look at how the parametrization works, you'll see we declare the
    name of an object, which we then pass to the signature of the method, and then
    we specify which values this object will take. For each value, the test will be
    run once. In the case of this first test, the object's name is `age`, and the
    values are all those returned by `range(18)`, which means all integer numbers
    from `0` to `17` are included. Notice how we feed `age` to the test method, right
    after `self`, and then we do something else, which is also very interesting. We
    pass this method a fixture: `min_user`. This has the effect of activating that
    fixture for the test run, so that we can use it, and can refer to it from within
    the test. In this case, we simply change the age within the `min_user` dictionary,
    and then we verify that the result of `is_valid(min_user)` is `False`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: We do this last bit by asserting on the fact that `not False` is `True`. In `pytest`, this
    is how you check for something. You simply assert that something is truthy. If
    that is the case, the test has succeeded. Should it instead be the opposite, the
    test would fail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed and add all the tests needed to make validation fail on the
    age:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, another two tests. One takes care of the other end of the spectrum, from
    66 years of age to 99\. And the second one instead makes sure that age is invalid
    when it's not an integer number, so we pass some values, such as a string, a float,
    and `None`, just to make sure. Notice how the structure of the test is basically
    always the same, but, thanks to the parametrization, we feed very different input
    arguments to it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the age-failing all sorted out, let''s add a test that actually
    checks the age is within the valid range:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's as easy as that. We pass the correct range, from `18` to `65`, and remove
    the `not` in the assertion. Notice how all tests start with the `test_` prefix,
    and have a different name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We can consider the age as being taken care of. Let''s move on to write tests
    on mandatory fields:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous three tests still belong to the same class. The first one tests
    whether a user is invalid when one of the mandatory fields is missing. Notice
    that at every test run, the `min_user` fixture is restored, so we only have one
    missing field per test run, which is the appropriate way to check for mandatory
    fields. We simply pop the key out of the dictionary. This time the parametrization
    object takes the name `field`, and, by looking at the first test, you see all
    the mandatory fields in the parametrization decorator: `email`, `name`, and `age`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In the second one, things are a little different. Instead of popping keys out,
    we simply set them (one at a time) to the empty string. Finally, in the third
    one, we check for the name to be made of whitespace only.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous tests take care of mandatory fields being there and being non-empty,
    and of the formatting around the `name` key of a user. Good. Let''s now write
    the last two tests for this class. We want to check email validity, and type for
    email, name, and the role:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time, the parametrization is slightly more complex. We define two objects
    (`email` and `outcome`), and then we pass a list of tuples, instead of a simple
    list, to the decorator. What happens is that each time the test is run, one of
    those tuples will be unpacked so to fill the values of `email` and `outcome`,
    respectively. This allows us to write one test for both valid and invalid email
    addresses, instead of two separate ones. We define an email address, and we specify
    the outcome we expect from validation. The first four are invalid email addresses,
    but the last three are actually valid. I have used a couple of examples with Unicode,
    just to make sure we're not forgetting to include our friends from all over the
    world in the validation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the validation is done, asserting the result of the call needs to
    match the outcome we have set.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now write a simple test to make sure validation fails when we feed the
    wrong type to the fields (again, the age has been taken care of separately before):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we did before, just for fun, we pass three different values, none of which
    is actually a string. This test could be expanded to include more values, but,
    honestly, we shouldn't need to write tests such as this one. I have included it
    here just to show you what's possible.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Before we move to the next test class, let me talk about something we have seen
    when we were checking the age.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Boundaries and granularity
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While checking for the age, we have written three tests to cover the three
    ranges: 0-17 (fail), 18-65 (success), 66-99 (fail). Why did we do this? The answer
    lies in the fact that we are dealing with two boundaries: 18 and 65\. So our testing
    needs to focus on the three regions those two boundaries define: before `18`,
    within `18` and `65`, and after `65`. How you do it is not crucial, as long as
    you make sure you test the boundaries correctly. This means if someone changes
    the validation in the schema from `18 <= value <= 65` to `18 <= value < 65` (notice
    the missing `=`), there must be a test that fails on the `65`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: This concept is known as **boundary**, and it's very important that you recognize
    them in your code so that you can test against them.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing is to understand is which zoom level we want to get
    close to the boundaries. In other words, which unit should I use to move around
    it? In the case of age, we're dealing with integers, so a unit of `1` will be
    the perfect choice (which is why we used `16`, `17`, `18`, `19`, `20`, ...). But
    what if you were testing for a timestamp? Well, in that case, the correct granularity
    will likely be different. If the code has to act differently according to your
    timestamp and that timestamp represent seconds, then the granularity of your tests
    should zoom down to seconds. If the timestamp represents years, then years should
    be the unit you use. I hope you get the picture. This concept is known as **granularity**,
    and needs to be combined with that of boundaries, so that by going around the
    boundaries with the correct granularity, you can make sure your tests are not
    leaving anything to chance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Let's now continue with our example, and test the `export` function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Testing the export function
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same test module, I have defined another class that represents a test
    suite for the `export` function. Here it is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's start understanding the fixtures. We have defined them at class-level
    this time, which means they will be alive only for as long as the tests in the
    class are running. We don't need these fixtures outside of this class, so it doesn't
    make sense to declare them at a module level like we've done with the user ones.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: So, we need two files. If you recall what I wrote at the beginning of this chapter,
    when it comes to interaction with databases, disks, networks, and so on, we should
    mock everything out. However, when possible, I prefer to use a different technique.
    In this case, I will employ temporary folders, which will be born within the fixture,
    and die within it, leaving no trace of their existence. I am much happier if I
    can avoid mocking. Mocking is amazing, but it can be tricky, and a source of bugs,
    unless it's done correctly.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Now, the first fixture, `csv_file`, defines a managed context in which we obtain
    a reference to a temporary folder. We can consider the logic up to and including
    the `yield`, as the setup phase. The fixture itself, in terms of data, is represented
    by the temporary filename. The file itself is not present yet. When a test runs,
    the fixture is created, and at the end of the test, the rest of the fixture code
    (the one after `yield`, if any) is executed. That part can be considered the teardown
    phase. In this case, it consists of exiting the context manager, which means the
    temporary folder is deleted (along with all its content). You can put much more
    in each phase of any fixture, and with experience, I'm sure you'll master the
    art of doing setup and teardown this way. It actually comes very naturally quite
    quickly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The second fixture is very similar to the first one, but we'll use it to test
    that we can prevent overwriting when we call `export` with `overwrite=False`.
    So we create a file in the temporary folder, and we put some content into it,
    just to have the means to verify it hasn't been touched.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how both fixtures are returning the filename with the full path information,
    to make sure we actually use the temporary folder in our code. Let''s now see
    the tests:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This test employs the `users` and `csv_file` fixtures, and immediately calls `export`
    with them. We expect that a file has been created, and populated with the two
    valid users we have (remember the list contains three users, but one is invalid).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: To verify that, we open the temporary file, and collect all its lines into a
    list. We then compare the content of the file with a list of the lines that we
    expect to be in it. Notice we only put the header, and the two valid users, in
    the correct order.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need another test, to make sure that if there is a comma in one of the
    values, our CSV is still generated correctly. Being a **comma-separated values**
    (**CSV**) file, we need to make sure that a comma in the data doesn''t break things
    up:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time, we don't need the whole users list, we just need one as we're testing
    a specific thing, and we have the previous test to make sure we're generating
    the file correctly with all the users. Remember, always try to minimize the work
    you do within a test.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: So, we use `min_user`, and put a nice comma in its name. We then repeat the
    procedure, which is very similar to that of the previous test, and finally we
    make sure that the name is put in the CSV file surrounded by double quotes. This
    is enough for any good CSV parser to understand that they don't have to break
    on the comma inside the double quotes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I want one more test, which needs to check that whether the file exists
    and we don''t want to override it, our code won''t touch it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a beautiful test, because it allows me to show you how you can tell `pytest`
    that you expect a function call to raise an exception. We do it in the context
    manager given to us by `pytest.raises`, to which we feed the exception we expect
    from the call we make inside the body of that context manager. If the exception
    is not raised, the test will fail.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: I like to be thorough in my test, so I don't want to stop there. I also assert
    on the message, by using the convenient `err.match` helper (watch out, it takes
    a regular expression, not a simple string–we'll see regular expressions in [Chapter
    14](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe), *Web Development*).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's make sure that the file still contains its original content (which
    is why I created the `existing_file` fixture) by opening it, and comparing all
    of its content to the string it should be.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Final considerations
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on to the next topic, let me just wrap up with some considerations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: First, I hope you have noticed that I haven't tested all the functions I wrote.
    Specifically, I didn't test `get_valid_users`, `validate`, and `write_csv`. The
    reason is because these functions are implicitly tested by our test suite. We
    have tested `is_valid` and `export`, which is more than enough to make sure our
    schema is validating users correctly, and the `export` function is dealing with
    filtering out invalid users correctly, respecting existing files when needed,
    and writing a proper CSV. The functions we haven't tested are the internals, they
    provide logic that participates to doing something that we have thoroughly tested
    anyway. Would adding extra tests for those functions be good or bad? Think about
    it for a moment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The answer is actually difficult. The more you test, the less you can refactor
    that code. As it is now, I could easily decide to call `is_valid` with another
    name, and I wouldn't have to change any of my tests. If you think about it, it
    makes sense, because as long as `is_valid` provides correct validation to the `get_valid_users`
    function, I don't really need to know about it. Does this make sense to you?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If instead I had tests for the `validate` function, then I would have to change
    them, if I decided to call it differently (or to somehow change its signature).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the right thing to do? Tests or no tests? It will be up to you.
    You have to find the right balance. My personal take on this matter is that everything
    needs to be thoroughly tested, either directly or indirectly. And I want the smallest
    possible test suite that guarantees me that. This way, I will have a great test
    suite in terms of coverage, but not any bigger than necessary. You need to maintain
    those tests!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: I hope this example made sense to you, I think it has allowed me to touch on
    the important topics.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: If you check out the source code for the book, in the `test_api.py` module,
    I have added a couple of extra test classes, which will show you how different
    testing would have been had I decided to go all the way with the mocks. Make sure
    you read that code and understand it well. It is quite straightforward and will
    offer you a good comparison with my personal approach, which I have shown you
    here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how about we run those tests? (The output is re-arranged to fit this book''s
    format):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Make sure you run `$ pytest test` from within the `ch8` folder (add the `-vv`
    flag for a verbose output that will show you how parametrization modifies the
    names of your tests). As you can see, `132` tests were run in less than half a
    second, and they all succeeded. I strongly suggest you check out this code and
    play with it. Change something in the code and see whether any test is breaking.
    Understand why it is breaking. Is it something important that means the test isn't
    good enough? Or is it something silly that shouldn't cause the test to break?
    All these apparently innocuous questions will help you gain deep insight into
    the art of testing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: I also suggest you study the `unittest` module, and `pytest` too. These are
    tools you will use all the time, so you need to be very familiar with them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Let's now check out test-driven development!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk briefly about **test-driven development** (**TDD**). It is a methodology
    that was rediscovered by Kent Beck, who wrote *Test-Driven Development by Example*,
    *Addison Wesley, 2002*, which I encourage you to check out if you want to learn
    about the fundamentals of this subject.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: TDD is a software development methodology that is based on the continuous repetition
    of a very short development cycle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: First, the developer writes a test, and makes it run. The test is supposed to
    check a feature that is not yet part of the code. Maybe it is a new feature to
    be added, or something to be removed or amended. Running the test will make it
    fail and, because of this, this phase is called **Red**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: When the test has failed, the developer writes the minimal amount of code to
    make it pass. When running the test succeeds, we have the so-called **Green**
    phase. In this phase, it is okay to write code that cheats, just to make the test
    pass. This technique is called *fake it 'till you make it*. In a second moment,
    tests are enriched with different edge cases, and the cheating code then has to
    be rewritten with proper logic. Adding other test cases is called **triangulation**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The last piece of the cycle is where the developer takes care of both the code
    and the tests (in separate times) and refactors them until they are in the desired
    state. This last phase is called **Refactor**.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The **TDD** mantra therefore is **Red-Green-Refactor**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: At first, it feels really weird to write tests before the code, and I must confess
    it took me a while to get used to it. If you stick to it, though, and force yourself
    to learn this slightly counter-intuitive way of working, at some point something
    almost magical happens, and you will see the quality of your code increase in
    a way that wouldn't be possible otherwise.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: When you write your code before the tests, you have to take care of *what* the
    code has to do and *how* it has to do it, both at the same time. On the other
    hand, when you write tests before the code, you can concentrate on the *what*
    part alone, while you write them. When you write the code afterward, you will
    mostly have to take care of *how* the code has to implement *what* is required
    by the tests. This shift in focus allows your mind to concentrate on the *what*
    and *how* parts in separate moments, yielding a brain power boost that will surprise
    you.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other benefits that come from the adoption of this technique:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**You will refactor with much more confidence**: Tests will break if you introduce
    bugs. Moreover, the architectural refactor will also benefit from having tests
    that act as guardians.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code will be more readable**: This is crucial in our time, when coding
    is a social activity and every professional developer spends much more time reading
    code than writing it.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The code will be more loosely coupled and easier to test and maintain**: Writing
    the tests first forces you to think more deeply about code structure.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Writing tests first requires you to have a better understanding of the business
    requirements**: If your understanding of the requirements is lacking information,
    you''ll find writing a test extremely challenging and this situation acts as a
    sentinel for you.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Having everything unit tested means the code will be easier to debug**: Moreover,
    small tests are perfect for providing alternative documentation. English can be
    misleading, but five lines of Python in a simple test are very hard to misunderstand.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher speed**: It''s faster to write tests and code than it is to write
    the code first and then lose time debugging it. If you don''t write tests, you
    will probably deliver the code sooner, but then you will have to track the bugs
    down and solve them (and, rest assured, there will be bugs). The combined time
    taken to write the code and then debug it is usually longer than the time taken
    to develop the code with TDD, where having tests running before the code is written,
    ensuring that the amount of bugs in it will be much lower than in the other case.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, the main shortcomings of this technique are the following
    ones:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**The whole company needs to believe in it**: Otherwise, you will have to constantly
    argue with your boss, who will not understand why it takes you so long to deliver.
    The truth is, it may take you a bit longer to deliver in the short-term, but in
    the long-term, you gain a lot with TDD. However, it is quite hard to see the long-term
    because it''s not under our noses like the short-term is. I have fought battles
    with stubborn bosses in my career, to be able to code using TDD. Sometimes it
    has been painful, but always well worth it, and I have never regretted it because,
    in the end, the quality of the result has always been appreciated.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If you fail to understand the business requirements, this will reflect in
    the tests you write, and therefore it will reflect in the code too**: This kind
    of problem is quite hard to spot until you do UAT, but one thing that you can
    do to reduce the likelihood of it happening is to pair with another developer.
    Pairing will inevitably require discussions about the business requirements, and
    discussion will bring clarification, which will help writing correct tests.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Badly written tests are hard to maintain:** This is a fact. Tests with too
    many mocks or with extra assumptions or badly-structured data will soon become
    a burden. Don''t let this discourage you; just keep experimenting and change the
    way you write them until you find a way that doesn''t require you a huge amount
    of work every time you touch your code.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I'm quite passionate about TDD. When I interview for a job, I always ask whether
    the company adopts it. I encourage you to check it out and use it. Use it until
    you feel something clicking in your mind. You won't regret it, I promise.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though I haven't formally introduced them to you, by now I expect you to
    at least have a vague idea of what an exception is. In the previous chapters,
    we've seen that when an iterator is exhausted, calling `next` on it raises a `StopIteration`
    exception. We met `IndexError` when we tried accessing a list at a position that
    was outside the valid range. We also met `AttributeError` when we tried accessing
    an attribute on an object that didn't have it, and `KeyError` when we did the
    same with a key and a dictionary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Now the time has come for us to talk about exceptions.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, even though an operation or a piece of code is correct, there are
    conditions in which something may go wrong. For example, if we're converting user
    input from `string` to `int`, the user could accidentally type a letter in place
    of a digit, making it impossible for us to convert that value into a number. When
    dividing numbers, we may not know in advance whether we're attempting a division
    by zero. When opening a file, it could be missing or corrupted.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'When an error is detected during execution, it is called an **exception**.
    Exceptions are not necessarily lethal; in fact, we''ve seen that `StopIteration`
    is deeply integrated in the Python generator and iterator mechanisms. Normally,
    though, if you don''t take the necessary precautions, an exception will cause
    your application to break. Sometimes, this is the desired behavior, but in other
    cases, we want to prevent and control problems such as these. For example, we
    may alert the user that the file they''re trying to open is corrupted or that
    it is missing so that they can either fix it or provide another file, without
    the need for the application to die because of this issue. Let''s see an example
    of a few exceptions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, the Python shell is quite forgiving. We can see `Traceback`,
    so that we have information about the error, but the program doesn't die. This
    is a special behavior, a regular program or a script would normally die if nothing
    were done to handle exceptions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: To handle an exception, Python gives you the `try` statement. When you enter
    the `try` clause, Python will watch out for one or more different types of exceptions
    (according to how you instruct it), and if they are raised, it will allow you
    to react. The `try` statement is composed of the `try` clause, which opens the
    statement, one or more `except` clauses (all optional) that define what to do
    when an exception is caught, an `else` clause (optional), which is executed when
    the `try` clause is exited without any exception raised, and a `finally` clause
    (optional), whose code is executed regardless of whatever happened in the other
    clauses. The `finally` clause is typically used to clean up resources (we saw
    this in [Chapter 7](part0187.html#5IAP60-2ddb708647cc4530a187c2c6c0e9acfe), *Files
    and Data Persistence*, when we were opening files without using a context manager).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Mind the order—it''s important. Also, `try` must be followed by at least one
    `except` clause or a `finally` clause. Let''s see an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding example defines a simple `try_syntax` function. We perform the
    division of two numbers. We are prepared to catch a `ZeroDivisionError` exception
    if we call the function with `denominator = 0`. Initially, the code enters the
    `try` block. If `denominator` is not `0`, `result` is calculated and the execution,
    after leaving the `try` block, resumes in the `else` block. We print `result`
    and return it. Take a look at the output and you'll notice that just before returning
    `result`, which is the exit point of the function, Python executes the `finally`
    clause.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'When `denominator` is `0`, things change. We enter the `except` block and print
    `zde`. The `else` block isn''t executed because an exception was raised in the
    `try` block. Before (implicitly) returning `None`, we still execute the `finally`
    block. Take a look at the output and see whether it makes sense to you:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you execute a `try` block, you may want to catch more than one exception.
    For example, when trying to decode a JSON object, you may incur into `ValueError`
    for malformed JSON, or `TypeError` if the type of the data you''re feeding to
    `json.loads()` is not a string. In this case, you may structure your code like
    this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code will catch both `ValueError` and `TypeError`. Try changing `json_data
    = '{}'` to `json_data = 2` or `json_data = '{{'`, and you'll see the different
    output.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to handle multiple exceptions differently, you can just add more
    `except` clauses, like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Keep in mind that an exception is handled in the first block that defines that
    exception class or any of its bases. Therefore, when you stack multiple `except`
    clauses like we've just done, make sure that you put specific exceptions at the
    top and generic ones at the bottom. In OOP terms, children on top, grandparents
    at the bottom. Moreover, remember that only one `except` handler is executed when
    an exception is raised.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: You can also write **custom exceptions**. To do that, you just have to inherit
    from any other exception class. Python's built-in exceptions are too many to be
    listed here, so I have to point you to the official documentation. One important
    thing to know is that every Python exception derives from `BaseException`, but
    your custom exceptions should never inherit directly from it. The reason is because
    handling such an exception will also trap **system-exiting exceptions**, such
    as `SystemExit` and `KeyboardInterrupt`, which derive from `BaseException`, and
    this could lead to severe issues. In the case of disaster, you want to be able
    to *Ctrl* + *C* your way out of an application.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: You can easily solve the problem by inheriting from `Exception`, which inherits
    from `BaseException` but doesn't include any system-exiting exception in its children
    because they are siblings in the built-in exceptions hierarchy (see [https://docs.python.org/3/library/exceptions.html#exception-hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming with exceptions can be very tricky. You could inadvertently silence
    out errors, or trap exceptions that aren''t meant to be handled. Play it safe
    by keeping in mind a few guidelines: always put in the `try` clause only the code
    that may cause the exception(s) that you want to handle. When you write `except`
    clauses, be as specific as you can, don''t just resort to `except Exception` because
    it''s easy. Use tests to make sure your code handles edge cases in a way that
    requires the least possible amount of exception handling. Writing an `except`
    statement without specifying any exception would catch any exception, therefore
    exposing your code to the same risks you incur when you derive your custom exceptions
    from `BaseException`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: You will find information about exceptions almost everywhere on the web. Some
    coders use them abundantly, others sparingly. Find your own way of dealing with
    them by taking examples from other people's source code. There are plenty of interesting
    open source projects on websites such as GitHub ([https://github.com](https://github.com))
    and Bitbucket ([https://bitbucket.org/](https://bitbucket.org/)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we talk about profiling, let me show you an unconventional use of exceptions,
    just to give you something to help you expand your views on them. They are not
    just simply errors:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding code is quite a common idiom if you deal with numbers. You have
    to iterate over a few nested ranges and look for a particular combination of `a`,
    `b`, and `c` that satisfies a condition. In the example, condition is a trivial
    linear equation, but imagine something much cooler than that. What bugs me is
    having to check whether the solution has been found at the beginning of each loop,
    in order to break out of them as fast as we can when it is. The breakout logic
    interferes with the rest of the code and I don''t like it, so I came up with a
    different solution for this. Take a look at it, and see whether you can adapt
    it to other cases too:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Can you see how much more elegant it is? Now the breakout logic is entirely
    handled with a simple exception whose name even hints at its purpose. As soon
    as the result is found, we raise it, and immediately the control is given to the
    `except` clause that handles it. This is food for thought. This example indirectly
    shows you how to raise your own exceptions. Read up on the official documentation
    to dive into the beautiful details of this subject.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, if you are up for a challenge, you might want to try to make this
    last example into a context manager for nested `for` loops. Good luck!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Profiling Python
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different ways to profile a Python application. Profiling means
    having the application run while keeping track of several different parameters,
    such as the number of times a function is called and the amount of time spent
    inside it. Profiling can help us find the bottlenecks in our application, so that
    we can improve only what is really slowing us down.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the profiling section in the standard library official
    documentation, you will see that there are a couple of different implementations
    of the same profiling interface—`profile` and `cProfile`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '`cProfile` is recommended for most users, it''s a C extension with reasonable
    overhead that makes it suitable for profiling long-running programs'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`profile` is a pure Python module whose interface is imitated by `cProfile`,
    but which adds significant overhead to profiled programs'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This interface does **determinist profiling**, which means that all function
    calls, function returns, and exception events are monitored, and precise timings
    are made for the intervals between these events. Another approach, called **statistical
    profiling**, randomly samples the effective instruction pointer, and deduces where
    time is being spent.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The latter usually involves less overhead, but provides only approximate results.
    Moreover, because of the way the Python interpreter runs the code, deterministic
    profiling doesn't add as much overhead as one would think, so I'll show you a
    simple example using `cProfile` from the command line.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to calculate Pythagorean triples (I know, you''ve missed them...)
    using the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The script is extremely simple; we iterate over the interval [`1`, `mx`] with
    `a` and `b` (avoiding repetition of pairs by setting `b >= a`) and we check whether
    they belong to a right triangle. We use `calc_hypotenuse` to get `hypotenuse`
    for `a` and `b`, and then, with `is_int`, we check whether it is an integer, which
    means (*a*, *b*, *c*) is a Pythagorean triple. When we profile this script, we
    get information in a tabular form. The columns are `ncalls`, `tottime`, `percall`,
    `cumtime`, `percall`, and `filename:lineno(function)`. They represent the amount
    of calls we made to a function, how much time we spent in it, and so on. I''ll
    trim a couple of columns to save space, so if you run the profiling yourself—don''t
    worry if you get a different result. Here is the code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Even with this limited amount of data, we can still infer some useful information
    about this code. First, we can see that the time complexity of the algorithm we
    have chosen grows with the square of the input size. The amount of times we get
    inside the inner loop body is exactly *mx (mx + 1) / 2*. We run the script with
    `mx = 1000`, which means we get `500500` times inside the inner `for` loop. Three
    main things happen inside that loop: we call `calc_hypotenuse`, we call `is_int`,
    and, if the condition is met, we append it to the `triples` list.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Taking a look at the profiling report, we notice that the algorithm has spent
    `0.393` seconds inside `calc_hypotenuse`, which is way more than the `0.096` seconds
    spent inside `is_int`, given that they were called the same number of times, so
    let's see whether we can boost `calc_hypotenuse` a little.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, we can. As I mentioned earlier in this book, the `**` power
    operator is quite expensive, and in `calc_hypotenuse`, we''re using it three times.
    Fortunately, we can easily transform two of those into simple multiplications,
    like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This simple change should improve things. If we run the profiling again, we
    see that `0.393` is now down to `0.137`. Not bad! This means now we're spending
    only about 37% of the time inside `calc_hypotenuse` that we were before.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see whether we can improve `is_int` as well, by changing it, like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This implementation is different, and the advantage is that it also works when
    `n` is an integer. Alas, when we run the profiling against it, we see that the
    time taken inside the `is_int` function has gone up to `0.135` seconds, so, in
    this case, we need to revert to the previous implementation. You will find the
    three versions in the source code for the book.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: This example was trivial, of course, but enough to show you how one could profile
    an application. Having the amount of calls that are performed against a function
    helps us better understand the time complexity of our algorithms. For example,
    you wouldn't believe how many coders fail to see that those two `for` loops run
    proportionally to the square of the input size.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to mention: depending on what system you''re using, results may be
    different. Therefore, it''s quite important to be able to profile software on
    a system that is as close as possible to the one the software is deployed on,
    if not actually on that one.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: When to profile?
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling is super cool, but we need to know when it is appropriate to do it,
    and in what measure we need to address the results we get from it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Donald Knuth once said, <q class="calibre30">*"premature optimization is the
    root of all evil"*,</q> and, although I wouldn't have put it down so drastically,
    I do agree with him. After all, who am I to disagree with the man who gave us
    *The Art of Computer Programming, TeX*, and some of the coolest algorithms I have
    ever studied when I was a university student?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first and foremost: *correctness*. You want your code to deliver the correct
    results, therefore write tests, find edge cases, and stress your code in every
    way you think makes sense. Don''t be protective, don''t put things in the back
    of your brain for later because you think they''re not likely to happen. Be thorough.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, take care of coding *best practices*. Remember the following—readability,
    extensibility, loose coupling, modularity, and design. Apply OOP principles: encapsulation,
    abstraction, single responsibility, open/closed, and so on. Read up on these concepts.
    They will open horizons for you, and they will expand the way you think about
    code.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, *refactor like a beast!* The Boy Scouts rule says:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '*"Always leave the campground cleaner than you found it*."'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Apply this rule to your code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: And, finally, when all of this has been taken care of, then and only then, take
    care of optimizing and profiling.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Run your profiler and identify bottlenecks. When you have an idea of the bottlenecks
    you need to address, start with the worst one first. Sometimes, fixing a bottleneck
    causes a ripple effect that will expand and change the way the rest of the code
    works. Sometimes this is only a little, sometimes a bit more, according to how
    your code was designed and implemented. Therefore, start with the biggest issue
    first.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons Python is so popular is that it is possible to implement
    it in many different ways. So, if you find yourself having trouble boosting up
    some part of your code using sheer Python, nothing prevents you from rolling up
    your sleeves, buying 200 liters of coffee, and rewriting the slow piece of code
    in C—guaranteed to be fun!
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of testing, exceptions, and profiling.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: I tried to give you a fairly comprehensive overview of testing, especially unit
    testing, which is the kind of testing that a developer mostly does. I hope I have
    succeeded in channeling the message that testing is not something that is perfectly
    defined that you can learn from a book. You need to experiment with it a lot before
    you get comfortable. Of all the efforts a coder must make in terms of study and
    experimentation, I'd say testing is the one that is the most important.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: We briefly saw how we can prevent our program from dying because of errors,
    called exceptions, that happen at runtime. And, to steer away from the usual ground,
    I have given you an example of a somewhat unconventional use of exceptions to
    break out of nested `for` loops. That's not the only case, and I'm sure you'll
    discover others as you grow as a coder.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we very briefly touched on profiling, with a simple example and
    a few guidelines. I wanted to talk about profiling for the sake of completeness,
    so at least you can play around with it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to explore the wonderful world of secrets,
    hashing, and creating tokens.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: I am aware that I gave you a lot of pointers in this chapter, with no links
    or directions. I'm afraid this was by choice. As a coder, there won't be a single
    day at work when you won't have to look something up in a documentation page,
    in a manual, on a website, and so on. I think it's vital for a coder to be able
    to search effectively for the information they need, so I hope you'll forgive
    me for this extra training. After all, it's all for your benefit.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
