- en: Inside JVM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM内部
- en: The previous chapter gave us knowledge on how to tune an application's performance
    by understanding the symptoms of the performance issues. We walked through the
    performance tuning life cycle, learning at what stages of the application performance
    can be tuned and how. We also learned how to connect JMX to the Spring application,
    observed the application's bottleneck, and tuned it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章让我们了解了如何通过理解性能问题的症状来调整应用程序的性能。我们走过了性能调整生命周期，学习了在应用程序性能的哪些阶段可以进行调整以及如何进行调整。我们还学会了如何将JMX连接到Spring应用程序，观察应用程序的瓶颈并进行调整。
- en: In this chapter, we will walk through the insides of **Java Virtual Machine** (**JVM**)
    and tuning JVM to achieve high performance. JVM performs two primary jobs—executing
    code and managing memory. JVM allocates memory from OS, manages to do heap compaction,
    and performs **garbage collection** (**GC**) of unreferenced objects. GC is important
    because proper GC improves the memory management of the application and the performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解**Java虚拟机**（**JVM**）的内部和调整JVM以实现高性能。JVM执行两项主要工作——执行代码和管理内存。JVM从操作系统分配内存，管理堆压缩，并对未引用的对象执行**垃圾回收**（**GC**）。GC很重要，因为适当的GC可以改善应用程序的内存管理和性能。
- en: 'The following are the topics we will go through in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习以下主题：
- en: Understanding JVM internals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JVM内部
- en: Understanding memory leak
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解内存泄漏
- en: Common pitfalls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: GC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC
- en: GC methods and policies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC方法和策略
- en: Tools to analyze GC logs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析GC日志的工具
- en: Understanding JVM internals
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JVM内部
- en: Being a Java developer, we know that Java bytecode runs in a **Java Runtime
    Environment** (**JRE**) and the most important part of the JRE is JVM, which analyzes
    and executes the Java bytecode. When we create a Java program and compile it,
    the result is a file with the `.class` extension. It contains Java bytecode. JVM
    converts Java bytecode into machine instructions that are executed on the hardware
    platform where we run our application. When a JVM runs a program, it needs memory
    to store bytecodes and other information it extracts from loaded class files,
    instantiated objects, method parameters, return values, local variables, and intermediate
    results of computations. The JVM organizes the memory it needs into several runtime
    data areas.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java开发人员，我们知道Java字节码在**Java运行环境**（**JRE**）中运行，而JRE最重要的部分是JVM，它分析并执行Java字节码。当我们创建一个Java程序并编译它时，结果是一个扩展名为`.class`的文件。它包含Java字节码。JVM将Java字节码转换为在我们运行应用程序的硬件平台上执行的机器指令。当JVM运行程序时，它需要内存来存储来自加载的类文件、实例化对象、方法参数、返回值、局部变量和计算的中间结果的字节码和其他信息。JVM将它需要的内存组织成几个运行时数据区域。
- en: 'JVM consist of three parts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JVM由三部分组成：
- en: Class loader subsystem
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类加载器子系统
- en: Memory areas
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域
- en: Execution engine
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行引擎
- en: 'The following diagram illustrates the high-level JVM architecture:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了高级JVM架构：
- en: '![](img/cfada67e-a629-4d24-a687-572f75805824.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfada67e-a629-4d24-a687-572f75805824.jpg)'
- en: JVM architecture
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JVM架构
- en: Let's briefly understand the three different parts of JVM we saw in the diagram.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要了解一下图表中我们看到的JVM的三个不同部分。
- en: Class loader subsystem
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类加载器子系统
- en: 'The class loader subsystem''s responsibilities are not limited to just locating
    and importing the binary data for classes. It also verifies that the imported
    classes are correct, allocates and initializes memory for class variables, and
    assists in resolving symbolic references. These activities are performed in a
    strict order:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类加载器子系统的责任不仅仅是定位和导入类的二进制数据。它还验证导入的类是否正确，为类变量分配和初始化内存，并协助解析符号引用。这些活动按严格顺序执行：
- en: '**Loading**: The class loader reads the `.class` file and finds and imports
    binary data for a type.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**加载**：类加载器读取`.class`文件并查找和导入类型的二进制数据。'
- en: '**Linking**: It performs verification, preparation, and (optionally) resolution:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链接**：它执行验证、准备和（可选）解析：'
- en: '**Verification**: Ensures the correctness of the imported type'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：确保导入类型的正确性'
- en: '**Preparation**: Allocates memory to class variables and initializes the memory
    to default values'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备**：为类变量分配内存并将内存初始化为默认值'
- en: '**Resolution**: Transforms symbolic references from the type into direct references'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析**：将类型的符号引用转换为直接引用'
- en: '**Initialization**: Assigns values to all static variables defined in the code
    and executes static block (if any). Execution occurs from top to bottom in a class,
    and from parent to child in a class hierarchy.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**：为代码中定义的所有静态变量分配值并执行静态块（如果有）。执行顺序是从类的顶部到底部，从类层次结构的父类到子类。'
- en: 'In general, there are three class loaders:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有三个类加载器：
- en: '**Bootstrap class loader**: This loads core-trusted Java API classes located
    in the `JAVA_HOME/jre/lib` directory. These Java APIs are implemented in native
    languages, such as C or C++.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引导类加载器**：这加载位于`JAVA_HOME/jre/lib`目录中的核心可信Java API类。这些Java API是用本地语言（如C或C++）实现的。'
- en: '**Extension class loader**: This inherits the Bootstrap class loader. It loads
    the classes from extension directories located at `JAVA_HOME/jre/lib/ext`, or
    any other directory specified by the `java.ext.dirs` system property. It is implemented
    in Java by the `sun.misc.Launcher$ExtClassLoader` class.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展类加载器**：这继承自引导类加载器。它从`JAVA_HOME/jre/lib/ext`目录或`java.ext.dirs`系统属性指定的任何其他目录加载类。它是由`sun.misc.Launcher$ExtClassLoader`类以Java实现的。'
- en: '**System class loader**: This inherits the extension class loader. It loads
    classes from our application classpath. It uses the `java.class.path` environment
    variable.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统类加载器**：这继承自扩展类加载器。它从我们应用程序的类路径加载类。它使用`java.class.path`环境变量。'
- en: To load classes, JVM follows the delegation hierarchy principle. The system
    class loader delegates a request to the extension class loader, and the extension
    class loader delegates the request to the Bootstrap class loader. If a class is
    found in the Bootstrap path, the class is loaded, otherwise, the request will
    be transferred to the extension class loader and then to the system class loader.
    At the end, if the system class loader fails to load the class, then a `java.lang.ClassNotFoundException`
    exception is generated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载类，JVM遵循委托层次原则。系统类加载器将请求委托给扩展类加载器，扩展类加载器将请求委托给引导类加载器。如果在引导路径中找到类，则加载该类，否则将请求转移到扩展类加载器，然后再转移到系统类加载器。最后，如果系统类加载器无法加载类，则会生成`java.lang.ClassNotFoundException`异常。
- en: 'The following diagram illustrates the delegation hierarchy principle:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了委托层次原则：
- en: '![](img/a69d9611-b82a-41b5-a33b-4395f6b52766.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a69d9611-b82a-41b5-a33b-4395f6b52766.jpg)'
- en: Delegation hierarchy principle
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 委托层次原则
- en: Memory areas
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存区域
- en: 'Java runtime memory is divided into five different areas, as shown in the following
    diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Java运行时内存分为五个不同的区域，如下图所示：
- en: '![](img/0e01a252-cd4f-468e-af57-7d81a78d933a.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e01a252-cd4f-468e-af57-7d81a78d933a.jpg)'
- en: Memory areas
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域
- en: 'Let''s look into a brief description of each component:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要描述每个组件：
- en: '**Method Area**: This contains all the class-level information, such as class
    name, parent class, methods, instance, and static variables. There is only one
    method area per JVM, and it is a shared resource.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法区**：这包含所有类级别的信息，如类名、父类、方法、实例和静态变量。每个JVM只有一个方法区，它是一个共享资源。'
- en: '**Heap Area**: This contains the information of all the objects. There is one
    **Heap Area** per JVM. It is also a shared resource. As **Method Area** and **Heap
    Area** are shared memory between multiple threads, the data stored is not thread-safe.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆区**：这包含所有对象的信息。每个JVM有一个**堆区**。它也是一个共享资源。由于**方法区**和**堆区**是多个线程之间的共享内存，所以存储的数据不是线程安全的。'
- en: '**Stack Memory**: JVM creates one runtime stack for every thread in execution
    and stores it in the stack area. Every block of this stack is called an **activation
    record** that stores methods call. All local variables of that method are stored
    in their corresponding frame. The stack area is thread-safe since it is not a
    shared resource. The runtime stack will be destroyed by the JVM up on termination
    of the thread. So, in the case of infinite loops of method calls, we might see
    `StackOverFlowError`, which is due to no memory in the stack for storing method
    calls.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栈内存**：JVM为每个正在执行的线程创建一个运行时栈，并将其存储在栈区。这个栈的每个块被称为一个**激活记录**，用于存储方法调用。该方法的所有局部变量都存储在相应的帧中。栈区是线程安全的，因为它不是共享资源。运行时栈将在线程终止时由JVM销毁。因此，在方法调用的无限循环中，我们可能会看到`StackOverFlowError`，这是由于栈中没有足够的内存来存储方法调用。'
- en: '**PC Registers**: These hold the addresses of current instructions under execution.
    Once the instruction is executed, the **PC Registers** will be updated with the
    next instruction. Each thread has a separate **PC Registers**.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PC寄存器**：这些保存正在执行的当前指令的地址。一旦指令执行完毕，**PC寄存器**将被更新为下一条指令。每个线程有一个单独的**PC寄存器**。'
- en: '**Native Method Stacks**: For every thread, a separate native stack is created.
    It stores the native method information. Native information is nothing but native
    method calls.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地方法栈**：为每个线程创建一个单独的本地栈。它存储本地方法信息。本地信息就是本地方法调用。'
- en: Execution engine
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行引擎
- en: 'The execution engine executes bytecode in runtime data areas. It executes bytecode
    by each line and uses the information available in runtime data areas. The execution
    engine can be classified into three parts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 执行引擎在运行时数据区域执行字节码。它逐行执行字节码，并使用运行时数据区域中可用的信息。执行引擎可以分为三部分：
- en: '**Interpreter**: This reads, interprets, and executes bytecode by each line.
    It interprets and executes bytecode quickly; however, it can be very slow in executing
    interpreted results.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解释器**：这逐行读取、解释和执行字节码。它快速解释和执行字节码；然而，在执行解释结果时可能非常缓慢。'
- en: '**Just-In-Time (JIT)**: In order to overcome the interpreter''s slowness in
    executing interpreted results, the JIT compiler converts the bytecode to native
    code once the interpreter interprets the code the first time. Execution happens
    fast with native code; it executes instructions one by one.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时（JIT）**：为了克服解释器在执行解释结果时的缓慢，即时编译器在解释器第一次解释代码后将字节码转换为本机代码。使用本机代码执行速度快；它逐条执行指令。'
- en: '**Garbage collector**: This destroys anything that is not referenced. This
    is very important, so anything not required will be destroyed to create room for
    new execution.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器：这会销毁任何没有被引用的东西。这非常重要，因此任何不需要的东西都将被销毁，以便为新的执行腾出空间。
- en: Understanding memory leak
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解内存泄漏
- en: Java's best benefit is the JVM, which offers memory management out of the box.
    We can create objects and Java's garbage collector takes care of freeing up memory
    for us. Still, memory leaks occur in Java applications. In the following section,
    we will see some common causes of memory leaks and walk through a few solutions
    to detect/avoid them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Java的最大好处是JVM，它提供了开箱即用的内存管理。我们可以创建对象，Java的垃圾收集器会帮我们释放内存。然而，在Java应用程序中会发生内存泄漏。在接下来的部分中，我们将看到一些内存泄漏的常见原因，并介绍一些检测/避免它们的解决方案。
- en: Memory leak in Java
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的内存泄漏
- en: A memory leak occurs when the garbage collector could not collect the objects
    any longer being used/referenced by an application. If the objects are not garbage
    collected, the application uses more memory and, once the entire heap is full,
    the object cannot be allocated, which leads to `OutOfMemoryError`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当垃圾收集器无法收集应用程序不再使用/引用的对象时，就会发生内存泄漏。如果对象没有被垃圾收集，应用程序将使用更多内存，一旦整个堆区满了，对象就无法分配，导致`OutOfMemoryError`。
- en: Heap memory has two types of objects—referenced objects and unreferenced objects.
    The garbage collector will remove all unreferenced objects. However, the garbage
    collector would not be able to remove referenced objects even though they aren't
    used by the application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存有两种对象——被引用的对象和未被引用的对象。垃圾回收器会移除所有未被引用的对象。然而，垃圾回收器无法移除被引用的对象，即使它们没有被应用程序使用。
- en: Common reasons for memory leaks
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存泄漏的常见原因
- en: 'The following are the most common reasons for memory leaks:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内存泄漏的最常见原因：
- en: '**Open streams**: While working on streams and readers, we often forget to
    close the streams, which eventually results in the memory leak. There are two
    types of leaks that result from unclosed streams—low-level resource leak and memory
    leak. Low-level resource leak includes OS-level resources, such as file descriptor
    and open connection. As JVM consumes memory to track these resources, it leads
    to memory leak. To avoid leaks, use the `finally` block to close the stream or
    use the autoclose feature of Java 8.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开流：在处理流和读取器时，我们经常忘记关闭流，最终导致内存泄漏。未关闭流导致两种类型的泄漏——低级资源泄漏和内存泄漏。低级资源泄漏包括操作系统级资源，如文件描述符和打开连接。由于JVM消耗内存来跟踪这些资源，这导致内存泄漏。为了避免泄漏，使用`finally`块关闭流，或者使用Java
    8的自动关闭功能。
- en: '**Open connections**: We often forget to close opened HTTP, database, or FTP
    connections, which results in the memory leak. Similar to closing streams, close
    the connections.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开的连接：我们经常忘记关闭已打开的HTTP、数据库或FTP连接，这会导致内存泄漏。与关闭流类似，要关闭连接。
- en: '**Static variables referencing instance objects**: Any static variable referencing
    a heavy object could lead to memory leak because even if the variable is not in
    use, it won''t be garbage collected. To prevent this, try not to have heavy static
    variables; use local variables instead.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量引用实例对象：任何引用重对象的静态变量都可能导致内存泄漏，因为即使变量没有被使用，它也不会被垃圾回收。为了防止这种情况发生，尽量不要使用重的静态变量，而是使用局部变量。
- en: '**Missing methods for objects in collection**: Adding objects having no implementation
    of the `equals` and `hashcode` methods to `HashSet` will add the number of duplicate
    objects in `HashSet` and we would not be able to remove these objects once added.
    To prevent this, implement the `equals` and `hashcode` methods in the object added
    to `HashSet`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合中对象缺少方法：向`HashSet`中添加没有实现`equals`和`hashcode`方法的对象会增加`HashSet`中重复对象的数量，一旦添加就无法移除这些对象。为了避免这种情况，在添加到`HashSet`中的对象中实现`equals`和`hashcode`方法。
- en: 'Diagnosing memory leaks is a lengthy process that requires a lot of practical
    experience, debugging skills, and detailed knowledge of the application. The following
    are the ways to diagnose memory leaks:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断内存泄漏是一个需要大量实际经验、调试技能和对应用程序的详细了解的漫长过程。以下是诊断内存泄漏的方法：
- en: Enable GC logs and fine-tune GC parameters
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用GC日志并调整GC参数
- en: Profiling
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Code review
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码审查
- en: In the following sections, we will see GC's common pitfalls, GC methods, and
    tools to analyze GC logs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到GC的常见陷阱、GC方法和分析GC日志的工具。
- en: Common pitfalls
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: Performance tuning is critical, and things can start getting hairy with one
    small JVM flag. JVM is subject to GC pauses, which vary in frequency and duration.
    During a pause, everything stops and all kinds of unexpected behaviors start. During
    pauses and unstable behavior where JVM gets stuck, performance is impacted. We
    can see the symptoms of slow response times, high CPU, and memory utilization,
    or the system acts normally most of the time but behaves weirdly, such as performing
    extremely slow transactions and disconnections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 性能调优至关重要，只需一个小的JVM标志，事情就可能变得复杂。JVM会出现GC暂停，频率和持续时间各不相同。在暂停期间，一切都会停止，各种意外行为开始出现。在暂停和不稳定行为的情况下，JVM被卡住，性能受到影响。我们可以看到响应时间变慢、CPU和内存利用率高，或者系统大部分时间表现正常，但偶尔出现异常行为，比如执行极慢的事务和断开连接。
- en: The majority of the time, we measure the average transaction time and ignore
    the outliers that cause unstable behavior. Most of the time a system behaves normally,
    however at certain points, system responsiveness degrades. The majority of the
    time, the reason for this low performance is due to low awareness of GC overhead
    and focusing on only average response times.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分时间我们测量平均事务时间，忽略导致不稳定行为的异常值。大部分时间系统表现正常，但在某些时刻，系统响应性下降。这种低性能的原因大部分是由于对GC开销的低意识和只关注平均响应时间。
- en: 'When defining performance requirements, an important question we need to answer
    is: What are the acceptable criteria for our application related to GC pause frequency
    and duration? Requirements vary from application to application, so based on our
    application and user experience, we need to first define these criteria.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义性能要求时，我们需要回答一个重要问题：与GC暂停频率和持续时间相关的应用程序的可接受标准是什么？要求因应用程序而异，因此根据我们的应用程序和用户体验，我们需要首先定义这些标准。
- en: A few common misunderstandings we usually have are as follows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常存在一些常见的误解。
- en: Number of garbage collectors
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾回收器的数量
- en: Most of the time, people are not aware that there isn't only one, but four,
    garbage collectors. The four garbage collectors are—**Serial**, **Parallel**,
    **Concurrent**, and **Garbage First** (**G1**). We will see them in the following
    section. There are some third-party garbage collectors, such as **Shenandoah**.
    JVM HotSpot's default garbage collector is Parallel up to Java 8, while from Java
    9, the default collector is **Garbage First Garbage Collector** (**G1 GC**). A
    Parallel garbage collector isn't best most of the time; however, it depends on
    our application requirements. For example, the **Concurrent Mark Sweep** (**CMS**)
    and G1 collectors cause less frequent GC pauses. But when they do cause a pause,
    the pause duration will most likely be longer than a pause caused by the Parallel
    collector. On the other hand, the Parallel collector usually achieves higher throughput
    for the same heap size.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，人们并不知道不只有一个，而是四个垃圾收集器。这四个垃圾收集器是——**串行**，**并行**，**并发**和**垃圾优先**（**G1**）。我们将在下一节中看到它们。还有一些第三方垃圾收集器，比如**Shenandoah**。JVM
    HotSpot的默认垃圾收集器在Java 8之前是并行的，而从Java 9开始，默认收集器是**垃圾优先垃圾收集器**（**G1 GC**）。并行垃圾收集器并不总是最好的；然而，这取决于我们的应用程序需求。例如，**并发标记清除**（**CMS**）和G1收集器导致GC暂停的频率较低。但是当它们导致暂停时，暂停持续时间很可能比并行收集器导致的暂停时间长。另一方面，对于相同的堆大小，并行收集器通常能实现更高的吞吐量。
- en: Wrong garbage collector
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误的垃圾收集器
- en: A common reason for the GC issue is the wrong choice of garbage collector for
    the type of application. Each collector has their own significance and benefits.
    We need to find our application's behavior and priorities and based on which we
    need to choose right garbage collector. The default garbage collector of HotSpot's is
    Parallel/Throughput and, most of time, it hasn't proven to be a good choice. The
    CMS and G1 collector are concurrent and cause less frequent pauses, but when a
    pause does come, its duration is longer than the Parallel collector. So the choice
    of the collector is a common mistake we often make.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GC问题的一个常见原因是选择了错误的垃圾收集器。每个收集器都有其自己的重要性和好处。我们需要找出我们应用程序的行为和优先级，然后根据这些来选择正确的垃圾收集器。HotSpot的默认垃圾收集器是并行/吞吐量，大多数情况下并不是一个好选择。CMS和G1收集器是并发的，导致暂停的频率较低，但当暂停发生时，其持续时间比并行收集器长。因此，选择收集器是我们经常犯的一个常见错误。
- en: Parallel / Concurrent keywords
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行/并发关键字
- en: A GC can either cause a **s****top-the-world** (**STW**) situation, or objects
    can be collected concurrently without stopping the application. The GC algorithm
    can be executed in a single thread or in multithread. So, Concurrent GC does not
    mean it executes in parallel, whereas Serial GC doesn't mean it causes more pauses
    due to serial execution. Concurrent and Parallel are different, where Concurrent
    means the GC cycle, and Parallel means the GC algorithm.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GC可能会导致**全局停顿**（**STW**）的情况，或者对象可以在不停止应用程序的情况下并发收集。GC算法可以在单线程或多线程中执行。因此，并发GC并不意味着它是并行执行的，而串行GC并不意味着它由于串行执行而导致更多的暂停。并发和并行是不同的，其中并发表示GC周期，而并行表示GC算法。
- en: G1 is a problem solver
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: G1是一个问题解决者
- en: With the introduction of the new garbage collector in Java 7, many people think
    that it is the problem solver to all previous garbage collectors. An important
    problem solved by G1 GC is the fragmentation problem, which is common to the CMS
    collector. However, in many cases other collectors can outperform G1 GC. So it
    all depends on our application's behavior and requirements.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 7引入新的垃圾收集器，许多人认为它是解决以前所有垃圾收集器问题的问题解决者。G1 GC解决的一个重要问题是碎片问题，这是CMS收集器常见的问题。然而，在许多情况下，其他收集器可能会胜过G1
    GC。因此，一切取决于我们应用程序的行为和需求。
- en: Average transaction time
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平均事务时间
- en: Mostly, while testing performance, we tend to measure average transaction time
    and, by only doing that, we miss the outliers. At some point, when GC causes pauses
    for a long duration, the application's response time increases drastically, which
    affects users accessing the application. This can go unnoticed, as we are only
    looking at the average transaction time. When the GC pause frequency increases,
    response time becomes a serious problem that we might have ignored by just measuring
    the average response time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，在测试性能时，我们倾向于测量平均事务时间，但仅这样做会忽略异常值。当GC导致长时间暂停时，应用程序的响应时间会急剧增加，影响用户访问应用程序。这可能会被忽视，因为我们只关注平均事务时间。当GC暂停频率增加时，响应时间成为一个严重的问题，我们可能会忽略只测量平均响应时间而忽略的问题。
- en: Reducing new object allocation rates improves GC behavior
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少新对象分配率可以改善GC行为
- en: 'Instead of focusing or reducing the new object allocation rate, we should focus
    on the life of objects. There are three different types of objects lives: long-lived
    objects, we cannot do much about them; mid-lived objects, these cause the biggest
    issues; and short-lived objects, which usually get freed and allocated quickly
    so they are collected by the next GC cycle. So instead of concentrating on long-lived
    and short-lived objects, focusing on the mid-lived objects allocation rate could
    bring positive results. It''s not the object allocation rate alone; it''s the
    type of objects in play that causes all the trouble.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与其专注于减少新对象分配率，我们应该专注于对象的生命周期。有三种不同类型的对象生命周期：长期对象，我们对它们无能为力；中期对象，这些会导致最大的问题；和短期对象，通常会被快速释放和分配，因此它们会在下一个GC周期中被收集。因此，与其专注于长期和短期对象，专注于中期对象的分配率可能会带来积极的结果。问题不仅仅在于对象分配率，而是在于所涉及的对象类型。
- en: GC logs cause overhead
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC日志会导致开销
- en: 'It is not true that GC logs cause overhead, especially in the default log settings.
    The data is extremely valuable and Java 7 introduced hooks to control the size
    of their log files. If we don''t collect GC logs with timestamps, then we are
    missing out on a critical source of data to analyze and solve pausing issues.
    GC logs are the richest source of data for the state of GC in a system. We can
    get data about all GC events in our application; say, it is completed concurrently
    or caused an STW pause: how long did it take, how much CPU it consumed, and how
    much memory was freed. From this data, we would be able to understand the frequency
    and duration of pauses, their overhead, and move on to take action to reduce them.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable GC by adding following arguments:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: GC
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Java's best achievements is GC. The GC process automatically manages
    memory and heap allocation that tracks down dead objects, removes them, and reallocates
    memory to a new object. Theoretically, as garbage collector automatically manages
    memory, it makes developers create new objects without thinking about the allocation
    and deallocation of memory to eliminate memory leaks and other problems related
    to memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: How GC works
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We usually think that GC collects and removes the unreferenced objects. Instead,
    GC in Java tracks live objects and marks all unreferenced objects as garbage.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap area of the memory is where objects are allocated dynamically. We
    should allocate heap memory to JVM before running the application. Allocating
    heap to JVM in advance has a couple of consequences:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Improves object creation rate because JVM doesn't need to communicate with the
    OS to get memory for each new object. Once the JVM allocates memory to an object,
    JVM moves the pointer toward the next available memory.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collectors collect the object when there is no object reference and
    reuse its memory for new object allocation. As the garbage collector doesn't delete
    the object, no memory is returned to the OS.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Until the objects are being referenced, JVM considers them live objects. When
    an object is no longer referenced and is not reachable by the application code,
    the garbage collector removes it and reclaims its memory. We get a question in
    our mind, who is the first reference in the tree of objects, right? Let's see
    the object tree and its roots.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: GC roots
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each tree of an object has one or more objects at the root. If the garbage collector
    can reach the root, the tree is reachable. Any object that is not reached by,
    or referenced by, GC roots is considered dead and the garbage collector removes
    it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the different kinds of GC roots in Java:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**Local variables: **Variables or parameters of a Java method.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active threads:** A running thread is a live object.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static variables:** Classes referencing static variables. When the garbage
    collector collects classes, it removes references to static variables.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JNI references:** Object reference created during the JNI call. They are
    kept alive because JVM is unaware that the native code has references of it.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please have a look at the following diagram:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/659a24ab-1fe8-43dd-a409-8b29f771150d.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: GC roots
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: GC methods and policies
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the preceding section, there isn't one but four different garbage
    collectors. Each one has its own advantages and disadvantages. The one thing these
    collectors have in common is that they split the managed heap into different segments
    with the assumption that objects are short-lived and should be removed shortly.
    Let's see four different algorithms of GC.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Serial collector
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Serial collector is the simplest GC implementation, mainly designed for
    single-threaded environments and small heaps. This GC implementation freezes all
    application threads whenever it's working. Hence, it's not a good idea to use
    it in multithreaded applications, such as server environments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To enable the Serial garbage collector, set `-XX:+UseSerialGC` to VM arguments
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Parallel/Throughput collector
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Parallel collector is the JVM's default collector and is also known as the
    Throughput collector. As the name suggests, this collector, unlike the Serial
    collector, uses multithread to manage the heap memory. The Parallel garbage collector
    still freezes all the application threads when performing either minor or full
    GC. If we want to use the Parallel garbage collector, we should specify the tuning
    parameters, such as threads, pause time, throughput, and footprints.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the arguments to specify the tuning parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Threads: `-XX:ParallelGCThreads=<N>`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause time: `-XX:MaxGCPauseMillis=<N>`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughput: `-XX:GCTimeRatio=<N>`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Footprint (maximum heap size): `-Xmx<N>`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable the Parallel garbage collector in our application, set the `-XX:+UseParallelGC`
    option.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: CMS garbage collector
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CMS implementation uses multiple garbage collector threads to scan (mark)
    the unused objects that can be removed (sweep). This garbage collector is preferable
    for applications that require short GC pauses, and who can share processor resources
    with the garbage collector while the application is running.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The CMS algorithm enters into STW mode in only two cases: when objects in Old
    Generations are still referenced from the thread entry point or static variables,
    and when the application changed the state of the heap while CMS is running which
    makes the algorithm go back and reiterate the object tree to validate that it
    had marked the correct objects.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: With this collector, promotion failure is the greatest cause for concern. Promotion
    failure occurs when a race condition occurs between a collection of objects from
    the Young and Old Generations. If the collector needs to promote objects from
    the Young Generation to the Old Generation and there is not enough space, it has
    to first STW to create the space. In order to make sure this doesn't happen in
    the case of the CMS collector, increase the size of the Old Generation or allocate
    more background thread to the collector to compete with the allocation rate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide high throughput, CMS uses more CPU to scan and collect objects.
    It is good for long-running server applications, which are adverse to application
    freezes. So, if we can allocate more CPU to avoid application pauses, we can choose
    the CMS collector for GC in our application. To enable the CMS collector, set
    the -`XX:+UseConcMarkSweepGC` option.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: G1 collector
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the new collector, introduced in JDK 7 update 4\. The G1 collector is
    designed for an application willing to allocate heap memory of more than 4 GB.
    G1 divides the heap into multiple regions, spanning from 1 MB to 32 MB, depending
    on the heap we configure and uses multiple background threads to scan through
    the heap regions. The benefit of dividing the heap into multiple regions is that
    G1 will scan through regions where there is plenty of garbage first in order to
    meet a given pause time.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: G1 reduces the change of low-heap availability before the background threads
    have finished scanning for unused objects. This reduced the chances to STW. G1
    compacts the heap on-the-go, unlike CMS, which does this during STW.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: In order to enable the G1 garbage collector in our application, we need to set
    the `-XX:+UseG1GC` option in the JVM parameters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 update 20 introduced a new JVM argument, `-XX:+UseStringDeduplication`,
    for the G1 collector. With this argument, G1 identifies duplicate strings and
    creates the pointer to the same integral `char[]` array to avoid multiple copies
    of the same string.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: From Java 8 `PermGen`, part of the heap is removed. This was the part that was
    allocated for class metadata, static variables, and interned strings. This parameter-tuning
    caused many `OutOfMemory` exceptions, which would be fine from Java 8 onward,
    where JVM would take care of it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Heap memory
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Heap memory is divided into primarily two generations: Young Generation and
    Old Generation. There is a **PERM GENERATION** that is a part of heap memory until
    Java 7, while from Java 8, the **PERM GENERATION** is replaced by **METASPACE**.
    **METASPACE** is not part of the heap memory but is part of the **Native Memory**.
    Set size of **METASPACE** using the `-XX:MaxMetaspaceSize` option. It is critical
    to consider this setting when going to production since if **METASPACE** takes
    up excessive memory, it affects the application''s performance:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c93fe61-8690-43ce-9362-ff57c083d627.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Java 8 memory management
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Young Generation** is where objects are created and allocated; it''s
    for young objects. The **Young Generation** is further divided into **Survivor
    Space**. The following is the **Hotspot Heap Structure**:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f239e0c8-d541-4a54-9646-068d5a38f0ec.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: 'The **eden** area is, by default, bigger than **Survivor Space**. All the objects
    are created first in the **eden** area. When **eden** is full, minor GC is triggered,
    which will quickly scan the object''s references, and unreferenced objects are
    marked dead and collected. The **Survivor Space** area in either of them would
    always be empty. Objects that survived in **eden** during minor GC will be moved
    to the empty **Survivor Space**. We might wonder why there are two **Survivor
    Space **areas and not one. The reason is to avoid memory fragmentation. When the
    **Young Generation** runs through and removes dead objects from the **Survivor
    Space**, it leaves holes in the memory and needs compaction. To avoid compaction,
    JVM moves surviving objects from one **Survivor Space** to another. This ping-pong
    of live objects from **eden** and one **Survivor Space** to another happens until
    the following conditions occur:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Objects reach maximum tenuring threshold. This means objects are no longer young.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Survivor Space** is full and cannot accommodate any new objects.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the preceding conditions happen, objects are moved to the **Old Generation**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: JVM flags
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following are the JVM parameters/flags commonly used in applications to
    tune the JVM for better performance. Tuning values depend on our application's
    behavior and the rate at which it is generated. So there is no defined guideline
    to use specific values for JVM flags in order to achieve better performance.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: -Xms and -Xmx
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `-Xms` and `-Xmx` are known as the minimum and maximum heap size. Setting `-Xms` equal
    to `-Xmx` prevents GC pauses during heap expansion and improves performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: -XX:NewSize and -XX:MaxNewSize
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can set the size of the Young Generation using `-XX:MaxNewSize`. The Young
    Generation resides under the total heap memory and the Old Generation size will
    be smaller if we set the size of the Young Generation as large. The Young Generation
    size should never be larger than the Old Generation for stability reasons. Thus, `-Xmx/2`
    is the maximum size we can set for `-XX:MaxNewSize`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: To achieve better performance, set the initial size of the Young Generation
    by setting the `-XX:NewSize` flag. This saves some costs in terms of the Young
    Generation growing to that size over time.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: -XX:NewRatio
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can set the size of the Young Generation as a ratio of the Old Generation
    using the `-XX:NewRatio` option. The benefit we can get with this option could
    be that the Young Generation can grow and shrink when JVM adjusts the total heap
    size during execution. `-XX:NewRatio` means the ratio of Old Generation is larger
    than the Young Generation. `-XX:NewRatio=2` means the size of the Old Generation
    is twice that of the Young Generation, which further means that the Young Generation
    is 1/3 of the total heap.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: If we specify ratio and a fixed size for the Young Generation, then the fixed
    size will take precedence. There is no generation rule regarding which method
    of specifying the size of the Young Generation is preferable. The rule of thumb
    here is that if you know the size of the objects generated by our application,
    then specify the fixed size, otherwise, specify the ratio.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了Young Generation的比例和固定大小，那么固定大小将优先。关于指定Young Generation大小的方法没有一定的规则。这里的经验法则是，如果我们知道应用程序生成的对象的大小，那么指定固定大小，否则指定比例。
- en: -XX:SurvivorRatio
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:SurvivorRatio
- en: The `-XX:SurvivorRatio` value is the ratio of eden relative to Survivor Spaces.
    There will be two Survivor Spaces and each one would be equal to the other. If `-XX:SurvivorRatio=8`,
    then eden occupies 3/4 and each Survivor Spaces occupies 1/4 of the total Old
    Generation size.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`-XX:SurvivorRatio`值是Eden相对于Survivor Spaces的比例。将有两个Survivor Spaces，每个都相等。如果`-XX:SurvivorRatio=8`，那么Eden占3/4，每个Survivor
    Spaces占老年代总大小的1/4。'
- en: If we set a ratio such that Survivor Spaces are small, then eden will make more
    space for new objects. During minor GC, unreferenced objects will be collected
    and eden will be empty for new objects, however, if the object still has references,
    then the garbage collector moves them to the Survivor Space. If the Survivor Space
    is small and cannot accommodate the new object, then the objects will be moved
    to the Old Generation. Objects in the Old Generation can only be collected during
    full GC, which creates long pauses in the application. And if the Survivor Space
    is large enough, then more objects can live in the Survivor Space but die young.
    If the Survivor Spaces are large, eden would be small, and a small eden would
    cause frequent young GC.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置了Survivor Spaces很小的比例，那么Eden将为新对象腾出更多空间。在Minor GC期间，未引用的对象将被收集，Eden将为空出来给新对象，但是如果对象仍然有引用，垃圾收集器会将它们移动到Survivor
    Space。如果Survivor Space很小，无法容纳新对象，那么对象将被移动到老年代。老年代中的对象只能在Full GC期间被收集，这会导致应用程序长时间暂停。如果Survivor
    Space足够大，那么更多的对象可以存活在Survivor Space中，但会死得很快。如果Survivor Spaces很大，Eden将会很小，而小的Eden会导致频繁的Young
    GC。
- en: -XX:InitialTenuringThreshold, -XX:MaxTenuringThreshold, and -XX:TargetSurvivorRatio
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:InitialTenuringThreshold、-XX:MaxTenuringThreshold和-XX:TargetSurvivorRatio
- en: The tenuring threshold decides when an object can be promoted/moved from the
    Young Generation to the Old Generation. We can set the initial and maximum value
    of the tenuring threshold using the `-XX:InitialTenuringThreshold` and `-XX:MaxTenuringThreshold` JVM
    flags. We can also use `-XX:TargetSurvivorRatio` to specify the target utilization
    (as a percentage) of the Survivor Space at the end of a Young Generation GC.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Tenuring阈值决定了对象何时可以从Young Generation晋升/移动到Old Generation。我们可以使用`-XX:InitialTenuringThreshold`和`-XX:MaxTenuringThreshold`
    JVM标志来设置tenuring阈值的初始值和最大值。我们还可以使用`-XX:TargetSurvivorRatio`来指定Young Generation
    GC结束时Survivor Space的目标利用率（以百分比表示）。
- en: -XX:CMSInitiatingOccupancyFraction
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:CMSInitiatingOccupancyFraction
- en: Use the `-XX:CMSInitiatingOccupancyFraction=85` option when using the CMS collector
    (`-XX:+UseConcMarkSweepGC`). If the flag is set and the Old Generation is 85%
    full, the CMS collector starts collecting unreferenced objects. It is not necessary
    that CMS will start collection only after the Old Generation 85% occupied. If
    we want CMS to start only at 85%, then we need to set `-XX:+UseCMSInitiatingOccupancyOnly`.
    The default value of the `-XX:CMSInitiatingOccupancyFraction` flag is 65%.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用CMS收集器（-XX:+UseConcMarkSweepGC）时，使用`-XX:CMSInitiatingOccupancyFraction=85`选项。如果设置了该标志，并且老年代占用了85%，CMS收集器将开始收集未引用的对象。并不是必须老年代占用了85%
    CMS才开始收集。如果我们希望CMS只在85%时开始收集，那么需要设置`-XX:+UseCMSInitiatingOccupancyOnly`。`-XX:CMSInitiatingOccupancyFraction`标志的默认值为65%。
- en: -XX:+PrintGCDetails, -XX:+PrintGCDateStamps, and -XX:+PrintTenuringDistribution
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: -XX:+PrintGCDetails、-XX:+PrintGCDateStamps和-XX:+PrintTenuringDistribution
- en: Flags are set to generate GC logs. In order to fine-tune JVM parameters to achieve
    better performance, it is important to understand GC logs and the behavior of
    the application. `-XX:+PrintTenuringDistribution` reports the statistics of an
    object (how old they are) and the desired threshold of objects when they are promoted.
    This is very important to understand how our application is holding the objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 设置标志以生成GC日志。为了微调JVM参数以实现更好的性能，了解GC日志和应用程序的行为非常重要。`-XX:+PrintTenuringDistribution`报告对象的统计信息（它们的年龄）以及它们晋升时的期望阈值。这对于了解我们的应用程序如何持有对象非常重要。
- en: Tools to analyze GC logs
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析GC日志的工具
- en: 'The Java GC logs are one of the places where we can start debugging an application
    in the event of a performance issue. The GC logs provide important information,
    such as:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Java GC日志是我们在性能问题发生时可以开始调试应用程序的地方之一。GC日志提供重要信息，例如：
- en: The last time the GC ran
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC上次运行的时间
- en: The number of GC cycles run
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC循环运行的次数
- en: The interval at which the GC ran
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC运行的间隔
- en: The amount of memory freed up after the GC ran
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC运行后释放的内存量
- en: The time the GC took to run
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GC运行的时间
- en: The amount of time for which the JVM paused when the garbage collector ran
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾收集器运行时JVM暂停的时间
- en: The amount of memory allocated to each generation
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配给每个代的内存量
- en: 'The following is the sample GC logs:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是样本GC日志：
- en: '[PRE1]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These logs are very difficult to interpret quickly. If we have a tool that can
    render these logs in a visual interface, it would be easy and quick to understand
    what is going on with the GC. We will take a look at one such tool to interpret
    the GC logs in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志很难快速解释。如果有一个工具可以将这些日志呈现在可视化界面中，那么就可以轻松快速地理解GC的情况。我们将在下一节中看一下这样的工具来解释GC日志。
- en: GCeasy
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCeasy
- en: GCeasy is one of the most popular garbage collection log analysis tools. GCeasy
    is developed to identify problems from the GC logs automatically. It is intelligent
    enough to provide alternative ways to solve problems.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GCeasy是最受欢迎的垃圾收集日志分析工具之一。GCeasy被开发出来自动从GC日志中识别问题。它足够智能，可以提供解决问题的替代方法。
- en: 'The following are the important basic features provided by GCeasy:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Uses machine learning algorithms to analyze the logs
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly detects memory leaks, premature object promotions, long JVM pauses,
    and many other performance issues
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful and informative visual analyzer
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides the REST API for proactive log analysis
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free cloud-based tool for log analysis
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides suggestions on the JVM heap size
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equipped to analyze all formats of GC logs
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCeasy.io ([http://www.gceasy.io/](http://www.gceasy.io/)) is the online garbage
    collection log analysis tool. It requires the log files to be uploaded on the
    GCeasy public cloud.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to gather detailed log analysis using the online
    tool:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Enable GC logs in the application by adding `XX:+PrintGCDetails -XX:+PrintGCDateStamps
    -Xloggc:<GC-log-file-path>` in the JVM parameters on the server.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the GC log file is generated at a specified location, upload the file to
    the GCeasy cloud by navigating to [http://gceasy.io/](http://gceasy.io/). It is
    also possible to upload a compressed ZIP file in case there are multiple log files
    to be analyzed.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the log files are processed, the detailed analysis report will be generated.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The report is properly organized and detailed enough to highlight every possible
    problem causing the performance hit. The following section explains the important
    sections in the report generated by GCeasy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Tips on JVM tuning
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The top section in the report provides suggestions based on the garbage-collection-log
    analysis. The suggestions are generated dynamically by machine learning algorithms
    after a thorough analysis of the log files. The details in the suggestion also
    include the probable cause of the issue. The following is an example suggestion
    provided by GCeasy after GC log analysis:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9d60f2f-d1d0-4b46-9d97-627b209fc693.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: JVM Heap Size
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section in the report provides information on the heap allocation and
    peak memory usage for each memory generation. It is possible that the allocated
    heap size may not match the one defined in the JVM parameters. This is because
    the GCeasy tool obtains the allocated memory information from the logs. It is
    possible that we have allocated 2 GB of heap memory, but at runtime, JVM could
    allocate only 1 GB of heap memory. In such a case, the report will show the allocated
    memory as 1 GB. The report shows the heap allocation in tabular and graphical
    formats. The following is an example heap size section from the report:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/760de75d-71b3-44b7-84b9-9583efa5af91.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Key Performance Indicators
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Key Performance Indicators** (**KPIs**) help make profound decisions for
    improving the application''s performance. Throughput, latency, and footprint are
    a few of the important KPIs. The KPIs in the report include Throughput and Latency.
    The footprint basically describes the amount of time CPU was occupied. It can
    be obtained from a performance-monitoring tool, such as JVisualVM.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The Throughput option indicates the amount of productive work done by the application
    during a specified time period. The Latency option indicates the average time
    taken by the GC to run.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of KPIs from the report:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d375ac5-b067-44c4-8efe-98a2a8498c14.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: GC Statistics
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GC statistics section provides information on the behavior of the garbage
    collector over a period of time. The period is the time duration for which the
    logs are analyzed. The GC statistics are provided based on real-time analysis.
    The statistics include the bytes reclaimed after the garbage collector ran, the
    cumulative GC time in seconds, and the average GC time in seconds. This section
    also provides information on total GC statistics, minor and full GC statistics,
    and GC pause statistics in a tabular format.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: GC Causes
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The GC Causes section provides information on what caused the garbage collector
    to run. The information is provided in tabular as well as graphical format. Along
    with the reasons, it also provides information on the time it took for the garbage
    collector to execute. The following is an example from the report:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f5ee498-4526-4f89-a07b-3d56e0863889.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: Based on the preceding details, GCeasy is an important tool in helping developers
    to interpret GC logs in a visual manner.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about JVM and its parameters. We learned about memory
    leaks and common misunderstandings related to GC. We learned about different GC
    methods and their importance. We learned about import JVM flags, which are tuned
    to achieve better performance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Spring Boot microservices and its performance
    tuning. Microservice is an architecture of an application with loosely coupled
    services that implements business capabilities. Spring Boot enables us to build
    production-ready applications.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
