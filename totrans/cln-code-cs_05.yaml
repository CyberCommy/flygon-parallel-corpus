- en: Exception Handling
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at functions. Despite the best efforts of
    programmers to write robust code, functions will, at some point, generate exceptions.
    This could be for a number of reasons, such as a missing file or folder, an empty
    or null value, the location can't be written to, or the user is denied access.
    So, with that in mind, in this chapter, you will learn about appropriate ways
    to use exception handling to produce clean C# code. First, we will start by looking
    at checked and unchecked exceptions with regards to arithmetic `OverflowExceptions`.
    We will look at what they are, why they are used, and some examples of them being
    used in code.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we'll look at how we can avoid the `NullPointerReference` exception. After
    that, we'll look at implementing specific business rules for specific types of
    exceptions. With our fresh understanding of exceptions and exception business
    rules, we will set about building our own custom exceptions and then finish off
    by looking at why we should not use exceptions to control the flow of our computer
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Checked and unchecked exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding `NullPointerExceptions`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business rule exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions should provide meaningful information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building your own custom exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have the skills to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to understand what checked and unchecked exceptions are, and
    why they are in C#.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to understand what an `OverflowException` is and how to trap
    them at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will know what `NullPointerExceptions` are and how to avoid them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to write your own custom exceptions that provide meaningful
    information to the customer and that aid you and fellow programmers to easily
    identify and resolve any issues that are raised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be able to understand why you should not use exceptions to control
    program flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will know how to replace business rule exceptions with C# statements and
    Boolean checks to control program flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checked and unchecked exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In unchecked mode, an arithmetic overflow is *ignored*. In this situation, the
    high-order bits that cannot be assigned to the destination type are discarded
    from the result.
  prefs: []
  type: TYPE_NORMAL
- en: By default, C# operates in the unchecked context while performing non-constant
    expressions at runtime. But compile-time constant expressions are *always* checked
    by default. When an arithmetic overflow is encountered in checked mode, an `OverflowException`
    is raised. One reason why unchecked exceptions are used is to increase performance.
    Checked exceptions can decrease the performance of methods by a small amount.
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb is to make sure that you perform arithmetic operations in
    the checked context. Any arithmetic overflow exceptions will be picked up as compile-time
    errors, and you can then fix them before you release your code. That is much better
    than releasing your code and then having to fix customer runtime errors.
  prefs: []
  type: TYPE_NORMAL
- en: Running code in unchecked mode is dangerous as you are making assumptions about
    the code. Assumptions are not facts and they can lead to exceptions being raised
    at runtime. Runtime exceptions lead to poor customer satisfaction and can produce
    serious follow-on exceptions that negatively impact a customer in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing an application to continue running that has experienced an overflow
    exception is very dangerous from a business perspective. The reason for this is
    that data can end up in a non-reversible invalid state. If the data is critical
    customer data, then this can be considerably costly to the business, and you don't
    want that on your shoulders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code. This code demonstrates how bad an unchecked overflow
    can be in the world of customer banking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Imagine the horror on this customer's face when they see that adding £1 to their
    bank balance of £2,147,483,647 causes them to be in debt by -£2,147,483,648!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a108b152-4768-43c9-acf0-164699f74f0b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it''s time to demonstrate checked and unchecked exceptions with some code
    examples. First, start a new **console application** and declare some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code declares two bytes that we will use in our arithmetic code
    examples. Now, add the `CheckedAdd()` method. This method will raise a checked
    `OverflowException` if an arithmetic overflow is encountered when adding two numbers
    that result in a number that is too big to be stored as a byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write the `CheckedMultiplication()` method. Again, a checked `OverflowException`
    will be raised if an arithmetic overflow is detected during the multiplication,
    which results in a number that is larger than a byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the `UncheckedAdd()` method. This method will ignore any overflow
    that happens as a result of an addition, and so an `OverflowException` will not
    be raised. The result of this overflow will be stored as a byte, but the value
    will be incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we add the `UncheckedMultiplication()` method. This method will not
    throw an `OverflowException` when an overflow is encountered as the result of
    this multiplication. The exception will simply be ignored. This will result in
    an incorrect number being stored as a byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is time to modify our `Main(string[] args)` method so that we can
    initialize the variables and execute the methods. Here, we add the maximum value
    for a byte to the `y` variable and `2` to the `z` variable. Then, we run the `CheckedAdd()`
    and `CheckedMultiplication()` methods, which will both generate `OverflowException()`.
    This is thrown because the `y` variable contains the maximum value for a byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, by adding or multiplying by `2`, you are exceeding the address space needed
    to store the variable. Next, we will run the `UncheckedAdd()` and `UncheckedMultiplication()`
    methods. Both these methods ignore overflow exceptions, assign the result to the
    `x` variable, and disregard any bits that overflow. Finally, we print a message
    to the screen and then exit when the user presses any key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code, we end up with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/575def5c-092b-4eda-b195-6fc08d6d56bd.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when we use checked exceptions, exceptions are raised when `OverflowException`
    is encountered. But when we use unchecked exceptions, no exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: It is apparent from the preceding screenshot that problems can arise from unexpected
    values and that certain behaviors can arise from using unchecked exceptions. Therefore,
    the rule of thumb when performing arithmetic operations must be to always use
    checked exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and look at a very common exception that is encountered frequently
    by programmers, known as `NullPointerException`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding NullPointerExceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`NullReferenceException` is a common exception that has been experienced by
    most programmers. It is thrown when an attempt is made to access a property or
    method on a `null` object.'
  prefs: []
  type: TYPE_NORMAL
- en: To defend against computer program crashes, the common course of action among
    fellow programmers is to use `try{...}catch (NullReferenceExceptionre){...}` blocks.
    This is a part of defensive programming. But the problem is that, a lot of the
    time, the error is simply *logged* and *rethrown*. Besides this, a lot of wasted
    computations are performed that could have been avoided.
  prefs: []
  type: TYPE_NORMAL
- en: A much better way of handling `ArgumentNullExceptions` is to implement `ArgumentNullValidator`.
    The parameters of a method are usually the source of a `null` object. It makes
    sense to test the parameters of a method before they are used and, if they are
    found to be invalid for any reason, to throw an appropriate `Exception`. In the
    case of `ArgumentNullValidator`, you would place this validator at the top of
    the method and then test each parameter. If any parameter was found to be `null`,
    then `NullReferenceException` would be thrown. This would save computations and
    remove the need to wrap your method's code in a `try...catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things clear, we will write `ArgumentNullValidator` and use it in a
    method to test the method''s arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have created the `Person` class with a single read-only
    property called `Name`. This will be the object that we will use to pass into
    the example methods to cause `NullReferenceException`. Next, we will create our
    `Attribute` for the validator called `ValidatedNotNullAttribibute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `Attribute`, it''s time to write the validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`ArgumentNullValidator` takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object is checked to see if it is `null`. If it is `null`, `ArgumentNullException`
    is thrown, passing in the name of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method is our `try/catch` example method. Notice that we log
    a message and throw the exception. However, we don''t use the declared exception
    parameter, and so by rights, this should be removed. You will see this quite often
    in code. It is unnecessary and should be removed to tidy the code up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will write our example method that will use `ArgumentNullValidator`.
    We will call it `ArgumentNullValidatorExample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have gone from nine lines, including braces, to only two lines.
    We also don't attempt to use the value before it has been validated. All we need
    to do now is modify our `Main` method to run the methods. Test each method by
    commenting out one of the methods and running the program. When you do this, it
    is best to step through your code to see what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of running the `TryCatchExample` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af29322d-9c55-4bf5-919a-2d18d325f98e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the output of running `ArgumentNullValidatorExample`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1e41646-e39e-46c3-a8ea-43d813d5e302.png)'
  prefs: []
  type: TYPE_IMG
- en: If you study the previous screenshots carefully, you will see that we have only
    logged the error once when using `ArgumentNullValidatorExample`. When throwing
    the exception using `TryCatchExample`, the exception is logged twice.
  prefs: []
  type: TYPE_NORMAL
- en: The first time, we have a meaningful message, but the second time, the message
    is *cryptic*. However, the exception that is logged by the calling method, `Main`,
    is not cryptic at all. It is, in fact, very helpful as it shows us that the value
    cannot be `null` for the `Person` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, this section has shown you the value of checking your parameters
    in your constructors and methods before you use them. By doing this, you can see
    how argument validators reduce your code, thus making it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at implementing business rules for specific exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Business rule exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Technical exceptions are exceptions that are thrown by a computer program as
    a result of programmer mistakes and/or environmental issues such as there not
    being enough disk space.
  prefs: []
  type: TYPE_NORMAL
- en: But business rule exceptions are different. Business rule exceptions imply that
    such behavior is expected and is used to control program flow, when in fact, exceptions
    should be an exception to the normal flow of the program and not the expected
    output of a method.
  prefs: []
  type: TYPE_NORMAL
- en: For example, picture a person at an ATM drawing out £100 from their account
    that has £0 in it and does not have the ability to go overdrawn. The ATM accepts
    the user request to draw £100 out, and so it issues the `Withdraw(100);` command.
    The `Withdraw` method checks the balance, discovers that the account has insufficient
    funds, and so throws `InsufficientFundsException()`.
  prefs: []
  type: TYPE_NORMAL
- en: You may think that having such exceptions is a good idea as they are explicit
    and help identify issues so that you can carry out a very specific action upon
    receiving such exceptions – but no! This is not a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: In such a scenario, when the user submits the request, the amount requested
    should be checked to see if it can be withdrawn. If it can, then the transaction
    should go ahead, as requested by the user. But if the validation check identifies
    that the transaction is unable to go ahead, then the program should follow normal
    program flow to cancel the transaction and inform the user who issued the request
    without raising an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The withdrawal scenario we've just looked at shows that the programmer has correctly
    pondered upon the normal flow of the program and the different outcomes. The program
    flow has been appropriately coded using Boolean checks to allow for the successful
    withdrawal transactions and to prevent disallowed withdrawal transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we would implement a withdrawal from a bank account that does
    not allow an overdraft scenario using **Business Rule Exceptions** (**BREs**).
    Then, we'll take a look at how we would implement the same scenario but using
    normal program flow instead of employing BREs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new console application and add two folders called `BankAccountUsingExceptions`
    and `BankAccountUsingProgramFlow`. Update your `void Main(string[] args)` method
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code runs each scenario. `UsingBusinessRuleExceptions()` demonstrates
    the use of exceptions as the expected output that's used to control program flow,
    while `UsingProgramFlow()` demonstrates the clean way of controlling program flow
    without the use of exceptional conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need a class to hold our current account information. So, add a class
    called `CurrentAccount` to your Visual Studio console project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties of this class can only be set internally or externally via the
    constructor. Now, add the constructor that takes the customer identifier as the
    only parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The current account constructor initializes all the properties. As shown in
    the preceding code, some properties are initialized using methods. Let''s implement
    each of the methods in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`GetAgreedOverdraftLimit()` returns the value of the agreed overdraft limit
    on the account. In this example, it is hardcoded to zero. But in a real scenario,
    it would extract the actual figure from a configuration file or other data store.
    This would allow non-technical users to update the agreed overdraft limit without
    developers having to change the code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetIsAllowedToGoOverdrawn()` determines if the account can be overdrawn, even
    if it has not been agreed, as some banks allow. In this case, we just return `false`
    to determine that the account is unable to go overdrawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of this example, we will set the user''s account balance to
    £250 in the `GetCurrentBalance()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a part of our example, we need to make sure that even if the person has
    £250 in their account, but their available balance is less than that, they are
    unable to withdraw more than the available balance as this would cause them to
    go overdrawn. To do this, we will set the available balance to £173.64 in the `GetAvailableBalance()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the UK, ATM machines will either allow you to withdraw a maximum of
    £200 or £250\. So, in the `GetAtmDailyLimit()` method, we will set the ATM daily
    limit to £250:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's write the code for our two scenarios by using business rule exceptions
    and normal program flow to handle different conditions within a program.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – handling conditions with business rule exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a new class to your project called `UsingBusinessRuleExceptions` and then
    add the following `Run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Run()` method calls two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The first method is called `ExceedAtmDailyLimit()`. This method intentionally
    exceeds the daily amount that is allowed to be withdrawn from an ATM. `ExceedAtmDailyLimit()`
    causes `ExceededAtmDailyLimitException`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Secondly, the `ExceedAvailableBalance()` method is called, which intentionally
    causes an `InsufficientFundsException`. Add the `ExceedAtmDailyLimit()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExceedAtmDailyLimit()` method creates a new `CustomerAccount` method and
    passes in the customer''s identifier, as represented by the number `1`. Then,
    an attempt is made to withdraw £300\. If the request is successful, then the message
    `Request accepted. Take cash and card.` is printed to the console window. Should
    the request fail, then the method traps `ExceededAtmLimitException` and prints
    the exception''s message to the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ExceedAvailableBalance()` method creates a new `CurrentAccount` and passes
    in the customer identifier, as represented by the number `1`. An attempt is then
    made to withdraw £180\. Since `GetAvailableMethod()` returns £173.64, the method
    causes an `InsufficientFundsException`.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've seen how to manage different conditions using business rule
    exceptions. Now, let's look at the proper way to manage the same conditions using
    normal program flow, without the use of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2 – handling conditions with normal program flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a class called `UsingProgramFlow` and then add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor of the `UsingProgramFlow` class, we will create a new `CurrentAccount`
    class and pass in the customer identifier. Next, we''ll add the `Run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Run()` method sets the `_requestedAmount` variable three times. Each time
    it does this, a message is printed stating the withdrawn amount on the console
    window before calling the `WithdrawMoney()` method. Now, add the `ExceedsDailyLimit()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExceedDailyLimit()` method returns `true` if `_requestedAmount` exceeds
    the daily ATM withdrawal limit. Otherwise, it returns false. Now, add the `ExceedsAvailableBalance()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExceedsAvailableBalance()` method returns `true` if the requested amount
    is more than is available for withdrawal. Finally, we come to the last method,
    called `WithdrawMoney()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `WithdrawMoney()` method does not use BREs to control the program flow.
    Instead, this method calls Boolean validation methods that determine the program
    flow. If `_requestedAmount` exceeds the ATM daily limit, as determined by the
    call to `ExceedsDailyLimit()`, then the request is denied. Otherwise, the next
    check is carried out to see if `_requestedAmount` is more than `AvailableBalance`.
    If it is, then the request is rejected. If not, then the code is executed that
    grants the request.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you can see that it makes more sense to control the flow of a program
    using the available logic rather than expecting exceptions to be thrown. The code
    is a lot cleaner and more correct. Exceptions should be reserved for exceptional
    circumstances that are not a part of the business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: When proper exceptions are raised in the correct manner, it is important for
    them to be meaningful. Cryptic error messages are no good for anyone and can actually
    add unnecessary stress for end users or developers. Now, we are going to look
    at providing meaningful information in any of the exceptions that are raised by
    our computer programs.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions should provide meaningful information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Critical errors that state "There is no error" and then kill a program are just
    not useful at all. I have experienced the actual "There is no error" critical
    exception first hand. It is a critical exception that stops an application from
    working. Yet the message is informing us that there is no error. Well, if there
    is no error, then why has a critical exception warning appeared on the screen?
    And why am I unable to continue using the application? Obviously, for the critical
    exception to be raised, there must be a critical exception somewhere that occurred.
    But where and why?
  prefs: []
  type: TYPE_NORMAL
- en: What makes such exceptions even more annoying is when they are deep-rooted in
    the framework or library that you are using (which you have no control over),
    and where you have no access to the source code. Such exceptions have caused programmers
    to say negative things out of frustration. I've been guilty of this and I've experienced
    fellow colleagues do the same. One of the main reasons for the frustration is
    the unhelpful fact that the code has raised an error and the user or programmer
    has been informed, but there is no helpful information to suggest what the problem
    is or where to look or even what remedial action to take.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions must provide information that is human-friendly, especially to the
    technically challenged. During my time developing dyslexia testing and assessment
    software, I have worked with many teachers and IT technicians.
  prefs: []
  type: TYPE_NORMAL
- en: It can be said that many IT technicians and teachers at all levels of ability
    have often been clueless when it comes to responding to software exception messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'One error that has perplexed many of the end users of the software I''ve supported
    has been **Error 76: Path not found**. This is an old Microsoft exception that
    has been around as far back as Windows 95, and that still exists today. For the
    end user of the software that raises this exception, the error message is totally
    useless. It would be useful for the end user to know what file and location cannot
    be found and to know what steps to take to remedy the situation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A potential solution would be to implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for the existence of the location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the location does not exist or access is denied, then display the file save
    or open dialog as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the user-selected location to a configuration file for future use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On subsequent runs of the same code, use the location set by the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But if you were to stay with the error message, then you should at least provide
    the name of the location and/or file that is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, it is now time to look at how we can build our own exceptions
    to provide just the right amount of information that will be useful to the end
    user and to the programmer. But take note: you must be careful not to disclose
    sensitive information or data.'
  prefs: []
  type: TYPE_NORMAL
- en: Building your own custom exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft .NET Framework already has a good number of exceptions that can be
    raised that you are able to trap. But there may be instances where you'll require
    a custom exception that provides more detailed information or that is more end
    user friendly in its terminology.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are now going to look at what the requirements are for building our
    own custom exceptions. It is surprisingly simple to build your own custom exception.
    All you have to do is give your class a name that ends with `Exception` and inherit
    from `System.Exception`. Then, you need to add three constructors, as shown in
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`TickerListNotFoundException` inherits from the `System.Exception` class. It
    contains three mandatory constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: A default constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that accepts a string of text for the exception message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor that accepts a string of text for the exception message and an
    `Exception` object for the inner exception
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are now going to write and execute three methods that will use each of our
    custom exception''s constructors. You will be able to clearly see the benefit
    of using custom exceptions to create more meaningful exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows our updated `Main(string[] args)` method, which has
    been updated to execute our three methods. These will test each of our custom
    exception''s constructors in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ThrowCustomExceptionA()` method throws a new `TickerListNotFoundException`
    by using the default constructor. When you run the code, the message that''s printed
    to the console window informs the user that a `CH05_CustomExceptions.TickerListNotFoundException`
    has been thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`ThrowCustomExceptionB()` throws a new `TickerListNotFoundException` by using
    the constructor that accepts a text message. In this case, the end user is informed
    that the ticker list hasn''t been found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `ThrowCustomExceptionC()` method throws a `TickerListNotFoundException`
    by using the constructor that takes a text message and inner exception. In our
    example, we provide a meaningful message stating that the ticker list has not
    been found for this exchange. The inner `FileNotFoundException` expands upon this
    by providing the name of the specific file that was not found, which happens to
    be the ticker list of Aim companies on the **London Stock Exchange** (**LSE**).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that there are genuine advantages to creating your own custom
    exceptions. But in most cases, using the intrinsic exceptions within .NET Framework
    should suffice. The main benefit of custom exceptions is that they're more meaningful
    exceptions that aid with debugging and resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief list of C# exception handling best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: Use try/catch/finally blocks to recover from errors or release resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle common conditions without throwing exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design classes so that exceptions can be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throw exceptions instead of returning an error code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the predefined .NET exception types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End exception class names with the word **Exception**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include three constructors in custom exception classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that exception data is available when code executes remotely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use grammatically correct error messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include a localized string message in every exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In custom exceptions, provide additional properties as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place throw statements so that the stack trace will be helpful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use exception builder methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restore state when methods don't complete due to exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it's time to summarize what we have learned in regard to exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about checked exceptions and unchecked exceptions.
    Checked exceptions prevent arithmetic overflow conditions from entering any production
    code as they are trapped at compile time. Unchecked exceptions go unchecked at
    compile time and can often make it into production code. This can lead to some
    *hard-to-track-down* bugs in your code through unexpected data values and even
    result in exceptions being thrown that cause your programs to crash.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned about the common `NullPointerException` and how to validate
    parameters that have been passed in using custom `Attribute` and `Validator` classes,
    which are placed at the top of your methods. These allow you to provide meaningful
    feedback when validation fails. This leads to more robust programs in the long
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed using **BREs** to control program flow. You were shown how
    to control the program flow by expecting exceptional output. Then, you saw how
    to achieve better control over the flow of computer code without using exceptions
    by using conditional checks.
  prefs: []
  type: TYPE_NORMAL
- en: The discussion then moved onto the importance of providing meaningful exception
    messages and how this can be achieved; that is, by writing your own custom exceptions
    that inherit from the `Exception` class and implement the required three parameters.
    Through the examples provided, you learned how to use your custom exceptions and
    how they aid better debugging and resolution.
  prefs: []
  type: TYPE_NORMAL
- en: So, now, it is time to put what you've learned to the test by answering some
    questions. There is also further reading for you to do if you wish to expand upon
    what you have learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at unit testing and how to write your
    tests first so that they fail. Then, we will write just enough code for the tests
    to pass and refactor the working code before moving on to the next unit test.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a checked exception?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an unchecked exception?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an arithmetic overflow exception?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a `NullPointerException`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you validate null parameters to improve your overall code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does BRE stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are BREs good or bad practice, and why do you think that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the alternative to BREs, is it good or bad, and why do you think that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you provide meaningful exception messages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the requirements for writing your own custom exceptions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/):
    This is the official documentation for handling and throwing exceptions in .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reflectoring.io/business-exceptions/](https://reflectoring.io/business-exceptions/):
    The author of this article provides five reasons why BREs are a bad idea after
    originally believing they were a good idea. There is extra information in this
    article that was not covered in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions):
    The best practices from Microsoft in regard to C# exception handling, along with
    code examples and explanations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
