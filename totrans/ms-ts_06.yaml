- en: Chapter 6. Test Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past few years, the popularity of the **Model View Controller** (**MVC**),
    **Model View Presenter** (**MVP**), and **Model View ViewModel** (**MVVM**) patterns
    has given rise to a range of third-party JavaScript libraries, each implementing
    their own version of these patterns. Backbone, for example, could be described
    as an MVP implementation, where the view acts as a presenter. ExtJS 4 introduced
    an MVC pattern to their framework, and Angular could be described as more of an
    MVVM framework. When discussing this group of patterns together, they have been
    described by some as **Model View Whatever** (**MVW**), or **Model View Something**
    (**MV***).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the benefits of this MV* style of writing applications include modularity
    and separation of concerns. This MV* style of building applications also brings
    with it a huge advantage—the ability to write testable JavaScript. Using MV* allows
    us to unit test, integration test, and function test almost all of our beautifully
    hand-crafted JavaScript. This means that we can test our rendering functions to
    ensure that DOM elements are correctly shown on the page. We can also simulate
    button clicks, drop-down selections, and animations. We can also extend these
    tests to page transitions, including login pages and home pages. By building a
    large set of tests for our application, we will gain confidence that our code
    works as expected, and it will allow us to refactor our code at any time.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at Test Driven Development in relation to TypeScript.
    We will discuss some of the more popular testing frameworks, write some unit tests,
    and then discuss test runners and continuous integration techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test Driven Development** (**TDD**) is a development process, or a development
    paradigm, that starts with tests and drives the momentum of a piece of production
    code through these tests. Test Driven Development means asking the question "how
    do I know that I have solved the problem?" instead of just "how do I solve the
    problem?"'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic steps of a test driven approach are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test that fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the test to ensure that it fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the code to make the test pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the test to see that it passes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run all tests to see that the new code does not break any others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Test Driven Development practices is really a mindset. Some developers
    follow this approach and write tests first, while others write their code first
    and their tests afterwards. Then there are some that don't write tests at all.
    If you fall into the last category, then hopefully, the techniques you learn in
    this chapter will help you to get started in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: There are so many excuses out there for not writing unit tests. Some typical
    excuses include phrases like "the test framework was not in our original quote",
    or "it will add 20 percent to the development time", or "the tests are outdated
    so we don't run them anymore". The truth is, though, that in this day and age,
    we cannot afford not to write tests. Applications grow in size and complexity,
    and requirements change over time. An application that has a good suite of tests
    can be modified far more quickly, and will be much more resilient to future requirement
    changes than one that does not have tests. This is when the real cost savings
    of unit testing become apparent. By writing unit tests for your application, you
    are future-proofing it, and ensuring that any change to the code base does not
    break existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: TDD in the JavaScript space adds another layer to our code coverage. Quite often,
    development teams will write tests that target only the server-side logic of an
    application. As an example, in the Visual Studio space, these tests are often
    written to only target the MVC framework of controllers, views, and underlying
    business logic. It has always been fairly difficult to test the client-side logic
    of an application—in other words, the actual rendered HTML and user-based interactions.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript testing frameworks provide us with tools to fill this gap. We can
    now start to unit test our rendered HTML, as well as simulate user interactions
    such as filling in forms and clicking on buttons. This extra layer of testing,
    combined with server-side testing, means that we have a way to unit testing each
    layer of our application—from server-side business logic, through server-side
    page rendering, right through to rendering and user interactions. The ability
    to unit test frontend user interactions is one of the greatest strengths of any
    JavaScript MV* framework. In fact, it could even influence the architectural decisions
    you make when choosing a technology stack.
  prefs: []
  type: TYPE_NORMAL
- en: Unit, integration and acceptance tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated tests can be broken up into three general areas, or types of tests—unit
    tests, integration tests, and acceptance tests. We can also describe these tests
    as either black box or white box tests. White box tests are tests where the internal
    logic or structure of the code under test is known to the tester. Black box tests,
    on the other hand, are tests where the internal design and or logic are not known
    to the tester.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A unit test is typically a white box test where all of the external interfaces
    to a block of code are mocked or stubbed out. If we are testing some code that
    does an asynchronous call to load a block of JSON for example, unit testing this
    code would require mocking out the returned JSON. This technique ensures that
    the object under test is always given a known set of data. When new requirements
    come along, this known set of data can grow and expand, of course. Objects under
    test should be designed to interact with interfaces so that those interfaces can
    be easily mocked or stubbed out in a unit test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration tests are another form of white box tests that allow the object
    under test to run in an environment close to how it would in real code. In our
    preceding example, where some code does an asynchronous call to load a block of
    JSON, an integration test would need to actually call the **Representational State
    Transfer** (**REST**) services that generate the JSON. If this REST service relied
    upon data from a database, then the integration test would need data in the database
    that matched the integration test scenario. If we were to describe a unit test
    as having a boundary around the object under test, then an integration test is
    simply an expansion of this boundary to include dependent objects or services.
  prefs: []
  type: TYPE_NORMAL
- en: Building automated integration tests for your applications will improve the
    quality of your application immensely. Consider the case in the scenario that
    we have been using—where a block of code calls a REST service for some JSON data.
    Someone could easily change the structure of the JSON data that the REST service
    returns. Our unit tests will still pass, as they are not actually calling the
    REST server-side code, but our application will be broken because the returned
    JSON is not what we are expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Without integration tests, these types of errors will only be picked up in later
    stages of manual testing. Thinking about integration tests, implementing specific
    data sets for integration tests, and building them into your test suite will eliminate
    these sorts of bugs early.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Acceptance tests are black box tests, and are generally scenario-based. They
    may incorporate multiple user screens or user interactions in order to pass. These
    tests are also generally carried out by the testing team, as it may require logging
    in to the application, searching for a particular set of data, updating the data,
    and so on. With some planning, we can also automate parts of these acceptance
    tests into an integration suite, as we have the ability in JavaScript to find
    and click buttons, insert data into required fields, or select drop-down items.
    The more acceptance tests a project has, the more robust it will be.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Test Driven Development methodology, every bug that is picked up by a
    manual testing team must result in the creation of new unit, integration, or acceptance
    tests. This methodology will help to ensure that once a bug is found and fixed,
    it never reappears again.
  prefs: []
  type: TYPE_NORMAL
- en: Using continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing unit tests for any application, it quickly becomes important to
    set up a build server and run your tests as part of each source control check
    in. When your development team grows beyond a single developer, using a **Continuous
    Integration** (**CI**) build server becomes imperative. This build server will
    ensure that any code committed to the source control server passes all known unit
    tests, integration tests, and automated acceptance tests. The build server is
    also responsible for labeling a build and generating any deployment artifacts
    that need to be used during deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic steps of a build server would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the latest version of the source code, and increase the build number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile the application on the build server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run any server-side unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package the application for deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the package to a build environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run any server-side integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run any JavaScript unit, integration, and acceptance tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mark the change set and build number as passed or failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the build failed, notify those responsible for breaking it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The build server should fail if any one of the preceding steps fail.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using a build server to run through the preceding steps brings huge benefits
    to any development team. Firstly, the application is compiled on the build server—which
    means that any tools or external libraries used, will need to be installed on
    the build server. This gives your development team the opportunity to document
    exactly what software needs to be installed on a new machine in order to compile
    or run your application.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, a standard set of server-side unit tests can be run before the packaging
    step is attempted. In a Visual Studio project, these would be C# unit tests built
    with any of the popular .NET testing frameworks, such as MSTest, NUnit, or xUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the entire application's packaging step is run. Let's assume for a moment
    that a developer has included a new JavaScript library within the project, but
    forgotten to add it to the Visual Studio solution. In this case, all of the tests
    will run on their local computer, but will break the build because of a missing
    library file. If we were to deploy the site at this stage, running the application
    would result in a 404 error – file not found. By running a packaging step, these
    sort of errors are quickly found.
  prefs: []
  type: TYPE_NORMAL
- en: Once a successful packaging step has been completed, the build server should
    deploy the site to a specially marked build environment. This build environment
    is only used for CI builds, and must therefore have its own database instances,
    web service references, and so on, set up specifically for CI builds. Again, actually
    doing a deployment to a target environment tests the deployment artifacts, as
    well as the deployment process. By setting up a build environment for automated
    package deployment, your team is again able to document the requirements and process
    for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have a full instance of our website up and running on an isolated
    build environment. We can then easily target specific web pages that will run
    our JavaScript tests, and also run integration or automated acceptance tests—directly
    on the full version of the website. In this way, we can write tests that target
    the real-life website REST services, without having to mock out these integration
    points. So in effect, we are testing the application from the ground up. Obviously,
    we may need to ensure that our build environment has a specific set of data that
    can be used for integration testing, or a way of generating the required data
    sets that our integration tests will need.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a build server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of continuous integration build servers out there, including
    TeamCity, Jenkins, and **Team Foundation Server** (**TFS**).
  prefs: []
  type: TYPE_NORMAL
- en: Team Foundation Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TFS needs a specific configuration on its build agents to be able to run instances
    of a web browser. With larger projects, actually running the JavaScript tests
    within a specific browser makes sense, and soon becomes a required step. You may
    need to support more than one browser, and want to run your tests within Firefox,
    Chrome, IE, Safari, or others. TFS also uses **Windows Workflow Foundation** (**WF**)
    to configure build steps, which takes a fair amount of experience and knowledge
    to modify.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jenkins is an open source, free-to-use CI build server. It has wide community
    usage, and many plugins. Installation and configuration of Jenkins is fairly straightforward,
    and Jenkins will allow processes to run browser instances, making it compatible
    with browser-based JavaScript unit tests. Jenkins build steps are command-line-based,
    and it sometimes takes a little nous to configure build steps correctly.
  prefs: []
  type: TYPE_NORMAL
- en: TeamCity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very popular, and very powerful, build server that is free to set up is TeamCity.
    TeamCity allows free installation if you have a small number of developers (<
    20), and a small number of projects (< 20). A full commercial license is only
    around $1,500.00, which makes it affordable for most organizations. Configuring
    build steps in TeamCity is much easier than in Jenkins or TFS, as it uses a wizard
    style of configuration depending on the type of build step you are creating. TeamCity
    also has a rich set of functionality around unit tests, with the ability to show
    graphs per unit test, and is therefore considered best of breed for build servers.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many JavaScript unit testing frameworks available, and also a few
    that have been written in TypeScript. Two of the most popular JavaScript frameworks
    are Jasmine ([http://jasmine.github.io/](http://jasmine.github.io/)) and QUnit
    ([http://qunitjs.com/](http://qunitjs.com/)). If you are writing Node TypeScript
    code, then you might want to have a look at mocha ([https://github.com/mochajs/mocha/wiki](https://github.com/mochajs/mocha/wiki)).
  prefs: []
  type: TYPE_NORMAL
- en: Two of the TypeScript-based testing frameworks are MaxUnit ([https://github.com/KnowledgeLakegithub/MaxUnit](https://github.com/KnowledgeLakegithub/MaxUnit))
    and tsUnit ([https://github.com/Steve-Fenton/tsUnit](https://github.com/Steve-Fenton/tsUnit)).
    Unfortunately, both MaxUnit and tsUnit are newcomers in this space, and therefore
    may not have the features that are inherent in the older, more popular frameworks.
    MaxUnit, for example, did not have any documentation at the time of writing, and
    tsUnit does not have a test reporting framework compatible with CI build servers.
    Over time, these TypeScript frameworks may grow, but seeing how easy it is to
    work with third-party libraries and use DefinitelyTyped declaration files, writing
    unit tests for either QUnit or Jasmine becomes a very simple process.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, we will be using Jasmine 2.0 as our testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section of the chapter, we will create a new Visual Studio project
    that is based on the MVC framework project type. For now, we can just use the
    empty MVC template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine can be installed into our new TypeScript project with the following
    two NuGet packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With these two packages in place, we have the required JavaScript libraries
    and TypeScript definition files in place to begin writing Jasmine tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default installation from NuGet for `JasmineTest` uses the ASP.NET MVC framework,
    and creates a `JasmineController` in the `Controllers` directory. If you are not
    using the MVC framework, or are installing this package in a Node environment,
    then this `JasmineController` should be deleted, as it will cause compilation
    errors. Later in this chapter, we will show how to run integration tests against
    this `JasmineController`, so it's best to leave it in place for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: A simple Jasmine test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jasmine uses a simple format for writing tests. Consider the following TypeScript
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This snippet starts with a Jasmine function called `describe`, which takes two
    arguments. The first argument is the name of the test suite, and the second is
    an anonymous function that contains our test suite. The next line uses the Jasmine
    function named `it`, which also takes two arguments. The first argument is the
    test name, and the second argument is an anonymous function that contains our
    test; in other words, whatever is within the `it` anonymous function is our actual
    test. This test starts by defining a variable, named `undefinedValue`, but does
    not actually set its value. Next, we use the Jasmine function `expect`. Just by
    reading the code of this `expect` statement, we can quickly understand what the
    unit test is doing. It is expecting that the value of the `undefinedValue` variable
    should be defined, that is, not `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: The `expect` function takes a single argument, and returns a Jasmine matcher.
    We can then call any of the Jasmine matcher functions to assess the value passed
    into `expect` against the matcher function. The `expect` keyword is similar to
    the `Assert` keyword in other testing libraries. The format of the `expect` statements
    are human-readable, making Jasmine expectations relatively simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine SpecRunner.html file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to run this test, we will need an HTML page that includes all the
    relevant Jasmine third-party libraries, as well as our test JavaScript file. We
    can create a `SpecRunner.html` file with the following HTML within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This HTML page is simply including the required Jasmine files, `jasmine.css`,
    `jasmine.js`, `jasmine-html.js`, and `boot.js`. The last line includes the compiled
    JavaScript file from our TypeScript test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set this page as our startup page within Visual Studio and run it, we
    should see one failing unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine SpecRunner.html file](img/image_9665OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SpecRunner.html page showing Jasmine output
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent! We are following the test-driven development process by firstly
    creating a failing unit test. The results are exactly what we expect. Our variable
    named `undefinedVariable` has not yet had a value assigned to it, and therefore
    will be `undefined`. If we follow the next step of the TDD process, we should
    write the code that makes the test pass. Updating our test as follows will ensure
    that the test will pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have updated our test name to describe what the test is trying
    to accomplish. To make the test pass, we are simply assigning the value `"test"`
    to our `undefinedValue` variable. Running the `SpecRunner.html` page now will
    show a passing test.
  prefs: []
  type: TYPE_NORMAL
- en: Matchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jasmine has a wide range of matchers that can be used within tests, and also
    allows us to write and include custom matchers. The syntax of Jasmine matchers
    is pretty self-explanatory, as can be seen from the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `.not.` matcher syntax to check that the variable `undefValue`
    is indeed `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This `expect` statement uses the `not.toBe` matcher to ensure that the `definedValue`
    variable is not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `.toBe` matcher to check that the `definedValue` is in
    fact a number with the value of two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `expect` statement is using the `toEqual` matcher to ensure that the `toString`
    function will return the string value of `"2"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are testing for `boolean` values, using the `toBeTruthy` and `toBeFalsy`
    matchers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can also use the `toContain` matcher to parse a string, and test
    whether it contains another string—or use the `.not.` matcher with `toContain`
    for the reverse test.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to head over to the Jasmine website for a full list of matchers, as
    well as details on writing your own custom matchers.
  prefs: []
  type: TYPE_NORMAL
- en: Test startup and teardown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in other testing frameworks, Jasmine provides a mechanism to define functions
    that will run before and after each test, or as a test startup and teardown mechanism.
    In Jasmine, the `beforeEach` and `afterEach` functions act as test startup and
    teardown functions, as can be seen from the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we define a variable named `myString`, at the start of the anonymous
    function. As we know from JavaScript lexical scoping rules, this `myString` variable
    will then be available for use within each of the following `beforeEach`, `afterEach`,
    and `it` functions. Within the `beforeEach` function, this variable is set to
    a string value. Within the `afterEach` function, the variable is tested to see
    that it has been reset to `undefined`. Our expectation within our test checks
    is that this variable has been set via the `beforeEach` function. At the end of
    our test, we then reset the variable to be `undefined`. Note that the `afterEach`
    function is also calling an `expect`—in this case to ensure that the test has
    reset the variable back to `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Jasmine 2.1 version introduces a second version of setup and teardown, called
    `beforeAll` and `afterAll`. At the time of writing this book, though, the versions
    of both the `jasmine.js` and `jasmine.d.ts` files available from NuGet had not
    been updated to v2.1.
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To show how extensible the Jasmine testing library is, JP Castro wrote a very
    short but powerful utility to provide data-driven tests within Jasmine. His blog
    on this topic can be found here ([http://blog.jphpsf.com/2012/08/30/drying-up-your-javascript-jasmine-tests/](http://blog.jphpsf.com/2012/08/30/drying-up-your-javascript-jasmine-tests/)),
    and the GitHub repository can be found here ([https://github.com/jphpsf/jasmine-data-provider](https://github.com/jphpsf/jasmine-data-provider)).
    This simple extension allows us to write intuitive Jasmine tests that take a parameter
    as part of each test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are wrapping our `it` test function within another function called
    `using`. This `using` function takes three parameters: a string description of
    the value set, an array of values, and a function definition. This last function
    definition uses the variable `value`, and will invoke our test using this value.
    Note also in the call to our test, we are changing the test name on the fly, to
    include the `value` parameter that is passed in. This is necessary in order for
    each test to have a unique test name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding solution just needs JP Castro''s Jasmine extension, shown in
    the following JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple function named `using`, that takes the three parameters
    that we mentioned earlier. The function does a simple loop through the array values,
    and passes in each array value to our test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last item that we will need is a TypeScript definition file for the preceding
    `using` function. This is a very simple function declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This TypeScript declaration uses the generic syntax `<T>` to ensure that the
    same type is used for both the second and third arguments. With this declaration
    in place, and the JavaScript `using` function, our code will compile correctly,
    and the tests will run through once for each value in the data array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using spies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jasmine also has a very powerful feature that allows your tests to see if a
    particular function was called, and what parameters it was called with. It can
    also be used to create mocks and stubs. All of this functionality is rolled into
    what Jasmine calls spies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We start with a simple class named `MySpiedClass`, that has a single function
    `testFunction`. This function takes a single argument, and logs the argument to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: Our test starts by creating a new instance of the `MySpiedClass`, and assigns
    it to a variable named `classIntance`. We then create a Jasmine spy on the function
    `testFunction` of the `classInstance` variable. Once we have a spy created, we
    can call the function. Our expectation then checks whether the function was called.
    This is the essence of a spy. Jasmine will "watch" the `testFunction` function
    of the instance of `MySpiedClass` to see whether or not it was called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jasmine spies, by default, block the call to the underlying function. In other
    words, they replace the function you are trying to call with a Jasmine delegate.
    If you need to spy on a function, but still need the body of the function to execute,
    you must specify this behavior using the `.and.callThrough()` fluent syntax.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a very trivial example, spies become very powerful in a number
    of different testing scenarios. Classes or functions that take callback parameters,
    for example, would need a spy to ensure that the callback function was in fact
    invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can test that a callback function was invoked correctly.
    Consider the following TypeScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we define a class named `CallbackClass` that has a single
    function `doCallback`. This `doCallback` function takes an `id` argument of type
    `number`, and also a `callback` function. The `callback` function takes a `string`
    as an argument, and returns `void`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second class that we have defined has a single function named `logValue`.
    This function signature matches the callback function signature required on the
    `doCallback` function. Using Jasmine spies, we can test the logic of the `doCallBack`
    function. This logic creates a string based on the `id` argument that was passed
    in, and then invokes the `callback` function with this string. Our test will need
    to ensure that this string is formatted correctly. Our Jasmine test, then, for
    this can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This test code firstly creates an instance of the class `CallbackClass`, and
    also an instance of the class `DoCallBack`. We then create a spy on the `logValue`
    function of the `DoCallBack` class. We then call the `doCallback` function, passing
    in a value of `1` as the first argument, and the `logValue` function as the second
    argument. Our `expect` statements on the last two lines check that the callback
    function `logValue` was actually called, and also what parameters it was called
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Using spies as fakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another benefit of Jasmine spies is that they can act as fakes. In other words,
    instead of calling a real function, the call is delegated to the Jasmine spy.
    Jasmine also allows spies to return values—which can be useful when generating
    small mocking frameworks. Consider the following tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We start with a class named `ClassToFake` that has a single function `getValue`,
    which returns `2`. Our test then creates an instance of this class. We then call
    the Jasmine `spyOn` function to create a spy on the `getValue` function, and then
    use the `.and.callFake` syntax to attach an anonymous function as a fake function.
    This fake function will return `5` instead of the original `getValue` function
    that would have returned `2`. The test then checks to see that when we call the
    `getValue` function on the `ClassToFake` instance, Jasmine will substitute our
    new fake function for the original `getValue` function, and return `5` instead
    of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of variants of the Jasmine fake syntax, including methods
    to throw errors, or return values—again, please consult the Jasmine documentation
    for a full list of its faking capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The asynchronous nature of JavaScript—made popular by AJAX and jQuery has always
    been one of the drawcards of the language, and is the principle architecture behind
    Node based applications. Let''s have a quick look at an asynchronous class, and
    then describe how we should go about testing it. Consider the following TypeScript
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `MockAsyncClass` has a single function named `executeSlowFunction`, which
    takes a function callback named `success`. Within the `executeSlowFunction` code,
    we are simulating an asynchronous call by using the `setTimeout` function, and
    only calling the success callback after `1000` milliseconds (1 second). This behavior
    is simulating a standard AJAX call (which would use both a `success` and an `error`
    callback), which could take a number of seconds to return—depending on the speed
    of the backend server, or the size of the data packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test for this `executeSlowFunction` may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Firstly, we instantiate an instance of the `MockAsyncClass`, and define a variable
    named `returnedValue`. We then call the `executeSlowFunction` with an anonymous
    function for the `success` callback function. This anonymous function sets the
    value of `returnedValue` to whatever value was passed in from the `MockAsyncClass`.
    Our expectation is that the `returnedValue` should equal `"success"`. If we run
    this test now, however, our test will fail with the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What is happening here, is that because the `executeSlowFunction` is asynchronous,
    JavaScript will not wait until the callback function is called, before executing
    the next line of code. This means that the expectation is being called before
    the `executeSlowFunction` has had a chance to call our anonymous callback function
    (setting the value of `returnedValue`). If you put a breakpoint on the `expect(returnValue).toEqual("success")`
    line, and another breakpoint on the `returnedValue = value` line, you will see
    that the expect line is called first, and the `returnedValue` line is only called
    after a second. This timing issue is what is causing this test to fail. We need
    to somehow have our test wait until the `executeSlowFunction` has invoked the
    callback, before we execute our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the done() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jasmine version 2.0 has introduced a new syntax to help us with these sort
    of asynchronous tests. In any `beforeEach`, `afterEach`, or `it` function, we
    pass an argument named `done`, which is a function, and then invoke it at the
    end of our asynchronous code. Consider the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we have moved the `returnedValue` variable outside of our test, and
    have included a `beforeEach` function to run before our actual test. This `beforeEach`
    function firstly resets the value of `returnValue`, and then sets up the `MockAsyncClass`
    instance. Finally it calls the `executeSlowFunction` on this instance.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the `beforeEach` function takes a parameter named `done`, and then
    calls this `done` function after the `returnedValue = value` line has been called.
    Notice too, that the second parameter to the `it` function now also takes a `done`
    parameter, and invokes this `done` function when the test is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'From the Jasmine documentation: The spec will not start until the `done` function
    is invoked in the call to `beforeEach`, and the spec will not complete until the
    `done` function is called. By default, Jasmine will wait for 5 seconds before
    causing a timeout failure. This can be overridden using the `jasmine.DEFAULT_TIMEOUT_INTERVAL`
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine fixtures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many times, our code is responsible for either reading in, or in most cases
    manipulating DOM elements from JavaScript. This means that any running code that
    relies on a DOM element could fail, if the underlying HTML does not contain the
    correct element or group of elements. Another Jasmine extension library named
    `jasmine-jquery` allows us to inject HTML elements into the DOM before our tests
    execute, and will remove them from the DOM after the test is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing this book, this library was not available on NuGet,
    so we will need to download the `jasmine-jquery.js` file the old-fashioned way,
    and include it in our project. The TypeScript definition file is, however, available
    on NuGet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will need to also update the `.html` file to include both `jquery.js` and
    `jasmine-jquery.js` files in the header script section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a test that injects DOM elements by using the `jasmine-jquery`
    library. Firstly, a class that manipulates a specific DOM element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This `ModifyDomElement` class has a single function, named `setHtml` that is
    using jQuery to find a DOM element with the id of `my_div`. The HTML of this div
    is then set to a simple `"Hello world"` paragraph. Now for our Jasmine test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The test starts by calling the `jasmine-jquery` function `setFixtures`. This
    function will inject the HTML provided as the first string argument directly into
    the DOM. We then create an instance of the `ModifyDomElement` class, and call
    the `setHtml` function to modify the `my_div` element. We are then setting the
    variable `modifiedElement` to the result of a jQuery search in the DOM. If jQuery
    has found the element, then its `length` property will be `> 0`, and we can then
    check to see if, in fact, the HTML was modified.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fixture methods provided by `jasmine-jquery` also allow loading raw HTML
    files off disk, instead of having to write out lengthy string representations
    of HTML. This is also particularly useful if your MV* framework uses HTML file
    snippets. The `jasmine-jquery` library also has utilities for loading JSON from
    disk, and purpose build matchers that work with jQuery. Be sure to check out the
    documentation at ([https://github.com/velesin/jasmine-jquery](https://github.com/velesin/jasmine-jquery)).
  prefs: []
  type: TYPE_NORMAL
- en: DOM events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `jasmine-jquery` library also adds some Jasmine spies to help with DOM
    events. If we were creating a button, either within TypeScript code or within
    HTML, we can ensure that our code correctly responds to DOM events such as `click`.
    Consider the following code and test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we are defining a dummy function named `handle_my_click_div_clicked`,
    which is used within the fixture HTML. Having a closer look at the HTML used in
    the `setFixtures` function call, we are creating a button with an id of `my_click_div`,
    and an `onclick` DOM event that will call our dummy function. We then create a
    spy on this click event for the `my_click_div` div, and on the next line actually
    invoke the click event. Our expectation is using the `jasmine-jquery` matcher
    `toHaveBeenTriggered` to test whether the `onclick` handler was invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jQuery and DOM manipulation provide us with a way of filling in forms, clicking
    on **Submit**, **Cancel**, **OK** buttons, and generally simulating user interaction
    with our application. We can easily write full acceptance or user acceptance tests
    within Jasmine using these techniques—further solidifying our application against
    errors and change.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of ways to run Jasmine tests outside of an actual web page,
    as we have been doing up until this point. Bear in mind, though, that Visual Studio
    does not support debugging TypeScript outside of directly running a web page with
    Internet Explorer. In these cases, you would need to revert to the existing developer
    tools available within your target browser.
  prefs: []
  type: TYPE_NORMAL
- en: Most test runners rely on a simple static HTML page to contain all tests, and
    will fire up a small instance of a web server in order to serve this HTML page
    to the test runner. Some test runners use a configuration file for this purpose,
    and construct a testing environment without the need for HTML at all. This may
    be all well and good for unit tests—where the integration points of your code
    are mocked or stubbed—but this approach does not work well for integration or
    acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: Many real-world web applications, for example, run through some server-side
    business logic to generate HTML for each web request. Authentication logic, for
    example, may redirect the user to a login page, and then use a forms-based auth
    cookie on subsequent page requests or RESTful data requests. In these circumstances,
    running a simple HTML page outside of the actual web application will not work.
    You need to run your tests within a page that is actually hosted along with the
    rest of the web application. Also, if you are trying to add a JavaScript test
    suite to an existing web project, this logic may not be easy to set aside.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, we have focused on using a standard HTML page within our
    web application to run our tests. In an MVC application, for example, we would
    set up a Jasmine controller, with a `Run` function that returned a `SpecRunner.cshtml`
    view page. In fact, the default installation of the NuGet package `JasmineTest`
    will set up these controllers and views as standard templates for us on installation.
  prefs: []
  type: TYPE_NORMAL
- en: Testem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testem is a Node based command-line utility that will continuously run test
    suites against connected browsers when it detects that JavaScript files have been
    modified. Testem is useful for very quick feedback on a number of browsers, and
    also has a continuous integration flag that can be used on build servers. Testem
    is suitable for unit testing. More info can be found at the GitHub repository
    ([https://github.com/airportyh/testem](https://github.com/airportyh/testem)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Testem can be installed via Node with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To run `testem`, simply navigate to the root folder of your test suite in a
    command-line window, and type `testem`. Testem will fire up, start a web server,
    and invite you to connect to it via a browser. In following the screenshots, Testem
    was running at `http://localhost:7357`. You can connect a number of different
    browsers to this URL—and Testem will run the specs it finds against each browser.
    By default, Testem will search the current directory for JavaScript files that
    contain tests, build an HTML page containing these tests and execute them. If
    you already have an HTML page that has your tests included, then this page can
    be specified to Testem via a `testem.yml` config file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This HTML page will also need to include the testem.js file to enable communication
    with the Testem server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testem](img/image_9665OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testem output showing three connected browsers
  prefs: []
  type: TYPE_NORMAL
- en: Testem has a number of powerful configuration options that can be specified
    in the configuration file. Be sure to head over to the GitHub repository for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Testem will not work with ASP.NET MVC controller routes—making it
    unsuitable for integration testing on ASP.NET MVC sites. If you are using an MVC
    controller and view to generate your test suite, such that the URL to your running
    test page is `/Jasmine/Run`, for example—Testem will not work.
  prefs: []
  type: TYPE_NORMAL
- en: Karma
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Karma is a test runner built by the Angular team, and features heavily in the
    Angular tutorials. It is a unit testing framework only, and the Angular team recommends
    end-to-end or integration tests to be built and run via Protractor. Karma, like
    Testem, runs its own instance of a web server in order to serve pages and artifacts
    required by the test suite, and has a large set of configuration options. It can
    also be used for unit tests that do not target Angular. To install Karma to work
    with Jasmine 2.0, we will need to install a few packages using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To run Karma, we will firstly need a config file. By convention, this is generally
    called `karma.conf.js`. A sample `karma` config file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'All config to Karma must be passed in via the `module.exports` and `config.set`
    convention, as seen in the first two lines. The `basePath` parameter specifies
    what the root path is of the web project, and is relevant to the directory that
    the `karma.config.js` file resides in. The `files` array contains list of files
    to be included in the generated HTML file, and can use the `\**\*.js` matching
    algorithms to load an entire directory and sub-directory of JavaScript files.
    The `autoWatch` parameter keeps karma running in the background, watching files
    for changes, in a similar manner to Testem. Karma also allows for a variety of
    browsers to be specified—each with their own launcher plugins. Finally, the `junitReporter`
    is being used in this example to report tests back to a Jenkins CI server. Once
    this config file is in place, simply run karma start as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Karma](img/image_9665OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Karma output from a simple test
  prefs: []
  type: TYPE_NORMAL
- en: Protractor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Protractor is a Node based test runner that tackles end-to-end testing. It
    was originally designed for Angular apps, but can be used with any website. Unlike
    Testem and Karma, Protractor is able to browse to a specific page and then interact
    with the page from JavaScript—making it suitable for integration testing. It can
    check metadata properties such as the page title, or fill in forms and click on
    buttons, and allow the backend server to redirect to different pages. Protractor
    documentation can be found here ([https://github.com/angular/protractor](https://github.com/angular/protractor)),
    and can be installed with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We will get to running Protractor a little later, but first, let's discuss the
    engine that Protractor uses in order to automate web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Using Selenium
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Selenium is a driver for web browsers. It allows programmatic remote control
    of web browsers, and can be used to create automated tests in Java, C#, Python,
    Ruby, PHP, Perl, and even JavaScript. Protractor uses Selenium under the covers
    to control web browser instances. To install the Selenium server for use with
    Protractor, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the Selenium server, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, Selenium will report that the server has started, and will
    detail the address of the Selenium server. Check your output for a line similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need Java to be installed on your machine in order to run the Selenium
    server, as the webdriver-manager script uses Java to start the Selenium server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the server is running, we will need a configuration file for Protractor
    (named `protractor.conf.js`) that includes some settings. At this stage, all we
    need is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These protractor settings simply set the `seleniumAddress` to the address of
    the Selenium server, as reported earlier. We also have a `specs` property, which
    is set to look for any `.js` file within the same directory as the `protractor.conf.js`,
    and treat them as test specs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the simplest of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Our test starts by opening the page at `/Jasmine/Run`. Note that this is an
    ASP.NET MVC path that uses the default Jasmine controller, and returns `Views/Jasmine/SpecRunner.cshtml`.
    This controller and view was included with the Jasmine NuGet package that we installed
    earlier. Make sure that you can navigate to this page in your browser before trying
    to execute the Protractor tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Protractor with the configuration file will now execute our previous
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And will produce the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two things that must be running here in order for this test to work:'
  prefs: []
  type: TYPE_NORMAL
- en: The Selenium server must be running in a command prompt, such that `localhost:4444/wd/hub`
    is a valid address, and does not return 404 errors
  prefs: []
  type: TYPE_NORMAL
- en: The developer ASP.NET website must be up and running so that `localhost:64277/Jasmine/Run`
    hits our Visual Studio Jasmine controller, and renders an HTML page
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that we are conducting integration tests in a test page that is
    rendered using ASP.NET MVC routes. We want to use the standard MVC controller,
    action, view method of generating an HTML page, as we may need to execute some
    server-side logic to setup pre-requisites before the integration tests can start.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in a real-world application, it is often necessary to run server-side
    logic or use server-side HTML rendering for integration tests. For instance, most
    applications will require some sort of authentication before allowing calls to
    REST services via JavaScript. Implementing an [Authorize] attribute to your RESTful
    API controllers is the logical solution. Unfortunately, calling any of these REST
    controllers from a normal HTML page will return 401 (Unauthorized) errors. One
    way around this is to use an MVC controller to serve the test HTML page, and then
    to set up a dummy forms authentication ticket in the server-side code. Once this
    is in place, any calls to RESTful services from this page will already be authenticated
    with a dummy user profile. This technique can also be used to run integration
    tests where users have different roles and different permissions based on their
    authentication credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating integration tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To simulate this sort of integration test page, let's reuse the `JasmineController`
    that was installed with the Jasmine NuGet package. As mentioned earlier, an integration
    test will need to hit the backend server-side logic (in this case the Jasmine
    MVC controller), and then render a server-side-generated HTML page to the browser
    (in this case the `SpecRunner.cshtml` view). This simulation means that we are
    relying on the server-side MVC framework to resolve the `/Jasmine/Run` URL, generate
    an HTML page on the fly, and return this generated HTML page to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `SpecRunner.cshtml` file (the MVC template for generating the HTML) is
    very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This ASP.NET MVC view page is using Razor syntax, and is not based on a master
    page—as the `Layout` parameter at the top of the file is set to `null`. The page
    includes a number of links in the `head` element, including `jasmine.css`, `jasmine.js`,
    `jasmine-html.js`, and `boot.js`. These are the required Jasmine files that we
    have seen before. After this, we have just included the `SpecHelper.js`, `PlayerSpec.js`,
    `Player.js`, and `Song.js` files from the `jasmine-samples` directory. Running
    this page by navigating to the `/Jasmine/Run` URL will run the sample tests included
    with Jasmine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simulating integration tests](img/image_9665OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the default/Jasmine/Run web page
  prefs: []
  type: TYPE_NORMAL
- en: Our simulated integration test page in this sample just runs a couple of standard
    Jasmine tests. Using a server-side generated HTML page now allows us to use dummy
    authentication, if needed. With dummy authentication in place, we can start to
    write Jasmine tests to target secure RESTful data services.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will have a look at building and testing some Backbone
    models and collections, and will work through further examples of integration
    tests that actually request data from the server. For the time being, though,
    we have a sample page that is generated server-side, and that can be used as the
    base for further integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Test pages like these should never be packaged in **User Acceptance Testing**
    (**UAT**) or release configurations. In ASP.NET, we can simply use a compiler
    directive such as the `#if DEBUG … #endif` around our controller classes to exclude
    them from any other build configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Detailed test results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So we now have the beginnings of an integration test page that shows us the
    results of our Jasmine test run. This HTML page is good for a quick overview,
    but we would now like some more detailed information on each test so that we can
    report back to our build server; how long each test took, and its `success` /
    `fail` state.
  prefs: []
  type: TYPE_NORMAL
- en: For these reporting purposes, Jasmine includes the ability to use custom test
    reporters, over and above the standard `HtmlReporter` that is the Jasmine default.
    The GitHub project, jasmine-reporters ([https://github.com/larrymyers/jasmine-reporters](https://github.com/larrymyers/jasmine-reporters)),
    has a number of prebuilt test reporters that cater for the most popular build
    servers. Unfortunately, this project does not have a corresponding NuGet package,
    so we will need to install the `.js` files within our project manually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An alternative method of managing JavaScript libraries is the **Bower** package
    manager. Bower is a Node based command-line utility that is similar to NuGet,
    but deals only with JavaScript libraries and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now modify our HTML page to include the TeamCity reporter. Firstly,
    modify the `SpecRunner.cshtml` file to include a `script` tag for the `teamcity_reporter.js`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create a simple script within the `body` tag to register this
    reporter with Jasmine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This script simply creates an instance of the `TeamCityReporter` class, and
    assigns it to a variable named `tcapi` on the `window` object. The second line
    of this script adds this reporter to the Jasmine environment. Running our page
    now will produce TeamCity results logged to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detailed test results](img/image_9665OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jasmine output with TeamCity messages logged to the console
  prefs: []
  type: TYPE_NORMAL
- en: Logging test results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now need to access this output, and find a way to report it back to the Protractor
    instance. Unfortunately, accessing the console's log through Selenium will only
    report critical errors, so the preceding TeamCity reporter output will be unavailable.
    A quick look around the `teamcity_reporter.js` code reveals that all `console.log`
    output messages use the `tclog` function to build a string, and then call `console.log`
    with this string. As we have an instance of our `TeamCityReporter` available to
    us, we can easily store these logged messages into an array, and then read through
    them once the test suite has finished running. Some quick modifications to the
    JavaScript file `teamcity_reporter.js` are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just under the constructor function for the `TeamCityReporter` class, create
    an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can modify the `tclog` function to return the string that is it building:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, each call to `tclog` can push the returned string to this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `TeamCityReporter` has a `logItems` array, we will need some method
    of finding out when the test suite has finished, and we can then loop through
    the array of `logItems`, and attach them to the DOM. Once it is in the DOM, our
    Protractor instance can use Selenium to read these values and report back to the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a small class named `JasmineApiListener` that accepts an instance
    of the `TeamCityReporter` class to do all this work for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our `JasmineApiListener` class has two private variables. The `_outputComplete`
    variable is a boolean flag indicating that the test suite has completed, and that
    the results have been written to the DOM. The `_tcReporter` variable holds an
    instance of the `TeamCityReporter` class, which is passed through in the `constructor`.
    The `constructor` simply sets the flag `_outputComplete` to `false`, creates a
    variable named `self`, and sets up a simple timer on a three-second interval.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `self` variable is a necessary scoping step in order to access the correct
    instance of `this` inside the anonymous function that is passed to `setInterval`.
  prefs: []
  type: TYPE_NORMAL
- en: The body of our anonymous function is where all the goodness takes place. Firstly,
    we are checking the `_tcReporter.finished` property on the `TeamCityReporter`
    instance to tell whether or not the suite has completed. If it has, and we have
    not yet appended our results to the DOM `(!self._outputComplete)`, then we can
    access the `logItems` array and create DOM elements for each of these entries.
    These elements are attached as `<div class="logentry">…</div>` elements, as children
    of the parent `<div id="teamCityReporterLog">` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding code is using the native `document.getElementById` and
    `appendChild` syntax for DOM manipulation, and not a jQuery-style syntax to avoid
    having a dependency on jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now modify the script within the `SpecRunner.cshtml` view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first script is the updated version of what we have been using previously,
    which now creates an instance of our `JasmineApiListener` class, and passes the
    instance of the `TeamCityReporter` class within the constructor. We have also
    added two `<div>` tags. The first one, `teamCityResultsDone`, is a flag to indicate
    that we have completed writing the TeamCity results to the DOM, and the second
    `teamCityReporterLog` is the parent `div` to hold all of the child `logentry`
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fire up this page now, we should see our tests run through, and then
    three seconds later, the DOM will be updated with the results that we have read
    from the `TeamCityReporter` array, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging test results](img/image_9665OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Jasmine output being logged to the DOM
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way of logging the results of our tests to the DOM, we can
    update our Protractor based Selenium tests to relate these results to our build
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Finding page elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, Protractor can be used to run integration tests, as
    well as automated acceptance tests. A Protractor test can browse to a login page,
    find the login username textbox, send a value such as "`testuser1"` to this textbox,
    and then repeat the process for a password. The same test code can then be used
    to click on the **Login** button, which will submit the form to our server login
    controller. Our test can then ensure that the server responds with the correct
    redirect to our main page. This main page may contain multiple buttons, grids,
    images, side panels and navigation elements. Ideally, we would want to write acceptance
    tests for each of these page elements.
  prefs: []
  type: TYPE_NORMAL
- en: Protractor uses locators to find these elements within our DOM. These elements
    can be found by their CSS selectors, by `id`, or, if using Angular, by model or
    binding. Building the correct strings for use in these selectors can sometimes
    be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium provides us with a useful Firefox extension to help when writing Selenium
    based tests - the Selenium IDE ([http://docs.seleniumhq.org/projects/ide/](http://docs.seleniumhq.org/projects/ide/)).
    With this extension installed within Firefox, we can use the IDE to help find
    elements on the page.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of how to use this extension, let's continue with our work on
    the Jasmine reporter that we have writing, and find the `teamCityResultsDone`
    DOM element that we have been using to flag a completed test suite. The code and
    process we use to find this DOM element is the same code and process that we would
    use to find other page elements on a login page, for example, or any other page
    that we were driving through Selenium.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we fire up our `/Jasmine/Run` page using Firefox, we can now click on the
    Selenium IDE button on the top right of the browser to launch the Selenium IDE.
    This IDE uses commands to record interactions against a web page, and shows this
    list of commands in the main window. Right-click on the command window, and select
    **Insert new command**. In the command name text box give the new command a name—something
    like `find done element`. Once a command has a name, the two buttons next to the
    target input box become enabled, and we can click on **Select**. We can then drag
    our mouse over the web page, and click on the text **done** at the top of the
    page. Notice how the command has automatically filled in the **Target** element
    in the Selenium IDE. The **Target** input box has now become a drop-down list,
    and we can use this list to show the Selenium selector syntax for our `teamCityResultsDone`
    `div`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding page elements](img/image_9665OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FireFox Selenium IDE
  prefs: []
  type: TYPE_NORMAL
- en: Working with page elements in Jasmine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to find an HTML page element using the Selenium IDE, we
    can start writing Selenium commands to query the page elements of our Jasmine
    tests. Remember that there are two elements we need to find.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we need to find the `teamCityResultsDone` `div`, and wait for the text
    of this element to be updated. This div is only updated when our Jasmine test
    suite is complete, and our tests results have been included in the DOM. Once our
    test suite has been flagged as complete, we then need to loop through each of
    the `logentry` `divs` that are child elements of the `teamCityReporterLog` `div`.
    These `logentry` `divs` will contain the detailed results each of our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The changes needed in our protractor tests are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Our test begins by browsing to the `/Jasmine/Run` page, and expects this page
    title to contain `"Jasmine"`, as we have seen previously. We are then using the
    `findElement` function from Selenium to find an element on the page. This function
    is passed a JavaScript object with the `id` set to `teamCityResultsDone`—and is
    using the select syntax that we saw earlier in the Selenium IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We are then calling the `wait` function to wait for the text of the `teamCityResultsDone`
    element to be updated (that is, its `length` is `> 0` ), and set a 60-second timeout
    for this `wait` function. Remember that our `JasmineApiListener` code will set
    the text value of this div to `"done"` when we have finished updating the DOM,
    which will effectively then trigger the `wait` function.
  prefs: []
  type: TYPE_NORMAL
- en: We are then using the `afterEach` function to loop through the `logentry` `divs`.
    Instead of finding the parent element, we are now using the `findElements` Selenium
    function to find multiple elements on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the Selenium selector syntax that we are using for these `divs`: `by.css("#teamCityReporterLog
    > div.logentry")`. This `by.css` function is using CSS selector syntax to find
    our elements, and the input string corresponds to the CSS selector that the Selenium
    IDE shows. We can therefore use the Selenium IDE to help us find the correct CSS
    selector syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Selenium uses a fluent syntax for most of its API functions. The call to the
    `findElements`, therefore, is followed by a `.then` function, which will pass
    the elements it has found in an array to the anonymous function. We use this anonymous
    function with the `.then( (elements) => { .. })` syntax. Within this function,
    we are looping through each element of the elements array, and calling the `.getText`
    Selenium function. Again, this `getText` function provides a fluent syntax, which
    allows us to write another anonymous function to use the text value returned,
    as seen in the line `elements[i].getText().then( (textValue ) => { … });`. This
    function is simply logging the `textValue` to the protractor console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running our Protractor test will now report our test results to the command
    line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with page elements in Jasmine](img/image_9665OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Protractor logging test results to the console
  prefs: []
  type: TYPE_NORMAL
- en: Mission accomplished. We are now using Protractor to browse to a server-generated
    HTML page that runs a set of Jasmine tests. We are then using Selenium to find
    elements on the page, waiting for DOM updates, and then loop through an array
    of elements in order to log our Jasmine test results to the protractor console.
  prefs: []
  type: TYPE_NORMAL
- en: These Selenium functions, such as `browser.driver.get`, `findElements`, and
    `wait` are all part of the rich set of functionality that Selenium provides to
    work with DOM elements. Be sure to head over to the Selenium documentation for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a mechanism to fire up an integration test page, run a Jasmine test
    suite, report these test results to the DOM, and then read these results and log
    them to the Protractor console. It is then a simple matter to set up a build step
    within a TeamCity build server to execute protractor, and record these test results
    during the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored Test Driven Development from the ground up.
    We have discussed the theory of TDD, explored the differences between unit, integration,
    and acceptance tests, and had a look at what a CI build server process would look
    like. We then explored Jasmine as a testing framework, learned how to write tests,
    use expectations and matchers, and also explored Jasmine extensions to help with
    data-driven tests and DOM manipulation through fixtures. Finally, we had a look
    at test runners, and built a Protractor based test framework to drive web pages
    through Selenium, and report the results back to a build server. In the next chapter,
    we will explore the TypeScript module syntax, in order to use both CommonJS and
    AMD JavaScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  prefs: []
  type: TYPE_NORMAL
