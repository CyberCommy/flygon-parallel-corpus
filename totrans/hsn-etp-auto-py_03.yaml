- en: Setting Up the Network Lab Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a fair idea of how to write and develop Python scripts, the building
    blocks to creating programs. We will now move on to understanding why automation
    is an important topic in today's network, and then we will build our network automation
    lab using one of the popular pieces of software, called EVE-NG, which helps us
    to virtualize network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: When and why to automate the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen scraping versus API automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why to use Python for network automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The future of network automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting ready: installing EVE-NG'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an enterprise network topology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the EVE-NG installation steps and how to create
    our lab environment. The installation will be done over VMware Workstation, VMware
    ESXi, and finally Red Hat KVM, so you should be familiar with the virtualization
    concept and have one of the hypervisors up and running prior to lab setup.
  prefs: []
  type: TYPE_NORMAL
- en: When and why to automate the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network automation is increasing all over the network world. However, it's really
    important to understand when and why to automate your network. For example, if
    you're an administrator of a few network devices (three or four switches) and
    you don't execute so many tasks on them regularly, then you might not need full
    automation for them. Actually, the time needed to write and develop a script and
    test and troubleshoot it might be greater than the time to do a simple task manually.
    On the other hand, if you're responsible for a big enterprise network that contains
    multi-vendor platforms and you always execute repetitive tasks, then it's highly
    recommended to have a script to automate it.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need automation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several reasons for why automation is important for networks today:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lower costs**: Using automation solutions (either developed in-house or purchased
    from vendors) will reduce network operation complexity and the time required to
    provision, configure, and operate network devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business continuity**: Automation will reduce human error during service
    creation over current infrastructure, and hence, allow businesses to reduce the
    service **time to market** (**TTM**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business agility**: Most network tasks are repeated and by automating them,
    you will increase productivity and drive business innovation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Correlation**: Building a solid automation workflow allows the network and
    systems administrators to perform root cause analysis faster and increases the
    possibility of solving the problem by correlating multiple events together'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen scraping versus API automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a long period of time, the CLI was the only access method available to manage
    and operate network devices. Operators and administrators used to have SSH and
    Telnet to access the network terminal for configuration and troubleshooting. Python,
    or any programming language, has two approaches to communicating with devices.
    The first one is to use SSH or telnet the same as before and get the information,
    then process it. This method is called **screen scraping** and requires libraries
    that will be able to establish a connection to the device and execute a command
    directly on the terminal, and other libraries to process the returned information
    to extract useful data from it. This method often requires knowledge of additional
    parsing languages, such as regular expressions, to match the data pattern from
    the output and extract useful data from it.
  prefs: []
  type: TYPE_NORMAL
- en: The second method is called an **Application Programmable Interface** (**API**)
    and this method depends entirely on sending a structured request using REST or
    SOAP protocols to the device and returning the output, also in structured format,
    encoded in JSON or XML. The time needed for processing the returned data in this
    method is quite small compared to the first method; however, the API requires
    additional configuration on network devices to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Why use Python for network automation?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a pretty well-structured and easy programming language available today
    and targets many areas in technology, web and internet development, data mining
    and visualization, desktop GUI, analysis, game building, and automation testing;
    that's why it's called a *general purpose language.*
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there are three reasons to choose Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readability and ease of use**: When you develop using Python, you actually
    find yourself writing in English. Many keywords and program flows inside Python
    are structured to have readable statements. Also, Python doesn''t require `;`
    or curly braces to start and end blocks, which gives Python a shallow learning
    curve. Finally, Python has some optional rules, called PEP 8, that tell Python
    developers how to format their program to have readable code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can configure PyCharm to take care of these rules and check whether your
    code violates them or not by going to Settings | Inspections | PEP 8 coding style
    violation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Libraries**: This is the real power of Python: libraries and packages. Python
    has a wide range of libraries in many areas. Any Python developer can easily develop
    a Python library and upload it online to make it available to other developers.
    Libraries are uploaded to a website called PyPI ([https://pypi.Python.org/pypi](https://pypi.python.org/pypi))
    and linked to a GitHub repository. When you want to download the library to your
    PC, then you use a tool called `pip` to connect to PyPI and download it locally.
    Network vendors such as Cisco, Juniper, and Arista developed libraries to facilitate
    access to their platforms. Most vendors are pushing to make their libraries easy
    to use and require minimum installation and configuration steps to retrieve useful
    information from devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Powerful**: Python tries to minimize the number of steps required to reach
    the end result. For example, to print hello world using Java, you will need this
    block of code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, in Python, the whole block is written in one line to print it, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Combining all these reasons together leads to making Python the de facto standard
    for automation and the first choice for vendors when it comes to automating network
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: The future of network automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For a long period of time, network automation only meant developing a script
    using a programming language such as Perl, TcL, or Python in order to execute
    tasks on different network platforms. This approach is known as **script-driven
    network automation**. But as the network becomes more complex and more service-oriented,
    new types of automation were required and started to appear, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software-defined network automation**: Network devices will have only a forwarding
    plane, while the control plane is implemented and created using an external software
    called an **SDN controller**. The benefit of this approach is there will be a
    single point of contact for any network changes and the SDN controller can accept
    those change requests from other software, such as an external portal, through
    well-implemented northbound interfaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High-level orchestration**: This approach requires software called an orchestrator
    that integrates with SDN controllers and enables the creation of network service
    models using languages, such as YANG, that abstract the service from the underlying
    devices that will run over it. Also, an orchestrator can integrate with a **Virtual
    Infrastructure Manager** (**VIM**) such as OpenStack and vCenter, in order to
    manage virtual machines as a part of network service modeling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy-based networking**: In this type of automation, you describe what
    you want to have in the network and the system has all the details to figure out
    how to implement it in the underlying devices. This allows software engineers
    and developers to implement changes in the network and describe their application''s
    needs in declarative policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network lab setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will start building our networking lab on a popular platform called
    EVE-NG. You could, of course, use a physical node to implement the topology, but
    a virtualized environment gives us an isolated and sandboxed environment to test
    many different configurations, plus the flexibility to add/remove nodes to/from
    the topology with a few clicks. Also, we can have multiple snapshots to our configuration
    so we can revert back to any scenario at any time.
  prefs: []
  type: TYPE_NORMAL
- en: EVE-NG (formerly known as UNetLab) is one of the most popular choices in network
    emulation. It supports a wide range of virtualized nodes from different vendors.
    There's another option, which is GNS3, but, as we will see during this chapter
    and the next one, EVE-NG provides many features that make it a solid choice for
    network modeling.
  prefs: []
  type: TYPE_NORMAL
- en: 'EVE-NG comes in three editions: Community, Pro, and Learning Center. We will
    use the Community edition as it contains all the features that we will need during
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready – installing EVE-NG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'EVE-NG Community edition came with two options, OVA and ISO. The first option
    is to use OVA, which gives you the minimum installation steps required, given
    that you already have VMware Player/Workstation/Fusion, or VMware ESXi, or Red
    Hat KVM. The second option is to install it directly over a bare metal server
    without a hypervisor, this time using Ubuntu 16.06 LTS OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The ISO option, however, requires some advanced skills in Linux to prepare the
    machine itself and import the installation repositories into the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle VirtualBox doesn't support the hardware acceleration needed by EVE-NG,
    so it's better to install it either in VMware or KVM.
  prefs: []
  type: TYPE_NORMAL
- en: First, head to [http://www.eve-ng.net/index.php/downloads/eve-ng](http://www.eve-ng.net/index.php/downloads/eve-ng)
    to download the latest version of EVE-NG, then import it into your hypervisor.
    I dedicated 8 GB of memory and four vCPUs to the created machine, but you can
    add additional resources to it. In the next section, we will see how to import
    the downloaded image to hypervisors and configure each one.
  prefs: []
  type: TYPE_NORMAL
- en: Installation on VMware Workstation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will import the downloaded EVE-NG OVA image into
    VMware Workstation. OVA-based images contain files that describe the virtual machine
    in terms of hard disk, CPU, and RAM values. You can later modify these numbers
    after importing them:'
  prefs: []
  type: TYPE_NORMAL
- en: Open VMware workstation and from File, choose Open to import the OVA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After completing the import process, right-click on the newly created machine
    and choose Edit Settings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase the number of processors to 4 and the memory allocated to 8 GB (again,
    you could add more if you have the resources but this setting will be enough for
    our lab).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure the Virtualize Intel VT-x/EPT or AMD-V/RVI checkbox is enabled. This
    option instructs VMware workstation to pass the virtualization flags to the guest
    OS (nested virtualization):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, it''s recommended to expand the hard disk by adding additional space
    to the existing hard disk in order to have enough space to host multiple images
    from vendors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A message will appear after expanding the disk, indicating that the operation
    was done successfully and you need to follow some procedures in the guest operating
    system to merge the new space with the old one. Luckily for us, we don''t need
    to do that as EVE-NG will merge any new space found in the hard disk with the
    old one during system boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installation over VMware ESXi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VMware ESXi is a good example of a type 1 hypervisor that runs directly on
    the system. Sometimes they''re called bare-metal hypervisors, and they provide
    many features compared to type 2 hypervisors, such as VMware workstation/Fusion
    or VirtualBox:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the vSphere client and connect to your ESXi server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the File menu, choose Deploy OVF Template
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the path for the downloaded OVA image and click Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Accept all the default settings suggested by the hypervisor till you land on
    the final page, Ready to Complete, and click on Finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ESXi will start to deploy the image on the hypervisor, and later you can change
    its settings and add more resources to it, as we did before in VMware workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Installation over Red Hat KVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to convert the downloaded OVA image to QCOW2 format, which is supported
    by KVM. Follow these steps to convert one format into another. We will need a
    special utility called `qemu-img` available inside the `qemu-utils` package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Untar the downloaded OVA to extract the VMDK file (the HDD of the image):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `qemu-utils` tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, convert the VMDK to QCOW2\. It may take a few minutes for the conversion
    to be complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have our own `qcow2` file ready to be hosted inside the Red Hat
    KVM. Open the KVM console and choose the Import existing disk image option from
    the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, choose the path of the converted image and click on Forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing EVE-NG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you import the image to the hypervisor and start it, you will be asked
    to provide some information to complete the installation. First, you will be greeted
    with the EVE logo as an indication that the machine has been successfully imported
    over the hypervisor and it is ready to start the boot phase:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide the root password that will be used for SSHing to the EVE machine.
    By default, it will be `eve`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00052.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide the hostname that will be used as a name inside Linux:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00053.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide a domain name for the machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00054.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose to configure networking with the static method. This will ensure the
    IP address given will be persistent even after machine reboot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00055.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, provide the static IP address from a range that is reachable from
    your network. This IP will be used to SSH to EVE and upload vendor images to the
    repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../images/00056.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to access the EVE-NG GUI, you need to open a browser and go to `http://<server_ip>`.
    Please note `server_IP` is what we used during the installation steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00057.jpeg)The default username for the GUI is `admin` and the
    password is `eve`, while the default username for SSH is `root` and the password
    is what was provided during the installation steps.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing EVE-NG client pack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client pack that comes with EVE-NG allows us to choose which application
    is used when you telnet or SSH to the device (either PuTTY or SecureCRT) and set
    up Wireshark for remote packet captures between links. Also, it facilitates work
    on RDP- and VNC-based images. First, you need to download the client pack to your
    PC from [http://eve-ng.net/index.php/downloads/windows-client-side-pack](http://eve-ng.net/index.php/downloads/windows-client-side-pack),
    then extract the file to `C:\Program Files\EVE-NG`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00058.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The extracted files contain many scripts written in Windows batch scripting
    (`.bat`) to configure the machine that will be used to access EVE-NG. You will
    find scripts that configure the default Telnet/SSH client and another one for
    Wireshark and the VNC. The software sources are also available inside the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00059.jpeg)If you are using a Linux desktop such as Ubuntu or
    Fedora, then you could use this excellent project from GitHub to get the client
    pack: [https://github.com/SmartFinn/eve-ng-integration](https://github.com/SmartFinn/eve-ng-integration).'
  prefs: []
  type: TYPE_NORMAL
- en: Loading network images into EVE-NG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All network images obtained from vendors should be uploaded to `/opt/unetlab/addons/qemu`.
    EVE-NG support QEMU-based images and Dynamics images, and also iOL (iOS On Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you get an image from a vendor, you should create a directory inside `/opt/unetlab/addons/qemu`
    and upload the image to that directory; then, you should execute this script to
    fix the permission of the uploaded image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Building an enterprise network topology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our base lab setup, we will simulate an enterprise network that has four
    switches and one router that act as a gateway to outside networks. Here is the
    IP schema that will be used for each node:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Node name** | **IP** |'
  prefs: []
  type: TYPE_TB
- en: '| GW | `10.10.88.110` |'
  prefs: []
  type: TYPE_TB
- en: '| Switch1 | `10.10.88.111` |'
  prefs: []
  type: TYPE_TB
- en: '| Switch2 | `10.10.88.112` |'
  prefs: []
  type: TYPE_TB
- en: '| Switch3 | `10.10.88.113` |'
  prefs: []
  type: TYPE_TB
- en: '| Switch4 | `10.10.88.114` |'
  prefs: []
  type: TYPE_TB
- en: Our Python script (or Ansible playbook) will be hosted on an external Windows
    PC that connects to the management of each device.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by choosing the IOSv image that was already uploaded to EVE and
    add four switches to the topology. Right-click on any empty space in the topology
    and from the drop-down menu named Add a new object, choose to add a Node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see two Cisco images colored blue as indication that they were successfully
    added to the available images inside the EVE-NG library and mapped to the corresponding
    template. Choose Cisco vIOS L2 to add Cisco switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Increase the Number of nodes to add to 4 and click OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, you will see four switches added to the topology; repeat this again and
    add the router, but this time choose Cisco vIOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting nodes together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, start to connect the nodes with each other while the nodes are offline,
    and repeat for each node till you finish connecting all of them inside the topology;
    then, start the lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00064.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The final view after adding IP addresses and some custom shapes to the topology
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, our topology is ready and should be loaded with basic configuration. I
    used the following snippet as a configuration base for any Cisco-IOS device that
    enabled SSH and telnet and configured the username for access. Notice that there
    are some parameters surrounded with `{{ }}`. We will discuss them in the next
    chapter when we generate a golden configuration using a Jinja2 template but, for
    now, replace them with `hostname` and the management IP address for each device
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the different types of network automation
    available today and why we chose Python to be our primary tool in network automation.
    Also, we learned how to install EVE-NG over different hypervisors and platforms,
    how to provide the initial configuration, and how to add our network images to
    the images catalog. Then, we added different nodes and connected them together
    to create our network enterprise lab.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start building our Python scripts that automate
    different tasks in the topology using different Python libraries, such as telnetlib,
    Netmiko, Paramiko, and Pexpect.
  prefs: []
  type: TYPE_NORMAL
