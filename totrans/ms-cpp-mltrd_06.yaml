- en: Debugging Multithreaded Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, one's code would work properly the first time around, and contain no
    hidden bugs that are waiting to crash the application, corrupt data, or cause
    other issues. Realistically, this is, of course, impossible. Thus it is that tools
    were developed which make it easy to examine and debug multithreaded applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at a number of them including a regular debugger
    as well as some of the tools which are part of the Valgrind suite, specifically,
    Helgrind and DRD. We will also look at profiling a multithreaded application in
    order to find hotspots and potential issues in its design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Valgrind suite of tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Helgrind and DRD tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting the Helgrind and DRD analysis results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling an application, and analyzing the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to start debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, one would test and validate one's code every time one has reached a
    certain milestone, whether it's for a singular module, a number of modules, or
    the application as a whole. It's important to ascertain that the assumptions one
    makes match up with the ultimate functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Especially, with multithreaded code, there's a large element of coincidence
    in that a particular error state is not guaranteed to be reached during each run
    of the application. Signs of an improperly implemented multithreaded application
    may result in symptoms such as seemingly random crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Likely the first hint one will get that something isn't correct is when the
    application crashes, and one is left with a core dump. This is a file which contains
    the memory content of the application at the time when it crashed, including the
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: This core dump can be used in almost the same fashion as running a debugger
    with the running process. It is particularly useful to examine the location in
    the code at which we crashed, and in which thread. We can also examine memory
    contents this way.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best indicators that one is dealing with a multithreading issue is
    when the application never crashes in the same location (different stack trace),
    or when it always crashes around a point where one performs mutual exclusion operations,
    such as manipulating a global data structure.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, we'll first take a more in-depth look at using a debugger for
    diagnosing and debugging before diving into the Valgrind suite of tools.
  prefs: []
  type: TYPE_NORMAL
- en: The humble debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of all the questions a developer may have, the question of *why did my application
    just crash?* is probably among the most important. This is also one of the questions
    which are most easily answered with a debugger. Regardless of whether one is live
    debugging a process, or analyzing the core dump of a crashed process, the debugger
    can (hopefully) generate a back trace, also known as a stack trace. This trace
    contains a chronological list of all the functions which were called since the
    application was started as one would find them on the stack (see [Chapter 2](part0026.html#OPEK0-1ab5991b318547348fc444437bdacb24),
    *Multithreading Implementation on the Processor and OS*, for details on how a
    stack works).
  prefs: []
  type: TYPE_NORMAL
- en: The last few entries of this back trace will thus show us in which part of the
    code things went wrong. If the debug information was compiled into the binary,
    or provided to the debugger, we can also see the code at that line along with
    the names of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Even better, since we're looking at the stack frames, we can also examine the
    variables within that stack frame. This means the parameters passed to the function
    along with any local variables and their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have the debug information (symbols) available, one has to compile
    the source code with the appropriate compiler flags set. For GCC, one can select
    a host of debug information levels and types. Most commonly, one would use the
    `-g` flag with an integer specifying the debug level attached, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-g0`: produces no debug information (negates `-g`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-g1`: minimal information on function descriptions and external variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-g3`: all information including macro definitions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This flag instructs GCC to generate debug information in the native format for
    the OS. One can also use different flags to generate the debug information in
    a specific format; however, this is not necessary for use with GCC's debugger
    (GDB) as well as with the Valgrind tools.
  prefs: []
  type: TYPE_NORMAL
- en: Both GDB and Valgrind will use this debug information. While it's technically
    possible to use both without having the debug information available, that's best
    left as an exercise for truly desperate times.
  prefs: []
  type: TYPE_NORMAL
- en: GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most commonly used debuggers for C-based and C++-based code is the
    GNU Debugger, or GDB for short. In the following example, we'll use this debugger
    due to it being both widely used and freely available. Originally written in 1986,
    it's now used with a wide variety of programming languages, and has become the
    most commonly used debugger, both in personal and professional use.
  prefs: []
  type: TYPE_NORMAL
- en: The most elemental interface for GDB is a command-line shell, but it can be
    used with graphical frontends, which also include a number of IDEs such as Qt
    Creator, Dev-C++, and Code::Blocks. These frontends and IDEs can make it easier
    and more intuitive to manage breakpoints, set up watch variables, and perform
    other common operations. Their use is, however, not required.
  prefs: []
  type: TYPE_NORMAL
- en: On Linux and BSD distributions, gdb is easily installed from a package, just
    as it is on Windows with MSYS2 and similar UNIX-like environments. For OS X/MacOS,
    one may have to install gdb using a third-party package manager such as Homebrew.
  prefs: []
  type: TYPE_NORMAL
- en: Since gdb is not normally code signed on MacOS, it cannot gain the system-level
    access it requires for normal operation. Here one can either run gdb as root (not
    recommended), or follow a tutorial relevant to your version of MacOS.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging multithreaded code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there are two ways to use a debugger, either by starting
    the application from within the debugger (or attaching to the running process),
    or by loading a core dump file. Within the debugging session, one can either interrupt
    the running process (with *Ctrl*+*C*, which sends the `SIGINT` signal), or load
    the debug symbols for the loaded core dump. After this, we can examine the active
    threads in this frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see how after sending the `SIGINT` signal to the
    application (a Qt-based application running on OS X), we request the list of all
    threads which exist at this point in time along with their thread number, ID,
    and the function which they are currently executing. This also shows clearly which
    threads are likely waiting based on the latter information, as is often the case
    of a graphical user interface application like this one. Here we also see that
    the thread which is currently active in the application as marked by the asterisk
    in front of its number (thread 1).
  prefs: []
  type: TYPE_NORMAL
- en: We can also switch between threads at will by using the `thread <ID>` command,
    and move `up` and `down` between a thread's stack frames. This allows us to examine
    every aspect of individual threads.
  prefs: []
  type: TYPE_NORMAL
- en: When full debug information is available, one would generally also see the exact
    line of code that a thread is executing. This means that during the development
    stage of an application, it makes sense to have as much debug information available
    as possible to make debugging much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the dispatcher code we looked at in [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24),
    *Threading Synchronization and Communication*, we can set a breakpoint to allow
    us to examine the active threads as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the above command line output, we start GDB with the name of
    the application we wish to debug as a parameter, here from a Bash shell under
    Windows. After this, we can set a breakpoint here, using the filename of the source
    file and the line we wish to break at after the (gdb) of the gdb command line
    input. We select the first line after the loop in which the requests get sent
    to the dispatcher, then run the application. This is followed by the list of the
    new threads which are being created by the dispatcher, as reported by GDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we wait until the breakpoint is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Upon reaching the breakpoint, an *info threads* command lists the active threads.
    Here we can clearly see the use of condition variables where a thread is waiting
    in `ntdll!ZwWaitForMultipleObjects()`. As covered in [Chapter 3](part0045.html#1AT9A0-1ab5991b318547348fc444437bdacb24),
    *C++ Multithreading APIs*, this is part of the condition variable implementation
    on Windows using its native multithreading API.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a back trace (`bt` command), we see that the current stack for
    thread 1 (the current thread) is just one frame, only for the main method, since
    we didn't call into another function from this starting point at this line.
  prefs: []
  type: TYPE_NORMAL
- en: Back traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During normal application execution, such as with the GUI application we looked
    at earlier, sending `SIGINT` to the application can also be followed by the command
    to create a back trace like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this preceding code, we can see the execution of thread ID 1 from its creation,
    through the entry point (main). Each subsequent function call is added to the
    stack. When a function finishes, it is removed from the stack. This is both a
    benefit and a disadvantage. While it does keep the back trace nice and clean,
    it also means that the history of what happened before the last function call
    is no longer there.
  prefs: []
  type: TYPE_NORMAL
- en: If we create a back trace with a core dump file, not having this historical
    information can be very annoying, and possibly make one start on a wild goose
    chase as one tries to narrow down the presumed cause of a crash. This means that
    a certain level of experience is required for successful debugging.
  prefs: []
  type: TYPE_NORMAL
- en: In case of a crashed application, the debugger will start us on the thread which
    suffered the crash. Often, this is the thread with the problematic code, but it
    could be that the real fault lies with code executed by another thread, or even
    the unsafe use of variables. If one thread were to change the information that
    another thread is currently reading, the latter thread could end up with garbage
    data. The result of this could be a crash, or even worse--corruption, later in
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case scenario consists of the stack getting overwritten by, for example,
    a wild pointer. In this case, a buffer or similar on the stack gets written past
    its limit, thus erasing parts of the stack by filling it with new data. This is
    a buffer overflow, and can both lead to the application crashing, or the (malicious)
    exploitation of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic analysis tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although the value of a debugger is hard to dismiss, there are times when one
    needs a different type of tool to answer questions about things such as memory
    usage, leaks, and to diagnose or prevent threading issues. This is where tools
    such as those which are part of the Valgrind suite of dynamic analysis tools can
    be of great help. As a framework for building dynamic analysis tools, the Valgrind
    distribution currently contains the following tools which are of interest to us:'
  prefs: []
  type: TYPE_NORMAL
- en: Memcheck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helgrind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memcheck is a memory error detector, which allows us to discover memory leaks,
    illegal reads and writes, as well as allocation, deallocation, and similar memory-related
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Helgrind and DRD are both thread error detectors. This basically means that
    they will attempt to detect any multithreading issues such as data races and incorrect
    use of mutexes. Where they differ is that Helgrind can detect locking order violations,
    and DRD supports detached threads, while also using less memory than Helgrind.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major limitation with dynamic analysis tools is that they require tight integration
    with the host operating system. This is the primary reason why Valgrind is focused
    on POSIX threads, and does not currently work on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Valgrind website (at [http://valgrind.org/info/platforms.html](http://valgrind.org/info/platforms.html))
    describes the issue as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Windows is not under consideration because porting to it would require so
    many changes it would almost be a separate project. (However, Valgrind + Wine
    can be made to work with some effort.) Also, non-open-source OSes are difficult
    to deal with; being able to see the OS and associated (libc) source code makes
    things much easier. However, Valgrind is quite usable in conjunction with Wine,
    which means that it is possible to run Windows programs under Valgrind with some
    effort."'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, this means that Windows applications can be debugged with Valgrind
    under Linux with some difficulty, but using Windows as the OS won't happen any
    time soon.
  prefs: []
  type: TYPE_NORMAL
- en: Valgrind does work on OS X/macOS, starting with OS X 10.8 (Mountain Lion). Support
    for the latest version of macOS may be somewhat incomplete due to changes made
    by Apple, however. As with the Linux version of Valgrind, it's generally best
    to always use the latest version of Valgrind. As with gdb, use the distro's package
    manager, or a third-party one like Homebrew on MacOS.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alternatives to the Valgrind tools on Windows and other platforms include the
    ones listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Type** | **Platforms** | **License** |'
  prefs: []
  type: TYPE_TB
- en: '| Dr. Memory | Memory checker | All major platforms | Open source |'
  prefs: []
  type: TYPE_TB
- en: '| gperftools (Google) | Heap, CPU, and call profiler | Linux (x86) | Open source
    |'
  prefs: []
  type: TYPE_TB
- en: '| Visual Leak Detector | Memory checker | Windows (Visual Studio) | Open Source
    |'
  prefs: []
  type: TYPE_TB
- en: '| Intel Inspector | Memory and thread debugger | Windows, Linux | Proprietary
    |'
  prefs: []
  type: TYPE_TB
- en: '| PurifyPlus | Memory, performance | Windows, Linux | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: '| Parasoft Insure++ | Memory and thread debugger | Windows, Solaris, Linux,
    AIX | Proprietary |'
  prefs: []
  type: TYPE_TB
- en: Memcheck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memcheck is the default Valgrind tool when no other tool is specified in the
    parameters to its executable. Memcheck itself is a memory error detector capable
    of detecting the following types of issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing memory outside of allocated bounds, overflowing of the stack, and
    accessing previously freed memory blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of undefined values, which are variables which have not been initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improper freeing of heap memory including repeatedly freeing blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mismatched use of C- and C++-style memory allocations as well as array allocators
    and deallocators (`new[]` and `delete[]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlapping source and destination pointers in functions such as `memcpy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The passing of an invalid (for example, negative) value as the size parameter
    to `malloc` or similar functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory leaks; that is, heap blocks without any valid reference to them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a debugger or a simple task manager, it's practically impossible to detect
    issues such as the ones given in the preceding list. The value of Memcheck lies
    in being able to detect and fix issues early in development, which otherwise can
    lead to corrupted data and mysterious crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Basic use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Memcheck is fairly easy. If we take the demo application we created in
    [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24), *Thread Synchronization
    and Communication*, we know that normally we start it using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To run Valgrind with the default Memcheck tool while also logging the resulting
    output to a log file, we would start it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command, we will log Memcheck's output to a file called `dispatcher.log`,
    and also enable the full checking of memory leaks, including detailed reporting
    of where these leaks occur, using the available debug information in the binary.
    By also reading the variable information (`--read-var-info=yes`), we get even
    more detailed information on where a memory leak occurred.
  prefs: []
  type: TYPE_NORMAL
- en: One cannot log to a file, but unless it's a very simple application, the produced
    output from Valgrind will likely be so much that it probably won't fit into the
    terminal buffer. Having the output as a file allows one to use it as a reference
    later as well as search it using more advanced tools than what the terminal usually
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this, we can examine the produced log file''s contents as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that we have a total of three memory leaks. Two are from allocations
    in the `dispatcher` class on lines 38 and 40:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And the other one is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also see a leak from an allocation at line 60 in `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although there is nothing wrong with these allocations themselves, if we trace
    them during the application life cycle, we notice that we never call `delete`
    on these objects. If we were to fix these memory leaks, we would need to delete
    those `Request` instances once we're done with them, and clean up the `Worker`
    and `thread` instances in the destructor of the `dispatcher` class.
  prefs: []
  type: TYPE_NORMAL
- en: Since in this demo application the entire application is terminated and cleaned
    up by the OS at the end of its run, this is not really a concern. For an application
    where the same dispatcher is used in a way where new requests are being generated
    and added constantly, while possibly also dynamically scaling the number of worker
    threads, this would, however, be a real concern. In this situation, care would
    have to be taken that such memory leaks are resolved.
  prefs: []
  type: TYPE_NORMAL
- en: Error types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memcheck can detect a wide range of memory-related issues. The following sections
    summarize these errors and their meanings.
  prefs: []
  type: TYPE_NORMAL
- en: Illegal read / illegal write errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These errors are usually reported in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the preceding error message tells one whether it was an invalid
    read or write access. The next few lines will be a back trace detailing the location
    (and possibly, the line in the source file) from which the invalid read or write
    was performed, and from where that code was called.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last line will detail the type of illegal access that occurred,
    such as the reading of an already freed block of memory.
  prefs: []
  type: TYPE_NORMAL
- en: This type of error is indicative of writing into or reading from a section of
    memory which one should not have access to. This can happen because one accesses
    a wild pointer (that is, referencing a random memory address), or due to an earlier
    issue in the code which caused a wrong memory address to be calculated, or a memory
    boundary not being respected, and reading past the bounds of an array or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, when this type of error is reported, it should be taken highly seriously,
    as it indicates a fundamental issue which can lead not only to data corruption
    and crashes, but also to bugs which can be exploited by others.
  prefs: []
  type: TYPE_NORMAL
- en: Use of uninitialized values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In short, this is the issue where a variable's value is used without the said
    variable having been assigned a value. At this point, it's likely that these contents
    are just whichever bytes were in that part of RAM which just got allocated. As
    a result, this can lead to unpredictable behavior whenever these contents are
    used or accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When encountered, Memcheck will throw errors similar to these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular series of errors was caused by the following small bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, we never initialize our variable, which
    would be set to just any random value. If one is lucky, it'll be set to zero,
    or an equally (hopefully) harmless value. This code shows just how any of our
    uninitialized variables enter into library code.
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not the use of uninitialized variables is harmful is hard to say,
    and depends heavily on the type of variable and the affected code. It is, however,
    far easier to simply assign a safe, default value than it is to hunt down and
    debug mysterious issues which may be caused (at random) by an uninitialized variable.
  prefs: []
  type: TYPE_NORMAL
- en: For additional information on where an uninitialized variable originates, one
    can pass the `-track-origins=yes` flag to Memcheck. This will tell it to keep
    more information per variable, which will make the tracking down of this type
    of issue much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Uninitialized or unaddressable system call values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever a function is called, it''s possible that uninitialized values are
    passed as parameters, or even pointers to a buffer which is unaddressable. In
    either case, Memcheck will log this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding log was generated by this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Much like the general use of uninitialized values as detailed in the previous
    section, the passing of uninitialized, or otherwise dodgy, parameters is, at the
    very least, risky, and in the worst case, a source of crashes, data corruption,
    or worse.
  prefs: []
  type: TYPE_NORMAL
- en: Illegal frees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An illegal free or delete is usually an attempt to repeatedly call `free()`
    or `delete()` on an already deallocated block of memory. While not necessarily
    harmful, this would be indicative of bad design, and would absolutely have to
    be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: It can also occur when one tries to free a memory block using a pointer which
    does not point to the beginning of that memory block. This is one of the primary
    reasons why one should never perform pointer arithmetic on the original pointer
    one obtains from a call to `malloc()` or `new()`, but use a copy instead.
  prefs: []
  type: TYPE_NORMAL
- en: Mismatched deallocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Allocation and deallocation of memory blocks should always be performed using
    matching functions. This means that when we allocate using C-style functions,
    we deallocate with the matching function from the same API. The same is true for
    C++-style allocation and deallocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Briefly, this means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If we allocate using `malloc`, `calloc`, `valloc`, `realloc,` or `memalign`,
    we deallocate with `free`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we allocate with new, we deallocate with `delete`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we allocate with `new[]`, we deallocate with `delete[]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing these up won't necessarily cause problems, but doing so is undefined
    behavior. The latter type of allocating and deallocating is specific to arrays.
    Not using `delete[]` for an array that was allocated with `new[]` likely leads
    to a memory leak, or worse.
  prefs: []
  type: TYPE_NORMAL
- en: Overlapping source and destination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of error indicates that the pointers passed for a source and destination
    memory block overlap (based on expected size). The result of this type of bug
    is usually a form of corruption or system crash.
  prefs: []
  type: TYPE_NORMAL
- en: Fishy argument values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For memory allocation functions, Memcheck validates whether the arguments passed
    to them actually make sense. One example of this would be the passing of a negative
    size, or if it would far exceed a reasonable allocation size: for example, an
    allocation request for a petabyte of memory. Most likely, these values would be
    the result of a faulty calculation earlier in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Memcheck would report this error like in this example from the Memcheck manual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here it was attempted to pass the value of -3 to `malloc`, which obviously doesn't
    make a lot of sense. Since this is obviously a nonsensical operation, it's indicative
    of a serious bug in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leak detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important thing to keep in mind for Memcheck''s reporting of memory
    leaks is that a lot of reported *leaks* may in fact not be leaks. This is reflected
    in the way Memcheck reports any potential issues it finds, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Definitely lost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indirectly lost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly lost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of the three possible report types, the **Definitely lost** type is the only
    one where it is absolutely certain that the memory block in question is no longer
    reachable, with no pointer or reference remaining, which makes it impossible for
    the application to ever free the memory.
  prefs: []
  type: TYPE_NORMAL
- en: In case of the **Indirectly lost** type, we did not lose the pointer to these
    memory blocks themselves, but, the pointer to a structure which refers to these
    blocks instead. This could, for example, occur when we directly lose access to
    the root node of a data structure (such as a red/black or binary tree). As a result,
    we also lose the ability to access any of the child nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, **Possibly lost** is the catch-all type where Memcheck isn't entirely
    certain whether there is still a reference to the memory block. This can happen
    where interior pointers exist, such as in the case of particular types of array
    allocations. It can also occur through the use of multiple inheritance, where
    a C++ object uses self-reference.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in the basic use section for Memcheck, it's advisable to
    always run Memcheck with `--leak-check=full` specified to get detailed information
    on exactly where a memory leak was found.
  prefs: []
  type: TYPE_NORMAL
- en: Helgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of Helgrind is to detect issues with synchronization implementations
    within a multithreaded application. It can detect wrongful use of POSIX threads,
    potential deadlock issues due to wrong locking order as well as data races--the
    reading or writing of data without thread synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Basic use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start Helgrind on our application in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Similar to running Memcheck, this will run the application and log all generated
    output to a log file, while explicitly using all available debugging information
    in the binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the application, we examine the generated log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After the initial basic information about the application and the Valgrind
    version, we are informed that the root thread has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thread is created by the dispatcher and logged. Next we get the first
    warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding warning, we are being told by Helgrind about a conflicting
    read of size 1 between thread IDs 1 and 2\. Since the C++11 threading API uses
    a fair amount of templates, the trace can be somewhat hard to read. The essence
    is found in these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This corresponds to the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: "The only variable of size 1 in these lines of code is the Boolean variable\
    \ `ready`. Since this is a Boolean variable, we know that it is an atomic operation\
    \ (see [\uFEFFChapter 8](part0169.html#515F20-1ab5991b318547348fc444437bdacb24),\
    \ *Atomic Operations - Working with the Hardware*, for details). As a result,\
    \ we can ignore this warning."
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we get another warning for this thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the first warning, this also refers to a Boolean variable--here,
    the `running` variable in the `Worker` instance. Since this is also an atomic
    operation, we can again ignore this warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following this warning, we get a repeat of these warnings for other threads.
    We also see this warning repeated a number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This warning is triggered by not having the use of standard output synchronized
    between threads. Even though the logging function of this demo application uses
    a mutex to synchronize the text logged by worker threads, we also write to standard
    output in an unsafe manner in a few locations.
  prefs: []
  type: TYPE_NORMAL
- en: This is relatively easy to fix by using a central, thread-safe logging function.
    Even though it's unlikely to cause any stability issues, it will very likely cause
    any logging output to end up as a garbled, unusable mess.
  prefs: []
  type: TYPE_NORMAL
- en: Misuse of the pthreads API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Helgrind detects a large number of errors involving the pthreads API, as summarized
    by its manual, and listed next:'
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking an invalid mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlocking a not-locked mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlocking a mutex held by a different thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying an invalid or a locked mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursively locking a non-recursive mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deallocation of memory that contains a locked mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing mutex arguments to functions expecting reader-writer lock arguments,
    and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure of a POSIX pthread function fails with an error code that must be handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A thread exits whilst still holding locked locks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `pthread_cond_wait` with a not-locked mutex, an invalid mutex, or one
    locked by a different thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inconsistent bindings between condition variables and their associated mutexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid or duplicate initialization of a pthread barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialization of a pthread barrier on which threads are still waiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destruction of a pthread barrier object which was never initialized, or on which
    threads are still waiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting on an uninitialized pthread barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to this, if Helgrind itself does not detect an error, but the pthreads
    library itself returns an error for each function which Helgrind intercepts, an
    error is reported by Helgrind as well.
  prefs: []
  type: TYPE_NORMAL
- en: Lock order problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lock order detection uses the assumption that once a series of locks have been
    accessed in a particular order, that is the order in which they will always be
    used. Imagine, for example, a resource that's guarded by two locks. As we saw
    with the dispatcher demonstration from [Chapter 4](part0076.html#28FAO0-1ab5991b318547348fc444437bdacb24),
    *Thread Synchronization and Communication*, we use two mutexes in its Dispatcher
    class, one to manage access to the worker threads, and one to the request instances.
  prefs: []
  type: TYPE_NORMAL
- en: In the correct implementation of that code, we always make sure to unlock one
    mutex before we attempt to obtain the other, as there's a chance that another
    thread already has obtained access to that second mutex, and attempts to obtain
    access to the first, thus creating a deadlock situation.
  prefs: []
  type: TYPE_NORMAL
- en: While useful, it is important to realize that there are some areas where this
    detection algorithm is, as of yet, imperfect. This is mostly apparent with the
    use of, for example, condition variables, which naturally uses a locking order
    that tends to get reported by Helgrind as *wrong*.
  prefs: []
  type: TYPE_NORMAL
- en: The take-away message here is that one has to examine these log messages and
    judge their merit, but unlike straight misuse of the multithreading API, whether
    or not the reported issue is a false-positive or not is far less clear-cut.
  prefs: []
  type: TYPE_NORMAL
- en: Data races
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In essence, a data race is when two more threads attempt to read or write to
    the same resource without any synchronization mechanism in place. Here, only a
    concurrent read and write, or two simultaneous writes, are actually harmful; therefore,
    only these two types of access get reported.
  prefs: []
  type: TYPE_NORMAL
- en: In an earlier section on basic Helgrind usage, we saw some examples of this
    type of error in the log. There it concerned the simultaneous writing and reading
    of a variable. As we also covered in that section, Helgrind does not concern itself
    with whether a write or read was atomic, but merely reports a potential issue.
  prefs: []
  type: TYPE_NORMAL
- en: Much like with lock order problems, this again means that one has to judge each
    data race report on its merit, as many will likely be false-positives.
  prefs: []
  type: TYPE_NORMAL
- en: DRD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DRD is very similar to Helgrind, in that it also detects issues with threading
    and synchronization in the application. The main ways in which DRD differs from
    Helgrind are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: DRD uses less memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRD doesn't detect locking order violations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRD supports detached threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generally, one wants to run both DRD and Helgrind to compare the output from
    both with each other. Since a lot of potential issues are highly non-deterministic,
    using both tools generally helps to pinpoint the most serious issues.
  prefs: []
  type: TYPE_NORMAL
- en: Basic use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting DRD is very similar to starting the other tools--we just have to specify
    our desired tool like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After the application finishes, we examine the generated log file's contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding summary basically repeats what we saw with the Helgrind log. We
    see the same data race report (conflicting store), which we can safely ignore
    due to atomics. For this particular code at least, the use of DRD did not add
    anything we didn't already know from using Helgrind.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, it's always a good idea to use both tools just in case one tools
    spots something which the other didn't.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DRD will detect the following errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Data races
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock contention (deadlocks and delays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misuse of the pthreads API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the third point, this list of errors detected by DRD, according to its
    manual, is very similar to that of Helgrind:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing the address of one type of synchronization object (for example, a mutex)
    to a POSIX API call that expects a pointer to another type of synchronization
    object (for example, a condition variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to unlock a mutex that has not been locked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to unlock a mutex that was locked by another thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to lock a mutex of type `PTHREAD_MUTEX_NORMAL` or a spinlock recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destruction or deallocation of a locked mutex
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a signal to a condition variable while no lock is held on the mutex
    associated with the condition variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `pthread_cond_wait` on a mutex that is not locked, that is, locked by
    another thread or that has been locked recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating two different mutexes with a condition variable through `pthread_cond_wait`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destruction or deallocation of a condition variable that is being waited upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destruction or deallocation of a locked reader-writer synchronization object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to unlock a reader-writer synchronization object that was not locked
    by the calling thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to recursively lock a reader-writer synchronization object exclusively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to pass the address of a user-defined reader-writer synchronization
    object to a POSIX threads function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to pass the address of a POSIX reader-writer synchronization object
    to one of the annotations for user-defined reader-writer synchronization objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinitialization of a mutex, condition variable, reader-writer lock, semaphore,
    or barrier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destruction or deallocation of a semaphore or barrier that is being waited upon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing synchronization between barrier wait and barrier destruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting a thread without first unlocking the spinlocks, mutexes, or reader-writer
    synchronization objects that were locked by that thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing an invalid thread ID to `pthread_join` or `pthread_cancel`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned earlier, helpful here is the fact that DRD also supports detached
    threads. Whether locking order checks are important depends on one's application.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 threads support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DRD manual contains this section on C++11 threads support.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use the `c++11` class `std::thread` you will need to do the
    following to annotate the `std::shared_ptr<>` objects used in the implementation
    of that class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the start of a common header or at the start of each
    source file, before any C++ header files are included:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Download the GCC source code and from the source file `libstdc++-v3/src/c++11/thread.cc`,
    copy the implementation of the `execute_native_thread_routine()` and `std::thread::_M_start_thread()`
    functions into a source file that is linked with your application. Make sure that
    also in this source file the `_GLIBCXX_SYNCHRONIZATION_HAPPENS_*()` macros are
    defined properly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One might see a lot of false positives when using DRD with an application that
    uses the C++11 threads API, which would be fixed by the preceding *fix*.
  prefs: []
  type: TYPE_NORMAL
- en: However, when using GCC 5.4 and Valgrind 3.11 (possibly, using older versions
    too) this issue does not seem to be present any more. It is, however, something
    to keep in mind when one suddenly sees a lot of false positives in one's DRD output
    while using the C++11 threads API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at how to approach the debugging of multithreaded
    applications. We explored the basics of using a debugger in a multithreaded context.
    Next, we saw how to use three tools in the Valgrind framework, which can assist
    us in tracking down multithreading and other crucial issues.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can take applications written using the information in the
    preceding chapters and analyze them for any issues which should be fixed including
    memory leaks and improper use of synchronization mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take all that we have learned, and look at some
    best practices when it comes to multithreaded programming and developing in general.
  prefs: []
  type: TYPE_NORMAL
