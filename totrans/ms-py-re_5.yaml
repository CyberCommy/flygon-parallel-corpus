- en: Chapter 5. Performance of Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we worried about learning how to leverage a feature or obtain
    a result without caring too much about how fast the process would be. Our only
    goals were correctness and readability.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to steer towards a completely different concern—performance.
    However, we will find that often an improvement in performance will result in
    degradation of readability. When we are modifying something to make it faster,
    we are probably making it easier for the machine to understand, and therefore,
    we are probably compromising on human readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'On December 4, 1974, Donald Knuth, the author of the famous book *The Art of
    Computer Programming*, wrote the paper *Structured Programming* with `go-to` statements.
    This well-known quote is extracted from the paper:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Programmers waste enormous amounts of time thinking about, or worrying about,
    the speed of noncritical parts of their programs, and these attempts at efficiency
    actually have a strong negative impact when debugging and maintenance are considered.
    We should forget about small efficiencies, say about 97% of the time: premature
    optimization is the root of all evil. Yet we should not pass up our opportunities
    in that critical 3%."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That said, we should be careful about what we optimize. Probably, for a regular
    expression used to validate an e-mail address of a form, we should have more interest
    in readability than in performance. On the other hand, if we are writing a regular
    expression to be used in batch processing of huge historical files, we should
    be more interested in the performance.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used approach for optimization is to first write, then measure,
    and only then optimize that critical 3 percent. So, in this chapter, first we
    are going to learn how to measure and analyze the regular expressions, and then
    follow on with optimization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking regular expressions with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to benchmark our regex, we're going to measure the time a regex takes
    to execute. It's important to test them with different inputs, because with small
    inputs almost every regex is fast enough. However, with longer ones it can be
    a completely different beast, as we will see later in the section *Backtracking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re going to create a small function to help us with this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can test a regex using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Python comes with a built-in profiler [http://docs.python.org/2/library/profile.html](http://docs.python.org/2/library/profile.html)
    that we can also use to measure the time and the number of calls, among other
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Benchmarking regular expressions with Python](graphics/3156OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Profiling output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another useful technique that is going to help when you want to
    see what''s going on under the hook of your regex. It''s something that we''ve
    seen before in [Chapter 2](ch02.html "Chapter 2. Regular Expressions with Python"),
    *Regular Expressions with Python*, the flag DEBUG. Recall that it gives us information
    about how the pattern is compiled. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see three `max_repeat` conditions from `1` to `4294967295`, two
    of them inside another `max_repeat`. Think about them as nested loops, as you're
    probably thinking this is a bad smell. In fact, this will lead you to a **catastrophic
    backtracking**, something that we'll see later.
  prefs: []
  type: TYPE_NORMAL
- en: The RegexBuddy tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the different tools available for better productivity while writing regular
    expressions, **RegexBuddy** ([http://www.regexbuddy.com/](http://www.regexbuddy.com/))
    by Just Great Software Co. Ltd. is outstanding.
  prefs: []
  type: TYPE_NORMAL
- en: The mastermind behind Just Great Software is Jan Goyvaerts, the same person
    who is behind **Regular-Expressions.info** ([http://www.regular-expressions.info/](http://www.regular-expressions.info/)),
    one of the most well-known references on the Internet for regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With RegexBuddy, we can use a visual interface for building, testing, and debugging
    regular expressions. The debug feature is almost unique, and provides a great
    mechanism to understand how the regular expression engine is working behind the
    scenes. In the following screenshot, we can see RegexBuddy debugging the execution
    of a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The RegexBuddy tool](graphics/3156OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: RegexBuddy debugging a regular expression
  prefs: []
  type: TYPE_NORMAL
- en: It does have other features, such as a library of commonly used regular expressions
    and a code generator for different programming environments.
  prefs: []
  type: TYPE_NORMAL
- en: Although it has a couple of downsides, its license is proprietary and the only
    build available is for Windows. However, the execution on Linux using the **wine
    emulator** is supported.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Python regex engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `re` module uses a backtracking regular expression engine; although, in
    the very well-known book *Mastering Regular Expressions* by *Jeffrey E. F. Friedl*,
    it is classified as **Nondeterministic Finite Automata** (**NFA**) type. Also,
    according to *Tim Peters* ([https://mail.python.org/pipermail/tutor/2006-January/044335.html](https://mail.python.org/pipermail/tutor/2006-January/044335.html)),
    the module is not purely NFA.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common characteristics of the algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports "lazy quantifiers" such as `*?`, `+?`, and `??`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It matches the first coincidence, even though there are longer ones in the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This also means that order is important.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm tracks only one transition at one step, which means that the engine
    checks one character at a time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backreferences and capturing parentheses are supported.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backtracking** is the ability to remember the last successful position so
    that it can go back and retry if needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the worst case, complexity is exponential O(*C^n*). We'll see this later
    in *Backtracking*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backtracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we''ve mentioned before, backtracking allows going back and repeating the
    different paths of the regular expression. It does so by remembering the last
    successful position. This applies to alternation and quantifiers. Let''s see an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backtracking](graphics/3156OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Backtracking
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, the regex engine tries to match one
    character at a time until it fails, and then starts again with the next path it
    can retry.
  prefs: []
  type: TYPE_NORMAL
- en: The regex used in the figure is a perfect example of the importance of how the
    regex is built. In this case, the expression can be rebuilt as `spa(in|niard)`
    so that the regex engine doesn't have to go back to the start of the string in
    order to retry the second alternative.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to something called a catastrophic backtracking; a well-known
    problem with backtracking that can give you several problems ranging from slow
    regex to a crash with a stack overflow.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, you can see that the behavior grows not only with the
    input but also with different paths in the regex, so the algorithm can be exponential
    O(*C^n*). With this in mind, it's easy to understand why we can end up with a
    stack overflow. The problem arises when the regex fails to match the string. Let's
    benchmark a regex with a technique we've seen previously so that we can understand
    the problem better.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s try a simple regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the text we''re trying to match is always going to fail as
    there is no `c` at the end. Let''s test it with different inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of this regex looks as if it is quadratic. But why? What's happening
    here? The problem is that `(a+)` starts greedy, so it tries to get as many `a`
    characters as possible. After that, it fails to match the `c`, that is, it backtracks
    to the second `a`, and continues consuming `a` characters until it fails to match
    `c`. And then, it tries the whole process again (backtracks) starting with the
    second `a` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example, in this case with an exponential behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the behavior is exponential, which can lead to catastrophic
    scenarios. Finally, let''s see what happens when the regex has a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Optimization recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following sections, we will find a number of recommendations that could
    be applied to improve regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: The best tool will always be common sense, and common sense will need to be
    used even while following these recommendations. It has to be understood when
    the recommendation is applicable and when it is not. For instance, the recommendation
    **don't be greedy** cannot be used in all the cases.
  prefs: []
  type: TYPE_NORMAL
- en: Reuse compiled patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned in [Chapter 2](ch02.html "Chapter 2. Regular Expressions with
    Python"), *Regular Expressions with Python*, that to use a regular expression
    we have to convert it from its string representation to a compiled form as `RegexObject`.
  prefs: []
  type: TYPE_NORMAL
- en: This compilation takes some time. If we are using the rest of the module operations
    instead of using the compile function to avoid the creation of the `RegexObject`,
    we should understand that the compilation is executed anyway and a number of compiled
    `RegexObject` are cached automatically.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we are compiling, that cache won't back us. Every single compile
    execution will consume an amount of time that perhaps could be negligible for
    a single execution, but it's definitely relevant if many executions are performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the difference between reusing and not reusing the compiled patterns
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Extract common parts in alternation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alternation is always a performance risk in regular expressions. When using
    them in a sort of NFA implementation, in Python, we should extract any common
    part outside of the alternation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we have `/(Hello`![Extract common parts in alternation](graphics/inlinemedia.jpg)`World|Hello`![Extract
    common parts in alternation](graphics/inlinemedia.jpg)`Continent|Hello`![Extract
    common parts in alternation](graphics/inlinemedia.jpg)`Country,)/`,we could easily
    extract `Hello`![Extract common parts in alternation](graphics/inlinemedia.jpg)
    with the following expression: `/Hello`![Extract common parts in alternation](graphics/inlinemedia.jpg)`(World|Continent|Country)/`.
    This would enable our engine to just check `Hello`![Extract common parts in alternation](graphics/inlinemedia.jpg)
    once, and it will not go back to recheck for each possibility. In the following
    example, we can see the difference on execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Shortcut to alternation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ordering in alternation is relevant, each of the different options present in
    the alternation will be checked one by one, from left to right. This can be used
    in favor of performance.
  prefs: []
  type: TYPE_NORMAL
- en: If we place the more likely options at the beginning of the alternation, more
    checks will mark the alternation as matched sooner.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, we know that the more common colors of cars are white and black.
    If we are writing a regular expression to accept some colors, we should put white
    and black first as those are more likely to appear. We can frame the regex like
    this `/(white|black|red|blue|green)/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of the elements, if they have the very same odds of appearing,
    it could be favorable to put the shortest ones before the longer ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Use non-capturing groups when appropriate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Capturing groups will consume some time for each group defined in an expression.
    This time is not very important, but it is still relevant if we are executing
    a regular expression several times.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we use groups but we might not be interested in the result, for instance,
    when using alternation. If that is the case, we can save some execution time of
    the engine by marking that group as non-capturing, for example, `(?:person|company)`.
  prefs: []
  type: TYPE_NORMAL
- en: Be specific
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the patterns we define are very specific, the engine can help us perform
    quick integrity checks before the actual pattern matching is executed.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we pass the expression `/\w{15}/` to the engine to match it
    against the text `hello`, the engine could decide to check whether the input string
    is actually at least 15 characters long instead of matching the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Don't be greedy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've studied about quantifiers in [Chapter 1](ch01.html "Chapter 1. Introducing
    Regular Expressions"), *Introducing Regular Expressions*, and we learned the difference
    between greedy and reluctant quantifiers. We also found that the quantifiers are
    greedy by default.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean in terms of performance? It means that the engine will always
    try to catch as many characters as possible, and then reduce the scope step-by-step
    until the matching is done. This could potentially make the regular expression
    slow if the match is typically short. Keep in mind, however, that this is only
    applicable if the match is usually short.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we have started learning the relevance of optimization
    and why we should avoid premature optimization by measuring. Then, we jumped into
    the topic of measuring by learning different mechanisms to measure the time of
    execution for our regular expressions. Later, we found out about the RegexBuddy
    tool that can help us to understand how the engine is doing its work and aiding
    us in pinpointing the performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, we understood how to see the engine working behind the scenes. We
    learned some theory of the engine design and how it's easy to fall in a common
    pitfall—the catastrophic backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we reviewed different general recommendations to improve the performance
    of our regular expressions.
  prefs: []
  type: TYPE_NORMAL
