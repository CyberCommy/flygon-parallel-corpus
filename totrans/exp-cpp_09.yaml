- en: Functional Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-Oriented Programming** (**OOP**) provides us with a way of thinking
    about objects, thus expressing the real world in terms of classes and their relationships.
    Functional programming is a completely different programming paradigm as it allows
    us to concentrate on the *functional* structure rather than the *physical* structure
    of code. Learning and using functional programming are useful in two ways. First,
    it is a new paradigm that forces you to think very differently. Solving problems
    requires having flexible thinking. People that are attached to a single paradigm
    tend to provide similar solutions to any problem, while most elegant solutions
    require a wider approach. Mastering functional programming provides developers
    with a new skill that helps them provide even better solutions to problems. Secondly,
    using functional programming reduces the number of bugs in software. One of the
    biggest reasons for that functional programming''s unique approach: it decomposes
    programs into functions, each of which doesn''t modify the state of the data.'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss the fundamental blocks of functional programming in this chapter,
    along with ranges. Introduced in C++20, ranges provide us with a great way to
    compose algorithms so that they work with collections of data. Composing algorithms
    so that we can apply them to this collection of data sequentially is at the heart
    of functional programming. That's why we'll also discuss ranges in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to the ranges library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving more deeply into recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metaprogramming in functional C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler, along with the `-std=c++2a` option, will be used to compile
    the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source files for this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Unveiling functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, functional programming is a programming paradigm. You
    can think of a paradigm as a way of thinking when constructing programs. C++ is
    a multi-paradigm language. We can use it to develop programs in a procedural paradigm,
    that is, by executing statements one after one another. In Chapter 3, *Details
    of Object-Oriented Programming*, we discussed the object-oriented approach, which
    involves decomposing a complex system into intercommunicating objects. Functional
    programming, on the other hand, encourages us to decompose the system into functions
    rather than objects. It operates with expressions rather than statements. Basically,
    you take something as input and pass it to a function that produces an output.
    This can then be used as input for another function. This might seem simple at
    first, but functional programming incorporates several rules and practices that
    feel hard to grasp initially. However, when you manage this, your brain will unlock
    a new way of thinking – the functional way.
  prefs: []
  type: TYPE_NORMAL
- en: To make this a bit clearer, let's start with an example that will demonstrate
    the essence of functional programming. Let's suppose we have been given a list
    of integers and need to count the number of even numbers in it. The only catch
    is that there are several such vectors. We should count the even numbers in all
    vectors separately and produce a result as a new vector containing the results
    of the calculation for each input vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The input is provided as a matrix, that is, a vector of vectors. The simplest
    way to express this in C++ is by using the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the preceding code even more by using type aliases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an illustration of this problem. We have a bunch of vectors
    containing integers, and as a result we should get a vector containing a count
    of even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6afeff6f-80a2-4fdc-a80e-d758cdcac856.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Look at the following function. It takes a vector of integer vectors (also
    known as a matrix) as its argument. The function counts the number of even numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function keeps a separate vector to store the count of even numbers
    for each vector. The input is provided as a vector of vectors, which is why the
    function loops over the first vector to retrieve the inner vectors. For each retrieved
    vector, it loops over it and increments a counter each time it encounters an even
    number in the vector. After completing the loop for each vector, the final result
    is pushed to the vector containing the list of numbers. While you might wish to
    go back to the preceding example and make the code better, we'll move on for now
    and decompose it into smaller functions. First, we move the portion of the code
    responsible for counting the even numbers into a separate function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s name it `count_evens`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note how we applied the `count_if()` algorithm. It takes two iterators and puts
    them at the beginning and the end of the container, respectively. It also takes
    a third parameter, a *unary predicate*, which is called for each element of the
    collection. We passed a lambda as a unary predicate. You can use any other callable
    entity too, such as a function pointer, an `std::` function, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a separate counting function, we can call it in the original
    `count_all_evens()` function. The following implementation of `count_all_evens()`
    expresses functional programming in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before delving into the preceding code, let's agree on the first thing that
    catches our eye – not the weird use of the `|` operator, but the conciseness of
    the code. Compare it to the version of the code we introduced at the beginning
    of this section. They both do the same job, but the second one – the functional
    one – does it more concisely. Also, note that the function doesn't keep or change
    any state. It has no side-effects. This is crucial in functional programming because
    a function must be a *pure* function. It takes an argument, then processes it
    without modifying it, and returns a new value (usually based on the input). The
    first challenge in functional programming is decomposing a task into smaller independent
    functions that are easily composed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we came to the functional solution from an imperative one, it''s not
    the right way to use it when leveraging the functional programming paradigm. Instead
    of writing the imperative code first and modifying it to get the functional version,
    you should change the way you think and how you approach the problem. You should
    tame the process of thinking functionally. The problem of counting all the even
    numbers leads to our solving the problem for one vector. If we can find a way
    to solve the problem for a single vector, we can solve the problem for all the
    vectors.  The `count_evens()` function takes a vector and produces a single value,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f23fba4f-7441-4785-94ef-d67480148d5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After solving the problem for one vector, we should move on to the original
    problem by applying the solution to all the vectors. The `std::transform()` function
    essentially does what we need: it takes a function that can be applied to a single
    value and transforms it in order to process a collection. The following image
    illustrates how we use it to implement a function (`count_all_evens`) that can
    process a collection of items from functions (`count_evens`) that process only
    one item at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fa67593-d788-4281-a47a-f8e9a968a285.png)'
  prefs: []
  type: TYPE_IMG
- en: Splitting bigger problems into smaller, independent tasks is at the heart of
    functional programming. Each function is specialized to do one simple enough task
    without realizing the original problem. Functions are then composed together to
    generate a collection of transformed items from the raw initial input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the final version of the `count_all_evens()` function leverages ranges.
    Let's find out what they are and how to use them because we will need them in
    further examples.
  prefs: []
  type: TYPE_NORMAL
- en: Using ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ranges are tied to views. We will examine them both in this section. We discussed
    STL containers and algorithms in [Chapter 6](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml),
    *Digging into Data Structures and Algorithms in STL*. They provide us with a generic
    approach to composing and working with collections of objects. As you already
    know, we use iterators a lot to loop over containers and work with their elements.
    Iterators are tools that allow us to have loose coupling between algorithms and
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, earlier, we applied `count_if()` to the vector, but `count_if()`
    is not aware of what container it is was applied to. Take a look at the following
    declaration of `count_if()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, besides its verbose declaration, which is specific to C++, `count_if()`
    doesn't take a container as an argument. Instead, it operates with iterators –
    specifically, input iterators.
  prefs: []
  type: TYPE_NORMAL
- en: An input iterator supports iterating forward using the `++` operator and accessing
    each element using the `*` operator. We also can compare input iterators using
    the `==` and `!=` relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithms iterate over containers without actually knowing the exact type
    of the container. We can use `count_if()` on any entity that has a beginning and
    an end, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides their generic nature, algorithms don''t compose well. Usually, we apply
    an algorithm to a collection and store the result of the algorithm as another
    collection that we can apply to more algorithms in the same manner at a later
    date. We use `std::transform()` to put the results into another container. For
    example, the following code defines a vector of Products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that the project has been developed by a different team of programmers
    and they chose to keep the name of a product as any number; for example, 1 is
    for an apple, 2 is for a peach, and so on. This means that `vec` will contain
    `Product` instances, each of which will have a number character in its `name`
    field (whereas the name''s type is `std::string` – this is why we keep the number
    as a character instead of its integer value). Now, our task is to transform the
    names of Products from numbers into full strings (`apple`, `peach`, and so on).
    We can use `std::transform` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the preceding code, the `full_named_products` vector will contain
    Products with full product names. Now, to filter out all the apples and copy them
    to a vector of apples, we need to use `std::copy_if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: One of the biggest disadvantages of the preceding code examples is the lack
    of nice composition until the introduction of ranges. Ranges provide us with an
    elegant way to work with container elements and compose algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, a range is a traversable entity; that is, a range has a `begin()`
    and an `end()`, much like the containers we''ve worked with so far. In these terms,
    every STL container can be treated as a range. STL algorithms are redefined to
    take ranges as direct arguments. By doing this, they allow us to pass a result
    from one algorithm directly to the other instead of storing intermediary results
    in local variables. For instance, `std::transform`, which we used earlier with
    a `begin()` and an `end()`, has the following form if applied to a range (the
    following code is pseudocode). By using ranges, we can rewrite the previous example
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to import the `<ranges>` header. The transform function will return
    a range containing `Product` pointers whose names are normalized; that is, the
    numeric value is replaced with a string value.The filter function will then take
    the result and return the range of products that have `apple` as their name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we simplified these code examples by omitting `std::ranges::views` from
    in front of the `filter` and `transform` functions. Use them as `std::ranges::views::filter`
    and `std::ranges::views::transform`, accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the overloaded operator, `**|**`, which we used in the example at
    the beginning of this chapter, allows us to pipe ranges together. This way, we
    can compose algorithms to produce a final result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We used piping instead of nesting function calls. This might be confusing at
    first because we used to use the `|` operator as a bitwise OR. Whenever you see
    it applied to a collection, it refers to piping ranges.
  prefs: []
  type: TYPE_NORMAL
- en: The `|` operator is inspired by the Unix shell pipe operator. In Unix, we can
    pipe the results of several processes together; for example, `ls -l | grep cpp
    | less` will find `cpp` in the result of the `ls` command and show the final result
    one screen at a time using the `less` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already stated, a range is an abstraction over a collection. This doesn''t
    mean it''s a collection. That''s why the previous example doesn''t carry any overhead –
    it just passes a range from a function to function, where the range just provides
    the beginning and the end of a collection. Also, it allows us to access the underlying
    collection elements. The following diagram illuminates this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fa625af2-3795-4fd4-b089-5a72113aa071.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The function (either **transform** or **filter**) returns a range structure
    instead of a collection. The `begin()` iterator of the range will point to the
    element in the source collection that satisfies the predicate. The range''s iterator
    is a proxy object: it differs from a regular iterator in that it points to an
    element that satisfies the given predicate. We sometimes refer to them as **smart
    iterators **because, every time we advance it (by incrementing, for example),
    it finds the next element in the collection that satisfies the predicate. What''s
    more interesting is that the "smartness" of the iterator depends on the kind of
    function we apply to the collection. For example, the `filter()` function returns
    a range that has smart iterators for their increment operator. This is mostly
    because the result of a filter might contain fewer elements than the original
    collection. Transform, on the other hand, doesn''t return a result with a reduced
    number of elements – it just transforms the elements. This means that a range
    that''s returned by transform has the same functionality for increment/decrement
    operations, but the element access will differ. For each access, the smart iterator
    of the range will return the transformed element from the original collection.
    In other words, it simply implements the `*()` operator for the iterator, similar
    to what can be seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This way, we are creating a new *view* of the collection rather than a new collection
    of transformed elements. The same applies to `filter` and other functions. More
    interestingly, range views leverage *lazy evaluation*. For our preceding example,
    even if we have two range transformations, the result is produced by evaluating
    them in a single pass.
  prefs: []
  type: TYPE_NORMAL
- en: In the example with `transform` and `filter`, each of the functions defines
    a view, but they don't modify or evaluate anything. When we assign the result
    to the result collection, the vector is constructed from the view by accessing
    each element. That's where the evaluation happens.
  prefs: []
  type: TYPE_NORMAL
- en: It's as simple as that – ranges provide us with function composition with lazy
    evaluation. We briefly touched on the toolset that's used in functional programming
    earlier. Now, let's find out about the benefits of the paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Why use functional programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, functional programming introduces conciseness. The code is much
    shorter compared to its imperative counterparts. It provides simple but highly
    expressive tools. When there's less code, fewer bugs will crop up.
  prefs: []
  type: TYPE_NORMAL
- en: Functions don't mutate anything, which makes it much easier to parallelize them.
    This is one of the main concerns in concurrent programs because concurrent tasks
    need to share mutable data between them. Most of the time, you have to explicitly
    synchronize threads using primitives such as mutexes. Functional programming frees
    us from explicit synchronization and we can run the code on multiple threads without
    adapting it. In [chapter 8](92a352fd-cfe4-4d57-8005-ef618534ff74.xhtml),* Digging
    into Data Structures*, we will discuss data races in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The functional paradigm considers all functions as *pure*; that is, functions
    that do not mutate the program state. They simply take input, transform it in
    a user-defined manner, and provide an output. A pure function generates the same
    result for the same input, independent of how many times it has been invoked.
    Whenever we speak about functional programming, we should take all pure functions
    into account by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function takes a `double` as its input and returns its square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Writing solely pure functions might feel like intentionally making the program
    run slower.
  prefs: []
  type: TYPE_NORMAL
- en: Some compilers, such as GCC, provide attributes that help the compiler optimize
    the code. For example, the `[[gnu::pure]]` attribute tells the compiler that the
    function can be considered a pure function. This will reassure the compiler that
    the function doesn't access any global variable and that the function's result
    depends solely on its input.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous scenarios where a *regular* function could bring a faster
    solution. However, in order to adapt to the paradigm, you should force yourself
    to think functionally. For example, the following program declares a vector and
    calculates the square roots of its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re passing the vector by reference. This means that, if we change
    it in the function, we change the original collection. This obviously isn''t a
    pure function because it mutates the input vector. A functional alternative would
    return the transformed elements in a new vector, leaving the input untouched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'An even better example of functional thinking is to solve a smaller problem
    and apply it to the collection. The smaller problem, in this case, is calculating
    the square root of a single number, which is already implemented as `std::sqrt`.
    Applying it to the collection is done with `std::ranges::views::transform`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we already know, by using ranges we can avoid storing intermediary objects.
    In the previous example, we applied `transform` directly to the vector. `transform`
    returns a view, but not a full collection consisting of the transformed elements
    of the source vector. The actual transformed copies of elements are made when
    we construct the `result` vector. Also, note that `std::sqrt` is considered to
    be a pure function.
  prefs: []
  type: TYPE_NORMAL
- en: The example that we solved at the beginning of this chapter gave us the necessary
    perspective for functional programming. To get a better grasp of this paradigm,
    we should become familiar with its principles. In the next section, we will delve
    into the principles of functional programming so that you have an even better
    idea of how and when to use the paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Principles of functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the functional paradigm is old (it was born in the 1950s), it didn't
    take the world of programming by storm. Most of the dominant paradigms these days
    include imperative and object-oriented languages. As we've stated many times in
    this and many other books, C++ is a **multi-paradigm language**. That's the beauty
    of studying C++; we can tune it to fit almost every environment. Grasping the
    paradigm is not an easy task. You have to feel it and apply it until you finally
    start thinking in terms of the paradigm. After that, you will see solutions to
    regular tasks in a matter of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: If you can remember when you first time learned about object-oriented programming,
    you might recall the principles that made you struggle a bit before you could
    unlock the true potential of OOP. The same is true for functional programming.
    In this section, we are going to discuss the basic concepts of functional programming
    that will be the base for further development. You can apply (or have already
    done so) some of these concepts without actually using the functional paradigm.
    However, try to put some effort into understanding and applying each of the following
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned previously, a *function is pure if it doesn't mutate the state*.
    Pure functions can be treated as less performant compared to their non-pure counterparts;
    however, they are great as they avoid most of the bugs that can arise in code
    due to state modifications. The bugs are related to the program state in some
    way. Obviously, programs work with data, so they compose state-modifying functionality
    that leads to some expected results for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, we decompose the program into objects, each
    of which has a list of special features. One of the fundamental features of an
    object in OOP is its *state*. Modifying an object's state by sending messages
    to it (in other words, calling its methods) is crucial in OOP. Usually, a member
    function invocation leads to the object state's modification. In functional programming,
    we organize code into a collection of pure functions, each of which has its own
    purpose and is independent of the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example, just to make this concept clear. Let''s
    say we''re dealing with user objects in a program and each user object contains
    the age associated with the user. The `User` type is described as a `struct` in
    the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a need to update users'' ages on a yearly basis. Let''s suppose we
    have a function that is being invoked for each `User` object once a year. The
    following function takes a `User` object as input and increases its `age` by `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update_age()` function takes the input by reference and updates the original
    object. This is not the case in functional programming. Instead of taking the
    original object by reference and mutating its value, the following pure function
    returns a totally different `user` object with the same properties, except for
    the updated `age` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Though it seems inefficient compared to `update_age()`, one of the pros of
    this approach is that it makes operations crystal clear (this is really useful
    when we''re debugging code). Now, it''s guaranteed that `pure_update_age()` won''t
    modify the original object. We can modify the preceding code so that it will take
    the object by value. This way, we will skip creating the `tmp` object as the argument
    itself represents a copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If a pure function is called multiple times with the same arguments, it must
    return the same result every time. The following code demonstrates that our `pure_update_age()`
    function returns the same value when it''s given the same input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It is a great benefit for a function to behave the same way each time it is
    called for the same input data. This means we can design the logic of the application
    by decomposing it into smaller functions, each of which has an exact and clear
    purpose. However, there is overhead for the pure function in terms of the additional
    temporary object. A regular design involves having a centralized store that contains
    the program state, which is updated indirectly by pure functions. After each pure
    function invocation, the function returns the modified object as a new object
    that can be stored if necessary. You can think of it as tweaking the code to omit
    passing the entire object.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In functional programming, functions are considered *first-class* objects (you
    might encounter first-class citizens as well). This means we should treat them
    as objects rather than a set of instructions. What difference does this make to
    us? Well, the only thing that is important at this point for a function to be
    treated as an object is the ability to pass it to other functions. Functions that
    take other functions as arguments are called **higher-order** **functions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not uncommon for C++ programmers to pass one function into another. Here''s
    how this can be done the old-school way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we declared a pointer to a function. `PF` represents
    a type definition for the function, takes one integer parameter, and doesn't return
    any value. The previous example is a popular way of passing pointers functions
    to other functions as arguments. We treat the function as an object. However,
    this depends on what we understand by an *object.*
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapters, we defined an object as something that has a state.
    This means that, if we treat a function as an object, we should also be able to
    somehow change its state if needed. For function pointers, this isn''t the case.
    Here''s a better way to pass a function to another function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a good look at the preceding code . It declares a class that has an overloaded
    `operator()`. Whenever we overload the operator of a class, we make it *callable*.
    And as obvious as it may sound, anything that is callable is treated as a function.
    So, an object of a class that has an overloaded `operator()` could be considered
    a function (sometimes. it''s referred to as a *functor*). This is like a trick
    in a way because instead of making a function an object, we made an object callable.
    However, this allowed us to achieve what we were looking for: a function that
    has a state. The following client code demonstrates that a `Function` object has
    a state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we can, for example, track how many times the function has been
    called. Here''s a simple example that tracks the number of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `std::function`, which is defined in the `<functional>` header in
    the following code, demonstrates another way of defining a higher-order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When `function_object` is called (using `operator()`), it delegates the call
    to the `print_it` function. `std::function` encapsulates any function and allows
    it to work with it as an object (and pass it to other functions as well).
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions in the preceding examples that took other functions as arguments
    are all examples of higher-order functions. A function that returns a function
    is also called a higher-order function. To sum this up, a higher-order function
    is a function that takes or returns another function or functions. Take a look
    at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`get_multiplier()` returns a lambda wrapped in `std::function`. Then, we call
    the result, just like we would call a regular function. The `get_multiplier()` function
    is a higher-order function. We can implement **currying** using a higher-order
    function, similar to what we did in the preceding example. In functional programming,
    currying is where we make a function take several arguments into several functions,
    each of which takes a single argument; for example, making `multiply(3, 5)` into
    `multiply(3)(5)`. Here''s how we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`multiply()` takes one argument and returns a function that also takes a single
    argument. Pay attention to the lambda capture: it captures the value of `a` so
    that it can multiply it by `b` in its body.'
  prefs: []
  type: TYPE_NORMAL
- en: Currying is a reference to logician Haskell Curry. The Haskell, Brook, and Curry
    programming languages are also named after him.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most useful features of currying is having abstract functions that
    we can compose together. We can create specialized versions of `multiply()` and
    pass them to other functions, or use them wherever they''re applicable. This can
    be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You must''ve used a higher-order function when working with the STL. Many STL
    algorithms take predicates to filter out or process collections of objects. For
    example, the `std::find_if` function finds the element that satisfies the passed
    predicate object, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`std::find_if` takes a lambda as its predicate and calls it for all the elements
    in the vector. Whichever element satisfies the condition is returned as the requested
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a higher-order function would be `std::transform`, which
    we introduced at the beginning of this chapter (not to be confused with `ranges::view::transform`).
    Let''s use it to transform a string into uppercase letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The third parameter is the beginning of the container and is where the `std::transform`
    function inserts its current results.
  prefs: []
  type: TYPE_NORMAL
- en: Folding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Folding (or reduction) is the process of combining a collection of values together
    to generate a reduced number of results. Most of the time, we're speaking about
    a single result. Folding abstracts the process of iterating over structures that
    are recursive in nature. For example, a linked list or a vector has a recursive
    nature in terms of element access. While the recursive nature of the vector is
    arguable, we will consider it recursive since it allows us to access its elements
    by repeatedly incrementing the index. To work with such structures, we usually
    keep track of the result at each step and process the next item to be combined
    with the previous result later. Folding is called *left* or *right* folding based
    on the direction we process the collection elements in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `std::accumulate` function (another example of a higher-order
    function) is a perfect example of folding functionality because it combines values
    in the collection. Take a look at the following simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last argument to the function is the accumulator. This is the initial value
    that should be used as the previous value for the first element of the collection.
    The preceding code calculates the sum of the vector elements. It''s the default
    behavior of the `std::accumulate` function. As we mentioned previously, it is
    a higher-order function, which implies that a function could be passed as its
    argument. This will then be called for each element to produce the desired result.
    For example, let''s find the product of the `elems` vector we declared previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes a binary operation; that is, a function with two arguments. The first
    argument of the operation is the previous value that''s been calculated so far,
    while the second argument is the current value. The result of the binary operation
    will be the previous value for the next step. The preceding code can be rewritten
    in a concise way using one of the existing operations in the STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A better alternative to the `std::accumulate` function is the `std::reduce`
    function. `reduce()` is similar to `accumulate()`, except it doesn''t keep the
    order of the operation; that is, it doesn''t necessarily process the collection
    elements sequentially. You can pass an execution policy to the `std::reduce` function
    and change its behavior, say, to processing elements in parallel. Here''s how
    the reduce function can be applied to the `elems` vector from the previous example
    using the parallel execution policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Though `std::reduce` seems faster compared to `std::accumulate`, you should
    be careful when using it with non-commutative binary operations.
  prefs: []
  type: TYPE_NORMAL
- en: Folding and recursion go hand in hand. Recursive functions also solve a problem
    by decomposing it into smaller tasks and solving them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Diving deeper into recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already discussed the main features of a recursive function in [Chapter
    2](06590f85-3b2c-4909-8bf0-a6a6f5d07c22.xhtml), *Low-level Programming with C++*.
    Let''s take a look at the following simple example of calculating the factorial
    of a number recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Recursive functions provide elegant solutions compared to their iterative counterparts.
    However, you should carefully approach the decision to use recursion. One of the
    most popular issues with recursive functions is stack overflows.
  prefs: []
  type: TYPE_NORMAL
- en: Head recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Head recursion is the regular recursion that we are already familiar with.
    In the preceding example, the factorial function behaves as a head recursive function,
    meaning that it makes the recursive call before processing the result at the current
    step. Take a look at the following line from the factorial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To find and return the result of the product, the function factorial is called
    with a reduced argument, that is, `(n - 1)`. This means that the product (the
    `*` operator) is kind of *on hold* and is waiting for its second argument to be
    returned by `factorial(n - 1)`. The stack grows in line with the number of recursive
    calls to the function. Let''s try to compare the recursive factorial implementation
    with the following iterative approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: One of the main differences here is the fact that we store the result of the
    product at each step in the same variable (named `result`). With this in mind,
    let's try to decompose the recursive implementation of the factorial function.
  prefs: []
  type: TYPE_NORMAL
- en: It's clear that each function call takes up a specified space on the stack.
    Each result at each step should be stored somewhere on the stack. Although we
    know that it should, and even must, be the same variable, the recursive function
    doesn't care; it allocates space for its variables. The counter-intuitiveness
    of regular recursive functions prompts us to find a solution that somehow knows
    that the result of each recursive call should be stored in the same place.
  prefs: []
  type: TYPE_NORMAL
- en: Tail recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tail recursion is the solution to the problem of having multiple unnecessary
    variables that we deal with in recursive functions. The basic idea of tail-recursive
    functions is doing the actual processing before the recursive call. Here''s how
    we can transform the factorial function into a tail-recursive one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the new argument of the function. Carefully reading the preceding
    code gives us a basic idea of the tail-recursion that''s occurring: the processing
    is done before the recursive call. Before `tail_factorial` is called again in
    its body, the current result is calculated (`n * result`) and passed to it.'
  prefs: []
  type: TYPE_NORMAL
- en: While this idea might not seem fascinating, it is really efficient if **Tail
    Call Optimization (TCO)** is supported by the compiler. TCO basically involves
    knowing that the second argument of the factorial function (the tail) can be stored
    at the same location for every recursive call. This allows for the stack to stay
    the same size, independent of the number of recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of compiler optimizations, we can't omit template metaprogramming.
    We're mentioning it here alongisde compiler optimizations because we can treat
    metaprogramming as the biggest optimization that can be done to the program. It's
    always better to do calculations at compile time than at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Metaprogramming in functional C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Metaprogramming can be treated as another programming paradigm. It''s a totally
    different approach to coding because we are not dealing with the regular process
    of programming. By a regular process, we mean the three phases that a program
    goes through in its lifetime: coding, compiling, and running. It''s obvious that
    a program does what it''s supposed to do when it is executed. An executable is
    generated by the compiler through compilation and linking. Metaprogramming, on
    the other hand, is where the code is being *executed* during the compilation of
    the code. This might sound magical if you are dealing with it for the first time.
    How can we execute code if the program doesn''t even exist yet? Recalling what
    we learned about templates in [Chapter 4](c0e82f94-f2ed-4f17-98c9-1c3d3b27ae3d.xhtml),
    *Understanding and Designing Templates*, we know that the compiler processes them
    with more than one pass. In the first pass, the compiler defines the necessary
    types and parameters that are used in the template class or function. With the
    next pass, the compiler starts to compile them in the way we''re familiar with;
    that is, it generates some code that will be linked by the linker to produce the
    final executable file.'
  prefs: []
  type: TYPE_NORMAL
- en: Since metaprogramming is something that happens during code compilation, we
    should already have an idea of which concepts and constructs of the language are
    used. Anything that can be calculated at compile-time can be used as a metaprogramming
    construct, such as templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the classic mind-blowing example of metaprogramming in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Why would we bother to write so much code just for a factorial that we wrote
    in the previous section in fewer than five lines of code? The reason is due to
    its efficiency. While it will take a little bit more time to compile the code,
    it is super efficient compared to the normal factorial function (implemented either
    recursively or iteratively). And the reason behind this efficiency is the fact
    that the actual calculation of the factorial is happening at compile time. That
    is, when the executable is run, the results are already ready to use. We just
    used the calculated value when we run the program; no calculation happens at runtime.
    If you're seeing this code for the first time, the following explanation will
    make you fall in love with metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s decompose and analyze the preceding code in detail. First of all, the
    `MetaFactorial` template is declared with a single `enum` with a `value` property.
    This `enum` is chosen solely because its properties are calculated at compile
    time. So, whenever we access the value property of `MetaFactorial`, it is already
    being calculated (evaluated) at compile time. Take a look at the actual value
    of the enumeration. It makes a recursive dependency from the same `MetaFactorial`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of you may have already noticed the trick here. `MetaFactorial<N - 1>`
    is not the same struct as `MetaFactorial<N>`. Although it has the same name, each
    template with a different type or value is generated as a separate new type. So,
    let''s say we call something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the hard-working compiler generates three different structs for each
    value (the following is some pseudocode representing how we should picture the
    compiler working):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next pass, the compiler replaces each of the generated struct''s values
    with their respective numeric values, as shown in the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the compiler removes the unused generated structs, leaving only `MetaFactorial<3>`,
    which is, again, only used as `MetaFactorial<3>::value`. This can also be optimized.
    By doing this, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this with the previous line we had:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: That's the beauty of metaprogramming F— it's done at compile time and leaves
    no trace, like a ninja. The compilation takes longer but the execution of the
    program is the fastest it can possibly be compared to regular solutions. We suggest
    that you try implementing meta-versions of other cost-expensive calculations,
    such as calculating the n^(th) Fibonacci number. It's not as easy as coding for
    *runtime* rather than *compile-time*, but you already have a sense of its power.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got a new perspective when it comes to using C++. As a multi-paradigm
    language, it can be used as a functional programming language.
  prefs: []
  type: TYPE_NORMAL
- en: We learned the main principles of functional programming, such as pure functions,
    higher-order functions, and folding. Pure functions are functions that do not
    mutate the state. One of the pros of pure functions is that they leave fewer bugs
    that would otherwise be introduced because of state mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions are functions that take or return other functions. Other
    than in functional programming, C++ programmers use higher-order functions when
    dealing with the STL.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions, along with higher-order functions, allow us to decompose the
    whole application into a big *assembly line* of functions. Each function in this
    assembly line is responsible for receiving data and returning a new, modified
    version of the original data (without mutating the original state). When combined,
    these functions provide a well-coordinated line of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into multithreaded programming and discuss
    the thread support library components that were introduced in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: List the advantages of ranges.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What functions are known to be pure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a pure virtual function and a pure function in
    terms of functional programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is folding?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of tail recursion over head recursion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding what was covered in this chapter, please take
    a look at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Learning C++ Functional Programming* by Wisnu Anggoro: [https://www.packtpub.com/application-development/learning-c-functional-programming](https://www.packtpub.com/application-development/learning-c-functional-programming)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Functional Programming in C++: How to Improve Your C++ Programs Using Functional
    Techniques* by Ivan Cukic: [https://www.amazon.com/Functional-Programming-programs-functional-techniques/dp/1617293814/](https://www.amazon.com/Functional-Programming-programs-functional-techniques/dp/1617293814/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
