- en: '*Chapter 16*: C# in Action with .NET Core 3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C# programming language is the medium that we use to turn ideas into runnable
    code. At compile time, the whole set of rules, grammar, constraints, and semantics
    get transformed into the **Intermediate Language**—a high-level assembly language
    used to instruct the **Common Language Runtime (CLR)**, which in turn provides
    the necessary services to run the code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to execute some code, native languages such as C, C++, and Rust require
    a thin runtime library to interact with the **operating system** (**OS**) and
    execute abstractions such as *program loading*, *constructors*, and *deconstructors*.
    On the other hand, higher-level languages such as C# and Java need a more complex
    runtime engine to provide other fundamental services such as *garbage collection*,
    *just-in-time compilation*, and *exception management*.
  prefs: []
  type: TYPE_NORMAL
- en: When .NET Framework was first created, the CLR was designed to run exclusively
    on Windows, but later, many other runtimes (implementing the same ECMA specifications)
    emerged, playing an important role in the market. For example, the Mono runtime
    was the first community-driven project to run on the Linux platform, and the Microsoft
    Silverlight project had brief success running inside the browsers of all the major
    platforms. Other runtimes, such as .NET Micro Framework for running on microcontrollers,
    .NET Compact Framework for targeting the embedded Windows CE OS, and other more
    recent flavors of the runtime running on Windows Phone and the Universal Windows
    Platform are good examples of the variety of the .NET implementations that have
    the ability to run the same set of instructions we still use today.
  prefs: []
  type: TYPE_NORMAL
- en: Each of those runtimes was built upon a number of requirements dictated by the
    historical context of the time, with no exceptions. At its birth, about 20 years
    ago, .NET Framework was designed to satisfy the growing Windows-based personal
    computer ecosystem, whose power grew over time in terms of CPU power, memory,
    and storage. Over the years, most of those runtimes successfully shifted toward
    more constrained hardware specifications, still offering roughly the same set
    of features. For example, even if modern mobile phones have very powerful microprocessors,
    code efficiency is still vital to preserve the battery life of those devices,
    a requirement that was not relevant when .NET Framework was initially designed.
  prefs: []
  type: TYPE_NORMAL
- en: Although the .NET specifications used by those runtimes are still the same,
    there are differences that make every developer's life hard when trying to design
    an application that is able to run on multiple runtimes, especially when a requirement
    is for it to be able to run cross-platform and/or cross-device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET Core 3 runtime was born to resolve those issues, by offering a new
    runtime that satisfies all the modern requirements. In this chapter, we are going
    to examine the factors related to the runtime when developing a C# application:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the .NET **command-line interface (CLI)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing on Linux distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What .NET Standard is and how can it help the application design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming NuGet packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Migrating an application designed with .NET Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be more familiar with the .NET Core tools
    that allow you to compile and publish your application so that you can design
    a library to share the code with other applications running on .NET Core or other
    runtime flavors. Also, where you already have an application based on .NET Framework,
    you will learn the main steps to migrate it to fully leverage the .NET Core runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .NET command-line interface (CLI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **command-line interface** (**CLI**) is a new but strategic tool in the
    .NET ecosystem, enabling a modern developmental approach that can be used the
    same way across all platforms. At first sight, defining a tool based on the old
    console as "modern" might look strange, but in the world of modern development,
    the ability to script the build process to embrace the **Continuous Integration**
    and **Continuous Delivery**/**Deployment** (**CI**/**CD**) strategy is fundamental
    to provide faster and higher quality development life cycles.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the .NET Core SDK (see [https://dotnet.microsoft.com/](https://dotnet.microsoft.com/)),
    the .NET CLI is available through the Linux Terminal or Windows Command Prompt.
    A good alternative on Windows is the new **Windows Terminal** application, which
    can be downloaded through the Windows Store and provides a great replacement for
    the traditional Command Prompt, as well as the **PowerShell** terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET CLI has a rich list of commands, enabling a complete set of operations
    for the entire development life cycle. Detailed and contextual help for every
    command is obtained by adding the `––help` string as the last argument. The most
    relevant commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet new`: The `new` command creates a folder for a new application project
    or solution, based on a long list of predefined templates that can be easily installed
    in addition to the default ones. Typing this command alone will just list all
    the available templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet restore`: The `restore` command restores the referenced libraries from
    the NuGet server (outside the default `nuget.org` internet packages repository,
    the user can create a `nuget.config` file to specify other locations such as GitHub,
    or even a local folder).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet run`: The `run` command builds, restores, and runs the project in a
    single shot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet test`: The `test` command runs the test for the specified project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet publish`: The `publish` command creates the deployable binaries, as
    we will discuss in the *Publishing an application* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these commands, the .NET CLI can be used to invoke other tools.
    Some of them are preinstalled. For example, `dotnet dev-certs` is a tool that's
    used to manage the HTTPS certificates on the local machine. Another example of
    the preinstalled tools on offer is `dotnet watch`, which observes the changes
    made to the source files in a project and automatically reruns the application
    every time any change occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `dotnet tool` command is the gateway to extend the CLI capability because
    it allows us to download and install additional tools through the configured NuGet
    servers. At the time of writing, there is still no way to filter the packages
    containing .NET tools on [https://nuget.org](https://nuget.org); therefore, your
    best option is reading the suggestions from articles or other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a new project (using the CLI), you may want to decide the runtime
    version first. The `dotnet ––info` command returns a list of all the installed
    runtimes and SDKs. By default, the CLI uses the more recently installed `global.json`.
    The settings in this file will affect all the operations done by the .NET CLI
    (which is also used by Visual Studio) for all the folders under the one containing
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can edit the file with your favorite editor and change the SDK version
    to one of the values listed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Be careful to choose the `info` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process is useful to keep an application tied to a specific SDK instead
    of automatically inheriting the latest one installed. That being said, it is now
    time to create a new empty solution, which is a codeless container for one or
    more projects. Creating a solution is optional, but is very useful when you need
    to create multiple cross-referenced projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s now time to create a new console project under the solution folder. The
    solution name can be omitted from the `sln add` command since there is only one
    solution in the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can build and run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use the `watch` command to rerun the project every time
    any file is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As soon as the first `Waiting for a file to change before restarting dotnet...`
    message was printed on the console, I modified and saved the `Program.cs` file
    using the Visual Studio Code editor. The changes on that file triggered the build
    process automatically, and the binary files were created as usual in the `bin`
    folder, whose tree structure has been slightly changed from .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is still the `Debug` or `Release` folder, which in turn contains a new
    subfolder with the name of the framework; in this case, `netcoreapp3.0`. The new
    project system is multi-target capable and can generate different binaries depending
    on the framework, runtime, and bitness specified in the project file. The contents
    of that folder are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hello.dll`. This is the assembly containing the `IL` code that was generated
    by the compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hello.exe`: The `.exe` file is a host application that bootstraps your application.
    Later, we will talk about publishing/deploying an application with more options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hello.pdb`: The `.pdb` file contains the symbols that allow the debugger to
    cross-reference the `IL` code to the source files, and the symbol (that is, variable,
    method, or class) names to the actual code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hello.deps.json`: This file contains the full dependency tree in JSON format.
    It is used to retrieve the libraries needed during compilation and it is a very
    effective way to discover undesired dependencies or problems when mixing different
    versions of the same assembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Hello.runtimeconfig.json` and `Hello.runtimeconfig.dev.json`: These are used
    by the runtime to know which shared runtime should be used to run the application.
    The `.dev` file contains configurations that are used in addition to the base
    file when the environment specifies that the application should be run in a development
    environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We just created a very basic application, but those steps are all that is required
    to create a complex application made of several libraries and using other, more
    complex templates. An interesting fact is that the same steps can be executed
    on the *Linux Terminal* to obtain the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Developing on Linux distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements revolution felt by developers did not stop with the mobile
    market and is still ongoing today. For example, the need to run across multiple
    OSes is more important than ever since the cloud era began. Many applications
    started moving from on-premises to cloud architectures, from virtual machines
    to containers, and from service-oriented architectures to microservices. This
    shift is so big that even the Microsoft CEO proudly celebrated the prevalence
    of Linux OSes on Azure, which is a clear sign of the importance of being able
    to create cross-platform applications.
  prefs: []
  type: TYPE_NORMAL
- en: There is no doubt that the ability of .NET Core to run on different OSes, devices,
    and CPU architectures is vital, but it comes with an awesome level of abstraction
    that minimizes the efforts of the developers, hiding most of the differences.
    For example, the Linux panorama offers a multitude of distributions, but you don't
    need to worry, as the abstraction doesn't affect the application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson learned from the IT industry is that the technologies currently driving
    the growth of the cloud are not the final destination, but just a transition.
    At the time of writing, a technology called **Web Assembly System Interface (WASI)**
    is being standardized as a powerful abstraction to sandbox small units of code,
    providing a security isolation that can be used to run not only web applications
    (already available in every browser through **WebAssembly**) but also cloud or
    even classic standalone applications.
  prefs: []
  type: TYPE_NORMAL
- en: We still don't know if WASI will be successful, but there is no doubt that a
    modern runtime must be ready to ride the wave, and this implies embracing the
    agility to rapidly evolve and mutate as soon as new requirements knock at the
    door.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the development box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple options when it comes to creating a development environment
    on Linux. The first is to install Linux on the physical machine itself, which
    gives benefits in terms of performance throughout the whole development life cycle.
    The choice of the primary OS is very subjective and, while Windows and macOS currently
    offer a better desktop experience, the choice mostly depends on the application
    ecosystem that you need.
  prefs: []
  type: TYPE_NORMAL
- en: Another well-tested scenario is developing inside a virtual machine. In this
    case, you can use *Windows Hyper-V* or *Parallels Desktop* on Mac. If you don't
    have a distribution of choice, I strongly suggest you start installing Ubuntu
    desktop.
  prefs: []
  type: TYPE_NORMAL
- en: "On Windows, you will find it very useful to use the integrated Linux support\
    \ called **Windows Subsystem for Linux (WSL)**, which can be installed as an additional\
    \ Windows 10 component. The current mature release, at the time of writing, is\
    \ **WSL 1**, which runs \La Linux distribution over the Windows kernel. In this\
    \ solution, the Linux system calls are automatically remapped to the Windows kernel\
    \ mode implementations."
  prefs: []
  type: TYPE_NORMAL
- en: While the distribution installed in this configuration is a fully genuine Linux
    distribution, some of its system calls cannot be translated and others, such as
    filesystem operations, are slower because their translation is not trivial. With
    **WSL 1**, most of the .NET Core code will run flawlessly; therefore, it is a
    good option for quickly switching between the Windows desktop and a true Linux
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The future of WSL is already available in the latest Windows preview and will
    soon be released in full. In this configuration, the full Linux kernel is installed
    on Windows and coexists with the Windows kernel, removing any of the previous
    limitations and providing near-native speed. As soon as it becomes fully available,
    I strongly recommend this development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you prepare the Linux machine, you have three options:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the .NET Core **SDK** because you want to manage the developer life
    cycle from within Linux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the .NET Core runtime because you just want to run the application and/or
    its tests on Linux to verify the cross-platform development is working as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't install either of the two, because you want to test the application as
    a self-contained deployment. We will investigate this option later in the *Publishing
    an application* section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The prerequisites and packages needed for the SDK or the runtimes are continuously
    subject to change; therefore, it is better to refer to the official download page
    at [https://dot.net](https://dot.net). Once installed, the `dotnet ––info` from
    a Terminal and show the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you decided to use the virtual machine or WSL, you should now install the
    **SSH daemon** so that you can communicate from the host machine to Linux. You
    should refer to the Linux distribution-specific instructions, but generally, the
    **openssh** package is the most popular choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the Linux machine can be contacted either via the hostname (if it is automatically
    registered to your DNS) or the IP address. You can obtain these two pieces of
    information by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ip address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hostname`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is a variety of free `ssh` command-line tool in Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If it doesn''t work because of a configuration problem, the typical troubleshooting
    path is to restore the default permissions on the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are, of course, many optional tools for Linux, but it is worth mentioning
    a few of them here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Net-tools**: This is a package containing many network-related tools to diagnose
    the network protocols such as *arp*, *hostname*, *netstat*, and *route*. Some
    distributions already include them; otherwise, you can install by using your favorite
    package manager, such as **apt-get** on Ubuntu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LLDB**: This is a Linux-native debugger. Microsoft provides the SOS extension
    for LLDB containing the same set of commands as the more popular SOS for WinDbg.
    This extension provides a lot of .NET-specific commands to diagnose leaks, walk
    the objects graph, investigate exceptions, and they can also be used on crash
    dumps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build-essential**: This is a package containing many developer tools, including
    the C/C++ compiler and related libraries to develop native code. This is useful
    if you wish to create native code to be invoked using **PInvoke** calls from .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh` tool under the hood are *Remote – SSH* and *Remote – WSL*. The SSH extension
    allows us to develop on the remote Linux machine via SSH, whereas the WSL one
    allows us to develop on the local WSL subsystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can just follow the most updated extension''s instructions to configure
    the remote machine (exhaustive documentation can be found at the installation
    link in the *Further reading* section at the end of this chapter). Once installed,
    by hitting *F1*, you can access the Visual Studio Code commands. Then, type `Remote-SSH`,
    click **Add New SSH Host**, and finally repeat and pick **Connect to Host**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – Connecting to a remote host via SSH from Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – Connecting to a remote host via SSH from Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: This first connection will remotely install the required tools on Linux to enable
    the **Remote Development** scenario, which is where all the compilation and run
    tasks are done remotely, instead of on the machine where you type the code.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you can just deploy the binaries and run them remotely, this configuration
    is very useful to test code that is demonstrating anomalies when running on Linux.
    In Visual Studio Code, you can open the Terminal window using the **View** | **Terminal**
    menu. The integrated Terminal window can be used to create the solution and projects
    and watch the sources to rerun the application automatically in the same way we
    previously did.
  prefs: []
  type: TYPE_NORMAL
- en: Writing cross-platform aware code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstractions provided by .NET Core let you forget many of the peculiarities
    that exist and work differently from one OS to another, but there are still things
    that must be considered carefully when developing the code. Most of these apparently
    insignificant details should become a best practice of the developer in order
    to avoid problems when running the application on different systems.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem casing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common mistake is not to consider the filesystem casing. On Linux,
    the files and folder names are *case-sensitive*; therefore, it is not unusual
    to discover problems due to a path containing the wrong casing for a file or a
    folder name.
  prefs: []
  type: TYPE_NORMAL
- en: Home directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The structure of the user profiles is different in Windows and Linux, and even
    more importantly, the home directory when running the application with `sudo`
    (admin) privileges is different than the current logged-in user.
  prefs: []
  type: TYPE_NORMAL
- en: Path separators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We all know that Linux and Windows use the forward slash and the backslash
    characters to separate the files and folders, respectively. This is why the `System.IO.Path`
    class exposes the available separators through a few properties. Even better,
    avoid using the separators at all. For example, to compose a folder, the following
    statement should be preferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to transform a relative into a full path, use the `Path.GetFullPath`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-line separators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with text files, the end-of-line separator in Windows is `\r\n`
    (`0x0D`, `0x0A`), while on Linux, we just use `\r` (`0x0D`). As for the `Path`
    class, the separator can be retrieved at runtime with `Environment.NewLine`, but
    most of the time, you can forget the difference by letting the `System.IO.TextReader.ReadLine`
    and `System.IO.TextWriter.WriteLine` abstractions take care of that.
  prefs: []
  type: TYPE_NORMAL
- en: Digital certificates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Windows has a standard central repository for digital certificates, Linux
    does not, and it is up to the developer to decide whether to rely only on the
    certificate file or a distribution-specific solution. When you need to store a
    certificate, including the private key, it must be protected, because the private
    key is a secret that must never be disclosed. Providing the appropriate restrictions
    to defend those certificates is up to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every platform-specific API such as the `NotImplementedException`. On Windows,
    the registry has historically been used to store per-user or even global settings
    related to the application. Linux has no equivalent; therefore, in modern development,
    it is better to get rid of the registry entirely. Another popular API is **Windows
    Management Instrumentation (WMI)**, which is only available on Windows and has
    no equivalent on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Everything related to Windows accounts is, again, only available on Windows.
    The easiest way to modify the filesystem security flags on Linux is to spawn a
    new process running the standard `chmod` command-line tool with the appropriate
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very powerful and common denominator among all the platforms is the availability
    of the environment variables. Windows developers generally don't use them very
    often, while they are quite popular on Linux. For example, ASP.NET Core uses them
    to switch configurations between development, staging, and production, but can
    also be used to retrieve the standard variables, such as `HOME` on Linux and `HOMEPATH`
    on Windows, both of which represent the root folder for the current user's profile.
  prefs: []
  type: TYPE_NORMAL
- en: Gaps you may discover only at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are times where you may need to detect at runtime the OS or the CPU architecture
    that the code is running on. For this purpose, the `System.Runtime.InteropServices.RuntimeInformation`
    class provides a lot of interesting information:'
  prefs: []
  type: TYPE_NORMAL
- en: The `OSDescription` property returns a string describing the OS the application
    is running on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OSArchitecture` property returns a string with the OS architecture. For
    example, the *X64* value stands for the Intel 64-bit architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FrameworkDescription` property returns a string describing the current
    framework, such as *.NET Core 3.0.1*. The short string *3.0.1* is instead available
    through the `Environment.Version` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ProcessArchitecture` property returns the processor architecture. This
    distinction exists because Windows can create 32-bit processes on its 64-bit flavor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GetRuntimeDirectory` method returns the full path, pointing to the runtime
    used by the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the `RuntimeInformation.IsOSPlatform` method returns a Boolean that
    can be used to execute platform-specific code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should always evaluate whether to use this technique to adopt platform-specific
    decisions, or to create a NuGet package containing one DLL for each platform.
    This latter solution is more maintainable but is not discussed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: What .NET Standard is and how can it help the application design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While .NET Core is the best candidate for running your code almost everywhere,
    it is also true that we currently may need to run our code on different runtimes,
    such as .NET Framework for existing Windows applications, Xamarin for developing
    mobile applications, and Blazor for running code in the WebAssembly sandbox or
    on other older runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: The first attempt to share compiled libraries across multiple runtimes was done
    with the **portable class library**, where the developer could only use the APIs
    that were available in all the selected runtimes. The resulting intersection was
    impractical because restricting the number of available APIs to just the common
    APIs was way too limiting. .NET Standard initiative was born to resolve this issue
    by creating versioned sets of API definitions for a number of well-known APIs.
    In order to be .NET Standard-compliant, any runtime must guarantee to implement
    that complete set of APIs. Think of .NET Standard as a sort of giant interface
    holding all the included APIs. Furthermore, every new version of .NET Standard
    adds new APIs to the previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Even if an API is a part of a .NET Standard contract, it can be implemented
    on certain platforms by throwing `NotImplementedException`. This solution was
    allowed to ease the migration of old applications to .NET Standard and must be
    taken into consideration when using a .NET Standard library.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Standard version 1.0 defined a very small set of APIs to satisfy almost
    all the available runtimes of the past, such as **Silverlight** and **Windows
    Phone 8**. Version after version, the number of defined APIs has grown larger,
    excluding older runtimes but also offering more APIs overall to developers. For
    example, version 1.5 offered a good compromise in terms of the number of APIs
    because it supported the very popular .NET Framework 4.6.2\. In the .NET Standard
    repository on GitHub ([https://github.com/dotnet/standard/tree/master/docs/versions](https://github.com/dotnet/standard/tree/master/docs/versions)),
    you can find the complete list of the versions and supported API sets.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, you should care about the .NET Standard versions only
    as a library author. If you look at the very popular `Newtonsoft.Json` package
    on NuGet, you will see that it complies to .NET Standard 1.0\. This makes very
    sense because it allows the library to be used by almost the entire .NET ecosystem.
    The simple rule is that library developers should support the lowest possible
    version.
  prefs: []
  type: TYPE_NORMAL
- en: From the application developer's perspective, the problem is different because
    you may want to use the highest possible number in order to have the largest number
    of APIs available. If your target is to develop applications just for .NET Framework
    and .NET Core (which is very common when migrating to a new runtime), your choice
    will be version 2.0 because this is the last version of the .NET Standard contract
    supported from .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the most recent version of .NET Standard is 2.1, which
    includes APIs such as `Span<T>`, and many new method overloads that take `Span<T>`
    instead of arrays, thereby providing better performance results.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .NET Standard library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a .NET Standard library is straightforward. In Visual Studio, there
    is a specific template, whereas from the command line, the following command creates
    a .NET Standard library whose version is 2.0 by default. You can list the other
    choices by appending `--help` onto the end of the following command, or you can
    stay with `netstandard2.0` and create the library project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once created, the library can be added to the previous solution with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can add the `MyLibrary` reference to the `Hello` project with
    this other command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The generated assembly is a class library that can be referenced from all the
    projects targeting the runtimes and supporting that .NET Standard version.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding between the .NET Standard and .NET Core libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every time you need to share some code across multiple runtimes, the best option
    is to try to fit it, whenever possible, into a .NET Standard library.
  prefs: []
  type: TYPE_NORMAL
- en: We already said that library authors should target the lowest possible version
    number, but of course, if you are the only library consumer, you may decide to
    adopt .NET Standard 2.0 to share codes, for example, between .NET Framework, .NET
    Core Mono 5.4, and Unity 2018.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time your library is going to be exclusively consumed by a .NET Core
    application, you may want to create a .NET Core class library instead as it does
    not limit the API set that you can use in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, a new .NET Core class library (`NetCoreLibrary`) has
    been created and added to the reference of the `Hello` project.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming NuGet packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages play a very important role in modern application development because
    they define a self-contained unit of code that can be used as a brick to build
    larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: This same definition was used in the past for libraries composed by a single
    `.dll` file, but modern development often requires more files to make a unit of
    code that's properly self-contained. The simplest example is when a package contains
    the library as well as its dependencies, but another, more complex, example is
    writing a library needing platform invocation calls to native APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '`RuntimeInformation` class, but it is generally better for both performance
    and maintenance to split the code into one library for each OS and CPU architecture.
    The advantage of packaging the platform-dependent libraries is that it lets the
    .NET Core build tools copy the relevant library in the output folder at publishing
    time. Beyond the interoperability with native code, there are other cases, such
    as providing different implementations depending on the runtime (for example,
    .NET Core, .NET Framework, Mono, and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding packages to a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple ways to add a package reference to a project; it mostly
    depends on your IDE of choice. Visual Studio offers full visual support by opening
    the **Solution Explorer** (this is the window showing the solution and projects
    hierarchy), expanding a project tree, right-clicking the **Dependencies** node,
    and picking the **Manage NuGet Packages** menu item. The following is a typical
    NuGet window, listing the packages available from **nuget.org** that can be added
    to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2 – The NuGet Package Manager Window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.2 – The NuGet Package Manager Window
  prefs: []
  type: TYPE_NORMAL
- en: 'The NuGet window allows you to add, remove, or update to a different version
    of the project packages:'
  prefs: []
  type: TYPE_NORMAL
- en: On the right, the **Package source** combo box shows the list of websites or
    local folders providing packages. The list can be configured by clicking on the
    nearby gear icon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left, the `author:microsoft`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Installed** tab only shows the packages that are already installed in
    the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Updates** tab shows the installed packages for which a new version is
    available from the selected source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've selected a package on the right-hand side of the tab, you select
    the desired version and it will proceed to install, uninstall, or update, depending
    on the tab you started from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a solution is composed of multiple projects, it is important to be consistent
    in the version packages. For this reason, Visual Studio offers the ability to
    **Manage NuGet Packages for Solution**, a menu item available by right-clicking
    the **Solution** node. This window is similar, but has an additional tab called
    **Consolidate**, showing the packages that are installed with different versions
    in multiple projects. Ideally, this tab shouldn''t show any packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3 – The NuGet Package Manager for the Solution, Consolidate tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.3_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.3 – The NuGet Package Manager for the Solution, Consolidate tab
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative way to search for packages is going straight to the source.
    In the following screenshot, you can see the [http://nuget.org](http://nuget.org/)
    website, which is the primary repository of .NET packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4 – Searching on the NuGet gallery website'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.4_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.4 – Searching on the NuGet gallery website
  prefs: []
  type: TYPE_NORMAL
- en: 'This web page shows important details for each package you select:'
  prefs: []
  type: TYPE_NORMAL
- en: On the right, the **Source repository** link jumps to the source repository
    whenever it is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Dependencies** section can be expanded to show which other packages it
    relies on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **GitHub Usage** section acts as a sort of reputation for the package, showing
    how many open source projects took a dependency from it. The more a package is
    used by the community, the higher the chance that it is supported and reliable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the upper part of the page, the package section shows different ways to
    add the package to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package Manager** shows the manual command you can execute from the window
    with the same name in Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET CLI** shows the .NET CLI command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.csproj` directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Paket CLI** is an alternative CLI tool to the .NET CLI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Adding a package via the CLI is straightforward because `nuget.org` already
    provides us with the exact command string to type into the console Terminal. Remember
    to enter the project folder first, and then type the command. For example, the
    following is the command to add a reference to the `Newtonsoft.Json` package from
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of the OS, if you are using Visual Studio Code, it provides the handy
    Terminal window from which you can type any .NET CLI command.
  prefs: []
  type: TYPE_NORMAL
- en: Another frequently used method to add a package reference is to directly edit
    the `.csproj` file. With .NET Core, the project file structure was drastically
    simplified, getting rid of all the past tags and also offering the ability, within
    Visual Studio, to edit and update the file without closing or unloading the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the relevant portion of a `.csproj` file where you can add
    the `PackageReference` tag by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `ItemGroup` element can be repeated multiple times and each
    of them may contain multiple `PackageReference` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from .NET Framework to .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I believe the most important new feature of the .NET Core runtime is its ability
    to be deployed side by side with any other .NET Core version, guaranteeing that
    any future release will not affect older runtimes or libraries and, consequently,
    applications. The primary reason that prevented Microsoft from modernizing and
    improving the performance of .NET Framework was the shared nature of the .NET
    runtime and base class libraries. Because of that, the smallest change to those
    libraries could potentially cause unacceptable breaking changes to the hundreds
    of millions of installations already deployed.
  prefs: []
  type: TYPE_NORMAL
- en: The obvious consequence of the new side-by-side deployment strategy in .NET
    Core is the total absence of the **Global Assembly Cache (GAC)**, which provided
    a central repository to which a system or user library could be deployed. The
    runtime is now completely isolated from the rest of the system, a decision that
    enabled the ability to deploy the application in a so-called **self-contained
    deployment** where all the required code, including the runtime and the system
    library, together with the application code, are copied into a single folder.
    We will dig into the deployment options later in the *Publishing an application*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among all the available runtimes, .NET Framework has always been the touchstone
    and, at the time of writing, is still a valid ecosystem that will be supported
    for a very long time by Microsoft since it is redistributed with the Windows client
    and server OSes. Though, as wise developers, we can''t ignore the fact that with
    the release of .NET Core 3, Microsoft made two important statements:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET Framework 4.8 will be the *last version* of this runtime and libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 5 will be the new *short name* for .NET Core to be released at the end
    of 2020.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no doubt that .NET Core 3 demarcates a turning point in the history
    of the .NET runtime as it provides all the workloads that were previously supported
    by .NET Framework. Starting from .NET Core 3, you can now create server and Windows
    desktop applications, leverage the power of machine learning, or develop cloud
    applications. This is also a strong piece of advice for all relevant developers
    who are invited to create all-new applications using .NET Core, because it offers
    the latest state-of-the-art technology in terms of runtime, libraries, compilers,
    and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing your architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before starting any migration step, it is important to verify whether the technologies,
    frameworks, and third-party libraries are available on .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: The old .NET Framework base class library has been ported entirely, as have
    the great majority of the most popular NuGet packages authored by Microsoft and
    other third parties, giving all of us a very high chance of finding updated versions
    compatible with .NET Core. If those dependencies are available as .NET Standard
    2.0 or a lower version (remember that .NET Standard 2.1 is not supported by .NET
    Framework), then they are good to go. But as we have seen previously, the NuGet
    package can contain multiple libraries targeting different runtimes, so it is
    important to verify the compatibility of the library on the vendor's page.
  prefs: []
  type: TYPE_NORMAL
- en: If your projects rely heavily on Windows because they need Windows APIs, you
    may want to take a look at the **Windows Compatibility Pack NuGet** package, which
    contains about 20,000 APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Information box
  prefs: []
  type: TYPE_NORMAL
- en: Even if a library is only .NET Framework-compatible, in most cases, it can be
    referenced by .NET Core thanks to a *shim mechanism* that makes this possible.
    In this case, Visual Studio shows a yellow triangle indicating a warning in the
    build log. The potential incompatibilities should be tested carefully to verify
    the correctness of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Although .NET Core supports the vast majority of the past workloads, some of
    them are not available and others have been rewritten, making the migration process
    a bit harder, but giving other advantages in return.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating ASP.NET Web Forms applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This technology is very old and considered obsolete, because the web of today
    has evolved with very different paradigms in comparison to the web technologies
    of the past. The best route to migrate this code is using the **Blazor template**,
    which allows us to run C# code inside the browser thanks to the *WebAssembly*
    support, which is now available in any modern browser. While this solution is
    not a real port, but a rewrite, it allows us to stay on C# for both the server
    and most of the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Communication Foundation (WCF)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On .NET Core, support for the **Windows Communication Foundation** (**WCF**)
    is available only for the client side, which means just consuming the WCF services.
    Nowadays, there are more performant and simpler technologies available, such as
    **gRPC** (requiring HTTP2) and **REST** (Web API). For those who still need to
    create SOAP-based web services, a community-driven open source project called
    **CoreWCF** is available on GitHub. Before you start migrating your old code using
    this library, you should verify that all of the WCF options used in your projects
    are also available on CoreWCF.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, neither .NET Core nor CoreWCF support the **WS-*** standards
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Workflow Foundation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Workflow Foundation has not been ported, but another open source project called
    **CoreWF** is available on GitHub. As we mentioned previously for WCF, you should
    verify the full availability of the features used in your projects first.
  prefs: []
  type: TYPE_NORMAL
- en: Entity Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Entity Framework 6 (EF6)** is also available on .NET Core and you should
    not have any issue in migrating this project, but it is worth mentioning that
    this technology is considered *feature complete* by Microsoft, which is now only
    developing **Entity Framework Core (EF Core)**. Depending on how your repository
    access is structured, including the model graph and the providers used in your
    project, you may want to consider migrating your access code to EF Core. In this
    case, be aware that, in .NET Core 3, many-to-many relationships are supported
    but require the intermediate entity class to be described in the model. The APIs
    in EF Core are very different but, on the other hand, they offer a lot of new
    functionalities. The roadmap for .NET 5 (which is the new name for .NET Core)
    includes a lot of new features that you may want to consider.'
  prefs: []
  type: TYPE_NORMAL
- en: For all the aforementioned reasons, you may find it easier to first migrate
    using EF6 and only later migrate to EF Core. This decision is very project dependent.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET MVC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ASP.NET MVC framework has been entirely rewritten on ASP.NET Core, but it
    still offers the same key functionalities. Unless you deeply customize and extend
    the infrastructure, the migration is definitely straightforward, but still requires
    some small rewriting of code because of the namespace and type changes.
  prefs: []
  type: TYPE_NORMAL
- en: Code Access Security APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the **Code Access Security (CAS)** APIs have been removed from .NET Core
    because the only trustable boundary is the one offered natively by the process
    hosting the code. If you are still using CAS, it is highly recommended to get
    rid of it, regardless of your .NET Core migration.
  prefs: []
  type: TYPE_NORMAL
- en: AppDomains and Remoting APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With .NET Core, there is always a single AppDomain per process. For this reason,
    you will see that most of the AppDomain APIs are gone and not available. If you
    have used AppDomains to isolate and unload certain assemblies, you should look
    at `AssemblyLoadContext`, a new API in .NET Core 3 that allows you to address
    this problem in a powerful way without requiring remoting communication, which
    has been removed from .NET Core as well.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the migration process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common step to pursue when starting the migration process from .NET Framework
    to .NET Core is updating .NET Framework to at least version 4.7.2.
  prefs: []
  type: TYPE_NORMAL
- en: Version 4.7.2 is a special version, as it was the first release to fully support
    the .NET Standard binary contract, avoiding the requirement of external NuGet
    packages needed to fill the gaps. This step shouldn't cause any issues and you
    can continue to deploy the current projects with this latest version of .NET Framework
    with no fear. Depending on the complexity of the solution, you may want to work
    on the migration while still running production code on .NET Framework until everything
    is fully tested.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the analysis should focus on external dependencies such as NuGet
    packages from third parties that you don't have control over. Once you have identified
    the newer packages, update them so that your .NET Framework solution can run on
    the newer versions. You still have a deployable solution that starts off with
    a few pieces that are compatible with .NET Core, even if you didn't change any
    lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: The Portability Analyzer Tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **API Port tool** is available on GitHub at [https://github.com/microsoft/dotnet-apiport](https://github.com/microsoft/dotnet-apiport)
    and provides us with the ability to create a detailed report of a .NET application
    that lists all the APIs used and whether they are available on other platforms.
    The tool is available both as a Visual Studio extension or via the CLI so that
    you can automate the process as desired. The ultimate report provided by the tool
    is an Excel spreadsheet containing a cross-reference of all the APIs that allows
    you to plan the migration without getting any undesirable surprises during the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can finally start updating the library projects in the solution. It is important
    to have a clear view of the dependency tree of the entire solution and packages.
    If the project is very large, you may want to leverage the power of external tools
    such as the popular **NDepend**. On the dependency tree, you should identify the
    libraries at the bottom of the tree that have no other dependencies on external
    packages—they are the best starting point.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, migrating a library with no dependencies (or a library depends
    on a package that can run on both frameworks) is straightforward. There is no
    automated support, so you should create a new **.NET Standard 2.0** project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the [https://github.com/dotnet/try-convert/releases](https://github.com/dotnet/try-convert/releases)
    repository contains the preview of a tool that is able to convert projects into
    .NET Core. As the name `try-convert` suggests, it cannot handle all types of project,
    but can still be used as a starting point for the migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrating to the new .`csproj` project structure can be done in one of two
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project and moving the source files over it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the `.csproj` file of the old project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first strategy is simpler, but it has the downside of changing the project
    name, which also implies changing the default for the namespace name and the assembly
    name. These can be renamed by making the following changes to the `.csproj` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Remember that creating a new project also implies fixing the references of all
    the dependent projects.
  prefs: []
  type: TYPE_NORMAL
- en: The second strategy consists of replacing the contents of the `.csproj` file,
    which requires you to have tested the changes prior to this on a separate project.
    When migrating the package references, be advised that new .NET Core projects
    ignore the `packages.config` file and require all the references to be specified
    in the `PackageReference` tags, as mentioned earlier in the *Consuming NuGet packages*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the missing APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the migration, you might discover some missing APIs. For this specific
    case, Microsoft created the [https://apisof.net/](https://apisof.net/) website,
    which has classified more than 700,000 APIs among those available through the
    base class library and NuGet. Thanks to its search capability, you can search
    for any class, method, property, or event and discover its usage and which platform
    and version supports it.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve migrated the lower-level dependent libraries, it is a good idea
    to create the test projects so that any migrated code gets tested on both frameworks.
    The test projects themselves shouldn''t really be migrated, as you may want to
    test the code on both frameworks. For this reason, you may want to share the test
    code in a **Shared Project** (a template available from the following screen in
    Visual Studio), which is a special project that doesn''t produce any binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5 – The Add a new project Visual Studio dialog box'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_16.5_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.5 – The Add a new project Visual Studio dialog box
  prefs: []
  type: TYPE_NORMAL
- en: All the projects referencing a Shared Project inherit its source code, as it
    was included directly. All the major test frameworks (xUnit, NUnit, and MSTest)
    have been ported to .NET Core, but there may be a few differences in the supported
    test APIs; therefore, any infrastructural code using the test API should be verified
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, if the test code uses AppDomains to unload certain assemblies, remember
    to rewrite it using the more powerful `AssemblyLoadContext` API. The migration
    should now continue by iterating over the porting libraries and their tests until
    all the infrastructure has been migrated and is working on both frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating the desktop projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WPF and Windows Forms workloads are available on .NET Core 3 and their migration
    should be straightforward. At the time of writing, the Windows Forms designer
    is available as a preview, but you can still share the designer code in the Shared
    Project mentioned previously to continue using the .NET Framework designer.
  prefs: []
  type: TYPE_NORMAL
- en: 'On .NET Core 3.1, some of the Windows Forms controls have been removed, but
    they can be replaced with newer ones exhibiting the same functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_16_Table.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another missing feature is **ClickOnce**, a deployment system that is widely
    used inside many companies. Microsoft's suggestion is to migrate the deployment
    package to the newer **MSIX** technology.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating ASP.NET projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Migrating ASP.NET MVC projects is the only workload that requires more manual
    work and code changes, but also brings many clear advantages from the newly rewritten
    ASP.NET Core framework in terms of performance and simplification, such as the
    unified `Controller` hierarchy of the **MVC** and **WebAPI** worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Before starting, I strongly suggest being familiar with the *ASP.NET Core MVC*
    framework, with particular focus on dependency injection, identity, authorization,
    configuration, and logging, the details of which go far beyond the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: To migrate a ASP.NET web project, it is always better to start from a new ASP.NET
    Core MVC template instead of tweaking the old `.csproj`, since the code won't
    run as-is and will always require some changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any code related to the ASP.NET infrastructure is the first you may want to
    migrate. For example, `Global.asax` generally contains the initialization code,
    while **HTTP Modules** and **Handlers** are infrastructural code meant to intercept
    the requests and responses. The general rules for migrating this code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Static structures or global helpers should be converted into a **Dependency
    Injection (DI)** singleton service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any code that is meant to intercept, read, or modify the HTTP requests and responses
    should become middleware and be configured in the `Startup` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify any code outside of the `Controller` logic, determine its life cycle,
    and make it available through `Controller` constructor, consider creating a factory
    instead and provide the factory through `Controller`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the old MVC framework, most of the infrastructure customization was needed
    to provide external services to the controller. This is not required anymore because
    **DI** allows controllers to require any service at any time.
  prefs: []
  type: TYPE_NORMAL
- en: A second key step is determining the identity framework infrastructure requirement.
    The new template provides a lot of enhancements, as well as basic support for
    legal *GDPR requirements*. In most cases, it is better to start from the new infrastructure
    and migrate the database, instead of just porting the old code. On NuGet, you
    will find support for many providers, starting from OAuth generic ones to social
    identity providers, OpenID specification providers, and many others. It is also
    possible to leverage the popular open source project **Identity Server**, an identity
    provider that is now part of the .NET Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization framework has changed as well and brings two important key
    features. The first is being claim-based. This presents a lot of advantages in
    comparison to the old role-based security (which has several limitations). `Claims`
    can also be used as roles whenever your checks are just Booleans, but they allow
    more complex logic structured as `Policies` inside ASP.NET Core, which is definitely
    worth adopting.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the infrastructure has been ported or converted, the application logic
    can finally be moved to the new controllers. As we mentioned previously, there
    is now a single `Controller` base class that is used for both MVC and Web API
    controllers. Matching a controller from a request is done via the routing mechanism.
    In ASP.NET Core, the routing is configured through attributes in your `Controller`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Every controller may expose one or more `Actions` that can be tagged with the
    attributes defining the HTTP verbs they are restricted to, such as `HttpGet` and
    `HttpPost`. Actions related to the HTTP `GET` verb do not take any input parameters,
    while other verbs such as `POST` and `PUT` can benefit from the *model-binding*
    feature, which automatically maps the values passed by the requests to the input
    parameters. You can find more information about model binding in the official
    documentation at [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding).
  prefs: []
  type: TYPE_NORMAL
- en: 'The response of the HTTP roundtrip depends, of course, on its HTTP verb. The
    typical return types for actions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An object representing the response value to return to the HTTP client. It will
    be serialized by the infrastructure according to the types specified by the client
    in the accept header.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Task<T>`, where `T` is the response value specified in the preceding. Tasks
    should be used whenever the content retrieval requires some "slow" access, such
    as accessing the filesystem or a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object implementing `IActionResult`, such as `OkResult` and `NotFoundResult`
    created by the homonymous method name in the `ControllerBase` class, which is
    the base class for any Controller. They are used to give full control over the
    status code and the response headers. The full list of ready-to-use `IActionResult`
    types is defined in the `Microsoft.AspNetCore.MVC` namespace. Some of these objects
    have a constructor that take the object to return, such as `OkObjectResult`, which
    returns an object as content and sets the HTTP status code to 200.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object implementing `Task<IActionResult>`, which is the asynchronous version
    of the previous case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last case is returning `void`, which lets the infrastructure return the
    default response with no content at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the code has been migrated, you have to consider the hosting environment.
    The web server for ASP.NET Core applications is called `web.config` file should
    be revised either in the new `appsettings.json` configuration file or directly
    in the code for Kestrel configurations in the `Program.cs` file.
  prefs: []
  type: TYPE_NORMAL
- en: Be advised that using IIS is still possible, but this can only be used as a
    reverse proxy and requires the use of the official ASP.NET Core IIS Module, which
    forwards all the HTTP traffic to and from the Kestrel web server.
  prefs: []
  type: TYPE_NORMAL
- en: This solution brings an excellent, improved, and cross-platform solution to
    ASP.NET Core, but if you still want to host the project on IIS, it is definitely
    possible by installing the official **ASP.NET Core IIS Module** on the hosting
    server. The module will forward all the HTTP requests and responses to the Kestrel
    web server, so most of the settings in IIS can be safely ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up the migration steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Planning a migration is certainly not always easy, but there is a clear path
    that can be applied to any group of projects. Some of the following steps may
    be harder or easier, depending on the technology they were implemented on, while
    some others are pretty straightforward and only require practicing in advance,
    but the number of available APIs make the process far easier starting from .NET
    Core version 3\. The rough steps to migrate an application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you are using the technologies available in .NET Core. You may want to
    consider a replacement when they are not but analyze the implications on the application
    architecture carefully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've decided to start the migration, upgrade all of your projects to
    the latest .NET Framework as a very first step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure all the third-party dependencies are available as .NET Standard and migrate
    your current .NET Framework projects to use them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyze your projects using the Portability Analyzer Tool or verify the availability
    of the APIs at https://apisof.net/.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time you migrate a single .NET Framework library project to .NET Standard,
    the application can be potentially merged back on the main branch and be deployed
    in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Migrate the projects by navigating the dependency tree from the ones with no
    dependencies, going all the way up to the applications referencing the ones that
    have already been migrated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At first glance, migration can look a bit scary, but there are many advantages
    that you will appreciate as soon as the application starts running on.NET Core.
    Among them, the deployment offers new, exciting, and powerful features, which
    we are going to discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "The last essential step for making an application usable outside the developer\
    \ \Lmachine is **publishing**. There are two kinds of deployment: framework-dependent\
    \ and self-contained."
  prefs: []
  type: TYPE_NORMAL
- en: '**Framework-dependent deployment (FDD)** creates a folder with all the required
    binaries needed to run the application on any computer with the same OS and the
    .NET runtime installed. FDD deployment has several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It lowers the size of the deployment folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes the security updates easy to install by an IT manager instead of the
    need to redeploy them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When deploying in Docker containers, you can start from pre-built images already
    containing the .NET runtime for the version you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other publishing option is **self-contained deployment (SCD)**, which creates/copies
    all the required files to run the application, including the runtime and all the
    base class libraries. The main advantage of SCD is that it gets rid of any requirements
    on the hosting target, enabling scenarios where you can run the application just
    by copying the folder.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, some basic libraries may be needed on certain distributions that are
    very constrained. On the [https://dot](https://dot.net/).net, you can find updated
    information about those requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the self-contained deployment scenario also has some drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: The application must be published for a specific OS and CPU architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should promptly respond to security bulletins every time the .NET Core runtime
    gets any security update. In this case, after applying the updates to the developer
    machine, you will have to rebuild and redeploy the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total deployment size is much larger.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting from .NET Core 2.2, the FDD produces automatically executable files
    instead of just `.dll` files for the main projects, while in the past, FDD applications
    needed to be run through the `dotnet run` command. Now, they are created as executables
    and also known as **Framework Dependent Executables (FDE)**, which is the default
    when publishing an application using the .NET Core 3 **SDK**.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing as an FDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to keep the deployment size compact, just make sure your version
    of choice for the .NET Core runtime is installed on the target machine and that
    you publish the application as an **FDD**. Publishing an application as an **FDD**
    from the command line is straightforward; first, you enter the project folder
    and then type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The CLI will build and publish the project, also printing the path of the publishing
    folder on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The target folder can be changed by appending the `-o` argument to the previous
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the output folder will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The publishing command can also specify the requested runtime accepting a **Runtime
    Identifier (RID)** ([https://docs.microsoft.com/en-us/dotnet/core/rid-catalog](https://docs.microsoft.com/en-us/dotnet/core/rid-catalog)).
    For example, publishing the application for Linux on the 64-bit architecture is
    done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you also specify the output folder, this will reflect the specified
    RID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `--no-self-contained` argument is needed because, by default, the application
    is published as self-contained if a runtime identifier is specified.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing as an SCD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using SCD means getting rid of any installed runtime dependencies. For this
    reason, when you decide to publish as an SCD, you also have to specify the runtime
    identifier (the target OS and CPU architecture) so that all the required runtime
    dependencies are published together with the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Publishing as an SCD just requires adding the `--self-contained` and `-r` option
    followed by the runtime identifier. The shorter version is just specifying the
    `-r` option as, by default, this turns on the self-contained options as well.
    For example, publishing a self-contained application for the 64-bit version of
    Windows is done with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output folder, in this case, will be as follows, as specified by the output
    messages of the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Whether you'll depend on the runtime installation or not is just one of the
    options when publishing. Now, we will examine other interesting possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding other publishing options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Starting from .NET Core 3, it is possible to specify a number of interesting
    options when publishing. These options can be either specified on the command
    line or even forced inside the `.csproj` file, making them the default for the
    project inside the `PropertyGroup` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Single-file publishing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Publishing as a single file is a very convenient feature that creates a single
    file for all of the project files. Having a single executable enables the possibility
    of moving the application easily through a USB key or as a download. The only
    files that cannot be embedded in the executable are the configuration files and
    the web static files (for example, HTML).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the command line that''s used to publish the application as
    a single file. Single-file publishing is compatible with FDD; in this case, you
    can append `–-no-self-contained` to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can turn on the single-file publishing option in the `.csproj`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You will immediately notice the size of the binary as particularly large because
    it contains all the dependent code, even the portions of the assemblies that you
    didn't need. What if we can get rid of all the unused methods, properties, or
    classes from inside our references? The solution comes from **IL trimming**.
  prefs: []
  type: TYPE_NORMAL
- en: IL trimming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trimming is the ability to remove all the unused code from the deployment binary.
    This feature comes from the **Mono** **IL Linker** code base. This setting requires
    the deployment to be self-contained, which, in turn, requires the runtime identifier
    to be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **PublishTrimmed** factory can be turned on when publishing on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, it can be specified in the **csproj** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When heavily using reflection, the trimmer loses the ability to understand which
    libraries and members are needed. For example, if you dynamically compose the
    member name, the trimmer can't know the members to keep or discard. In this case,
    there are other two options, `TrimmerRootAssembly` and `TrimmerRootDescription`,
    that can be used to specify the code that should not be trimmed away.
  prefs: []
  type: TYPE_NORMAL
- en: Ahead-of-Time (AOT) compilation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AOT compilation allows us to precompile the application by generating almost
    all the native CPU assembly code on the developer machine. If you have never heard
    of the **ngen** tool in .NET Framework, it was used to generate the native assembly
    code on the target machine, making the application bootstrap performance much
    faster, as the **Just-in-Time** (**JIT**) compiler was no longer needed. The AOT
    compiler has the same goal but uses a different strategy: in fact, the compilation
    is done on the developer machine and because of this, the quality of the generated
    code is lower. This is because the compiler cannot make assumptions on the CPU
    that will run the code.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to balance the lower-quality code, .NET Core 3 enables **TieredCompilation**
    by default. Whenever an application method is called more than 30 times, it is
    considered "hot" and scheduled on a remote thread to be recompiled from the **JIT
    compiler**, thereby providing better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **AOT** compilation can be enabled when publishing from the command line,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can modify the `.csproj` file to make this setting persistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The AOT compilation provides a better startup, but also requires specifying
    the runtime identifier, which means compiling for a specific OS and CPU architecture.
    This setting wipes out the advantage of IL code being deployed on multiple platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Quick JIT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every time you are worried about the need to pre-generate the native compilation
    but still need to provide a fast application bootstrap, you can enable **QuickJIT**,
    a faster **JIT** compiler that has the downside of producing less performant code.
    Once again, the tiered compilation balances the code-quality disadvantages and
    recompiles the code as soon it qualifies as a hot path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling Quick JIT from the command line is no different than the other options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Enabling Quick JIT in the **csproj** file is similar as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It is important to observe that the calls to external libraries cannot be compiled
    in native code by the AOT compiler as the libraries may be replaced with newer
    versions in the target machine, invalidating the generated code. Every time some
    code cannot be compiled as native, it will be compiled with the **JIT** on the
    target machine. For this reason, it totally makes sense to enable **AOT** and
    **QuickJIT** together.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The **ngen** compiler of .NET Framework is able to generate the assembly code
    for all the IL in the assemblies, but as soon as any dependent assembly is replaced,
    all the native code is invalidated, requiring the JIT to compile all the code.
  prefs: []
  type: TYPE_NORMAL
- en: Whether your application needs to be self-contained, single-file, or precompiled,
    there is a multitude of deployment options that .NET Core offers to make your
    application shine in every scenario, and you can now pick the one you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through all the fundamental steps to follow in order
    to build a new application using the .NET Core runtime, which is accompanied by
    an increased number of APIs. We started by looking at the new powerful command
    line that offers all the commands that can be used to control the development
    life cycle of the application. The command-line extensibility removes any limitations,
    allowing anyone to add local and global tools to the ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how the command-line commands are exactly the same when developing
    on Linux OSes, which can be used as a developer box directly or through Windows,
    as you please. In fact, the Visual Studio Code remote extensions let you develop
    and debug the code on a Linux machine from Windows.
  prefs: []
  type: TYPE_NORMAL
- en: But we also saw that .NET Core 3 is not a one-way trip, because .NET Standard
    libraries allow us to share code with all the recent runtimes, making it easier
    to reuse the code. In addition to that, the very rich ecosystem of NuGet packages
    makes consuming libraries straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adopting the new runtime is not that hard: some applications can be migrated
    by just converting the project file, while others require more coding, but the
    resulting application will benefit from the new ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we examined the complete set of possibilities when publishing
    an application, which is the culmination of the application development process.
    At this point, you are able to transform ideas and algorithms into a running application,
    possibly running on the most popular OSes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about unit testing, a practice that is extremely
    important for guaranteeing code quality across time and providing proof that future
    development iterations will not introduce breaking changes or regressions.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After installing five different SDKs, how can you tell the CLI to use a specific
    version for an entire solution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you concatenate some paths so that they work correctly on both Windows
    and Linux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you share some code among three different applications based on .NET
    Framework, .NET Core 3, and Xamarin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the fastest method for a new library project to add the exact same references
    to an existing one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When migrating a complex solution, where should we start?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What deployment options guarantee faster application startup time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Visual Studio Code extensions to compile and debug a project on a remote
    Linux or WSL session, can be found at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-wsl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to create NuGet packages containing multiple binaries, each of
    them targeting a different CPU architecture or framework version is described
    at the following link: [https://docs.microsoft.com/en-us/nuget/create-packages/supporting-multiple-target-frameworks](https://docs.microsoft.com/en-us/nuget/create-packages/supporting-multiple-target-frameworks).'
  prefs: []
  type: TYPE_NORMAL
