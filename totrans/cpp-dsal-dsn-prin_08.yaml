- en: 8\. Dynamic Programming I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyze whether the dynamic programming approach can be applied to a given problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compare and choose the right approach between memoization and tabulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose an appropriate caching solution using memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze a problem using a naive brute-force approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a dynamic programming solution by implementing progressively optimized
    algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the dynamic programming approach.
    This chapter will guide you through implementing this approach for solving some
    well-known problems in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loved and feared in equal measure by many programmers, **dynamic programming**
    (**DP**) is a conceptual extension of the divide-and-conquer paradigm that pertains
    to a specific class of problems. The difficulties involved in dynamic programming
    problems are multi-faceted and often require creativity, patience, and the ability
    to visualize abstract concepts. However, the challenges these problems pose frequently
    have elegant and surprisingly simple solutions, which can provide a programmer
    with insights that reach far beyond the scope of the immediate task.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed several techniques, such as the divide-and-conquer
    and the greedy approach. These approaches, though quite effective in the right
    circumstances, will not produce optimal results in certain situations. For example,
    in the previous chapter, we discussed how Dijkstra's algorithm does not produce
    optimal results for graphs with negative edge weights, whereas the Bellman-Ford
    algorithm does. For problems that can be solved recursively, but cannot be solved
    using the aforementioned techniques, a DP solution may often be the best approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'DP problems are also encountered in a wide variety of situations. Here are
    just a few broad examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Combinatorics (counting the number of combinations/permutations of a sequence
    matching certain criteria)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings/arrays (edit distance, longest common subsequence, longest increasing
    subsequence, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphs (shortest path problem)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning (speech/face recognition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by understanding the basic idea of dynamic programming.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Dynamic Programming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to answer this question is by example. To illustrate the purpose
    of dynamic programming, let''s consider the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By observing the preceding sequence, we can see that, beginning with the third
    element, each term is equal to the sum of the two preceding terms. This can be
    simply expressed with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can clearly see, the terms of this sequence have a recursive relationship
    – the current term, *F(n)*, is based on the results of previous terms, *F(n-1)*
    and *F(n-2)*, and thus the preceding equation, that is, *F(n) = F(n-1) + F(n-2)*,
    is described as the **recurrence relation** of the sequence. The initial terms,
    *F(0)* and *F(1)*, are described as the **base cases**, or the points in which
    a solution is produced without the need to recurse further. These operations are
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: Computing the nth term in the Fibonacci sequence](img/C14498_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Computing the nth term in the Fibonacci sequence'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Describing the preceding figure in English might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We describe the preceding approach as a **top-down solution** because it begins
    at the top of the recursion tree (that is, the solution) and traverses down its
    branches until it reaches the base cases. In C++, this could be written using
    the following recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By observing the tree further, we can see that several **subproblems**, or intermediate
    problems that must be solved to find the ultimate solution, must be solved more
    than once. For example, the solution for *F(2)* must be found to get the solution
    for *F(4) [F(3) + F(2)]* and *F(3) [F(2) + F(1)]*. Thus, the Fibonacci sequence
    is said to exhibit a property known as **overlapping subproblems**. This is one
    of the defining characteristics that separate a standard divide-and-conquer problem
    from a dynamic programming problem; in the former, subproblems tend to be unique,
    whereas in the latter, the same subproblems must be solved repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that several of the solution branches are completely identical
    to each other. For example, finding the solution for *F(2)* is going to require
    the same set of calculations, regardless of whether you need it to solve *F(4)*
    or *F(3)*. This demonstrates the second defining characteristic of dynamic programming
    problems, which is known as the optimal substructure. A problem is said to exhibit
    an **optimal substructure** when the optimal solution to the overall problem can
    be formed through some combination of the optimal solutions of its subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: For a problem to be solvable using dynamic programming, it must possess these
    two properties. Because of the overlapping subproblems property, the complexity
    of these problems tends to increase exponentially as the input increases; however,
    exploiting the optimal substructure property makes it possible to reduce the complexity
    significantly. So, in essence, the purpose of DP is to devise a method of caching
    previous solutions as a means to avoid the repeated calculation of previously
    solved subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization – The Top-Down Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No, this is not "memorization," though that would also describe this technique
    quite accurately. Using memoization, we can reformulate the top-down solution
    we described previously to make use of the optimal substructure property exhibited
    by the Fibonacci sequence. Our program logic will essentially be the same as it
    was before, only now, after having found the solution at every step, we will cache
    the results in an array, indexed according to the current value of *n* (in this
    problem, *n* represents the **state** or set of parameters defining the current
    recursive branch). At the very beginning of each function call, we will check
    to see whether we have a solution available in the cache for state *F(n)*. If
    so, we will simply return the cached value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The recursion tree now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Computing the nth term in the Fibonacci sequence using cached
    solutions](img/C14498_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Computing the nth term in the Fibonacci sequence using cached solutions'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By doing this, we have eliminated quite a bit of redundant work. This technique
    of recursively caching solutions in a top-down manner is known as **memoization**,
    and can essentially be employed for any DP problem, assuming the following are
    true:'
  prefs: []
  type: TYPE_NORMAL
- en: You can devise a caching scheme that exploits the similarity of different states
    while preserving their uniqueness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can accumulate the solutions for the requisite subproblems before exceeding
    the available stack space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first point means that the method of indexing results for later use should
    be both valid and useful. In order for a caching scheme to be valid, it must only
    be considered a match for states whose solutions are derived from the same series
    of subproblems; in order for it to be useful, it must not be so state-specific
    that it cannot be effectively used (for example, if every subproblem is assigned
    a unique index in the cache, the conditional "`if(memo[KEY] != UNKNOWN)`" will
    never be true).
  prefs: []
  type: TYPE_NORMAL
- en: The second point refers to the possibility of causing a stack overflow error,
    which is a fundamental limitation of any top-down approach if the number of recursive
    calls is likely to be very high. A stack overflow occurs when a program exceeds
    the allotted amount of memory that's available on the call stack. Depending on
    the nature of a given problem, it is possible that the depth of recursion that's
    required may prevent memoization from being a viable option; as always, it is
    quite beneficial to assess the potential complexity of the task at hand before
    choosing an approach.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization is frequently a decent optimization method for DP problems. However,
    in many cases, a better option is available, which we will study in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Tabulation – the Bottom-Up Approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *heart* of dynamic programming is tabulation, which is the inverse approach
    to memoization. In fact, though the term *dynamic programming* is sometimes applied
    to both memoization and tabulation, its use is generally assumed to refer specifically
    to the latter.
  prefs: []
  type: TYPE_NORMAL
- en: The standard implementation of tabulation consists of storing the solutions
    for the base cases and then iteratively filling a table with the solutions for
    every subproblem, which can then be reused to find the solutions for other subproblems.
    Tabulated solutions are generally considered to be a bit harder to conceptualize
    than memoized ones because the state of each subproblem must be represented in
    a way that can be expressed iteratively.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tabulated solution to computing the Fibonacci sequence would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the Fibonacci example, the state is quite simple since it's one-dimensional
    and unconditional — the formula always holds that, for any n greater than *1*,
    *F(n) = F(n-1) + F(n-2)*. However, DP problems often contain several dimensions
    that define a given state and may have multiple conditions that affect how states
    transition between each other. In such cases, determining how to represent the
    current state may require a fair amount of creativity, in addition to a comprehensive
    understanding of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of tabulation, however, are significant. In addition to the fact
    that tabulated solutions frequently tend to be much more efficient in terms of
    memory, they also produce a complete lookup table encompassing every given state.
    Therefore, if you are likely to receive queries about any state of the problem,
    tabulation is likely to be your best option.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, any problem that can be solved with memoization can theoretically
    be reformulated into a tabulated solution, and vice versa. Using the former can
    often provide immense insight into how to approach the latter. Over the next few
    sections, we will explore several classical examples of dynamic programming problems
    and demonstrate how employing multiple approaches (beginning with naive brute
    force) can lead you to the level of understanding that's required for the tabulated
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Subset Sum Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you are implementing the logic for a digital cash register. Whenever
    a customer needs change, you would like to display a message that tells the cashier
    whether or not the money currently in the register can be combined in some way
    so that its sum is equal to the amount of change required. For example, if a product
    costs $7.50 and the customer pays $10.00, the message would report whether the
    money in the register can be used to produce exactly $2.50 in change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that the register currently contains ten quarters (10 x $0.25),
    four dimes (4 x $0.10), and six nickels (6 x $0.05). We can easily conclude that
    the target sum of $2.50 can be formed in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these parameters, the problem is rather straightforward and can be solved
    by simply trying all the available combinations of money until a sum matching
    $2.50 is found. But what if the change that's required is $337.81, and the register
    contains 100 banknotes/coins divided into denominations of $20.00, $10.00, $5.00,
    $1.00, $0.25, $0.10, $0.05, and $0.01? We can clearly see that trying every possible
    sum becomes quite impractical as the complexity increases. This is an example
    of a classic problem known as the subset sum problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its most basic form, the `S`, and an integer, `x`, is there a subset of
    `S`''s elements whose sum is equal to `x`? Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding set as an example, we can find the following 16 subsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By listing the total amount of subsets that can be produced for sets of different
    sizes, we get the following numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From this list, we can deduce that the total number of subsets that can be formed
    from a set of size `n` is equal to *2**n*, which demonstrates that the number
    of subsets to consider increases exponentially with the size of *n*. Assuming
    the number of elements in *S* is small, say 10 elements or less, a brute-force
    approach to this problem could find the solution rather quickly; but if we reconsider
    the example of a cash register containing 100 different banknotes/coins, the size
    of *S* would be equal to 100, which would require exploring 1,267,650,600,228,229,401,496,703,205,376
    subsets!
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the Subset Sum Problem – Step 1: Evaluating the Need for DP'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first step when faced with a problem like this is to determine whether
    it can (and/or should) be solved with DP. To reiterate, a problem is solvable
    with DP if it has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overlapping subproblems**: Like the standard divide-and-conquer approach,
    the final solution can be derived by combining the solutions of smaller subproblems
    in some way; in contrast to divide and conquer, however, certain subproblems will
    be encountered multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimal substructure**: The optimal solution for a given problem can be produced
    by the optimal solutions of its subproblems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s analyze the preceding example in terms of whether or not it possesses
    these characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Optimal substructure and overlapping subproblems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: ''''
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Figure 8.3: Optimal substructure and overlapping subproblems'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reformatting the collection of subsets as shown clearly illustrates how each
    new subset of size n is formed by appending a single new element to a subset of
    size `n - 1`. This is the optimal approach for constructing a new subset and holds
    true for every subset of size greater than 0\. Thus, the subset sum problem has
    an **optimal substructure**. We can also see that several subsets are derived
    from the same "subsubset" (for example, both *{ 13 79 45 }* and *{ 13 79 29 }*
    are based on *{ 13 79 }*). Therefore, the problem also has **overlapping subproblems**.
  prefs: []
  type: TYPE_NORMAL
- en: Having satisfied both of our criteria, we can conclude that this problem can
    be solved with dynamic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Defining the States and the Base Cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having determined that this is a DP problem, we now must determine what constitutes
    a state within the context of this problem. In other words, in terms of the question
    that we are trying to answer, what makes one possible solution different from
    another?
  prefs: []
  type: TYPE_NORMAL
- en: Though it is generally advisable to consider these aspects of the problem early
    in the process, it is often quite difficult to define the states of a DP problem
    without having a clear understanding of how the ultimate result is formed, and
    thus it is often quite helpful to start by implementing a solution in the most
    straightforward way possible. Therefore, we will develop our understanding of
    the subset sum problem's base case(s) and states by solving it in two different
    ways that are much simpler to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout our exploration of dynamic programming, we will consider a total
    of four different approaches to each problem: **brute force**, **backtracking**,
    **memoization**, and **tabulation**. As with any DP problem, all of these approaches
    are capable of producing the correct result, but the first three quickly demonstrate
    their limitations as the size of the input increases. Nevertheless, implementing
    progressively optimized solutions in this way can be used to great effect when
    tackling any dynamic programming problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2.a: Brute Force'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Despite its inefficiency, a brute-force solution can be quite informative in
    developing an understanding of the problem at hand. Implementing brute-force approaches
    can be an essential step in the process of forming a DP solution for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: The simplicity of writing a solution without any consideration
    of its efficiency can be an excellent way to develop an understanding of the fundamental
    aspects of the problem; it can also lead to insights about the problem''s nature
    that may otherwise be missed in the act of trying to comprehend its complexity
    without sufficient context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The certainty of solution correctness**: Oftentimes, a particularly complex
    DP solution will require quite a bit of redesign as the problem is better understood.
    Because of this, it is essential to have a way to compare your solution''s output
    to the correct answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ability to visualize the subproblems**: A brute-force solution will generate
    every potential solution and then choose the ones that meet the criteria of the
    problem. This provides an effective means for visualizing how a correct solution
    is formed, which can then be inspected for essential patterns that can be used
    in later approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following exercise demonstrates the implementation of the brute-force approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 36: Solving the Subset Sum Problem by Using the Brute-Force Approach'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall find a solution to the subset sum problem using
    the brute-force approach. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by including the following headers (and the `std` namespace for
    convenience):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, let''s define a preprocessor constant called `DEBUG` and a macro
    called `PRINT`, which will print to `stderr` only if `DEBUG` is not zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now declare a new function, `SubsetSum_BruteForce()`, that takes two
    arguments — an array of integers, `set`, and an integer, `sum` — and returns a
    Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare another function, `GetAllSubsets()`, which takes four arguments
    — two integer vectors, `set` and `subset`; an integer; `index`; and a three-dimensional
    vector of integers called `allSubsets` (passed by reference). We will use this
    function to generate all subsets of *S* recursively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to our `SubsetSum_BruteForce()` function, we can now declare `allSubsets`
    and call the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can iterate through each subset and compare its sum to `target`, returning
    `true` if a match is found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If a matching sum is not found after checking every subset, we return `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `main()` function, let''s define our set and target as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call `SubsetSum_BruteForce()` with these inputs like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon running the preceding code, you should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s set `target` to a sum that is not found in the set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program again should produce the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s redefine our `DEBUG` constant to 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program now will produce the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we are able to find the required subset using the brute-force approach.
    Note that we are basically trying out every possibility in order to find the solution.
    In the following section, we shall apply one layer of optimization over it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2.b: Optimizing Our Approach – Backtracking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clearly, the brute-force approach leaves a lot to be desired. In terms of performance,
    it is about as inefficient as it possibly could be. By indiscriminately checking
    every possible subset, we consider options long after the point where we could
    determine that they will never lead to a solution (for example, subsets with sums
    exceeding the target). To improve our algorithm, we can utilize **backtracking**
    to exclude all the branches of subproblems that are guaranteed to be invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of implementing a backtracking solution before attempting
    to use DP is that it requires us to determine the base case(s) and intermediate
    recursive states of the problem. As we defined earlier in this chapter, a base
    case is a condition in a recursive function that does not rely on further recursion
    to produce an answer. For further clarification, consider the problem of calculating
    the factorial of a number (the factorial of a number, *n*, is equivalent to *n
    * (n-1) * (n-2) * (n-3) … * 1*). We could code a C++ function that accomplishes
    this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of this recursive function can be illustrated like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4: Recursively calculating the Nth factorial](img/C14498_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Recursively calculating the Nth factorial'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `n = 1` condition is the base case because that is the point at which the
    solution can be returned without recursing further.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the subset sum problem, one way to define our base cases would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have established base cases, we need to define our intermediate
    states. Using our brute-force algorithm''s output as a reference, we can analyze
    how subsets of each size group are formed to plot out our state transitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the size `0` and size `1` states are the simplest to understand.
    We begin with an empty set and we can add any of the elements to it in order to
    create all subsets of size 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can follow the same line of logic for size 2 subsets. Simply take each subset
    of size 1 and append every element whose index is greater than the highest-indexed
    element already in the subset. This is essentially the approach we took in our
    brute-force implementation; however, this time, we will consider the sum of each
    subset as we process them, and terminating them when the current sum exceeds the
    target:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Eliminating values that exceed the target](img/C14498_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Eliminating values that exceed the target'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When `target` is equal to `58`, we can see that none of the subsets of size
    3 or 4 need to be considered. Thus, we can describe our intermediate state transition
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should ask the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the minimal amount of data needed to represent this state?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we reformulate the preceding logic to remove unnecessary information?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the specific problem we are trying to solve: finding whether a subset
    of elements exists within the set whose sum is equal to the target. According
    to the problem description, our task does not require that we produce the actual
    subsets, but only their sums. So, our pseudocode could be more succinctly expressed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using this new approach, we can essentially represent each state transition
    with only two integers, `sum` and `i`, eliminating the need to store *2**n* subset
    arrays in the worst case. Furthermore, we can remove the need to keep track of
    the target value by inverting the problem (that is, starting at `target` and subtracting
    `set[i]` at each step). As a final optimization, we can sort the set before calling
    the function, which allows us to determine that there are no other valid possibilities
    as soon as the sum exceeds the target. We'll implement this in C++ in the following
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 37: Solving the Subset Sum Problem by Using Backtracking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall solve a problem similar to the one demonstrated
    in *Exercise 36*, *Solving the Subset Sum Problem by Using the Brute-Force Approach*,
    but using a backtracking approach and a more complex input to highlight the differences.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the backtracking solution for the subset sum problem, we define
    a function called `SubsetSum_Backtracking()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As is often the case in recursive functions, we define our base cases at the
    very beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At each step, our options are to add the current element''s value to the sum,
    or to keep the sum as-is. We can condense this logic into one line like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning to `main`, let''s sort the set and add our call to `SubsetSum_Backtracking()`
    underneath the call to `SubsetSum_BruteForce()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of testing, we will implement a function that will display the
    time each approach takes to find the solution. First, we will need to include
    the `<time.h>` and `<iomanip>` headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also define an array of strings called `types`, which we will use to
    label the results of each approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write another function, `GetTime()`, that takes a reference to
    a `clock_t` object called `timer` and a `string type`, and then returns `void`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s rewrite the `main()` function so that we can perform each function
    call sequentially and compare the time taken by each approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s redefine our input to highlight the difference in efficiency
    between the two approaches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output will produce something along the lines of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The actual values for the time taken would vary depending on your system. Please
    note the difference in the values.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, in this particular case, the answer was found over 1,000 times
    faster using the backtracking approach. In the following section, we shall optimize
    this solution further by making use of caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Memoization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though significantly better than brute force, the backtracking solution is still
    far from ideal. Consider a case where the target sum is high and not in the set
    — if the target is greater than or equal to the sum of every element in the set,
    we could easily determine the result by calculating the total in advance and checking
    that the target is within the valid range. However, if the target sum is just
    slightly under this amount, our algorithm will still be forced to explore practically
    every possibility before finishing.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this difference, try running your code from the previous exercise
    using `6799` as the target (exactly 1 less than the total sum of all the elements
    of the set). On the author's machine, the backtracking solution took about 0.268
    seconds on average to produce the result – nearly 350 times longer than the average
    time taken with the target value used in the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we already have all the information we need to devise a top-down
    solution while utilizing memoization. Even better, we hardly have to modify our
    previous approach at all to implement it!
  prefs: []
  type: TYPE_NORMAL
- en: Devising a Caching Scheme
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most important aspect of using memoization is to define a caching scheme.
    Caching results for memoized solutions can be done in a number of ways, but the
    most common are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple arrays, with states represented by numerical indices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables/maps, with states represented by descriptive strings that are hashed
    using built-in language features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables/maps, with states represented by hash values that are created using
    an original hashing formula
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The choice to make here is largely context-dependent, but here are some general
    guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays/vectors that are accessed by a numerical index tend to be much faster
    than maps, which must locate a given key in the map in order to determine whether
    or not it has already been cached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even when states can be represented as integers, if the cache keys are quite
    large, the memory requirements of an array large enough to encompass them may
    be unreasonable. In this case, maps are a better option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash tables (for example, `std::unordered_map`) tend to be much faster than
    standard map/dictionary structures for locating and retrieving keys (but are still
    slower than arrays).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::map` is much more versatile than `std::unordered_map` in terms of what
    types of data can be used as keys. Although `std::unordered_map` can technically
    offer the same functionality, it requires the programmer to create their own hashing
    function for data types it is not equipped to store as keys by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you may recall from the introduction to this chapter, a caching scheme should
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Valid**: Cache keys must be represented in a way that avoids collisions between
    different states that are not used to solve the same set of subproblems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worthwhile/useful**: If your caching scheme is so specific that it never
    actually produces any "hits", then it essentially accomplishes nothing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the subset sum problem, we may mistakenly come to believe that failing to
    find the target from a state with a given `sum` value means that it would be impossible
    to get a true result from any other state with the same sum. Therefore, we may
    decide to cache every solution based solely on the value of `sum` (that is, `if(memo[sum]
    != UNKNOWN) return memo[sum];`). This is an example of an invalid caching scheme
    because it fails to take into account the fact that there may be multiple ways
    to reach the same sum within the same set, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the target value is `8` in the preceding example. If the third case
    is encountered first, `memo[6]` would be set to `false`, which is obviously incorrect
    since the target can be reached from both of the other cases by including the
    4th element (`2`).
  prefs: []
  type: TYPE_NORMAL
- en: An example of a useless memoization scheme would be one where the keys are equal
    to the indices of the subset because every possible state will contain a completely
    unique key; as a result, states that are formed from the same set of subproblems
    will not trigger a cache hit.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure about the efficacy of your caching scheme, it can be useful
    to store a counter that increments on every cache hit. If the final value of this
    counter is equal to `0`, or is very low relative to the number of states you have
    to consider, you can conclude that your caching scheme needs revision.
  prefs: []
  type: TYPE_NORMAL
- en: We shall explore the implementation of memoization with the use of a vector
    for caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 38: Solving the Subset Sum Problem by Using Memoization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall try to implement the same solution that we implemented
    in *Exercise 37*, *Solving the Subset Sum Problem by Using Backtracking*, but
    with the addition of memoization. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create another function called `SubsetSum_Memoization()`. The definition
    for this function will be identical to `SubsetSub_Backtracking()`, except that
    it will include a reference to a two-dimensional integer vector called `memo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Much of our code for this function will look quite similar to the backtracking
    approach. For example, our base cases will be defined exactly like they were previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the pivotal difference is that after the base cases, rather than immediately
    investigating the next two states, we check the `memo` table for cached results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should insert a call to `SubsetSum_Memoization()` in the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define `target` as `6799` and run our code. You should see an output
    similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The actual values for time taken would vary depending on your system. Please
    note the difference in the values.
  prefs: []
  type: TYPE_NORMAL
- en: We can see from the output that caching has optimized our problem by an exponential
    factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Tabulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have implemented three different algorithmic approaches to solving
    the subset sum problem, each of which has a significant improvement over the one
    preceding it. However, let's say that we wanted a list of every possible subset
    sum in a given set. We would have to run our algorithm repeatedly for each sum,
    from 1 to the total sum of the entire set. For situations such as these, tabulation
    is often the only efficient option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing an iterative tabulated solution to a problem like this is often
    rather hard to conceptualize. Whereas recursive formulations of a problem lend
    themselves well to multidimensional states and branching conditions, a tabulated
    solution has to somehow condense the layers of complexity into a simple set of
    iterations using the standard `for`/`while` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Depiction of how the complexity of the subset sum problem’s recursive
    structure is reduced in the tabulated DP solution](img/C14498_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Depiction of how the complexity of the subset sum problem''s recursive
    structure is reduced in the tabulated DP solution'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are several methods for tackling this reduction, but ultimately it tends
    to come down to whether or not you understand the problem well enough to make
    the correct generalizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like memoization, the first goal after defining the base case(s) and states
    of the problem is to develop a scheme for storing the solutions for different
    states. Typically, tabulated approaches use simple arrays/vectors for this purpose.
    We have already looked at an example of a very simple DP table in the calculation
    of the Fibonacci sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier in this chapter, we also discussed how to calculate factorials recursively.
    A bottom-up approach to filling the table for that problem would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These are very simple examples because they only contain a single dimension
    and no conditional logic. Each state has a consistent, predictable formula from
    beginning to end.
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference between those examples and the subset sum problem is
    that the minimal way to represent each state uniquely in the latter requires two
    dimensions — the index in the set and the current sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider some of the insights we have gained about this problem in greater
    depth:'
  prefs: []
  type: TYPE_NORMAL
- en: Each possible subset of size `k` can be formed by taking new elements and appending
    them onto every subset of size `k – 1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a solution has been found at index `i` with a sum value of `x`, then any
    sequence of state transitions that eventually lead to that same set of conditions
    will produce an identical result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.7: Multiple paths with the same sum value on the same index value](img/C14498_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Multiple paths with the same sum value on the same index value'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both of these recursive paths have a sum value equal to `8` and an index value
    equal to `3` at the states indicated in red which, due the optimal substructure
    of the subset sum problem, means that the solution for that state only needs to
    be found once — its result will be the same any time those conditions are arrived
    at, regardless of what occurred before.
  prefs: []
  type: TYPE_NORMAL
- en: With these facts in mind, we can essentially invert our top-down approach to
    develop the bottom-up approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-down logic:**'
  prefs: []
  type: TYPE_NORMAL
- en: Start at the target sum and the first index of the set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: - If the sum is reduced to zero, the result is `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: - If the end of the set is reached or the target is exceeded, the result is
    `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: - Otherwise, you can either subtract the current value from the sum or ignore
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If the target can be found from state `S`, where the sum is equal to `x` and
    the index is equal to `i`, then the target can also be found from any earlier
    state that eventually leads to the state `S`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bottom-up logic:**'
  prefs: []
  type: TYPE_NORMAL
- en: Start with sum and index values equal to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: - If a sum equal to `x` can be found between indices `0` and `i`, then a sum
    equal to `x` can also be found between indices `0` and `i+1`.
  prefs: []
  type: TYPE_NORMAL
- en: - If a sum equal to `x` can be found between indices `0` and `i`, then a sum
    equal to `x + set[i]` can be found between indices `0` and `i+1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of how the table is filled, the top-down approach can be described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the sum equals `x` and index equals `i` at state S1, the value of `memo(i,
    x) = true` if either of the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: - The target can be found from state S2 (where the sum equals `x – set[i]` and
    index equals `i + 1`), OR…
  prefs: []
  type: TYPE_NORMAL
- en: - The target can be found from state S3 (where the sum equals `x` and index
    equals `i + 1`)
  prefs: []
  type: TYPE_NORMAL
- en: - Otherwise, `memo(i, x) = false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom-up version of this logic would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the sum equals `x` and index equals `i`, the value of `DP(i, x) = true`
    if either of the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: - `x` is less than the value of `set[i]` and `DP(i-1, x) = true`
  prefs: []
  type: TYPE_NORMAL
- en: - `x` is greater than, or equal to, the value of `set[i]` and `DP(i-1, sum)
    = true OR DP(i-1, sum – set[i]) = true`
  prefs: []
  type: TYPE_NORMAL
- en: - Otherwise, `DP(i, x) = false`.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if we have already determined that a sum, `x`, can be formed
    between indices `0` and `i` (inclusive), then clearly, a sum equal to both `x`
    and `x + set[i]` can be formed between indices `0` and `i + 1`. We'll take a look
    at the implementation of this in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 39: Solving the Subset Sum Problem by Using Tabulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall modify the solution for *Exercise 38*, *Solving
    the Subset Sum Problem by Using Memoization*, so that we can use tabulation by
    converting the logic from top-down to bottom-up. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define a new function called — you guessed it — `SubsetSum_Tabulation()`
    that takes an integer vector called `set` as an argument and returns a two-dimensional
    Boolean vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare a two-dimensional Boolean vector called `DP`. The first dimension''s
    size should be equal to the length of `set`, and the second dimension''s size
    should be equal to the highest possible subset sum in the set (that is, the total
    sum of all elements) plus one. Every value of DP should be initialized to `false`,
    except for the base cases (that is, the sum is equal to zero):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we iterate across two nested `for` loops, corresponding to the first and
    second dimensions of the `DP` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to fill the table, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we once again modify the `main()` function to include our tabulated solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an output something like the one shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The actual values for the time taken will vary depending on your system. Please
    note the difference in the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the time taken by the tabulated solution is longer than both
    the memoization and backtracking solutions. However, using the DP table returned
    by `SubsetSum_Tabulation()`, we can use the following code to find every possible
    subset sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this should begin and end like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we have optimized the solution and also obtained the sum values of all
    the states.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we've explored a variety of ways of solving the subset
    sum problem, which, in turn, demonstrated the clear superiority of the dynamic
    programming approach; however, despite the comparative advantages that DP solutions
    have over the alternatives, we also demonstrated how the naive and relatively
    inefficient approaches can help us better understand the problem, which greatly
    simplifies the process of devising a solution using DP.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the logic that's required by dynamic programming solutions may initially
    appear to be quite complex and difficult to grasp. It is highly recommended that
    you fully understand each solution approach we discussed in this section before
    proceeding further, since this is a process that can be accelerated by using different
    input parameters and comparing the results. Additionally, drawing diagrams of
    how different solutions are formed from given inputs can be particularly helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 18: Travel Itinerary'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are designing a web application for a travel agency that wants to help clients
    plan their holiday itineraries. A major aspect of this software concerns route
    planning, which allows users to specify multiple locations they would like to
    visit and then view a list of cities they would have to pass through en route
    to their final destination.
  prefs: []
  type: TYPE_NORMAL
- en: Your agency has contracts with specific transportation companies in every major
    city, and each transportation company has set limits on how far they can travel.
    Whereas a plane or train can traverse multiple cities and even entire countries,
    a bus or taxi service may only be willing to travel one or two cities beyond their
    initial location. When your software produces the list of possible intermediate
    stops, it also displays the maximum number of cities the transportation company
    at that location is willing to travel so that clients can plot their course accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: You recently realized that your application needs some method of allowing clients
    to filter the number of options presented to them since many popular tourist locations
    are separated by dense clusters of towns. To do this, you want to determine the
    total number of possible ways to reach the ultimate destination from a given starting
    location so that you can reduce the amount of information that's displayed when
    it becomes excessive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your application already has the capability to calculate the list of locations
    on the ideal route between a departure point and destination. From this, you have
    derived the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`N`: An integer representing the number of cities between the source and the
    destination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distance`: An array of integers representing the maximum number of cities
    the transportation company at each location is willing to traverse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your task is to implement an algorithm that will calculate the total number
    of possible ways that the destination can be reached by traveling through a sequence
    of intermediate locations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains a single integer, `N`, the number of cities between
    the starting point, and the destination.
  prefs: []
  type: TYPE_NORMAL
- en: The second line contains `N` space-separated integers, where each integer, di,
    represents the maximum distance that can be traveled starting from the city at
    index `i`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: Your program should output a single integer and the total number of ways to
    traverse the cities beginning at index `0` and ending at index `N`. Because the
    values get quite large as `N` increases, output each result as `modulo 1000000007`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you were given the following input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This means there are a total of six cities between the source and target locations.
    From a given city at index `i`, you have the option of traveling to any other
    city within the range of `i + 1` to `i + distance[i]` (inclusive). If we were
    to think of the sequence of cities as a graph, the adjacencies for the preceding
    example would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the following figure for further clarification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Example of city adjacencies](img/C14498_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Example of city adjacencies'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding example, the destination can be reached in the following ways
    (with `E` representing the end point):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This gives us an answer of `9`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the traversal always starts at index `0` and ends at index `N`.
    It is guaranteed that the sum of a city's index `i` with `distance[i]` will never
    be greater than `N`, and that every city will have a corresponding distance value
    of at least `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test cases should help you to understand this problem better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: Activity 18 simple test cases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.9: Activity 18 simple test cases'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here are some more complex test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: Activity 18 complex test cases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10: Activity 18 complex test cases'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Extra Credit**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have found an approach that passes the preceding test cases within
    reasonable time limits, you can truly test the efficiency of your algorithm with
    one final test case, with `N` equal to `10000000`. Because the number of values
    would take too much space to print, you can use the following code to generate
    the array values programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Your program should print `318948158` as the result of this test case. An optimal
    algorithm should be able to find the result in under one second.
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity Guidelines**'
  prefs: []
  type: TYPE_NORMAL
- en: An optimal approach will run in `O(n)` time and require exactly `n` iterations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are completely unsure as to how to formulate the DP solution, use the
    incremental approach that was described in this chapter, that is, by using brute
    force first and then progressively optimizing the solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For insights into how the problem's states are formed, consider the recurrence
    relation exhibited by the Fibonacci sequence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 556.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Programming on Strings and Sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our exploration of dynamic programming has primarily focused on combinatorial
    problems and calculating terms of integer sequences with defined formulae. Now,
    we will consider another one of DP's most common uses, that is, working with patterns
    in sequences of data. The most typical scenarios in which a programmer would use
    DP for this purpose generally concern searching, comparing, and constructing strings.
  prefs: []
  type: TYPE_NORMAL
- en: As software developers, we often work collaboratively with several individuals
    who all have the ability to make contributions and modifications to the same project.
    Since the possibility always exists that a programmer may inadvertently introduce
    a bug into the code, or that the team may try a different approach for a given
    feature and then decide to return to their original method, it becomes extremely
    important to have some system of version control. In the event that a feature
    that was working recently mysteriously develops a glitch, it is essential to have
    the ability to see the changes that were made to the code, particularly in terms
    of how they differ from an earlier version. All version control systems therefore
    have a "diff" feature that analyzes the similarity between two versions of the
    same code and then displays this in some way to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you had added the following code to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'On the following day, you made some changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'A diff utility would then display something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: Diff utility output](img/C14498_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Diff utility output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To accomplish this, the utility needs to compute the similarity of the two code
    files by taking into account the fact that the sequence of text that is common
    to both versions may not necessarily be contiguous in the string. Additionally,
    parts of the original text may have been removed or appear in additional locations
    in the new version. This demonstrates the need for **approximate** (or "**fuzzy**")
    **string matching**, a technique that frequently makes use of dynamic programming.
  prefs: []
  type: TYPE_NORMAL
- en: The Longest Common Subsequence Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **longest common subsequence problem** (commonly abbreviated as **LCS**)
    is one of the most famous classical examples of dynamic programming. It answers
    the following question: given two sequences of data, what is the longest subsequence
    common to both of them?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider two strings, `A` and `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: Two given strings for finding the longest common subsequence](img/C14498_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Two given strings for finding the longest common subsequence'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The longest common subsequence would be "`LONGEST`":'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13: Longest common subsequence in the given strings](img/C14498_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Longest common subsequence in the given strings'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Equipped with the insights that we've gained from the series of approaches we
    implemented for the subset sum problem, let's be a bit smarter about how we attack
    this one. We will start by formulating some ideas about the structure of the problem
    in advance, starting with the base cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it tends to be quite difficult to understand the nature of a DP problem
    for large inputs without first having considered the trivial ones, let''s create
    some examples of different scenarios using small input strings and try to find
    the length of the longest common subsequence (LCS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where either or both strings are empty, it should be fairly obvious
    that the length of the longest common subsequence will always be equal to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'These two cases have a simple binary definition – either they have a common
    character, or they do not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Things become a bit more interesting with strings of length 2, but the logic
    is still quite trivial. Given two strings of length 2, they either are identical,
    have one character in common, or have no characters in common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the complexity of the problem is beginning to emerge. This case demonstrates
    that the comparisons progressively become much less straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, it should be fairly obvious that the LCS problem does indeed contain
    overlapping subproblems. Similar to the previous problem, we can observe that
    there are 2n possible subsets of a given string, with `n` being equal to the string''s
    length, except now we have two sequences to contend with. Even worse is the fact
    that we are not simply considering the subsets of each sequence independently,
    but must also make comparisons between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14: All possible character subsequences of two strings, ABCX and
    ACY](img/C14498_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: All possible character subsequences of two strings, ABCX and ACY'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The fact that we are not merely looking for consecutive groups of characters
    has several implications: firstly, the same sequence of characters can occur multiple
    times throughout the string and can be spaced across either string in any possible
    arrangement, assuming the order of the characters is the same. Secondly, there
    can be many common subsequences beginning from any given index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementing our brute-force approach, let''s also define what constitutes
    a state for this problem. Let''s assume that we are maintaining two pointers,
    `i` and `j`, which represent character indices in `A` and `B`, respectively, as
    well as a record of the subsequence of common characters we have found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have reached the end of either string, there is nothing else to compare
    because the indices of subsequences are ordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If the characters are equal, there is no advantage in not including it in our
    found subsequence. We increment both pointers because any given character can
    only be considered once per subsequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have not found a match, we have the choice to either explore the next
    subset of A''s characters, or the next subset of B''s characters. We do not include
    the case of incrementing both indices simultaneously from this state because it
    would be redundant. That case will be explored by the next function call. Outlining
    the structure of this recurrence would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15: Subproblem tree for the longest subsequence problem](img/C14498_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Subproblem tree for the longest subsequence problem'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding figure, the overlapping subproblems have been color coded.
    The optimal substructure of this problem is still not quite clear yet, but we
    can still make some basic generalizations:'
  prefs: []
  type: TYPE_NORMAL
- en: We only need to compare subsets of equal length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a given state, the possibilities for the next state can be explored by
    incrementing `i`, `j`, or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our search always ends when the end of either string is reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, our preliminary brute-force implementation can provide additional
    insights. Let's get right to it in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 40: Finding the Longest Common Subsequence by Using the Brute-Force
    Approach'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall use the brute-force approach to solve this problem,
    just like we did for the subset sum problem in *Exercise 36*, *Solving the Subset
    Sum Problem by Using the Brute-Force Approach*. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by including the following headers and defining the `DEBUG` and `PRINT`
    macros that we used in the previous chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a function called `LCS_BruteForce()` that takes the following arguments
    – two strings, `A` and `B`, two integers, `i` and `j`, and a vector of integer
    pairs, `subsequence` – and returns an integer. Above this function, we will also
    declare a two-dimensional vector of integer pairs with a global scope, that is,
    `found`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`A` and `B` are, of course, the strings we are comparing, `i` and `j` represent
    our current positions in `A` and `B`, respectively, and `subsequence` is the collection
    of index pairs that form each common subsequence, which will be collected in `found`
    for output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we already have pseudocode to work with, we can implement our function
    with relative ease by simply inserting each line of pseudocode into our function
    as comments and translating it into C++ code underneath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main()`, we''ll receive input in the form of two strings, and then call
    our function on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Like we did in the previous chapter, we will also output the subsequences found
    to `stderr` if `DEBUG` is not set to `0`. However, because of the greater complexity
    of this problem, we will put this output in a separate function, `PrintSubsequences()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call this function in `main()`, specifying that it should be ignored
    unless `DEBUG` is set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `DEBUG` to `1` and using `ABCX` and `ACYXB` as input should produce
    the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This output shows us all the possible combinations of subsequence pairs. Let's
    analyze this output in the following section and work toward optimizing our solution.
  prefs: []
  type: TYPE_NORMAL
- en: First Steps Toward Optimization – Finding the Optimal Substructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s revisit the logic of our previous approach again to see how it may be
    optimized. Using the input strings from the previous exercise, `ABCX` and `ACYXB`,
    if our current state has `i = 0` and `j = 0`, we can clearly see that the only
    possibility for our next state is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may recall, one of our initial insights is that the LCS is equal to
    `0` if either or both strings are empty. We can also generalize that the LCS of
    a given prefix of `A` and a given prefix of `B` is equal to the maximum LCS of
    A''s prefix reduced by one character with `B`, and `B`''s prefix reduced by one
    character with `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this concept of the LCS for two strings being based on the LCS of their
    prefixes, we can redefine our logic as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Using memoization, we can store our results at every step in a two-dimensional
    table, with the first dimension equal to the size of `A` and the second dimension
    equal to the size of `B`. Assuming we have not reached the base case, we can check
    whether we have a cached result stored in `memo[i - 1][j - 1]`. If we do, we return
    the result; if not, we recursively explore possibilities in the same way as before
    and store the results accordingly. We'll implement this in the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 19: Finding the Longest Common Subsequence by Using Memoization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In solving the subset sum problem, we implemented various approaches, namely
    brute force, backtracking, memoization, and tabulation. In this activity, your
    task is to independently implement a solution to the longest common subsequence
    problem using memoization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  prefs: []
  type: TYPE_NORMAL
- en: Two strings, *A* and *B*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: The length of the longest common subsequence of *A* and *B*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test cases should help you to understand this problem better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16: Activity 19 test cases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.16: Activity 19 test cases'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Activity Guidelines:**'
  prefs: []
  type: TYPE_NORMAL
- en: You can represent the state in two dimensions, with the first dimension bound
    by the length of *A*, and the second bound by the length of *B*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very little must be changed to convert the brute-force algorithm into a memoized
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your approach has a way to differentiate between subproblems that
    have already been cached versus those that have not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 563.
  prefs: []
  type: TYPE_NORMAL
- en: From Top-Down to Bottom-Up – Converting the Memoized Approach into a Tabulated
    Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we were to print out the values of the memo table for the pair of strings
    `ABCABDBEFBA` and `ABCBEFBEAB`, it would look like this (note that values of `-1`
    are unknown):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17: Memo table for ABCABDBEFBA and ABCBEFBE](img/C14498_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Memo table for ABCABDBEFBA and ABCBEFBE'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Looking up any of the row/column combinations where the characters are equal
    (say the 7th row and 7th column), we notice a pattern: the value at `memo[i][j]`
    is equal to `memo[i - 1][j - 1] + 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the other case (that is, the characters are not equal); the
    pattern we see is that `memo[i][j]` is equal to the maximum of `memo[i - 1][j]`
    and `memo[i][j - 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that we have found the optimal substructure of a problem, it is often
    quite a simple task to form a solution using tabulation by merely taking the table
    produced by a memoized solution and devising a scheme to build it from the bottom
    up. We will need to formulate some of our logic a bit differently, but the general
    ideas will essentially be the same. The first difference to contend with is the
    fact that the memo table's values are initialized to `UNKNOWN` (`-1`). Remember
    that a tabulated solution will fill the *entire* table with the appropriate results,
    and so nothing should be *unknown* by the time the algorithm has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the unknown value in the second row and third column; what should
    this be equal to? Assuming the prefixes we are considering at that point are `AB_________`
    and `ABC_______`, it should be fairly clear that the LCS at this point is equal
    to `2`. Now, let''s consider the unknown value in the 10th row and the 9th column:
    the prefixes we are considering at this point are `ABCABDBEFB_` and `ABCBEFBEA_`,
    and the LCS that''s found at this point is `ABC_B__EFB_` —> `ABCBEFB___`, which
    is seven characters long. We can logically deduce that the LCS value at a given
    state is either equal to the previously found LCS, or one greater than the previously
    found LCS if the characters are equal. The lowest possible LCS value, of course,
    should be equal to 0\. So, our logic for filling a DP table iteratively would
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Our logic is essentially identical to what it was for the memoized solution,
    except that rather than recursively finding the values of unexplored states to
    fill the current state's value in the table, we fill the values for those states
    first and then simply reuse them as needed. We'll put this logic into code in
    the following activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 20: Finding the Longest Common Subsequence Using Tabulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, your task is to implement a bottom-up solution to the longest
    common subsequence problem using tabulation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  prefs: []
  type: TYPE_NORMAL
- en: Two strings, *A* and *B*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: The length of the longest common subsequence of *A* and *B*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra Credit**'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the length of the LCS, also output the actual characters it contains.
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test cases should help you to understand this problem better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18: Activity 20 test cases'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.18: Activity 20 test cases'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Activity Guidelines**'
  prefs: []
  type: TYPE_NORMAL
- en: Like the subset sum problem, the tabulated solution requires iterating over
    two nested `for` loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a given state, `LCS(I, j)`, there are three possibilities that need to be
    handled – either the string's prefix is empty, the last characters of *A*'s and
    *B*'s prefixes are equal, or the last characters of *A*'s and *B*'s prefixes are
    not equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the characters of the LCS can be done by backtracking through the DP
    table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 568.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 21: Melodic Permutations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This activity is based around the traditional Western 8-note equal temperament
    scale, although students do not need to know anything about music theory to perform
    this activity. All the necessary information about the musical aspect is provided
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Musical set theory is a form of categorization for musical harmonies and melodies
    according to the intervallic relations of their notes. In musical terminology,
    an interval can be defined as the distance between two notes in terms of their
    relative positions when written in musical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: Musical notations](img/C14498_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: Musical notations'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following figure demonstrates the distance between different musical notes
    when represented as musical notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20: Musical intervals](img/C14498_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: Musical intervals'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You are a music theorist who is curious about how many times a permutation
    of a particular note set appears within the melodies of various composers. Given
    the notes of a complete melody and a set of notes, count the number of times any
    [permutation](http://www.apple.com) of the note set appears within the melody.
    For any valid permutation, notes can be repeated any amount of times and can occur
    in any order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The following notes are described as *enharmonically equivalent* and should
    be considered identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram illustrates this equivalence on a piano:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21: Enharmonically equivalent notes represented on a section of
    a piano](img/C14498_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: Enharmonically equivalent notes represented on a section of a
    piano'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Thus, the following combinations of notes would be considered equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are a few sample inputs and corresponding outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Output: `21`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Output: `27`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Output: `315`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Output: `945`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Output: `1323`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The guidelines for this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You do not actually have to know anything about music theory to solve this problem
    beyond what is explained in the description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a better way to represent the notes? Could they be converted into a
    format that would be more amenable to a tabulated DP solution?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the total count of subsets for *n* elements? Could this bit of information
    be useful in solving this problem?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 574.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have analyzed and implemented two archetypal examples of
    dynamic programming and learned several methods by which different DP problems
    may be approached. We have also learned how to identify the characteristics of
    problems that can be solved with DP, how DP algorithms should be considered conceptually,
    and how the concepts of states, base cases, and recurrence relations can be used
    to break a complex problem down into much simpler components.
  prefs: []
  type: TYPE_NORMAL
- en: We have just barely scratched the surface of the dynamic programming technique.
    Indeed, the two problems we explored in depth are actually quite similar, both
    conceptually and in terms of how their solutions are implemented. However, many
    of these similarities serve to demonstrate several commonalities that are encountered
    in nearly every DP problem, and, as such, they serve as an excellent introduction
    to a topic that is admittedly quite complex and difficult to master.
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic programming is a skill that you are unlikely to improve at merely
    through the act of reading or observing. The only way to truly get better with
    this technique is through solving as many problems with it as possible, preferably
    without guidance. At first, certain difficult DP problems may necessitate many
    attempts before the optimal solution is found, but the experience that you garner
    through this often arduous process is arguably much greater than what you are
    likely to gain through simply studying the solutions of any number of DP problems.
  prefs: []
  type: TYPE_NORMAL
- en: The progressive approach to solving DP problems that was demonstrated in this
    chapter can serve you well in the future, but it is by no means the only way to
    arrive at the ultimate solution. After having solved a number of DP problems,
    you will undoubtedly begin to notice certain patterns that will make it possible
    to devise tabulated solutions from the start. However, these patterns are not
    likely to be discovered until you have encountered a range of different DP problems.
    Keep in mind the fact that with DP, just like any challenging skill, continuous
    practice will make it easier, and, before long, what originally appeared extremely
    daunting will eventually seem thoroughly manageable, and even quite fun!
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we will learn how to apply dynamic programming to more
    advanced situations and develop a deeper understanding of how DP problems that
    appear quite different from one another at first glance are often just variations
    on the same set of concepts. Finally, we will conclude this book by revisiting
    the topic of graphs to demonstrate how the DP paradigm can be effectively applied
    to the shortest path problem.
  prefs: []
  type: TYPE_NORMAL
