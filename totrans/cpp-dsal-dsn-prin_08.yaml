- en: 8\. Dynamic Programming I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 动态规划I
- en: Learning Objectives
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Analyze whether the dynamic programming approach can be applied to a given problem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析动态规划方法是否适用于给定问题
- en: Compare and choose the right approach between memoization and tabulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较并选择记忆化和表格法之间的正确方法
- en: Choose an appropriate caching solution using memoization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择使用记忆化的适当缓存解决方案
- en: Analyze a problem using a naive brute-force approach
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用朴素的蛮力方法分析问题
- en: Develop a dynamic programming solution by implementing progressively optimized
    algorithms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实现逐步优化的算法来开发动态规划解决方案
- en: In this chapter, you will be introduced to the dynamic programming approach.
    This chapter will guide you through implementing this approach for solving some
    well-known problems in computer science.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将介绍动态规划方法。本章将指导您实现这种方法来解决计算机科学中一些众所周知的问题。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: Loved and feared in equal measure by many programmers, **dynamic programming**
    (**DP**) is a conceptual extension of the divide-and-conquer paradigm that pertains
    to a specific class of problems. The difficulties involved in dynamic programming
    problems are multi-faceted and often require creativity, patience, and the ability
    to visualize abstract concepts. However, the challenges these problems pose frequently
    have elegant and surprisingly simple solutions, which can provide a programmer
    with insights that reach far beyond the scope of the immediate task.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员对**动态规划**（**DP**）既爱又恐惧，它是分治范例的概念扩展，适用于特定类别的问题。动态规划问题涉及的困难是多方面的，通常需要创造力、耐心和对抽象概念的可视化能力。然而，这些问题提出的挑战通常有优雅且令人惊讶地简单的解决方案，这些解决方案可以为程序员提供超出即时任务范围的见解。
- en: In the previous chapter, we discussed several techniques, such as the divide-and-conquer
    and the greedy approach. These approaches, though quite effective in the right
    circumstances, will not produce optimal results in certain situations. For example,
    in the previous chapter, we discussed how Dijkstra's algorithm does not produce
    optimal results for graphs with negative edge weights, whereas the Bellman-Ford
    algorithm does. For problems that can be solved recursively, but cannot be solved
    using the aforementioned techniques, a DP solution may often be the best approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了几种技术，比如分治和贪婪方法。这些方法在适当的情况下非常有效，但在某些情况下不会产生最佳结果。例如，在上一章中，我们讨论了Dijkstra算法对于具有负边权重的图不会产生最佳结果，而Bellman-Ford算法会。对于可以递归解决但不能使用前述技术解决的问题，DP解决方案通常是最佳方法。
- en: 'DP problems are also encountered in a wide variety of situations. Here are
    just a few broad examples:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DP问题也出现在各种情况下。以下只是一些广泛的例子：
- en: Combinatorics (counting the number of combinations/permutations of a sequence
    matching certain criteria)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合数学（计算符合特定条件的序列的组合/排列数）
- en: Strings/arrays (edit distance, longest common subsequence, longest increasing
    subsequence, and so on)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串/数组（编辑距离、最长公共子序列、最长递增子序列等）
- en: Graphs (shortest path problem)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图（最短路径问题）
- en: Machine learning (speech/face recognition)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习（语音/人脸识别）
- en: Let's begin by understanding the basic idea of dynamic programming.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理解动态规划的基本思想开始。
- en: What Is Dynamic Programming?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是动态规划？
- en: 'The best way to answer this question is by example. To illustrate the purpose
    of dynamic programming, let''s consider the Fibonacci sequence:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这个问题的最佳方法是通过例子。为了说明动态规划的目的，让我们考虑斐波那契数列：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By observing the preceding sequence, we can see that, beginning with the third
    element, each term is equal to the sum of the two preceding terms. This can be
    simply expressed with the following formula:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察前述序列，我们可以看到，从第三个元素开始，每个项都等于前两个项的和。这可以用以下公式简单表示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can clearly see, the terms of this sequence have a recursive relationship
    – the current term, *F(n)*, is based on the results of previous terms, *F(n-1)*
    and *F(n-2)*, and thus the preceding equation, that is, *F(n) = F(n-1) + F(n-2)*,
    is described as the **recurrence relation** of the sequence. The initial terms,
    *F(0)* and *F(1)*, are described as the **base cases**, or the points in which
    a solution is produced without the need to recurse further. These operations are
    shown in the following figure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以清楚地看到，这个序列的项之间存在递归关系 - 当前项*F(n)*基于前面项*F(n-1)*和*F(n-2)*的结果，因此前述方程*F(n)
    = F(n-1) + F(n-2)*被描述为序列的**递归关系**。初始项*F(0)*和*F(1)*被描述为**基本情况**，或者在不需要进一步递归的情况下产生解决方案的点。这些操作如下图所示：
- en: '![Figure 8.1: Computing the nth term in the Fibonacci sequence](img/C14498_08_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：计算斐波那契数列的第n项](img/C14498_08_01.jpg)'
- en: 'Figure 8.1: Computing the nth term in the Fibonacci sequence'
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：计算斐波那契数列的第n项
- en: 'Describing the preceding figure in English might look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语描述前述图可能是这样的：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We describe the preceding approach as a **top-down solution** because it begins
    at the top of the recursion tree (that is, the solution) and traverses down its
    branches until it reaches the base cases. In C++, this could be written using
    the following recursive function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将前述方法描述为**自顶向下的解决方案**，因为它从递归树的顶部（即解决方案）开始，并沿着其分支向下遍历，直到达到基本情况。在C++中，这可以使用以下递归函数来编写：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By observing the tree further, we can see that several **subproblems**, or intermediate
    problems that must be solved to find the ultimate solution, must be solved more
    than once. For example, the solution for *F(2)* must be found to get the solution
    for *F(4) [F(3) + F(2)]* and *F(3) [F(2) + F(1)]*. Thus, the Fibonacci sequence
    is said to exhibit a property known as **overlapping subproblems**. This is one
    of the defining characteristics that separate a standard divide-and-conquer problem
    from a dynamic programming problem; in the former, subproblems tend to be unique,
    whereas in the latter, the same subproblems must be solved repeatedly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We can also see that several of the solution branches are completely identical
    to each other. For example, finding the solution for *F(2)* is going to require
    the same set of calculations, regardless of whether you need it to solve *F(4)*
    or *F(3)*. This demonstrates the second defining characteristic of dynamic programming
    problems, which is known as the optimal substructure. A problem is said to exhibit
    an **optimal substructure** when the optimal solution to the overall problem can
    be formed through some combination of the optimal solutions of its subproblems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: For a problem to be solvable using dynamic programming, it must possess these
    two properties. Because of the overlapping subproblems property, the complexity
    of these problems tends to increase exponentially as the input increases; however,
    exploiting the optimal substructure property makes it possible to reduce the complexity
    significantly. So, in essence, the purpose of DP is to devise a method of caching
    previous solutions as a means to avoid the repeated calculation of previously
    solved subproblems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Memoization – The Top-Down Approach
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No, this is not "memorization," though that would also describe this technique
    quite accurately. Using memoization, we can reformulate the top-down solution
    we described previously to make use of the optimal substructure property exhibited
    by the Fibonacci sequence. Our program logic will essentially be the same as it
    was before, only now, after having found the solution at every step, we will cache
    the results in an array, indexed according to the current value of *n* (in this
    problem, *n* represents the **state** or set of parameters defining the current
    recursive branch). At the very beginning of each function call, we will check
    to see whether we have a solution available in the cache for state *F(n)*. If
    so, we will simply return the cached value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The recursion tree now looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: Computing the nth term in the Fibonacci sequence using cached
    solutions](img/C14498_08_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Computing the nth term in the Fibonacci sequence using cached solutions'
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By doing this, we have eliminated quite a bit of redundant work. This technique
    of recursively caching solutions in a top-down manner is known as **memoization**,
    and can essentially be employed for any DP problem, assuming the following are
    true:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: You can devise a caching scheme that exploits the similarity of different states
    while preserving their uniqueness.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can accumulate the solutions for the requisite subproblems before exceeding
    the available stack space.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first point means that the method of indexing results for later use should
    be both valid and useful. In order for a caching scheme to be valid, it must only
    be considered a match for states whose solutions are derived from the same series
    of subproblems; in order for it to be useful, it must not be so state-specific
    that it cannot be effectively used (for example, if every subproblem is assigned
    a unique index in the cache, the conditional "`if(memo[KEY] != UNKNOWN)`" will
    never be true).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The second point refers to the possibility of causing a stack overflow error,
    which is a fundamental limitation of any top-down approach if the number of recursive
    calls is likely to be very high. A stack overflow occurs when a program exceeds
    the allotted amount of memory that's available on the call stack. Depending on
    the nature of a given problem, it is possible that the depth of recursion that's
    required may prevent memoization from being a viable option; as always, it is
    quite beneficial to assess the potential complexity of the task at hand before
    choosing an approach.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点指的是可能引起堆栈溢出错误的可能性，这是任何自顶向下方法的基本限制，如果递归调用的次数可能非常高。堆栈溢出发生在程序超出调用堆栈上可用的内存分配量时。根据给定问题的性质，可能需要的递归深度可能会阻止记忆化成为可行的选择；因此，在选择方法之前评估手头任务的潜在复杂性是非常有益的。
- en: Memoization is frequently a decent optimization method for DP problems. However,
    in many cases, a better option is available, which we will study in the following
    section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化经常是动态规划问题的一个不错的优化方法。然而，在许多情况下，有更好的选择，我们将在下一节中学习。
- en: Tabulation – the Bottom-Up Approach
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制表 - 自底向上的方法
- en: The *heart* of dynamic programming is tabulation, which is the inverse approach
    to memoization. In fact, though the term *dynamic programming* is sometimes applied
    to both memoization and tabulation, its use is generally assumed to refer specifically
    to the latter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划的核心是制表法，这是记忆化的逆向方法。事实上，尽管动态规划这个术语有时被应用于记忆化和制表，但通常认为它特指后者。
- en: The standard implementation of tabulation consists of storing the solutions
    for the base cases and then iteratively filling a table with the solutions for
    every subproblem, which can then be reused to find the solutions for other subproblems.
    Tabulated solutions are generally considered to be a bit harder to conceptualize
    than memoized ones because the state of each subproblem must be represented in
    a way that can be expressed iteratively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 制表的标准实现包括存储基本情况的解决方案，然后迭代地填充一个表格，其中包含每个子问题的解决方案，然后可以重复使用这些解决方案来找到其他子问题的解决方案。制表解决方案通常被认为比记忆化的解决方案更难以理解，因为每个子问题的状态必须以可以迭代表示的方式来表示。
- en: 'A tabulated solution to computing the Fibonacci sequence would look like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斐波那契数列的制表解决方案如下：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the Fibonacci example, the state is quite simple since it's one-dimensional
    and unconditional — the formula always holds that, for any n greater than *1*,
    *F(n) = F(n-1) + F(n-2)*. However, DP problems often contain several dimensions
    that define a given state and may have multiple conditions that affect how states
    transition between each other. In such cases, determining how to represent the
    current state may require a fair amount of creativity, in addition to a comprehensive
    understanding of the problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在斐波那契数列的例子中，状态非常简单，因为它是一维的和无条件的——对于任何大于1的n，公式总是成立，即F(n) = F(n-1) + F(n-2)。然而，动态规划问题通常包含定义给定状态的多个维度，并且可能有多个条件影响状态之间的转换。在这种情况下，确定如何表示当前状态可能需要相当多的创造力，以及对问题的全面理解。
- en: The advantages of tabulation, however, are significant. In addition to the fact
    that tabulated solutions frequently tend to be much more efficient in terms of
    memory, they also produce a complete lookup table encompassing every given state.
    Therefore, if you are likely to receive queries about any state of the problem,
    tabulation is likely to be your best option.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，制表的优势是显著的。除了制表解决方案通常在内存方面更有效之外，它们还产生一个包含每个给定状态的完整查找表。因此，如果你可能会收到关于问题的任何状态的查询，制表很可能是你最好的选择。
- en: Interestingly, any problem that can be solved with memoization can theoretically
    be reformulated into a tabulated solution, and vice versa. Using the former can
    often provide immense insight into how to approach the latter. Over the next few
    sections, we will explore several classical examples of dynamic programming problems
    and demonstrate how employing multiple approaches (beginning with naive brute
    force) can lead you to the level of understanding that's required for the tabulated
    solution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，任何可以通过记忆化解决的问题理论上都可以重新制定为制表解决方案，反之亦然。使用前者通常可以为如何处理后者提供巨大的见解。在接下来的几节中，我们将探讨动态规划问题的几个经典示例，并演示如何使用多种方法（从朴素的蛮力开始）可以使你达到制表解决方案所需的理解水平。
- en: Subset Sum Problem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子集和问题
- en: Imagine that you are implementing the logic for a digital cash register. Whenever
    a customer needs change, you would like to display a message that tells the cashier
    whether or not the money currently in the register can be combined in some way
    so that its sum is equal to the amount of change required. For example, if a product
    costs $7.50 and the customer pays $10.00, the message would report whether the
    money in the register can be used to produce exactly $2.50 in change.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在为一个数字现金注册逻辑。每当顾客需要找零时，你希望显示一条消息，告诉收银员当前注册处的钱是否可以以某种方式组合，使其总和等于所需的找零金额。例如，如果一个产品售价为7.50美元，顾客支付10.00美元，消息将报告注册处的钱是否可以用来产生精确的2.50美元的找零。
- en: 'Let''s say that the register currently contains ten quarters (10 x $0.25),
    four dimes (4 x $0.10), and six nickels (6 x $0.05). We can easily conclude that
    the target sum of $2.50 can be formed in the following ways:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设注册处当前包含十个25美分的硬币（10 x 0.25美元），四个10美分的硬币（4 x 0.10美元）和六个5美分的硬币（6 x 0.05美元）。我们可以很容易地得出结论，2.50美元的目标总额可以以下列方式形成：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these parameters, the problem is rather straightforward and can be solved
    by simply trying all the available combinations of money until a sum matching
    $2.50 is found. But what if the change that's required is $337.81, and the register
    contains 100 banknotes/coins divided into denominations of $20.00, $10.00, $5.00,
    $1.00, $0.25, $0.10, $0.05, and $0.01? We can clearly see that trying every possible
    sum becomes quite impractical as the complexity increases. This is an example
    of a classic problem known as the subset sum problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'In its most basic form, the `S`, and an integer, `x`, is there a subset of
    `S`''s elements whose sum is equal to `x`? Take a look at the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the preceding set as an example, we can find the following 16 subsets:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By listing the total amount of subsets that can be produced for sets of different
    sizes, we get the following numbers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From this list, we can deduce that the total number of subsets that can be formed
    from a set of size `n` is equal to *2**n*, which demonstrates that the number
    of subsets to consider increases exponentially with the size of *n*. Assuming
    the number of elements in *S* is small, say 10 elements or less, a brute-force
    approach to this problem could find the solution rather quickly; but if we reconsider
    the example of a cash register containing 100 different banknotes/coins, the size
    of *S* would be equal to 100, which would require exploring 1,267,650,600,228,229,401,496,703,205,376
    subsets!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving the Subset Sum Problem – Step 1: Evaluating the Need for DP'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our first step when faced with a problem like this is to determine whether
    it can (and/or should) be solved with DP. To reiterate, a problem is solvable
    with DP if it has the following properties:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '**Overlapping subproblems**: Like the standard divide-and-conquer approach,
    the final solution can be derived by combining the solutions of smaller subproblems
    in some way; in contrast to divide and conquer, however, certain subproblems will
    be encountered multiple times.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimal substructure**: The optimal solution for a given problem can be produced
    by the optimal solutions of its subproblems.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s analyze the preceding example in terms of whether or not it possesses
    these characteristics:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3: Optimal substructure and overlapping subproblems'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: ''''
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Figure 8.3: Optimal substructure and overlapping subproblems'
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Reformatting the collection of subsets as shown clearly illustrates how each
    new subset of size n is formed by appending a single new element to a subset of
    size `n - 1`. This is the optimal approach for constructing a new subset and holds
    true for every subset of size greater than 0\. Thus, the subset sum problem has
    an **optimal substructure**. We can also see that several subsets are derived
    from the same "subsubset" (for example, both *{ 13 79 45 }* and *{ 13 79 29 }*
    are based on *{ 13 79 }*). Therefore, the problem also has **overlapping subproblems**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Having satisfied both of our criteria, we can conclude that this problem can
    be solved with dynamic programming.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Defining the States and the Base Cases
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having determined that this is a DP problem, we now must determine what constitutes
    a state within the context of this problem. In other words, in terms of the question
    that we are trying to answer, what makes one possible solution different from
    another?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Though it is generally advisable to consider these aspects of the problem early
    in the process, it is often quite difficult to define the states of a DP problem
    without having a clear understanding of how the ultimate result is formed, and
    thus it is often quite helpful to start by implementing a solution in the most
    straightforward way possible. Therefore, we will develop our understanding of
    the subset sum problem's base case(s) and states by solving it in two different
    ways that are much simpler to implement.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout our exploration of dynamic programming, we will consider a total
    of four different approaches to each problem: **brute force**, **backtracking**,
    **memoization**, and **tabulation**. As with any DP problem, all of these approaches
    are capable of producing the correct result, but the first three quickly demonstrate
    their limitations as the size of the input increases. Nevertheless, implementing
    progressively optimized solutions in this way can be used to great effect when
    tackling any dynamic programming problem.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索动态规划的过程中，我们将考虑每个问题的四种不同方法：**蛮力**，**回溯**，**记忆化**和**表格化**。与任何DP问题一样，所有这些方法都能够产生正确的结果，但前三种方法在输入规模增加时很快显示出它们的局限性。然而，以这种方式逐渐实现优化的解决方案在解决任何动态规划问题时都可以产生很大的效果。
- en: 'Step 2.a: Brute Force'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2.a：蛮力
- en: 'Despite its inefficiency, a brute-force solution can be quite informative in
    developing an understanding of the problem at hand. Implementing brute-force approaches
    can be an essential step in the process of forming a DP solution for several reasons:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其效率低下，蛮力解决方案在开发对手头问题的理解方面可能非常有益。以蛮力方法实现可能是形成DP解决方案过程中的一个重要步骤，原因有几个：
- en: '**Simplicity**: The simplicity of writing a solution without any consideration
    of its efficiency can be an excellent way to develop an understanding of the fundamental
    aspects of the problem; it can also lead to insights about the problem''s nature
    that may otherwise be missed in the act of trying to comprehend its complexity
    without sufficient context.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：在不考虑效率的情况下编写解决方案的简单性可以是开发对问题基本方面的理解的绝佳方式；它还可以带来关于问题性质的见解，否则可能会在尝试理解其复杂性时因缺乏足够的上下文而被忽略。'
- en: '**The certainty of solution correctness**: Oftentimes, a particularly complex
    DP solution will require quite a bit of redesign as the problem is better understood.
    Because of this, it is essential to have a way to compare your solution''s output
    to the correct answer.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决方案正确性的确定性**：通常，特别复杂的DP解决方案在更好地理解问题时需要进行重新设计。因此，比较解决方案的输出与正确答案是至关重要的。'
- en: '**Ability to visualize the subproblems**: A brute-force solution will generate
    every potential solution and then choose the ones that meet the criteria of the
    problem. This provides an effective means for visualizing how a correct solution
    is formed, which can then be inspected for essential patterns that can be used
    in later approaches.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可视化子问题的能力**：蛮力解决方案将生成每个潜在解决方案，然后选择符合问题标准的解决方案。这提供了一种有效的方式来可视化正确解决方案的形成方式，然后可以检查其中可以在后续方法中使用的基本模式。'
- en: The following exercise demonstrates the implementation of the brute-force approach.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习演示了蛮力方法的实现。
- en: 'Exercise 36: Solving the Subset Sum Problem by Using the Brute-Force Approach'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习36：使用蛮力方法解决子集和问题
- en: 'In this exercise, we shall find a solution to the subset sum problem using
    the brute-force approach. Let''s get started:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用蛮力方法找到子集和问题的解决方案。让我们开始吧：
- en: 'Let''s begin by including the following headers (and the `std` namespace for
    convenience):'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先包括以下标头（以及`std`命名空间以方便起见）：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Additionally, let''s define a preprocessor constant called `DEBUG` and a macro
    called `PRINT`, which will print to `stderr` only if `DEBUG` is not zero:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，让我们定义一个名为`DEBUG`的预处理器常量和一个名为`PRINT`的宏，它将仅在`DEBUG`不为零时打印到`stderr`：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will now declare a new function, `SubsetSum_BruteForce()`, that takes two
    arguments — an array of integers, `set`, and an integer, `sum` — and returns a
    Boolean:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将声明一个新函数`SubsetSum_BruteForce（）`，它接受两个参数 - 一个整数数组`set`和一个整数`sum` - 并返回一个布尔值：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s declare another function, `GetAllSubsets()`, which takes four arguments
    — two integer vectors, `set` and `subset`; an integer; `index`; and a three-dimensional
    vector of integers called `allSubsets` (passed by reference). We will use this
    function to generate all subsets of *S* recursively:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们声明另一个函数`GetAllSubsets（）`，它接受四个参数 - 两个整数向量`set`和`subset`；一个整数`index`；和一个名为`allSubsets`的三维整数向量（通过引用传递）。我们将使用此函数递归地生成*S*的所有子集：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Returning to our `SubsetSum_BruteForce()` function, we can now declare `allSubsets`
    and call the function:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到我们的`SubsetSum_BruteForce（）`函数，我们现在可以声明`allSubsets`并调用该函数：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can iterate through each subset and compare its sum to `target`, returning
    `true` if a match is found:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以遍历每个子集并将其总和与`target`进行比较，如果找到匹配，则返回`true`：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If a matching sum is not found after checking every subset, we return `false`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在检查每个子集后找不到匹配的和，我们返回`false`：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, in the `main()` function, let''s define our set and target as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`main（）`函数中，让我们定义我们的集合和目标如下：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now call `SubsetSum_BruteForce()` with these inputs like so:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以这样调用`SubsetSum_BruteForce（）`与这些输入：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Upon running the preceding code, you should see the following output:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码后，您应该看到以下输出：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s set `target` to a sum that is not found in the set:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`target`设置为一个集合中找不到的和：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the program again should produce the following output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行程序应该产生以下输出：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, let''s redefine our `DEBUG` constant to 1:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将我们的`DEBUG`常量重新定义为1：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Running the program now will produce the following output:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行程序将产生以下输出：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Thus, we are able to find the required subset using the brute-force approach.
    Note that we are basically trying out every possibility in order to find the solution.
    In the following section, we shall apply one layer of optimization over it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够使用蛮力方法找到所需的子集。请注意，我们基本上是尝试找到解决方案的每种可能性。在下一节中，我们将对其进行一层优化。
- en: 'Step 2.b: Optimizing Our Approach – Backtracking'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤2.b：优化我们的方法 - 回溯
- en: Clearly, the brute-force approach leaves a lot to be desired. In terms of performance,
    it is about as inefficient as it possibly could be. By indiscriminately checking
    every possible subset, we consider options long after the point where we could
    determine that they will never lead to a solution (for example, subsets with sums
    exceeding the target). To improve our algorithm, we can utilize **backtracking**
    to exclude all the branches of subproblems that are guaranteed to be invalid.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，蛮力方法还有很多不足之处。在性能方面，它几乎是尽可能低效的。通过不加区分地检查每个可能的子集，我们在可以确定它们永远不会导致解决方案的点之后仍然考虑选项（例如，总和超过目标的子集）。为了改进我们的算法，我们可以利用**回溯法**来排除所有已经被保证无效的子问题的分支。
- en: 'The main advantage of implementing a backtracking solution before attempting
    to use DP is that it requires us to determine the base case(s) and intermediate
    recursive states of the problem. As we defined earlier in this chapter, a base
    case is a condition in a recursive function that does not rely on further recursion
    to produce an answer. For further clarification, consider the problem of calculating
    the factorial of a number (the factorial of a number, *n*, is equivalent to *n
    * (n-1) * (n-2) * (n-3) … * 1*). We could code a C++ function that accomplishes
    this as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用DP之前实现回溯解决方案的主要优势是，它要求我们确定问题的基本情况和中间递归状态。正如我们在本章前面定义的那样，基本情况是递归函数中的一个条件，它不依赖于进一步递归来产生答案。为了进一步澄清，考虑计算一个数字的阶乘的问题（一个数字*n*的阶乘等于*n
    * (n-1) * (n-2) * (n-3) … * 1*）。我们可以编写一个C++函数来实现这个问题，如下所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The structure of this recursive function can be illustrated like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归函数的结构可以用下面的方式来说明：
- en: '![Figure 8.4: Recursively calculating the Nth factorial](img/C14498_08_04.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4：递归计算第N个阶乘](img/C14498_08_04.jpg)'
- en: 'Figure 8.4: Recursively calculating the Nth factorial'
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.4：递归计算第N个阶乘
- en: The `n = 1` condition is the base case because that is the point at which the
    solution can be returned without recursing further.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`n = 1`的条件是基本情况，因为这是可以在不进一步递归的情况下返回解决方案的点。'
- en: 'In the subset sum problem, one way to define our base cases would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在子集和问题中，定义我们的基本情况的一种方式是：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have established base cases, we need to define our intermediate
    states. Using our brute-force algorithm''s output as a reference, we can analyze
    how subsets of each size group are formed to plot out our state transitions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本情况，我们需要定义中间状态。使用我们的蛮力算法的输出作为参考，我们可以分析每个大小组的子集是如何形成的，以绘制出我们的状态转换：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Of course, the size `0` and size `1` states are the simplest to understand.
    We begin with an empty set and we can add any of the elements to it in order to
    create all subsets of size 1.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大小为`0`和大小为`1`的状态是最容易理解的。我们从一个空集开始，我们可以添加任何元素到它，以创建所有大小为1的子集。
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can follow the same line of logic for size 2 subsets. Simply take each subset
    of size 1 and append every element whose index is greater than the highest-indexed
    element already in the subset. This is essentially the approach we took in our
    brute-force implementation; however, this time, we will consider the sum of each
    subset as we process them, and terminating them when the current sum exceeds the
    target:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对大小为2的子集采用相同的逻辑。只需取每个大小为1的子集，并附加索引大于子集中已有的最高索引的每个元素。这本质上是我们在蛮力实现中采取的方法；然而，这一次，我们在处理它们时将考虑每个子集的总和，并在当前总和超过目标时终止它们。
- en: '![Figure 8.5: Eliminating values that exceed the target](img/C14498_08_05.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：消除超过目标值的值](img/C14498_08_05.jpg)'
- en: 'Figure 8.5: Eliminating values that exceed the target'
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：消除超过目标值的值
- en: 'When `target` is equal to `58`, we can see that none of the subsets of size
    3 or 4 need to be considered. Thus, we can describe our intermediate state transition
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当`target`等于`58`时，我们可以看到不需要考虑大小为3或4的子集。因此，我们可以描述我们的中间状态转换如下：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we should ask the following questions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该问以下问题：
- en: What is the minimal amount of data needed to represent this state?
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示这种状态所需的最少数据是什么？
- en: How can we reformulate the preceding logic to remove unnecessary information?
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何重新构思前面的逻辑以去除不必要的信息？
- en: 'Consider the specific problem we are trying to solve: finding whether a subset
    of elements exists within the set whose sum is equal to the target. According
    to the problem description, our task does not require that we produce the actual
    subsets, but only their sums. So, our pseudocode could be more succinctly expressed
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们要解决的具体问题：找出是否存在一个子集的元素，其总和等于目标值。根据问题描述，我们的任务不需要产生实际的子集，而只需要它们的总和。因此，我们的伪代码可以更简洁地表示如下：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using this new approach, we can essentially represent each state transition
    with only two integers, `sum` and `i`, eliminating the need to store *2**n* subset
    arrays in the worst case. Furthermore, we can remove the need to keep track of
    the target value by inverting the problem (that is, starting at `target` and subtracting
    `set[i]` at each step). As a final optimization, we can sort the set before calling
    the function, which allows us to determine that there are no other valid possibilities
    as soon as the sum exceeds the target. We'll implement this in C++ in the following
    exercise.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新方法，我们基本上可以用两个整数`sum`和`i`来表示每个状态转换，从而在最坏情况下消除了存储*2**n*子集数组的需要。此外，我们可以通过反转问题（即从`target`开始，并在每一步减去`set[i]`）来消除跟踪目标值的需要。最后，我们可以在调用函数之前对集合进行排序，这样我们就可以在总和超过目标时确定没有其他有效可能性。我们将在接下来的练习中用C++来实现这一点。
- en: 'Exercise 37: Solving the Subset Sum Problem by Using Backtracking'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习37：使用回溯法解决子集和问题
- en: 'In this exercise, we shall solve a problem similar to the one demonstrated
    in *Exercise 36*, *Solving the Subset Sum Problem by Using the Brute-Force Approach*,
    but using a backtracking approach and a more complex input to highlight the differences.
    Let''s get started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将解决一个类似于*练习36*中演示的问题，即*使用蛮力方法解决子集和问题*，但是使用回溯方法和更复杂的输入来突出差异。让我们开始吧：
- en: 'To implement the backtracking solution for the subset sum problem, we define
    a function called `SubsetSum_Backtracking()`, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现子集和问题的回溯解决方案，我们定义一个名为`SubsetSum_Backtracking()`的函数，如下所示：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As is often the case in recursive functions, we define our base cases at the
    very beginning:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在递归函数中经常这样，我们在一开始就定义了基本情况：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At each step, our options are to add the current element''s value to the sum,
    or to keep the sum as-is. We can condense this logic into one line like so:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每一步，我们的选择是将当前元素的值加到总和中，或者保持总和不变。我们可以将这个逻辑压缩成一行，如下所示：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Returning to `main`, let''s sort the set and add our call to `SubsetSum_Backtracking()`
    underneath the call to `SubsetSum_BruteForce()`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`main`，让我们对集合进行排序，并在调用`SubsetSum_BruteForce()`之后添加我们对`SubsetSum_Backtracking()`的调用：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For the sake of testing, we will implement a function that will display the
    time each approach takes to find the solution. First, we will need to include
    the `<time.h>` and `<iomanip>` headers:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试，我们将实现一个函数，它将显示每种方法找到解决方案所花费的时间。首先，我们需要包含`<time.h>`和`<iomanip>`头文件：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will also define an array of strings called `types`, which we will use to
    label the results of each approach:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将定义一个名为`types`的字符串数组，我们将用它来标记每种方法的结果：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we will write another function, `GetTime()`, that takes a reference to
    a `clock_t` object called `timer` and a `string type`, and then returns `void`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写另一个函数`GetTime()`，它接受一个名为`timer`的`clock_t`对象的引用和一个`string`类型，然后返回`void`：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s rewrite the `main()` function so that we can perform each function
    call sequentially and compare the time taken by each approach:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们重写`main()`函数，以便我们可以依次执行每个函数调用并比较每种方法所花费的时间：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let''s redefine our input to highlight the difference in efficiency
    between the two approaches:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们重新定义我们的输入，以突出两种方法之间效率的差异：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Your output will produce something along the lines of the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的输出将产生类似以下内容的东西：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The actual values for the time taken would vary depending on your system. Please
    note the difference in the values.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的时间取值会根据您的系统而有所不同。请注意数值上的差异。
- en: As you can see, in this particular case, the answer was found over 1,000 times
    faster using the backtracking approach. In the following section, we shall optimize
    this solution further by making use of caching.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这种特殊情况下，使用回溯方法找到答案要快1000多倍。在接下来的部分中，我们将通过利用缓存来进一步优化这个解决方案。
- en: 'Step 3: Memoization'
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤3：记忆化
- en: Though significantly better than brute force, the backtracking solution is still
    far from ideal. Consider a case where the target sum is high and not in the set
    — if the target is greater than or equal to the sum of every element in the set,
    we could easily determine the result by calculating the total in advance and checking
    that the target is within the valid range. However, if the target sum is just
    slightly under this amount, our algorithm will still be forced to explore practically
    every possibility before finishing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然比蛮力方法好得多，但回溯解决方案仍然远非理想。考虑一个目标和集合中没有的情况-如果目标大于或等于集合中每个元素的总和，我们可以通过预先计算总和并检查目标是否在有效范围内来轻松确定结果。然而，如果目标总和略低于这个数额，我们的算法仍然需要在完成之前探索几乎每种可能性。
- en: To demonstrate this difference, try running your code from the previous exercise
    using `6799` as the target (exactly 1 less than the total sum of all the elements
    of the set). On the author's machine, the backtracking solution took about 0.268
    seconds on average to produce the result – nearly 350 times longer than the average
    time taken with the target value used in the exercise.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这种差异，尝试使用`6799`作为目标来运行上一个练习中的代码（恰好比集合中所有元素的总和少1）。在作者的机器上，回溯解决方案平均花费大约0.268秒来产生结果-几乎比练习中使用的目标值所花费的平均时间长了近350倍。
- en: Thankfully, we already have all the information we need to devise a top-down
    solution while utilizing memoization. Even better, we hardly have to modify our
    previous approach at all to implement it!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经拥有了所有需要设计自顶向下解决方案并利用记忆化的信息。更好的是，我们几乎不需要修改我们以前的方法来实现它！
- en: Devising a Caching Scheme
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计缓存方案
- en: 'The most important aspect of using memoization is to define a caching scheme.
    Caching results for memoized solutions can be done in a number of ways, but the
    most common are as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记忆化最重要的方面是定义一个缓存方案。对于记忆化解决方案的缓存结果可以通过多种方式来完成，但最常见的方式如下：
- en: Simple arrays, with states represented by numerical indices
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单数组，状态由数字索引表示
- en: Hash tables/maps, with states represented by descriptive strings that are hashed
    using built-in language features
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表/映射，状态由使用内置语言特性散列的描述性字符串表示
- en: Hash tables/maps, with states represented by hash values that are created using
    an original hashing formula
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表/映射，状态由使用原始哈希公式创建的哈希值表示
- en: 'The choice to make here is largely context-dependent, but here are some general
    guidelines:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要做出的选择在很大程度上取决于上下文，但以下是一些一般性指导方针：
- en: Arrays/vectors that are accessed by a numerical index tend to be much faster
    than maps, which must locate a given key in the map in order to determine whether
    or not it has already been cached.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过数字索引访问的数组/向量通常比必须在映射中定位给定键以确定是否已经被缓存的映射要快得多。
- en: Even when states can be represented as integers, if the cache keys are quite
    large, the memory requirements of an array large enough to encompass them may
    be unreasonable. In this case, maps are a better option.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使状态可以表示为整数，如果缓存键非常大，足以包含它们的数组的内存需求可能是不合理的。在这种情况下，映射是更好的选择。
- en: Hash tables (for example, `std::unordered_map`) tend to be much faster than
    standard map/dictionary structures for locating and retrieving keys (but are still
    slower than arrays).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表（例如`std::unordered_map`）在定位和检索键时往往比标准的映射/字典结构快得多（但仍然比数组慢）。
- en: '`std::map` is much more versatile than `std::unordered_map` in terms of what
    types of data can be used as keys. Although `std::unordered_map` can technically
    offer the same functionality, it requires the programmer to create their own hashing
    function for data types it is not equipped to store as keys by default.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::map`在可以用作键的数据类型方面比`std::unordered_map`更加灵活。尽管`std::unordered_map`在技术上可以提供相同的功能，但它要求程序员为默认情况下无法存储为键的数据类型创建自己的哈希函数。'
- en: 'As you may recall from the introduction to this chapter, a caching scheme should
    be as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得本章节介绍的那样，缓存方案应该是这样的：
- en: '**Valid**: Cache keys must be represented in a way that avoids collisions between
    different states that are not used to solve the same set of subproblems.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效**：缓存键必须以一种方式表示，以避免不用于解决相同子问题集的不同状态之间发生冲突。'
- en: '**Worthwhile/useful**: If your caching scheme is so specific that it never
    actually produces any "hits", then it essentially accomplishes nothing.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有价值/有用**：如果您的缓存方案如此特定，以至于实际上从未产生任何“命中”，那么它基本上什么也没做。'
- en: 'In the subset sum problem, we may mistakenly come to believe that failing to
    find the target from a state with a given `sum` value means that it would be impossible
    to get a true result from any other state with the same sum. Therefore, we may
    decide to cache every solution based solely on the value of `sum` (that is, `if(memo[sum]
    != UNKNOWN) return memo[sum];`). This is an example of an invalid caching scheme
    because it fails to take into account the fact that there may be multiple ways
    to reach the same sum within the same set, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在子集和问题中，我们可能错误地认为，从具有给定`sum`值的状态中找不到目标意味着从具有相同和的任何其他状态中都不可能得到真正的结果。因此，我们可能决定仅基于`sum`的值缓存每个解决方案（即`if(memo[sum]
    != UNKNOWN) return memo[sum];`）。这是一个无效的缓存方案的例子，因为它未考虑到在同一组内可能有多种达到相同和的方式，如下所示：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Suppose the target value is `8` in the preceding example. If the third case
    is encountered first, `memo[6]` would be set to `false`, which is obviously incorrect
    since the target can be reached from both of the other cases by including the
    4th element (`2`).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在前面的例子中目标值为`8`。如果首先遇到第三种情况，`memo[6]`将被设置为`false`，这显然是不正确的，因为目标可以通过包括第4个元素（`2`）从其他两种情况中达到。
- en: An example of a useless memoization scheme would be one where the keys are equal
    to the indices of the subset because every possible state will contain a completely
    unique key; as a result, states that are formed from the same set of subproblems
    will not trigger a cache hit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无用的记忆化方案的例子是，其中键等于子集的索引，因为每个可能的状态都将包含一个完全独特的键；因此，由相同子问题集形成的状态不会触发缓存命中。
- en: If you are unsure about the efficacy of your caching scheme, it can be useful
    to store a counter that increments on every cache hit. If the final value of this
    counter is equal to `0`, or is very low relative to the number of states you have
    to consider, you can conclude that your caching scheme needs revision.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对自己的缓存方案的有效性不确定，可以有用的是存储一个在每次缓存命中时递增的计数器。如果这个计数器的最终值等于`0`，或者相对于您需要考虑的状态数量来说非常低，那么您可以得出结论，您的缓存方案需要修订。
- en: We shall explore the implementation of memoization with the use of a vector
    for caching.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨使用向量进行缓存的记忆化实现。
- en: 'Exercise 38: Solving the Subset Sum Problem by Using Memoization'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习38：使用记忆化解决子集和问题
- en: 'In this exercise, we shall try to implement the same solution that we implemented
    in *Exercise 37*, *Solving the Subset Sum Problem by Using Backtracking*, but
    with the addition of memoization. Let''s get started:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将尝试实现与*练习37*中实现的相同解决方案，即使用回溯法解决子集和问题，但增加了记忆化。让我们开始吧：
- en: 'We will now create another function called `SubsetSum_Memoization()`. The definition
    for this function will be identical to `SubsetSub_Backtracking()`, except that
    it will include a reference to a two-dimensional integer vector called `memo`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建另一个名为`SubsetSum_Memoization()`的函数。这个函数的定义将与`SubsetSub_Backtracking()`完全相同，只是它将包括对名为`memo`的二维整数向量的引用：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Much of our code for this function will look quite similar to the backtracking
    approach. For example, our base cases will be defined exactly like they were previously:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的大部分代码看起来与回溯法的方法非常相似。例如，我们的基本情况将与以前定义的完全相同：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, the pivotal difference is that after the base cases, rather than immediately
    investigating the next two states, we check the `memo` table for cached results:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关键的区别在于，在基本情况之后，我们不是立即调查下两种状态，而是检查`memo`表以获取缓存的结果：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we should insert a call to `SubsetSum_Memoization()` in the `main()` function:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该在`main()`函数中插入对`SubsetSum_Memoization()`的调用：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s define `target` as `6799` and run our code. You should see an output
    similar to this:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`target`定义为`6799`并运行我们的代码。您应该看到类似于这样的输出：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The actual values for time taken would vary depending on your system. Please
    note the difference in the values.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的时间值会根据您的系统而有所不同。请注意值的差异。
- en: We can see from the output that caching has optimized our problem by an exponential
    factor.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从输出中看到，缓存已经将我们的问题优化了指数倍。
- en: 'Step 4: Tabulation'
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步：制表
- en: So far, we have implemented three different algorithmic approaches to solving
    the subset sum problem, each of which has a significant improvement over the one
    preceding it. However, let's say that we wanted a list of every possible subset
    sum in a given set. We would have to run our algorithm repeatedly for each sum,
    from 1 to the total sum of the entire set. For situations such as these, tabulation
    is often the only efficient option.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing an iterative tabulated solution to a problem like this is often
    rather hard to conceptualize. Whereas recursive formulations of a problem lend
    themselves well to multidimensional states and branching conditions, a tabulated
    solution has to somehow condense the layers of complexity into a simple set of
    iterations using the standard `for`/`while` loops:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6: Depiction of how the complexity of the subset sum problem’s recursive
    structure is reduced in the tabulated DP solution](img/C14498_08_06.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Depiction of how the complexity of the subset sum problem''s recursive
    structure is reduced in the tabulated DP solution'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are several methods for tackling this reduction, but ultimately it tends
    to come down to whether or not you understand the problem well enough to make
    the correct generalizations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Like memoization, the first goal after defining the base case(s) and states
    of the problem is to develop a scheme for storing the solutions for different
    states. Typically, tabulated approaches use simple arrays/vectors for this purpose.
    We have already looked at an example of a very simple DP table in the calculation
    of the Fibonacci sequence:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Earlier in this chapter, we also discussed how to calculate factorials recursively.
    A bottom-up approach to filling the table for that problem would look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are very simple examples because they only contain a single dimension
    and no conditional logic. Each state has a consistent, predictable formula from
    beginning to end.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The primary difference between those examples and the subset sum problem is
    that the minimal way to represent each state uniquely in the latter requires two
    dimensions — the index in the set and the current sum.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider some of the insights we have gained about this problem in greater
    depth:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Each possible subset of size `k` can be formed by taking new elements and appending
    them onto every subset of size `k – 1`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a solution has been found at index `i` with a sum value of `x`, then any
    sequence of state transitions that eventually lead to that same set of conditions
    will produce an identical result:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.7: Multiple paths with the same sum value on the same index value](img/C14498_08_07.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Multiple paths with the same sum value on the same index value'
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both of these recursive paths have a sum value equal to `8` and an index value
    equal to `3` at the states indicated in red which, due the optimal substructure
    of the subset sum problem, means that the solution for that state only needs to
    be found once — its result will be the same any time those conditions are arrived
    at, regardless of what occurred before.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: With these facts in mind, we can essentially invert our top-down approach to
    develop the bottom-up approach.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-down logic:**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Start at the target sum and the first index of the set.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the set:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: - If the sum is reduced to zero, the result is `TRUE`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: - If the end of the set is reached or the target is exceeded, the result is
    `FALSE`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: - Otherwise, you can either subtract the current value from the sum or ignore
    it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: If the target can be found from state `S`, where the sum is equal to `x` and
    the index is equal to `i`, then the target can also be found from any earlier
    state that eventually leads to the state `S`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bottom-up logic:**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Start with sum and index values equal to `0`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Iterate through the set:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: - If a sum equal to `x` can be found between indices `0` and `i`, then a sum
    equal to `x` can also be found between indices `0` and `i+1`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: - If a sum equal to `x` can be found between indices `0` and `i`, then a sum
    equal to `x + set[i]` can be found between indices `0` and `i+1`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of how the table is filled, the top-down approach can be described
    as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'If the sum equals `x` and index equals `i` at state S1, the value of `memo(i,
    x) = true` if either of the following occurs:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: - The target can be found from state S2 (where the sum equals `x – set[i]` and
    index equals `i + 1`), OR…
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: - The target can be found from state S3 (where the sum equals `x` and index
    equals `i + 1`)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: - Otherwise, `memo(i, x) = false`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom-up version of this logic would be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'If the sum equals `x` and index equals `i`, the value of `DP(i, x) = true`
    if either of the following occurs:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: - `x` is less than the value of `set[i]` and `DP(i-1, x) = true`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: - `x` is greater than, or equal to, the value of `set[i]` and `DP(i-1, sum)
    = true OR DP(i-1, sum – set[i]) = true`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: - Otherwise, `DP(i, x) = false`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if we have already determined that a sum, `x`, can be formed
    between indices `0` and `i` (inclusive), then clearly, a sum equal to both `x`
    and `x + set[i]` can be formed between indices `0` and `i + 1`. We'll take a look
    at the implementation of this in the following exercise.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 39: Solving the Subset Sum Problem by Using Tabulation'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall modify the solution for *Exercise 38*, *Solving
    the Subset Sum Problem by Using Memoization*, so that we can use tabulation by
    converting the logic from top-down to bottom-up. Let''s get started:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define a new function called — you guessed it — `SubsetSum_Tabulation()`
    that takes an integer vector called `set` as an argument and returns a two-dimensional
    Boolean vector:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We declare a two-dimensional Boolean vector called `DP`. The first dimension''s
    size should be equal to the length of `set`, and the second dimension''s size
    should be equal to the highest possible subset sum in the set (that is, the total
    sum of all elements) plus one. Every value of DP should be initialized to `false`,
    except for the base cases (that is, the sum is equal to zero):'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we iterate across two nested `for` loops, corresponding to the first and
    second dimensions of the `DP` table:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, to fill the table, use the following code:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we once again modify the `main()` function to include our tabulated solution:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should see an output something like the one shown here:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The actual values for the time taken will vary depending on your system. Please
    note the difference in the values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the time taken by the tabulated solution is longer than both
    the memoization and backtracking solutions. However, using the DP table returned
    by `SubsetSum_Tabulation()`, we can use the following code to find every possible
    subset sum:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output of this should begin and end like this:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Thus, we have optimized the solution and also obtained the sum values of all
    the states.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we've explored a variety of ways of solving the subset
    sum problem, which, in turn, demonstrated the clear superiority of the dynamic
    programming approach; however, despite the comparative advantages that DP solutions
    have over the alternatives, we also demonstrated how the naive and relatively
    inefficient approaches can help us better understand the problem, which greatly
    simplifies the process of devising a solution using DP.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Some of the logic that's required by dynamic programming solutions may initially
    appear to be quite complex and difficult to grasp. It is highly recommended that
    you fully understand each solution approach we discussed in this section before
    proceeding further, since this is a process that can be accelerated by using different
    input parameters and comparing the results. Additionally, drawing diagrams of
    how different solutions are formed from given inputs can be particularly helpful.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 18: Travel Itinerary'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are designing a web application for a travel agency that wants to help clients
    plan their holiday itineraries. A major aspect of this software concerns route
    planning, which allows users to specify multiple locations they would like to
    visit and then view a list of cities they would have to pass through en route
    to their final destination.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Your agency has contracts with specific transportation companies in every major
    city, and each transportation company has set limits on how far they can travel.
    Whereas a plane or train can traverse multiple cities and even entire countries,
    a bus or taxi service may only be willing to travel one or two cities beyond their
    initial location. When your software produces the list of possible intermediate
    stops, it also displays the maximum number of cities the transportation company
    at that location is willing to travel so that clients can plot their course accordingly.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: You recently realized that your application needs some method of allowing clients
    to filter the number of options presented to them since many popular tourist locations
    are separated by dense clusters of towns. To do this, you want to determine the
    total number of possible ways to reach the ultimate destination from a given starting
    location so that you can reduce the amount of information that's displayed when
    it becomes excessive.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Your application already has the capability to calculate the list of locations
    on the ideal route between a departure point and destination. From this, you have
    derived the following data:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '`N`: An integer representing the number of cities between the source and the
    destination'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distance`: An array of integers representing the maximum number of cities
    the transportation company at each location is willing to traverse'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your task is to implement an algorithm that will calculate the total number
    of possible ways that the destination can be reached by traveling through a sequence
    of intermediate locations.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains a single integer, `N`, the number of cities between
    the starting point, and the destination.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: The second line contains `N` space-separated integers, where each integer, di,
    represents the maximum distance that can be traveled starting from the city at
    index `i`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Your program should output a single integer and the total number of ways to
    traverse the cities beginning at index `0` and ending at index `N`. Because the
    values get quite large as `N` increases, output each result as `modulo 1000000007`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**Example**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you were given the following input:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This means there are a total of six cities between the source and target locations.
    From a given city at index `i`, you have the option of traveling to any other
    city within the range of `i + 1` to `i + distance[i]` (inclusive). If we were
    to think of the sequence of cities as a graph, the adjacencies for the preceding
    example would be as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Observe the following figure for further clarification:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Example of city adjacencies](img/C14498_08_08.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Example of city adjacencies'
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding example, the destination can be reached in the following ways
    (with `E` representing the end point):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This gives us an answer of `9`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: In general, the traversal always starts at index `0` and ends at index `N`.
    It is guaranteed that the sum of a city's index `i` with `distance[i]` will never
    be greater than `N`, and that every city will have a corresponding distance value
    of at least `1`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test cases should help you to understand this problem better:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9: Activity 18 simple test cases'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_09.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.9: Activity 18 simple test cases'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here are some more complex test cases:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10: Activity 18 complex test cases'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_10.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.10: Activity 18 complex test cases'
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Extra Credit**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have found an approach that passes the preceding test cases within
    reasonable time limits, you can truly test the efficiency of your algorithm with
    one final test case, with `N` equal to `10000000`. Because the number of values
    would take too much space to print, you can use the following code to generate
    the array values programmatically:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Your program should print `318948158` as the result of this test case. An optimal
    algorithm should be able to find the result in under one second.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**Activity Guidelines**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: An optimal approach will run in `O(n)` time and require exactly `n` iterations.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are completely unsure as to how to formulate the DP solution, use the
    incremental approach that was described in this chapter, that is, by using brute
    force first and then progressively optimizing the solution.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For insights into how the problem's states are formed, consider the recurrence
    relation exhibited by the Fibonacci sequence.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 556.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Programming on Strings and Sequences
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our exploration of dynamic programming has primarily focused on combinatorial
    problems and calculating terms of integer sequences with defined formulae. Now,
    we will consider another one of DP's most common uses, that is, working with patterns
    in sequences of data. The most typical scenarios in which a programmer would use
    DP for this purpose generally concern searching, comparing, and constructing strings.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: As software developers, we often work collaboratively with several individuals
    who all have the ability to make contributions and modifications to the same project.
    Since the possibility always exists that a programmer may inadvertently introduce
    a bug into the code, or that the team may try a different approach for a given
    feature and then decide to return to their original method, it becomes extremely
    important to have some system of version control. In the event that a feature
    that was working recently mysteriously develops a glitch, it is essential to have
    the ability to see the changes that were made to the code, particularly in terms
    of how they differ from an earlier version. All version control systems therefore
    have a "diff" feature that analyzes the similarity between two versions of the
    same code and then displays this in some way to the user.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you had added the following code to the repository:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On the following day, you made some changes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A diff utility would then display something similar to the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11: Diff utility output](img/C14498_08_11.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.11: Diff utility output'
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To accomplish this, the utility needs to compute the similarity of the two code
    files by taking into account the fact that the sequence of text that is common
    to both versions may not necessarily be contiguous in the string. Additionally,
    parts of the original text may have been removed or appear in additional locations
    in the new version. This demonstrates the need for **approximate** (or "**fuzzy**")
    **string matching**, a technique that frequently makes use of dynamic programming.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The Longest Common Subsequence Problem
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **longest common subsequence problem** (commonly abbreviated as **LCS**)
    is one of the most famous classical examples of dynamic programming. It answers
    the following question: given two sequences of data, what is the longest subsequence
    common to both of them?'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider two strings, `A` and `B`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12: Two given strings for finding the longest common subsequence](img/C14498_08_12.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.12: Two given strings for finding the longest common subsequence'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The longest common subsequence would be "`LONGEST`":'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13: Longest common subsequence in the given strings](img/C14498_08_13.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.13: Longest common subsequence in the given strings'
  id: totrans-332
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Equipped with the insights that we've gained from the series of approaches we
    implemented for the subset sum problem, let's be a bit smarter about how we attack
    this one. We will start by formulating some ideas about the structure of the problem
    in advance, starting with the base cases.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it tends to be quite difficult to understand the nature of a DP problem
    for large inputs without first having considered the trivial ones, let''s create
    some examples of different scenarios using small input strings and try to find
    the length of the longest common subsequence (LCS):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the case where either or both strings are empty, it should be fairly obvious
    that the length of the longest common subsequence will always be equal to zero:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'These two cases have a simple binary definition – either they have a common
    character, or they do not:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Things become a bit more interesting with strings of length 2, but the logic
    is still quite trivial. Given two strings of length 2, they either are identical,
    have one character in common, or have no characters in common:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, the complexity of the problem is beginning to emerge. This case demonstrates
    that the comparisons progressively become much less straightforward:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'By now, it should be fairly obvious that the LCS problem does indeed contain
    overlapping subproblems. Similar to the previous problem, we can observe that
    there are 2n possible subsets of a given string, with `n` being equal to the string''s
    length, except now we have two sequences to contend with. Even worse is the fact
    that we are not simply considering the subsets of each sequence independently,
    but must also make comparisons between them:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14: All possible character subsequences of two strings, ABCX and
    ACY](img/C14498_08_14.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.14: All possible character subsequences of two strings, ABCX and ACY'
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The fact that we are not merely looking for consecutive groups of characters
    has several implications: firstly, the same sequence of characters can occur multiple
    times throughout the string and can be spaced across either string in any possible
    arrangement, assuming the order of the characters is the same. Secondly, there
    can be many common subsequences beginning from any given index.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementing our brute-force approach, let''s also define what constitutes
    a state for this problem. Let''s assume that we are maintaining two pointers,
    `i` and `j`, which represent character indices in `A` and `B`, respectively, as
    well as a record of the subsequence of common characters we have found:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we have reached the end of either string, there is nothing else to compare
    because the indices of subsequences are ordered:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If the characters are equal, there is no advantage in not including it in our
    found subsequence. We increment both pointers because any given character can
    only be considered once per subsequence:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we have not found a match, we have the choice to either explore the next
    subset of A''s characters, or the next subset of B''s characters. We do not include
    the case of incrementing both indices simultaneously from this state because it
    would be redundant. That case will be explored by the next function call. Outlining
    the structure of this recurrence would look like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15: Subproblem tree for the longest subsequence problem](img/C14498_08_15.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.15: Subproblem tree for the longest subsequence problem'
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding figure, the overlapping subproblems have been color coded.
    The optimal substructure of this problem is still not quite clear yet, but we
    can still make some basic generalizations:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: We only need to compare subsets of equal length.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a given state, the possibilities for the next state can be explored by
    incrementing `i`, `j`, or both.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our search always ends when the end of either string is reached.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, our preliminary brute-force implementation can provide additional
    insights. Let's get right to it in the following exercise.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 40: Finding the Longest Common Subsequence by Using the Brute-Force
    Approach'
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we shall use the brute-force approach to solve this problem,
    just like we did for the subset sum problem in *Exercise 36*, *Solving the Subset
    Sum Problem by Using the Brute-Force Approach*. Let''s get started:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by including the following headers and defining the `DEBUG` and `PRINT`
    macros that we used in the previous chapter:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Define a function called `LCS_BruteForce()` that takes the following arguments
    – two strings, `A` and `B`, two integers, `i` and `j`, and a vector of integer
    pairs, `subsequence` – and returns an integer. Above this function, we will also
    declare a two-dimensional vector of integer pairs with a global scope, that is,
    `found`:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`A` and `B` are, of course, the strings we are comparing, `i` and `j` represent
    our current positions in `A` and `B`, respectively, and `subsequence` is the collection
    of index pairs that form each common subsequence, which will be collected in `found`
    for output.'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we already have pseudocode to work with, we can implement our function
    with relative ease by simply inserting each line of pseudocode into our function
    as comments and translating it into C++ code underneath:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In `main()`, we''ll receive input in the form of two strings, and then call
    our function on it:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Like we did in the previous chapter, we will also output the subsequences found
    to `stderr` if `DEBUG` is not set to `0`. However, because of the greater complexity
    of this problem, we will put this output in a separate function, `PrintSubsequences()`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can then call this function in `main()`, specifying that it should be ignored
    unless `DEBUG` is set:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Setting `DEBUG` to `1` and using `ABCX` and `ACYXB` as input should produce
    the following output:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This output shows us all the possible combinations of subsequence pairs. Let's
    analyze this output in the following section and work toward optimizing our solution.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: First Steps Toward Optimization – Finding the Optimal Substructure
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s revisit the logic of our previous approach again to see how it may be
    optimized. Using the input strings from the previous exercise, `ABCX` and `ACYXB`,
    if our current state has `i = 0` and `j = 0`, we can clearly see that the only
    possibility for our next state is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As you may recall, one of our initial insights is that the LCS is equal to
    `0` if either or both strings are empty. We can also generalize that the LCS of
    a given prefix of `A` and a given prefix of `B` is equal to the maximum LCS of
    A''s prefix reduced by one character with `B`, and `B`''s prefix reduced by one
    character with `A`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Using this concept of the LCS for two strings being based on the LCS of their
    prefixes, we can redefine our logic as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Using memoization, we can store our results at every step in a two-dimensional
    table, with the first dimension equal to the size of `A` and the second dimension
    equal to the size of `B`. Assuming we have not reached the base case, we can check
    whether we have a cached result stored in `memo[i - 1][j - 1]`. If we do, we return
    the result; if not, we recursively explore possibilities in the same way as before
    and store the results accordingly. We'll implement this in the following activity.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 19: Finding the Longest Common Subsequence by Using Memoization'
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In solving the subset sum problem, we implemented various approaches, namely
    brute force, backtracking, memoization, and tabulation. In this activity, your
    task is to independently implement a solution to the longest common subsequence
    problem using memoization.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Two strings, *A* and *B*, respectively.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: The length of the longest common subsequence of *A* and *B*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test cases should help you to understand this problem better:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16: Activity 19 test cases'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_16.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.16: Activity 19 test cases'
  id: totrans-398
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Activity Guidelines:**'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: You can represent the state in two dimensions, with the first dimension bound
    by the length of *A*, and the second bound by the length of *B*.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very little must be changed to convert the brute-force algorithm into a memoized
    one.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure your approach has a way to differentiate between subproblems that
    have already been cached versus those that have not.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 563.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: From Top-Down to Bottom-Up – Converting the Memoized Approach into a Tabulated
    Approach
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we were to print out the values of the memo table for the pair of strings
    `ABCABDBEFBA` and `ABCBEFBEAB`, it would look like this (note that values of `-1`
    are unknown):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17: Memo table for ABCABDBEFBA and ABCBEFBE](img/C14498_08_17.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.17: Memo table for ABCABDBEFBA and ABCBEFBE'
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Looking up any of the row/column combinations where the characters are equal
    (say the 7th row and 7th column), we notice a pattern: the value at `memo[i][j]`
    is equal to `memo[i - 1][j - 1] + 1`.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the other case (that is, the characters are not equal); the
    pattern we see is that `memo[i][j]` is equal to the maximum of `memo[i - 1][j]`
    and `memo[i][j - 1]`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that we have found the optimal substructure of a problem, it is often
    quite a simple task to form a solution using tabulation by merely taking the table
    produced by a memoized solution and devising a scheme to build it from the bottom
    up. We will need to formulate some of our logic a bit differently, but the general
    ideas will essentially be the same. The first difference to contend with is the
    fact that the memo table's values are initialized to `UNKNOWN` (`-1`). Remember
    that a tabulated solution will fill the *entire* table with the appropriate results,
    and so nothing should be *unknown* by the time the algorithm has finished.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the unknown value in the second row and third column; what should
    this be equal to? Assuming the prefixes we are considering at that point are `AB_________`
    and `ABC_______`, it should be fairly clear that the LCS at this point is equal
    to `2`. Now, let''s consider the unknown value in the 10th row and the 9th column:
    the prefixes we are considering at this point are `ABCABDBEFB_` and `ABCBEFBEA_`,
    and the LCS that''s found at this point is `ABC_B__EFB_` —> `ABCBEFB___`, which
    is seven characters long. We can logically deduce that the LCS value at a given
    state is either equal to the previously found LCS, or one greater than the previously
    found LCS if the characters are equal. The lowest possible LCS value, of course,
    should be equal to 0\. So, our logic for filling a DP table iteratively would
    look something like this:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Our logic is essentially identical to what it was for the memoized solution,
    except that rather than recursively finding the values of unexplored states to
    fill the current state's value in the table, we fill the values for those states
    first and then simply reuse them as needed. We'll put this logic into code in
    the following activity.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 20: Finding the Longest Common Subsequence Using Tabulation'
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this activity, your task is to implement a bottom-up solution to the longest
    common subsequence problem using tabulation.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Two strings, *A* and *B*, respectively.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: The length of the longest common subsequence of *A* and *B*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '**Extra Credit**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the length of the LCS, also output the actual characters it contains.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Cases**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test cases should help you to understand this problem better:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18: Activity 20 test cases'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14498_08_18.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.18: Activity 20 test cases'
  id: totrans-427
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Activity Guidelines**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Like the subset sum problem, the tabulated solution requires iterating over
    two nested `for` loops.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a given state, `LCS(I, j)`, there are three possibilities that need to be
    handled – either the string's prefix is empty, the last characters of *A*'s and
    *B*'s prefixes are equal, or the last characters of *A*'s and *B*'s prefixes are
    not equal.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the characters of the LCS can be done by backtracking through the DP
    table.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 568.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 21: Melodic Permutations'
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note
  id: totrans-435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This activity is based around the traditional Western 8-note equal temperament
    scale, although students do not need to know anything about music theory to perform
    this activity. All the necessary information about the musical aspect is provided
    here.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Musical set theory is a form of categorization for musical harmonies and melodies
    according to the intervallic relations of their notes. In musical terminology,
    an interval can be defined as the distance between two notes in terms of their
    relative positions when written in musical notation:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19: Musical notations](img/C14498_08_19.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.19: Musical notations'
  id: totrans-439
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following figure demonstrates the distance between different musical notes
    when represented as musical notations:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20: Musical intervals](img/C14498_08_20.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.20: Musical intervals'
  id: totrans-442
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You are a music theorist who is curious about how many times a permutation
    of a particular note set appears within the melodies of various composers. Given
    the notes of a complete melody and a set of notes, count the number of times any
    [permutation](http://www.apple.com) of the note set appears within the melody.
    For any valid permutation, notes can be repeated any amount of times and can occur
    in any order:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following notes are described as *enharmonically equivalent* and should
    be considered identical:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The following diagram illustrates this equivalence on a piano:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21: Enharmonically equivalent notes represented on a section of
    a piano](img/C14498_08_21.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.21: Enharmonically equivalent notes represented on a section of a
    piano'
  id: totrans-449
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Thus, the following combinations of notes would be considered equivalent:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following are a few sample inputs and corresponding outputs:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Output: `21`'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output: `27`'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Output: `315`'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Output: `945`'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Input:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Output: `1323`'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'The guidelines for this activity are as follows:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: You do not actually have to know anything about music theory to solve this problem
    beyond what is explained in the description.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is there a better way to represent the notes? Could they be converted into a
    format that would be more amenable to a tabulated DP solution?
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the total count of subsets for *n* elements? Could this bit of information
    be useful in solving this problem?
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 574.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have analyzed and implemented two archetypal examples of
    dynamic programming and learned several methods by which different DP problems
    may be approached. We have also learned how to identify the characteristics of
    problems that can be solved with DP, how DP algorithms should be considered conceptually,
    and how the concepts of states, base cases, and recurrence relations can be used
    to break a complex problem down into much simpler components.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: We have just barely scratched the surface of the dynamic programming technique.
    Indeed, the two problems we explored in depth are actually quite similar, both
    conceptually and in terms of how their solutions are implemented. However, many
    of these similarities serve to demonstrate several commonalities that are encountered
    in nearly every DP problem, and, as such, they serve as an excellent introduction
    to a topic that is admittedly quite complex and difficult to master.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Using dynamic programming is a skill that you are unlikely to improve at merely
    through the act of reading or observing. The only way to truly get better with
    this technique is through solving as many problems with it as possible, preferably
    without guidance. At first, certain difficult DP problems may necessitate many
    attempts before the optimal solution is found, but the experience that you garner
    through this often arduous process is arguably much greater than what you are
    likely to gain through simply studying the solutions of any number of DP problems.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: The progressive approach to solving DP problems that was demonstrated in this
    chapter can serve you well in the future, but it is by no means the only way to
    arrive at the ultimate solution. After having solved a number of DP problems,
    you will undoubtedly begin to notice certain patterns that will make it possible
    to devise tabulated solutions from the start. However, these patterns are not
    likely to be discovered until you have encountered a range of different DP problems.
    Keep in mind the fact that with DP, just like any challenging skill, continuous
    practice will make it easier, and, before long, what originally appeared extremely
    daunting will eventually seem thoroughly manageable, and even quite fun!
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: In the final chapter, we will learn how to apply dynamic programming to more
    advanced situations and develop a deeper understanding of how DP problems that
    appear quite different from one another at first glance are often just variations
    on the same set of concepts. Finally, we will conclude this book by revisiting
    the topic of graphs to demonstrate how the DP paradigm can be effectively applied
    to the shortest path problem.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
