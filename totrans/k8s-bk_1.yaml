- en: '1: Kubernetes Primer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter is split into two main sections.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes background - where it came from etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of Kubernetes as a data center OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes background
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes is an orchestrator. For the most part, it orchestrates containerized
    apps. However, there are projects that enable it to orchestrate virtual machines
    and functions (serverless workloads). All of this is adding up to Kubernetes being
    the de-facto orchestrator for *cloud-native applications* .
  prefs: []
  type: TYPE_NORMAL
- en: So, what is an *orchestrator* and what is a *cloud-native app* ?
  prefs: []
  type: TYPE_NORMAL
- en: An *orchestrator* is a back-end system that deploys and manages applications.
    This means it helps you deploy your application, scale it up and down, perform
    updates and rollbacks, and more. And if it’s a good orchestrator, it does this
    without you having to supervise.
  prefs: []
  type: TYPE_NORMAL
- en: A *cloud-native application* is made from a set of small independent services
    that communicate and form into a useful application. As the name suggests, this
    design enables it to cope with cloud-like demands and run natively on cloud platforms.
    As an example, cloud-native applications are designed and written so that they
    can easily be scaled up and down as demand rises and falls. It’s also simple to
    update them and perform rollbacks. They can also self-heal.
  prefs: []
  type: TYPE_NORMAL
- en: More on all these concepts throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Despite the name, *cloud-native* apps can also run on-premises. In
    fact, an attribute of a cloud-native app might be the ability to run anywhere
    - any cloud, or any on-prem datacenter.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Where did Kubernetes come from
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start from the beginning… Kubernetes came out of Google! In the summer
    of 2014 it was open-sourced and handed over to the Cloud Native Computing Foundation
    (CNCF).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1](Image00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1
  prefs: []
  type: TYPE_NORMAL
- en: Since then, it’s gone on to become the most important cloud-native technology
    on the planet.
  prefs: []
  type: TYPE_NORMAL
- en: Like many of the modern cloud-native projects, it’s written in Go (Golang).
    It lives on Github at `kubernetes/kubernetes` . It’s actively discussed on the
    IRC channels, you can follow it on Twitter (@kubernetesio), and this is pretty
    good slack channel - slack.k8s.io. There are also regular meetups all over the
    planet!
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and Docker
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Kubernetes and Docker are complementary technologies. For example, it’s common
    to develop your applications with Docker, and then use Kubernetes to orchestrate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, you write your code in your favourite languages, and then use
    Docker to package it, test it, and ship it. But the final step of running it in
    test or production is handled by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: At a high-level, you might have a Kubernetes cluster with 10 nodes to run your
    production applications. Behind the scenes though, each node is running Docker
    as its container runtime. This means that Docker is the low-level technology that
    starts and stops containers etc., and Kubernetes is the higher-level technology
    that looks after the bigger picture things like; deciding which nodes to run certain
    parts of the app on, deciding when to scale up or down, and executing updates.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 shows a simple Kubernetes cluster with nodes using Docker as the
    container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2](Image00002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in Figure 1.2, Docker isn’t the only container runtime that
    Kubernetes supports. In fact, Kubernetes has a couple of features that abstract
    the runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: The Container Runtime Interface (CRI) is an abstraction layer that standardizes
    the way 3rd-party container runtimes interface with Kubernetes. It allows the
    container runtime code to exist outside of Kubernetes, but interface with it in
    a supported and standardized way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Runtime Classes* are a new feature in Kubernetes 1.12 (alpha) that allow for
    different classes of runtimes. For example, *gVisor* might provide better isolation
    than something like Docker or containerd.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the time of writing, `containerd` is overtaking Docker as the most commonly
    used container runtime in Kubernetes. `containerd` is effectively a stripped-down
    version of Docker with just the stuff that Kubernetes needs.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is low-level stuff, and none of it should impact your experience
    as a Kubernetes user. Whichever container runtime you use, the regular Kubernetes
    commands and patterns will continue to work as normal.
  prefs: []
  type: TYPE_NORMAL
- en: What about Kubernetes vs Docker Swarm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2016 and 2017 we had the *orchestrator wars* where Docker Swarm, Mesosphere
    DCOS, and Kubernetes fought over which would be de-facto container orchestrator.
    To cut a long story short, Kubernetes won.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, Docker Swarm and other container orchestrators still exist, but their development
    and market-share are tiny compared to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes and Borg: Resistance is futile!'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s a pretty good chance you’ll hear people talk about how Kubernetes relates
    to Google’s *Borg* and *Omega* systems.
  prefs: []
  type: TYPE_NORMAL
- en: It’s no secret that Google has been running many of its systems on containers
    for years. Legendary stories of them crunching through *billions of containers
    a week* are common. So yes, for a very long time – even before Docker came along
    - Google has been running things like *search* , *Gmail* , and *GFS* on containers
    - **lots** of containers!
  prefs: []
  type: TYPE_NORMAL
- en: Pulling the strings and keeping those billions of containers in check are a
    couple of in-house technologies and frameworks called *Borg* and *Omega* . So,
    it’s not a huge stretch to make the connection between these and Kubernetes -
    they’re all in the game of orchestrating containers at scale, and they’re all
    related to Google.
  prefs: []
  type: TYPE_NORMAL
- en: This has occasionally led to people thinking Kubernetes is an open-sourced version
    of either *Borg* or *Omega* . But it’s not! It’s more like Kubernetes shares its
    DNA and family history with them. A bit like this… In the beginning was Borg…
    and Borg begat Omega. Omega *knew* the open-source community and begat her Kubernetes
    ;-)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 - Shared DNA](Image00003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 - Shared DNA
  prefs: []
  type: TYPE_NORMAL
- en: The point is, all three are separate, but all three are related. In fact, a
    lot of the people involved with building Borg and Omega were also involved in
    building Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: So, although Kubernetes was built from scratch, it leverages much of what was
    learned at Google with Borg and Omega.
  prefs: []
  type: TYPE_NORMAL
- en: As things stand, Kubernetes is an open-source project under the CNCF, licensed
    under the Apache 2.0 license, and version 1 shipped way back in July 2015.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes - what’s in the name
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The name **Kubernetes** comes from the Greek word meaning *Helmsman* - the person
    who steers a ship. This theme is reflected in the logo.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 - The Kubernetes logo](Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 - The Kubernetes logo
  prefs: []
  type: TYPE_NORMAL
- en: '**Rumor:** Kubernetes was originally going to be called *Seven of Nine* . If
    you know your Star Trek, you’ll know that *Seven of Nine* is a female **Borg**
    rescued by the crew of the USS Voyager under the command of Captain Catherine
    Janeway. The **7** spokes on the logo are also a reference to Seven of *Nine*
    .'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One last thing about the name before moving on… You’ll often see Kubernetes
    shortened to **K8s** . The idea is that the number 8 replaces the 8 characters
    in between the K and the S – great for tweets and lazy typists like me ;-)
  prefs: []
  type: TYPE_NORMAL
- en: A data center OS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, containers make our previous scalability challenges look
    easy - we’ve just said that Google goes through billions of containers per week!!
  prefs: []
  type: TYPE_NORMAL
- en: OK… but not everybody is the size of Google. What about the rest of us?
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, if your legacy apps had hundreds of VMs, there’s a good chance
    your containerized cloud-native apps will have thousands of containers! With this
    in mind, we desperately need a way to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: Say hello to Kubernetes!
  prefs: []
  type: TYPE_NORMAL
- en: When getting your head around something like Kubernetes it’s important to get
    your head around modern data center architectures. For example, we’re abandoning
    the traditional view of the data center as collection of computers. Instead, we’re
    viewing it as a *single large computer* .
  prefs: []
  type: TYPE_NORMAL
- en: But what does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: A typical computer is a collection of CPU, RAM, storage, and networking. But
    we’ve done a great job of building operating systems (OS) that abstract away a
    lot of that detail. For example, it’s rare for a developer to care which CPU core
    or exact memory address their application uses – we let the OS decide all of that.
    And it’s a good thing, the world of application development is a far friendlier
    place for it.
  prefs: []
  type: TYPE_NORMAL
- en: So, it’s natural to take this to the next level and apply those same abstractions
    to data center resources - to view the data center as just a pool of compute,
    network and storage, and have an over-arching system that abstracts it. This means
    we no longer need to care about which server or LUN our containers are running
    on - just leave this up to the data center OS.
  prefs: []
  type: TYPE_NORMAL
- en: In some ways, Kubernetes is a data center OS. Others do exist, but they’re all
    in the *cattle business* . Forget about naming your servers, mapping LUNs in a
    spreadsheet, and otherwise treating them like *pets* . Systems like Kubernetes
    don’t care. Gone are the days of taking your app and saying *“Run this part of
    the app on this node, with this IP, on this specific LIUN…“* . In the cloud-native
    Kubernetes world, we’re more about saying *“Hey Kubernetes, I’ve got this app
    and it consists of these parts… just run it for me please”* . Kubernetes then
    goes off and does all the hard scheduling and orchestration work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** No offence is intended to anyone, or any animals, when using the
    terms *pets* and *cattle* .'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s look at a quick analogy…
  prefs: []
  type: TYPE_NORMAL
- en: Think about the process of sending goods via a courier service. You package
    the goods in the courier’s standard packaging, put a label on it, and hand it
    over to the courier. The courier takes care of everything else – all the complex
    logistics of which planes and trucks it goes on, which drivers to use etc. They
    also provide services that let you do things like track your package. The point
    is, the only thing that the courier requires is that the goods are packaged and
    labelled according to their requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for apps in Kubernetes. Package them as containers, give them
    a declarative manifest, and let Kubernetes take care of running them and keeping
    them running. You also get a rich set of tools and APIs that let you see what’s
    going on. It’s a beautiful thing!
  prefs: []
  type: TYPE_NORMAL
- en: While all of this sounds great, don’t take this *data center OS* analogy too
    far. It’s not a DVD install, you don’t end up with a shell prompt to control your
    entire data center. And you definitely don’t get a solitaire card game included!
    We’re in the early stages, but Kubernetes is leading the way and I think you’ll
    love it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes is *the* leading orchestrator of cloud-native apps. We give it an
    app, tell it what we want the app to look like, and let Kubernetes make happen.
  prefs: []
  type: TYPE_NORMAL
- en: It came out of Google, it’s open-sourced under the Apache 2.0 license, and lives
    within the Cloud Native Computing Foundation (CNCF).
  prefs: []
  type: TYPE_NORMAL
- en: Tip!
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes is a fast-moving project under active development, so things are
    changing fast! But don’t let that put you off - embrace it! Rapid change is the
    new normal!
  prefs: []
  type: TYPE_NORMAL
- en: As well as reading this book, I suggest you follow @kubernetesio on Twitter,
    hit the various k8s slack channels, and attend your local meetups. These will
    all help to keep you up-to-date with the latest and greatest in the Kubernetes
    world. I’ll also be updating the book regularly and producing more video training
    courses! Keep an eye on pluralsight.com and acloud.guru for my latest courses!
  prefs: []
  type: TYPE_NORMAL
