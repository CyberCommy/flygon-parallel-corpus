- en: Animating Components with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, animations are one of the cornerstones of modern user experience design.
    Far from just representing visual eye candy to beautify the UI, they have become
    an important part of the visual narrative. Animations pave the road to convey
    messages in a non-intrusive way, becoming a cheap but powerful tool for informing
    the user about the underlying processes and events that happen while we interact
    with our application. The moment an animation pattern becomes widespread and the
    audience embraces it as a modern standard, we gain access to a priceless tool
    for enhancing our application's user experience. Animations are language-agnostic,
    not necessarily bound to a single device or environment (web, desktop, or mobile),
    and pleasing to the eye of the beholder, when used wisely. In other words, animations
    are here to stay and Angular 2 has a strong commitment to this aspect of modern
    visual development.
  prefs: []
  type: TYPE_NORMAL
- en: With all modern browsers embracing the newer features of CSS3 for animation
    handling, Angular 2 offers support for implementing imperative animation scripting
    through an incredibly simple but powerful API. This chapter will cover several
    approaches to implementing animation effects, moving from leveraging plain vanilla
    CSS for applying class-based animations, to implementing script routines where
    Angular takes full responsibility for handling DOM transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating animations with plain vanilla CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging class-named animation with the `ngClass` directive to better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: handle transitions
  prefs: []
  type: TYPE_NORMAL
- en: Looking at Angular's built-in CSS hooks for defining styles for each
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transition state
  prefs: []
  type: TYPE_NORMAL
- en: Introducing animation triggers and declaratively attaching those animations
    to elements in your template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating components with the **AnimationBuilder** API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing directives that handle animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating animations with plain vanilla CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The inception of CSS-based animation was an important milestone in modern web
    design. Before that, we used to rely on JavaScript to accommodate animations in
    our web applications by manipulating DOM elements through complex and cumbersome
    scripts based on intervals, timeouts, and loops of all sorts. Unfortunately, this
    was neither maintainable nor scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Then, modern browsers embraced the functionalities brought about by the recent
    CSS transform, transition, keyframes, and animation properties. This became a
    game changer in the context of web interaction design. While support for these
    techniques in browsers, such as **Microsoft Internet Explorer**, is far from optimal,
    the rest of the browsers that are available (including Microsoft's very own Edge)
    provide full support for these CSS APIs.
  prefs: []
  type: TYPE_NORMAL
- en: MSIE provides support for these animation techniques only as of version 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'We assume that you have a broad understanding of how CSS animation works with
    regard to building keyframe-driven or transition-based animations, since providing
    coverage to these techniques is obviously beyond of the scope of this book. As
    a recap, we can highlight the fact that CSS-based animation is usually implemented
    by either of these approaches, or even a combination of both:'
  prefs: []
  type: TYPE_NORMAL
- en: Transition properties that will act as observers of either all, or just a subset,
    of the CSS properties applied to the DOM elements impacted by the selector. Whenever
    any of these CSS properties is changed, the DOM element will not take the new
    value right away, but will experience a steady transition into its new state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named keyframe animations, where we define different steps of the evolution
    of one, or several, CSS properties under a unique name, which will populate later
    on an animation property of a given selector, being one able to set additional
    parameters, such as the delay, the duration of the animation tweening, or the
    number of iterations that the animation is meant to feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see in the two aforementioned scenarios, the use of a CSS selector
    populated with animation settings is the starting point for all things related 
    to animation, and that is what we will do now. Let's build a fancy pulse animation
    to emulate a heartbeat-style effect in the bitmap that decorates our Pomodoro
    timer.
  prefs: []
  type: TYPE_NORMAL
- en: We will use a keyframe-based animation this time, so we will begin by building
    the actual CSS routine in a separate style sheet. The entire animation is based
    on a simple interpolation where we take an object, scale it up by 10 percent,
    and scale it back down again to its initial state. This keyframe-based tweening
    is then named and wrapped in a CSS class named `pulse`, which will execute the
    animation in an infinite loop where each iteration takes 1 second to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the CSS rules for implementing this animation will live in an external
    stylesheet, part of the timer widget component, within the `timer feature` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From this point on, any DOM element annotated with this class name will visually
    beat like a heart. This visual effect is actually a good hint that the element
    is undertaking some kind of action, so applying it to the main icon bitmap in
    our timer widget when the countdown is on will help convey the feeling that an
    activity is currently taking place in a lively fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, we have a good way to apply such an effect only when the countdown
    is active. We use the `isPaused` binding in the `TimerWidgetComponent` template.
    Binding its value to the `NgClass` directive in order to render the class name
    only when the component is not paused will do the trick, so just open the timer
    widget code unit file and add a reference to the stylesheet we just created and
    apply the directive as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Run our Pomodoro app and click on the `Timer` link at the top
    to reach the timer component page and check the visual effect live after starting
    the countdown. Stop it and resume it again to see the effect applied only when
    the countdown is active.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Angular animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea with an animation trigger is that you can show animations when a certain
    property changes from one state to the next. To define a trigger, we first need
    to install and import the library we need, specifically, `BrowserAnimationsModule`, so
    let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'We install the library by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now import and set up the module with `BrowsersAnimationsModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, it''s time to import a bunch of constructs that we need to set
    up the trigger itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The imported constructs have the following functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '`trigger`: This defines the property in the component that the animation targets;
    it needs a name as the first argument and an array of states and transitions as
    the second argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: This defines the property value and what CSS properties it should
    have; you need to define one of these for each value that the property can assume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transition`: This defines how the animation should play out when you go from
    one property value to another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`animate`: This carries out the defined animation when we move from one state
    value to the next'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first trigger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a quick look on what an animation trigger can look like, and then
    explain the parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `animations` array is something we add to the components object, such as
    template or `styleUrls`. Inside of the `animations` array are a number of trigger
    definitions. A `trigger` takes a name and an array of items, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Those items are either a state definition or a transition. With this knowledge,
    it is easier to understand what we are looking at. For now, we have chosen to
    call the trigger `animationName`. It defines two states and two transitions. A
    state says that a value has been changed to this state and we react accordingly
    by executing a style, which is why the code should be read as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that style properties are camel cased and not kebab cased, for example,
    write `backgroundColor` and not `background-color`, like you might be used to
    in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at our example, we are saying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If someone triggers `sizeAnimation` and the value is set to `small` then apply
    this transform: `scale(1)` and `backgroundColor: ''green''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If someone triggers `sizeAnimation`and the value is set to `large`then apply
    this transform: `scale(1.4)` and `backgroundColor: ''red''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two remaining items are two calls to `transition`. This instructs the animation
    on how to apply the animation in a smooth way. You can read a transition definition
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when we go from one state to the next, we apply an easing function and
    also define for how long the animation should execute. Let''s look back at our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We interpret it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: When we go from the value `small`to `large`, carry out the animation for `100ms`
    and use the`ease-in` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we go from the value `large`to `small`, carry out the animation for `100ms`
    and use the`ease-out` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have dissected our `trigger` statement completely, we have one
    last thing to do, and that is to connect the trigger to a property it needs to
    look at. So, let''s add a little more code to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, they key thing to look at is the `[@animationName]='state'`; this is where
    we say that the trigger should look at the component `state`property and we already
    know what values `state` should have for an animation to be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: The wildcard state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There can be more than just the two states that we defined for our trigger.
    In some cases, it makes more sense to apply transitions regardless of what state
    value we come from. For those cases, there is the wildcard state. Using the wildcard
    state is easy. You go to your transition definition and replace a state value
    with `*`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This means regardless of what state we were in before, a transition will happen
    when our `state` property assumes a `larger` value.
  prefs: []
  type: TYPE_NORMAL
- en: The void state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `void` state is different from the wildcard state. Void is the same thing
    as saying that if an element didn''t exist before, then it has the `void`value.
    Upon exiting, it assumes a value. The definition of a transition call, therefore,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make this more real by adding some code to our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have added one button set to call `abraCadabra()` to show the element
    and one button that calls`poof()`, which will hide the element. Let''s now add
    some code to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This trigger definition says the following, if an element goes from not existing
    to existing, `void => *`, then animate from `-100%` to `x` position `0`. When
    going from existing to non-existing, then move it out of the picture by moving
    it to `x` position `200%`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the final bit, our component code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see that calling the `abraCadabra()`method will trigger the state
    `'in'` and setting the Boolean`showMe` to`true` will trigger the transition `void
    => *`. This explains the main purpose of the `void` state, which is to be used
    when prior elements don't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Animation callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are occasions when you might want to know when you are kicking off an
    animation as well as knowing when the animation finishes. There is good news to
    be had here; we can find this out and execute whatever code we need for those
    occasions.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is listen to the `start` and `done` properties of our trigger,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, we need add code to our component so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Animating components with the AnimationBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have covered how to do animations with pure CSS or by defining a
    trigger that we can hook up to our markup. There is another more programmatic
    approach to animation. This approach uses a service called `AnimationBuilder`.
    There are some key factors involved in making this approach work, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnimationBuilder`: This is a service we inject; it has a single method, `build`,
    that when called creates an instance of an ``AnimationFactory``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnimationFactory`: This is the result of calling `build()` on an `AnimationBuilder` instance;
    it has been given a number of styling transformations and one or more animations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnimationPlayer`: The player needs an element on which to apply the animation
    instruction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s cover these bullets so we understand what happens, when, and to what
    element. First things first, we need to inject the `AnimationBuilder`to a component''s
    constructor and also inject an `elementRef` instance so we have a target for our
    animation, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have access to an instance of the `animationBuilder` and
    are ready to set up our style transformations and an animation, so let''s do that
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a transformation that sets the width to `0px` initially,
    and an animation setting the width to `100px` over `1` second. We have also assigned
    the result of calling `animationBuilder.build()`to a variable animation that is
    of type `AnimationFactory`. The next step is to create an instance of an animation
    player and decide what element to apply this animation to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We do two things here; first, we point out an element in our template where
    we want the animation to be applied to. Next, we create an instance of an animation
    player by calling `animation.create( elem )`with our element as input. What''s
    missing now is to create the element in the UI so our `querySelector()`can find
    it. We need to create an element with the CSS class text, which is just what we
    do in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The very last step is to call the `play()` method on our animation player instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Enjoy the animation as it plays in the browser. You can easily extend the animation
    by adding more properties to our `style({})` method call, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In summary, `AnimationBuilder` is a powerful way to create reusable animations
    that you can easily apply to an element of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable animation directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen how we can create an `AnimationBuilder` and how we can
    use it to programmatically create and apply animations at will. One way of making
    it reusable is to wrap it inside a directive. Creating a directive is quite a
    simple feat that we have done a few times already; the thing we need to keep in
    mind is that our directive will be applied to an element and this element is the
    thing that will be animated by our animation. Let''s summarize what we need to
    do in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inject `AnimationBuilder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create our animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an animation player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This list of things is very similar to when we explained how the `AnimationBuilder`
    worked, and it should be; after all, the directive is the only new thing here.
    Let''s define our directive and the animation; there really isn''t much to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need. Now we can just apply our directive to any element, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have only scratched the surface of dealing with animations. To read up on
    everything you can do, we suggest looking at the official documentation at [https://angular.io/guide/animations](https://angular.io/guide/animations).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we started looking at how to define vanilla CSS animations.
    Then, we explained animation triggers and how you can declaratively attach a defined
    animation to an element. Then, we looked at how to programmatically define animations
    and attach them to an element at will. The very last thing we did was to package
    our programmatic animations in a directive. There is a lot more to learn about
    animations, but now you should have a basic understanding of what APIs exist and
    when to use them. Go out there and make your app full of life, but remember, less
    is more.
  prefs: []
  type: TYPE_NORMAL
