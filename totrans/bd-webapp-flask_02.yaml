- en: Chapter 2. First App, How Hard Could it Be?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a full chapter without a single line of code, you need this, right? In
    this chapter, we will write our first app explained line by line; we will also
    cover how to set up our environment, what tools to use for development, and how
    to work with HTML in our app.
  prefs: []
  type: TYPE_NORMAL
- en: Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first app one writes when learning a new technology is usually a Hello World
    app, which consists of the minimum possible code necessary to start a simple application
    and show the text "Hello World!". Let's do exactly that using Flask.
  prefs: []
  type: TYPE_NORMAL
- en: This book is optimized for **Python 2.x**, so, that's the version I advise you
    to use from now on. All the examples and code are aimed at that Python version,
    which is the default in most Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites and tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's make sure our environment is properly configured. For this course,
    I assume you are using a Debian-like Linux distribution, such as Mint ([http://www.linuxmint.com/](http://www.linuxmint.com/))
    or Ubuntu ([http://ubuntu.com/](http://ubuntu.com/)). All the instructions will
    be geared towards these systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by installing the required Debian packages with `apt-get` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the Python development tools and libraries required for compiling
    Python packages, and pip: a neat tool you can use to install Python packages from
    the command line. On with it! Let''s install our virtual environment managing
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To explain what we just did: `sudo` tells our OS that we want administrative
    privileges to run the next command, and `pip` is the default Python package management
    tool and helps us install the `virtualenvwrapper` package. The second command
    statement adds a command to load the `virtualenvwrapper.sh` script together with
    the console, so that commands work inside your shell (we''ll be using it, by the
    way).'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A virtual environment is the way Python isolates full package environments
    from one another. This means you can easily manage dependencies. Imagine you want
    to define the minimum necessary packages for a project; a virtual environment
    would be perfect to let you test and export the list of needed packages. We will
    discuss it later on. Now, create a new terminal pressing *Ctrl* + *Shift* + *T*
    on your keyboard and create our *hello world* environment like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line creates our environment with the name "hello". You will also
    *automatically* load that environment into the current terminal. You can deactivate
    your virtual environment by typing `deactivate` and you can load it again with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The second line tells pip to install the Flask package in the current virtual
    environment, `hello` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the "Hello World" app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the environment set, what should we use to write our beautiful code? An
    editor or an IDE? If you're working on a low budget, try Light Table editor ([http://lighttable.com/](http://lighttable.com/)).
    Free, fast, and easy to use (*Ctrl* + *Spacebar* gives you access to all available
    options), it also has workspace support! Can't get any better for the money. If
    you're a lucky one with $200 to spare (or if you have a free license [https://www.jetbrains.com/pycharm/buy/](https://www.jetbrains.com/pycharm/buy/)),
    just fork out for the PyCharm IDE which is pretty much the best IDE for Python
    Web development. Now let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder that will hold your project files (you don''t need to but people
    will like you more if you do), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the new project folder and create the `main.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main.py` file will have the whole "Hello World" application in it. Our
    `main.py` content should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: Wow! That took some typing, right? No? Yeah, I know. So, what did we just do?
  prefs: []
  type: TYPE_NORMAL
- en: The first line states that our `main.py` file should use `utf-8` encoding. All
    the cool kids do that so don't be mean to your non-English pals and use that in
    all your Python files (doing so might help you avoid some nasty bugs in big projects).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second and third lines we import our Flask class and instantiate it.
    The name of our application is "app". Pretty much everything is related to it:
    views, blueprints, config, and so on. The argument, `__name__` is required and
    is used to tell the application where to look for resources such as static content
    or templates.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to create our "Hello World", we need to tell our Flask instance how
    to respond when a user tries to access our Web application (using a browser or
    whatever). For that purpose, Flask has routes.
  prefs: []
  type: TYPE_NORMAL
- en: Routes are the way Flask reads a request header and decides which view should
    respond to that request. It does so by analyzing the path part of the requested
    URL and finding which route is registered with that path.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *hello world* example, in line 5, we use the route decorator to register
    the `hello` function to the path `"/"`. Every time an app receives a request in
    which the path is `"/"`, `hello` will respond to that request. The following snippet
    shows how to check the path part of a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also have multiple routes mapped to the same function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, both the `"/"` and `"/index"` paths would map to `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: In lines 6 and 7 we have the function that will respond the request. Notice
    that it receives no parameters and responds –with a familiar string. It receives
    no parameters because the request data, like a submitted form, is accessed through
    a thread-safe variable called **request** that we will see more about in upcoming
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to the response, Flask can respond to requests in numerous formats.
    In our example, we respond with a plain string, but we could also respond with
    a JSON or HTML string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 9 and 10 are simple. They check whether `main.py` is being called as
    a script or as a module. If it is as a script, it will run the built-in development
    server that comes bundled with Flask. Let''s try that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Your terminal console will output something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just open `http://127.0.0.1:5000/` in your browser to see your app working.
  prefs: []
  type: TYPE_NORMAL
- en: Running `main.py` as a script is usually a very simple and handy setup. Usually,
    you have Flask-Script to handle calling the development server for you and other
    setups.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you used `main.py` as a module, just import it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You would usually do something like this to import an app factory function in
    your testing code.
  prefs: []
  type: TYPE_NORMAL
- en: That's pretty much all there is to know about our *"Hello World"* application.
    One thing our world application lacks is a fun factor. So let's add that; let's
    make your application fun! Maybe some HTML, CSS, and JavaScript could do the trick
    here. Let's try that!
  prefs: []
  type: TYPE_NORMAL
- en: Serving HTML pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, to make our `hello` function respond with HTML, all we have to do is
    change it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, `hello` is returning a HTML formatted string and a
    number. The string will be parsed as HTML by default while `200` is an optional
    HTTP code indicating a successful response. `200` is returned by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refresh your browser with *F5*, you''ll notice that nothing has changed.
    That''s why the Flask development server is not reloading when the source changes.
    That only happens when you run your application in debug mode. So let''s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go to the terminal where your application is running, type `Ctrl + C` then
    restart the server. You will notice a new output besides the URL where your server
    is running—something about "stat". That indicates your server will reload the
    code on source modification. That''s nice, but did you spot the crime we just
    committed: defining our template inside the function that handles the response?
    Be careful, the MVC gods might be watching. Let''s separate where we define our
    view from where we define our controller. Create a folder called templates and
    a file called `index.html` inside it. The `index.html` file content should be
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now change your code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Did you see what we did there? `render_response` is capable of loading templates
    from the `templates/` folder (a default for Flask) and you can render it just
    by returning the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add some JavaScript and CSS styles. By default, the Flask built-in
    development server serves all files in your `project` folder that are in a subfolder
    called `static`. Let''s create ours and add some files to it. Your project tree
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that I add files from the `foundation.zurb` framework, a nice CSS framework
    available in [http://foundation.zurb.com/](http://foundation.zurb.com/). I advise
    you to do the same in order to have a modern, good-looking site. The path to the
    static files in your template should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The folder, `/static` before the real file path is a route served by default
    by Flask that only works in debug mode. In production, you would have the HTTP
    server serving your static files for you. See the attached code for this chapter
    for the full example.
  prefs: []
  type: TYPE_NORMAL
- en: Try improving the *hello world* example with some nice CSS styling!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up a development environment is a very important task, and we just did
    this! Creating a *"Hello World"* application is a great way to introduce a new
    technology to someone. We also did that. At last, we learned how to serve an HTML
    page and static files, which is pretty much what most Web applications do. You
    acquired all these skills in this chapter, and I hope the process has been quite
    easy but fulfilling!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we add a little sauce to our challenges by getting more
    adventurous with templates. We'll learn how to use Jinja2 components to create
    powerful templates that allow us to do more with less typing. See you there!
  prefs: []
  type: TYPE_NORMAL
