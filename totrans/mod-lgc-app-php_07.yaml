- en: Chapter 7. Write Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, our legacy application has been partially modernized so that
    we have all existing classes in a central location. Those classes now enjoy freedom
    from `global` and `new` using dependency injection. The proper thing to do now
    is to write tests for these classes so that, if we ever need to change them, we
    know that their pre-existing behavior remains intact.
  prefs: []
  type: TYPE_NORMAL
- en: Fighting test resistance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are probably not eager to spend time writing tests right now. We don't want
    to lose the forward momentum we are feeling. Just as we believe we are making
    some real progress, stopping to write tests feels like make-work. It takes away
    from the joy of making yet another series of improvements to the awful codebase
    that we have been suffering under for so long.
  prefs: []
  type: TYPE_NORMAL
- en: The resistance to writing tests is understandable. I myself was only a slow
    convert to automated testing. If one is not used to it, the act of writing tests
    feels alien, unfamiliar, challenging, and unproductive. It is very easy to say,
    I can see the code is working, because the application is working.
  prefs: []
  type: TYPE_NORMAL
- en: 'And yet if we do not write tests, we are condemning ourselves to continued
    rounds of suffering later. We are enabling a particular kind of awfulness in our
    legacy application: that feeling of dread we feel when we change one part of the
    application, not knowing what other parts of the application are going to break
    as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: So while it may be true that writing tests sucks, it is also true that "having
    written tests" is awesome. It is awesome because, as we make changes to our classes,
    we can run an automated test suite, and it will tell us immediately if anything
    has broken after a change.
  prefs: []
  type: TYPE_NORMAL
- en: The way of Testivus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even if we are already familiar with writing tests, all of the dogma that surrounds
    testing can be intimidating:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not interact with the file system; build a virtual file system instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not interact with the database; build a set of data fixtures instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewrite your classes to use interfaces instead of concrete classes, and write
    test doubles for all the dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the kinds of dogmatic commands that make testing seem like an insurmountable
    challenge. Surely we can build our tests later when everything else is done! The
    problem is that there will never be a point when everything else is done, and
    so the tests will never come into being.
  prefs: []
  type: TYPE_NORMAL
- en: As an antidote to the dogma of testing commandments, I suggest following *The
    Way Of Testivus* ([http://www.artima.com/weblogs/viewpost.jsp?thread=203994](http://www.artima.com/weblogs/viewpost.jsp?thread=203994))
    instead. The core message of *The Way of Testivus* is More testing karma, less
    testing dogma.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the major points we need to take from *Testivus* in regard to modernizing
    our legacy application:'
  prefs: []
  type: TYPE_NORMAL
- en: The best time to test is when the code is fresh.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the test that needs to be written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An imperfect test today is better than a perfect test someday.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the test you can today.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code in the classes is stale. That code is part of a legacy application,
    after all. But now that we have spent so much time reorganizing the classes and
    removing their `global` and `new` keywords in favor of dependency injection, the
    code in those classes has been made fresh again in our minds. Now is the time
    to write the tests for these classes, while their operation is still in recent
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should not get hung up on writing proper unit tests that adhere to every
    commandment of testing dogma. Instead, we should write the best test we can, even
    if the test is imperfect:'
  prefs: []
  type: TYPE_NORMAL
- en: If we can write a characterization test that only checks the output as-it-is,
    then we should do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we can write a functional or integration test that interacts with the database,
    network, or file system, then we should do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we can write a loose unit test that combines concrete classes, then we should
    do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we can write a strict unit test that uses test doubles to fully isolate the
    tested class, then we should do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An imperfect test can be perfected as we become more adept at testing. A test
    that does not exist cannot be perfected at all.
  prefs: []
  type: TYPE_NORMAL
- en: We will write the tests we can, while we can, as soon as we can. Waiting to
    write tests will only increase the inertia against writing tests. The code will
    grow more stale in our mind, making the tests harder to write. Writing tests today
    will give us a sense of accomplishment and increase our inertia in favor of writing
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a test suite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not within the scope of this book to fully explain the technique and methodology
    of writing tests. Instead, we will review a very brief summary of the process
    involved in setting up the automated test suite and writing a simple test. For
    a more thorough treatment of testing in PHP, refer to *The Grumpy Programmer's
    PHPUnit Cookbook* ([http://grumpy-phpunit.com/](http://grumpy-phpunit.com/))by
    *Chris Hartjes*.
  prefs: []
  type: TYPE_NORMAL
- en: Install PHPUnit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many different testing systems in PHP land, but the most commonly
    used one is PHPUnit. We need to install PHPUnit on our development and testing
    servers in order to write and execute our tests. The full installation instructions
    are at the PHPUnit site.
  prefs: []
  type: TYPE_NORMAL
- en: 'One easy way to install PHPUnit is via Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to install a `.phar` of PHPUnit directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create a tests/ directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once we have PHPUnit installed, we need to create a `tests/` directory in our
    legacy application. The name and location do not matter so much as the fact that
    the purpose and place are obvious. The most obvious place is probably at the root
    of the legacy application, though it should not be directly accessible by browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `tests/` directory, we need to create a subdirectory named for our
    central class directory location. If all our application classes are in a directory
    named `classes/`, then we should have a `tests/classes/` directory. The idea is
    for our testing structure to mimic the structure of our application classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `tests/classes/` subdirectory, the `tests/` directory should
    contain two files. The first is a `bootstrap.php` file that PHPUnit will execute
    when it runs. Its purpose is to help set up the execution environment for the
    tests. By default, PHPUnit will not use the application autoloader code, so creating
    and registering the autoloader is a classic use for the `bootstrap.php` file.
    Here is an example using the autoloader from an earlier chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also in the `tests/` directory, we need to create a `phpunit.xml` file. This
    tells PHPUnit how to bootstrap itself and where the tests are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the `tests/` directory and its contents, our legacy application
    directory structure should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pick a class to test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have a `tests/` directory in place, we can actually write a test
    for one of our application classes. The easiest way to get started is to pick
    a class that has no dependencies. We should be familiar enough with the codebase
    at this point that we know which classes have dependencies and which do not. If
    we cannot find a class that has no dependencies, we should pick the one with the
    fewest dependencies, or with the least-complex dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to do here is *start small* and get some early wins. Each win
    will give us the drive and motivation to continue with larger, more complex tests.
    These smaller wins will accumulate into a final big win: a fully-tested set of
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's say we have picked a class named `Foo` that has no dependencies, and that
    it has a method called `doSomething()`. We are now going to write a test for this
    class method.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a skeleton test file in our `tests/classes/` directory. Its
    location should mimic the location of the class being tested. We add `Test` to
    the end of the class name, and extend `PHPUnitFramework_TestCase_` so that we
    have access to the various `assert*()` methods in the testing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run our tests now with `phpunit`, the test will fail because it
    has no test methods in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Believe it or not, this is just fine! As *The Way Of Testivus* tells us, we
    rejoice when our tests pass, and we rejoice when they fail. The failure here tells
    us that PHPUnit has successfully found our test class, but did not find any tests
    in that class. That tells us what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add a test method for a public method of the class being
    tested. All test methods begin with the word `test`, so we will test the `doSomething()`
    method using a method named `testDoSomething()`. In it, we will create an instance
    of the `_Foo_` class, invoke its public `doSomething()` method, and assert that
    its actual output is the same as what we expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run our test suite again with `phpunit`. As long as the `doSomething()`
    method returns the string `Did the thing!` then our test will pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We rejoice because our tests have passed!
  prefs: []
  type: TYPE_NORMAL
- en: If `doSomething()` ever returns anything different, then the test will fail.
    This means that if we change `doSomething()` in the course of our following work,
    we will know that its behavior has changed. We will rejoice in its failure, knowing
    that we have caught a bug before it went into production, and then fix the code
    until all the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: Do ... While
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After we write a passing test, we commit it to revision control and push it
    to our central repository. We continue writing tests for each public method in
    the application class, committing and pushing as we go. When all the public methods
    in the application class have passing tests, we pick another class to test, and
    begin again with a new test class.
  prefs: []
  type: TYPE_NORMAL
- en: Common Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can we skip this step and do it later?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No.
  prefs: []
  type: TYPE_NORMAL
- en: Come On, Really, Can We Do This Later?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look, I get it. I really do. Testing feels unrewarding at this point in our
    modernization process. If the entire rest of the chapter has not convinced you
    of the benefit of tests, then there's not much else I can say to convince you
    now. If you want to skip this step, you're going to skip it no matter what advice
    you read here.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let us assume that our reasons for avoiding tests at this point are perfectly
    sensible and well-adjusted to our particular context. With that in mind, let''s
    take a look at some things we can do to get those tests done, if not now then
    over the course of the project. Go on to the next chapter (unadvisedly!) but then
    commit to one or more of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: Complete at least one new test class per day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each time we use a method in the codebase, check to see if there is a test for
    it. If there is not, write one before using the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we fix a bug or build a feature, create a list of methods used over the course
    of the task, then write tests for those methods when the task is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we add a new class method, write a corresponding test for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delegate the writing of tests to another developer, perhaps a junior developer.
    Then we can have the "fun" of modernizing, and the junior developer can have the
    perceived boring work of writing tests, but beware ... pretty soon, the junior
    developer will know more about the codebase than we do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These options allow us to build up a test suite and still feel like we are making
    progress elsewhere. Creating an automated test suite is a non-negotiable aspect
    of modernizing our legacy application. Write tests now, or write them as we go,
    but write them, sooner rather than later.
  prefs: []
  type: TYPE_NORMAL
- en: What about hard-to-test classes?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Even with dependency injection in place, some of the classes in the legacy
    application are going to be hard to write tests for. There are lots of ways in
    which the classes can be hard to test and I cannot do the solutions justice in
    this book. Instead, please refer to these works:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Working Effectively With Legacy Code* by *Michael Feathers*. The examples
    throughout are in Java, but the situations are similar to those in PHP. Feathers
    shows how to break dependencies, introduce seams, and otherwise improve the testability
    of legacy classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring by Fowler et al. This one also uses Java in the examples, but thanks
    to Adam Culp, we have the same examples converted to PHP. As with Fowler's Patterns
    of Enterprise Application Architecture, the Refactoring book will give you a vocabulary
    to describe things you probably already know how to do, as well as introduce you
    to new techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information in these publications will help us improve the quality of our
    classes without changing the behavior of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: What about our earlier characterization tests?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tests we write as a result of this chapter are probably not a replacement
    for any existing characterization tests from the chapter on Prerequisites. Having
    the two sets of tests is likely to be a blessing, not a curse. At some point,
    the characterization tests may end up being converted to acceptance tests for
    use by the QA team. Until then, run both sets of tests from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: Should we test private and protected methods?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Probably not. There are dogmatic reasons for this that I will not go into here,
    but the short version is this: tests that inspect too deeply the internal workings
    of a class become difficult to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we should test only the public methods on our classes. Any behavior
    exposed by these methods is likely to be the only behavior we care about. There
    are some exceptions to this rule, but at this stage in our testing career, the
    exceptions are less important than the rule.
  prefs: []
  type: TYPE_NORMAL
- en: Can we change a test after we write it?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The time will come when we need to change the existing behavior of an application
    class method. In these cases, it is all right to change the related test to suit
    the new behavior. However, when we do so, we must be sure to run the entire test
    suite, not just the tests for that application class. Running the entire test
    suite will help us make sure that the change does not break behavior in other
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to test Third-party libraries?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If our legacy application uses third-party libraries, they may already come
    with tests. We should run these from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: If the third-party libraries do not come with tests, we may choose to write
    some, depending on our priorities. If we are dependent on the library behaving
    the same way between upgrades, it would be wise to write some tests of our own
    to make sure that the expected behaviors remain in place.
  prefs: []
  type: TYPE_NORMAL
- en: Building tests for a third-party library may be difficult if it is not written
    in an easily-testable way. If the library is free software or open source, perhaps
    this is an opportunity to contribute back to the project. However, our main priority
    is probably our own legacy application, not third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: What about code coverage?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Code coverage is a report given by PHPUnit to tell us how many lines of code
    we have tested. (Strictly speaking, it tells us the number of statements that
    have been tested).
  prefs: []
  type: TYPE_NORMAL
- en: A particular case may only test part of a class, or part of a method, and leave
    some of the code untested. The parts that are tested are called the covered portions
    of the code and the parts that are not tested are uncovered.
  prefs: []
  type: TYPE_NORMAL
- en: It is mostly the uncovered parts of the codebase that we need to worry about.
    If anything in the uncovered code changes, the tests won't detect it, and so we
    may be open to bugs and other regressions.
  prefs: []
  type: TYPE_NORMAL
- en: If we can, we should discover the code coverage of our tests early and often.
    These coverage reports will help us determine what needs to be tested next, and
    which parts of the codebase need to be refactored so they are easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: More code coverage is better. However, reaching 100% line coverage is probably
    not feasible (and, indeed, is not the final goal, that being 100% condition/decision
    coverage among other things). If we can reach 100% coverage, though, we should.
  prefs: []
  type: TYPE_NORMAL
- en: For more on this topic, please review the PHPUnit documentation on code coverage
    at [https://phpunit.de/manual/3.7/en/code-coverage-analysis.html](https://phpunit.de/manual/3.7/en/code-coverage-analysis.html).
  prefs: []
  type: TYPE_NORMAL
- en: Review and next steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we have completed writing our tests, as briefly outlined in this chapter,
    we will have created a great trap for future bugs. Each time we run our tests,
    any changes to the expected behavior will stand out as failures for us to correct.
    This ensures that as we continue refactoring, we will be doing more good than
    harm to our legacy codebase as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, because we now have a working test suite, we can add tests for
    any new behavior extracted from our legacy codebase into our application classes.
    Each time we create a new application class method, we will also create a passing
    test for that method. Each time we modify an application class method, we will
    run the test suite so that we can find bugs and breaks before they make it into
    production. We will rejoice when our tests pass, and we will rejoice when they
    fail; each outcome is a positive sign when it comes to modernizing our legacy
    application.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we can continue our modernization process. The next step is to extract
    our data retrieval and persistence behaviors from the page scripts and into a
    series of classes. Generally, this means moving all our SQL calls to a separate
    layer.
  prefs: []
  type: TYPE_NORMAL
