- en: Chapter 4. OpenGL Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenGL in Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hello World!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering 2D shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering 3D shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texturing in OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting and texture filter in OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving an object using keyboard controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3D Canvas in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use **Open Graphics Library** (**OpenGL**),
    a powerful rendering **Application Program Interface** (**API**), and combine
    it with Qt. OpenGL is a cross-language, cross platform API for drawing 2D and
    3D graphics on screen through the **Graphics Processing Unit** (**GPU**) within
    our computer's graphics chip. In this chapter, we will be learning OpenGL 2.x
    instead of 3.x, because the fixed-function pipeline is easier for beginners to
    grasp compared to the newer programmable pipeline. Qt supports both versions,
    so there should be no problem switching over to OpenGL 3.x and above once you
    have learned the basic concepts of OpenGL rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up OpenGL in Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to set up OpenGL in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's create a new Qt widgets application by going to **File** | **New
    File or Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will remove the `mainwindow.ui` file because we are not going to use
    it in this example. Right-click on the `mainwindow.ui` file and select **Remove
    File** from the drop-down menu. Then, a message box will appear and ask for your
    confirmation. Tick **Delete file permanently** and press the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, open up your project file (`.pro`) and add the OpenGL module to
    your project by adding an `opengl` keyword behind `QT +=`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to add another line in your project file so that it will load
    both the OpenGL and **GLu** (**OpenGL Utilities**) libraries during startup. Without
    these two libraries, you program will not be able to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open up `mainwindow.h` and remove several things from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code to your `mainwindow.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have done that, we will proceed to the source file, which is `mainwindow.cpp`.
    Functions that we have just added to the header, such as `initializeGL()`, `resizeGL()`,
    and so on, can be left empty for now; we will only use these in the next section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, set a title for the main window and resize it to 640x480 by adding
    the following code to your `main.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run the project now, you will see an empty window with a
    black background. Don't worry about it, your program is now running on OpenGL!![How
    to do it…](img/B02820_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OpenGL module must be added to the project file (`.pro`) in order to access
    header files that are related to OpenGL, such as QtOpenGL, QOpenGLFunctions, and
    so on. We used the `QOpenGLWindow` class instead of `QMainWindow` for the main
    window because it's designed to easily create windows that perform OpenGL rendering,
    and it offers better performance compared to QOpenGLWidget due to the fact that
    it has no dependencies in its widget module. We must call `setSurfaceType(QWindow::OpenGLSurface`)
    to tell Qt we prefer to use OpenGL to render the images to screen, instead of
    QPainter. The `QOpenGLWindow` class provides several virtual functions (`initializeGL()`,
    `resizeGL()`, `paintGL()`, and so on) for us to conveniently set up OpenGL and
    perform graphics rendering.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenGL is a cross-language, cross-platform API for drawing 2D and 3D graphics
    on screen through the **Graphics Processing Unit** (**GPU**) within our computer's
    graphics chip.
  prefs: []
  type: TYPE_NORMAL
- en: Computer graphics technology has been evolving rapidly over the years, so rapidly
    that the software industry can hardly keep up with its pace. In 2008, Khronos
    Group, the company that maintains and develops OpenGL, announced the release of
    the OpenGL 3.0 specification, which created a huge uproar and controversy throughout
    the industry. That was mainly because OpenGL 3.0 was supposed to deprecate the
    entire fixed-function pipeline from the OpenGL API, and it was simply an impossible
    task for the big players to make the sudden switch overnight from a fixed-function
    pipeline to a programmable pipeline. This resulted in two different major versions
    of OpenGL being maintained concurrently by the Khronos Group, namely OpenGL 2.x
    and 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be learning OpenGL 2.x instead of 3.x, because the
    fixed-function pipeline is easier for beginners to grasp than the programmable
    pipeline. It's very straightforward and less confusing for learning the basics
    of computer graphics programming. Qt supports both versions, so there should be
    no problem switching over to OpenGL 3.x (and above) once you have learned the
    basic concepts of OpenGL rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Qt uses OpenGL internally whenever it sees fit. Moreover, the new Qt Quick 2
    renderer is based on OpenGL and is now a core part of Qt's graphical offering.
    That makes OpenGL more compatible with Qt than any other graphics APIs, such as
    DirectX.
  prefs: []
  type: TYPE_NORMAL
- en: Hello world!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn about the pipeline of OpenGL and how to render
    a simple shape to the window. We will continue from the example project used in
    the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, go to `mainwindow.h` and add the following headers at the top
    of the source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare two private variables in `mainwindow.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, move over to `mainwindow.cpp` and set the surface format to compatibility
    profile. We also set the OpenGL version to 2.1 and create the OpenGL context using
    the format we just declared. Then, use the context we just created to access the
    OpenGL functions that are relevant only to the OpenGL version we have just set,
    by calling `context->functions()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will start adding some code to the `paintGL()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing will appear on the screen yet until we call `paintGL()` in the `paintEvent()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run the project now, you should be able to see a white rectangle
    being drawn in front of a blue background:![How to do it…](img/B02820_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must set the OpenGL version to 2.1 and the surface format to compatibility
    profile so that we can access the fixed-function pipeline, which no longer exists
    in the newer version. Alternatively, you can set the surface format to `QSurfaceFormat::CoreProfile`
    if you want to use OpenGL 3.x and above.
  prefs: []
  type: TYPE_NORMAL
- en: We called `glClearColor()` and `glClear(GL_COLOR_BUFFER_BIT)` to remove the
    previous `render buffer` (or in layman's terms, the previous frame) and fill the
    entire canvas with the color we provided. We will repeat this step after an image
    has been rendered so that it clears the entire screen before we proceed to the
    next frame. We called `glBegin(GL_QUAD)` to tell OpenGL we are about to draw a
    quad on the screen. After that, we provided the positions of all the vertices
    (or points) to OpenGL so that it will know how the quad should be positioned on
    the screen by calling `glVertex2f()` four times, because a quad can only be constructed
    by connecting four different points. Then, we called `glEnd()` to inform OpenGL
    that we are done with the quad.
  prefs: []
  type: TYPE_NORMAL
- en: Always call `glFlush()` once you are done drawing images on screen so that OpenGL
    clears away all the unwanted information from the memory to give space to the
    next drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we must call `paintGL()` in the `paintEvent()` function, or else nothing
    will be drawn on the screen. Just like what we have learned in the previous chapters,
    all drawings happen within the `paintEvent()` function, and it will only be called
    by Qt when it thinks it's necessary to refresh the screen. To force Qt to update
    the screen, call `update()` manually.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering 2D shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have already learned how to draw our first rectangle on the screen,
    we will further enhance it in this section. We will take the previous example
    and continue from there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, go to the `paintGL()` function in `mainwindow.cpp` and replace the quad
    in the previous example with new code. This time, we draw a quad together with
    a triangle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `resizeGL()` function, add the following code to adjust the viewport
    and orthographic view so that the rendered image correctly follows the window''s
    aspect ratio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `resizeEvent()` function, call the `resize()` function and force
    the main window to refresh the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, in the `initializeGL()` function, we call `resizeGL()` once so
    that the aspect ratio of the first rendered image is correct (before any window
    resize event is triggered):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you're done with that, compile and run the program. You should see something
    like this:![How to do it…](img/B02820_04_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The geometric primitive types supported by OpenGL are points, lines, linestrips,
    line loops, polygons, quads, quad strips, triangles, triangle strips, and triangle
    fans. In this example, we drew a quad and a triangle, where each of the shapes
    is provided with a set of vertices and colors so that OpenGL knows how the shapes
    should be rendered. The rainbow color is created by giving a different color to
    each of the vertices. OpenGL will automatically interpolate the colors between
    each vertex and display it onscreen. The shape that gets rendered later will always
    appear in front of other shapes. In this case, the triangle is being rendered
    later and hence it appears in front of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: We need to calculate the aspect ratio of the main window every time it's resized,
    so that the rendered image will not be stretched and result in an odd appearance.
    Always reset the projection matrix by calling `glMatrixMode()` and `glLoadIdentity()`
    before calling `glViewport()` and `glOrtho()` so that the shapes are being rendered
    correctly when resizing the main window. Without resetting the projection matrix,
    we will be using the matrices from the previous frame and hence producing the
    wrong projection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to call `update()` when the window is being resized, otherwise the
    screen will not be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Render 3D shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to draw simple 2D shapes onscreen in the previous section.
    However, to fully utilize the OpenGL API, we also need to learn how to use it
    to render 3D images. In a nutshell, 3D images are simply an illusion created using
    2D shapes stacked in a way that makes them look like 3D.
  prefs: []
  type: TYPE_NORMAL
- en: The main ingredient here is the depth value, which determines which shapes should
    appear in front or at the back of the other shapes. The primitive shape that is
    positioned behind another surface (with a shallower depth than another shape)
    will not be rendered (or partially rendered). OpenGL provides a simple way to
    achieve this, without too much technical hassle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, add the `QTimer` header to your `mainwindow.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a private variable to your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a public slot to `mainwindow.h` for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, enable depth testing by adding `glEnable(GL_DEPTH_TEST)` to the
    `initializeGL()` function in `mainwindow.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will alter the `resizeGL()` function so that it uses the perspective
    view instead of the orthogonal view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to alter the `paintGL()` function as well. First, add `GL_DEPTH_BUFFER_BIT`
    to the `glClear()` function, because we also need to clear the depth information
    for the previous frame before we proceed to render the next frame. Then, remove
    the code we used in the previous example, which rendered a quad and a triangle
    on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, before calling `glFlush()`, we will add the following code to draw a
    3D cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done with that, add a timer to the construction of the `MainWindow`
    class, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we increase the rotation variable by 10 every time the `updateAnimation()`
    slot is called by the timer. We also manually call the `update()` function to
    update the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run the program now, you should see a spinning cube in your
    main window!![How to do it…](img/B02820_04_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any 3D rendering, depth is very important and thus we need to enable the
    depth testing feature in OpenGL by calling `glEnable(GL_DEPTH_TEST)`. When we
    clear the buffer, we also must specify `GL_DEPH_BUFFER_BIT` so that the depth
    information is also being cleared, in order for the next image to be rendered
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `gluPerspective()` to set up a perspective projection matrix so that
    the graphics appear to have depth and distance. The opposite to the perspective
    view is the orthographic view, which is the default view in OpenGL, and we have
    used it in our previous example. Orthographic projection is a form of parallel
    projection where objects appear to be flat and do not suggest depth and distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B02820_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we used a timer to increase the rotation value by 10 every
    100 milliseconds (0.1 second). The rotation value is then applied to the cube
    by calling `glRotatef()` before supplying the vertex data to OpenGL. We also called
    `glTranslatef()` to move the cube slightly to the back so that it's not too close
    to the camera view.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to call `update()` manually so that the screen gets refreshed, otherwise
    the cube will not be animated.
  prefs: []
  type: TYPE_NORMAL
- en: Texturing in OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenGL allows us to map an image (also referred to as a texture) to a 3D shape
    or polygon. This process is also called texture mapping. Qt appears to be the
    best combination with OpenGL in this case because it provides an easy way to load
    images that belong to one of the common formats (BMP, JPEG, PNG, TARGA, TIFF,
    and so on) and you don't have to implement it by yourself. We will use the previous
    example with a spinning cube and try to map it with a texture!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, open up `mainwindow.h` and add the following header to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare an array that stores the texture IDs created by OpenGL. We will
    be using it later when it comes to rendering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, open up `mainwindow.cpp` and add the following code to `initializeGL()`
    to load the texture file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following code to the `paintGL()` function to apply the texture
    to the 3D cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run the program now, you should see a brick cube rotating
    around the screen!![How to do it…](img/B02820_04_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The variable `GLuint texID[1]` is an array that stores the texture ID generated
    by OpenGL when we call `glGenTexture()`, which OpenGL uses to allocate the texture
    from the memory during rendering. In this case, we set the size of the array to
    `1` because we are only using a single texture in this example. We must tell OpenGL
    to enable texturing by calling `glEnable(GL_TEXTURE_2D)` before doing anything
    related to texturing. We used two `QImage` classes to load the texture, the first
    one called `image` was used to load the image file, and the second one called
    `texture` was used to convert the image to an OpenGL-compatible format. Then we
    called `glGenTextures()` to generate an empty texture using OpenGL, and after
    that, we called `glBindTexture()` to select that particular texture. This step
    was needed so that the functions called after that will be applied to the texture
    that we just selected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we called `glTexParameteri()` twice to set both the texture minifying
    and texture magnification settings to point sampling. This will tell OpenGL how
    the texture should be rendered. More about that later. After that, we called `glTexImage2D()`
    to supply the pixel information from the texture file loaded by Qt to the empty
    OpenGL texture we just created. Call `glEnabled(GL_TEXTURE_2D)` and `glBindTexture()`
    to enable texturing in OpenGL and select the texture we wanted to use before we
    start rendering the 3D cube. Then, we must call `glTexCoord2f()` before calling
    `glVertex3f()` to tell OpenGL how the texture should be mapped. We supply the
    coordinates for the texture and OpenGL will figure out the rest for us.
  prefs: []
  type: TYPE_NORMAL
- en: Once you're done, call `glDisable(GL_TEXTURE_2D)` to disable texturing.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting and texture filter in OpenGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to apply different types of filtering effects
    such as point sampling, bilinear interpolation, and trilinear interpolation to
    the textures we use in OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Again, we will use the previous example and add a light near the spinning cube.
    Open up `mainwindow.cpp` and add the following code to the `initializeGL()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, go to the `paintGL()` function and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run the program now, you should see the lighting in action!![How
    to do it…](img/B02820_04_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the fixed pipeline, it''s extremely easy to add lights to your scene. First,
    we need to choose which shading model we want OpenGL to use. In our case, we chose
    the smooth shading model by calling `glShaderModel(GL_SMOOTH)`. Alternatively,
    you can also pick the flat shading model by calling `glShaderModel(GL_FLAT)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B02820_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, enable the first light in OpenGL by calling `glEnable(GL_LIGHT1)`.
    Since there is a limited number of lights allowed in the fixed pipeline, the names
    of the lights are all static: `GL_LIGHT1`, `GL_LIGHT2`, `GL_LIGHT3`, and so on.
    Next, we created three arrays that store the color of the ambient light, the color
    of the diffuse light, and the position of the diffuse light. Ambient light is
    the environment lighting, which affects the entire scene and has no position.
    Diffuse light, on the other hand, has a position and area of light influence.
    We then supply this information to OpenGL by calling the `glLightfv()` functions.
    Then, in `paintGL()`, we must enable the lighting by calling `glEnable(GL_LIGHTING)`
    before we start rendering the cube. Without it, you won''t see any lighting effects
    applied to the cube.'
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, we also need to add a surface normal value to every surface
    of the cube. Surface normal indicates where the surface is facing and is used
    for lighting calculations. Don't forget to disable lighting once you're done with
    it by calling `glDisable(GL_LIGHTING)`.
  prefs: []
  type: TYPE_NORMAL
- en: Besides adding a light to the scene, we also changed the texture filtering setting
    to trilinear interpolation by calling `glTexParameteri()`, which makes the texture
    looks smoother. You can also try out the other two types of filtering, point filtering
    and bilinear filtering, by uncommenting the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the distinction between three different types of
    filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/B02820_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bilinear and trilinear filtering require a mipmap in order to work, which we
    can ask OpenGL to generate by calling `glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP,
    GL_TRUE)`. Mipmaps are pre-calculated, optimized sequences of textures, each of
    which is a progressively lower resolution representation of the same image. OpenGL
    will switch the texture of an object to a lower resolution mipmap when moving
    further away from the camera, which is effective for avoiding visual artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a 3D scene, lighting is a very important aspect that helps to define the
    3D shape of an object. A light doesn't just make the surfaces facing the light
    become brighter, but it also makes other surfaces that are blocked become darker.
  prefs: []
  type: TYPE_NORMAL
- en: In OpenGL, at least in the fixed-function pipeline, you can only add a limited
    number of lights to the scene. The number of lights is limited by the graphics
    chip – some support up to four lights, some support up to eight, and some support
    up to 16\. However, since the fixed-function pipeline is slowly being phased out
    and people are starting to use the programmable pipeline, this problem has been
    solved. In the programmable pipeline, you can have any number of lights in the
    scene; however, the lighting model will need to be coded entirely by you in the
    shaders, which is not an easy task.
  prefs: []
  type: TYPE_NORMAL
- en: In the fixed-function pipeline, if you want to add more lights than what your
    graphics chip supports, what you can do is to turn off lights that are further
    away from the camera view and only turn on a few that are closer to your camera
    view. The disadvantage of this method is that you may see the lights popping on
    and off while walking along a maze, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Moving an object using keyboard controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this topic we'll be looking at is how to move an object in OpenGL using keyboard
    controls. Qt provides an easy way to detect keyboard events using virtual functions,
    namely `keyPressEvent()` and `keyReleaseEvent()`. We will be using the previous
    example and adding to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up `mainwindow.h` and declare two floating point numbers called `moveX`
    and `moveZ`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, declare the `keyPressEvent()` function, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open up `mainwindow.cpp` and set the default values for the two variables
    we just declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will implement the `keyPressEvent()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we call `glTranslatef()` before drawing the 3D cube and putting
    both `moveX` and `moveZ` into the function. Also, we disabled the rotation so
    that it''s easier to see the movement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you compile and run the program now, you should be able to move the cube
    around by pressing *W*, *A*, *S* and *D*:![How to do it…](img/B02820_04_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basically, what we did here was add or subtract the `moveX` and `moveZ` values
    when a key is pressed. In `keyPressEvent()`, we checked whether the keyboard button
    pressed was *W*, *A*, *S*, or *D*. Then, we add or subtract 0.2 from the variables
    accordingly. To get the full list of key names used by Qt, visit [http://doc.qt.io/qt-5/qt.html#Key-enum](http://doc.qt.io/qt-5/qt.html#Key-enum).
  prefs: []
  type: TYPE_NORMAL
- en: When we hold down the same key and don't release it, Qt will repeat the key
    press event after an interval. The keyboard input interval varies between different
    operating systems. You can set the interval by calling `QApplication::setKeyboardInterval()`,
    but this may not work in every operating system. We called `glTranslatef(moveX,
    0.0, moveZ)` before drawing the cube, which moves the cube around when we press
    *W*, *A*, *S*, or *D*.
  prefs: []
  type: TYPE_NORMAL
- en: 3D canvas in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to render 3D images using Qt's powerful QML
    scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start this example by creating a new project in Qt Creator. This time
    around, we will create **Qt Canvas 3D Application** and not the other options
    that we chose in all previous examples:![How to do it…](img/B02820_04_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, Qt Creator will ask you whether to create a project that is based
    on `three.js`. Leave the option checked and press the **Next** button to proceed:![How
    to do it…](img/B02820_04_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project is created, you will notice there are some JavaScript (`.js`)
    files already added to your project's resources. This is normal as the Qt Canvas
    3D application uses JavaScript and WebGL technology to render 3D images on screen.
    In this case, it's running a WebGL-based rendering library called three.js, which
    makes our programming job simpler and easier compare to writing pure WebGL code:![How
    to do it…](img/B02820_04_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add an image file to our project resources as we'll be using it in this
    example. Open up `qml.qrc` with Qt Creator by right-clicking on it in the **Projects**
    pane and select **Open in Editor**. Once the resources file is opened by Qt Creator,
    click the **Add** button, followed by the **Add File** button, then select the
    image file you want from your computer. In my case, I've added a `bricks.png`
    image, which will be used as the surface texture for our 3D object:![How to do
    it…](img/B02820_04_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, open up `glcode.js` using Qt Creator. You will see there is already
    plenty of code written in the file. What ithis does is basically render a simple
    3D cube on screen using the `three.js` library. You can build the project right
    away and run it to see what it looks like. However, we will change the code a
    little bit to customize its output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `initializeGL()` function, we''ll add a directional light to the scene,
    load the texture file we just added to our project resources, and then apply the
    texture to the material that defines the surface properties of the 3D cube. Also,
    we will make the scale of the cube slightly bigger by setting its scale to `3`
    in all dimensions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `paintGL()` function, add an extra line of code to rotate the
    3D cube before rendering the scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'I personally find the window size is a little too large, so I also changed
    the width and height of the window in `main.qml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once you're done, let's build and run the project. You should be able to see
    a 3D cube with a brick texture, spinning slowly on the screen:![How to do it…](img/B02820_04_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally, `three.js` was a cross-browser JavaScript library/API that used
    WebGL technology to display animated 3D computer graphics in a web browser. Qt
    Canvas 3D, however, also uses web technology, specifically the WebGL technology,
    to render 3D images like it would on a web browser. This means that not only is
    `three.js` supported on Qt Canvas 3D, but all the different types of library that
    are based on WebGL technology will work flawlessly on Qt Canvas 3D. However, Qt
    Canvas 3D only works on QML-based projects and does not work in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're interested to learn more about `three.js`, check out their website
    at [http://threejs.org](http://threejs.org).
  prefs: []
  type: TYPE_NORMAL
