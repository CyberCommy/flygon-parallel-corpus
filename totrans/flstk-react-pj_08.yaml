- en: Building a Media Streaming Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading and streaming media content, specifically video content, has been
    a growing part of internet culture for some time now. From individuals sharing
    personal video content to the entertainment industry disseminating commercial
    content on online streaming services, we all rely on web applications that enable
    smooth uploading and streaming. Capabilities within the MERN stack technologies
    can be used to build and integrate these core streaming features into any MERN-based
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics to implement basic media
    uploading and streaming by extending the MERN skeleton application:'
  prefs: []
  type: TYPE_NORMAL
- en: Uploading videos to MongoDB GridFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving media details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming from GridFS to a basic media player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MERN Mediastream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build the MERN Mediastream application by extending the base application.
    It will be a simple video streaming application that allows registered users to
    upload videos that can be streamed by anyone browsing through the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/71c4f48b-a483-4c54-aa63-b515ec8ff080.png)The code for the complete
    MERN Mediastream application is available on GitHub [github.com/shamahoque/mern-mediastream](https://github.com/shamahoque/mern-mediastream). The
    implementations discussed in this chapter can be accessed in the `simple-mediastream-gridfs`
    branch of the same repository. You can clone this code and run the application
    as you go through the code explanations in the rest of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The views needed for the features related to media upload, editing, and streaming
    in a simple media player will be developed by extending and modifying the existing React
    components in the MERN skeleton application. The component-tree pictured next
    shows all the custom React components that make up the MERN Mediastream frontend
    developed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4ff4252c-f5de-4c9d-a967-550090c679eb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Uploading and storing media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users on MERN Mediastream will be able to upload videos from their
    local files to store the video and related details directly on MongoDB using GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: Media model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to store media details, we will add a Mongoose Schema for the media
    model in `server/models/media.model.js` with fields to record the media title,
    description, genre, number of views, created time, updated time, and reference
    to the user who posted the media.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/models/media.model.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB GridFS to store large files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we discussed how files uploaded by users could be stored
    directly in MongoDB as binary data. But this only worked for files smaller than
    16 MB. In order to store larger files in MongoDB, we will need to use GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: GridFS stores large files in MongoDB by dividing the file into several chunks
    of a maximum of 255 KB each, and then storing each chunk as a separate document.
    When the file has to be retrieved in response to a query to GridFS, the chunks
    are reassembled as needed. This opens up the option to fetch and load only parts
    of the file as required, rather than retrieving the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of storing and retrieving video files for MERN Mediastream, we will
    utilize GridFS to store video files, and also to stream parts of the video depending
    on which part the user skips to and starts playing from.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `gridfs-stream` npm module to add GridFS features to our server-side
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To configure `gridfs-stream` with our database connection, we will use Mongoose
    to link it up as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `gridfs` object will give access to the GridFS functionalities required
    to store the file when new media is created and to fetch the file when the media
    is to be streamed back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a media API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will set up a create media API on the Express server that will receive a
    POST request at `'/api/media/new/:userId'` with the multipart body content containing
    the media fields and the uploaded video file.
  prefs: []
  type: TYPE_NORMAL
- en: Route to create media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `server/routes/media.routes.js`, we will add the create route, and utilize
    the `userByID` method from the user controller. The `userByID` method processes
    the `:userId` parameter passed in the URL and retrieves the associated user from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A POST request to the create route will first make sure the user is signed in
    and then initiate the `create` method in the media controller.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the user and auth routes, we will have to mount the media routes
    on the Express app in `express.js` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/express.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Controller method to handle create request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `create` controller method in the media controller will use the `formidable`
    npm module to parse the multipart request body that will contain the media details
    and video file uploaded by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The media fields received in the form data, and parsed with `formidable`, will
    be used to generate a new Media object and saved to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If there is a file in the request, `formidable` will store it temporarily in
    the filesystem, and we will use the media object's ID to create a `gridfs.writeStream`
    to read the temporary file and write it into MongoDB. This will generate the associated
    chunks and file information documents in MongoDB. When it is time to retrieve
    this file, we will identify it with the media ID.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch create API in the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `api-media.js`, we will add a corresponding method to make a `POST` request
    to the create API by passing the multipart form data from the view.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/user/api-user.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `create` fetch method will be used when the user submits the new media
    form to upload a new video.
  prefs: []
  type: TYPE_NORMAL
- en: New media form view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A registered user will see a link on the menu to add new media. This link will
    take them to the new media form view and allow them to upload a video file along
    with details of the video.
  prefs: []
  type: TYPE_NORMAL
- en: Adding media menu button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `client/core/Menu.js`, we will update the existing code that renders the
    My Profile and Signout links to add the Add Media button link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/70473631-4b0c-4671-a6d6-5f5ea13228f7.png)'
  prefs: []
  type: TYPE_IMG
- en: This will only render on the menu if the user is currently signed in.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/core/Menu.js/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: React route for NewMedia view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To take the user to the new media form view when they click the Add Media link,
    we will update the `MainRouter` file to add the `/media/new` React route, which
    will render the `NewMedia` component.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As this new media form should only be accessed by a signed-in user, we will
    add it as a `PrivateRoute`.
  prefs: []
  type: TYPE_NORMAL
- en: NewMedia component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `NewMedia` component, we will render a form that allows a user to create
    media by entering the title, description, and genre, and uploading a video file
    from their local file system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/88d4481d-4f65-41db-9f97-d32ab8547e5e.png)'
  prefs: []
  type: TYPE_IMG
- en: We will add the file upload elements using a Material-UI `Button` and an HTML5
    `file input` element.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Title`, `Description`, and `Genre` form fields will be added with `TextField`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These form field changes will be tracked with the `handleChange` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `handleChange` method updates the state with the new values and populates
    `mediaData`, which is a `FormData` object. The `FormData` API ensures that the
    data to be sent to the server is stored in the correct format needed for the encoding-type
    `multipart/form-data`. This `mediaData` object is initialized in `componentDidMount`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon form submit, the `create` fetch method is called with the necessary credentials
    and the form data passed as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On successful media creation, the user may be redirected to a different view
    as desired, for example, to a Media view with the new media details.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/NewMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In order to allow users to stream and view this video file stored in MongoDB,
    next we will implement how to retrieve and render the video in the view.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve and stream media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the server, we will set up a route to retrieve a single video file, which
    we will then use as a source in a React media player to render the streaming video.
  prefs: []
  type: TYPE_NORMAL
- en: Get video API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will add a route in the media routes to fetch a video when a GET request
    is received at `'/api/medias/video/:mediaId'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `:mediaId` parameter in the route URL will be processed in the `mediaByID`
    controller to fetch the associated document from the Media collection and attached
    to the request object, so it may be used in the `video` controller method as required.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `video` controller method in `media.controller.js` will use `gridfs` to
    find the video associated with the `mediaId` in MongoDB. Then, if the matching
    video is found and depending on whether the request contains range headers, the
    response will send back the correct chunks of video with the related content information
    set as response headers.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 4If the request contains range headers, for example when the user drags to the
    middle of the video and starts playing from that point, we need to convert the
    range headers to start and end positions that will correspond with the correct
    chunks stored using GridFS. Then we will pass these start and end values as a
    range to the gridfs-stream's `createReadStream` method, and also set the response
    headers with additional file details including content length, range, and type.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The final `readStream` piped to the response can be rendered directly in a basic
    HTML5 media player or a React-flavored media player in the frontend view.
  prefs: []
  type: TYPE_NORMAL
- en: React media player to render the video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A good option for a React-flavored media player is the `ReactPlayer` component
    available as an npm, which can be customized as required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/815895de-c19d-439e-b16b-56eb8b0c12d2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It can be used in the application by installing the corresponding `npm` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For basic usage with default controls provided by the browser, we can add it
    to any React view in the application that has access to the ID of the media to
    be rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the next chapter, we will look into advanced options for customizing this
    `ReactPlayer` with our own controls.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about what is possible with `ReactPlayer`, visit [cookpete.com/react-player](https://cookpete.com/react-player).
  prefs: []
  type: TYPE_NORMAL
- en: Media list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In MERN Mediastream, we will add list views of relevant media with a snapshot
    of each video to give visitors easier access and an overview of the videos on
    the application. We will set up list APIs in the backend to retrieve different
    lists, such as videos uploaded by a single user and the most popular videos with
    the highest views in the application. Then, these retrieved lists can be rendered
    in the `MediaList` component, which will receive a list as a prop from a parent
    component that fetches the specific API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c2da7fb-dec3-407d-b2e4-3114b4b61e71.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, the `Profile` component uses the list by user API
    to fetch the list of media posted by the user seen in the preceding profile, and
    passes the received list to the `MediaList` component to render each video and
    media details.
  prefs: []
  type: TYPE_NORMAL
- en: MediaList component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MediaList` component is a reusable component that will take a list of media
    and iterate through it to render each item in the view. In MERN Mediastream, we
    use it to render a list of the most popular media in the home view and a list
    of media uploaded by a specific user in their profile.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/MediaList.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `MediaList` component uses the Material-UI `GridList` components as it iterates
    through the list sent in the props, and renders media details for each item in
    the list, along with a `ReactPlayer` component that renders the video URL without
    showing any controls. In the view, this gives the visitor a brief overview of
    the media and also a glimpse of the video content.
  prefs: []
  type: TYPE_NORMAL
- en: List popular media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to retrieve specific lists of media from the database, we need to set
    up relevant APIs on the server. For popular media, we will set up a route that
    receives a GET request at `/api/media/popular`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `listPopular` controller method will query the Media collection to retrieve
    ten media documents that have the highest `views` in the whole collection.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To use this API in the view, we will set up a corresponding fetch method in
    `api-media.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/api-media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This `fetch` method will be called when the `Home` component mounts so the list
    can be set to state and passed to the `MediaList` component in the view.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/core/Home.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the Home view, we will add the `MediaList` as follows, with the list provided
    as a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: List media by users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To retrieve a list of media uploaded by a specific user, we will set up an API
    with a route that accepts a GET request at `'/api/media/by/:userId'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `listByUser` controller method will query the Media collection to find media
    documents that have `postedBy` values matching the `userId`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To use this list by user API in the frontend view, we will set up a corresponding
    `fetch` method in `api-media.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/user/api-user.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This fetch method can be used in the `Profile` component, similar to the `listPopular`
    fetch method used in the home view, to retrieve the list data, set to state, and
    then pass to the `MediaList` component.
  prefs: []
  type: TYPE_NORMAL
- en: Display, update, and delete media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any visitor to MERN Mediastream will be able to view media details and stream
    the video, while only registered users will be able to edit the details and delete
    the media any time after they post it on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Display media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any visitor to the MERN Mediastream will be able to browse to a single media
    view to play the video and read the details associated with the media. Every time
    a specific video is loaded on the application, we will also increment the number
    of views associated with the media.
  prefs: []
  type: TYPE_NORMAL
- en: Read media API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fetch media information for a specific media record, we will set up a route
    that accepts a GET request at `'/api/media/:mediaId'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `mediaId` in the request URL will cause the `mediaByID` controller method
    to execute and attach the retrieved media document to the request object. Then
    this media data will be returned in the response by the `read` controller method.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A GET request to this API will also execute the `incrementViews` controller
    method, which will find the matching media record and increment the `views` value
    by `1` before saving the updated record to the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In order to use this read API in the frontend, we will set up a corresponding
    fetch method in `api-media.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/user/api-user.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The read API can be used to render individual media details in a view or to
    pre-populate a media edit form.
  prefs: []
  type: TYPE_NORMAL
- en: Media component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Media` component will render details of an individual media record and
    stream the video in a basic `ReactPlayer` with default browser controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0573b444-addd-489c-99eb-7fb12e3c0a68.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Media` component can call the read API to fetch the media data itself or
    receive the data as props from a parent component that makes the call to the read
    API. In the latter case, the parent component will add the `Media` component,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/PlayMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In MERN Mediastream, we add the `Media` component in a `PlayMedia` component
    that fetches the media content from the server using the read API, and passes
    it to Media as a prop. The `Media` component will take this data and render it
    in the view to display the details and load the video in a `ReactPlayer` component.
  prefs: []
  type: TYPE_NORMAL
- en: The title, genre, and view count can be rendered in a Material-UI `CardHeader`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The video URL, which is basically the GET API route we set up in the backend,
    is loaded in a `ReactPlayer` with default browser controls.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `Media` component renders additional details about the user who posted the
    video, and the media description, along with the date the media was created.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Media` component also conditionally shows an edit and a delete option if
    the currently-signed-in user is also the one who posted the media being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/Media.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The edit option links to the media edit form, and the delete option opens a
    dialog box that can initiate the deletion of this particular media document from
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Update media details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registered users will have access to an edit form for each of their media uploads,
    updating and submitting this form will save the changes to the document in the
    Media collection.
  prefs: []
  type: TYPE_NORMAL
- en: Media update API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To allow users to update media details, we will set up a media update API that
    accepts a PUT request at `'/api/media/:mediaId'` with the updated details in the
    request body.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When this request is received, the server will first ensure the signed-in user
    is the original poster of the media content by calling the `isPoster` controller
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If the user is authorized, the `update` controller method will be called `next`,
    to update the existing media document with the changes and then save it to the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To access the update API in the frontend, we will add a corresponding fetch
    method in `api-media.js` that takes the necessary credentials and media details
    as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/user/api-user.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This fetch method will be used in the media edit form when the user makes updates
    and submits the form.
  prefs: []
  type: TYPE_NORMAL
- en: Media edit form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The media edit form will be similar to the new media form, but without the
    upload option, and the fields will be pre-populated with the existing details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dd5cc45f-20f1-422b-b493-2d38f7343bca.png)'
  prefs: []
  type: TYPE_IMG
- en: The `EditMedia` component containing this form, which can only be accessed by
    signed-in users, will be rendered at `'/media/edit/:mediaId'`. This private route
    will be declared in `MainRouter` with the other frontend routes.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/MainRouter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Once the `EditMedia` component mounts on the view, a fetch call will be made
    to the read media API to retrieve the media details and set to state so the values
    are rendered in the text fields.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/EditMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The form field elements will be the same as in the `NewMedia` component. When
    a user updates any of the values in the form, the changes will be registered in
    the `media` object in state with a call to the `handleChange` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`mediastream/client/media/EditMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When the user is done editing and clicks submit, a call will be made to the
    update API with the required credentials and the changed media values.
  prefs: []
  type: TYPE_NORMAL
- en: '`mediastream/client/media/EditMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will update the media details, and the video file associated with the media
    will remain as it is in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting media
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An authenticated user can delete the media they uploaded to the application
    completely, including the media document in the Media collection, and the file
    chunks stored in MongoDB using GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: The Delete media API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the backend, we will add a DELETE route that allows an authorized user to
    delete their uploaded media records.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/routes/media.routes.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When the server receives a DELETE request at `'/api/media/:mediaId'`, it will
    first make sure the signed-in user is the original poster of the media that needs
    to be deleted. Then the `remove` controller method will delete the specified media
    details from the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/server/controllers/media.controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Besides deleting the media record from the Media collection, we also use `gridfs`
    to remove the associated file details and chunks stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will also add a corresponding method in `api-media.js` to fetch the `delete`
    API from the view.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/user/api-user.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The DeleteMedia component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `DeleteMedia` component is added to the `Media` component and is only visible
    to the signed-in user who added this specific media. This component takes the
    media ID and title as props:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0470db1-6793-4723-8c9e-b918a4929e74.png)'
  prefs: []
  type: TYPE_IMG
- en: This `DeleteMedia` component is basically an icon button that on click opens
    a confirm dialog to ask the user whether they are sure they want to delete their
    video.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/DeleteMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When the user confirms the delete intent, the `delete` fetch method is called.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/DeleteMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then on successful deletion, the user is redirected to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: '`mern-mediastream/client/media/DeleteMedia.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The MERN Mediastream application developed in this chapter is a complete media
    streaming application with capabilities of uploading video files to the database,
    streaming stored videos back to the viewers, support for CRUD operations such
    as media create, update, read, and delete, along with options to list media by
    uploader or popularity.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed a media streaming application by extending the
    MERN Skeleton application and leveraging MongoDB GridFS.
  prefs: []
  type: TYPE_NORMAL
- en: Besides adding basic add, update, delete, and listing features for media, we
    looked into how MERN-based applications can allow users to upload video files,
    store these files into MongoDB GridFS as chunks, and stream the video back to
    the viewer partially or fully as required. We also covered a basic use of `ReactPlayer`
    with default browser controls to stream the video file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can customize `ReactPlayer` with our
    own controls and functionality so users have more options, such as playing the
    next video in a list. In addition, we will discuss how to improve the SEO of the
    media details by implementing server-side rendering with data for the media view.
  prefs: []
  type: TYPE_NORMAL
