- en: Chapter 8. Exploiting Trust Through Cryptography Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The development of commercially available encryption and cryptographic methods
    has been crucial to the adoption of the internet as the engine of the global economy.
    The web has come a long way from its early days with early browsers such as Erwise
    and Mosaic delivering static, open information to mainly education users. It is
    hard to imagine a time when the web was plain-text, when information was transmitted
    (and stored, for that matter) without any protection against theft or snooping.
    Now, the financial, personal, and intellectual transactions that the internet
    facilitates are protected by mathematically-driven algorithms such as the **Secure
    Socket Layer** (**SSL**)/Â **Transport Layer Security** (**TLS**), **Advanced
    Encryption Standard**Â (**AES**), **Secure Hashing Algorithm** (**SHA**), and
    **Diffie-Helman** (**DH**). Together, these standards and more, coupled with an
    extensive infrastructure for the sharing of keys are what enable us to trust these
    transactions. That trust is understandable; consumer-grade electronics and open-source
    software are readily available to implement cryptographic techniques to provide
    the three key tenets of information security; **Confidentiality**, **Integrity**,
    and **Availability** (**CIA**). This, of course, assumes everyone is using the
    right standards and protocols and that they are configured properly.
  prefs: []
  type: TYPE_NORMAL
- en: Attacks focused on cryptographic methods (and related fields, like steganography)
    often avoid trying to break the encryption itself. The *Apple vs. United States
    Department of Justice* battle over backdoors into iPhones is telling; it is cheap
    and easy to encrypt communications, but incredibly hard to break that same encryption.
    Attackers might instead look to head encryption off at the pass; to intercept
    the information before it is encrypted, or after it is decrypted by the recipient.
    This is easier technically, but practically speaking, they have to be on those
    hosts. Wouldn't it be easier to fool both the sender and recipient; source and
    destination into believing that their own system is one of the two interested
    parties? This is in essence the **Man-in-the-Middle** (**MITM**) attack, and its
    uses extend far beyond mere intercepts. This is a sort of *if you can't beat 'em,
    join 'em* approach.
  prefs: []
  type: TYPE_NORMAL
- en: MITM attacks are popular for many forms of hacking; credential capture, poisoned
    web traffic resulting in malware delivery, redirection to a malicious portal,
    or the collection and potential manipulation of the flows themselves are possible.
    Defending against these malicious uses is made more difficult because the same
    techniques have legitimate uses in the enterprise. Web proxies and firewalls use
    SSL/TLS MITM for good, helping to hide and protect the end users and their clients,
    allowing for full inspection and content filtering, and ensuring protection from
    denial of service attacks and privacy. As long as these two opposed uses of these
    techniques exist, attackers can leverage them in their hacking of our customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must be able to uncover and validate all perceivable flaws, via both circumvention
    and MITM. In this chapter, we''ll see how encryption is used in web application
    communications, peer into encrypted sessions, and either circumvent encryption
    or breach it using MITM attacks. In this chapter, we''ll go through the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how weak ciphers can be compromised by persistent attackers and how
    we can detect them using OpenSSL, **SSLyze**, and **SSLscan**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiencing how we perform MITM attacks against a secure connection, spot interesting
    payloads, and manipulate them using **SSLsplit** and **SSLsniff**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defeating SSL altogether by acting as a MITM and removing encryption from the
    flow usingÂ **SSLstrip**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How secret is your secret?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Estimates place SSL/TLS use in web traffic at over 60%, and with public sentiment
    regarding snooping and intercept by both hackers and governments, we should expect
    that to continue to rise. While it is difficult in practice, it is indeed well
    worth an attacker''s time if the data gleaned is of sufficient value. OWASP''s
    Top 10 list has had **Sensitive Data Exposure** as a top threat for several cycles,
    with both the 2013 and 2017 ([https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf?platform=hootsuite](https://github.com/OWASP/Top10/blob/master/2017/OWASP%20Top%2010%20-%202017%20RC1-English.pdf?platform=hootsuite))
    iterations ranking it number 6: the most concerning threat to web applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In the summary of their Sensitive Data Exposure section (as shown in the following
    screenshot), it would be much harder if web developers properly configured it
    and used current technologies and module versions to provide protection. A considerable
    portion of our tests will revolve around checking for obsolete packages, insufficient
    key strengths, and misconfigured endpoints. That being said, should all of those
    things have been properly configured, we'll see how some MITM attacks can assist
    in overcoming that protection.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: OWASP's Broken Auth and Session Hijacking Characterization
  prefs: []
  type: TYPE_NORMAL
- en: 'Before jumping in, it is helpful to understand what type of cryptographic application
    we are discussing. Given its wide spread use in information technology, we need
    to restrict this discussion to the scope of web servers and their server-client
    relationships. Even then, there are many potential topologies out there, but they
    all share some common elements, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic SSL/TLS Structure and Attack Points
  prefs: []
  type: TYPE_NORMAL
- en: An on-the-rise means of attack involves exploiting the DNS and PKI infrastructure
    to augment MITM and fool wary clients into believing they are indeed attaching
    to the appropriate server or legitimate proxy (not shown). Each of the elements
    here will have their own capabilities.Â  Our job as testers is to find which elements
    are compromising the integrity end to end.
  prefs: []
  type: TYPE_NORMAL
- en: Assessing encryption like a pro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Much of an application's crypto configuration and potential flaws can be identified
    and verified simply through connecting to the application and seeing what was
    negotiated. This can be pretty labor-intensive, so luckily we have some fast scanning
    tools that will systematically negotiate all potential configurations from a server
    to better help us understand what they are allowing.
  prefs: []
  type: TYPE_NORMAL
- en: I would still recommend spending some quality time learning how to test SSL/TLS
    manually, as it is always handy to have a quick check to ensure versions, cipher
    preference, and similar ones.Â  A great writeup and cheatsheet is available atÂ Â [http://www.exploresecurity.com/wp-content/uploads/custom/SSL_manual_cheatsheet.html](http://www.exploresecurity.com/wp-content/uploads/custom/SSL_manual_cheatsheet.html).
  prefs: []
  type: TYPE_NORMAL
- en: SSLyze - it slices, it scansâ�¦
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first tool in this regard may be the only one you need.Â  Written in Python,
    SSLyze ([https://github.com/iSECPartners/sslyze](https://github.com/iSECPartners/sslyze))
    will reach out to a server using pretty much any transport protocol in use today,
    and do so fast! By initiating StartTLS handshakes with the server across all manner
    of protocols, it can scan for cipher suite issues, negotiation flaws, certificate
    inconsistencies, and common SSL-focused vulnerabilities that have put many in
    the news (Heartbleed, CRIME, and so on.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Using SSLyze is a piece of cake; you can select a number of options to pass,
    and then test multiple servers at the same time. The options can help refine the
    versions being tested, the timeouts and retries associated with the connections,
    adding a client-side certificate orÂ *cert* to test for mutual authentication,
    and testing for compression and resumptions.Â  The option I tend to use is the
    regular option coupled with the Heartbleed module, and I tend to write the output
    to a text file. In this example, we''ll run against the site [www.hackthissite.org](http://www.hackthissite.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the following screenshot, there is a ton of testing that they
    handily take care of for us in SSLyze. I dumped the extensive input into a text
    file to better snip out the whitespace, but the major areas they provide insight
    into are a complete health check of a site.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_03-861x1024.png)'
  prefs: []
  type: TYPE_IMG
- en: SSLyze Scan Output
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the output, there is a lot to digest. Section 1 outlines
    the tool's instantiation and the basic connectivity. If the server was not properly
    input, this would be where the script exits. Section 2 (snipped for brevity) covers
    certificate checks with known, trusted PKI certificate authorities to ensure that
    a certificate is adequately associated. Issues with certs can allow attackers
    to assume the identity of the legitimate server and thus hijack traffic for their
    own malicious needs. Section 3 will help us see the results of special stress
    testing associated with plugins such as the Heartbleed module and resilience through
    the session resumption capabilities of the server. Section 4 highlights the ciphers
    available; servers supporting weaker or known vulnerable cipher suites are just
    asking for trouble. Section 5 is pretty straightforward; how long did the scan
    take? In the past, testing with Cisco firewalls, the manual process of inferring
    which cipher suites are enabled and negotiated can take a couple of hours.Â  Not
    bad, but occasionally, it may provide different results, so let's look at another
    tool that can help cross-check and give us another data point.
  prefs: []
  type: TYPE_NORMAL
- en: SSLscan can do it!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SSLscan is another tool provided in Kali that is adept at automating the scanning
    process and helping us assess the versions of software, ciphers in use, and many
    other aspects of secure connectivity. Built in C and leveraging the OpenSSL 1.0.1
    libraries, SSLscan is also cross-platform, so if you happen to need a Microsoft
    Windows or Mac OS version of the application, they are available. SSLscan''s options
    are much more straightforward and they help file brief, and while this makes it
    very easy to run, it is also helpful to run another tool with greater detail on
    the PKI-side of things alongside it. To run SSLscan, you can simply use the following
    syntax with the scan I ran for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following screenshot, it offers a more compact output,
    but some of this is at the expense of certificate checks and details that may
    be useful in your penetration testing. The same color code and numbering schemes
    were used to help contrast with the SSLyze output: section 1 outlines the tool''s
    basic connectivity testing; section 2 shows a much less verbose certificate check;
    section 3 is limited to Heartbleed scanning results; section 4 highlights the
    ciphers available. A timer is not included, but the timing is comparable to SSLyze
    across a test of common sites.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Â SSLscan scan output
  prefs: []
  type: TYPE_NORMAL
- en: In this particular scenario, both the tools detected the same preferred cipher
    suite of **`ECDHE-RSA-AES128-SHA`**, but in some tests, people have reported some
    issues with SSLyze properly interpreting or negotiating the same cipher suites
    SSLscan does. Issues like these warrant running both tools and using manual analysis
    to resolve any conflicts. Another tool in the Kali distribution, **tlssled**,
    reformats the output into a summary style view based on underlying SSLscan results,
    but offers little beyond SSLscan's capability.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap has SSL skills too
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last tool we'll look into for general SSL/TLS scanning is the venerable
    **Nmap**. Armed with a script, specific to the task (`ssl-enum-ciphers`), NmapÂ can
    enumerate all of the ciphers available on a host and even provide a grading for
    each based on current best practices. While it lacks the completeness of SSLyze
    and SSLscan, this feature makes it a useful and well-known engine for making recommendations
    to customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output in the following screenshotÂ shows what a scan might look like against
    the OWASP BWA itself (the homepage, not a specific application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B03918_08_05.png)'
  prefs: []
  type: TYPE_IMG
- en: Nmap with ssl-enum-ciphers Scan Output
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting the flaws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Once you've scanned for SSL/TLS cipher issues or certificate woes, there is
    a lot that can be done to look for specific weaknesses that attackers will be
    using, and these same attacks can be delivered via some of the tools we have already
    visited in previous chapters.Â  Let's look at a few of the more famous vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: POODLE â�� all bark, no bite (usually)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Padding Oracle On Downgraded Legacy Encryption** (**POODLE**) (CVE-2014-3566)
    is a vulnerability that allows a man-in-the-middle exploit by taking advantage
    of a downward negotiation of the cipher to the affected SSLv3.0 **Cipher Block
    Chaining** (**CBC**)**Â **cipher suites. Using a MITM attack, POODLE requires
    256 SSL requests to reveal each byte of data, and itÂ is not used often unless
    a large-scale, powerful, and persistent MITM proxy is in place for a period of
    time. Nonetheless, it is a hot button issue, and you can infer that this may exist
    on a host if SSLscan or SSLyze show that this combination exists, or you can opt
    to run `nmap` with its `ssl-poodle` module to verify that the conditions exist.
    The following script will check it on your target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the Nmap scan for the `ssl-enum-ciphers` script, this scan stops short
    and only delves into the specifics around this CVE (as shown in the following
    screenshot). You can also see that we picked up the CVE in the `ssl-enum-ciphers`
    scan, but flagged it without its commonly referred-to name.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_06.png)'
  prefs: []
  type: TYPE_IMG
- en: Nmap with SSL-poodle Module Scan Output
  prefs: []
  type: TYPE_NORMAL
- en: The OpenSSL team discusses the background ([https://www.openssl.org/~bodo/ssl-poodle.pdf](https://www.openssl.org/~bodo/ssl-poodle.pdf))
    and the methods used to take advantage of this vulnerability. My friend Joey Muniz
    also wrote about this flaw in his *The Security Blogger* blog ([http://www.thesecurityblogger.com/ssl-broken-again-in-poodle-attack/](http://www.thesecurityblogger.com/ssl-broken-again-in-poodle-attack/)),
    and it describes at a high level how it is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Heartbleed-ing out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another flaw that gained a ton of press and attention is the very serious **Heartbleed**
    vulnerability (CVE-2014-0160, [http://heartbleed.com](http://heartbleed.com)).
    Unlike POODLE, this couldn't just be configured away but requires a patch to the
    underlying OpenSSL software that was used by roughly three-quarters of internet-connected
    hosts at the time. Where POODLE allows an attacker to guess a session cookie one
    byte at a time, Heartbleed is a vulnerability that allows the attacker to read
    all of the private encryption keys, usernames and passwords, certificates, and
    all the protected communications on a vulnerable host. Whereas POODLE seems to
    be an academic exercise against a long-replaced cipher category, Heartbleed impacted
    the vast majority of networked equipment, worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen in SSLyze and SSLscan that they are both capable of detecting the
    Heartbleed vulnerability, but what if you want to take advantage of it as part
    of a larger pen-test? Metasploit just happens to be able to deliver, so let's
    take a look!
  prefs: []
  type: TYPE_NORMAL
- en: After starting up Metasploit (with the `msfconsole` command), we can use the
    `auxiliary/scanner/ssl/openssl_heartbleed` module to support us in exploiting
    Heartbleed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and check out the options (as shown in the following screenshot)
    we''ll need to consider as we configure the exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_07.png)'
  prefs: []
  type: TYPE_IMG
- en: Â Configuration options for Heartbleed Module in Metasploit
  prefs: []
  type: TYPE_NORMAL
- en: We're going to look into the BeeBox VM ([http://www.itsecgames.com](http://www.itsecgames.com))
    and hit **`Heartbleed Vulnerability`**Â in the drop-down list, as shown in the
    following screenshot. Notice that there are older attacks such as the aforementioned
    **`POODLE`** available for you to practice on. We can see that the lab would like
    us to work on the port namedÂ `8443`, and my **RHOSTS** are just the single server
    `172.16.30.134`. I also set **VERBOSE** (not shown in the options, as it is a
    more global, module-agnostic setting) to *true* so that we can see all of the
    transactions. I'll also leave the rest of the settings at their default.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_08.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding a Heartbleed vulnerable server.
  prefs: []
  type: TYPE_NORMAL
- en: After modifying these settings, we can simply type `run` or `exploit` and Metasploit
    will now attempt to compromise the server and scrape all of the credentials and
    cookies it can find, as seen in the following screenshot. Something this lethal
    should not be this easy, and you can see why we need to be testing and protecting
    against these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Metasploit's Heartbleed Exploit is a success.
  prefs: []
  type: TYPE_NORMAL
- en: DROWNing HTTPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **DROWN** (CVE-2016-0800) vulnerability identifies a server that is open
    to a non-trivial attack that relies on SSLv2 support, to which at least a third
    of all internet servers were vulnerable as of March 2016\. Attackers will take
    advantage of SSLv2 supported by an application using the same keys as are used
    to *salt* or help randomize TLS (the more recent protocol versions). By initiating
    tens of thousands of SSLv2 messages,Â  they are able to glean the keys used in
    more robust and current versions of TLS, and thus break the higher-grade encryption
    with stolen private keys. Once thought to be impractical based on the sheer number
    of messages believed to be needed; they also call this the *million message attack;*
    it is now known to be achievable through commercially available resources in hours
    using tens of thousands of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting DROWN vulnerabilities is as simple as seeing if SSLv2 is supported
    on the target server or any other servers sharing the same keys. Another tool
    that can be used to identify the vulnerability is located on the [http://test.drownattack.com](http://test.drownattack.com)
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the classics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SSL and TLS have both seen their share of vulnerabilities as time has marched
    on; thisÂ is inevitable given the huge dependence on modules such as OpenSSL that
    are maintained by a small band of overworked and under-supported volunteers. Some
    of the other vulnerabilities we should understand and check for are described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**BEAST**: Our customers need to practice good patching and configuration hygiene
    to avoid attacks such as the **Browser Exploit Against SSL/TLS** (CVE-2011-3389)
    attack. BEAST targets TLSv1.0 **Initialization Vectors** (**IVs**), which are
    seed values to help randomize the encryption. Guessing IVs helps attackers reconstruct
    the conversation and reveal the very plain text that was supposed to be obscured.
    They can avoid these issues with newer versions of TLS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CRIME**: **Compression Ratio Info-leak Made Easy** (CVE-2012-4929) is a vulnerability
    when TLS compression is used in older versions. By injecting bytes and comparing
    the size of responses, hackers can identify and deduce the cookie itself, which
    can allow them to hijack the session for their own nefarious uses. Modern browsers
    are not vulnerable â�� so customers should always remain current.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BREACH**: **Browser Reconnaissance and Exfiltration via Adaptive Compression
    of Hypertext** (CVE-2013-3587) uses a similar technique but with the HTTP compression,
    so there is no dependence on TLS compression to use BREACH. You can advise customers
    to block compression and break up and obscure any passwords or authentication
    values across multiple transactions, or you can also obscure the requests with
    wrappers and operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hanging out as the Man-in-the-Middle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: MITM attacks get a lot of attention from network and application security vendors,
    and rightfully so. MITM attacks can be conducted near the application server but
    are more commonly seen near the clients. The grade of MITM attack will vary greatly,
    from passively monitoring traffic patterns to active interference and credential
    harvesting. Given the prevalence of higher-priority compromises that can yield
    the same information (such asÂ **Cross Site Scripting** or **XSS**), web application
    penetration testers need to evaluate the risk against theÂ reward of pursuing
    a MITM attack. Let's take a look at one of the most popular tools in detail and
    survey some similar tools for different MITM objectives.
  prefs: []
  type: TYPE_NORMAL
- en: Scraping creds with SSLstrip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**SSLstrip** ([https://moxie.org/software/sslstrip/](https://moxie.org/software/sslstrip/)
    ) is anÂ MITM attack tool created by a hacker by the name of Moxie Marlinspike
    that transparently intercepts HTTPS traffic and replaces any HTTPS links and redirects
    with HTTP look-alikes, which we can see are completely unprotected. This attack
    is like a test of browser configurations and user diligence, but it can also stress
    the importance of DNS Security, PKI, two-way certificate checks, and two-factor
    authorization.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Jason Beltrame* and I wrote about it in our book *Penetration Testing with
    the Raspberry Pi, Second Edtition* ([https://www.packtpub.com/networking-and-servers/penetration-testing-raspberry-pi-second-edition](https://www.packtpub.com/networking-and-servers/penetration-testing-raspberry-pi-second-edition)),
    but in this case, we''ll forgo the physical in-line configuration and instead
    aim for MITM by hair-pinning traffic back through our Kali VM (please note, this
    is a LAN-based attack, so you''ll want to be on the browsing victim''s LAN). The
    unsuspecting victim believes he/she is indeed securely connected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A high-level overview is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_10.png)'
  prefs: []
  type: TYPE_IMG
- en: Â MITM Topology
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first; we need to fool the host into thinking we''re the real
    default gateway. We can do this by determining why the Default GW on the segment
    is using `route -n`, identifying our browsing victim''s IP (I am using a Windows
    7 VM with IE9). With a couple of commands, we can turn on IP forwarding and `arpspoof`
    the victim with our MAC address, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now need to modify our `iptables` configuration. Iptables, in case you
    haven''t run into it before, act as the interface to the kernel''s host-based
    firewall for Linux, so you can imagine we need some magic here to allow traffic
    to enter and exit that wasn''t really meant for us. In my example, I am using
    port `80` for the HTTP, and port `1111` for SSLstrip, but feel free to modify
    the latter if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll now want to start up SSLstrip from either the command line or the GUI
    shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once I''ve done that I usually surf to a site such asÂ [https://www.aol.com/](https://www.aol.com/)Â and
    enter in some fake credentials in the hope I can capture them in my SSLstrip logs,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_11.png)'
  prefs: []
  type: TYPE_IMG
- en: Any SSL Site can be used to test.
  prefs: []
  type: TYPE_NORMAL
- en: More often than not, I get a bunch of errors kicking back from the Python script
    in the last terminal session where I invoked SSLstrip, but it still works like
    a champ. Simply open the `ssltrip.log` file (mine was located in the `root` directory),
    and scroll to the end of the search for one of the field strings; in my case I
    used password.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows us the fake credentials I was hoping to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_12.png)'
  prefs: []
  type: TYPE_IMG
- en: SSLstrip's logs with captured creds.
  prefs: []
  type: TYPE_NORMAL
- en: Looking legit with SSLsniff and SSLsplit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''d hope our customers wouldn''t fall for a MITM that removes the SSL/TLS
    protection. More savvy customers will both train their users and restrict non-HTTPS
    traffic in browsers. For those cases, Moxie is back again with SSLsniff, which,
    like Daniel Roethlisberger''s **SSLsplit** ([https://github.com/droe/sslsplit](https://github.com/droe/sslsplit)),
    can provide a higher-grade MITM attack by acting as a transparent proxy and serving
    up a SSL/TLS connection to both the server and the client. Both SSLsniff and SSLsplit
    will forge X.509 certificates and mimic the server for most relevant certificate
    fields, so this is a fantastic approach for environments where we suspect users
    aren''t paying attention to their certificate checks or where enforcement may
    be weak. Both tools rely on spoofed certificates, but use the same IP forwarding
    and `iptables` configurations to funnel traffic. In order to pull this off, you
    need to have a running certificate authority; if you have yet to establish one
    of your own, here is a fantastic tutorial on it: [https://jamielinux.com/docs/openssl-certificate-authority/](https://jamielinux.com/docs/openssl-certificate-authority/).'
  prefs: []
  type: TYPE_NORMAL
- en: SSLsniff
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can look at SSLsniff first. SSLsniff then requires you to either have the
    private keys and certificates for your target web application (unlikely) or that
    you generate spoofed certificates, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/B03918_08_13.png)'
  prefs: []
  type: TYPE_IMG
- en: Spoofing Certs for SSLsniff and SSLsplit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re using a Unicode `\x00` in our **Common Name** (**CN**) as a placeholder,
    following along with the guidance provided by the excellent tutorial at [http://www.kimiushida.com/bitsandpieces/articles/attacking_ssl_with_sslsniff_and_null_prefixes/](http://www.kimiushida.com/bitsandpieces/articles/attacking_ssl_with_sslsniff_and_null_prefixes/).
    Creating a real spoofed cert as back-end programming is needed to create null
    characters that allow this to be accepted by victim browsers as the real deal.
    Once we''ve created `cert` and `key`, we''ll need to sign the cert using our own
    CA, concatenate `key` and `cert`, and then place it in our fake site''s own directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that you have already configured IP forwarding and `iptables` properly,
    SSLsniff can be started using a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve got SSLsniff waiting for our victim''s traffic, we can start
    redirecting traffic from the client using the same sort of `arpspoof`Â we used
    in SSLstrip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reveal the contents of your `sslsniff.log` file and see the credentials
    (as shown in the following screenshot). This attack offers a greater likelihood
    of success than SSLstrip, as users still will see an HTTPS session in their browser''s
    address bar; and depending on the trusted CA configurations, they may have little
    warning that things are not on the up-and-up. If you are using a real spoofed
    certificate (take a look at this tutorial for how that might happen: [https://blog.leetsys.com/2012/01/18/insider-rogue-certification-authority-attack/](https://blog.leetsys.com/2012/01/18/insider-rogue-certification-authority-attack/)),
    it will even look valid.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B03918_08_14.png)'
  prefs: []
  type: TYPE_IMG
- en: Viewing SSLsniff's credentials scrape
  prefs: []
  type: TYPE_NORMAL
- en: SSLsplit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'SSLsplit follows a similar approach; first you''ll need to ensure IP forwarding
    is enabled. It is common to use more `iptables` entries to pull in a greater number
    of ports, provide NAT, and use the typical remapping ports of `80`, `8080`, `443`,
    and `8443`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now kick off SSLsplit using a single command. Notice that there is no
    labor-intensive overhead associated with the generation of spoofed certificates;
    this is very helpful, in that we can deploy this to gather information on multiple
    sites without having to generate fake certs for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As with SSLsniff, the output is pointed toward a log file that tells you that
    you can find the logs in the `~/scrapes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate MITM motives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are a ton of MITM attack approaches that we can implement with Kali Linux
    as our base. If you are looking for HTTP-only MITM (some internal sites might
    still use unprotected HTTP), or if you are looking for something pretty specific,
    take a look at **Driftnet** ([http://www.ex-parrot.com/~chris/driftnet/](http://www.ex-parrot.com/~chris/driftnet/)
    ) and **Urlsnarf**. Each of these use the same IP forwarding and arpspoof configurations,
    but offers some different capabilities than SSLstrip. Driftnet focuses on pulling
    images and multimedia from HTTP streams passing through your Kali VM, which can
    be helpful in intercepting corporate training. Urlsnarf simply pulls all of the
    websites visited by a host, which can help you map internal sites that are explicitly
    visited and may not appear in a DNS recon task.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'While some attacks get a lot of press and glory, the trust relationships that
    drive society''s reliance on the web are paramount. Attacks on these trust mechanisms
    are very concerning given that they often leave users and application developers
    unaware of the compromise. Many of the other threats covered in this book and
    represented on the OWASP Top 10 are something that the web application''s owners
    can control or have in their power to remediate. Cryptographic or PKI-based attacks,
    however, involve other aspects outside their realm, such as the certificate authority''s
    integrity, the network''s tolerance for ARP injections, and the integrity of local
    area networks outside the application''s own domain. In the case of attacks such
    as Heartbleed and POODLE, even the software relied upon to deliver these services
    can be guilty of the ultimate compromise: the leakage of sensitive data and credentials.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we scratched the surface of how to scan for known vulnerabilities
    in the software that the applications run on. We also saw how SSLscan and SSLyze
    differ in their detection of PKI details, and how we can use them and Nmap to
    identify weakspots. We also discussed a couple of the more prevalent attacks of
    interest, how to take advantage of Heartbleed, and how to approach MITM attacks
    several ways.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](000.html#)*, Stress Testing Authentication and Session Management*,
    we'll assume that the crypto is in great shape and that the easier path is to
    compromise the authentication at the application's end. These authentication and
    session management attacks are much more focused on potential flaws on the specific
    application's configuration and maintenance, which, in reality, tend to have a
    higher probability of being vulnerable. These attacks also have the added benefit
    of using the same secure pathways into the environment that a legitimate user
    would have â�� essential for persistent testing and deeper analysis of the target
    systems. [Chapter 9](000.html#), *Stress Testing Authentication and Session Management,*
    will also mark a return to some of the tool sets that we've already invested in,
    so grab a drink and let's get to work!
  prefs: []
  type: TYPE_NORMAL
