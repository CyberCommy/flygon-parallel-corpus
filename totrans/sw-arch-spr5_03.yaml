- en: Spring Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will review some Spring projects, looking at a brief explanation
    of each of them as we explore some scenarios in which they may be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Spring appeared
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring projects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Initializr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot in a Nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding redeployment with developer tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting EIPs with Spring Integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Batch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing applications with Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing (Spring) HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud and the microservices world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive and Spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive Spring Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive REST services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Spring appeared
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably know, Spring was created with the intention of simplifying all
    of the complexity of the J2EE world. It was created as a dependency injection
    framework and as an alternative to the EJB stack with distributed objects, which
    was unnecessary in most applications. The traditional approach to J2EE introduced
    a lot of complexity when it was used to bootstrap an application, and this involved
    even more complexity when used to accomplish the business requirements it had
    to solve. Consequently, we were left with applications that were difficult to
    test and were too costly to develop and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Spring and J2EE were created when Java didn't have annotations, so big XML files
    were necessary for wire classes. Fortunately, annotations became available in
    version 1.5 of the **Java Development Kit** (**JDK**), and that helped to reduce
    the need for such descriptor files.
  prefs: []
  type: TYPE_NORMAL
- en: Spring evolves faster than JEE, since it doesn't have to satisfy the formality
    of talking with a large committee, as required for JEE. When a new feature has
    to be incorporated as part of the JEE specification, a JSR document has to be
    created and approved by the JCP. The main motivation for this is that it guarantees
    backward and forward compatibility among the different versions of the specification.
    On the other hand, Spring is a project that is always evolving, considering the
    constantly changing nature of the software industry.
  prefs: []
  type: TYPE_NORMAL
- en: When a new feature is required, it is either embraced as a part of an existing
    project, or a new project is created and supported by the Spring project umbrella.
    There is no reason to be worried about compatibility, since Spring is designed
    to run on any servlet container, such as Apache Tomcat, Jetty, and so on. This
    is contrary to JEE applications, which only run on servers that implement the
    Java EE specifications and provide the standard Java EE services.
  prefs: []
  type: TYPE_NORMAL
- en: Spring projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring projects make use of an ecosystem of tools that can be used to create
    different kinds of applications in order to accomplish different goals. All of
    these projects are built around Spring, which is a legitimate modular framework
    that makes it possible to plug separate Spring projects to allow applications
    to deal with more technical requirements. If you're interested in the complete
    list of Spring projects, you can visit their home page at [https://Spring.io/projects](https://spring.io/projects).
  prefs: []
  type: TYPE_NORMAL
- en: We will review the most commonly used Spring projects to build enterprise applications,
    but first, we will introduce Spring Initializr, one of the preferred websites
    for Spring developers.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we plan to create a new project from scratch, we tend to think about which
    build tool we will use, which framework we will use, and so on. One of the most
    difficult tasks is finding the right dependencies to make the projects work. That
    is what Spring Initializr was created for. This excellent Spring initiative makes
    it possible to bootstrap applications in minutes, or even seconds, no matter what
    version you prefer. Spring Initializr can be used on the web or in your favorite
    IDE (Eclipse or IntelliJ), and it even has a cool CLI tool. My preferred approach
    is the web, and the following screenshot illustrates why:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6ceedc9-69a8-4470-bb19-fdef34e6f985.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Initializr home page
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the page, you have the option to specify your favorite build tool.
    The available options for this are Maven and Gradle. The next option allows you
    to choose the programming language of your choice (at the moment, Java, Groovy,
    and Kotlin are supported). The last option at the top of the web page asks which
    Spring Boot version you want to use. In this section, even snapshot and milestone
    versions are included. In the Project Metadata section, you specify the group
    and artifact name of your project. The Dependencies section has the Search for
    dependencies text field, which is helpful for defining what Spring projects you
    want to include as a part of your application. If you want to see more, go ahead
    and click on the Switch to the full version link; this will show you a big list
    of all of the available dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: All of these projects are created using the Spring Boot framework, which makes
    it easy to create standalone applications that are ready for production. Now,
    let's quickly go over Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot in a Nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Boot framework intends to make the following tasks easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Servlet container integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoconfiguration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servlet container integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we created `.war` files and then dropped them into the corresponding
    servlet container's deployment directory. However, Spring Boot includes an embedded
    servlet container, which ensures that this is no longer necessary. The idea is
    to generate a JAR file with all involved dependencies, and then execute the JAR
    file as a regular Java application. It's possible, but not recommended, to keep
    using the old approach of generating WAR files.
  prefs: []
  type: TYPE_NORMAL
- en: Autoconfiguration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot always attempts to automatically configure your application, based
    on the dependencies that you have added. For example, if H2 is a part of your
    dependencies, a data source to use an in-memory database will be configured automatically.
    You can always override these default configurations by using annotations, environment
    variables, configuration files, and even arguments when you're running the `.jar`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each Spring Boot version includes a curated list of dependencies. Because of
    this, you don't even have to know what artifacts and versions are required as
    a part of your application. You will always have the option to override these
    dependencies if you have to, but that is often unnecessary. This approach allows
    us to easily upgrade our Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple Spring Boot application by running the following `curl`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will download a `.zip` file containing the following
    file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58e57436-d3b0-4f60-9b5f-8ddb7a8ee74d.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Boot project structure
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly review these files.
  prefs: []
  type: TYPE_NORMAL
- en: mvnw and mvnw.cmd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These first two files are a part of the Maven wrapper ([https://github.com/takari/maven-wrapper](https://github.com/takari/maven-wrapper)).
    Here, the idea is to avoid forcing the developers to install Maven from scratch,
    instead of providing a built-in script that is able to download the right version
    and make it ready to work.
  prefs: []
  type: TYPE_NORMAL
- en: pom.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This file contains the necessary dependencies to run a Spring Boot application.
    Let''s review the file''s content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `parent` pom section provides the necessary dependency and plugin management
    for the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `Spring-boot-starter` dependency contains all of the dependencies that you
    need to get the project up and running, using a curated set of managed transitive
    dependencies. There are also other starters that you may want to use, depending
    on what you need for your project (for example, JPA, queues, security, and so
    on).
  prefs: []
  type: TYPE_NORMAL
- en: The `Spring-boot-starter-test` dependency includes the whole set of dependencies
    for testing. It will allow you to write not only unit tests, but integration tests
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: DemoApplication.java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a simple class with a `main` method, which is in charge of running
    the application. This `main` class can be executed in this way because of the
    `@SpringBootApplication` annotation, which enables all of the required autoconfiguration,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The application.properties file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within this file, you have to define all of the configuration properties for
    your application. For example, if you are interacting with an SQL database, this
    file will have properties such as the JDBC URL, database username, password, and
    more. If you want to, you can change its extension from `.properties` to `.yml`,
    in order to make it more expressive by using a YAML format ([http://www.yaml.org/start.html](http://www.yaml.org/start.html)).
  prefs: []
  type: TYPE_NORMAL
- en: DemoApplicationTests.java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a bonus, the following is an example of a simple integration test that you
    can use as a guide, to keep writing tests for your new code. Thanks to annotations,
    writing this kind of test is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding explanations should be enough to provide you with a brief overview
    so that you can understand what Spring Boot is and what its benefits are. Now,
    it's time to review other Spring projects that you'll love.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding redeployment with developer tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This module is awesome because it''s meant to help you avoid redeployment when
    you''re working on a Spring Boot application. It is similar to JRebel, but this
    product is absolutely free, and you can include it as a part of your application
    by simply adding the following dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the dependency has been added, you just have to recompile the classes to
    trigger an application restart. Depending on your IDE configuration, this process
    will be done either automatically or manually.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project offers you an additional abstraction layer for accessing data storage;
    it has a bunch of interfaces that you need to extend, in order to take advantage
    of the built-in functionalities offered by Spring Data. When you extend these
    interfaces, all of the standard operations surrounding data storage will be ready
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data supports technologies such as relational and non-relational databases,
    map-reduce frameworks, and cloud-based data services. These technologies are supported
    by modules; if you are interested in the whole list of existing modules, you can
    visit [http://projects.Spring.io/Spring-data/](http://projects.spring.io/spring-data/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s play with Spring Data by using an SQL database, such as H2\. Suppose
    that you want to build a **Create, Read, Update, Delete** (**CRUD**) operation
    for a country database table. With this framework, you only need to create the
    entity class and an empty interface extending the `CrudRepository` interface provided
    by Spring Data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the `CrudRepository` interface has all of the CRUD operations in it,
    you won''t have to implement anything; you will only have to use its functionality.
    Let''s see this in action, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two **Beans** that use the repository interface created previously.
    The first method will run, and it will insert two rows into the table. The second
    method will query all of the rows in the table and then print them in the console.
    After running this application, you will see the following output in the console
    when the application starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Spring Data has more features; it also gives you the chance to create queries
    in a fascinating way. Let''s suppose that you want to filter the countries by
    name. In that case, you will need to add the method to your interface repository,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use the preceding method in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There's no implementation at all for this method, which is a great advantage.
    Spring Data uses the method's name to generate the required implementation, allowing
    us to forget trivial implementations for these kinds of queries. There are many
    interfaces that provide more functionalities, such as pagination, sorting, and
    reactive extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting EIPs with Spring Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration is important because applications are intended to interact with
    each other. Forcing them to work in isolation makes them useless.
  prefs: []
  type: TYPE_NORMAL
- en: It's common to find companies that have their own software, developed in-house,
    to solve their specific business requirements; but, since certain scenarios tend
    to be common for more than one company, there are third-party services that can
    fulfill these needs. Since the functionality offered by these systems is ready
    to use, we have to find a way to make these applications work as a single system,
    and that's where **Enterprise Integration Patterns** (**EIP**) come into play.
  prefs: []
  type: TYPE_NORMAL
- en: EIPs provide proven solutions to recurring problems that can be applied in different
    contexts with slight modifications, depending on particular business needs. There
    is a vast catalog of these patterns available on the internet, and a must-read
    within this field is the book *Enterprise Integration Patterns, *by Gregor Hohpe
    and Bobby Woolf. This book explains a large list of patterns, along with example
    scenarios, by using a technology agnostic approach.
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand the theory around EIPs, you will find Spring Integration
    pretty handy for implementing them; it will have all of the benefits inherent
    to the Spring Framework, as discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we discuss integration, we can consider the concept using a three-step
    approach. Let''s start reviewing the following diagram which shows these three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d79debc-84d7-4f68-8a8f-7ebd87f7d5ad.png)'
  prefs: []
  type: TYPE_IMG
- en: EIPs
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of steps that are executed as a part of the preceding
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a data source where the information is extracted; a poll is sometimes
    needed, in order to ask for data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ingested data is filtered, transformed, composed, decomposed, routed, and
    so on, depending on what's required. It's here that the EIPs are used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The processed data is ready to be delivered or stored, depending on what is
    needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Spring Integration provides built-in support for retrieving or sending information
    from or to queues, databases, system files, FTP servers, and many other options.
    Moreover, if needed, you can write your own implementation and plug it in, in
    order to make it work as a part of your process. The DSL provided by Spring makes
    it easy to read and implement the EIPs.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Batch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter what type of architecture we are using, sometimes we will need to
    work with a great amount of data and apply some transformations to make it useful.
    This kind of processing usually happens when we need to consolidate (or simply
    process) data from one or many data sources, making it available for certain business
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'These batch processes require a well-defined set of steps for accomplishing
    the required goal. Using Spring Batch, you can implement them by using jobs that
    are composed of steps to read, process, and write the processed data. One job
    can have as many steps as required, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f3e4098-f790-4fe1-951f-5820d1229695.png)'
  prefs: []
  type: TYPE_IMG
- en: Spring Batch – Job structure
  prefs: []
  type: TYPE_NORMAL
- en: The read step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, the information is read from an external data source using a built-in
    `ItemReader` object that is part of Spring Batch. The `ItemReader` object will
    serve a `<T>` object, which will be consumed later.
  prefs: []
  type: TYPE_NORMAL
- en: The process step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, the data processing is done by an `ItemProcessor` object that can transform
    and manipulate the `<T>` data that has been read from the `ItemReader` object.
    An `ItemProcessor` can return the same `<T>` object that was read, or another
    `<O>` object that is completely different if that's the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The write step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the processing step has finished, an `ItemWriter` object is available to
    use, writing the `<O>` transformed object obtained in the processing stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides the ability to interact with traditional data sources, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMS providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Spring Batch, one cool feature is that it offers the chance to rerun and
    skip jobs, since it has its own database where the state to executed jobs is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring Batch is designed to deal with huge amounts of data, in order to
    accelerate the processing, the framework offers the chance to process the information
    as chunks of data. This also makes it possible to reduce the server resources
    required for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Securing applications with Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security is an extensible framework that can be used to secure Java applications.
    It can also be used to handle authentication and authorization, and it uses a
    declarative style that is not at all intrusive of the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The framework supports different approaches to authentication, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: LDAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDBC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also add your own custom authentication mechanism by implementing the `AuthenticationProvider` interface,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `user` and `password` hardcoded strings  are expected
    as credentials in order to have a successful authentication process, and you should
    replace that verification with the necessary logic.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned authentication mechanisms follow the **Basic Authentication**
    model, which is the preferred model for web applications. However, when you're
    writing APIs, you will need other approaches to deal with security. A good option
    is to use a model based on tokens, such as JWT or OAuth, which we will review
    and implement in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Embracing (Spring) HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When talking about the REST subject, it''s always worth discussing the Maturity
    Model, created by Leonard Richardson, which establishes three steps that a REST
    API should accomplish in order to be considered mature:'
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hypermedia controls: HATEOAS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will focus on the last element. **HATEOAS** is intended
    to provide information about what we can do next, using additional **Uniform Resource
    Identifiers **(**URIs**) that are included as part of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit our banking example, in order to explain HATEOAS from a practical
    view. Suppose that you have the following URI to query the customer's bank statements: `http://your-api/customer/{customer_id}/bankStatements`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s suppose that the API has the ability to resend the bank statements
    or mark them as failed. With the information provided by the previously mentioned
    payload, there is no way to know about these operations. It''s here that HATEOAS
    can be used, to let our API users know about the existence of these additional
    features. After applying HATEOAS, the payload will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note how easy it is to learn about the existence of these operations, which
    were hidden before applying HATEOAS as part of the API.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud and the microservices world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project provides a set of tools to deal with distributed applications.
    Spring Cloud is mainly used within the microservices world, which we will review
    in depth in [Chapter 8](7c38500a-5a66-422b-a41b-21f4fd18de51.xhtml), *Microservices*.
    This project is composed of modules that offer different functionalities, which
    can be embraced all at once or one by one, depending on your needs. Let's briefly review
    some of the most common modules available in Spring Cloud, and look at how they
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This module provides a centralized tool for storing all of the configurations
    that your applications need in order to work. Within the Java world, it's quite
    common to have `.properties` and `.yml` files that store all of the required configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Spring offers the ability to create different profiles, in order to deal with
    different environments, using files with the previously mentioned extensions.
    However, it also has the option to keep all of the configuration centralized in
    a server, where you can store values and even encrypted information. When clients
    need to access this secret information, the configuration server has the ability
    to decrypt the information and make it available to the client. Furthermore, you
    can change the configuration values on the fly. The files storing this configuration
    reside inside of a Git repository, which gives us the additional benefit of accounting
    for the changes applied in the configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Service registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A service registry works like a phone book for the Cloud, which makes it possible
    to find out where the services are and how many instances of them are available
    for handling incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring offers support for most of the common service registries, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Zookeeper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a service registry offers the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Sophisticated load balancing, such as availability zone awareness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An edge service acts as a proxy. It is designed to take all incoming requests
    and do something useful with them, before sending them to the services that are
    behind the load balancers, firewalls, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of edge services:'
  prefs: []
  type: TYPE_NORMAL
- en: Microproxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the benefits of using an edge service is that you can manage all of the
    specific client details in a centralized place instead of writing code to deal
    with these details in each service individually. For example, if you need to make
    a particular consideration for mobile clients, this is the perfect place to do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Microproxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microproxy is a kind of edge service that retrieves an incoming request only, and
    then redirects the request to the corresponding service.
  prefs: []
  type: TYPE_NORMAL
- en: A classic example of this type of edge service involves dealing with **Cross-Origin
    Resource Sharing (CORS)**, as defined at[https://en.wikipedia.org/wiki/Cross-origin_resource_sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing).
    As you probably know, CORS restricts access to specific resources when they are
    requested from a domain different from where they reside. You can allow access
    to the resources on each service, or you can take advantage of an edge server,
    in order to allow services to be requested from other domains.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of an API gateway transforms incoming requests before redirecting them
    to the corresponding services. Not only can the requests be modified, but the
    responses are also provided.
  prefs: []
  type: TYPE_NORMAL
- en: A gateway can also work as a facade, which should orchestrate some services
    before sending the responses to the clients. When we are working with this particular
    use case, we can implement the circuit breaker pattern in order to be more defensive.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A circuit breaker is a pattern used to deal with failed calls. If an error occurs,
    you can usually throw an exception and let the user know that something went wrong,
    but you can also use an alternative path to serve an alternative response. For
    example, let's suppose that service A has failed. Now, instead of returning a
    failed response, you can invoke an alternative service, B, which acts similarly
    to service A, in order to provide a valid response to the client, hence improving
    the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive and Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is a paradigm built around a simple concept that proposes
    propagating changes using events. This programming style has been used for a while
    in programming languages such as JavaScript, and one of its main benefits is its
    asynchronous and non-blocking behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In order to embrace this programming paradigm within the Java world, the Reactive
    Stream specification was created, following the goals declared in the Reactive
    Manifesto ([https://www.reactivemanifesto.org](https://www.reactivemanifesto.org)),
    which was written a few years ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specification is mainly composed of four interfaces, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscriber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscription
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly review these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This interface has a simple method, which makes it possible to register subscribers
    that will eventually receive the data when it is available to consume. The following
    is the code for the `Publisher` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Subscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This interface is where the action happens. The following methods have names
    that are self-describing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With each of the previously mentioned methods, you can register a callback
    that will be invoked under the appropriate circumstances, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onSubscribe`: This method is executed when the subscription process happens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNext`: This method is executed when a new event is received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError`: This method is executed when an error occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete`: This method is executed when the producer has finished and there
    are no more results to receive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscription
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This interface is intended to be used when you want to request a subscription
    to the `Publisher` interface, specifying the number of elements to request to
    the upstream; the `cancel` method should be called when the subscriber is no longer
    interested in receiving data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Processor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `processor` interface implements two additional interfaces: `Publisher`
    and `Subscriber`. This interface is used to subscribe to and publish events.
  prefs: []
  type: TYPE_NORMAL
- en: Project reactor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project is an implementation of the Reactive Streams specification, which
    is preferred by Spring Framework. There are also adapters that make it possible
    to use other implementations if required, but that is often unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Project reactor can also be used to implement Reactive applications without
    using Spring.
  prefs: []
  type: TYPE_NORMAL
- en: When we're registering functions to handle events, we tend to nest callbacks
    that make it difficult to understand the written code. In order to simplify these
    kinds of requirements, Reactor has its own set of operators (visit [https://goo.gl/y7kcgS](https://goo.gl/y7kcgS)
    to see the whole list of available operators). These operators allow us to interact
    with the API in a cleaner way, without having to chain callback functions together.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main producer classes that deal with results where the operators
    can be applied:'
  prefs: []
  type: TYPE_NORMAL
- en: Mono
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mono represents the asynchronous result of a single or empty value (0...1).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram was taken from the Project Reactor documentation, and
    it indicates how an item is emitted by a `Mono` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23f3a241-caf4-48f7-be45-cb51f6e87c29.png)'
  prefs: []
  type: TYPE_IMG
- en: Item emitted by a Mono object
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram illustrates the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: A new value is produced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operator is applied to the produced value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is delivered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows how to work using an empty value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux represents an asynchronous sequence of 0 to *n* items.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will again borrow a diagram from the Project Reactor documentation, which
    explains how a `Flux` object emits items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0429f36a-f799-4bc7-a1c8-45dbbb92e30a.png)'
  prefs: []
  type: TYPE_IMG
- en: Item emitted by a Flux object
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram illustrates the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: At least six values have been produced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operator is applied to the produced values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result is delivered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we will first convert each produced value to uppercase,
    in order to deliver the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Back pressure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back pressure is a mechanism that allows us to specify the required number of
    elements to be read at once. It is used when you're interested in chunks of data
    with a defined quantity of *n* elements. The data is delivered in chunks until
    the whole dataset is reached.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want chunks of data with three elements, from a `Flux` object with
    ten elements. In this case, you will retrieve the data four times, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the generated output from the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, Spring 5 supports reactive programming by using the
    Reactor project. We have the ability to use it as a part of Spring MVC and Spring
    Data, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Reactor can be used with Spring Data, we can take full advantage of the
    reactive programming model at this stage. This means that you can persist data
    represented as `Flux` or `Mono` objects. Let''s review the following example,
    implemented with MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the provided information is represented as `Flux` and `Mono` objects,
    and the queried data is obtained as a `Flux` object, which is manipulated using
    the map operator to recover only the IDs as `List<String>` to verify the number
    of entities created.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive REST services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive REST services have been added by using `WebFlux` as a part of the Spring
    web stack. This allows us to implement endpoints that are capable of delivering
    information as streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review how this works from a practical viewpoint. Suppose that you want
    to retrieve notifications that are often pushed by users. Without using the reactive
    approach, you can retrieve all of the notifications created until the request
    is made; but, with the reactive approach, you can keep receiving new notifications,
    which means that if a new notification is created, you will receive it at that
    exact moment. Let''s analyze the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, pay attention to the produced content. This is a stream value,
    rather than JSON, XML, or any other content type. Next, we are simulating that
    a new comment is created every second (check the code in bold). At the end of
    the process, that information is delivered by the endpoint. You can give this
    a try with the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can see how a new comment is being retrieved each second. This feature
    opens up a new world of opportunities and functionalities that can be implemented
    in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed some of the most common projects available in Spring,
    along with a brief explanation and use case for each of them. We also looked at
    the Spring Reactor project and the features associated with it, which can be implemented
    using Spring Data. We then looked at writing RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: With all of the knowledge that you have acquired, it's time to dive into the
    subsequent chapters to review some architectural styles and learn how to implement
    them using the Spring Framework.
  prefs: []
  type: TYPE_NORMAL
