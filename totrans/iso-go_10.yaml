- en: Testing an Isomorphic Go Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the sprinkling of reusable components (cogs) throughout the website, that
    was performed in the previous chapter, we had reached a project milestone – we
    completed the IGWEB feature set that was laid out in [Chapter 2](9b9730ea-ae72-4285-be30-58f2f8ab2f1e.xhtml), *The
    Isomorphic Go Toolchain*. However, we can't launch IGWEB just yet. Prior to launch,
    we must ensure the quality of the isomorphic web application by verifying that
    it meets a certain baseline set of functional requirements. To do this, we must
    implement end-to-end tests that exercise the isomorphic web application's functionality
    across environments (server-side and client-side).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to provide end-to-end test coverage for
    IGWEB. We will use Go's built-in test framework, for testing the server-side functionality,
    and we will use CasperJS for testing the client-side functionality. By implementing
    a suite of end-to-end tests, not only will we have a means for automated testing,
    but we also have a valuable project artifact in each test that we write, since
    each test communicates the intent of the expected functionality found in the isomorphic
    web application. By the end of this chapter, we will have created an end-to-end
    test suite that forms the foundation of a solid test strategy, which the reader
    can further build upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the server-side functionality with Go's testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the client-side functionality with CasperJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the server-side functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in [Chapter 1](c90ed736-d3cf-4c9b-bae7-c8b894e25259.xhtml), *Isomorphic
    Web Applications with Go*, the isomorphic web application architecture utilizes
    the classic web application architecture, meaning that the web page response will
    be rendered on the server-side. This means that the web client need not be JavaScript-enabled
    in order to consume the content received from the server response. This fact is
    especially important for machine users, such as search engine bots, who need to
    crawl through the various links found on the website and index them. Often times,
    search engine spiders are not JavaScript-enabled. This means that we have to ensure
    that server-side routing is functioning properly, and that the web page response
    is rendered properly also.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we put in good effort in [Chapter 7](a9dcc0d7-ecf7-4ad0-b879-0a596ab4594e.xhtml),
    *The Isomorphic Web Form*, to create an accessible, isomorphic web form that can
    be accessed by users who have greater accessibility needs. We need to ensure that
    the contact form's validation functionality is working, and that we can successfully
    send a valid contact form submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, on the server-side, the baseline set of functionality that we''ll
    test for, includes the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the server-side routing and template rendering
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the contact form's validation functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying a successful contact form submission
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go's testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Go's built-in testing framework to write a set of tests that exercise
    IGWEB's server-side functionality. All server-side tests are stored in the `tests`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you are new to Go's built-in testing framework, provided through the `testing`
    package, you can read more about it at this link: [https://golang.org/pkg/testing/](https://golang.org/pkg/testing/).
  prefs: []
  type: TYPE_NORMAL
- en: Prior to running the `go test` command to execute all the tests, you must start
    up the Redis server instance and IGWEB (each preferably in their own dedicated
    Terminal window or tab).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start the Redis server instance with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can start the IGWEB instance with the following command, inside the `$IGWEB_APP_ROOT`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run all the tests in the suite, we simply need to run the `go test` command
    within the `tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Verifying server-side routing and template rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a test to verify all the server-side routes of the IGWEB application.
    Each route that we test will be associated with an expected string token, which
    is rendered in the page response, particularly in the primary content `div` container.
    So, not only will we be able to verify if the server-side route is functioning
    properly or not, but we will also know if the server-side template rendering is
    functioning normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the contents of the `routes_test.go` source file, found in the `tests`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `testHost` variable that we defined, is used to specify the hostname and
    port where the IGWEB instance is running.
  prefs: []
  type: TYPE_NORMAL
- en: The `TestServerSideRoutes` function is responsible for testing server-side routes,
    and verifying that the expected token string exists within the response body.
    Inside the function, we declare and initialize the `routesTokenMap` variable of
    type `map[string]string`. The keys in this `map`, represent the server-side route
    that we are testing, and the value for a given key, represents the expected `string`
    token that should exist in the web page response returned from the server. So,
    this test not only will tell us if the server-side route is functioning properly,
    but it will also give us a good idea on the health of template rendering, since
    the expected `string` tokens we supply are all strings that should be found in
    the body of the web page. We then `range` through the `routesTokenMap`, and for
    each iteration, we pass in the `route` and the `expectedString` to the `checkRoute`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `checkRoute` function is responsible for accessing a given route, reading
    its response body and verifying that the `expectedString` exists within the response
    body. There are three conditions that can cause the test to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: When a connection to the route URL cannot be made
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the response body retrieved from the server could not be read
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the expected string token did not exist in the web page response returned
    from the server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any of these three errors occur, the test will fail. Otherwise the function
    will return normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run this test by issuing the following `go test` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the output of running the test shows that the test has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have now successfully verified accessing server-side routes and ensuring
    that the expected string in each route was rendered properly in the web page response.
    Now, let's start verifying the contact form functionality, starting with the form
    validation functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the contact form's validation functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next test that we are going to implement will test the contact form''s
    server-side form validation functionality. There are two types of validations
    that we will be testing:'
  prefs: []
  type: TYPE_NORMAL
- en: An error message that is displayed when the required form field has not been
    filled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error message that is displayed when an improperly formatted email address
    value is provided in the email field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the contents of the `contactvalidation_test.go` source file, found
    in the `tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `TestContactFormValidation` function is responsible for testing the contact
    form's server-side form validation functionality. We declare and initialize the
    `testURL` variable, which is the URL of the contact section of IGWEB.
  prefs: []
  type: TYPE_NORMAL
- en: We declare and initialize the `expectedTokenMap` variable of the `map[string]string` type,
    where keys in the map are the names of the form fields and the value for each
    key represents the expected error message that should be returned upon submitting
    the form.
  prefs: []
  type: TYPE_NORMAL
- en: We create a new form and populate the form field values using the form object's
    `Add` method. Notice that we provided an empty `string` value for the `firstName`,
    `lastName`, and `messageBody` fields. We also provided an improperly formatted
    email address for the `email` field.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `NewRequest` function found in the `http` package to submit the form
    using a HTTP POST request.
  prefs: []
  type: TYPE_NORMAL
- en: We create an `http.Client`, `hc`, and submit the POST request by calling its
    `Do` method. We fetch the contents of the response body using the `ReadAll` function
    found in the `ioutil` package. We `range` through the `expectedTokenMap`, and
    in each iteration, we check whether the expected error message is found in the
    response body.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the four possible conditions that can cause this test to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: If the POST request could not be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the POST request failed due to connectivity issues with the web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the web client failed to read the response body of the web page response
    returned from the web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the expected error message could not be found in the body of the web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any one of these errors are encountered, this test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run this test by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Examining the output of running the test shows that the test has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Verifying a successful contact form submission
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next test that we will implement will test a successful contact form submission.
    This test, will be closely similar to the last test, with the exception that we
    will fill in all the form fields and provide a properly formatted email address
    in the `email` form field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the contents of the `contact_test.go` source file, found in the `tests`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, the test is very similar to the previous test that we implemented, except
    that we are populating all the form fields and providing a properly formatted
    email address. We declare and initialize the `expectedTokenString` variable to
    the confirmation string that we expect to be printed out in the response body,
    after conducting a successful form submission. The last `if` conditional block
    of the function checks whether the response body contains the `expectedTokenString`.
    If it does not, then the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the four possible conditions that can cause this test to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: If the POST request could not be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the POST request failed due to connectivity issues with the web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the web client failed to read the response body of the web page response
    returned from the web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the expected confirmation message could not be found in the body of the web
    page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, if any one of these errors are encountered, this test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the test by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From examining the output after running the test, we can see that the test
    has passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run all the tests in the test suite by simply issuing the `go test`
    command inside the `tests` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, we have written tests to cover the baseline set of functionality
    to test the server-side web application. Now, it's time to focus on testing the
    client-side application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the client-side functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in [Chapter 1](https://cdp.packtpub.com/isomorphic_go/wp-admin/post.php?post=616&action=edit#post_26), *Isomorphic
    Web Applications with Go*, after the initial page load, subsequent navigations
    on the website are served using single page application architecture. This means
    that an XHR call is initiated to a Rest API endpoint that provides the necessary
    data to render content that will be displayed on the web page. In the case where
    the client-side handler displays the products listing page, for example, a Rest
    API endpoint is utilized to fetch the list of products to display. In some cases,
    a Rest API endpoint is not even necessary since the page content only requires
    rendering a template. One such example of this is when a user accesses the contact
    form by clicking on the Contact link in the navigation bar. In this situation,
    we simply render the contact form template and display the contents in the primary
    content area.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a moment and think about all the baseline functionality that we would
    need to test on the client-side. We need to verify that the client-side routes
    are functional and that the proper page is rendered for each route, similar to
    how we verified the server-side routes in the previous section. In addition to
    that, we need to confirm that the client-side form validation is working for the
    contact form as well as testing the scenario of a valid form submission. The functionality
    to add and remove items, to and from the shopping cart, is currently implemented
    on the client-side only. This means that we will have to write tests to verify
    that this functionality is working as expected. Another feature that is currently
    only available on the client-side, is the live chat feature. We must validate
    that the user can communicate with the live chat bot, that the bot replies, and
    that the conversation is maintained as the user navigates to different sections
    of the website.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to test our collection of cogs. We have to make sure that the
    time ago cog, shows a time instance in human understandable format. We have to
    verify that the live clock cog is functioning properly. We have to verify that
    the date picker cog appears when the Time Sensitivity Date field is clicked. We
    have to verify that the carousel cog appears on the home page. Finally, we have
    to verify that the notify cog is displaying notifications properly when adding
    and removing items to and from the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore on the client-side, the baseline set of functionality that we''ll
    test for, includes the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying client-side routing and template rendering
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the contact form
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the shopping cart functionality
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the live chat feature
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the time ago cog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the live clock cog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the date picker cog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the carousel cog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verifying the notify cog
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to perform automated testing on the client-side, which includes user
    interactions, we need a tool that has a JavaScript runtime built into it. Therefore,
    we cannot use `go test` when testing the client-side functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We will use CasperJS to perform automated testing on the client-side.
  prefs: []
  type: TYPE_NORMAL
- en: CasperJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CasperJS is an automated testing tool that sits on top of PhantomJS, a headless
    web browser that is used for automating user interactions. CasperJS allows us
    to write tests using assertions, and organize the tests, so that they can all
    be run together sequentially. After the tests are run, we can receive a summary
    of how many tests passed versus how many tests failed. In addition to this, CasperJS
    can tap into the functionality within PhantomJS to take web page screenshots as
    tests are being conducted. This allows human users to visually evaluate a test
    run.
  prefs: []
  type: TYPE_NORMAL
- en: In order to install CasperJS, we must first install NodeJS and PhantomJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install NodeJS by downloading the NodeJS installer for your operating
    system from this link: [https://nodejs.org/en/download/](https://nodejs.org/en/download/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once NodeJS is installed, you can install PhantomJS by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You may verify that `phantomjs` has been installed properly, by issuing the
    following command to view the version number of PhantomJS installed on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have verified that PhantomJS is installed on your system, you may
    issue the following command to install CasperJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that `casperjs` has been installed properly, you may issue the following
    command to view the version number of CasperJS installed on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our client-side CasperJS tests will be housed in the `client/tests` directory.
    Take note of the sub folders inside the `client/tests` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will be writing all of our CasperJS tests in Go, and we will be placing them
    in the `go` folder. We will use the `build_casper_tests.sh` bash script found
    in the `scripts` directory to transpile the CasperJS tests implemented in Go,
    to their equivalent JavaScript representation. The produced JavaScript source
    files will be placed in the `js` folder. Many of the tests we will create, will
    generate screenshots of the test run in progress, and these screenshot images
    will be stored in the `screenshots` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should run the following command, to make the `build_casper_tests.sh` bash
    script executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Anytime we write a CasperJS test in Go, or make changes to it, we must execute
    the `build_casper_tests.sh` bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we get started writing CasperJS tests, let''s take a look at the `caspertest.go`
    source file found in the `client/tests/go/caspertest` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ViewportParams` struct will be used to define the web browser's viewport
    dimensions. We will use a dimension of 1440 × 960 to simulate a desktop viewing
    experience for all of the client-side tests. The ramifications of setting the
    viewport dimensions can readily be seen by viewing the screenshots generated,
    after running a CasperJS test that generates one or more screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started with writing client-side tests using CasperJS.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying client-side routing and template rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CasperJS test that we implemented in Go, to test the client-side routing,
    can be found in the `routes_test.go` source file in the `client/tests/go` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the import grouping, notice that we include the `caspertestjs` package,
    where we defined the `ViewportParams` `struct`, and we include the `js` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will use the functionality found in the `js` package, quite extensively,
    to tap into the CasperJS functionality since there are currently no GopherJS bindings
    available for CasperJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define a JavaScript function called `wait`, which is responsible for
    waiting until the primary content `div` container gets loaded in the remote DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare and initialize the `casper` variable to the `casper` instance, a
    JavaScript object, which has been populated in the remote DOM, upon executing
    CasperJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We implement the client-side routing test in the `main` function. We start
    by declaring a `routesTokenMap` (similar to what we did on the server-side route
    test), having a type of `map[string]string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The key represents a client-side route, and the value for a given key represents
    the expected string token that should be rendered on the web page, when the given
    client-route has been accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the following code, we set the web browser''s viewport size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that PhantomJS uses a default viewport of 400 × 300\. We have to override
    this value since we will be simulating a desktop viewing experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `tester` module of CasperJS when writing our tests. The `Tester`
    class provides an API, for unit and functional testing, and can be accessed by
    the `test` property of the `casper` instance. The full documentation for the `tester`
    module is available at this link: [http://docs.casperjs.org/en/latest/modules/tester.html](http://docs.casperjs.org/en/latest/modules/tester.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `test` object''s `begin` method to start a suite of planned tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter supplied to the `begin` method is the description of the
    test suite. We have provided a description of `"Client-Side Routes Test Suite"`.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter represents the number of tests planned. Here we have specified
    that there will be a total of seven tests since that is how many client-side routes
    we will be testing. If the number of planned tests does not match the number of
    actual tests performed, then CasperJS will consider it to be a *dubious* error,
    so it's always a good practice to make sure that the proper number of tests planned
    is set correctly. We will show you how to count the number of tests performed
    in this example.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter is a JavaScript callback function that contains the suite
    of tests that will be performed. Note that the callback function gets the `test`
    instance, a JavaScript object, as an input argument. Inside this function we call
    the `casper` object's `start` method. This starts up Casper and opens up the URL
    specified in the first input argument to the method. The second input argument
    to the `start` method is considered the next step, a JavaScript callback function
    that will run, right after accessing the URL. The next step that we specified
    is the `wait` function, which we had created earlier. This will have the effect
    of accessing the URL to the IGWEB home page, and waiting until the primary content
    `div` container is available in the remote DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can start our tests. We `range` through each route and `expectedString`
    pair in the `routesTokenMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `then` method of the `casper` object to add a new navigation step
    to the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inside the function that represents the navigation step, we call the `casper`
    object's `click` method. The `click` method will trigger a mouse click event on
    the element that matches the provided CSS selector. We create a CSS selector for
    each route, and it will match a link on the body of the web page. The CSS selector
    allows us to simulate the scenario of the user clicking on the navigation links.
  prefs: []
  type: TYPE_NORMAL
- en: The two routes that are not part of the navigation links are the `/` and `/product-detail/swiss-army-knife`
    routes. The CSS selector for the `/` route will match the link declared for the
    website's logo in the upper left-hand corner of the web page. When this scenario
    is tested, it is equivalent to the user clicking on the logo of the website. In
    this case of the link to the product detail page for the Swiss Army Knife, `/product-detail/swiss-army-knife`,
    will be found in the primary content area div once the content for the products
    page has been rendered. When this scenario is tested, it is equivalent of the
    user clicking on the Swiss Army Knife image on the products listing page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next navigation step, we will generate a screenshot of the tests case,
    and check if `expectedString` is found in the body of the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call the `casper` object's `capture` method to supply the path of the
    generated screenshot image. A screenshot will be generated for each route that
    we test, so we will have a total of seven screenshot images generated from this
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we call casper's `wait` method to introduce a `1800` millisecond
    delay, and we supply a `then` callback function. In conversational English, we
    can interpret this call as, "Wait 1800 milliseconds, and then do this." Inside
    the `then` callback function that we have supplied, we make a call to the `assertTextExists`
    method on casper's `test` object (the `tester` module). In the `assertTextExists`
    method call, we supply the `expectedString` that should exist in the body of the
    web page, and the second parameter is a message describing the test. We have added
    the `1800` millisecond delay, to provide sufficient time for the page content
    to be displayed on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that whenever any type of `assert` method call, in the family of `assert`
    methods in the casper `tester` module is called, it counts as a single test. Recall
    that when we called the tester module's `begin` method, we supplied a value of
    `7`, to indicate that there were to be 7 expected tests that would take place
    in this test suite. So the amount of `assert` method calls that you have in your
    test, must match the number of expected tests that will be conducted, otherwise
    you will get a dubious error when performing a run of the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a call to the `casper` object''s `run` method to run the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we supply a callback function to the `run` method. This callback function
    will be called when all steps have completed running. Inside the callback function,
    we call the `tester` module's `done` method to signify the end of the test suite.
    Remember that in a CasperJS test, whenever we call the `begin` method on the `tester`
    module, there must be a corresponding place in the test where we call the tester
    module's `done` method. If we forget to leave the method call to `done`, the program
    will hang and we'll have to break out of the program (using a *Ctrl* + *C* keystroke).
  prefs: []
  type: TYPE_NORMAL
- en: 'We must transpile the test to its JavaScript equivalent, and we can do so by
    running the `build_casper_tests.sh` bash script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The bash script will transpile all of the CasperJS tests written in Go residing
    in the `client/tests/go` directory, and place the produced JavaScript source files
    in the `client/tests/js` directory. We will omit this step in subsequent test
    runs. Just keep in mind that if you make changes to any of the tests that you
    need to re-run this script so that the changes will take effect, next time you
    run the suite of tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the test to check the client-side routes by issuing the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.1* shows a screenshot of running the client-side routes test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41dfb567-3a37-4b6c-8814-5928926b71ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Running the client-side routes test suite'
  prefs: []
  type: TYPE_NORMAL
- en: The produced screenshot images from the test can be found in the `client/tests/screenshots`
    folder. The screenshots come in handy because they allow a human user to visually
    look over the test results.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.2* shows a screenshot image of testing the `/` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb2e82c8-a64f-4f2b-9f2b-014b2f11dccf.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Testing the / route'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.3* shows a screenshot image of testing the `/index` route. Note
    that the page rendering is identical to *Figure 10.2* as it should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1eaa6278-ca2f-4f14-bb58-48db34218b0c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Testing the /index route'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that by supplying the delay time of `1800` milliseconds, we gave enough
    time for the carousel cog and the live clock cogs to load. Later in this chapter,
    you'll learn how to test these cogs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.4* shows a screenshot image of testing the `/products` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bd932f1-20ee-4f35-943b-54e3a4e13f07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Testing the /products route'
  prefs: []
  type: TYPE_NORMAL
- en: From this test, we can visually confirm that the products listing page has loaded
    fine. The next test step will click on the image of the Swiss Army Knife to navigate
    to its product detail page.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.5* shows a screenshot image of testing the `/product-detail/swiss-army-knife`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6cc75f81-3bfe-46f3-8191-244984eea02c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Testing the /product-detail route'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.6* shows a screenshot image of testing the `/about` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ea50626-d930-4c4b-a750-adab177c1edd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Testing the /about route'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the time ago cog has rendered properly for all three gophers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.7* shows a screenshot image of testing the `/contact` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24d218b2-ecb9-4a99-8aab-ad4490824fff.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: Testing the /contact route'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.8* shows a screenshot image of testing `/shopping-cart` route.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d93df9f-ec48-4fdd-bbde-00e75c0dfce5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Testing the /shopping-cart route'
  prefs: []
  type: TYPE_NORMAL
- en: From the visual confirmation provided by the screenshots, we can now be confident
    that the client-side routing is working as expected. In addition to that, the
    generated screenshots help us visually confirm that template rendering is functioning
    properly. Let's take a look at verifying the contact form functionality now.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the contact form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test that we implemented to verify the contact form functionality, can be
    found in the `contactform_test.go` source file in the `client/tests/go` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this test, we defined the `FormParams` `struct`, which represents the form
    parameters that the contact form should be filled with, when conducting our test
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created a JavaScript `wait` function to ensure that the test runner
    will wait for the primary content `div` container to have loaded, prior to running
    other steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will introduce the following three JavaScript functions to populate the
    contact form''s fields, depending on the type of test we are conducting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fillOutContactFormWithPoorlyFormattedEmailAddress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fillOutContactFormPartially`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filloutContactFormCompletely`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `fillOutContactFormWithPoorlyFormattedEmailAddress` function, as the name
    implies, will supply an invalid email address to the `email` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we created a new `FormParams` instance, and populated the `FirstName`,
    `LastName`, `Email`, and `MessageBody` fields. Take particular note that we have
    supplied an invalid email address for the `Email` field.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this function, the `this` variable represents the `tester`
    module. We make a call to the `tester` module's `fill` method, supplying the CSS
    selector to the contact form, the `params` object, and a Boolean value of `true`
    to indicate that the form should be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: After filling in and submitting the form, we expect the client-side form validation
    to present us with an error message indicating that we have provided an invalid
    email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fillOutContactFormPartially` function will fill out the contact form partially,
    leaving some required fields unfilled, resulting in an incomplete form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new `FormParams` instance, and take note that we have provided
    an empty `string` value for the `LastName` and `MessageBody` fields.
  prefs: []
  type: TYPE_NORMAL
- en: After filling in and submitting the form, we expect the client-side form validation
    to present us with an error message indicating that we have not filled in these
    two required fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fillOutContactFormCompletely` function will fill out all fields of the
    contact form and will include a properly formatted email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here we create a new `FormParams` instance, and populate all the fields of the
    contact form. In the case of the `Email` field, we ensure to supply a properly
    formatted email address.
  prefs: []
  type: TYPE_NORMAL
- en: After filling in and submitting the form, we expect the client-side form validation
    to green-light the form, which behind the scenes, will initiate an XHR call to
    the rest API endpoint to verify that the contact form has been properly filled
    using the server-side form validation. We expect the server-side validation to
    also green-light the form field values, resulting in a confirmation message. Our
    test will pass, if we can successfully verify that we have obtained the confirmation
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous example, we start by declaring the viewport parameters
    and setting the viewport size of the web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we call the `tester` module''s `begin` method to start the tests
    in the Contact Form Test Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We supply the `begin` method with the description of the test, `"Contact Form
    Test Suite"`. We then supply the number of expected tests in this suite, which
    is `4`. Remember that this value corresponds to the number of tests we conduct.
    The number of tests conducted can be ascertained by the number of calls we make
    to a method belonging to the `tester` module's `assert` family of methods. We
    provide the `then` callback function, where we call the `start` method on the
    `casper` object, providing the URL to the Contact page and supplying the `wait`
    function to indicate that we should wait for the primary content `div` container
    to load before conducting any test steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first scenario that we test is to check the client-side validation when
    a poorly formatted email address is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We call the casper object's `then` method, providing the `fillOutContactFormWithPoorlyFormattedEmailAddress`
    JavaScript function as the `then` callback function. We wait for `450` milliseconds
    for a result, capture a screenshot of the test run (shown in *Figure 10.10*),
    and then call the `assertSelectorHasText` method on the `tester` module, providing
    a CSS selector of the element containing the error message, along with the expected
    text the error message should have displayed, followed with a description of the
    test we are conducting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second scenario that we test, is to check the client-side validation when
    an incomplete form has been submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We call the `casper` object's `then` method, providing the `fillOutContactFormPartially`
    JavaScript function, as the `then` callback function. We wait for `450` milliseconds
    for a result, capture a screenshot of the test run (shown in *Figure 10.11*),
    and conduct two tests within this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In the first test, we call the `assertSelectorHasText` method on the `tester`
    module, providing a CSS selector of the element containing the error message for
    the last name field along with the expected text, the error message should have,
    followed with a description of the test. In the second test, we call the `assertSelectorHasText`
    method on the `tester` module, providing a CSS selector of the element containing
    the error message for the message body text area, the expected text the error
    message should have, followed with a description of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third scenario that we test is to check that a confirmation message has
    been displayed upon the submission of a properly filled out contact form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We call the `casper` object's `then` method, providing the `fillOutContactFormCompletely`
    JavaScript function, as the `then` callback function. We wait for `450` milliseconds
    for a result, capture a screenshot of the test run (shown in *Figure 10.12*),
    and call the `casper` object's `assertSelectorHasText` method. We provide the
    CSS selector `"#primaryContent h1"`, since the confirmation message will be inside
    the `<h1>` tag. We supply the expected text that the confirmation message should
    contain, being `"Confirmation"`. Finally, we provide a description of the test
    for the last parameter of the `assertSelectorHasText` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To signify the end of the test suite, we call the casper object''s `run` method,
    and inside the `then` callback function, we call the tester module''s `done` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that you are inside the `client/tests` folder, you can issue the following
    command to run the contact form test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.9* shows a screenshot image of running the contact form test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23a64aa1-e615-485d-8963-23c087ae03b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Running the contact form test suite'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.10* shows the generated screenshot image of running the first test
    which checks that the client-side form validation properly detects an improperly
    formatted email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e460f8a1-c6f5-48d1-b820-b84ae40699ef.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Testing the email validation syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.11* shows the generated screenshot image of running the second test
    and third test, which checks that the client-side form validation properly detects
    that the last name field and the message body text area has not been filled in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38941cab-a572-415b-9fc3-d1af80f33375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Test to verify if the form validation detects required fields
    that have not been filled out'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.12* shows the generated screenshot image of running the fourth test,
    which checks that the confirmation message has been displayed upon successfully
    filling out and submitting the contact form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ac84bc0-7438-47bf-a309-700223b90e08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Test to verify the confirmation message'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified the client-side validation functionality for the contact
    form, let's look into implementing a CasperJS test suite for the shopping cart
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the shopping cart functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to verify the shopping cart functionality, we must be able to add a
    product multiple times to the shopping cart, check that the product exists in
    the shopping cart with the proper quantity of the product displayed, and have
    the ability to remove the product from the shopping cart. Therefore, there are
    3 expected tests that we will need in the shopping cart test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` function in the `shoppingcart_test.go` source file, located in the
    `client/tests/go` directory, implements the shopping cart test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `main` function, we set the web browser's viewport size. We start
    a new test suite by calling the `begin` method on the `casper` object. Note that
    we have indicated that there are 3 expected tests in this test suite. Inside the
    `then` callback function that constitutes the last argument to the `begin` method,
    we call the `start` method of the `casper` object, providing the URL to the products
    listing page, and providing the JavaScript `wait` function, as the `then` callback
    function. This will cause the program to wait until the primary content `div`
    container has loaded in the DOM, before conducting any tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following code, we add three Swiss Army Knives to the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have passed the `click` method of the `casper` object with the
    CSS selector `".addToCartButton:first-child"`, to ensure that the Swiss Army Knife
    product is clicked on, since it is the first product displayed on the products
    listing page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to verify that the Swiss Army Knives were properly placed in the shopping
    cart, we need to navigate to the shopping cart page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first test consists of verifying that the correct product type exists in
    the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We do this by checking that the `"Swiss Army Knife"` text exists on the shopping
    cart page by calling the `assertTextExists` method on the `tester` module object
    and providing an expected text value of `"Swiss Army Knife"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second test consists of verifying that the correct product quantity exists
    on the Shopping Cart page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we call the `tester` module object''s `assertTextExists` method, passing
    in the expected text, `"Quantity: 3"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We generate a screenshot of the shopping cart, and this screenshot (shown in
    *Figure 10.14*) should display the Swiss Army Knife with a quantity value of `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our last test consists of removing an item from the shopping cart. We remove
    the product from the shopping cart with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to verify that the product was successfully removed from the shopping
    cart, we need to check if the message indicating that the shopping cart is empty,
    exists on the Shopping Cart page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in our call to the `tester` module object's `assertTextExists` method,
    we check to see whether the `"Your shopping cart is empty."` text exists on the
    web page. Prior to this, we also generate a screenshot image (shown in *Figure
    10.15*), which will show us the shopping cart in the empty state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will signify the end of the shopping cart test suite with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the CasperJS tests for the shopping cart test suite by issuing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.13* shows a screenshot of the result of running the shopping cart
    test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/198e3138-fef7-4a77-aaac-3d297f1761a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13: Running the shopping cart test suite
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.14* shows the generated screenshot showing the test case, where
    `3` Swiss Army Knives have been successfully added to the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc3bbfd2-e87e-482b-9d5b-0511eb5cffe9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14: Test case to add a product multiple times to the shopping cart
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.15* shows the generated screenshot showing the test case, where
    the Swiss Army Knife product has been removed, thus emptying the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f46a1785-f500-4a37-b10c-e58ceb670de9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15: Test to verify emptying the shopping cart
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified the functionality for the shopping cart, let's look
    into testing the live chat feature.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the live chat feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The live chat test suite consists of three tests. First, we must ensure that
    the chat box opens up when the live chat icon is clicked on the top bar. Second,
    we must ensure that the chat bot responds to us when we ask it a question. Third,
    we must ensure that the conversation is retained when we navigate to another section
    of the website.
  prefs: []
  type: TYPE_NORMAL
- en: The live chat test suite is implemented in the `livechat_test.go` source file
    found in the `client/tests/go` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `waitChat` JavaScript function will be used to wait for the chat box to
    open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `askQuestion` JavaScript function will be used to send a question to the
    chat bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use the `sendKeys` method of the `tester` module object (the `this`
    variable is bound to the `tester` module object) to type the `"What is Isomorphic
    Go"` question, and we call the `sendKeys` method again to send the `enter` key
    (the equivalent of pressing the `enter` key on the keyboard).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `main` function, we set the web browser''s viewport size and begin
    the test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will activate the live chat feature, by simulating a user
    click on the live chat icon on the top bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will wait until the chat box has opened up, before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the chat box has opened up, we can verify that the chat box is visible
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that we call the `tester` module object's `assertSelectorHasText` method,
    providing a CSS selector of `"#chatboxTitle span"` to target the chat box's title
    `span` element. We then check to see whether the `"Chat with"` text exists inside
    the `span` element to verify that the chat box is visible.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have generated a screenshot image, which should show us the chat
    box opened up, with the chat bot providing its greeting message (shown in *Figure
    10.17*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to verify that the chat bot provides an answer to
    us when we ask it a question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We call the `askQuestion` function to simulate the user typing in the `"What
    is Isomorphic Go"` question and pressing the `enter` key. We wait for `450` milliseconds,
    then generate a screenshot, which should show the live chat bot answering our
    question (shown in *Figure 10.18*). We verify that the chat bot has provided an
    answer by calling the `tester` module object's `assertSelectorHasText` method
    and providing it the CSS selector to access the `div` container, which contains
    the conversation and a substring of the expected answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we are on the home page. To test that the conversation is retained
    while navigating to a different section of the website, we use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specified to navigate to the About page, and then wait until the primary
    content `div` container has loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We wait for `450` milliseconds, take a screenshot image (shown in *Figure 10.19*),
    and then conduct the last test in our test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The last test here is a repeat of the previous test we conducted. Since we are
    testing that the conversation has been retained, we expect that the answer the
    chat bot gave us, after the last test, is preserved within the `div` container
    containing the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will close the chat box by simulating a user click to the close control
    (the Χ found in the upper right hand corner of the chat box), so that the websocket
    connection is closed normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will signify the end of the live chat test suite with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the CasperJS tests for the live chat test suite by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.16* shows a screenshot of the result of running the live chat test
    suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a3a32ac-e59b-46df-8825-8444727993e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16: Running the live chat test suite
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.17* shows the generated screenshot showing the test case, where
    we check to see whether the chat box has opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2356f933-0a29-4f85-9cb1-e16773ef5aa0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17: Test to verify that the chat box appears
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.18* shows the generated screenshot showing the test case, where
    we check to see whether the chat bot responds to the given question:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/287800b7-6d60-4eb6-95b2-ead61e61aa08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18: Test to verify that the chat bot responds to a question
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.19* shows the generated screenshot showing the test case, where
    we check to see whether the chat conversation is retained after navigating to
    a different page on the website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b035846b-882a-430c-abe3-f4f36f65c4ef.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19: Test to see if chat conversation is retained after navigation
    to a different section of the website
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified the functionality for the live chat feature, let's look
    into testing the cogs, starting with the time ago cog.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, the generated screenshot images shown in Figures 10.17,
    10.18, 10.19, 10.21, 10.23, 10.25, 10.27, and 10.29 have been cropped.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the time ago cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing the time ago cog consists of establishing a gopher's known date of joining
    the IGWEB team. We will establish May 24, 2017, as Molly's start date, and use
    this as the basis to test the human understandable time that is displayed under
    Molly's bio data on the About page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test suite for the time ago cog, which is implemented in the `humantimecog_test.go`
    source file found in the `client/tests/go` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `main` function, after we set the viewport size, and begin the test
    suite, we create a new `time` instance, called `mollysStartDate`, which represents
    the time when Molly joined the IGWEB team. We then pass `mollyStartDate`, to the
    `Time` function of the `go-humanize` package (note that we have aliased this package
    as `"humanize"`) and store the human understandable value of the start date in
    the `mollysStartDateHumanTime` variable.
  prefs: []
  type: TYPE_NORMAL
- en: We generate a screenshot of the test run (shown in *Figure 10.21*). We then
    call the `tester` module object's `assertSelectorHasText` method, passing in the
    CSS selector to the `div` container containing Molly's start date in human readable
    format. We also pass in the `mollysStartDateInHumanTime` variable, since this
    is the expected text that should exist within the selector.
  prefs: []
  type: TYPE_NORMAL
- en: We will signify the end of the time ago cog test suite by calling the `done`
    method on the `tester` module object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the CasperJS test for the time ago cog test suite by issuing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.20* shows a screenshot of the result of running the time ago cog
    test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/167feaf5-4996-4f62-b9f6-f6ad7d46c6cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20: Running the time ago cog test suite
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.21* shows the generated screenshot showing the About page, with
    Molly''s start date printed out in human readable time format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4939e782-a0bc-42a1-b2a9-0dc531f15f44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21: Test to verify the time ago cog
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified the functionality for the time ago cog, let's look into
    testing the functionality of the live clock cog.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the live clock cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verifying the functionality for the live clock cog for the user's local time,
    consists of creating a new `time` instance, of the current time formatted based
    on the local zone name and the local timezone offset, and comparing it to the
    value that is in the `myLiveClock` `div` container displayed on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test suite for the live clock cog, which is implemented in the
    `liveclockcog_test.go` source file found in the `client/tests/go` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: After setting the web browser's viewport size and starting the test suite by
    accessing the home page, we wait for `900ms`, and then we gather the user's local
    time zone name and the local time zone offset. We will be formatting the time
    according to the RFC1123 layout. This happens to be the same layout that is used
    by the live clock cog for displaying the time.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `FixedZone` function from the `time` package passing in `localZonename`
    and `localOffset` to get the location. We create a new time zone instance, and
    format it using the `location` and the RFC1123 `layout`. We use the `tester` module
    object's `assertSelectorHasText` method to see whether the current time formatted,
    using the RFC1123 `layout` and using the user's present `location`, exists within
    the selector specified to the `assertSelectorHasText` method.
  prefs: []
  type: TYPE_NORMAL
- en: We generate a screenshot of the test run (shown in *Figure 10.23*), and then
    call the `done` method on the `tester` module object to signify the end of the
    test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the CasperJS test for the live clock cog test suite by issuing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.22* shows a screenshot of the result of running the live clock cog
    test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e537569-a9fc-488b-a40b-35643edd978c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22: Running the live clock cog test suite
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.23* shows the generated screenshot showing the live clock cog on
    the Home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85e8e540-f8e5-4f98-acf1-ca380e3bb0ba.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23: Testing the live clock cog on the home page
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified the functionality for the live clock cog, let's look
    into testing the functionality of the date picker cog.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the date picker cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verifying the functionality for the date picker cog consists of navigating to
    the Contact page, and clicking on the Time Sensitivity Date input field. This
    should trigger the display of the calendar widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test suite for the date picker cog, which is implemented in the
    `datepickercog_test.go` source file, located in the `client/tests/go` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `main` function, we set the web browser's viewport size and start
    the test suite by navigating to the Contact page.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `casper` object's `click` method and provide the CSS selector
    `"#byDateInput"`, which will send a mouse click event to the Time Sensitivity
    Date input field, which should reveal the calendar widget.
  prefs: []
  type: TYPE_NORMAL
- en: We take a screenshot of the test run (shown in *Figure 10.25*), and then call
    the `tester` module object's `assertVisible` method, providing the `".pika-single"` selector and
    the name of the test, as input arguments to the method. The `assertVisible` method
    will assert that at least one element matching the provided selector expression
    is visible.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `done` method on the `tester` module object to signify
    the end of the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the CasperJS test for the date picker cog test suite by issuing
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.24* shows a screenshot of the result of running the date picker
    cog test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b21e8409-5679-499d-b43f-2c07f6351391.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24: Running the date picker cog test suite
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.25* shows the generated screenshot showing the calendar widget after
    the Time Sensitivity Date input field has been clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e736752f-9000-4c4a-8520-62d18ef8be0a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25: Test verifying that the date picker appears
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified the functionality for the date picker cog, let's look
    into testing the functionality of the carousel cog.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the carousel cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verifying the functionality for the carousel cog consists of providing sufficient
    time for the images of the carousel to load, and for the first image, the `watch.jpg`
    image file to appear on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test suite for the carousel cog, which is implemented in the `carouselcog_test.go`
    source file, located in the `client/tests/go` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: After setting the web browser's viewport size and starting the test suite, by
    navigating to the Home page, we wait `1800` milliseconds and then we call the
    `assetResourceExists` method on the `tester` module object, supplying the name
    of the resource to check, which happens to be the `"watch.jpg"` image file, and
    a description of the test. The `assertResourceExists` function checks to see whether
    the `"watch.jpg"` image file exists in the set of assets that were loaded on the
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: We take a screenshot of the test run (shown in *Figure 10.27*), and then call
    the `done` method on the `casper` object to signify the end of the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the CasperJS test for the carousel cog test suite by issuing the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.26* shows a screenshot of the result of running the carousel cog
    test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17e19dbb-85e2-46db-b799-0f4e08e90ac5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26: Running the carousel cog test suite
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.27* shows the generated screenshot showing the carousel cog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/682d8e25-dc8f-45b3-a254-22e383f29bff.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27: Test to veriy that the carousel cog appears
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've verified the functionality for the carousel cog, let's look into
    testing the functionality of the notify cog.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the notify cog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Verifying the functionality for the notify cog consists of navigating to the
    products listing page, adding an item to the shopping cart by clicking the Add
    to Cart button on a listed product, and then verifying that the notification appeared
    on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the test suite for the notify cog, which is implemented in the `notifycog_test.go`
    source file, located in the `client/test/go` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: After setting the web browser's viewport and starting the test suite by navigating
    to the products listing page, we call the `casper` object's `click` method, providing
    the `".addToCartButton:nth-child(1)"` selector. This sends a mouse click event
    to the first Add to Cart button on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: We wait for `450` milliseconds and then call the `tester` module's `assertSelectorHasText`
    method providing the CSS selector, the text that should exist within the element
    returned from the selector, and the description of the test as input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We take a screenshot of the test run (shown in *Figure 10.29*). We then navigate
    to the shopping cart page, and remove the item from the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call the `done` method on the `tester` module object to signify
    the end of the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run the CasperJS test for the notify cog test suite by issuing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 10.28* shows a screenshot of the result of running the notify cog test
    suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b92c81a-fd43-4a2a-ae48-6dcd8626da95.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.28: Running the notify cog test suite
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.29* shows the generated screenshot showing the notification message
    displayed on the lower right hand corner of the web page as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19ffe05f-950c-4448-9608-7f34d1addbb4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.29: Running the test to verify that the notification message was displayed
  prefs: []
  type: TYPE_NORMAL
- en: We have now verified that the notify cog is functioning as expected and this
    wraps up our testing of IGWEB's client-side functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.30* shows a screenshot of running the whole collection of test suites
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/2b9a606e-627b-4472-b0a2-af934ca2ff35.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.30: Running the whole collection of CasperJS test suites
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to perform end-to-end testing to verify the
    functionality of an Isomorphic Go web application. To ensure the quality of IGWEB,
    prior to website launch, we started out by gathering the set of baseline functionality
    to test for.
  prefs: []
  type: TYPE_NORMAL
- en: To verify server-side functionality, we implemented tests using Go's `testing`
    package from the standard library. We implemented tests that verified server-side
    routing/template rendering, the contact form's validation functionality, and the
    successful contact form submission scenario.
  prefs: []
  type: TYPE_NORMAL
- en: To verify client-side functionality, we implemented tests using CasperJS that
    verified multiple user interaction scenarios. We were able to perform automated
    user interaction testing using CasperJS, since it sits on top of PhantomJS, a
    headless web browser equipped with a JavaScript runtime. We implemented CasperJS
    tests to verify the client-side routing/template rendering, the contact form's
    client-side validation functionality, the successful contact form submission scenario
    on the client-side, the functionality of the shopping cart, and the functionality
    of the live chat feature. We also implemented CasperJS tests, to verify the functionality
    of the collection of cogs that we implemented in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml),
    *Cogs – Reusable Components*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](19922281-fd33-4fab-bac2-75066243176d.xhtml), *Deploying an Isomorphic
    Go Web Application*, you will learn how to deploy IGWEB to the cloud. We will
    first explore the procedure to release the website to a standalone server. After
    that, you'll learn how to utilize Docker, to release the website as a multi-container
    Docker application.
  prefs: []
  type: TYPE_NORMAL
