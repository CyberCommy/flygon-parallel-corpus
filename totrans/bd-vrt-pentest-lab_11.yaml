- en: Chapter 11. Attacking Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will identify the methods we use to attack services and
    servers. The nice thing about this is that we know a server has to have the service
    running and, more importantly, have the socket in a listening state, ready to
    accept connections. Moreover, this means that the server sits there and just waits
    for us to attack it. This is good for us, as we already covered this in [Chapter
    9](ch09.html "Chapter 9. Assessment of Web Servers and Web Applications"), *Assessment
    of Web Servers and Web Applications*. The most common attack vector we are going
    to see is the web applications that are running on a web server. It is not our
    intention to cover this again here; instead, we will focus on other things that
    we can attack on the server platforms we encounter. In this chapter, we will be
    discussing the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Common protocols and applications for servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database assessment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS platform specifics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with information about the ways we can target and
    hopefully, penetrate the servers that we encounter when we are testing. As the
    target is a server, we could potentially get access via an OS vulnerability or
    a flaw. Unfortunately, this is becoming more and more rare. Microsoft and other
    vendors have done their homework, and the vectors of attack against the OS are
    not dead, but they could be considered to be on life support. Therefore, we want
    to focus on the protocols and the applications that are running on the servers,
    as they will usually provide us with our best chance at a successful attack.
  prefs: []
  type: TYPE_NORMAL
- en: Common protocols and applications for servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some of the more common protocols and applications
    that are typically found on servers.
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, we have covered this, but it is still one of the most common applications
    on servers, and as such, one of our potential vectors of attack. When it comes
    to web applications, we have even more potential areas that we can attack due
    to the common mistakes in the coding of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: File Transfer Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**File Transfer Protocol** (**FTP**) has been around for a very long time.
    In this section, we are going to use an advanced method of FTP that can be used
    when you encounter an environment that does not allow the standard FTP client/server
    communication to work. An excellent reference for information on protocols is
    the Network Sorcery website; you can find it at [http://www.networksorcery.com](http://www.networksorcery.com).
    There is a wealth of information here for reference; the area we want to concentrate
    on is **RFC** **Sourcebook** | **Protocols**. An example of this page is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File Transfer Protocol](img/477-1_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The RFC protocols (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'As you review the site, you will see that at the top, there is a menu bar that
    is alphabetical. This is where we want to select the protocols we might encounter
    when we do our professional security testing. We want to take a look at the FTP
    information. Navigate to **F** | **FTP** to open the page that contains the information
    about FTP. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File Transfer Protocol](img/477-1_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the page that contains the information about FTP (the cropped
    text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are doing our testing, it is often too late to get the detailed knowledge
    we might need with certain protocols; this is where the RFC Sourcebook can assist
    us. This site is beneficial because it also provides the protocol packet header
    information. Click on **IP** to display the header. An example of the header is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File Transfer Protocol](img/477-1_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Protocol research
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of things you can discover when you research on a protocol;
    however, to be able to do this, we need to understand how the protocol behaves.
    This is what we want to do when we research the protocol; furthermore, we want
    to know how we can leverage FTP. As the majority, if not all clients, have an
    FTP client on the machine, it is a good way to transfer files. For example, we
    commonly do this if we find the weak filters that we discussed in [Chapter 7](ch07.html
    "Chapter 7. Assessment of Devices"), *Assessment of Devices*. Before we can do
    this, we need to understand more about the FTP and how it creates the connections.
    We will save you some time and offer an example; however, you are encouraged to
    research the protocol to learn more tricks that you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main thing you need to know is that the FTP port command identifies an IP
    address by separating it with commas and not decimals like we are commonly used
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, it uses a byte mode system, and the ports are represented in
    the Base 256 format. So, to connect to IP address `192.168.177.10` on port `1024`,
    the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The breakdown of this is that the port is represented by *4x256=1024*. Again,
    these are the types of things that are good to know when we run into the common
    FTP protocol, and it is located in a DMZ protected by a weak filtering rule.
  prefs: []
  type: TYPE_NORMAL
- en: This is best represented with an example. You will need a machine to serve as
    the filter; you can use either the **Dynamips** machine or the **IP Tables** machine
    that we created earlier in the book. Then, you need a machine that will serve
    as the inside machine that will run the FTP server. We will use a Windows 7 machine
    here in the book, but it can be any machine with the capability to run an FTP
    server. Then, we need a machine that will serve as the external machine, sending
    traffic from the outside. You need to create routes on both sides of the filtering
    device. Additionally, create the rule to allow FTP traffic and the return traffic.
    Remember that the return traffic will have a source port of 20\. Once you have
    built the required architecture, it is just a matter of working through the commands.
    We will use the Kali Linux machine to send the commands and run `netcat`; we will
    use the 3com FTP server on the protected machine.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, with routers and stateless filters, it is often common
    for the administrator to allow the return traffic of a protocol such as FTP, and
    as we have shown, we can leverage this to get past the filter that is in place.
    Furthermore, we can use our knowledge of how the FTP behaves and the commands
    it uses to interact with an FTP server through a filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do once we have our environment built is start our
    FTP server. Once the server has started, we then need to connect to it from the
    Kali Linux machine using the capability coming from the source port of 20\. In
    the terminal window on Kali Linux, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will connect to the FTP server that is located inside the filtering device.
    An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol research](img/477-1_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, a good indication that we are successful is
    the fact that we see the banner from the server. This is a common configuration
    when an inside machine is allowed to connect to an external FTP server, as the
    server will send the data from a source port of 20\. Then, the rule to allow this
    connection is in the filtering device; therefore, by sending the data from this
    port, we can penetrate into a weak filter. We use the FTP server on the inside
    to demonstrate the point. We could have chosen any open port on the machine to
    show this. We now need to log in to the server, and it is likely that `anonymous`
    will be enabled. So, enter the user as `anonymous`, and once you see the acknowledgement
    of the user, enter the password as `password123`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get the acknowledgement that the user is logged in, you can enter
    `help` to see the commands if you want to. From the FTP commands that are available,
    the one that we want to use is the `nlst` command that will provide us with a
    listing of the directory that we are in. In the FTP login window, enter `nlst`
    to list a directory. Are you successful? The answer is no! This is because for
    this to work, the program has to know what port the client is listening on to
    send the data to that port. To set this up, we need to open another window so
    that we can get the data returned by the connection. When you open another terminal
    window, you can arrange them so that you can see both of them at the same time.
    In the new window, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open a port on the Kali Linux machine that will receive the data
    from the server. Once the port is in the listening state, we need to tell the
    server what port to send the data to, and we do this with the `port` command as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will inform the server that the port to send the data to is 2048\. Once
    the data has been sent, you enter the `nlst` command. This will show you the directory
    that is listed on the server. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol research](img/477-1_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have a file called `account.txt`, which
    is located on the server. We will now transfer the file using the FTP server to
    send it to us. We want to output the data that is received on the port to a file;
    we will do this using the output redirection (`>`) operator. The process is the
    same as before. In the window with the `netcat` tool, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to run through the command sequence. Enter the same commands
    as we did earlier to the port command. Once the port command has been entered,
    we need to get the file. We do this by entering `retr accounts.txt`. An example
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol research](img/477-1_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have transferred the file to our Kali
    Linux machine. To verify this, we enter `trophy.txt`. The results are shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol research](img/477-1_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have successfully transferred a file. It
    is important to remember that this could have been any file. The requirement is
    to find the weak filtering rule and then leverage it for our benefit.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed how to identify vulnerabilities and a number of resources
    to do this on numerous occasions throughout the book, and this also applies here.
    The FTP server is a software and, as such, does have vulnerabilities. In fact,
    the version of the FTP server we used, 3com Daemon, does actually have an exploitable
    vulnerability in it. However, as this is our test lab, we control for the most
    part what happens to our machines and also the applications running on these machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visit the Exploit DB site ([http://www.exploit-db.com](http://www.exploit-db.com))
    to see what we are referring to. Once we are on the site, we enter a search on
    all the vulnerabilities that were found to be running on port 21\. An example
    of the results of the search is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Protocol research](img/477-1_11_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Secure Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Secure Shell** (**SSH**) protocol is quite common, so we will more than
    likely encounter it when we are testing. The techniques we applied with FTP could
    also, in some cases, be applied to SSH; it depends on how the administrator has
    configured the access to and from the SSH server. We will not focus on this here
    as we have covered the process and steps we would use with respect to FTP.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the SSH protocol? It was designed originally as a replacement for
    the clear text weaknesses of the Telnet protocol. An excellent way to learn more
    on the protocol is to visit the Network Sorcery site.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the explanation for SSH is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a brief understanding of what the SSH protocol is, let''s
    take a look at the vulnerabilities related to it. If we return to our Exploit
    DB and enter a search for the port of SSH, which is 22, we can review the vulnerabilities
    in the protocol itself. An example of the results of this search is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our search returned some exploits; however, this search has not returned any
    for a recent version. At first, we would say that this makes it very difficult
    to find an exploit that we can use against a site today. In many environments,
    we have and continue to discover old versions of the SSH protocol, so never count
    out using it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Another nice thing about the SSH protocol is that it is only as strong as the
    administrator configures it. If the administrator allows weak passwords to exist,
    then there is still a chance that we can gain access using the SSH protocol. This
    brings us to a very important point that is good to understand, and that is, we
    do not always have to exploit the box to get on the box! We can use other methods
    of access to the machine, so it is not always imperative that we find an exploit.
    Furthermore, the validation of vulnerabilities or exploitation has to be allowed
    as per the scope of work.
  prefs: []
  type: TYPE_NORMAL
- en: A powerful thing that we can do is use SSH to mask our presence and blind the
    monitoring of the client network. As SSH is encrypted, we can use it to carry
    out commands remotely once we have exploited a machine. For this demonstration,
    we will use the Kioptrix virtual machine. The process will be to exploit it, then
    crack the password and use it to log in via SSH to the machine, then execute our
    commands in an encrypted tunnel. We will run Wireshark throughout, so we can see
    exactly what the victims' network monitoring systems would see.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we discovered earlier, we know that we have a vulnerable version of Samba,
    so we will use that as our initial vector of attack. We can use metasploit or
    the code from the exploit database. We need to run Wireshark and see what can
    be seen when we attack. For the example, in the book, we will use the code and
    not metasploit. We decided to use this because the metasploit Meterpreter shell
    is great, but if we do not have a Windows machine, then we have a limited selection
    of shells. To refresh your memory, we are using the C file `10.c`, and we have
    compiled it to the name of `sambaexp`,so we want to run the`./sambaexp` command
    to see how to use the tool. Remember that you have to be in the directory of the
    program to get the program to execute the command. An example of the results of
    this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the terminal window, we need to enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should result in getting the shell on the machine, and once you
    have done this, you can just copy the password file over and crack a password.
    Alternatively, you could create a user or change the root password. Which one
    you choose is up to you. An example of the exploited machine is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have root user on the machine, but the problem is we are going across
    the network, so any monitoring system will see what we do. We can enter a few
    commands and then review the information in Wireshark. Enter `/sbin/ifconfig`
    to view the IP information. Then, enter `nmap` to see if we have got lucky and
    the administrator has installed Nmap on the machine. An example of this command
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen that comes up when we enter nmap (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'As the previous screenshot shows, we have gotten lucky; well, not that lucky
    as this is a very old version of Nmap. However, what about our activity? Have
    we been noticed? What does Wireshark capture? As you can imagine, for the most
    part, everything we have done is in clear text; therefore, Wireshark will show
    our activity. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have intercepted our communications, and
    a monitoring device would know what we were doing. As we have the Nmap tool on
    the machine, we could run commands with it. However, we would be detected again
    if someone looked at the network traffic; therefore, it is much better to use
    a tunnel, and we will do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example in the book, we have changed the root password on the compromised
    machine to `password`. To connect via SSH, we enter `ssh root@192.168.177.148`.
    An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we logged in to the root account. Once we
    are in, we did an Nmap scan. That is all well and good, but the thing we want
    to know is what our network traffic reveals to our potential clients'' monitoring
    devices. An example of the Wireshark information is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Secure Shell](img/477-1_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our network traffic shows the handshake that has the clear text information
    for the different algorithms as well as the banners of the client and server.
    Once the handshake completes, the rest of the data is encrypted, and as such,
    we cannot see what is taking place in our tunnel; this was our goal. It is good
    that many of the types of architecture that are out there use SSH on a regular
    basis, and we can use this to our advantage if we compromise a machine and perform
    post-exploitation tasks without being monitored.
  prefs: []
  type: TYPE_NORMAL
- en: Mail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next service we want to discuss is mail. This is another one of those services
    that we can count on to be on the servers of our clients. One of the first challenges
    we face is the type of mail server that is being used. Once we have determined
    that, we can start looking for ways to attack it or, at the very least, use it
    to our advantage when we are doing our testing. Most of the servers we encounter
    will be running the **Simple Mail Transfer Protocol** (**SMTP**), which is one
    of the easy things to determine. The port that SMTP runs on is 25, but administrators
    can change this and often do. So, it is a matter of looking for the banner that
    is returned to discover where the service is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same technique that we used earlier and search in the Exploit
    DB to see whether there might be some kind of exploit there. An example of a search
    for the SMTP exploits is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mail](img/477-1_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we really do not have anything current in
    the exploit department for the SMTP service. This is only one type of mail we
    might encounter in testing, so let us explore another one and see if we have any
    more luck. We will look at the **Post Office Protocol** (**POP**) that runs on
    port 110\. An example of the search for exploits for this service is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mail](img/477-1_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not having much luck here, and this is the reality of searching for
    exploits. All systems and services will have vulnerabilities in them, but not
    all vulnerabilities will have exploits. We have one more mail type that we can
    look for and that is **Internet Message Access Protocol** (**IMAP**), which runs
    on port 143\. An example of a search for exploits is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mail](img/477-1_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, we are not getting anywhere with an exploit for the mail service, so
    what do we do now? Give up? Not yet! We can interact with the mail server in SMTP
    and potentially send an e-mail. This is possible provided that social engineering
    is part of our scope of work. You can connect to the port 25 and send an e-mail.
    Years ago, you could send an e-mail as any user of your choice. It was fun to
    send an e-mail as the Queen of England or the President of the United States.
    This was because the connection of port 25 could be made manually, and you could
    enter the commands that a mail server uses when it sends mails. In the year 2000,
    this mail spoofing attack was used to attack the company Emulex by spreading false
    information about the company. This had a direct impact on the stock price and
    caused a *paper* loss of more than 2 billion dollars to the company before it
    was discovered to be a spoof and illegitimate e-mail. Since there are few relay
    sites available after the Emulex attack, you still need to test for them. Furthermore,
    I can send an e-mail as a legitimate user at the site by connecting to port 25\.
    This is commonly referred to as an SMTP relay. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: telnet <site> 25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'mail from: kevin@company.com'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'rcpt to: victim@spoofed.com'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Subject: Message from the IT department'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hello, this is the IT department, please send an email with your username and
    password to access XYZ project files. Thank You.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (this is a period on a line by itself to indicate end of the data)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the process for manually connecting and sending an e-mail. Again, most
    organizations will prevent this, but it is worth an attempt. Furthermore, in an
    internal test, you might have more success. An example of an attempt that fails
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mail](img/477-1_11_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the first `rcpt to` is to an incorrect e-mail
    address, and it is immediately rejected with the message stating that the relay
    is not permitted. This is because of the lessons that were learned some time ago
    with the Emulex attack as well as others. In today's environment, this more than
    likely will not work, but there is always a chance.
  prefs: []
  type: TYPE_NORMAL
- en: Database assessment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are testing one of the things that we want to treat as a valuable asset:
    the databases for our clients. This is where the company usually has most of the
    data that, if compromised, could cost the company a great amount of revenue. There
    are a number of different databases that are out there. We will concentrate on
    only three of them: **Microsoft SQL** (**MSSQL**), **MySQL**, and **Oracle**.'
  prefs: []
  type: TYPE_NORMAL
- en: MSSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MSSQL database has provided us with a number of vulnerabilities over the
    years, but as the versions of the database became more mature, the vulnerabilities
    decreased dramatically. We will start off by searching to see whether we can find
    any database exploits in the Exploit DB site for MSSQL. The results of the search
    are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we do not have much of a selection of exploits
    that are against the MSSQL database, but we do have an interesting exploit that
    is against the Symantec Endpoint Protection Manager. However, it is not against
    MSSQL, so we will leave this as homework for those of you who want to pursue it.
    It is interesting that it attacks an endpoint protection system via SQL injection
    among other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we really did not discover much in our search of the exploit database, we
    will turn our attention to the process we use when we encounter a MSSQL target.
    As with all the testing, the sequence to follow is very similar to the methodologies
    that we have discussed throughout the book. The first approach we will use is
    the Nmap tool in our Kali Linux distribution. You will need an SQL Server as a
    target. If you do not have one, you can download the software from the Microsoft
    site. Bear in mind that the newer the version you install, the more you will have
    to change the settings so that it is vulnerable. Open a terminal window and enter
    `nmap –p 1433 --script ms-sql-info <target>`. An example of the results from this
    command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have an old version of SQL Server, and
    this should make our job easier. Once we have the information on the database,
    we need to see if we can determine the password of the administration account,
    which is the SA account in MSSQL. We have a script in Nmap that will perform a
    brute-force attempt to find the password. In the terminal window, enter `nmap
    –p 1433 --script ms-sql-brute` `192.168.177.149` to determine the password.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of an attempt at this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, our attempt has failed, and in this case, we were not able to
    crack the SA password. Often, the password will be the default, which is `<blank>`.
    As we have failed at this, we will face more challenges as we attempt to extract
    more data from this database. As we are in control of the targets, we can just
    create a target that has the default or a known password so that we can continue
    our testing. One of the things we can do if we do get the credentials of the SA
    account is that we can attempt to dump the password hashes. To do this, enter
    `nmap –p 1433 --script ms-sql-empty-password,ms-sql-dump-hashes <target>` in the
    terminal window in Kali. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The thing that we want to explore is the stored procedures within the SQL Server.
    As we have identified that the credentials are default, we can execute commands
    on the server. In the terminal window, enter `nmap –p 1433 --script ms-sql-xp-cmdshell,ms-sql-empty-password`
    -`p 1433 192.168.177.149` to run a command on the server machine. By default,
    the command will be `ipconfig /all`, but you can change it if you want to run
    another command. It is important to note that this command shell access is the
    same as opening a command prompt window on the server machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a portion of the output from this command is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have virtually complete access to this machine. Of course, it is running
    SQL Server 2000; however, what if it is running SQL Server 2005? We will now take
    a look at a Windows Server 2003 machine. The main thing to remember is that with
    SQL Server 2005, these stored procedures are disabled by default and the administrator
    will have to enable them. Also, the SA password will have to remain as the default,
    so when you encounter Server 2005, you might not be able to gain the information
    as with an SQL Server 2000 configuration. Furthermore, if the password cannot
    be determined, you will not be able to execute the commands. An example is shown
    in the following screenshot where SQL Server 2000 is not configured with the default
    password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have only used the scripting capability within Nmap. We also have
    the capability for database testing in metasploit. Start the metasploit tool by
    entering `msfconsole` in a terminal window. Once the metasploit tool comes up,
    enter `use auxiliary/scanner/mssql/mssql_ping`, then set `RHOSTS` and run the
    module. An example of the output of the module is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have information about the database server and the version of SQL that
    is running. The next thing we need to do is to see what the configuration on the
    SQL Server is. In the metasploit window, enter `use auxiliary/scanner/mssql/mssql_login`,
    set `RHOSTS`, and run the command. An example of the output of this command is
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have enough information about our target, the database it is running,
    and the configuration of that database. It is time to attempt enumeration methods
    on the database using metasploit. In the metasploit window, enter `use auxiliary/admin/mssql/mssql_enum`
    to enumerate information about the database. The output from this command is quite
    extensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the first portion of the output from this command is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have been able to determine a number of
    configuration parameters and we have names of the databases that have been created.
    An example of another portion of the output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have a list of the admin logins and the stored procedures that are allowed
    by the database configuration. The list is truncated here, but you are encouraged
    to review all of the possible stored procedures that you can find in an MSSQL
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, we have the capability to execute commands using these
    stored procedures just as we did with Nmap. We will do this now. In the terminal
    window, enter `use auxiliary/admin/mssql/mssql_exec` to access the module. Once
    you are in the module, enter `set CMD ''dir''` to display a directory on the machine.
    Remember that this is a command shell with system privileges, and as such, the
    only limit is your imagination. An example of the output of this command is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MSSQL](img/477-1_11_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next database that we will look at is the MySQL database that is free and
    open source. As we did earlier, we will start with searching the Exploit DB site
    and see what exploits we might have available when it comes to this database.
    An example of the search results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MySQL](img/477-1_11_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have a number of vulnerabilities that have
    exploits for them with respect to MySQL. For now, we will continue with the methodology
    of identifying and enumerating information from a MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: We need a MySQL database to work with first, so we can use our CentOS virtual
    machine. To install the database, enter `yum install mysql-server mysql`. Once
    the installation is completed, you need to check it. Enter `chkconfig mysqld on`,
    and once this completes, enter `/etc/init.d/mysqld start` to start the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we need to do for our testing purposes. We will use Nmap, as we
    did in the previous sections, against the database. The first command we will
    enter is to take advantage of the fact that the database has been set up with
    the default settings, and as such, there is no password on the root account. In
    the terminal window on Kali, enter `nmap -p 3306 --script mysql-empty-password,mysql-databases
    <target>`. An example of the results of this command is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MySQL](img/477-1_11_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, this version of MySQL does not allow the
    connection. This is a change in the default install configuration. We have a couple
    of options. We can attempt enumeration without a password; this probably will
    not get us very far. Additionally, we can set a password and configure the database
    to see what we can discover; however, to save us the time, we will use the metasploitable
    virtual machine. We just need to start the MySQL server. In the metasploitable
    virtual machine terminal window, enter `sudo /etc/init.d/mysql start`. When prompted,
    enter the required password. Return to your Kali machine and enter `nmap -p 3306
    --script mysql-empty-password,mysql-databases <target>`. An example of the output
    of this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MySQL](img/477-1_11_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the MySQL database with an empty password, we can continue
    to explore the different commands within Nmap. In the Kali terminal window, enter
    `nmap -sV --script mysql-empty-password,mysql-databases,mysql-users <target>`
    to enumerate the users from the database. An example of the output from this command
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MySQL](img/477-1_11_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The metasploit tool also has a number of modules for the MySQL database. We
    will not explore them here, as it is very similar to the process we covered when
    we were looking at the MSSQL database. We have covered the process, and as such,
    you are encouraged to explore on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one of the most popular databases that we could run into. The Oracle
    database is used quite extensively from small to large corporations. As such,
    it is more than likely something that we will encounter when testing; therefore,
    we need to take a look at some of the techniques to test it. The product is a
    commercial one, but they do offer an express version that you can use for free.
    You can download it from the Oracle site, but it you are required to register
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There are many references on the Internet that you can use to assist with the
    setup of Oracle to view the one that is put out by Oracle itself; refer to [http://docs.oracle.com/html/B13669_01/toc.htm](http://docs.oracle.com/html/B13669_01/toc.htm).
    Once you have the Oracle box set up, we can try a number of techniques to extract
    information and test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Oracle database after Version 9 has started to protect the information
    in the database. The first thing we need to do is determine the SID of the Oracle
    database. We will attempt this using the metasploit module for it. In the metasploit
    terminal window, enter `use auxiliary/scanner/oracle/sid_enum` to enter the module.
    Once you are in the module, you need to set `RHOSTS` value and then enter `run`.
    An example of the output from this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oracle](img/477-1_11_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, if you encounter an Oracle database that
    is newer than v9, the SID is protected. We can run a brute force attack to determine
    the SIDs. It is also good to note that there are some defaults. When you install
    the Oracle database, you can review the information there and see what the default
    SIDs there are. To attempt to brute force the SIDs, enter `use auxiliary/admin/oracle/sid_brute`
    in the metasploit terminal window to enter the module. Set the RHOST and then
    run the module. An example of the output from the module is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oracle](img/477-1_11_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we now have some SIDs to reference. As the
    installation package that we installed was the Express Edition, it is nice to
    see that there is a default SID of XE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we can do is attempt to brute force the passwords for the database
    accounts. We do this with another module within metasploit. In the metasploit
    window, enter `use auxiliary/scanner/oracle/oracle_login` to enter the module.
    Once you are in the module, you have to set the `RHOSTS` value as well as the
    `RPORTS` value. The default port for Oracle is 1521, so this is the port that
    you will more than likely set. An example of a portion of the output from this
    command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Oracle](img/477-1_11_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have now locked out all of the accounts.
    This is always the danger when attempting to brute force, but at least we did
    it in our test lab and not our client's live database.
  prefs: []
  type: TYPE_NORMAL
- en: OS platform specifics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in this chapter we are looking at servers, we want to look at some of the
    platform characteristics that we can encounter when we are testing servers.
  prefs: []
  type: TYPE_NORMAL
- en: Windows legacy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the older Windows servers, that is, Windows 2000 and Windows Server
    2003\. Even though the Windows 2000 server has been out for many years, it is
    not uncommon to find one when you are testing. This is especially true when you
    are testing **Supervisory Control and Data Acquisition** (**SCADA**) systems.
    It is quite common to see these systems on SCADA networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to determine some of the things we can do against this platform
    is to return to our Exploit DB and conduct a search for vulnerabilities. An example
    of the search results is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows legacy](img/477-1_11_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have some exploits available, but as the
    OS is becoming outdated, we really do not have that many in the database. We can
    search the Internet and look for them as well. The Windows Server 2003 platform
    has had a number of vulnerabilities that we might be able to leverage. We have
    covered a number of methods to do this, so when you encounter any of these machines,
    you can use those techniques to discover potential exploits.
  prefs: []
  type: TYPE_NORMAL
- en: Windows Server 2008 and 2012
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Windows Server 2008 and 2012 servers represent a different approach to security
    for Microsoft and, as such, have proven to be hard targets for the most part,
    especially the 64-bit versions. In fact, at the time of writing this book, the
    available 64-bit exploits were not that many. An example for a search of 64-bit
    exploits in the exploit DB is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows Server 2008 and 2012](img/477-1_11_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, there are only six results returned when we
    search for 64-bit exploits in the Exploit DB. This is a good indication that the
    latest versions of Microsoft are providing a challenge when it comes to writing
    exploit code; therefore, the more common method of compromising these operating
    systems is via a configuration error or an application that is running on the
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Unix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are still some Unix servers that you might encounter when testing, but
    there will not be many exploits when you search for them. This is part of the
    fact that the most targeted platform is Windows, and as such, there are not a
    lot of people who target Unix. Additionally, there are not that many commercial
    Unix providers. There is still **Solaris**, so we can conduct a search for Solaris
    exploits.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the results of this search is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unix](img/477-1_11_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Linux OS has continued to increase in popularity, and with it, the number
    of discovered vulnerabilities has also increased. There are lots of Linux distributions
    today, and there is a chance that you will encounter a variety of them when testing.
    A search of the Exploit DB site is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linux](img/477-1_11_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, there are a number of exploits available for
    2014, so the exploit writers continue to explore the Linux code for weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: MAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common misconception is that there are no exploits for the MAC OS. Well,
    to refute this, we first have to understand that MAC is based on Unix; therefore,
    it has the potential to have similar types of vulnerabilities. A search for the
    exploit DB is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MAC](img/477-1_11_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we do have some exploits available for the
    OS X of the MAC machine. For more information on malware on the MAC platform,
    refer to the following brief from the Blackhat Conference at [https://www.blackhat.com/asia-14/briefings.html#Tsai](https://www.blackhat.com/asia-14/briefings.html#Tsai).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the process of assessing servers. We started off
    the chapter by looking at the common protocols that servers run. We looked at
    the FTP, e-mail, and SSH. We explored ways to extract information from a server
    when it is running these services.
  prefs: []
  type: TYPE_NORMAL
- en: Following the exploration of the common protocols, we continued with a look
    at databases and how we can assess them. We looked at MySQL, MSSQL, and Oracle.
    We discovered that the latest versions of these have more protections in place,
    and as such, it takes some effort to extract information when the database is
    configured with security in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter and looked at different server operating systems
    and information that can be obtained based on the platform that we have discovered.
    The newer the platform we encounter, the bigger the challenge we face with respect
    to testing.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. In the next chapter, we will look at the more common
    vector we have for attacks since the vendors have improved their security, and
    that is the client-side attack vector.
  prefs: []
  type: TYPE_NORMAL
