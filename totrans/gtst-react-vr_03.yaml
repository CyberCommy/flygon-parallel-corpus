- en: 3D or Reality in Dimensions Other than X and Y
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've decided to step into a virtually real world. To understand how to draw
    that world, we'll need to understand exactly how to describe it.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes how we do that in a mathematical sense. Don't worry,
    this is not a return to high–school math! (Well, maybe geometry. OK, so maybe
    a little bit. OK, maybe a lot. I'll try to make it painless.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many different ways to describe the world; it is still the same world
    no matter how we do so. As Shakespeare said in Romeo and Juliet:'
  prefs: []
  type: TYPE_NORMAL
- en: '"What''s in a name? That which we call a rose by any other name would smell
    as sweet."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, interestingly, this is not so: a box described incorrectly will
    look totally different. You need to learn the language. Not only that, you need
    to learn how React VR describes the world, as different 3D graphics programs all
    use different numbers (scaling), directions (vectors), and rotations.'
  prefs: []
  type: TYPE_NORMAL
- en: With virtual worlds, the types of software and hardware all require different
    ways of describing the things you see. For example, coordinates can be left handed
    or right handed. If you mix them up, objects will move in a different direction
    than you had intended them to!
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, up has different meanings in 3D; more specifically, the up direction
    typically is not standard between different 3D programs. In React VR, Y is up.
    Why is Y up?  Read on to learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coordinates: These are fixing points in space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Points: These are building blocks for polygons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Vectors: These are directions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transforms: These are moving things to where you want them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rendering: This turns this discussion of points and transforms into something
    real'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond flatland - 3D concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To represent things in 3D, we have to translate what we see into things that
    the computer can use to generate images. These methods will involve files with
    3D geometry, pictures, and code. First, let's discuss how we position things in
    3D.
  prefs: []
  type: TYPE_NORMAL
- en: To represent objects in 3D, we need their locations. A spreadsheet such as Excel
    uses A-Z (across) and 1-66 down (actually, A-XFD and 1-1048576). Computer graphics
    use numbers for all three axes. However, there are different ways to code these
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: This applies to both the scale (what is one, an inch? One mile?) and what direction
    they go (is it Y or Z that is up?). To figure this out, we need to talk about
    coordinate systems.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're all used to graph paper, grids, glowing spreadsheets with *X* and *Y*
    grids, or, numbers and letters like A1 and B1 in whatever spreadsheet program
    you use. Moving into the third dimension can be confusing, even though that's
    where we live. This is why I called this section *Beyond flatland*.
  prefs: []
  type: TYPE_NORMAL
- en: Math operations we take for granted in two dimensions or general math turn out
    to be just different in three dimensions. For example, if you multiply *X* and
    *Y*, you get the same answer as if you multiplied *Y* and *X*. Yet in three dimensions,
    rotations do not behave that way. To see this in action, try taking both copies
    of this book. (I bought two copies, didn't you? Mom, aren't you reading it?)
  prefs: []
  type: TYPE_NORMAL
- en: OK, seriously, please pick up any two books, real books on paper. If you have
    two Kindles, you could use those.
  prefs: []
  type: TYPE_NORMAL
- en: 'With book number one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Physically flip it (while closed) a quarter turn left to right (toward your
    right hand).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, flip the back edge toward you (flip it over).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now looking at the back page, sideways.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With book number two, flip it in the opposite order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flip the back edge toward you (flip it over).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then rotate it a quarter turn clockwise left to right (toward your right hand).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two books are facing different directions, even though you rotated them
    the same way both times, just in a slightly different order.
  prefs: []
  type: TYPE_NORMAL
- en: Three-dimensional math can be confusing. Normally, if you multiply *A* and *B*,
    you get the same results as if you multiply *B* by *A*.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is very important when it comes to translations, rotations, and
    scaling. Where your objects end up in the world and what they look like is dependent
    on the order you code it in.
  prefs: []
  type: TYPE_NORMAL
- en: We will use three numbers to designate a location for everything in 3D, specifically
    *X*, *Y*, and *Z*.
  prefs: []
  type: TYPE_NORMAL
- en: This is called a **Cartesian coordinate system**. There are other types of coordinate
    systems, but nearly every computer system uses a Cartesian system for spatial
    locations. Rotations and vectors will sometimes use other systems. This is a **Euclidean
    space.**
  prefs: []
  type: TYPE_NORMAL
- en: To make 3D more confusing, some people use *X* and *Y*, with *Z* being the new
    dimension, while others say *Y* is up. Why is (it) up? When dealing with a screen,
    you're used to using *X* and *Y*. A sheet of paper is similar, although paper
    is usually horizontal and a screen is vertical.
  prefs: []
  type: TYPE_NORMAL
- en: This causes an interesting issue of conversion to 3D. In 3D, we use *X*, *Y*,
    and *Z*. If you're used to using *X* and *Y*, then the *Z* has to be the new third
    dimension, and it would be up. If, however, you're used to thinking of *X* and
    *Y* as a piece of graph paper, then *Y* is already up and so *Z* ends up being
    in and out. Each 3D system seems to be slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL, which React VR is based on, uses the familiar *X* and *Y* as right/left
    and up/down; so *Z* has to be in/out. However, one difference is that in React
    VR, *Y* is up; in standard HTML, *Y* is down. In other words, HTML and React use
    a coordinate of (zero by zero) as the upper left-hand corner. Is *Y* is up? Most
    3D programs use *Y* or *Z* as up, meaning in our case positive *Y* is up.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL and HTML are different than React, and may take some getting used to.
    To put an object forward in front of you so you can see it, you'll need to give
    it a negative Z.
  prefs: []
  type: TYPE_NORMAL
- en: In 3D, coordinates can be left handed or right handed. As we've seen with *X*,
    *Y*, and *Z*, sometimes arrows don't go in the direction you'd expect. Why didn't
    React VR (really, it was OpenGL) decide to make Z go in the screen? Then the coordinates
    would be left handed. Instead, most graphics systems use a right handed coordinate
    system.
  prefs: []
  type: TYPE_NORMAL
- en: My brother is left handed.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing wrong with a south paw.
  prefs: []
  type: TYPE_NORMAL
- en: (Actually, he's right handed, but why spoil a good story with the facts?)
  prefs: []
  type: TYPE_NORMAL
- en: 'What in the world does right versus left handed mean? It is a mnemonic that
    helps with the direction of the arrows and with rotations. If you take either
    hand and spread your first three digits out, they spell out the *X*, *Y* and *Z*
    directions. A diagram would help; your first three digits (thumb, index, middle
    finger) point in positive *X*, *Y*, and *Z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/70da68aa-7788-45c8-a787-59a2251ef419.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram, there are a few things to note. The camera represents us on
    the left, looking into the screen (depicted transparently). Because *Y* is up
    (why?) and *X* is to the right, the coordinate system that OpenGL uses isn't similar
    to HTML or to a piece of graph paper, but it is more or less a standard with the
    web.
  prefs: []
  type: TYPE_NORMAL
- en: This was chosen to map more easily to the way that 3D models, **Computer Aided
    Design** (**CAD**), and modeling programs (such as Blender, Maya, 3DSMax) are
    constructed. It is backwards from the way that React works—*Y* is positive going
    down with React. This is a right handed system; if you try to do this with your
    left hand, you get a different order of the *X*, *Y* and *Z* axes.
  prefs: []
  type: TYPE_NORMAL
- en: What about rotations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rotations around any axis with React VR and OpenGL are also right handed. This
    means a positive rotation around any axis will go in the direction the thumb points
    and the fingers curl. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7d08ad11-3632-48f3-bd08-47cfc805800f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Are you looking at your right hand and curling your fingers? It's OK, it helps
    to visualize. Yes, those are arrows showing the positive direction along the respective
    axes.
  prefs: []
  type: TYPE_NORMAL
- en: Honestly, *Y* is up and *Z* is up seem to be pretty commonly mixed in the 3D
    CAD world. Your CAD system may work differently. It's OK, we can flip and invert
    it - just be aware that when importing models, you may find them on their side,
    or even inside out.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, in Blender *Z* is up and *X* and *Y* are in the flat plane; however,
    it can substitute *Y* for up when you export. Why? Because it's on the up and
    up.
  prefs: []
  type: TYPE_NORMAL
- en: These numbers are dimensionless; a cube that is 1 x 1 x 1 can be thought of
    as 1 mile or 1 foot. However, in WebVR and React VR, the units are commonly thought
    of in meters.
  prefs: []
  type: TYPE_NORMAL
- en: Blender can use dimensionless units, metric, or imperial, so you'll need to
    fiddle with scaling when importing things.
  prefs: []
  type: TYPE_NORMAL
- en: The program Poser uses odd units—you will need to scale anything coming from
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'OBJ files, commonly used for importing models, have no unit information; they
    are dimensionless: 1 is 1, not 1 meter.'
  prefs: []
  type: TYPE_NORMAL
- en: Points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Points refer to 3D locations in space, generally identified via *X*, *Y*, and
    *Z* locations. A point is rarely described directly in React VR, unless you are
    doing native rendering, but locations in space are frequently described as points.
    For example, a transform node may say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The center of the object that the transform is applied to will be at the location
    *X*=0, *Y*=400,  *Z*=700.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vectors refer to a direction. In Aviation, pilots talk about vectors. From the
    scene in the movie *Airplane*, Clarence Oveur, Roger Murdock, Victor Basta, and
    the control tower discuss heading:  ([http://bit.ly/WhatsOurVector](http://bit.ly/WhatsOurVector))
  prefs: []
  type: TYPE_NORMAL
- en: '"Roger Murdock: Flight 2-0-9''er, you are cleared for take-off.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Captain Oveur: Roger!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roger Murdock: Huh?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tower voice: L.A. departure frequency, 123 point 9''er.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Captain Oveur: Roger!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roger Murdock: Huh?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Victor Basta: Request vector, over.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Captain Oveur: What?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tower voice: Flight 2-0-9''er cleared for vector 324.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roger Murdock: We have clearance, Clarence.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Captain Oveur: Roger, Roger. What''s our vector, Victor?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tower voice: Tower''s radio clearance, over!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Captain Oveur: That''s Clarence Oveur. Over."'
  prefs: []
  type: TYPE_NORMAL
- en: From our standpoint as VR people, they really mean heading. In 3D space, you
    can also be aimed up or down. All three directions are very important to us.
  prefs: []
  type: TYPE_NORMAL
- en: Translations, properly speaking, use vectors; if you give a transform property
    to an object of [0, 2, 0], you are telling the object to move *2* units in the
    *+Y* direction, not necessarily to an absolute position of 0,2,0\. However, note
    that if the object's origin is at 0,0,0, then it is the same. It is important
    to consider the origin of your 3D objects when translating them, and whether objects
    take absolute or relative positioning.
  prefs: []
  type: TYPE_NORMAL
- en: Transforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not a book about bizarre foldable robots, so we are talking about transforms,
    not Transformers.
  prefs: []
  type: TYPE_NORMAL
- en: Transforms are ways to place, position, move, and scale objects, essentially,
    anything that transforms the *X*, *Y*, *Z* coordinates of an object, point, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In React VR, transforms are usually part of a style. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Transform order is very important. As we discussed earlier, in 3D, transforms
    are not transitive—if you translate, then rotate, you end up in a different spot
    than if you rotate, then translate. Remember the book example?
  prefs: []
  type: TYPE_NORMAL
- en: In React VR, the Transform is a standard props node for most objects that have
    a physical presence. (See Appendix and Chapter 4, *The React VR Library*.)
  prefs: []
  type: TYPE_NORMAL
- en: Transforms take really three main arguments (and a number of deprecated props);
    a transform, or matrix arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, I said the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f12b10ac-92c1-40c0-9af8-a8e99912e12d.png)'
  prefs: []
  type: TYPE_IMG
- en: A matrix has always been a mathematical concept for quite some time. It also
    made a great movie. Due to copyright restrictions, I can't include a picture of
    the matrix here, but above is my representation of our VR controller scene viewed
    in the matrix. In any event, I don't mean the movie. We will use the matrix to
    create 3D scenes of our own.
  prefs: []
  type: TYPE_NORMAL
- en: A matrix is a mathematical way to describe translation (vectors), rotations,
    scaling, and skewing. Some of my friends get skewed on the weekends, but skewing
    is a mathematical term meaning to shift, say, the top of an object more than the
    bottom. You might think of it as tilted.
  prefs: []
  type: TYPE_NORMAL
- en: To fully understand matrices, let's talk about the non-Keanu Reeves way of doing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anytime there is a physical object, such as a box, a model, a light, or a VR
    button, you have various style props, one of which is a transform. A transform
    node can use matrices, or, a little easier sometimes, direct translation properties.
    For example, if you define a `Cylinder` in React VR, you might transform it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Transform order is important. Here is an example of three cylinders, identical
    except for their color and transforms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the resulting React VR world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a28d4478-ef65-41b7-82b7-8f6a0d669186.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What about the matrix?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A matrix is a four column by four row series (array) of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a `matrix` in the transform node as well. A complete discussion
    of matrix math is beyond the scope of this book. There are plenty of reference
    materials on the web. The basic concept is fairly straightforward, but rotations
    can be a bit difficult (although deterministic) to program free-hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Translations are stored as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Scaling is represented by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotations can be represented by the R values in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Rotations via matrix math are very precise, but also very complicated. As we
    saw earlier, the order of rotations will change the location of the resulting
    object. A matrix does not have these problems as the order is baked into the matrix
    itself. Calculating the rotations can be messy.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, you'll want to use the transform styles instead of the matrix
    math, when moving an object by hand (manual coding).
  prefs: []
  type: TYPE_NORMAL
- en: You'll want to use matrices when copying an object's position and orientation
    or programmatically moving it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `matrix` that scales all axes by one tenth and translates by [3, 2, 1] can
    be applied as a `matrix` as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You cannot use a transform matrix and a transform style (separate translate,
    rotate, scale) at the same time. There is really no need to, as you can do everything
    with a matrix you would do by specifying individual transformations. If you do
    use a matrix, you're pretty hardcore! In any event, any transforms that you create
    will be converted to a matrix behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome to the matrix - now you can create it.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bing defines rendering as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/862749ff-cd38-427a-9b98-edee837df825.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, that was fun, but is obviously not what we mean. Rendering refers to taking
    all of the mathematical description we've been discussing and making something
    visual out of it.
  prefs: []
  type: TYPE_NORMAL
- en: The rendering engine used with React VR is three.js ([http://bit.ly/2wHI8S9](http://bit.ly/2wHI8S9)),
    which normally uses WebGL for rendering ([http://bit.ly/2wKoKCe](http://bit.ly/2wKoKCe)).
    WebGL is a robust JavaScript API for generating high performance graphics. It
    will use any high performance graphics hardware (GPU) in your system, and is native
    in most browsers, allowing 3D graphics without requiring plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, however, the web can be a wild place. You would think browser manufacturers
    would have learned from the compatibility problems of 20 years ago, but sadly
    this is not the case. There may be wrinkles or issues with some browsers, especially
    on mobile.
  prefs: []
  type: TYPE_NORMAL
- en: Can't we all just get along?
  prefs: []
  type: TYPE_NORMAL
- en: This will affect how well React VR works. If you want to see whether your browser
    and hardware support WebGL, go to the WebGL test page at [http://bit.ly/WebGLTestPage](http://bit.ly/WebGLTestPage).
    The page will display a spinning cube; it may also display some warnings if you
    use a browser that is not one hundred percent compatible. The WebGL Wikipedia
    page ([http://bit.ly/2wKoKCe](http://bit.ly/2wKoKCe)) has a good description of
    which browsers do what, but things change.
  prefs: []
  type: TYPE_NORMAL
- en: You need to test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing how it looks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In World War II, the Marines tested amphibious landings extensively before the
    War in the Pacific. They had tactics and strategy down.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first landing they did, they hit coral reefs. There are no coral reefs
    in San Diego/Camp Pendleton. As a result, although it was a successful landing,
    it was a bit more calamitous than they thought it would be. As a result, the Marine
    Corps has a saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Train as you would fight."'
  prefs: []
  type: TYPE_NORMAL
- en: 'This has apparently been a long–standing saying. The Roman Legion used to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Training should be a bloodless battle, so that in battle, it will be just
    like bloody training." -Roman Legion Training Maxim'
  prefs: []
  type: TYPE_NORMAL
- en: If you get used to using Firefox, send your React VR solution out into the world,
    and your Aunt Petunia uses the Orchestra browser to view your world, it may not
    work, and Aunt Petunia will still think you're that shiftless spawn of her aimless
    sibling. Note that Orchestra isn't a real browser as far as I know, although I
    use Opera.
  prefs: []
  type: TYPE_NORMAL
- en: If this is an internal company-only app, and you have a standard (and can enforce
    it!) of only one browser, then you can test and develop with that browser.
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you want a wide number of people to use your React VR app, you
    really should test with a variety of browsers. If you have a Mac, a PC, and a
    Linux machine, so much the better. These can be virtual machines (especially Windows,
    with the appropriate license, and Linux), otherwise you need beta testers.
  prefs: []
  type: TYPE_NORMAL
- en: You need to test it like you expect people to use it, otherwise you'll think
    it works fine but people will not be happy with your virtual world. You'll need
    to test with as many browsers and hardware platforms as you can. Of course, this
    is not really practical, but it is necessary. This is where beta testers can come
    in handy.
  prefs: []
  type: TYPE_NORMAL
- en: How rendering works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We were talking about rendering. This is the process of taking the mathematical
    model, with the attributes expressed, and turning it into something you can see
    on your screen.
  prefs: []
  type: TYPE_NORMAL
- en: To render your models in VR, React VR uses WebGL, which is based on OpenGL.
    WebGL is a JavaScript implementation and should, generally, look the same on most
    platforms if they have a fairly functional implementation in the browser. If you
    describe an upright red arrow, then in all browsers it will look like an arrow
    pointing up. The advice about testing is generally to make sure that it works
    at all, not so much to make sure an up arrow will not suddenly point to the right.
  prefs: []
  type: TYPE_NORMAL
- en: In the game industry, people usually have to make a decision between DirectX
    and OpenGL. WebVR uses neither, although WebGL is based on the design of OpenGL.
    Unlike OpenGL, it also includes HTML elements such as HTML5 canvas and DOM (Document
    Object Model). If you are using WebVR, you are using WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: If a browser you are testing doesn't show your scene right, but does in other
    browsers, *please* file a bug report. Many of these applications are, like most
    cool things on the internet, bleeding edge.
  prefs: []
  type: TYPE_NORMAL
- en: You want these bugs fixed — so tell people. Programmers can't fix what they
    don't know about. You'll be contributing to a saner, cleaner, more effective web.
  prefs: []
  type: TYPE_NORMAL
- en: Be part of the solution!
  prefs: []
  type: TYPE_NORMAL
- en: WebGL will generally use your high performance GPU, through either OpenGL or
    through DirectX. You don't need to worry about, nor are you able to control, what
    React VR uses (unless going native), although this is an advantage. The web browser
    will generally do the right thing and use any hardware available on either mobile
    (phones, tablets), laptop, or desktop machine.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to control rendering more precisely? That is possible with
    React VR Native, which we will cover in more detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned the important ways to describe our VR world. If
    you want to think about it this way, we're learning the language of the matrix,
    and it even involves matrices. We learned about 3D coordinates, points, vectors,
    right-and left-handed worlds, and transforms.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how all of these concepts come together and are rendered, and how
    the different web pages take that information and create a visual space out of
    it. We also learned to test!
  prefs: []
  type: TYPE_NORMAL
- en: To be able to test, we need something in the browser. To do that, we need to
    know not only how to describe the world in terms of numbers and rotations, but
    also how these numbers are used in building blocks. The next section will cover
    the keywords, components, and objects that React VR uses to describe the world.
  prefs: []
  type: TYPE_NORMAL
