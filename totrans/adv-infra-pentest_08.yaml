- en: VLAN Exploitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Switches are vital components in any modern network. This chapter will take
    you through a learning experience in which we will discover how to perform layer
    2 attacks on the one hand, and how to defend against them on the other hand. It
    is necessary to know how to secure layer 2 because network security is only as
    strong as your weakest layer. In our case, the weakest layer is layer 2\. Compromising
    it could lead to compromising the other layers in the stack. In this chapter,
    we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Switching basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MAC attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic Host Configuration Protocol** (**DHCP**) attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Virtual LAN** (**VLAN**) attacks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching in networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Switches are data link layer (layer 2 in the OSI model) devices. Their main
    goal is connecting networking devices by receiving switching packets and forwarding
    them to the destination devices. Switching is an efficient solution for connecting
    devices, though it is not practical if we want to connect a large number of end-system
    devices (computers, phones, and so on) and nodes. A node is an entity that carries
    information from a source to a destination without modifying information or data;
    a set of nodes is called a communication network, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00242.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'In switching, there are three different techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Circuit switching**: This is a fixed channel between the sender and the receiver,
    and the dedicated channel is called a **circuit**. Once a connection is established,
    no other devices can use the channel, even if the circuit is not fully used until
    the connection is determined. This type of switching is widely used in telephone
    networks. During circuit switching, we have the following three steps: channel
    establishment, data transfer, and connection determination. There are two types
    of circuit switching:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frequency division multiplexing (FDM)**: Multiplexing is the process of combining
    many signals into one signal. FDM is an operation where channels are divided without
    frequency overlapping. The following diagram illustrates the FDM process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00243.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**Time division multiplexing (TDM)**: This is another multiplexing operation,
    but it uses time periods instead of frequencies. This operation is more flexible
    and efficient than FDM, and is illustrated here:'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00244.gif)'
  prefs: []
  type: TYPE_IMG
- en: '**Packet switching**: During this switching technique, data is switched and
    forwarded in a specific format called a **packet**. A packet is composed of the
    following elements, shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data**: Transferred information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header**: This contains the address of the destination'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trailer** **(optional)**: In general, this contains some information to indicate
    that it is the end of the packet; sometimes, it is used for error checking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00245.gif)'
  prefs: []
  type: TYPE_IMG
- en: In a transmission, packets from different end-systems will multiplex; packets
    are also called **datagrams**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Message switching: **This is sometimes called store-and-forward switching.
    In this technique, all the end-systems receive the message, store it, and forward
    it to the next device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LAN switching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The access method used in LANs is an Ethernet connection based on the IEEE 802.3
    standard. We have different types based on the connection bandwidth (10 Mbps (Ethernet),
    100 Mbps (fast Ethernet), or 1,000 Mbps (gigabit Ethernet)). Ethernet gives you
    the opportunity to choose from different Ethernet-transmission physical devices,
    such as twisted pair and fiber optics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm used to block devices from sending information at the same time
    is called **Carrier Sense Multiple Access/Collision Detect** (**CSMA/CD**). As
    you can see from the graph shown below two hosts cannot send information at the
    same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00246.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In an Ethernet connection, the traffic of data is determined by **Media Access
    Control** (**MAC**) addresses. This address is a unique 48-bit serial number.
    It is composed equally of the **Organizational Unique Identifier** (**OUI**) and
    the vendor-assigned address, as shown here. It is represented in hexadecimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00247.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Transmission in layer 2 can be categorized into three main data transmission
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicast**: This is a transmission mode from a specific network device to
    another specific device. In other words, it is a one-to-one transmission mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multicast**: In a multicast operation, a single device sends data to multiple
    networking devices. It is a one-to-many transmission mode where a device sends
    data to a specific group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast**: This transmission mode is like multicast, but in a broadcast
    operation, a network device sends data to all the other devices. In broadcast,
    a device uses an `FF-FF-FF-FF-FF-FF` MAC address (the highest possible MAC address).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the difference between the three transmission
    modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00248.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In LAN switching, we have the following three techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Store-and-forward switching**: In store-and-forward switching, mode switches
    store all the frames in memory and check for errors, after calculating the **cyclic
    redundancy check** (**CRC**). If there is an error based on the number of bits
    in a frame, the frame will be rejected, otherwise it will be forwarded, as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00249.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Cut-through switching**: In cut-through switching, mode switches store only
    destination MAC addresses and compare them with its MAC table. This technique
    is faster than the previous technique because it deals with only the first 6 bytes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00250.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Fragment-free switching**: This switching technique combines the two previous
    switching modes. It is a hybrid switching technique. It is like cut-through switching,
    but instead of checking the first 6 bytes, it checks the first 64 bytes because
    to detect collision, we need to check the first 64 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MAC attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MAC addresses are unique identifiers with two assigned parts—the OUI is assigned
    by IEEE, and the second 24 bits are assigned by the manufacturer. These addresses
    are stored in a table called the **Content Addressable Memory** (**CAM**). This
    table has a fixed size. The CAM stores information about MAC addresses after operating,
    as the following graph illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00251.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, initially, the CAM contains two addresses with their port information.
    To send traffic from **Host A** to **Host B**, information about **Host B** should
    be included in the CAM table but this is not the case in this demonstration. Thus
    **Host A** sends an ARP request to all hosts. The hosts send back information
    about their MAC addresses and ports. Now **Host A** has information about **Host
    B** and stores it in the CAM table, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00252.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the CAM table contains all the required information about the hosts,
    including the destination host. So, the traffic from **Host A** to **Host B**
    should operate normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00253.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Attackers can exploit the CAM table to perform malicious activities. An attack
    called CAM overflow can be carried out. In other words, attackers overflow the
    CAM tables by exploiting the maximum limit of the CAM table size. There are many
    tools available, one of which is **macof**. Let''s suppose that the CAM table
    is full with all the information. An attacker can flood switches using macof by
    sending random source MAC addresses (up to 155,000 MAC entries per minute):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00254.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Or simply, you can use `macof -i eth1 2> /dev/null`. To defend against MAC
    flooding, you need to limit the number of MAC addresses on an interface using
    port security as shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00255.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Media Access Control Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To protect your network from data link layer attacks and provide total Ethernet
    links security, you can use **Media Access Control Security** (**MACsec**), which
    is based on an 802.1 AE standard. MACsec is like IPsec in the network layer, it
    provides integrity and confidentiality protection using a hop-by-hop encryption
    (GCM-AES-128) with the use of a **MACsec Key Agreement** (**MKA**) between the
    network nodes. Thus, it encrypts all the Ethernet packets but without touching
    the source and destination MAC addresses. MACsec in switch-to-switch mode is not
    the same with switch-to-host mode. The first is named downlink MACsec, where the
    host goes through the 802.1x authentication process. The second is named uplink
    MACsec. It is manually configured on switches, or configured dynamically with
    a remote RADIUS server. The following graph shows that the communication is encrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00256.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: DHCP attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DHCP is a network layer protocol based on RFC 2131 that enables assigning IP
    addresses dynamically to hosts. The following four required steps to assign an
    IP address to a specific host:'
  prefs: []
  type: TYPE_NORMAL
- en: DHCP discover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHCP offer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHCP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHCP acknowledgment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00257.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: DHCP starvation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are discussing layer 2 attacks; I bet you are wondering
    why we talked about a network layer protocol (DHCP in our case). The answer is
    easy. Attackers can perform what we call DHCP starvation. An attacker broadcasts
    DHCP requests with spoofed MAC addresses; this attack exploits the DHCP servers 
    address space. This attack can be done using a simple tools, such as *the gobbler.*
  prefs: []
  type: TYPE_NORMAL
- en: Rogue DHCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A rogue DHCP server (this can be a home router or a modem) is a server implemented
    by an attacker in a network to perform man-in-the-middle attacks, or sniffing
    the network traffic. This implementation of a rogue server lets the attacker gather
    a great deal of information, including DNS server information and the default
    gateway. To defend against DHCP attacks, you need to use DHCP snooping, which
    is a switch feature to identify ports that respond to DHCP requests.
  prefs: []
  type: TYPE_NORMAL
- en: ARP attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Address Resolution Protocol** (**ARP**) is a protocol that maps the IP addresses
    with their associated MAC addresses, based on the RFC 826 standard. ARP is implemented
    in many operating systems, including Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check it using the `arp` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00258.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Attackers can exploit its cache to perform man-in-the-middle attacks using
    a tool such as Ettercap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00259.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are already using Kali Linux, you can also use the `dsniff` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00260.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Attackers can use the IP/MAC matching capability of the ARP protocol to map
    their MAC addresses with legitimate IP addresses. If you are using Kali Linux,
    you can use it directly from the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: To defend against ARP attacks, it is better to use dynamic ARP inspection by
    checking whether the packets match the binding table entries, otherwise packets
    will be dropped; but first you need to configure DHCP snooping.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the normal ARP operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00261.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an illustration of an ARP spoofing attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: VLAN attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VLAN is a logical grouping of networking devices in the same broadcast domain.
    This logical separation is very beneficial in many cases. For example, if we have
    different geological locations, using VLANS could be a great way to group networking
    devices, even if they are in different places, but they act like one broadcast
    domain. This diagram illustrates a classic switching architecture; there is a
    specific switch for every specific enterprise department:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00263.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram illustrates the beneficial results of implementing VLANs.
    We can configure a switch for many different departments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Switching operations occur in layer 2, but when we use VLANs, we need a router
    (layer 3) to make VLANs communicate with each other via an operation named **interVLAN
    routing**. VLAN trunking is needed to interconnect switches by tagging each frame
    with a VLAN ID, which is a number between 0 and 4095, to identify the VLAN. Here,
    the trunking negotiation is used, thanks to the **Dynamic Trunk Protocol** (**DTP**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: VLAN implementation is possible when the switches and routers support VLANs.
    It means, they support trunking protocols such as **Inter-Switch Link** (**ISL**),
    which is a Cisco proprietary, and IEEE 802.1q. If a switch supports trunking,
    it is called a **managed switch**.
  prefs: []
  type: TYPE_NORMAL
- en: Types of VLANs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many types of VLANs. Two of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Native VLAN or untagged VLAN**: If a host sends traffic to a switch port
    without a specified VLAN ID, then the traffic will be assigned the untagged VLAN'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tagged VLAN**: This is used when a packet is tagged with a VLAN ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VLAN configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure VLANs on a switch, you need to follow this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00266.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'First VLAN:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Second VLAN:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign ports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: VLAN hopping attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'VLAN hopping attacks are based on DTP. The main role of DTP is automating an
    802.1q or ISL trunk configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Switch spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During this attack, an attacker mimics a switch by emulating ISL or 802.1q and
    signaling with DTP. Thus, it looks like a switch with a trunking port, so it will
    have access to all the VLANs.
  prefs: []
  type: TYPE_NORMAL
- en: VLAN double tagging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This attack is sometimes called a double 802.1q encapsulation attack, which
    is done by sending 802.1q double encapsulated frames. In general, switches only
    perform one decapsulation operation at a time. Thus, they will strip off the first
    and send back out the second. This attack is possible, only if the attack and
    the target are on the same VLAN, even if trunk ports are off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Private VLAN attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in the previous sections that a VLAN divides a LAN into broadcast domains.
    **Private VLANs** (**PVLAN**) are also subdomains of VLANs, and there are isolated
    subdomains, such as sub-VLANs.
  prefs: []
  type: TYPE_NORMAL
- en: 'VLANs require a layer 3 device, such as a router, to communicate with each
    other, PVLANs also require routers to communicate, but the hosts are still in
    the same IP subnet. We have three PVLAN ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Promiscuous (P)**: Connected to a router'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolated (I)**: Connected to hosts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Community (C)**: Connected to other community ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Attackers can attack PVLANs by sending frames with their IP and MAC addresses
    and the destination IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Spanning Tree Protocol attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Spanning Tree Protocol** (**STP**) was developed by Radia Perlman in
    1985 to solve the problem of Ethernet loops, but before diving into STPs, let''s
    go back to the root causes of this issue. If a broadcast storm occurs, you will
    lose your network availability. This happens when we have an Ethernet loop. As
    simple example, in the following diagram, we have three connected switches. If
    a switch sends a broadcast to the other two switches, they will receive and rebroadcast
    it by forwarding it through all ports because they couldn''t find the address.
    Also, they will go for a repeating loop called a **broadcast storm**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This way, the STP appeared to solve this networking issue by blocking the redundant
    paths, thanks to the **Spanning Tree Algorithm** (**STA**) based on the IEEE 802.1d
    standard, which makes sure that only one path is available between two stations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'But which ports do you block when using STP? In STP, there are five types of ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Learning port**: This port learns the MAC addresses but does not forward
    the frames'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Listening port**: This port doesn''t learn MAC addresses or forward them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Discarding port**: This port doesn''t forward data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forwarding port**: This port learns MAC addresses and forwards data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled port**: This port is self-explanatory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following workflow describes the stages of ports in STP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00272.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'STP performs the following three steps in order to achieve its goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root bridge election**: Switches are not very smart devices. So by default,
    each switch in the network claims to be the root bridge, which is the main switch
    that controls the topology. To select a root bridge, all switches send their **b****ridge
    ID** (**BID**), which is 8 bytes combined between a bridge priority and a MAC
    address; by default, it is 32,768\. The switch with the minimum BID gets selected
    as a root bridge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selecting a root port**: This selection is based on a simple selection criteria,
    which is the lowest-cost **Bridge Protocol Data Units **(**BPDU**). So, the port
    that receives the lowest BPDU will be a root port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selecting designated ports**: Designated ports are the other switch ports
    (blocked).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking STP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An attacker can exploit STP to attack a network. One of the hacking techniques
    is to implement a rogue switch at trunk ports, and manipulate the spanning tree
    priority by configuring this rogue switch and giving it the lowest ID to become
    a root bridge. As a consequence, all the traffic will be transferred through this
    switch and then it will sniff all the traffic or redirect the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To defend against STP attacks, you need to enable the root guard on all switch
    ports that you don''t designate as root ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a useful explanation of how to compromise networks by exploiting
    layer 2 weaknesses. The next chapter will be an in-depth learning experience that
    explains how to exploit Voice over IP systems.
  prefs: []
  type: TYPE_NORMAL
