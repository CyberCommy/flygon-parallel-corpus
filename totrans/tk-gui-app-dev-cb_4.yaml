- en: Dialogs and Menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Showing alert dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asking for user confirmation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data into a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a menu bar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables in menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying context menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a secondary window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing variables between windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling window deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost every nontrivial GUI application is composed of multiple views. In browsers,
    this is achieved by navigating from one HTML page to another, and in desktop applications,
    it is represented by multiple windows and dialogs that users can interact with.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned how to create only a root window, which is associated
    with the Tcl interpreter. However, Tkinter allows us to create multiple top-level
    windows under the same application, and it also includes specific modules with
    built-in dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to structure how to navigate in your application is using menus,
    which are usually displayed under the title bar in desktop applications. In Tkinter,
    these menus are represented by a widget class; we will dive later into its methods
    and how to integrate it with the rest of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Showing alert dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common use case for dialogs is notifying users of events that occurred in
    our application, such as that a record has been saved, or that it failed to open
    a file. We will now take a look at some of the basic functions included in Tkinter
    to display informational dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our program will have three buttons, where each one illustrates a different
    dialog with a static title and message. This type of dialog boxes have only a
    button to confirm and close the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/6bf8de6b-3907-4221-9ea0-3fc4a4fabd9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you run the preceding example, note that each dialog plays the corresponding
    sound defined by your platform, and the button label is translated to your language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/55c3bc6c-eb7e-4198-8f1a-4ee12827f024.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three dialogs mentioned in the preceding *Getting ready* section are opened
    with the `showinfo`, `showwarning`, and `showerror` functions from the `tkinter.messagebox` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we imported the `tkinter.messagebox` module with the shorter alias `mb`.
    This module was named `tkMessageBox` in Python 2, so this syntax also helps us
    to isolate compatibility issues in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each dialog is commonly used depending on the type of information that is notified
    to the users:'
  prefs: []
  type: TYPE_NORMAL
- en: '`showinfo`: The operation completed successfully'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`showwarning`: The operation completed but something did not behave as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`showerror`: The operation failed due to an error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three functions receive two strings as input arguments: the first one
    is displayed on the title bar, and the second one corresponds to the message shown
    by the dialog.'
  prefs: []
  type: TYPE_NORMAL
- en: Dialog messages can also spawn across multiple lines by adding the new line
    character, `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: Asking for user confirmation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other types of dialogs included in Tkinter are those used to ask for user confirmation,
    such as the ones shown when we want to save a file and are about to override an
    existing one with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: These dialogs differ from the preceding one because the values returned by the
    functions will depend on the confirmation button clicked by the user. This way,
    we can interact with the program to indicate whether to continue or cancel the
    action.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will cover the remaining dialog functions defined in the
    `tkinter.messagebox` module. Each button is labeled with the type of dialog that
    is opened when clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/fdcf033f-5f95-4a30-80e5-775993a13713.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since there are a few differences among these dialogs, you can try them out
    to see which one may better fit your needs for each situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/58981fea-4262-4b93-b599-d6baf00fe9f4.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did in our preceding example, we will import `tkinter.messagebox` with
    the `import ... as` syntax and call each function with `title` and `message`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To avoid repeating the code for the button instantiation and the callback method,
    we defined a `create_button` method to reuse it as many times as we need to add
    all the buttons with their dialogs. The commands simply print the result of the
    `dialog` function passed as a parameter so that we can see the values returned,
    depending on the button clicked, to answer the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File dialogs allow users to select one or multiple files from the filesystem.
    In Tkinter, these functions are declared in the `tkinter.filedialog` module, which
    also includes dialogs for choosing directories. It also lets you customize the
    behavior of a new dialog, such as filtering the files by their extension or choosing
    the initial directory displayed by the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application will contain two buttons. The first will be labeled Choose
    file, and it will display a dialog to select a file. By default, it will only
    show files with the `.txt` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/7f9c5028-420b-4ff0-b74b-840a8521687a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The second button will be Choose directory, and it will open a similar dialog
    to select a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/04091bd1-b45c-4a74-8168-0cc0eca082a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Both buttons will print the full path to the selected file or directory, and
    will not perform any action if the dialog is canceled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first button of our application will trigger a call to the `askopenfilename`
    function, whereas the second one will call the `askdirectory` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Since these dialogs can be dismissed, we added conditional statements to check
    whether the dialog function returns a non-empty string before printing it into
    the console. We would need this validation in any application that must perform
    an action with this path, such as reading or copying files, or changing permissions.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We create the first dialog with the `askopenfilename` function, which returns
    a string that represents the full path to the chosen file. It accepts the following
    optional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: Title displayed in the dialog''s title bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialdir`: Initial directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filetypes`: Sequence of tuples of two strings. The first one is a label indicating
    the type of the file in a human-readable format, whereas the second one is a pattern
    to match the filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiple`: Boolean value to indicate whether users may select multiple files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultextension`: Extension added to the filename if it is not explicitly
    given.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, we set the initial directory to the root folder and a custom
    title. In our tuple of file types, we have the following three valid choices:
    text files saved with the `.txt` extension; images with the `.jpg`, `.gif`, and
    `.png` extensions; and the wildcard (`"*"`) to match all files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that these patterns do not necessarily match the format of the data contained
    in the file since it is possible to rename a file with a different extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `askdirectory` function also takes the `title` and `initialdir` parameters,
    and a `mustexist` Boolean option to indicate whether users have to pick an existing
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `tkinter.filedialog` module includes some variations of these functions
    that allow you to directly retrieve the file objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `askopenfile` returns the file object corresponding to the selected
    file, instead of having to call `open` with the path returned by `askopenfilename`.
    We still have to check whether the dialog has not been dismissed before calling
    the file methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Saving data into a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from selecting existing files and directories, it is also possible to
    create a new file using Tkinter dialogs. They can be used to persist data generated
    by our application, letting users choose the name and location of the new file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the Save file dialog to write the contents of a Text widget into
    a plain text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/1d7858dc-1a91-4591-8f72-08ee9d0c6f1d.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To open a dialog to save a file, we call the `asksaveasfile` function from
    the `tkinter.filedialog` module. It internally creates a file object with the
    `''w''` mode for writing, or `None` if the dialog is dismissed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `asksaveasfile` function accepts the same optional parameters as the `askopenfile`
    function, but also allows you to add the file extension by default with the `defaultextension` option.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent users from accidentally overriding previous files, this dialog automatically
    warns you if you try to save a new file with the same name as an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the file object, we can write the contents of the Text widget—always remember
    to close the file to free the resources taken by the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding recipe, we saw that there is a function equivalent to `askopenfilename`
    that returns a file object instead of a string, named `askopenfile`.
  prefs: []
  type: TYPE_NORMAL
- en: To save files, there is also a `asksaveasfilename` function that returns the
    path of the selected file. You can use this function if you want to modify the
    path or perform any validation before opening the file for writing.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Choosing files and directories* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a menu bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex GUIs typically use menu bars to organize the actions and navigations
    that are available in our application. This pattern is also used to group operations
    that are closely related, such as the File menu included in most text editors.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter natively supports these menus, which are displayed with the look and
    feel of the target desktop environment. Therefore, you do not have to simulate
    them with frames or labels, because you would lose the cross-platform features
    that have already been built into Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by adding a menu bar to a root window with a nested drop-down
    menu. On Windows 10, this is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/42b9c97d-a199-40bb-8c16-7be46d4ec632.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tkinter has a `Menu` widget class that can be used for many kinds of menus,
    including top menu bars. As any other widget classes, menus are instantiated with
    the parent container as the first argument and some optional configuration options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you run the preceding script, you can see that the `File` entry shows the
    secondary menu, and you can close the application by clicking the `Quit` menu
    button.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we instantiate each menu, indicating the parent container. The `tearoff`
    option, set to `1` by default, indicates that the menu can be detached by clicking
    on the dashed line of its top border. This behavior is not applied to the top
    menu bar, but if we want to deactivate this functionality, we have to set this
    option to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Menu entries are arranged in the same order that they are added, using the
    `add_command`, `add_separator`, and `add_cascade` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Usually, `add_command` is called with a `command` option, which is the callback
    invoked when the entry is clicked. There are no arguments passed to the callback
    function, exactly as with the `command` option of the Button widget.
  prefs: []
  type: TYPE_NORMAL
- en: For illustration purposes, we only added this option to the `Quit` entry to
    destroy the `Tk` instance and close the application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we attach the menu to the top-level window by calling `self.config(menu=menu)`.
    Note that each top-level window can only have a single menu bar configured.
  prefs: []
  type: TYPE_NORMAL
- en: Using variables in menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from calling commands and nesting submenus, it is also possible to connect
    Tkinter variables to menu entries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add a check button entry and three radio button entries to the Options submenu,
    divided by a separator. There will be two underlying Tkinter variables to store
    the selected values, so we can retrieve them easily from other methods of our
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/d882404a-5f1c-428e-b30d-784413ff31e6.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These types of entries are added with the `add_checkbutton` and `add_radiobutton`
    methods of the `Menu` widget class. Like with regular radio buttons, all are connected
    to the same Tkinter variable, but each one sets a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, we are tracing the variable changes so you can see the values
    printed on the console when you run this application.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To connect a Boolean variable to the `Checkbutton` entry, we first define `BooleanVar` and
    then create the entry by calling `add_checkbutton` using the `variable` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the `onvalue` and `offvalue` options should match the type of
    the Tkinter variable, as we do with regular RadioButton and CheckButton widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Radiobutton` entries are created in a similar fashion using the `add_radiobutton`
    method, and only a single `value` option to set to the Tkinter variable when the
    radio is clicked. Since `StringVar` initially holds the empty string value, we
    set it to the first radio value so that it will display as checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Both variables trace the changes with the `mark_checked` and `mark_radio` methods,
    which simply print the variable values into the console.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying context menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter menus do not necessarily have to be located on the menu bar, but they
    can actually be freely placed at any coordinate. These types of menus are called
    context menus, and they are usually displayed when users right-click on an item.
  prefs: []
  type: TYPE_NORMAL
- en: Context menus are widely used in GUI applications; for instance, file browsers
    display them to offer the available operations over the selected file, so it is
    intuitive for users to know how to interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build a context menu for a Text widget to display some common actions
    of text editors, such as Cut, Copy, Paste, and Delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/c344d057-cdb3-4c33-9a5c-1cc2ecf55991.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of configuring a menu instance with a top-level container as a top menu
    bar, you can explicitly place it using its `post` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the commands in the menu entries call a method that uses the text instance
    to retrieve the current selection or the insertion position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We bind the right-click event to the `show_popup` handler for the text instance,
    which displays the menu with its top-left corner over the clicked position. Each
    time this event is triggered, the same menu instance is displayed again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following methods are available for all widget classes to interact with
    the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clipboard_clear()`: Clears the data from the clipboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clipboard_append(string)`: Appends a string to the clipboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clipboard_get()`: Returns the data from the clipboard'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The callback method for the *copy* action gets the current selection and adds
    it to the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The *paste* action inserts the clipboard contents into the insertion cursor
    position, defined by the `INSERT` index. We have to wrap this in a `try...except`
    block, since calling `clipboard_get` raises a `TclError` if the clipboard is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The *delete* action does not interact with the clipboard, but removes the contents
    of the current selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Since the cut action is a combination of copy and delete, we reused these methods
    to compose its callback function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `postcommand` option allows you to reconfigure a menu each time it is displayed
    with the `post` method. To illustrate how to use this option, we will disable
    the cut, copy, and delete entries if there is no current selection in the Text
    widget and disable the paste entry if there are no contents in the clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the rest of our callback functions, we pass a reference to a method of
    our class to add this configuration option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we check whether the `SEL` range exists to determine whether the state
    of the entries should be `ACTIVE` or `DISABLED`. This value is passed to the `entryconfig` method,
    which takes the index of the entry to configure as its first argument, and the
    list of options to be updated—remember that menu entries are `0` indexed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, all the entries should be grayed out if there is no selection
    or if there are no contents on the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/f731180c-8a40-4ad9-a552-df57e3a48a4b.png)'
  prefs: []
  type: TYPE_IMG
- en: With `entryconfig`, it is also possible to configure many other options, such
    as the label, font, and background. Refer to [https://www.tcl.tk/man/tcl8.6/TkCmd/menu.htm#M48](https://www.tcl.tk/man/tcl8.6/TkCmd/menu.htm#M48)
    for a complete reference of available entry options.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a secondary window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The root `Tk` instance represents the main window of our GUI—when it is destroyed,
    the application quits and the event mainloop finishes.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is another Tkinter class to create additional top-level windows
    in our application, called `Toplevel`. You can use this class to display any kind
    of window, from custom dialogs to wizard forms.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by creating a simple window that is opened when a button of the
    main window is clicked. It will contain a button that closes it and returns the
    focus to the main window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/f4f3b50d-7dd0-487d-8db4-022b57435aac.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Toplevel` widget class creates a new top-level window, which acts as a
    parent container like the `Tk` instance does. Unlike the `Tk` class, you can instantiate
    as many top-level windows as you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define a `Toplevel` subclass to represent our custom window, whose relationship
    with the parent window is defined in its `__init__` method. Widgets are added
    to this window as usual, since we are following the same conventions as when we
    subclass `Tk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The window is opened by simply creating a new instance, but in order to make
    it receive all the events, we have to call its `grab_set` method. This prevents
    users from interacting with the main window until this one is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Handling window deletion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under some circumstances, you might want to perform an action before the user
    closes a top-level window, for instance, to prevent you losing unsaved work. Tkinter
    allows you to intercept this type of event to conditionally destroy the window.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will reuse the `App` class from the preceding recipe, and we will modify
    the `Window` class so that it shows a dialog to confirm closing the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/4c58c76f-dc88-4947-ba95-45a14f8417e0.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Tkinter, we can detect when a window is about to be closed by registering
    a handler function for the `WM_DELETE_WINDOW` protocol. This can be triggered
    by clicking on the X button of the title bar on most desktop environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Our handler method displays a dialog to confirm window deletion. In more complex
    programs, this logic is usually extended with additional validations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the `bind()` method is used to register handlers for widget events, the
    `protocol` method does the same for window manager protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The `WM_DELETE_WINDOW` handler is called when a top-level window is about to
    be closed, and, by default, `Tk` destroys the window for which it was received.
    Since we are overriding this behavior by registering the `confirm_delete` handler,
    it needs to explicitly destroy the window if the dialog is confirmed.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful protocol is `WM_TAKE_FOCUS`, which is called when a window takes
    the focus.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bear in mind that to keep the focus of the second window when the dialog is
    displayed, we have to pass the reference to the top-level instance, the `parent` option,
    to the dialog function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, the dialog will take the root window as its parent, and you would
    see that it pops over the second window. These quirks may confuse your users,
    so it is a good practice to correctly set the parent of each top-level instance
    or dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Passing variables between windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two different windows may need to share information during program execution.
    While this data might be saved to disk and read from the window that consumes
    it, in some circumstances it is more straightforward to handle it in memory and
    simply pass this information as variables.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main window will contain three radio buttons to select the type of user
    that we want to create, and the secondary window will open the form to fill in
    the user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/4a23ce5f-f29c-4fea-ac85-e96904c0d994.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To hold the user data, we create `namedtuple` with fields that represent each
    user instance. This function from the `collections` module receives the type name
    and a sequence of field names, and returns a tuple subclass to create lightweight
    objects with the given fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the execution flow returns to the main window, the user data is printed
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the code of this recipe have already been covered in other recipes,
    and the main difference is contained in the `open()` method of the `UserForm`
    class, where we moved the call to `grab_set()`. However, the `wait_window()` method
    is what actually stops the execution and prevents us from returning the data before
    the form has been modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is important to remark that `wait_window()` enters a local event loop, which
    finishes when the window is destroyed. Although it is possible to pass the widget
    we want to wait to be removed, we can omit it to implicitly refer to the instance
    that calls this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `UserForm` instance is destroyed, the execution of the `open()` method
    continues, and it returns the `User` object that can now be used in the `App`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
